{
          "0": "    private void encode(final int minOffset) {\n\n        // choose an offset with some margins\n        offset  = minOffset + 31;\n        offset -= offset % 32;\n\n        if ((encoding != null) && (encoding.length == 1) && (encoding[0] == 0x0L)) {\n            // the components are all zeroes\n            return;\n        }\n\n        // allocate an integer array to encode the components (we use only\n        // 63 bits per element because there is no unsigned long in Java)\n        final int neededBits  = offset + 1 - lsb;\n        final int neededLongs = (neededBits + 62) / 63;\n        encoding = new long[components.length * neededLongs];\n\n        // mix the bits from all components\n        int  eIndex = 0;\n        int  shift  = 62;\n        long word   = 0x0L;\n        for (int k = offset; eIndex < encoding.length; --k) {\n            for (int vIndex = 0; vIndex < components.length; ++vIndex) {\n                if (getBit(vIndex, k) != 0) {\nword |= (1 >>> shift);\n                }\n                if (shift-- == 0) {\n                    encoding[eIndex++] = word;\n                    word  = 0x0L;\n                    shift = 62;\n                }\n            }\n        }\n\n    }",
          "1": "    private void encode(final int minOffset) {\n\n        // choose an offset with some margins\n        offset  = minOffset + 31;\n        offset -= offset % 32;\n\n        if ((encoding != null) && (encoding.length == 1) && (encoding[0] == 0x0L)) {\n            // the components are all zeroes\n            return;\n        }\n\n        // allocate an integer array to encode the components (we use only\n        // 63 bits per element because there is no unsigned long in Java)\n        final int neededBits  = offset + 1 - lsb;\n        final int neededLongs = (neededBits + 62) / 63;\n        encoding = new long[components.length * neededLongs];\n\n        // mix the bits from all components\n        int  eIndex = 0;\n        int  shift  = 62;\n        long word   = 0x0L;\n        for (int k = offset; eIndex < encoding.length; --k) {\n            for (int vIndex = 0; vIndex < components.length; ++vIndex) {\n                if (getBit(vIndex, k) != 0) {\nword |= (2 >>> shift);\n                }\n                if (shift-- == 0) {\n                    encoding[eIndex++] = word;\n                    word  = 0x0L;\n                    shift = 62;\n                }\n            }\n        }\n\n    }",
          "2": "    private void encode(final int minOffset) {\n\n        // choose an offset with some margins\n        offset  = minOffset + 31;\n        offset -= offset % 32;\n\n        if ((encoding != null) && (encoding.length == 1) && (encoding[0] == 0x0L)) {\n            // the components are all zeroes\n            return;\n        }\n\n        // allocate an integer array to encode the components (we use only\n        // 63 bits per element because there is no unsigned long in Java)\n        final int neededBits  = offset + 1 - lsb;\n        final int neededLongs = (neededBits + 62) / 63;\n        encoding = new long[components.length * neededLongs];\n\n        // mix the bits from all components\n        int  eIndex = 0;\n        int  shift  = 62;\n        long word   = 0x0L;\n        for (int k = offset; eIndex < encoding.length; --k) {\n            for (int vIndex = 0; vIndex < components.length; ++vIndex) {\n                if (getBit(vIndex, k) != 0) {\nword += (1L >>> shift);\n                }\n                if (shift-- == 0) {\n                    encoding[eIndex++] = word;\n                    word  = 0x0L;\n                    shift = 62;\n                }\n            }\n        }\n\n    }",
          "3": "    private void encode(final int minOffset) {\n\n        // choose an offset with some margins\n        offset  = minOffset + 31;\n        offset -= offset % 32;\n\n        if ((encoding != null) && (encoding.length == 1) && (encoding[0] == 0x0L)) {\n            // the components are all zeroes\n            return;\n        }\n\n        // allocate an integer array to encode the components (we use only\n        // 63 bits per element because there is no unsigned long in Java)\n        final int neededBits  = offset + 1 - lsb;\n        final int neededLongs = (neededBits + 62) / 63;\n        encoding = new long[components.length * neededLongs];\n\n        // mix the bits from all components\n        int  eIndex = 0;\n        int  shift  = 62;\n        long word   = 0x0L;\n        for (int k = offset; eIndex < encoding.length; --k) {\n            for (int vIndex = 0; vIndex < components.length; ++vIndex) {\n                if (getBit(vIndex, k) != 0) {\nword |= (1L >>> shift);\n                }\n                if (shift-- == 0) {\n                    encoding[eIndex++] = word;\n                    word  = 0x0L;\n                    shift = 62;\n                }\n            }\n        }\n\n    }",
          "4": "    private void encode(final int minOffset) {\n\n        // choose an offset with some margins\n        offset  = minOffset + 31;\n        offset -= offset % 32;\n\n        if ((encoding != null) && (encoding.length == 1) && (encoding[0] == 0x0L)) {\n            // the components are all zeroes\n            return;\n        }\n\n        // allocate an integer array to encode the components (we use only\n        // 63 bits per element because there is no unsigned long in Java)\n        final int neededBits  = offset + 1 - lsb;\n        final int neededLongs = (neededBits + 62) / 63;\n        encoding = new long[components.length * neededLongs];\n\n        // mix the bits from all components\n        int  eIndex = 0;\n        int  shift  = 62;\n        long word   = 0x0L;\n        for (int k = offset; eIndex < encoding.length; --k) {\n            for (int vIndex = 0; vIndex < components.length; ++vIndex) {\n                if (getBit(vIndex, k) != 0) {\nword |= (0x0L >>> shift);\n                }\n                if (shift-- == 0) {\n                    encoding[eIndex++] = word;\n                    word  = 0x0L;\n                    shift = 62;\n                }\n            }\n        }\n\n    }",
          "5": "    private void encode(final int minOffset) {\n\n        // choose an offset with some margins\n        offset  = minOffset + 31;\n        offset -= offset % 32;\n\n        if ((encoding != null) && (encoding.length == 1) && (encoding[0] == 0x0L)) {\n            // the components are all zeroes\n            return;\n        }\n\n        // allocate an integer array to encode the components (we use only\n        // 63 bits per element because there is no unsigned long in Java)\n        final int neededBits  = offset + 1 - lsb;\n        final int neededLongs = (neededBits + 62) / 63;\n        encoding = new long[components.length * neededLongs];\n\n        // mix the bits from all components\n        int  eIndex = 0;\n        int  shift  = 62;\n        long word   = 0x0L;\n        for (int k = offset; eIndex < encoding.length; --k) {\n            for (int vIndex = 0; vIndex < components.length; ++vIndex) {\n                if (getBit(vIndex, k) != 0) {\nword |= (62 >>> shift);\n                }\n                if (shift-- == 0) {\n                    encoding[eIndex++] = word;\n                    word  = 0x0L;\n                    shift = 62;\n                }\n            }\n        }\n\n    }",
          "6": "    private void encode(final int minOffset) {\n\n        // choose an offset with some margins\n        offset  = minOffset + 31;\n        offset -= offset % 32;\n\n        if ((encoding != null) && (encoding.length == 1) && (encoding[0] == 0x0L)) {\n            // the components are all zeroes\n            return;\n        }\n\n        // allocate an integer array to encode the components (we use only\n        // 63 bits per element because there is no unsigned long in Java)\n        final int neededBits  = offset + 1 - lsb;\n        final int neededLongs = (neededBits + 62) / 63;\n        encoding = new long[components.length * neededLongs];\n\n        // mix the bits from all components\n        int  eIndex = 0;\n        int  shift  = 62;\n        long word   = 0x0L;\n        for (int k = offset; eIndex < encoding.length; --k) {\n            for (int vIndex = 0; vIndex < components.length; ++vIndex) {\n                if (getBit(vIndex, k) != 0) {\n                }\n                if (shift-- == 0) {\n                    encoding[eIndex++] = word;\n                    word  = 0x0L;\n                    shift = 62;\n                }\n            }\n        }\n\n    }",
          "7": "    private void encode(final int minOffset) {\n\n        // choose an offset with some margins\n        offset  = minOffset + 31;\n        offset -= offset % 32;\n\n        if ((encoding != null) && (encoding.length == 1) && (encoding[0] == 0x0L)) {\n            // the components are all zeroes\n            return;\n        }\n\n        // allocate an integer array to encode the components (we use only\n        // 63 bits per element because there is no unsigned long in Java)\n        final int neededBits  = offset + 1 - lsb;\n        final int neededLongs = (neededBits + 62) / 63;\n        encoding = new long[components.length * neededLongs];\n\n        // mix the bits from all components\n        int  eIndex = 0;\n        int  shift  = 62;\n        long word   = 0x0L;\n        for (int k = offset; eIndex < encoding.length; --k) {\n            for (int vIndex = 0; vIndex < components.length; ++vIndex) {\n                if (getBit(vIndex, k) != 0) {\nword |= (1L >>> k);\n                }\n                if (shift-- == 0) {\n                    encoding[eIndex++] = word;\n                    word  = 0x0L;\n                    shift = 62;\n                }\n            }\n        }\n\n    }",
          "8": "    private void encode(final int minOffset) {\n\n        // choose an offset with some margins\n        offset  = minOffset + 31;\n        offset -= offset % 32;\n\n        if ((encoding != null) && (encoding.length == 1) && (encoding[0] == 0x0L)) {\n            // the components are all zeroes\n            return;\n        }\n\n        // allocate an integer array to encode the components (we use only\n        // 63 bits per element because there is no unsigned long in Java)\n        final int neededBits  = offset + 1 - lsb;\n        final int neededLongs = (neededBits + 62) / 63;\n        encoding = new long[components.length * neededLongs];\n\n        // mix the bits from all components\n        int  eIndex = 0;\n        int  shift  = 62;\n        long word   = 0x0L;\n        for (int k = offset; eIndex < encoding.length; --k) {\n            for (int vIndex = 0; vIndex < components.length; ++vIndex) {\n                if (getBit(vIndex, k) != 0) {\nword -= (1L >>> shift);\n                }\n                if (shift-- == 0) {\n                    encoding[eIndex++] = word;\n                    word  = 0x0L;\n                    shift = 62;\n                }\n            }\n        }\n\n    }",
          "9": "    private void encode(final int minOffset) {\n\n        // choose an offset with some margins\n        offset  = minOffset + 31;\n        offset -= offset % 32;\n\n        if ((encoding != null) && (encoding.length == 1) && (encoding[0] == 0x0L)) {\n            // the components are all zeroes\n            return;\n        }\n\n        // allocate an integer array to encode the components (we use only\n        // 63 bits per element because there is no unsigned long in Java)\n        final int neededBits  = offset + 1 - lsb;\n        final int neededLongs = (neededBits + 62) / 63;\n        encoding = new long[components.length * neededLongs];\n\n        // mix the bits from all components\n        int  eIndex = 0;\n        int  shift  = 62;\n        long word   = 0x0L;\n        for (int k = offset; eIndex < encoding.length; --k) {\n            for (int vIndex = 0; vIndex < components.length; ++vIndex) {\n                if (getBit(vIndex, k) != 0) {\nword |= (1L >>> vIndex);\n                }\n                if (shift-- == 0) {\n                    encoding[eIndex++] = word;\n                    word  = 0x0L;\n                    shift = 62;\n                }\n            }\n        }\n\n    }",
          "10": "    private void encode(final int minOffset) {\n\n        // choose an offset with some margins\n        offset  = minOffset + 31;\n        offset -= offset % 32;\n\n        if ((encoding != null) && (encoding.length == 1) && (encoding[0] == 0x0L)) {\n            // the components are all zeroes\n            return;\n        }\n\n        // allocate an integer array to encode the components (we use only\n        // 63 bits per element because there is no unsigned long in Java)\n        final int neededBits  = offset + 1 - lsb;\n        final int neededLongs = (neededBits + 62) / 63;\n        encoding = new long[components.length * neededLongs];\n\n        // mix the bits from all components\n        int  eIndex = 0;\n        int  shift  = 62;\n        long word   = 0x0L;\n        for (int k = offset; eIndex < encoding.length; --k) {\n            for (int vIndex = 0; vIndex < components.length; ++vIndex) {\n                if (getBit(vIndex, k) != 0) {\nshift |= (1L >>> shift);\n                }\n                if (shift-- == 0) {\n                    encoding[eIndex++] = word;\n                    word  = 0x0L;\n                    shift = 62;\n                }\n            }\n        }\n\n    }",
          "11": "    private void encode(final int minOffset) {\n\n        // choose an offset with some margins\n        offset  = minOffset + 31;\n        offset -= offset % 32;\n\n        if ((encoding != null) && (encoding.length == 1) && (encoding[0] == 0x0L)) {\n            // the components are all zeroes\n            return;\n        }\n\n        // allocate an integer array to encode the components (we use only\n        // 63 bits per element because there is no unsigned long in Java)\n        final int neededBits  = offset + 1 - lsb;\n        final int neededLongs = (neededBits + 62) / 63;\n        encoding = new long[components.length * neededLongs];\n\n        // mix the bits from all components\n        int  eIndex = 0;\n        int  shift  = 62;\n        long word   = 0x0L;\n        for (int k = offset; eIndex < encoding.length; --k) {\n            for (int vIndex = 0; vIndex < components.length; ++vIndex) {\n                if (getBit(vIndex, k) != 0) {\nk |= (1L >>> shift);\n                }\n                if (shift-- == 0) {\n                    encoding[eIndex++] = word;\n                    word  = 0x0L;\n                    shift = 62;\n                }\n            }\n        }\n\n    }",
          "12": "    private void encode(final int minOffset) {\n\n        // choose an offset with some margins\n        offset  = minOffset + 31;\n        offset -= offset % 32;\n\n        if ((encoding != null) && (encoding.length == 1) && (encoding[0] == 0x0L)) {\n            // the components are all zeroes\n            return;\n        }\n\n        // allocate an integer array to encode the components (we use only\n        // 63 bits per element because there is no unsigned long in Java)\n        final int neededBits  = offset + 1 - lsb;\n        final int neededLongs = (neededBits + 62) / 63;\n        encoding = new long[components.length * neededLongs];\n\n        // mix the bits from all components\n        int  eIndex = 0;\n        int  shift  = 62;\n        long word   = 0x0L;\n        for (int k = offset; eIndex < encoding.length; --k) {\n            for (int vIndex = 0; vIndex < components.length; ++vIndex) {\n                if (getBit(vIndex, k) != 0) {\nword &= (1L >>> shift);\n                }\n                if (shift-- == 0) {\n                    encoding[eIndex++] = word;\n                    word  = 0x0L;\n                    shift = 62;\n                }\n            }\n        }\n\n    }",
          "13": "    private void encode(final int minOffset) {\n\n        // choose an offset with some margins\n        offset  = minOffset + 31;\n        offset -= offset % 32;\n\n        if ((encoding != null) && (encoding.length == 1) && (encoding[0] == 0x0L)) {\n            // the components are all zeroes\n            return;\n        }\n\n        // allocate an integer array to encode the components (we use only\n        // 63 bits per element because there is no unsigned long in Java)\n        final int neededBits  = offset + 1 - lsb;\n        final int neededLongs = (neededBits + 62) / 63;\n        encoding = new long[components.length * neededLongs];\n\n        // mix the bits from all components\n        int  eIndex = 0;\n        int  shift  = 62;\n        long word   = 0x0L;\n        for (int k = offset; eIndex < encoding.length; --k) {\n            for (int vIndex = 0; vIndex < components.length; ++vIndex) {\n                if (getBit(vIndex, k) != 0) {\nword = (1L >>> shift);\n                }\n                if (shift-- == 0) {\n                    encoding[eIndex++] = word;\n                    word  = 0x0L;\n                    shift = 62;\n                }\n            }\n        }\n\n    }",
          "14": "    private void encode(final int minOffset) {\n\n        // choose an offset with some margins\n        offset  = minOffset + 31;\n        offset -= offset % 32;\n\n        if ((encoding != null) && (encoding.length == 1) && (encoding[0] == 0x0L)) {\n            // the components are all zeroes\n            return;\n        }\n\n        // allocate an integer array to encode the components (we use only\n        // 63 bits per element because there is no unsigned long in Java)\n        final int neededBits  = offset + 1 - lsb;\n        final int neededLongs = (neededBits + 62) / 63;\n        encoding = new long[components.length * neededLongs];\n\n        // mix the bits from all components\n        int  eIndex = 0;\n        int  shift  = 62;\n        long word   = 0x0L;\n        for (int k = offset; eIndex < encoding.length; --k) {\n            for (int vIndex = 0; vIndex < components.length; ++vIndex) {\n                if (getBit(vIndex, k) != 0) {\nword |= (1L >>> encoding);\n                }\n                if (shift-- == 0) {\n                    encoding[eIndex++] = word;\n                    word  = 0x0L;\n                    shift = 62;\n                }\n            }\n        }\n\n    }",
          "15": "    private void encode(final int minOffset) {\n\n        // choose an offset with some margins\n        offset  = minOffset + 31;\n        offset -= offset % 32;\n\n        if ((encoding != null) && (encoding.length == 1) && (encoding[0] == 0x0L)) {\n            // the components are all zeroes\n            return;\n        }\n\n        // allocate an integer array to encode the components (we use only\n        // 63 bits per element because there is no unsigned long in Java)\n        final int neededBits  = offset + 1 - lsb;\n        final int neededLongs = (neededBits + 62) / 63;\n        encoding = new long[components.length * neededLongs];\n\n        // mix the bits from all components\n        int  eIndex = 0;\n        int  shift  = 62;\n        long word   = 0x0L;\n        for (int k = offset; eIndex < encoding.length; --k) {\n            for (int vIndex = 0; vIndex < components.length; ++vIndex) {\n                if (getBit(vIndex, k) != 0) {\nword = 0x0L;\n                    word |= 1L >>> shift;                }\n                if (shift-- == 0) {\n                    encoding[eIndex++] = word;\n                    word  = 0x0L;\n                    shift = 62;\n                }\n            }\n        }\n\n    }",
          "16": "    private void encode(final int minOffset) {\n\n        // choose an offset with some margins\n        offset  = minOffset + 31;\n        offset -= offset % 32;\n\n        if ((encoding != null) && (encoding.length == 1) && (encoding[0] == 0x0L)) {\n            // the components are all zeroes\n            return;\n        }\n\n        // allocate an integer array to encode the components (we use only\n        // 63 bits per element because there is no unsigned long in Java)\n        final int neededBits  = offset + 1 - lsb;\n        final int neededLongs = (neededBits + 62) / 63;\n        encoding = new long[components.length * neededLongs];\n\n        // mix the bits from all components\n        int  eIndex = 0;\n        int  shift  = 62;\n        long word   = 0x0L;\n        for (int k = offset; eIndex < encoding.length; --k) {\n            for (int vIndex = 0; vIndex < components.length; ++vIndex) {\n                if (getBit(vIndex, k) != 0) {\nshift = 62;\n}\n                    word |= 1L >>> shift;                }\n                if (shift-- == 0) {\n                    encoding[eIndex++] = word;\n                    word  = 0x0L;\n                    shift = 62;\n                }\n            }\n        }\n\n    }",
          "17": "    private void encode(final int minOffset) {\n\n        // choose an offset with some margins\n        offset  = minOffset + 31;\n        offset -= offset % 32;\n\n        if ((encoding != null) && (encoding.length == 1) && (encoding[0] == 0x0L)) {\n            // the components are all zeroes\n            return;\n        }\n\n        // allocate an integer array to encode the components (we use only\n        // 63 bits per element because there is no unsigned long in Java)\n        final int neededBits  = offset + 1 - lsb;\n        final int neededLongs = (neededBits + 62) / 63;\n        encoding = new long[components.length * neededLongs];\n\n        // mix the bits from all components\n        int  eIndex = 0;\n        int  shift  = 62;\n        long word   = 0x0L;\n        for (int k = offset; eIndex < encoding.length; --k) {\n            for (int vIndex = 0; vIndex < components.length; ++vIndex) {\n                if (getBit(vIndex, k) != 0) {\nvIndex |= (1L >>> shift);\n                }\n                if (shift-- == 0) {\n                    encoding[eIndex++] = word;\n                    word  = 0x0L;\n                    shift = 62;\n                }\n            }\n        }\n\n    }",
          "18": "    private void encode(final int minOffset) {\n\n        // choose an offset with some margins\n        offset  = minOffset + 31;\n        offset -= offset % 32;\n\n        if ((encoding != null) && (encoding.length == 1) && (encoding[0] == 0x0L)) {\n            // the components are all zeroes\n            return;\n        }\n\n        // allocate an integer array to encode the components (we use only\n        // 63 bits per element because there is no unsigned long in Java)\n        final int neededBits  = offset + 1 - lsb;\n        final int neededLongs = (neededBits + 62) / 63;\n        encoding = new long[components.length * neededLongs];\n\n        // mix the bits from all components\n        int  eIndex = 0;\n        int  shift  = 62;\n        long word   = 0x0L;\n        for (int k = offset; eIndex < encoding.length; --k) {\n            for (int vIndex = 0; vIndex < components.length; ++vIndex) {\n                if (getBit(vIndex, k) != 0) {\nencoding[eIndex++] = word;\n                    word |= 1L >>> shift;                }\n                if (shift-- == 0) {\n                    encoding[eIndex++] = word;\n                    word  = 0x0L;\n                    shift = 62;\n                }\n            }\n        }\n\n    }",
          "19": "    private void encode(final int minOffset) {\n\n        // choose an offset with some margins\n        offset  = minOffset + 31;\n        offset -= offset % 32;\n\n        if ((encoding != null) && (encoding.length == 1) && (encoding[0] == 0x0L)) {\n            // the components are all zeroes\n            return;\n        }\n\n        // allocate an integer array to encode the components (we use only\n        // 63 bits per element because there is no unsigned long in Java)\n        final int neededBits  = offset + 1 - lsb;\n        final int neededLongs = (neededBits + 62) / 63;\n        encoding = new long[components.length * neededLongs];\n\n        // mix the bits from all components\n        int  eIndex = 0;\n        int  shift  = 62;\n        long word   = 0x0L;\n        for (int k = offset; eIndex < encoding.length; --k) {\n            for (int vIndex = 0; vIndex < components.length; ++vIndex) {\n                if (getBit(vIndex, k) != 0) {\nword |= (1L >>> word);\n                }\n                if (shift-- == 0) {\n                    encoding[eIndex++] = word;\n                    word  = 0x0L;\n                    shift = 62;\n                }\n            }\n        }\n\n    }",
          "20": "    private void encode(final int minOffset) {\n\n        // choose an offset with some margins\n        offset  = minOffset + 31;\n        offset -= offset % 32;\n\n        if ((encoding != null) && (encoding.length == 1) && (encoding[0] == 0x0L)) {\n            // the components are all zeroes\n            return;\n        }\n\n        // allocate an integer array to encode the components (we use only\n        // 63 bits per element because there is no unsigned long in Java)\n        final int neededBits  = offset + 1 - lsb;\n        final int neededLongs = (neededBits + 62) / 63;\n        encoding = new long[components.length * neededLongs];\n\n        // mix the bits from all components\n        int  eIndex = 0;\n        int  shift  = 62;\n        long word   = 0x0L;\n        for (int k = offset; eIndex < encoding.length; --k) {\n            for (int vIndex = 0; vIndex < components.length; ++vIndex) {\n                if (getBit(vIndex, k) != 0) {\nreturn;\n                    word |= 1L >>> shift;                }\n                if (shift-- == 0) {\n                    encoding[eIndex++] = word;\n                    word  = 0x0L;\n                    shift = 62;\n                }\n            }\n        }\n\n    }",
          "21": "    private void encode(final int minOffset) {\n\n        // choose an offset with some margins\n        offset  = minOffset + 31;\n        offset -= offset % 32;\n\n        if ((encoding != null) && (encoding.length == 1) && (encoding[0] == 0x0L)) {\n            // the components are all zeroes\n            return;\n        }\n\n        // allocate an integer array to encode the components (we use only\n        // 63 bits per element because there is no unsigned long in Java)\n        final int neededBits  = offset + 1 - lsb;\n        final int neededLongs = (neededBits + 62) / 63;\n        encoding = new long[components.length * neededLongs];\n\n        // mix the bits from all components\n        int  eIndex = 0;\n        int  shift  = 62;\n        long word   = 0x0L;\n        for (int k = offset; eIndex < encoding.length; --k) {\n            for (int vIndex = 0; vIndex < components.length; ++vIndex) {\n                if (getBit(vIndex, k) != 0) {\nencoding = new long[(components.length * neededLongs)];\n                    word |= 1L >>> shift;                }\n                if (shift-- == 0) {\n                    encoding[eIndex++] = word;\n                    word  = 0x0L;\n                    shift = 62;\n                }\n            }\n        }\n\n    }",
          "22": "    private void encode(final int minOffset) {\n\n        // choose an offset with some margins\n        offset  = minOffset + 31;\n        offset -= offset % 32;\n\n        if ((encoding != null) && (encoding.length == 1) && (encoding[0] == 0x0L)) {\n            // the components are all zeroes\n            return;\n        }\n\n        // allocate an integer array to encode the components (we use only\n        // 63 bits per element because there is no unsigned long in Java)\n        final int neededBits  = offset + 1 - lsb;\n        final int neededLongs = (neededBits + 62) / 63;\n        encoding = new long[components.length * neededLongs];\n\n        // mix the bits from all components\n        int  eIndex = 0;\n        int  shift  = 62;\n        long word   = 0x0L;\n        for (int k = offset; eIndex < encoding.length; --k) {\n            for (int vIndex = 0; vIndex < components.length; ++vIndex) {\n                if (getBit(vIndex, k) != 0) {\nword *= (1L >>> shift);\n                }\n                if (shift-- == 0) {\n                    encoding[eIndex++] = word;\n                    word  = 0x0L;\n                    shift = 62;\n                }\n            }\n        }\n\n    }",
          "23": "    private void encode(final int minOffset) {\n\n        // choose an offset with some margins\n        offset  = minOffset + 31;\n        offset -= offset % 32;\n\n        if ((encoding != null) && (encoding.length == 1) && (encoding[0] == 0x0L)) {\n            // the components are all zeroes\n            return;\n        }\n\n        // allocate an integer array to encode the components (we use only\n        // 63 bits per element because there is no unsigned long in Java)\n        final int neededBits  = offset + 1 - lsb;\n        final int neededLongs = (neededBits + 62) / 63;\n        encoding = new long[components.length * neededLongs];\n\n        // mix the bits from all components\n        int  eIndex = 0;\n        int  shift  = 62;\n        long word   = 0x0L;\n        for (int k = offset; eIndex < encoding.length; --k) {\n            for (int vIndex = 0; vIndex < components.length; ++vIndex) {\n                if (getBit(vIndex, k) != 0) {\nword |= (1L - shift);\n                }\n                if (shift-- == 0) {\n                    encoding[eIndex++] = word;\n                    word  = 0x0L;\n                    shift = 62;\n                }\n            }\n        }\n\n    }",
          "24": "    private void encode(final int minOffset) {\n\n        // choose an offset with some margins\n        offset  = minOffset + 31;\n        offset -= offset % 32;\n\n        if ((encoding != null) && (encoding.length == 1) && (encoding[0] == 0x0L)) {\n            // the components are all zeroes\n            return;\n        }\n\n        // allocate an integer array to encode the components (we use only\n        // 63 bits per element because there is no unsigned long in Java)\n        final int neededBits  = offset + 1 - lsb;\n        final int neededLongs = (neededBits + 62) / 63;\n        encoding = new long[components.length * neededLongs];\n\n        // mix the bits from all components\n        int  eIndex = 0;\n        int  shift  = 62;\n        long word   = 0x0L;\n        for (int k = offset; eIndex < encoding.length; --k) {\n            for (int vIndex = 0; vIndex < components.length; ++vIndex) {\n                if (getBit(vIndex, k) != 0) {\nword |= (-1 >>> shift);\n                }\n                if (shift-- == 0) {\n                    encoding[eIndex++] = word;\n                    word  = 0x0L;\n                    shift = 62;\n                }\n            }\n        }\n\n    }",
          "25": "    private void encode(final int minOffset) {\n\n        // choose an offset with some margins\n        offset  = minOffset + 31;\n        offset -= offset % 32;\n\n        if ((encoding != null) && (encoding.length == 1) && (encoding[0] == 0x0L)) {\n            // the components are all zeroes\n            return;\n        }\n\n        // allocate an integer array to encode the components (we use only\n        // 63 bits per element because there is no unsigned long in Java)\n        final int neededBits  = offset + 1 - lsb;\n        final int neededLongs = (neededBits + 62) / 63;\n        encoding = new long[components.length * neededLongs];\n\n        // mix the bits from all components\n        int  eIndex = 0;\n        int  shift  = 62;\n        long word   = 0x0L;\n        for (int k = offset; eIndex < encoding.length; --k) {\n            for (int vIndex = 0; vIndex < components.length; ++vIndex) {\n                if (getBit(vIndex, k) != 0) {\nbreak;\n                    word |= 1L >>> shift;                }\n                if (shift-- == 0) {\n                    encoding[eIndex++] = word;\n                    word  = 0x0L;\n                    shift = 62;\n                }\n            }\n        }\n\n    }",
          "26": "    private void encode(final int minOffset) {\n\n        // choose an offset with some margins\n        offset  = minOffset + 31;\n        offset -= offset % 32;\n\n        if ((encoding != null) && (encoding.length == 1) && (encoding[0] == 0x0L)) {\n            // the components are all zeroes\n            return;\n        }\n\n        // allocate an integer array to encode the components (we use only\n        // 63 bits per element because there is no unsigned long in Java)\n        final int neededBits  = offset + 1 - lsb;\n        final int neededLongs = (neededBits + 62) / 63;\n        encoding = new long[components.length * neededLongs];\n\n        // mix the bits from all components\n        int  eIndex = 0;\n        int  shift  = 62;\n        long word   = 0x0L;\n        for (int k = offset; eIndex < encoding.length; --k) {\n            for (int vIndex = 0; vIndex < components.length; ++vIndex) {\n                if (getBit(vIndex, k) != 0) {\nword |= (1L >>> offset);\n                }\n                if (shift-- == 0) {\n                    encoding[eIndex++] = word;\n                    word  = 0x0L;\n                    shift = 62;\n                }\n            }\n        }\n\n    }",
          "27": "    private void encode(final int minOffset) {\n\n        // choose an offset with some margins\n        offset  = minOffset + 31;\n        offset -= offset % 32;\n\n        if ((encoding != null) && (encoding.length == 1) && (encoding[0] == 0x0L)) {\n            // the components are all zeroes\n            return;\n        }\n\n        // allocate an integer array to encode the components (we use only\n        // 63 bits per element because there is no unsigned long in Java)\n        final int neededBits  = offset + 1 - lsb;\n        final int neededLongs = (neededBits + 62) / 63;\n        encoding = new long[components.length * neededLongs];\n\n        // mix the bits from all components\n        int  eIndex = 0;\n        int  shift  = 62;\n        long word   = 0x0L;\n        for (int k = offset; eIndex < encoding.length; --k) {\n            for (int vIndex = 0; vIndex < components.length; ++vIndex) {\n                if (getBit(vIndex, k) != 0) {\nencoding |= (1L >>> shift);\n                }\n                if (shift-- == 0) {\n                    encoding[eIndex++] = word;\n                    word  = 0x0L;\n                    shift = 62;\n                }\n            }\n        }\n\n    }",
          "28": "    private void encode(final int minOffset) {\n\n        // choose an offset with some margins\n        offset  = minOffset + 31;\n        offset -= offset % 32;\n\n        if ((encoding != null) && (encoding.length == 1) && (encoding[0] == 0x0L)) {\n            // the components are all zeroes\n            return;\n        }\n\n        // allocate an integer array to encode the components (we use only\n        // 63 bits per element because there is no unsigned long in Java)\n        final int neededBits  = offset + 1 - lsb;\n        final int neededLongs = (neededBits + 62) / 63;\n        encoding = new long[components.length * neededLongs];\n\n        // mix the bits from all components\n        int  eIndex = 0;\n        int  shift  = 62;\n        long word   = 0x0L;\n        for (int k = offset; eIndex < encoding.length; --k) {\n            for (int vIndex = 0; vIndex < components.length; ++vIndex) {\n                if (getBit(vIndex, k) != 0) {\nif((getBit(vIndex, k) != 0)){\n}\n                    word |= 1L >>> shift;                }\n                if (shift-- == 0) {\n                    encoding[eIndex++] = word;\n                    word  = 0x0L;\n                    shift = 62;\n                }\n            }\n        }\n\n    }",
          "29": "    private void encode(final int minOffset) {\n\n        // choose an offset with some margins\n        offset  = minOffset + 31;\n        offset -= offset % 32;\n\n        if ((encoding != null) && (encoding.length == 1) && (encoding[0] == 0x0L)) {\n            // the components are all zeroes\n            return;\n        }\n\n        // allocate an integer array to encode the components (we use only\n        // 63 bits per element because there is no unsigned long in Java)\n        final int neededBits  = offset + 1 - lsb;\n        final int neededLongs = (neededBits + 62) / 63;\n        encoding = new long[components.length * neededLongs];\n\n        // mix the bits from all components\n        int  eIndex = 0;\n        int  shift  = 62;\n        long word   = 0x0L;\n        for (int k = offset; eIndex < encoding.length; --k) {\n            for (int vIndex = 0; vIndex < components.length; ++vIndex) {\n                if (getBit(vIndex, k) != 0) {\nword |= (false >>> shift);\n                }\n                if (shift-- == 0) {\n                    encoding[eIndex++] = word;\n                    word  = 0x0L;\n                    shift = 62;\n                }\n            }\n        }\n\n    }",
          "30": "    private void encode(final int minOffset) {\n\n        // choose an offset with some margins\n        offset  = minOffset + 31;\n        offset -= offset % 32;\n\n        if ((encoding != null) && (encoding.length == 1) && (encoding[0] == 0x0L)) {\n            // the components are all zeroes\n            return;\n        }\n\n        // allocate an integer array to encode the components (we use only\n        // 63 bits per element because there is no unsigned long in Java)\n        final int neededBits  = offset + 1 - lsb;\n        final int neededLongs = (neededBits + 62) / 63;\n        encoding = new long[components.length * neededLongs];\n\n        // mix the bits from all components\n        int  eIndex = 0;\n        int  shift  = 62;\n        long word   = 0x0L;\n        for (int k = offset; eIndex < encoding.length; --k) {\n            for (int vIndex = 0; vIndex < components.length; ++vIndex) {\n                if (getBit(vIndex, k) != 0) {\nword |= (null >>> shift);\n                }\n                if (shift-- == 0) {\n                    encoding[eIndex++] = word;\n                    word  = 0x0L;\n                    shift = 62;\n                }\n            }\n        }\n\n    }",
          "31": "    private void encode(final int minOffset) {\n\n        // choose an offset with some margins\n        offset  = minOffset + 31;\n        offset -= offset % 32;\n\n        if ((encoding != null) && (encoding.length == 1) && (encoding[0] == 0x0L)) {\n            // the components are all zeroes\n            return;\n        }\n\n        // allocate an integer array to encode the components (we use only\n        // 63 bits per element because there is no unsigned long in Java)\n        final int neededBits  = offset + 1 - lsb;\n        final int neededLongs = (neededBits + 62) / 63;\n        encoding = new long[components.length * neededLongs];\n\n        // mix the bits from all components\n        int  eIndex = 0;\n        int  shift  = 62;\n        long word   = 0x0L;\n        for (int k = offset; eIndex < encoding.length; --k) {\n            for (int vIndex = 0; vIndex < components.length; ++vIndex) {\n                if (getBit(vIndex, k) != 0) {\nword += word;\n                }\n                if (shift-- == 0) {\n                    encoding[eIndex++] = word;\n                    word  = 0x0L;\n                    shift = 62;\n                }\n            }\n        }\n\n    }",
          "32": "    private void encode(final int minOffset) {\n\n        // choose an offset with some margins\n        offset  = minOffset + 31;\n        offset -= offset % 32;\n\n        if ((encoding != null) && (encoding.length == 1) && (encoding[0] == 0x0L)) {\n            // the components are all zeroes\n            return;\n        }\n\n        // allocate an integer array to encode the components (we use only\n        // 63 bits per element because there is no unsigned long in Java)\n        final int neededBits  = offset + 1 - lsb;\n        final int neededLongs = (neededBits + 62) / 63;\n        encoding = new long[components.length * neededLongs];\n\n        // mix the bits from all components\n        int  eIndex = 0;\n        int  shift  = 62;\n        long word   = 0x0L;\n        for (int k = offset; eIndex < encoding.length; --k) {\n            for (int vIndex = 0; vIndex < components.length; ++vIndex) {\n                if (getBit(vIndex, k) != 0) {\nword |= (1L >>> eIndex);\n                }\n                if (shift-- == 0) {\n                    encoding[eIndex++] = word;\n                    word  = 0x0L;\n                    shift = 62;\n                }\n            }\n        }\n\n    }",
          "33": "    private void encode(final int minOffset) {\n\n        // choose an offset with some margins\n        offset  = minOffset + 31;\n        offset -= offset % 32;\n\n        if ((encoding != null) && (encoding.length == 1) && (encoding[0] == 0x0L)) {\n            // the components are all zeroes\n            return;\n        }\n\n        // allocate an integer array to encode the components (we use only\n        // 63 bits per element because there is no unsigned long in Java)\n        final int neededBits  = offset + 1 - lsb;\n        final int neededLongs = (neededBits + 62) / 63;\n        encoding = new long[components.length * neededLongs];\n\n        // mix the bits from all components\n        int  eIndex = 0;\n        int  shift  = 62;\n        long word   = 0x0L;\n        for (int k = offset; eIndex < encoding.length; --k) {\n            for (int vIndex = 0; vIndex < components.length; ++vIndex) {\n                if (getBit(vIndex, k) != 0) {\nword |= (63 >>> shift);\n                }\n                if (shift-- == 0) {\n                    encoding[eIndex++] = word;\n                    word  = 0x0L;\n                    shift = 62;\n                }\n            }\n        }\n\n    }",
          "34": "    private void encode(final int minOffset) {\n\n        // choose an offset with some margins\n        offset  = minOffset + 31;\n        offset -= offset % 32;\n\n        if ((encoding != null) && (encoding.length == 1) && (encoding[0] == 0x0L)) {\n            // the components are all zeroes\n            return;\n        }\n\n        // allocate an integer array to encode the components (we use only\n        // 63 bits per element because there is no unsigned long in Java)\n        final int neededBits  = offset + 1 - lsb;\n        final int neededLongs = (neededBits + 62) / 63;\n        encoding = new long[components.length * neededLongs];\n\n        // mix the bits from all components\n        int  eIndex = 0;\n        int  shift  = 62;\n        long word   = 0x0L;\n        for (int k = offset; eIndex < encoding.length; --k) {\n            for (int vIndex = 0; vIndex < components.length; ++vIndex) {\n                if (getBit(vIndex, k) != 0) {\nword |= (1L <= shift);\n                }\n                if (shift-- == 0) {\n                    encoding[eIndex++] = word;\n                    word  = 0x0L;\n                    shift = 62;\n                }\n            }\n        }\n\n    }",
          "35": "    private void encode(final int minOffset) {\n\n        // choose an offset with some margins\n        offset  = minOffset + 31;\n        offset -= offset % 32;\n\n        if ((encoding != null) && (encoding.length == 1) && (encoding[0] == 0x0L)) {\n            // the components are all zeroes\n            return;\n        }\n\n        // allocate an integer array to encode the components (we use only\n        // 63 bits per element because there is no unsigned long in Java)\n        final int neededBits  = offset + 1 - lsb;\n        final int neededLongs = (neededBits + 62) / 63;\n        encoding = new long[components.length * neededLongs];\n\n        // mix the bits from all components\n        int  eIndex = 0;\n        int  shift  = 62;\n        long word   = 0x0L;\n        for (int k = offset; eIndex < encoding.length; --k) {\n            for (int vIndex = 0; vIndex < components.length; ++vIndex) {\n                if (getBit(vIndex, k) != 0) {\noffset |= (1L >>> shift);\n                }\n                if (shift-- == 0) {\n                    encoding[eIndex++] = word;\n                    word  = 0x0L;\n                    shift = 62;\n                }\n            }\n        }\n\n    }",
          "36": "    private void encode(final int minOffset) {\n\n        // choose an offset with some margins\n        offset  = minOffset + 31;\n        offset -= offset % 32;\n\n        if ((encoding != null) && (encoding.length == 1) && (encoding[0] == 0x0L)) {\n            // the components are all zeroes\n            return;\n        }\n\n        // allocate an integer array to encode the components (we use only\n        // 63 bits per element because there is no unsigned long in Java)\n        final int neededBits  = offset + 1 - lsb;\n        final int neededLongs = (neededBits + 62) / 63;\n        encoding = new long[components.length * neededLongs];\n\n        // mix the bits from all components\n        int  eIndex = 0;\n        int  shift  = 62;\n        long word   = 0x0L;\n        for (int k = offset; eIndex < encoding.length; --k) {\n            for (int vIndex = 0; vIndex < components.length; ++vIndex) {\n                if (getBit(vIndex, k) != 0) {\nword |= (true >>> shift);\n                }\n                if (shift-- == 0) {\n                    encoding[eIndex++] = word;\n                    word  = 0x0L;\n                    shift = 62;\n                }\n            }\n        }\n\n    }",
          "37": "    private void encode(final int minOffset) {\n\n        // choose an offset with some margins\n        offset  = minOffset + 31;\n        offset -= offset % 32;\n\n        if ((encoding != null) && (encoding.length == 1) && (encoding[0] == 0x0L)) {\n            // the components are all zeroes\n            return;\n        }\n\n        // allocate an integer array to encode the components (we use only\n        // 63 bits per element because there is no unsigned long in Java)\n        final int neededBits  = offset + 1 - lsb;\n        final int neededLongs = (neededBits + 62) / 63;\n        encoding = new long[components.length * neededLongs];\n\n        // mix the bits from all components\n        int  eIndex = 0;\n        int  shift  = 62;\n        long word   = 0x0L;\n        for (int k = offset; eIndex < encoding.length; --k) {\n            for (int vIndex = 0; vIndex < components.length; ++vIndex) {\n                if (getBit(vIndex, k) != 0) {\noffset -= (offset % 32);\n                    word |= 1L >>> shift;                }\n                if (shift-- == 0) {\n                    encoding[eIndex++] = word;\n                    word  = 0x0L;\n                    shift = 62;\n                }\n            }\n        }\n\n    }",
          "38": "    private void encode(final int minOffset) {\n\n        // choose an offset with some margins\n        offset  = minOffset + 31;\n        offset -= offset % 32;\n\n        if ((encoding != null) && (encoding.length == 1) && (encoding[0] == 0x0L)) {\n            // the components are all zeroes\n            return;\n        }\n\n        // allocate an integer array to encode the components (we use only\n        // 63 bits per element because there is no unsigned long in Java)\n        final int neededBits  = offset + 1 - lsb;\n        final int neededLongs = (neededBits + 62) / 63;\n        encoding = new long[components.length * neededLongs];\n\n        // mix the bits from all components\n        int  eIndex = 0;\n        int  shift  = 62;\n        long word   = 0x0L;\n        for (int k = offset; eIndex < encoding.length; --k) {\n            for (int vIndex = 0; vIndex < components.length; ++vIndex) {\n                if (getBit(vIndex, k) != 0) {\nword = 0x0L;\n                }\n                if (shift-- == 0) {\n                    encoding[eIndex++] = word;\n                    word  = 0x0L;\n                    shift = 62;\n                }\n            }\n        }\n\n    }",
          "39": "    private void encode(final int minOffset) {\n\n        // choose an offset with some margins\n        offset  = minOffset + 31;\n        offset -= offset % 32;\n\n        if ((encoding != null) && (encoding.length == 1) && (encoding[0] == 0x0L)) {\n            // the components are all zeroes\n            return;\n        }\n\n        // allocate an integer array to encode the components (we use only\n        // 63 bits per element because there is no unsigned long in Java)\n        final int neededBits  = offset + 1 - lsb;\n        final int neededLongs = (neededBits + 62) / 63;\n        encoding = new long[components.length * neededLongs];\n\n        // mix the bits from all components\n        int  eIndex = 0;\n        int  shift  = 62;\n        long word   = 0x0L;\n        for (int k = offset; eIndex < encoding.length; --k) {\n            for (int vIndex = 0; vIndex < components.length; ++vIndex) {\n                if (getBit(vIndex, k) != 0) {\nshift = 62;\n                }\n                if (shift-- == 0) {\n                    encoding[eIndex++] = word;\n                    word  = 0x0L;\n                    shift = 62;\n                }\n            }\n        }\n\n    }",
          "40": "    private void encode(final int minOffset) {\n\n        // choose an offset with some margins\n        offset  = minOffset + 31;\n        offset -= offset % 32;\n\n        if ((encoding != null) && (encoding.length == 1) && (encoding[0] == 0x0L)) {\n            // the components are all zeroes\n            return;\n        }\n\n        // allocate an integer array to encode the components (we use only\n        // 63 bits per element because there is no unsigned long in Java)\n        final int neededBits  = offset + 1 - lsb;\n        final int neededLongs = (neededBits + 62) / 63;\n        encoding = new long[components.length * neededLongs];\n\n        // mix the bits from all components\n        int  eIndex = 0;\n        int  shift  = 62;\n        long word   = 0x0L;\n        for (int k = offset; eIndex < encoding.length; --k) {\n            for (int vIndex = 0; vIndex < components.length; ++vIndex) {\n                if (getBit(vIndex, k) != 0) {\nencoding[eIndex++] = word;\n                }\n                if (shift-- == 0) {\n                    encoding[eIndex++] = word;\n                    word  = 0x0L;\n                    shift = 62;\n                }\n            }\n        }\n\n    }",
          "41": "    private void encode(final int minOffset) {\n\n        // choose an offset with some margins\n        offset  = minOffset + 31;\n        offset -= offset % 32;\n\n        if ((encoding != null) && (encoding.length == 1) && (encoding[0] == 0x0L)) {\n            // the components are all zeroes\n            return;\n        }\n\n        // allocate an integer array to encode the components (we use only\n        // 63 bits per element because there is no unsigned long in Java)\n        final int neededBits  = offset + 1 - lsb;\n        final int neededLongs = (neededBits + 62) / 63;\n        encoding = new long[components.length * neededLongs];\n\n        // mix the bits from all components\n        int  eIndex = 0;\n        int  shift  = 62;\n        long word   = 0x0L;\n        for (int k = offset; eIndex < encoding.length; --k) {\n            for (int vIndex = 0; vIndex < components.length; ++vIndex) {\n                if (getBit(vIndex, k) != 0) {\nencoding = new long[(components.length * neededLongs)];\n                }\n                if (shift-- == 0) {\n                    encoding[eIndex++] = word;\n                    word  = 0x0L;\n                    shift = 62;\n                }\n            }\n        }\n\n    }",
          "42": "    private void encode(final int minOffset) {\n\n        // choose an offset with some margins\n        offset  = minOffset + 31;\n        offset -= offset % 32;\n\n        if ((encoding != null) && (encoding.length == 1) && (encoding[0] == 0x0L)) {\n            // the components are all zeroes\n            return;\n        }\n\n        // allocate an integer array to encode the components (we use only\n        // 63 bits per element because there is no unsigned long in Java)\n        final int neededBits  = offset + 1 - lsb;\n        final int neededLongs = (neededBits + 62) / 63;\n        encoding = new long[components.length * neededLongs];\n\n        // mix the bits from all components\n        int  eIndex = 0;\n        int  shift  = 62;\n        long word   = 0x0L;\n        for (int k = offset; eIndex < encoding.length; --k) {\n            for (int vIndex = 0; vIndex < components.length; ++vIndex) {\n                if (getBit(vIndex, k) != 0) {\nword += shift;\n                }\n                if (shift-- == 0) {\n                    encoding[eIndex++] = word;\n                    word  = 0x0L;\n                    shift = 62;\n                }\n            }\n        }\n\n    }",
          "43": "    private void encode(final int minOffset) {\n\n        // choose an offset with some margins\n        offset  = minOffset + 31;\n        offset -= offset % 32;\n\n        if ((encoding != null) && (encoding.length == 1) && (encoding[0] == 0x0L)) {\n            // the components are all zeroes\n            return;\n        }\n\n        // allocate an integer array to encode the components (we use only\n        // 63 bits per element because there is no unsigned long in Java)\n        final int neededBits  = offset + 1 - lsb;\n        final int neededLongs = (neededBits + 62) / 63;\n        encoding = new long[components.length * neededLongs];\n\n        // mix the bits from all components\n        int  eIndex = 0;\n        int  shift  = 62;\n        long word   = 0x0L;\n        for (int k = offset; eIndex < encoding.length; --k) {\n            for (int vIndex = 0; vIndex < components.length; ++vIndex) {\n                if (getBit(vIndex, k) != 0) {\noffset -= (offset % 32);\n                }\n                if (shift-- == 0) {\n                    encoding[eIndex++] = word;\n                    word  = 0x0L;\n                    shift = 62;\n                }\n            }\n        }\n\n    }",
          "44": "    private void encode(final int minOffset) {\n\n        // choose an offset with some margins\n        offset  = minOffset + 31;\n        offset -= offset % 32;\n\n        if ((encoding != null) && (encoding.length == 1) && (encoding[0] == 0x0L)) {\n            // the components are all zeroes\n            return;\n        }\n\n        // allocate an integer array to encode the components (we use only\n        // 63 bits per element because there is no unsigned long in Java)\n        final int neededBits  = offset + 1 - lsb;\n        final int neededLongs = (neededBits + 62) / 63;\n        encoding = new long[components.length * neededLongs];\n\n        // mix the bits from all components\n        int  eIndex = 0;\n        int  shift  = 62;\n        long word   = 0x0L;\n        for (int k = offset; eIndex < encoding.length; --k) {\n            for (int vIndex = 0; vIndex < components.length; ++vIndex) {\n                if (getBit(vIndex, k) != 0) {\nword |= (1L >= shift);\n                }\n                if (shift-- == 0) {\n                    encoding[eIndex++] = word;\n                    word  = 0x0L;\n                    shift = 62;\n                }\n            }\n        }\n\n    }",
          "45": "    private void encode(final int minOffset) {\n\n        // choose an offset with some margins\n        offset  = minOffset + 31;\n        offset -= offset % 32;\n\n        if ((encoding != null) && (encoding.length == 1) && (encoding[0] == 0x0L)) {\n            // the components are all zeroes\n            return;\n        }\n\n        // allocate an integer array to encode the components (we use only\n        // 63 bits per element because there is no unsigned long in Java)\n        final int neededBits  = offset + 1 - lsb;\n        final int neededLongs = (neededBits + 62) / 63;\n        encoding = new long[components.length * neededLongs];\n\n        // mix the bits from all components\n        int  eIndex = 0;\n        int  shift  = 62;\n        long word   = 0x0L;\n        for (int k = offset; eIndex < encoding.length; --k) {\n            for (int vIndex = 0; vIndex < components.length; ++vIndex) {\n                if (getBit(vIndex, k) != 0) {\nword |= (0 >>> shift);\n                }\n                if (shift-- == 0) {\n                    encoding[eIndex++] = word;\n                    word  = 0x0L;\n                    shift = 62;\n                }\n            }\n        }\n\n    }",
          "46": "    private void encode(final int minOffset) {\n\n        // choose an offset with some margins\n        offset  = minOffset + 31;\n        offset -= offset % 32;\n\n        if ((encoding != null) && (encoding.length == 1) && (encoding[0] == 0x0L)) {\n            // the components are all zeroes\n            return;\n        }\n\n        // allocate an integer array to encode the components (we use only\n        // 63 bits per element because there is no unsigned long in Java)\n        final int neededBits  = offset + 1 - lsb;\n        final int neededLongs = (neededBits + 62) / 63;\n        encoding = new long[components.length * neededLongs];\n\n        // mix the bits from all components\n        int  eIndex = 0;\n        int  shift  = 62;\n        long word   = 0x0L;\n        for (int k = offset; eIndex < encoding.length; --k) {\n            for (int vIndex = 0; vIndex < components.length; ++vIndex) {\n                if (getBit(vIndex, k) != 0) {\neIndex |= (1L >>> shift);\n                }\n                if (shift-- == 0) {\n                    encoding[eIndex++] = word;\n                    word  = 0x0L;\n                    shift = 62;\n                }\n            }\n        }\n\n    }",
          "47": "    private void encode(final int minOffset) {\n\n        // choose an offset with some margins\n        offset  = minOffset + 31;\n        offset -= offset % 32;\n\n        if ((encoding != null) && (encoding.length == 1) && (encoding[0] == 0x0L)) {\n            // the components are all zeroes\n            return;\n        }\n\n        // allocate an integer array to encode the components (we use only\n        // 63 bits per element because there is no unsigned long in Java)\n        final int neededBits  = offset + 1 - lsb;\n        final int neededLongs = (neededBits + 62) / 63;\n        encoding = new long[components.length * neededLongs];\n\n        // mix the bits from all components\n        int  eIndex = 0;\n        int  shift  = 62;\n        long word   = 0x0L;\n        for (int k = offset; eIndex < encoding.length; --k) {\n            for (int vIndex = 0; vIndex < components.length; ++vIndex) {\n                if (getBit(vIndex, k) != 0) {\nword--;\n                }\n                if (shift-- == 0) {\n                    encoding[eIndex++] = word;\n                    word  = 0x0L;\n                    shift = 62;\n                }\n            }\n        }\n\n    }",
          "48": "    private void encode(final int minOffset) {\n\n        // choose an offset with some margins\n        offset  = minOffset + 31;\n        offset -= offset % 32;\n\n        if ((encoding != null) && (encoding.length == 1) && (encoding[0] == 0x0L)) {\n            // the components are all zeroes\n            return;\n        }\n\n        // allocate an integer array to encode the components (we use only\n        // 63 bits per element because there is no unsigned long in Java)\n        final int neededBits  = offset + 1 - lsb;\n        final int neededLongs = (neededBits + 62) / 63;\n        encoding = new long[components.length * neededLongs];\n\n        // mix the bits from all components\n        int  eIndex = 0;\n        int  shift  = 62;\n        long word   = 0x0L;\n        for (int k = offset; eIndex < encoding.length; --k) {\n            for (int vIndex = 0; vIndex < components.length; ++vIndex) {\n                if (getBit(vIndex, k) != 0) {\nword |= (\"null\" >>> shift);\n                }\n                if (shift-- == 0) {\n                    encoding[eIndex++] = word;\n                    word  = 0x0L;\n                    shift = 62;\n                }\n            }\n        }\n\n    }",
          "49": "    private void encode(final int minOffset) {\n\n        // choose an offset with some margins\n        offset  = minOffset + 31;\n        offset -= offset % 32;\n\n        if ((encoding != null) && (encoding.length == 1) && (encoding[0] == 0x0L)) {\n            // the components are all zeroes\n            return;\n        }\n\n        // allocate an integer array to encode the components (we use only\n        // 63 bits per element because there is no unsigned long in Java)\n        final int neededBits  = offset + 1 - lsb;\n        final int neededLongs = (neededBits + 62) / 63;\n        encoding = new long[components.length * neededLongs];\n\n        // mix the bits from all components\n        int  eIndex = 0;\n        int  shift  = 62;\n        long word   = 0x0L;\n        for (int k = offset; eIndex < encoding.length; --k) {\n            for (int vIndex = 0; vIndex < components.length; ++vIndex) {\n                if (getBit(vIndex, k) != 0) {\nword |= (1L + shift);\n                }\n                if (shift-- == 0) {\n                    encoding[eIndex++] = word;\n                    word  = 0x0L;\n                    shift = 62;\n                }\n            }\n        }\n\n    }",
          "50": "    private void encode(final int minOffset) {\n\n        // choose an offset with some margins\n        offset  = minOffset + 31;\n        offset -= offset % 32;\n\n        if ((encoding != null) && (encoding.length == 1) && (encoding[0] == 0x0L)) {\n            // the components are all zeroes\n            return;\n        }\n\n        // allocate an integer array to encode the components (we use only\n        // 63 bits per element because there is no unsigned long in Java)\n        final int neededBits  = offset + 1 - lsb;\n        final int neededLongs = (neededBits + 62) / 63;\n        encoding = new long[components.length * neededLongs];\n\n        // mix the bits from all components\n        int  eIndex = 0;\n        int  shift  = 62;\n        long word   = 0x0L;\n        for (int k = offset; eIndex < encoding.length; --k) {\n            for (int vIndex = 0; vIndex < components.length; ++vIndex) {\n                if (getBit(vIndex, k) != 0) {\noffset = (minOffset + 31);\n                    word |= 1L >>> shift;                }\n                if (shift-- == 0) {\n                    encoding[eIndex++] = word;\n                    word  = 0x0L;\n                    shift = 62;\n                }\n            }\n        }\n\n    }",
          "51": "    private void encode(final int minOffset) {\n\n        // choose an offset with some margins\n        offset  = minOffset + 31;\n        offset -= offset % 32;\n\n        if ((encoding != null) && (encoding.length == 1) && (encoding[0] == 0x0L)) {\n            // the components are all zeroes\n            return;\n        }\n\n        // allocate an integer array to encode the components (we use only\n        // 63 bits per element because there is no unsigned long in Java)\n        final int neededBits  = offset + 1 - lsb;\n        final int neededLongs = (neededBits + 62) / 63;\n        encoding = new long[components.length * neededLongs];\n\n        // mix the bits from all components\n        int  eIndex = 0;\n        int  shift  = 62;\n        long word   = 0x0L;\n        for (int k = offset; eIndex < encoding.length; --k) {\n            for (int vIndex = 0; vIndex < components.length; ++vIndex) {\n                if (getBit(vIndex, k) != 0) {\nword |= (32 >>> shift);\n                }\n                if (shift-- == 0) {\n                    encoding[eIndex++] = word;\n                    word  = 0x0L;\n                    shift = 62;\n                }\n            }\n        }\n\n    }",
          "52": "    private void encode(final int minOffset) {\n\n        // choose an offset with some margins\n        offset  = minOffset + 31;\n        offset -= offset % 32;\n\n        if ((encoding != null) && (encoding.length == 1) && (encoding[0] == 0x0L)) {\n            // the components are all zeroes\n            return;\n        }\n\n        // allocate an integer array to encode the components (we use only\n        // 63 bits per element because there is no unsigned long in Java)\n        final int neededBits  = offset + 1 - lsb;\n        final int neededLongs = (neededBits + 62) / 63;\n        encoding = new long[components.length * neededLongs];\n\n        // mix the bits from all components\n        int  eIndex = 0;\n        int  shift  = 62;\n        long word   = 0x0L;\n        for (int k = offset; eIndex < encoding.length; --k) {\n            for (int vIndex = 0; vIndex < components.length; ++vIndex) {\n                if (getBit(vIndex, k) != 0) {\nword |= (1L >>> neededBits);\n                }\n                if (shift-- == 0) {\n                    encoding[eIndex++] = word;\n                    word  = 0x0L;\n                    shift = 62;\n                }\n            }\n        }\n\n    }",
          "53": "    private void encode(final int minOffset) {\n\n        // choose an offset with some margins\n        offset  = minOffset + 31;\n        offset -= offset % 32;\n\n        if ((encoding != null) && (encoding.length == 1) && (encoding[0] == 0x0L)) {\n            // the components are all zeroes\n            return;\n        }\n\n        // allocate an integer array to encode the components (we use only\n        // 63 bits per element because there is no unsigned long in Java)\n        final int neededBits  = offset + 1 - lsb;\n        final int neededLongs = (neededBits + 62) / 63;\n        encoding = new long[components.length * neededLongs];\n\n        // mix the bits from all components\n        int  eIndex = 0;\n        int  shift  = 62;\n        long word   = 0x0L;\n        for (int k = offset; eIndex < encoding.length; --k) {\n            for (int vIndex = 0; vIndex < components.length; ++vIndex) {\n                if (getBit(vIndex, k) != 0) {\nword /= (1L >>> shift);\n                }\n                if (shift-- == 0) {\n                    encoding[eIndex++] = word;\n                    word  = 0x0L;\n                    shift = 62;\n                }\n            }\n        }\n\n    }",
          "54": "    private void encode(final int minOffset) {\n\n        // choose an offset with some margins\n        offset  = minOffset + 31;\n        offset -= offset % 32;\n\n        if ((encoding != null) && (encoding.length == 1) && (encoding[0] == 0x0L)) {\n            // the components are all zeroes\n            return;\n        }\n\n        // allocate an integer array to encode the components (we use only\n        // 63 bits per element because there is no unsigned long in Java)\n        final int neededBits  = offset + 1 - lsb;\n        final int neededLongs = (neededBits + 62) / 63;\n        encoding = new long[components.length * neededLongs];\n\n        // mix the bits from all components\n        int  eIndex = 0;\n        int  shift  = 62;\n        long word   = 0x0L;\n        for (int k = offset; eIndex < encoding.length; --k) {\n            for (int vIndex = 0; vIndex < components.length; ++vIndex) {\n                if (getBit(vIndex, k) != 0) {\noffset = (minOffset + 31);\n                }\n                if (shift-- == 0) {\n                    encoding[eIndex++] = word;\n                    word  = 0x0L;\n                    shift = 62;\n                }\n            }\n        }\n\n    }",
          "55": "    private void encode(final int minOffset) {\n\n        // choose an offset with some margins\n        offset  = minOffset + 31;\n        offset -= offset % 32;\n\n        if ((encoding != null) && (encoding.length == 1) && (encoding[0] == 0x0L)) {\n            // the components are all zeroes\n            return;\n        }\n\n        // allocate an integer array to encode the components (we use only\n        // 63 bits per element because there is no unsigned long in Java)\n        final int neededBits  = offset + 1 - lsb;\n        final int neededLongs = (neededBits + 62) / 63;\n        encoding = new long[components.length * neededLongs];\n\n        // mix the bits from all components\n        int  eIndex = 0;\n        int  shift  = 62;\n        long word   = 0x0L;\n        for (int k = offset; eIndex < encoding.length; --k) {\n            for (int vIndex = 0; vIndex < components.length; ++vIndex) {\n                if (getBit(vIndex, k) != 0) {\nencode(shift);\n                }\n                if (shift-- == 0) {\n                    encoding[eIndex++] = word;\n                    word  = 0x0L;\n                    shift = 62;\n                }\n            }\n        }\n\n    }",
          "56": "    private void encode(final int minOffset) {\n\n        // choose an offset with some margins\n        offset  = minOffset + 31;\n        offset -= offset % 32;\n\n        if ((encoding != null) && (encoding.length == 1) && (encoding[0] == 0x0L)) {\n            // the components are all zeroes\n            return;\n        }\n\n        // allocate an integer array to encode the components (we use only\n        // 63 bits per element because there is no unsigned long in Java)\n        final int neededBits  = offset + 1 - lsb;\n        final int neededLongs = (neededBits + 62) / 63;\n        encoding = new long[components.length * neededLongs];\n\n        // mix the bits from all components\n        int  eIndex = 0;\n        int  shift  = 62;\n        long word   = 0x0L;\n        for (int k = offset; eIndex < encoding.length; --k) {\n            for (int vIndex = 0; vIndex < components.length; ++vIndex) {\n                if (getBit(vIndex, k) != 0) {\nword++;\n                }\n                if (shift-- == 0) {\n                    encoding[eIndex++] = word;\n                    word  = 0x0L;\n                    shift = 62;\n                }\n            }\n        }\n\n    }",
          "57": "    private void encode(final int minOffset) {\n\n        // choose an offset with some margins\n        offset  = minOffset + 31;\n        offset -= offset % 32;\n\n        if ((encoding != null) && (encoding.length == 1) && (encoding[0] == 0x0L)) {\n            // the components are all zeroes\n            return;\n        }\n\n        // allocate an integer array to encode the components (we use only\n        // 63 bits per element because there is no unsigned long in Java)\n        final int neededBits  = offset + 1 - lsb;\n        final int neededLongs = (neededBits + 62) / 63;\n        encoding = new long[components.length * neededLongs];\n\n        // mix the bits from all components\n        int  eIndex = 0;\n        int  shift  = 62;\n        long word   = 0x0L;\n        for (int k = offset; eIndex < encoding.length; --k) {\n            for (int vIndex = 0; vIndex < components.length; ++vIndex) {\n                if (getBit(vIndex, k) != 0) {\nword |= (1L >> shift);\n                }\n                if (shift-- == 0) {\n                    encoding[eIndex++] = word;\n                    word  = 0x0L;\n                    shift = 62;\n                }\n            }\n        }\n\n    }",
          "58": "    private void encode(final int minOffset) {\n\n        // choose an offset with some margins\n        offset  = minOffset + 31;\n        offset -= offset % 32;\n\n        if ((encoding != null) && (encoding.length == 1) && (encoding[0] == 0x0L)) {\n            // the components are all zeroes\n            return;\n        }\n\n        // allocate an integer array to encode the components (we use only\n        // 63 bits per element because there is no unsigned long in Java)\n        final int neededBits  = offset + 1 - lsb;\n        final int neededLongs = (neededBits + 62) / 63;\n        encoding = new long[components.length * neededLongs];\n\n        // mix the bits from all components\n        int  eIndex = 0;\n        int  shift  = 62;\n        long word   = 0x0L;\n        for (int k = offset; eIndex < encoding.length; --k) {\n            for (int vIndex = 0; vIndex < components.length; ++vIndex) {\n                if (getBit(vIndex, k) != 0) {\nword |= (1L < shift);\n                }\n                if (shift-- == 0) {\n                    encoding[eIndex++] = word;\n                    word  = 0x0L;\n                    shift = 62;\n                }\n            }\n        }\n\n    }",
          "59": "    private void encode(final int minOffset) {\n\n        // choose an offset with some margins\n        offset  = minOffset + 31;\n        offset -= offset % 32;\n\n        if ((encoding != null) && (encoding.length == 1) && (encoding[0] == 0x0L)) {\n            // the components are all zeroes\n            return;\n        }\n\n        // allocate an integer array to encode the components (we use only\n        // 63 bits per element because there is no unsigned long in Java)\n        final int neededBits  = offset + 1 - lsb;\n        final int neededLongs = (neededBits + 62) / 63;\n        encoding = new long[components.length * neededLongs];\n\n        // mix the bits from all components\n        int  eIndex = 0;\n        int  shift  = 62;\n        long word   = 0x0L;\n        for (int k = offset; eIndex < encoding.length; --k) {\n            for (int vIndex = 0; vIndex < components.length; ++vIndex) {\n                if (getBit(vIndex, k) != 0) {\nword |= (1L > shift);\n                }\n                if (shift-- == 0) {\n                    encoding[eIndex++] = word;\n                    word  = 0x0L;\n                    shift = 62;\n                }\n            }\n        }\n\n    }",
          "60": "    private void encode(final int minOffset) {\n\n        // choose an offset with some margins\n        offset  = minOffset + 31;\n        offset -= offset % 32;\n\n        if ((encoding != null) && (encoding.length == 1) && (encoding[0] == 0x0L)) {\n            // the components are all zeroes\n            return;\n        }\n\n        // allocate an integer array to encode the components (we use only\n        // 63 bits per element because there is no unsigned long in Java)\n        final int neededBits  = offset + 1 - lsb;\n        final int neededLongs = (neededBits + 62) / 63;\n        encoding = new long[components.length * neededLongs];\n\n        // mix the bits from all components\n        int  eIndex = 0;\n        int  shift  = 62;\n        long word   = 0x0L;\n        for (int k = offset; eIndex < encoding.length; --k) {\n            for (int vIndex = 0; vIndex < components.length; ++vIndex) {\n                if (getBit(vIndex, k) != 0) {\nword[eIndex++];\n                }\n                if (shift-- == 0) {\n                    encoding[eIndex++] = word;\n                    word  = 0x0L;\n                    shift = 62;\n                }\n            }\n        }\n\n    }",
          "61": "    private void encode(final int minOffset) {\n\n        // choose an offset with some margins\n        offset  = minOffset + 31;\n        offset -= offset % 32;\n\n        if ((encoding != null) && (encoding.length == 1) && (encoding[0] == 0x0L)) {\n            // the components are all zeroes\n            return;\n        }\n\n        // allocate an integer array to encode the components (we use only\n        // 63 bits per element because there is no unsigned long in Java)\n        final int neededBits  = offset + 1 - lsb;\n        final int neededLongs = (neededBits + 62) / 63;\n        encoding = new long[components.length * neededLongs];\n\n        // mix the bits from all components\n        int  eIndex = 0;\n        int  shift  = 62;\n        long word   = 0x0L;\n        for (int k = offset; eIndex < encoding.length; --k) {\n            for (int vIndex = 0; vIndex < components.length; ++vIndex) {\n                if (getBit(vIndex, k) != 0) {\nword |= (1L % shift);\n                }\n                if (shift-- == 0) {\n                    encoding[eIndex++] = word;\n                    word  = 0x0L;\n                    shift = 62;\n                }\n            }\n        }\n\n    }",
          "62": "    private void encode(final int minOffset) {\n\n        // choose an offset with some margins\n        offset  = minOffset + 31;\n        offset -= offset % 32;\n\n        if ((encoding != null) && (encoding.length == 1) && (encoding[0] == 0x0L)) {\n            // the components are all zeroes\n            return;\n        }\n\n        // allocate an integer array to encode the components (we use only\n        // 63 bits per element because there is no unsigned long in Java)\n        final int neededBits  = offset + 1 - lsb;\n        final int neededLongs = (neededBits + 62) / 63;\n        encoding = new long[components.length * neededLongs];\n\n        // mix the bits from all components\n        int  eIndex = 0;\n        int  shift  = 62;\n        long word   = 0x0L;\n        for (int k = offset; eIndex < encoding.length; --k) {\n            for (int vIndex = 0; vIndex < components.length; ++vIndex) {\n                if (getBit(vIndex, k) != 0) {\nword |= (1L == shift);\n                }\n                if (shift-- == 0) {\n                    encoding[eIndex++] = word;\n                    word  = 0x0L;\n                    shift = 62;\n                }\n            }\n        }\n\n    }",
          "63": "    private void encode(final int minOffset) {\n\n        // choose an offset with some margins\n        offset  = minOffset + 31;\n        offset -= offset % 32;\n\n        if ((encoding != null) && (encoding.length == 1) && (encoding[0] == 0x0L)) {\n            // the components are all zeroes\n            return;\n        }\n\n        // allocate an integer array to encode the components (we use only\n        // 63 bits per element because there is no unsigned long in Java)\n        final int neededBits  = offset + 1 - lsb;\n        final int neededLongs = (neededBits + 62) / 63;\n        encoding = new long[components.length * neededLongs];\n\n        // mix the bits from all components\n        int  eIndex = 0;\n        int  shift  = 62;\n        long word   = 0x0L;\n        for (int k = offset; eIndex < encoding.length; --k) {\n            for (int vIndex = 0; vIndex < components.length; ++vIndex) {\n                if (getBit(vIndex, k) != 0) {\nif((encoding[0] == 0x0L)){\n}\n                    word |= 1L >>> shift;                }\n                if (shift-- == 0) {\n                    encoding[eIndex++] = word;\n                    word  = 0x0L;\n                    shift = 62;\n                }\n            }\n        }\n\n    }",
          "64": "    private void encode(final int minOffset) {\n\n        // choose an offset with some margins\n        offset  = minOffset + 31;\n        offset -= offset % 32;\n\n        if ((encoding != null) && (encoding.length == 1) && (encoding[0] == 0x0L)) {\n            // the components are all zeroes\n            return;\n        }\n\n        // allocate an integer array to encode the components (we use only\n        // 63 bits per element because there is no unsigned long in Java)\n        final int neededBits  = offset + 1 - lsb;\n        final int neededLongs = (neededBits + 62) / 63;\n        encoding = new long[components.length * neededLongs];\n\n        // mix the bits from all components\n        int  eIndex = 0;\n        int  shift  = 62;\n        long word   = 0x0L;\n        for (int k = offset; eIndex < encoding.length; --k) {\n            for (int vIndex = 0; vIndex < components.length; ++vIndex) {\n                if (getBit(vIndex, k) != 0) {\nif((shift-- == 0)){\n}\n                    word |= 1L >>> shift;                }\n                if (shift-- == 0) {\n                    encoding[eIndex++] = word;\n                    word  = 0x0L;\n                    shift = 62;\n                }\n            }\n        }\n\n    }",
          "65": "    private void encode(final int minOffset) {\n\n        // choose an offset with some margins\n        offset  = minOffset + 31;\n        offset -= offset % 32;\n\n        if ((encoding != null) && (encoding.length == 1) && (encoding[0] == 0x0L)) {\n            // the components are all zeroes\n            return;\n        }\n\n        // allocate an integer array to encode the components (we use only\n        // 63 bits per element because there is no unsigned long in Java)\n        final int neededBits  = offset + 1 - lsb;\n        final int neededLongs = (neededBits + 62) / 63;\n        encoding = new long[components.length * neededLongs];\n\n        // mix the bits from all components\n        int  eIndex = 0;\n        int  shift  = 62;\n        long word   = 0x0L;\n        for (int k = offset; eIndex < encoding.length; --k) {\n            for (int vIndex = 0; vIndex < components.length; ++vIndex) {\n                if (getBit(vIndex, k) != 0) {\nneededBits |= (1L >>> shift);\n                }\n                if (shift-- == 0) {\n                    encoding[eIndex++] = word;\n                    word  = 0x0L;\n                    shift = 62;\n                }\n            }\n        }\n\n    }",
          "66": "    private void encode(final int minOffset) {\n\n        // choose an offset with some margins\n        offset  = minOffset + 31;\n        offset -= offset % 32;\n\n        if ((encoding != null) && (encoding.length == 1) && (encoding[0] == 0x0L)) {\n            // the components are all zeroes\n            return;\n        }\n\n        // allocate an integer array to encode the components (we use only\n        // 63 bits per element because there is no unsigned long in Java)\n        final int neededBits  = offset + 1 - lsb;\n        final int neededLongs = (neededBits + 62) / 63;\n        encoding = new long[components.length * neededLongs];\n\n        // mix the bits from all components\n        int  eIndex = 0;\n        int  shift  = 62;\n        long word   = 0x0L;\n        for (int k = offset; eIndex < encoding.length; --k) {\n            for (int vIndex = 0; vIndex < components.length; ++vIndex) {\n                if (getBit(vIndex, k) != 0) {\nword |= (1L / shift);\n                }\n                if (shift-- == 0) {\n                    encoding[eIndex++] = word;\n                    word  = 0x0L;\n                    shift = 62;\n                }\n            }\n        }\n\n    }",
          "67": "    private void encode(final int minOffset) {\n\n        // choose an offset with some margins\n        offset  = minOffset + 31;\n        offset -= offset % 32;\n\n        if ((encoding != null) && (encoding.length == 1) && (encoding[0] == 0x0L)) {\n            // the components are all zeroes\n            return;\n        }\n\n        // allocate an integer array to encode the components (we use only\n        // 63 bits per element because there is no unsigned long in Java)\n        final int neededBits  = offset + 1 - lsb;\n        final int neededLongs = (neededBits + 62) / 63;\n        encoding = new long[components.length * neededLongs];\n\n        // mix the bits from all components\n        int  eIndex = 0;\n        int  shift  = 62;\n        long word   = 0x0L;\n        for (int k = offset; eIndex < encoding.length; --k) {\n            for (int vIndex = 0; vIndex < components.length; ++vIndex) {\n                if (getBit(vIndex, k) != 0) {\nreturn;\n                }\n                if (shift-- == 0) {\n                    encoding[eIndex++] = word;\n                    word  = 0x0L;\n                    shift = 62;\n                }\n            }\n        }\n\n    }",
          "68": "    private void encode(final int minOffset) {\n\n        // choose an offset with some margins\n        offset  = minOffset + 31;\n        offset -= offset % 32;\n\n        if ((encoding != null) && (encoding.length == 1) && (encoding[0] == 0x0L)) {\n            // the components are all zeroes\n            return;\n        }\n\n        // allocate an integer array to encode the components (we use only\n        // 63 bits per element because there is no unsigned long in Java)\n        final int neededBits  = offset + 1 - lsb;\n        final int neededLongs = (neededBits + 62) / 63;\n        encoding = new long[components.length * neededLongs];\n\n        // mix the bits from all components\n        int  eIndex = 0;\n        int  shift  = 62;\n        long word   = 0x0L;\n        for (int k = offset; eIndex < encoding.length; --k) {\n            for (int vIndex = 0; vIndex < components.length; ++vIndex) {\n                if (getBit(vIndex, k) != 0) {\ncontinue;\n                    word |= 1L >>> shift;                }\n                if (shift-- == 0) {\n                    encoding[eIndex++] = word;\n                    word  = 0x0L;\n                    shift = 62;\n                }\n            }\n        }\n\n    }",
          "69": "    private void encode(final int minOffset) {\n\n        // choose an offset with some margins\n        offset  = minOffset + 31;\n        offset -= offset % 32;\n\n        if ((encoding != null) && (encoding.length == 1) && (encoding[0] == 0x0L)) {\n            // the components are all zeroes\n            return;\n        }\n\n        // allocate an integer array to encode the components (we use only\n        // 63 bits per element because there is no unsigned long in Java)\n        final int neededBits  = offset + 1 - lsb;\n        final int neededLongs = (neededBits + 62) / 63;\n        encoding = new long[components.length * neededLongs];\n\n        // mix the bits from all components\n        int  eIndex = 0;\n        int  shift  = 62;\n        long word   = 0x0L;\n        for (int k = offset; eIndex < encoding.length; --k) {\n            for (int vIndex = 0; vIndex < components.length; ++vIndex) {\n                if (getBit(vIndex, k) != 0) {\nword += (1L + shift);\n                }\n                if (shift-- == 0) {\n                    encoding[eIndex++] = word;\n                    word  = 0x0L;\n                    shift = 62;\n                }\n            }\n        }\n\n    }",
          "70": "    private void encode(final int minOffset) {\n\n        // choose an offset with some margins\n        offset  = minOffset + 31;\n        offset -= offset % 32;\n\n        if ((encoding != null) && (encoding.length == 1) && (encoding[0] == 0x0L)) {\n            // the components are all zeroes\n            return;\n        }\n\n        // allocate an integer array to encode the components (we use only\n        // 63 bits per element because there is no unsigned long in Java)\n        final int neededBits  = offset + 1 - lsb;\n        final int neededLongs = (neededBits + 62) / 63;\n        encoding = new long[components.length * neededLongs];\n\n        // mix the bits from all components\n        int  eIndex = 0;\n        int  shift  = 62;\n        long word   = 0x0L;\n        for (int k = offset; eIndex < encoding.length; --k) {\n            for (int vIndex = 0; vIndex < components.length; ++vIndex) {\n                if (getBit(vIndex, k) != 0) {\nword |= (1L >>> shift);\n}\n                    word |= 1L >>> shift;                }\n                if (shift-- == 0) {\n                    encoding[eIndex++] = word;\n                    word  = 0x0L;\n                    shift = 62;\n                }\n            }\n        }\n\n    }",
          "71": "    private void encode(final int minOffset) {\n\n        // choose an offset with some margins\n        offset  = minOffset + 31;\n        offset -= offset % 32;\n\n        if ((encoding != null) && (encoding.length == 1) && (encoding[0] == 0x0L)) {\n            // the components are all zeroes\n            return;\n        }\n\n        // allocate an integer array to encode the components (we use only\n        // 63 bits per element because there is no unsigned long in Java)\n        final int neededBits  = offset + 1 - lsb;\n        final int neededLongs = (neededBits + 62) / 63;\n        encoding = new long[components.length * neededLongs];\n\n        // mix the bits from all components\n        int  eIndex = 0;\n        int  shift  = 62;\n        long word   = 0x0L;\n        for (int k = offset; eIndex < encoding.length; --k) {\n            for (int vIndex = 0; vIndex < components.length; ++vIndex) {\n                if (getBit(vIndex, k) != 0) {\nfor(int vIndex = 0;(vIndex < components.length);++vIndex) {                    word |= 1L >>> shift;                }\n                if (shift-- == 0) {\n                    encoding[eIndex++] = word;\n                    word  = 0x0L;\n                    shift = 62;\n                }\n            }\n        }\n\n    }",
          "72": "    private void encode(final int minOffset) {\n\n        // choose an offset with some margins\n        offset  = minOffset + 31;\n        offset -= offset % 32;\n\n        if ((encoding != null) && (encoding.length == 1) && (encoding[0] == 0x0L)) {\n            // the components are all zeroes\n            return;\n        }\n\n        // allocate an integer array to encode the components (we use only\n        // 63 bits per element because there is no unsigned long in Java)\n        final int neededBits  = offset + 1 - lsb;\n        final int neededLongs = (neededBits + 62) / 63;\n        encoding = new long[components.length * neededLongs];\n\n        // mix the bits from all components\n        int  eIndex = 0;\n        int  shift  = 62;\n        long word   = 0x0L;\n        for (int k = offset; eIndex < encoding.length; --k) {\n            for (int vIndex = 0; vIndex < components.length; ++vIndex) {\n                if (getBit(vIndex, k) != 0) {\nfor(int k = offset;(eIndex < encoding.length);--k) {                    word |= 1L >>> shift;                }\n                if (shift-- == 0) {\n                    encoding[eIndex++] = word;\n                    word  = 0x0L;\n                    shift = 62;\n                }\n            }\n        }\n\n    }",
          "73": "    private void encode(final int minOffset) {\n\n        // choose an offset with some margins\n        offset  = minOffset + 31;\n        offset -= offset % 32;\n\n        if ((encoding != null) && (encoding.length == 1) && (encoding[0] == 0x0L)) {\n            // the components are all zeroes\n            return;\n        }\n\n        // allocate an integer array to encode the components (we use only\n        // 63 bits per element because there is no unsigned long in Java)\n        final int neededBits  = offset + 1 - lsb;\n        final int neededLongs = (neededBits + 62) / 63;\n        encoding = new long[components.length * neededLongs];\n\n        // mix the bits from all components\n        int  eIndex = 0;\n        int  shift  = 62;\n        long word   = 0x0L;\n        for (int k = offset; eIndex < encoding.length; --k) {\n            for (int vIndex = 0; vIndex < components.length; ++vIndex) {\n                if (getBit(vIndex, k) != 0) {\nword = (1L + shift);\n                }\n                if (shift-- == 0) {\n                    encoding[eIndex++] = word;\n                    word  = 0x0L;\n                    shift = 62;\n                }\n            }\n        }\n\n    }",
          "74": "    private void encode(final int minOffset) {\n\n        // choose an offset with some margins\n        offset  = minOffset + 31;\n        offset -= offset % 32;\n\n        if ((encoding != null) && (encoding.length == 1) && (encoding[0] == 0x0L)) {\n            // the components are all zeroes\n            return;\n        }\n\n        // allocate an integer array to encode the components (we use only\n        // 63 bits per element because there is no unsigned long in Java)\n        final int neededBits  = offset + 1 - lsb;\n        final int neededLongs = (neededBits + 62) / 63;\n        encoding = new long[components.length * neededLongs];\n\n        // mix the bits from all components\n        int  eIndex = 0;\n        int  shift  = 62;\n        long word   = 0x0L;\n        for (int k = offset; eIndex < encoding.length; --k) {\n            for (int vIndex = 0; vIndex < components.length; ++vIndex) {\n                if (getBit(vIndex, k) != 0) {\nword -= (1L + shift);\n                }\n                if (shift-- == 0) {\n                    encoding[eIndex++] = word;\n                    word  = 0x0L;\n                    shift = 62;\n                }\n            }\n        }\n\n    }",
          "75": "    private void encode(final int minOffset) {\n\n        // choose an offset with some margins\n        offset  = minOffset + 31;\n        offset -= offset % 32;\n\n        if ((encoding != null) && (encoding.length == 1) && (encoding[0] == 0x0L)) {\n            // the components are all zeroes\n            return;\n        }\n\n        // allocate an integer array to encode the components (we use only\n        // 63 bits per element because there is no unsigned long in Java)\n        final int neededBits  = offset + 1 - lsb;\n        final int neededLongs = (neededBits + 62) / 63;\n        encoding = new long[components.length * neededLongs];\n\n        // mix the bits from all components\n        int  eIndex = 0;\n        int  shift  = 62;\n        long word   = 0x0L;\n        for (int k = offset; eIndex < encoding.length; --k) {\n            for (int vIndex = 0; vIndex < components.length; ++vIndex) {\n                if (getBit(vIndex, k) != 0) {\nword &= (1L + shift);\n                }\n                if (shift-- == 0) {\n                    encoding[eIndex++] = word;\n                    word  = 0x0L;\n                    shift = 62;\n                }\n            }\n        }\n\n    }",
          "76": "    private void encode(final int minOffset) {\n\n        // choose an offset with some margins\n        offset  = minOffset + 31;\n        offset -= offset % 32;\n\n        if ((encoding != null) && (encoding.length == 1) && (encoding[0] == 0x0L)) {\n            // the components are all zeroes\n            return;\n        }\n\n        // allocate an integer array to encode the components (we use only\n        // 63 bits per element because there is no unsigned long in Java)\n        final int neededBits  = offset + 1 - lsb;\n        final int neededLongs = (neededBits + 62) / 63;\n        encoding = new long[components.length * neededLongs];\n\n        // mix the bits from all components\n        int  eIndex = 0;\n        int  shift  = 62;\n        long word   = 0x0L;\n        for (int k = offset; eIndex < encoding.length; --k) {\n            for (int vIndex = 0; vIndex < components.length; ++vIndex) {\n                if (getBit(vIndex, k) != 0) {\nword += encode(shift);\n                }\n                if (shift-- == 0) {\n                    encoding[eIndex++] = word;\n                    word  = 0x0L;\n                    shift = 62;\n                }\n            }\n        }\n\n    }",
          "77": "    private void encode(final int minOffset) {\n\n        // choose an offset with some margins\n        offset  = minOffset + 31;\n        offset -= offset % 32;\n\n        if ((encoding != null) && (encoding.length == 1) && (encoding[0] == 0x0L)) {\n            // the components are all zeroes\n            return;\n        }\n\n        // allocate an integer array to encode the components (we use only\n        // 63 bits per element because there is no unsigned long in Java)\n        final int neededBits  = offset + 1 - lsb;\n        final int neededLongs = (neededBits + 62) / 63;\n        encoding = new long[components.length * neededLongs];\n\n        // mix the bits from all components\n        int  eIndex = 0;\n        int  shift  = 62;\n        long word   = 0x0L;\n        for (int k = offset; eIndex < encoding.length; --k) {\n            for (int vIndex = 0; vIndex < components.length; ++vIndex) {\n                if (getBit(vIndex, k) != 0) {\nbreak;\n                }\n                if (shift-- == 0) {\n                    encoding[eIndex++] = word;\n                    word  = 0x0L;\n                    shift = 62;\n                }\n            }\n        }\n\n    }"
}