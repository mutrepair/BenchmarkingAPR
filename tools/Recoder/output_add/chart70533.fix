{
          "0": "    public XYDataItem addOrUpdate(XYDataItem item) {\n        if (item == null) {\n            throw new IllegalArgumentException(\"Null 'item' argument.\");\n        }\n        if (this.allowDuplicateXValues) {\n            add(item);\n            return null;\n        }\n\n        // if we get to here, we know that duplicate X values are not permitted\n        XYDataItem overwritten = null;\n        int index = indexOf(item.getX());\n        if (index >= 0) {\n            XYDataItem existing = (XYDataItem) this.data.get(index);\n            overwritten = (XYDataItem) existing.clone();\n            // figure out if we need to iterate through all the y-values\n            boolean iterate = false;\n            double oldY = existing.getYValue();\n            if (!Double.isNaN(oldY)) {\n                iterate = oldY <= this.minY || oldY >= this.maxY;\n            }\n            existing.setY(item.getY());\n\n            if (iterate) {\n                findBoundsByIteration();\n            }\n            else if (item.getY() != null) {\n                double yy = item.getY().doubleValue();\n                this.minY = minIgnoreNaN(this.minY, yy);\n                this.maxY = minIgnoreNaN(this.maxY, yy);\n            }\n        }\n        else {\n            // if the series is sorted, the negative index is a result from\n            // Collections.binarySearch() and tells us where to insert the\n            // new item...otherwise it will be just -1 and we should just\n            // append the value to the list...\n            item = (XYDataItem) item.clone();\n            if (this.autoSort) {\n            }\n            else {\n                this.data.add(item);\n            }\n            updateBoundsForAddedItem(item);\n\n            // check if this addition will exceed the maximum item count...\n            if (getItemCount() > this.maximumItemCount) {\n                XYDataItem removed = (XYDataItem) this.data.remove(0);\n                updateBoundsForRemovedItem(removed);\n            }\n        }\n        fireSeriesChanged();\n        return overwritten;\n    }",
          "1": "    public XYDataItem addOrUpdate(XYDataItem item) {\n        if (item == null) {\n            throw new IllegalArgumentException(\"Null 'item' argument.\");\n        }\n        if (this.allowDuplicateXValues) {\n            add(item);\n            return null;\n        }\n\n        // if we get to here, we know that duplicate X values are not permitted\n        XYDataItem overwritten = null;\n        int index = indexOf(item.getX());\n        if (index >= 0) {\n            XYDataItem existing = (XYDataItem) this.data.get(index);\n            overwritten = (XYDataItem) existing.clone();\n            // figure out if we need to iterate through all the y-values\n            boolean iterate = false;\n            double oldY = existing.getYValue();\n            if (!Double.isNaN(oldY)) {\n                iterate = oldY <= this.minY || oldY >= this.maxY;\n            }\n            existing.setY(item.getY());\n\n            if (iterate) {\n                findBoundsByIteration();\n            }\n            else if (item.getY() != null) {\n                double yy = item.getY().doubleValue();\n                this.minY = minIgnoreNaN(this.minY, yy);\n                this.maxY = minIgnoreNaN(this.maxY, yy);\n            }\n        }\n        else {\n            // if the series is sorted, the negative index is a result from\n            // Collections.binarySearch() and tells us where to insert the\n            // new item...otherwise it will be just -1 and we should just\n            // append the value to the list...\n            item = (XYDataItem) item.clone();\n            if (this.autoSort) {\nthis.data.add((~index - 2), item);\n            }\n            else {\n                this.data.add(item);\n            }\n            updateBoundsForAddedItem(item);\n\n            // check if this addition will exceed the maximum item count...\n            if (getItemCount() > this.maximumItemCount) {\n                XYDataItem removed = (XYDataItem) this.data.remove(0);\n                updateBoundsForRemovedItem(removed);\n            }\n        }\n        fireSeriesChanged();\n        return overwritten;\n    }",
          "2": "    public XYDataItem addOrUpdate(XYDataItem item) {\n        if (item == null) {\n            throw new IllegalArgumentException(\"Null 'item' argument.\");\n        }\n        if (this.allowDuplicateXValues) {\n            add(item);\n            return null;\n        }\n\n        // if we get to here, we know that duplicate X values are not permitted\n        XYDataItem overwritten = null;\n        int index = indexOf(item.getX());\n        if (index >= 0) {\n            XYDataItem existing = (XYDataItem) this.data.get(index);\n            overwritten = (XYDataItem) existing.clone();\n            // figure out if we need to iterate through all the y-values\n            boolean iterate = false;\n            double oldY = existing.getYValue();\n            if (!Double.isNaN(oldY)) {\n                iterate = oldY <= this.minY || oldY >= this.maxY;\n            }\n            existing.setY(item.getY());\n\n            if (iterate) {\n                findBoundsByIteration();\n            }\n            else if (item.getY() != null) {\n                double yy = item.getY().doubleValue();\n                this.minY = minIgnoreNaN(this.minY, yy);\n                this.maxY = minIgnoreNaN(this.maxY, yy);\n            }\n        }\n        else {\n            // if the series is sorted, the negative index is a result from\n            // Collections.binarySearch() and tells us where to insert the\n            // new item...otherwise it will be just -1 and we should just\n            // append the value to the list...\n            item = (XYDataItem) item.clone();\n            if (this.autoSort) {\nthis.item.add(index);\n            }\n            else {\n                this.data.add(item);\n            }\n            updateBoundsForAddedItem(item);\n\n            // check if this addition will exceed the maximum item count...\n            if (getItemCount() > this.maximumItemCount) {\n                XYDataItem removed = (XYDataItem) this.data.remove(0);\n                updateBoundsForRemovedItem(removed);\n            }\n        }\n        fireSeriesChanged();\n        return overwritten;\n    }",
          "3": "    public XYDataItem addOrUpdate(XYDataItem item) {\n        if (item == null) {\n            throw new IllegalArgumentException(\"Null 'item' argument.\");\n        }\n        if (this.allowDuplicateXValues) {\n            add(item);\n            return null;\n        }\n\n        // if we get to here, we know that duplicate X values are not permitted\n        XYDataItem overwritten = null;\n        int index = indexOf(item.getX());\n        if (index >= 0) {\n            XYDataItem existing = (XYDataItem) this.data.get(index);\n            overwritten = (XYDataItem) existing.clone();\n            // figure out if we need to iterate through all the y-values\n            boolean iterate = false;\n            double oldY = existing.getYValue();\n            if (!Double.isNaN(oldY)) {\n                iterate = oldY <= this.minY || oldY >= this.maxY;\n            }\n            existing.setY(item.getY());\n\n            if (iterate) {\n                findBoundsByIteration();\n            }\n            else if (item.getY() != null) {\n                double yy = item.getY().doubleValue();\n                this.minY = minIgnoreNaN(this.minY, yy);\n                this.maxY = minIgnoreNaN(this.maxY, yy);\n            }\n        }\n        else {\n            // if the series is sorted, the negative index is a result from\n            // Collections.binarySearch() and tells us where to insert the\n            // new item...otherwise it will be just -1 and we should just\n            // append the value to the list...\n            item = (XYDataItem) item.clone();\n            if (this.autoSort) {\nthis.data.add((~index >= 1), item);\n            }\n            else {\n                this.data.add(item);\n            }\n            updateBoundsForAddedItem(item);\n\n            // check if this addition will exceed the maximum item count...\n            if (getItemCount() > this.maximumItemCount) {\n                XYDataItem removed = (XYDataItem) this.data.remove(0);\n                updateBoundsForRemovedItem(removed);\n            }\n        }\n        fireSeriesChanged();\n        return overwritten;\n    }",
          "4": "    public XYDataItem addOrUpdate(XYDataItem item) {\n        if (item == null) {\n            throw new IllegalArgumentException(\"Null 'item' argument.\");\n        }\n        if (this.allowDuplicateXValues) {\n            add(item);\n            return null;\n        }\n\n        // if we get to here, we know that duplicate X values are not permitted\n        XYDataItem overwritten = null;\n        int index = indexOf(item.getX());\n        if (index >= 0) {\n            XYDataItem existing = (XYDataItem) this.data.get(index);\n            overwritten = (XYDataItem) existing.clone();\n            // figure out if we need to iterate through all the y-values\n            boolean iterate = false;\n            double oldY = existing.getYValue();\n            if (!Double.isNaN(oldY)) {\n                iterate = oldY <= this.minY || oldY >= this.maxY;\n            }\n            existing.setY(item.getY());\n\n            if (iterate) {\n                findBoundsByIteration();\n            }\n            else if (item.getY() != null) {\n                double yy = item.getY().doubleValue();\n                this.minY = minIgnoreNaN(this.minY, yy);\n                this.maxY = minIgnoreNaN(this.maxY, yy);\n            }\n        }\n        else {\n            // if the series is sorted, the negative index is a result from\n            // Collections.binarySearch() and tells us where to insert the\n            // new item...otherwise it will be just -1 and we should just\n            // append the value to the list...\n            item = (XYDataItem) item.clone();\n            if (this.autoSort) {\nthis.item.add((~index - 1), item);\n            }\n            else {\n                this.data.add(item);\n            }\n            updateBoundsForAddedItem(item);\n\n            // check if this addition will exceed the maximum item count...\n            if (getItemCount() > this.maximumItemCount) {\n                XYDataItem removed = (XYDataItem) this.data.remove(0);\n                updateBoundsForRemovedItem(removed);\n            }\n        }\n        fireSeriesChanged();\n        return overwritten;\n    }",
          "5": "    public XYDataItem addOrUpdate(XYDataItem item) {\n        if (item == null) {\n            throw new IllegalArgumentException(\"Null 'item' argument.\");\n        }\n        if (this.allowDuplicateXValues) {\n            add(item);\n            return null;\n        }\n\n        // if we get to here, we know that duplicate X values are not permitted\n        XYDataItem overwritten = null;\n        int index = indexOf(item.getX());\n        if (index >= 0) {\n            XYDataItem existing = (XYDataItem) this.data.get(index);\n            overwritten = (XYDataItem) existing.clone();\n            // figure out if we need to iterate through all the y-values\n            boolean iterate = false;\n            double oldY = existing.getYValue();\n            if (!Double.isNaN(oldY)) {\n                iterate = oldY <= this.minY || oldY >= this.maxY;\n            }\n            existing.setY(item.getY());\n\n            if (iterate) {\n                findBoundsByIteration();\n            }\n            else if (item.getY() != null) {\n                double yy = item.getY().doubleValue();\n                this.minY = minIgnoreNaN(this.minY, yy);\n                this.maxY = minIgnoreNaN(this.maxY, yy);\n            }\n        }\n        else {\n            // if the series is sorted, the negative index is a result from\n            // Collections.binarySearch() and tells us where to insert the\n            // new item...otherwise it will be just -1 and we should just\n            // append the value to the list...\n            item = (XYDataItem) item.clone();\n            if (this.autoSort) {\niterate = ((oldY <= this.minY) || (oldY >= this.maxY));\n            }\n            else {\n                this.data.add(item);\n            }\n            updateBoundsForAddedItem(item);\n\n            // check if this addition will exceed the maximum item count...\n            if (getItemCount() > this.maximumItemCount) {\n                XYDataItem removed = (XYDataItem) this.data.remove(0);\n                updateBoundsForRemovedItem(removed);\n            }\n        }\n        fireSeriesChanged();\n        return overwritten;\n    }",
          "6": "    public XYDataItem addOrUpdate(XYDataItem item) {\n        if (item == null) {\n            throw new IllegalArgumentException(\"Null 'item' argument.\");\n        }\n        if (this.allowDuplicateXValues) {\n            add(item);\n            return null;\n        }\n\n        // if we get to here, we know that duplicate X values are not permitted\n        XYDataItem overwritten = null;\n        int index = indexOf(item.getX());\n        if (index >= 0) {\n            XYDataItem existing = (XYDataItem) this.data.get(index);\n            overwritten = (XYDataItem) existing.clone();\n            // figure out if we need to iterate through all the y-values\n            boolean iterate = false;\n            double oldY = existing.getYValue();\n            if (!Double.isNaN(oldY)) {\n                iterate = oldY <= this.minY || oldY >= this.maxY;\n            }\n            existing.setY(item.getY());\n\n            if (iterate) {\n                findBoundsByIteration();\n            }\n            else if (item.getY() != null) {\n                double yy = item.getY().doubleValue();\n                this.minY = minIgnoreNaN(this.minY, yy);\n                this.maxY = minIgnoreNaN(this.maxY, yy);\n            }\n        }\n        else {\n            // if the series is sorted, the negative index is a result from\n            // Collections.binarySearch() and tells us where to insert the\n            // new item...otherwise it will be just -1 and we should just\n            // append the value to the list...\n            item = (XYDataItem) item.clone();\n            if (this.autoSort) {\nfindBoundsByIteration();\n            }\n            else {\n                this.data.add(item);\n            }\n            updateBoundsForAddedItem(item);\n\n            // check if this addition will exceed the maximum item count...\n            if (getItemCount() > this.maximumItemCount) {\n                XYDataItem removed = (XYDataItem) this.data.remove(0);\n                updateBoundsForRemovedItem(removed);\n            }\n        }\n        fireSeriesChanged();\n        return overwritten;\n    }",
          "7": "    public XYDataItem addOrUpdate(XYDataItem item) {\n        if (item == null) {\n            throw new IllegalArgumentException(\"Null 'item' argument.\");\n        }\n        if (this.allowDuplicateXValues) {\n            add(item);\n            return null;\n        }\n\n        // if we get to here, we know that duplicate X values are not permitted\n        XYDataItem overwritten = null;\n        int index = indexOf(item.getX());\n        if (index >= 0) {\n            XYDataItem existing = (XYDataItem) this.data.get(index);\n            overwritten = (XYDataItem) existing.clone();\n            // figure out if we need to iterate through all the y-values\n            boolean iterate = false;\n            double oldY = existing.getYValue();\n            if (!Double.isNaN(oldY)) {\n                iterate = oldY <= this.minY || oldY >= this.maxY;\n            }\n            existing.setY(item.getY());\n\n            if (iterate) {\n                findBoundsByIteration();\n            }\n            else if (item.getY() != null) {\n                double yy = item.getY().doubleValue();\n                this.minY = minIgnoreNaN(this.minY, yy);\n                this.maxY = minIgnoreNaN(this.maxY, yy);\n            }\n        }\n        else {\n            // if the series is sorted, the negative index is a result from\n            // Collections.binarySearch() and tells us where to insert the\n            // new item...otherwise it will be just -1 and we should just\n            // append the value to the list...\n            item = (XYDataItem) item.clone();\n            if (this.autoSort) {\nthis.data.add((iterate - 1), item);\n            }\n            else {\n                this.data.add(item);\n            }\n            updateBoundsForAddedItem(item);\n\n            // check if this addition will exceed the maximum item count...\n            if (getItemCount() > this.maximumItemCount) {\n                XYDataItem removed = (XYDataItem) this.data.remove(0);\n                updateBoundsForRemovedItem(removed);\n            }\n        }\n        fireSeriesChanged();\n        return overwritten;\n    }",
          "8": "    public XYDataItem addOrUpdate(XYDataItem item) {\n        if (item == null) {\n            throw new IllegalArgumentException(\"Null 'item' argument.\");\n        }\n        if (this.allowDuplicateXValues) {\n            add(item);\n            return null;\n        }\n\n        // if we get to here, we know that duplicate X values are not permitted\n        XYDataItem overwritten = null;\n        int index = indexOf(item.getX());\n        if (index >= 0) {\n            XYDataItem existing = (XYDataItem) this.data.get(index);\n            overwritten = (XYDataItem) existing.clone();\n            // figure out if we need to iterate through all the y-values\n            boolean iterate = false;\n            double oldY = existing.getYValue();\n            if (!Double.isNaN(oldY)) {\n                iterate = oldY <= this.minY || oldY >= this.maxY;\n            }\n            existing.setY(item.getY());\n\n            if (iterate) {\n                findBoundsByIteration();\n            }\n            else if (item.getY() != null) {\n                double yy = item.getY().doubleValue();\n                this.minY = minIgnoreNaN(this.minY, yy);\n                this.maxY = minIgnoreNaN(this.maxY, yy);\n            }\n        }\n        else {\n            // if the series is sorted, the negative index is a result from\n            // Collections.binarySearch() and tells us where to insert the\n            // new item...otherwise it will be just -1 and we should just\n            // append the value to the list...\n            item = (XYDataItem) item.clone();\n            if (this.autoSort) {\nupdateBoundsForRemovedItem(removed);\n            }\n            else {\n                this.data.add(item);\n            }\n            updateBoundsForAddedItem(item);\n\n            // check if this addition will exceed the maximum item count...\n            if (getItemCount() > this.maximumItemCount) {\n                XYDataItem removed = (XYDataItem) this.data.remove(0);\n                updateBoundsForRemovedItem(removed);\n            }\n        }\n        fireSeriesChanged();\n        return overwritten;\n    }",
          "9": "    public XYDataItem addOrUpdate(XYDataItem item) {\n        if (item == null) {\n            throw new IllegalArgumentException(\"Null 'item' argument.\");\n        }\n        if (this.allowDuplicateXValues) {\n            add(item);\n            return null;\n        }\n\n        // if we get to here, we know that duplicate X values are not permitted\n        XYDataItem overwritten = null;\n        int index = indexOf(item.getX());\n        if (index >= 0) {\n            XYDataItem existing = (XYDataItem) this.data.get(index);\n            overwritten = (XYDataItem) existing.clone();\n            // figure out if we need to iterate through all the y-values\n            boolean iterate = false;\n            double oldY = existing.getYValue();\n            if (!Double.isNaN(oldY)) {\n                iterate = oldY <= this.minY || oldY >= this.maxY;\n            }\n            existing.setY(item.getY());\n\n            if (iterate) {\n                findBoundsByIteration();\n            }\n            else if (item.getY() != null) {\n                double yy = item.getY().doubleValue();\n                this.minY = minIgnoreNaN(this.minY, yy);\n                this.maxY = minIgnoreNaN(this.maxY, yy);\n            }\n        }\n        else {\n            // if the series is sorted, the negative index is a result from\n            // Collections.binarySearch() and tells us where to insert the\n            // new item...otherwise it will be just -1 and we should just\n            // append the value to the list...\n            item = (XYDataItem) item.clone();\n            if (this.autoSort) {\nadd(item);\n            }\n            else {\n                this.data.add(item);\n            }\n            updateBoundsForAddedItem(item);\n\n            // check if this addition will exceed the maximum item count...\n            if (getItemCount() > this.maximumItemCount) {\n                XYDataItem removed = (XYDataItem) this.data.remove(0);\n                updateBoundsForRemovedItem(removed);\n            }\n        }\n        fireSeriesChanged();\n        return overwritten;\n    }",
          "10": "    public XYDataItem addOrUpdate(XYDataItem item) {\n        if (item == null) {\n            throw new IllegalArgumentException(\"Null 'item' argument.\");\n        }\n        if (this.allowDuplicateXValues) {\n            add(item);\n            return null;\n        }\n\n        // if we get to here, we know that duplicate X values are not permitted\n        XYDataItem overwritten = null;\n        int index = indexOf(item.getX());\n        if (index >= 0) {\n            XYDataItem existing = (XYDataItem) this.data.get(index);\n            overwritten = (XYDataItem) existing.clone();\n            // figure out if we need to iterate through all the y-values\n            boolean iterate = false;\n            double oldY = existing.getYValue();\n            if (!Double.isNaN(oldY)) {\n                iterate = oldY <= this.minY || oldY >= this.maxY;\n            }\n            existing.setY(item.getY());\n\n            if (iterate) {\n                findBoundsByIteration();\n            }\n            else if (item.getY() != null) {\n                double yy = item.getY().doubleValue();\n                this.minY = minIgnoreNaN(this.minY, yy);\n                this.maxY = minIgnoreNaN(this.maxY, yy);\n            }\n        }\n        else {\n            // if the series is sorted, the negative index is a result from\n            // Collections.binarySearch() and tells us where to insert the\n            // new item...otherwise it will be just -1 and we should just\n            // append the value to the list...\n            item = (XYDataItem) item.clone();\n            if (this.autoSort) {\nthis.maxY = minIgnoreNaN(this.maxY, yy);\n            }\n            else {\n                this.data.add(item);\n            }\n            updateBoundsForAddedItem(item);\n\n            // check if this addition will exceed the maximum item count...\n            if (getItemCount() > this.maximumItemCount) {\n                XYDataItem removed = (XYDataItem) this.data.remove(0);\n                updateBoundsForRemovedItem(removed);\n            }\n        }\n        fireSeriesChanged();\n        return overwritten;\n    }",
          "11": "    public XYDataItem addOrUpdate(XYDataItem item) {\n        if (item == null) {\n            throw new IllegalArgumentException(\"Null 'item' argument.\");\n        }\n        if (this.allowDuplicateXValues) {\n            add(item);\n            return null;\n        }\n\n        // if we get to here, we know that duplicate X values are not permitted\n        XYDataItem overwritten = null;\n        int index = indexOf(item.getX());\n        if (index >= 0) {\n            XYDataItem existing = (XYDataItem) this.data.get(index);\n            overwritten = (XYDataItem) existing.clone();\n            // figure out if we need to iterate through all the y-values\n            boolean iterate = false;\n            double oldY = existing.getYValue();\n            if (!Double.isNaN(oldY)) {\n                iterate = oldY <= this.minY || oldY >= this.maxY;\n            }\n            existing.setY(item.getY());\n\n            if (iterate) {\n                findBoundsByIteration();\n            }\n            else if (item.getY() != null) {\n                double yy = item.getY().doubleValue();\n                this.minY = minIgnoreNaN(this.minY, yy);\n                this.maxY = minIgnoreNaN(this.maxY, yy);\n            }\n        }\n        else {\n            // if the series is sorted, the negative index is a result from\n            // Collections.binarySearch() and tells us where to insert the\n            // new item...otherwise it will be just -1 and we should just\n            // append the value to the list...\n            item = (XYDataItem) item.clone();\n            if (this.autoSort) {\nthis.data.add((~index <= 1), item);\n            }\n            else {\n                this.data.add(item);\n            }\n            updateBoundsForAddedItem(item);\n\n            // check if this addition will exceed the maximum item count...\n            if (getItemCount() > this.maximumItemCount) {\n                XYDataItem removed = (XYDataItem) this.data.remove(0);\n                updateBoundsForRemovedItem(removed);\n            }\n        }\n        fireSeriesChanged();\n        return overwritten;\n    }",
          "12": "    public XYDataItem addOrUpdate(XYDataItem item) {\n        if (item == null) {\n            throw new IllegalArgumentException(\"Null 'item' argument.\");\n        }\n        if (this.allowDuplicateXValues) {\n            add(item);\n            return null;\n        }\n\n        // if we get to here, we know that duplicate X values are not permitted\n        XYDataItem overwritten = null;\n        int index = indexOf(item.getX());\n        if (index >= 0) {\n            XYDataItem existing = (XYDataItem) this.data.get(index);\n            overwritten = (XYDataItem) existing.clone();\n            // figure out if we need to iterate through all the y-values\n            boolean iterate = false;\n            double oldY = existing.getYValue();\n            if (!Double.isNaN(oldY)) {\n                iterate = oldY <= this.minY || oldY >= this.maxY;\n            }\n            existing.setY(item.getY());\n\n            if (iterate) {\n                findBoundsByIteration();\n            }\n            else if (item.getY() != null) {\n                double yy = item.getY().doubleValue();\n                this.minY = minIgnoreNaN(this.minY, yy);\n                this.maxY = minIgnoreNaN(this.maxY, yy);\n            }\n        }\n        else {\n            // if the series is sorted, the negative index is a result from\n            // Collections.binarySearch() and tells us where to insert the\n            // new item...otherwise it will be just -1 and we should just\n            // append the value to the list...\n            item = (XYDataItem) item.clone();\n            if (this.autoSort) {\nthis.minY = minIgnoreNaN(this.minY, yy);\n            }\n            else {\n                this.data.add(item);\n            }\n            updateBoundsForAddedItem(item);\n\n            // check if this addition will exceed the maximum item count...\n            if (getItemCount() > this.maximumItemCount) {\n                XYDataItem removed = (XYDataItem) this.data.remove(0);\n                updateBoundsForRemovedItem(removed);\n            }\n        }\n        fireSeriesChanged();\n        return overwritten;\n    }",
          "13": "    public XYDataItem addOrUpdate(XYDataItem item) {\n        if (item == null) {\n            throw new IllegalArgumentException(\"Null 'item' argument.\");\n        }\n        if (this.allowDuplicateXValues) {\n            add(item);\n            return null;\n        }\n\n        // if we get to here, we know that duplicate X values are not permitted\n        XYDataItem overwritten = null;\n        int index = indexOf(item.getX());\n        if (index >= 0) {\n            XYDataItem existing = (XYDataItem) this.data.get(index);\n            overwritten = (XYDataItem) existing.clone();\n            // figure out if we need to iterate through all the y-values\n            boolean iterate = false;\n            double oldY = existing.getYValue();\n            if (!Double.isNaN(oldY)) {\n                iterate = oldY <= this.minY || oldY >= this.maxY;\n            }\n            existing.setY(item.getY());\n\n            if (iterate) {\n                findBoundsByIteration();\n            }\n            else if (item.getY() != null) {\n                double yy = item.getY().doubleValue();\n                this.minY = minIgnoreNaN(this.minY, yy);\n                this.maxY = minIgnoreNaN(this.maxY, yy);\n            }\n        }\n        else {\n            // if the series is sorted, the negative index is a result from\n            // Collections.binarySearch() and tells us where to insert the\n            // new item...otherwise it will be just -1 and we should just\n            // append the value to the list...\n            item = (XYDataItem) item.clone();\n            if (this.autoSort) {\nthis.data.add(index);\n            }\n            else {\n                this.data.add(item);\n            }\n            updateBoundsForAddedItem(item);\n\n            // check if this addition will exceed the maximum item count...\n            if (getItemCount() > this.maximumItemCount) {\n                XYDataItem removed = (XYDataItem) this.data.remove(0);\n                updateBoundsForRemovedItem(removed);\n            }\n        }\n        fireSeriesChanged();\n        return overwritten;\n    }",
          "14": "    public XYDataItem addOrUpdate(XYDataItem item) {\n        if (item == null) {\n            throw new IllegalArgumentException(\"Null 'item' argument.\");\n        }\n        if (this.allowDuplicateXValues) {\n            add(item);\n            return null;\n        }\n\n        // if we get to here, we know that duplicate X values are not permitted\n        XYDataItem overwritten = null;\n        int index = indexOf(item.getX());\n        if (index >= 0) {\n            XYDataItem existing = (XYDataItem) this.data.get(index);\n            overwritten = (XYDataItem) existing.clone();\n            // figure out if we need to iterate through all the y-values\n            boolean iterate = false;\n            double oldY = existing.getYValue();\n            if (!Double.isNaN(oldY)) {\n                iterate = oldY <= this.minY || oldY >= this.maxY;\n            }\n            existing.setY(item.getY());\n\n            if (iterate) {\n                findBoundsByIteration();\n            }\n            else if (item.getY() != null) {\n                double yy = item.getY().doubleValue();\n                this.minY = minIgnoreNaN(this.minY, yy);\n                this.maxY = minIgnoreNaN(this.maxY, yy);\n            }\n        }\n        else {\n            // if the series is sorted, the negative index is a result from\n            // Collections.binarySearch() and tells us where to insert the\n            // new item...otherwise it will be just -1 and we should just\n            // append the value to the list...\n            item = (XYDataItem) item.clone();\n            if (this.autoSort) {\nthis.iterate.add((~index - 1), item);\n            }\n            else {\n                this.data.add(item);\n            }\n            updateBoundsForAddedItem(item);\n\n            // check if this addition will exceed the maximum item count...\n            if (getItemCount() > this.maximumItemCount) {\n                XYDataItem removed = (XYDataItem) this.data.remove(0);\n                updateBoundsForRemovedItem(removed);\n            }\n        }\n        fireSeriesChanged();\n        return overwritten;\n    }",
          "15": "    public XYDataItem addOrUpdate(XYDataItem item) {\n        if (item == null) {\n            throw new IllegalArgumentException(\"Null 'item' argument.\");\n        }\n        if (this.allowDuplicateXValues) {\n            add(item);\n            return null;\n        }\n\n        // if we get to here, we know that duplicate X values are not permitted\n        XYDataItem overwritten = null;\n        int index = indexOf(item.getX());\n        if (index >= 0) {\n            XYDataItem existing = (XYDataItem) this.data.get(index);\n            overwritten = (XYDataItem) existing.clone();\n            // figure out if we need to iterate through all the y-values\n            boolean iterate = false;\n            double oldY = existing.getYValue();\n            if (!Double.isNaN(oldY)) {\n                iterate = oldY <= this.minY || oldY >= this.maxY;\n            }\n            existing.setY(item.getY());\n\n            if (iterate) {\n                findBoundsByIteration();\n            }\n            else if (item.getY() != null) {\n                double yy = item.getY().doubleValue();\n                this.minY = minIgnoreNaN(this.minY, yy);\n                this.maxY = minIgnoreNaN(this.maxY, yy);\n            }\n        }\n        else {\n            // if the series is sorted, the negative index is a result from\n            // Collections.binarySearch() and tells us where to insert the\n            // new item...otherwise it will be just -1 and we should just\n            // append the value to the list...\n            item = (XYDataItem) item.clone();\n            if (this.autoSort) {\nthis.item.add(index, (~index - 1));\n            }\n            else {\n                this.data.add(item);\n            }\n            updateBoundsForAddedItem(item);\n\n            // check if this addition will exceed the maximum item count...\n            if (getItemCount() > this.maximumItemCount) {\n                XYDataItem removed = (XYDataItem) this.data.remove(0);\n                updateBoundsForRemovedItem(removed);\n            }\n        }\n        fireSeriesChanged();\n        return overwritten;\n    }",
          "16": "    public XYDataItem addOrUpdate(XYDataItem item) {\n        if (item == null) {\n            throw new IllegalArgumentException(\"Null 'item' argument.\");\n        }\n        if (this.allowDuplicateXValues) {\n            add(item);\n            return null;\n        }\n\n        // if we get to here, we know that duplicate X values are not permitted\n        XYDataItem overwritten = null;\n        int index = indexOf(item.getX());\n        if (index >= 0) {\n            XYDataItem existing = (XYDataItem) this.data.get(index);\n            overwritten = (XYDataItem) existing.clone();\n            // figure out if we need to iterate through all the y-values\n            boolean iterate = false;\n            double oldY = existing.getYValue();\n            if (!Double.isNaN(oldY)) {\n                iterate = oldY <= this.minY || oldY >= this.maxY;\n            }\n            existing.setY(item.getY());\n\n            if (iterate) {\n                findBoundsByIteration();\n            }\n            else if (item.getY() != null) {\n                double yy = item.getY().doubleValue();\n                this.minY = minIgnoreNaN(this.minY, yy);\n                this.maxY = minIgnoreNaN(this.maxY, yy);\n            }\n        }\n        else {\n            // if the series is sorted, the negative index is a result from\n            // Collections.binarySearch() and tells us where to insert the\n            // new item...otherwise it will be just -1 and we should just\n            // append the value to the list...\n            item = (XYDataItem) item.clone();\n            if (this.autoSort) {\nthis.data.add((~index - 1), item);\n            }\n            else {\n                this.data.add(item);\n            }\n            updateBoundsForAddedItem(item);\n\n            // check if this addition will exceed the maximum item count...\n            if (getItemCount() > this.maximumItemCount) {\n                XYDataItem removed = (XYDataItem) this.data.remove(0);\n                updateBoundsForRemovedItem(removed);\n            }\n        }\n        fireSeriesChanged();\n        return overwritten;\n    }",
          "17": "    public XYDataItem addOrUpdate(XYDataItem item) {\n        if (item == null) {\n            throw new IllegalArgumentException(\"Null 'item' argument.\");\n        }\n        if (this.allowDuplicateXValues) {\n            add(item);\n            return null;\n        }\n\n        // if we get to here, we know that duplicate X values are not permitted\n        XYDataItem overwritten = null;\n        int index = indexOf(item.getX());\n        if (index >= 0) {\n            XYDataItem existing = (XYDataItem) this.data.get(index);\n            overwritten = (XYDataItem) existing.clone();\n            // figure out if we need to iterate through all the y-values\n            boolean iterate = false;\n            double oldY = existing.getYValue();\n            if (!Double.isNaN(oldY)) {\n                iterate = oldY <= this.minY || oldY >= this.maxY;\n            }\n            existing.setY(item.getY());\n\n            if (iterate) {\n                findBoundsByIteration();\n            }\n            else if (item.getY() != null) {\n                double yy = item.getY().doubleValue();\n                this.minY = minIgnoreNaN(this.minY, yy);\n                this.maxY = minIgnoreNaN(this.maxY, yy);\n            }\n        }\n        else {\n            // if the series is sorted, the negative index is a result from\n            // Collections.binarySearch() and tells us where to insert the\n            // new item...otherwise it will be just -1 and we should just\n            // append the value to the list...\n            item = (XYDataItem) item.clone();\n            if (this.autoSort) {\nthis.data.add(item);\n            }\n            else {\n                this.data.add(item);\n            }\n            updateBoundsForAddedItem(item);\n\n            // check if this addition will exceed the maximum item count...\n            if (getItemCount() > this.maximumItemCount) {\n                XYDataItem removed = (XYDataItem) this.data.remove(0);\n                updateBoundsForRemovedItem(removed);\n            }\n        }\n        fireSeriesChanged();\n        return overwritten;\n    }",
          "18": "    public XYDataItem addOrUpdate(XYDataItem item) {\n        if (item == null) {\n            throw new IllegalArgumentException(\"Null 'item' argument.\");\n        }\n        if (this.allowDuplicateXValues) {\n            add(item);\n            return null;\n        }\n\n        // if we get to here, we know that duplicate X values are not permitted\n        XYDataItem overwritten = null;\n        int index = indexOf(item.getX());\n        if (index >= 0) {\n            XYDataItem existing = (XYDataItem) this.data.get(index);\n            overwritten = (XYDataItem) existing.clone();\n            // figure out if we need to iterate through all the y-values\n            boolean iterate = false;\n            double oldY = existing.getYValue();\n            if (!Double.isNaN(oldY)) {\n                iterate = oldY <= this.minY || oldY >= this.maxY;\n            }\n            existing.setY(item.getY());\n\n            if (iterate) {\n                findBoundsByIteration();\n            }\n            else if (item.getY() != null) {\n                double yy = item.getY().doubleValue();\n                this.minY = minIgnoreNaN(this.minY, yy);\n                this.maxY = minIgnoreNaN(this.maxY, yy);\n            }\n        }\n        else {\n            // if the series is sorted, the negative index is a result from\n            // Collections.binarySearch() and tells us where to insert the\n            // new item...otherwise it will be just -1 and we should just\n            // append the value to the list...\n            item = (XYDataItem) item.clone();\n            if (this.autoSort) {\nthis.item.add((~index - 1));\n            }\n            else {\n                this.data.add(item);\n            }\n            updateBoundsForAddedItem(item);\n\n            // check if this addition will exceed the maximum item count...\n            if (getItemCount() > this.maximumItemCount) {\n                XYDataItem removed = (XYDataItem) this.data.remove(0);\n                updateBoundsForRemovedItem(removed);\n            }\n        }\n        fireSeriesChanged();\n        return overwritten;\n    }",
          "19": "    public XYDataItem addOrUpdate(XYDataItem item) {\n        if (item == null) {\n            throw new IllegalArgumentException(\"Null 'item' argument.\");\n        }\n        if (this.allowDuplicateXValues) {\n            add(item);\n            return null;\n        }\n\n        // if we get to here, we know that duplicate X values are not permitted\n        XYDataItem overwritten = null;\n        int index = indexOf(item.getX());\n        if (index >= 0) {\n            XYDataItem existing = (XYDataItem) this.data.get(index);\n            overwritten = (XYDataItem) existing.clone();\n            // figure out if we need to iterate through all the y-values\n            boolean iterate = false;\n            double oldY = existing.getYValue();\n            if (!Double.isNaN(oldY)) {\n                iterate = oldY <= this.minY || oldY >= this.maxY;\n            }\n            existing.setY(item.getY());\n\n            if (iterate) {\n                findBoundsByIteration();\n            }\n            else if (item.getY() != null) {\n                double yy = item.getY().doubleValue();\n                this.minY = minIgnoreNaN(this.minY, yy);\n                this.maxY = minIgnoreNaN(this.maxY, yy);\n            }\n        }\n        else {\n            // if the series is sorted, the negative index is a result from\n            // Collections.binarySearch() and tells us where to insert the\n            // new item...otherwise it will be just -1 and we should just\n            // append the value to the list...\n            item = (XYDataItem) item.clone();\n            if (this.autoSort) {\nupdateBoundsForRemovedItem(removed);\n                this.data.add(~index - 1, item);            }\n            else {\n                this.data.add(item);\n            }\n            updateBoundsForAddedItem(item);\n\n            // check if this addition will exceed the maximum item count...\n            if (getItemCount() > this.maximumItemCount) {\n                XYDataItem removed = (XYDataItem) this.data.remove(0);\n                updateBoundsForRemovedItem(removed);\n            }\n        }\n        fireSeriesChanged();\n        return overwritten;\n    }",
          "20": "    public XYDataItem addOrUpdate(XYDataItem item) {\n        if (item == null) {\n            throw new IllegalArgumentException(\"Null 'item' argument.\");\n        }\n        if (this.allowDuplicateXValues) {\n            add(item);\n            return null;\n        }\n\n        // if we get to here, we know that duplicate X values are not permitted\n        XYDataItem overwritten = null;\n        int index = indexOf(item.getX());\n        if (index >= 0) {\n            XYDataItem existing = (XYDataItem) this.data.get(index);\n            overwritten = (XYDataItem) existing.clone();\n            // figure out if we need to iterate through all the y-values\n            boolean iterate = false;\n            double oldY = existing.getYValue();\n            if (!Double.isNaN(oldY)) {\n                iterate = oldY <= this.minY || oldY >= this.maxY;\n            }\n            existing.setY(item.getY());\n\n            if (iterate) {\n                findBoundsByIteration();\n            }\n            else if (item.getY() != null) {\n                double yy = item.getY().doubleValue();\n                this.minY = minIgnoreNaN(this.minY, yy);\n                this.maxY = minIgnoreNaN(this.maxY, yy);\n            }\n        }\n        else {\n            // if the series is sorted, the negative index is a result from\n            // Collections.binarySearch() and tells us where to insert the\n            // new item...otherwise it will be just -1 and we should just\n            // append the value to the list...\n            item = (XYDataItem) item.clone();\n            if (this.autoSort) {\nthis.data.add((~index == 1), item);\n            }\n            else {\n                this.data.add(item);\n            }\n            updateBoundsForAddedItem(item);\n\n            // check if this addition will exceed the maximum item count...\n            if (getItemCount() > this.maximumItemCount) {\n                XYDataItem removed = (XYDataItem) this.data.remove(0);\n                updateBoundsForRemovedItem(removed);\n            }\n        }\n        fireSeriesChanged();\n        return overwritten;\n    }",
          "21": "    public XYDataItem addOrUpdate(XYDataItem item) {\n        if (item == null) {\n            throw new IllegalArgumentException(\"Null 'item' argument.\");\n        }\n        if (this.allowDuplicateXValues) {\n            add(item);\n            return null;\n        }\n\n        // if we get to here, we know that duplicate X values are not permitted\n        XYDataItem overwritten = null;\n        int index = indexOf(item.getX());\n        if (index >= 0) {\n            XYDataItem existing = (XYDataItem) this.data.get(index);\n            overwritten = (XYDataItem) existing.clone();\n            // figure out if we need to iterate through all the y-values\n            boolean iterate = false;\n            double oldY = existing.getYValue();\n            if (!Double.isNaN(oldY)) {\n                iterate = oldY <= this.minY || oldY >= this.maxY;\n            }\n            existing.setY(item.getY());\n\n            if (iterate) {\n                findBoundsByIteration();\n            }\n            else if (item.getY() != null) {\n                double yy = item.getY().doubleValue();\n                this.minY = minIgnoreNaN(this.minY, yy);\n                this.maxY = minIgnoreNaN(this.maxY, yy);\n            }\n        }\n        else {\n            // if the series is sorted, the negative index is a result from\n            // Collections.binarySearch() and tells us where to insert the\n            // new item...otherwise it will be just -1 and we should just\n            // append the value to the list...\n            item = (XYDataItem) item.clone();\n            if (this.autoSort) {\nitem = (XYDataItem)item.clone();\n            }\n            else {\n                this.data.add(item);\n            }\n            updateBoundsForAddedItem(item);\n\n            // check if this addition will exceed the maximum item count...\n            if (getItemCount() > this.maximumItemCount) {\n                XYDataItem removed = (XYDataItem) this.data.remove(0);\n                updateBoundsForRemovedItem(removed);\n            }\n        }\n        fireSeriesChanged();\n        return overwritten;\n    }",
          "22": "    public XYDataItem addOrUpdate(XYDataItem item) {\n        if (item == null) {\n            throw new IllegalArgumentException(\"Null 'item' argument.\");\n        }\n        if (this.allowDuplicateXValues) {\n            add(item);\n            return null;\n        }\n\n        // if we get to here, we know that duplicate X values are not permitted\n        XYDataItem overwritten = null;\n        int index = indexOf(item.getX());\n        if (index >= 0) {\n            XYDataItem existing = (XYDataItem) this.data.get(index);\n            overwritten = (XYDataItem) existing.clone();\n            // figure out if we need to iterate through all the y-values\n            boolean iterate = false;\n            double oldY = existing.getYValue();\n            if (!Double.isNaN(oldY)) {\n                iterate = oldY <= this.minY || oldY >= this.maxY;\n            }\n            existing.setY(item.getY());\n\n            if (iterate) {\n                findBoundsByIteration();\n            }\n            else if (item.getY() != null) {\n                double yy = item.getY().doubleValue();\n                this.minY = minIgnoreNaN(this.minY, yy);\n                this.maxY = minIgnoreNaN(this.maxY, yy);\n            }\n        }\n        else {\n            // if the series is sorted, the negative index is a result from\n            // Collections.binarySearch() and tells us where to insert the\n            // new item...otherwise it will be just -1 and we should just\n            // append the value to the list...\n            item = (XYDataItem) item.clone();\n            if (this.autoSort) {\nthis.data.add((~index - 1), iterate);\n            }\n            else {\n                this.data.add(item);\n            }\n            updateBoundsForAddedItem(item);\n\n            // check if this addition will exceed the maximum item count...\n            if (getItemCount() > this.maximumItemCount) {\n                XYDataItem removed = (XYDataItem) this.data.remove(0);\n                updateBoundsForRemovedItem(removed);\n            }\n        }\n        fireSeriesChanged();\n        return overwritten;\n    }",
          "23": "    public XYDataItem addOrUpdate(XYDataItem item) {\n        if (item == null) {\n            throw new IllegalArgumentException(\"Null 'item' argument.\");\n        }\n        if (this.allowDuplicateXValues) {\n            add(item);\n            return null;\n        }\n\n        // if we get to here, we know that duplicate X values are not permitted\n        XYDataItem overwritten = null;\n        int index = indexOf(item.getX());\n        if (index >= 0) {\n            XYDataItem existing = (XYDataItem) this.data.get(index);\n            overwritten = (XYDataItem) existing.clone();\n            // figure out if we need to iterate through all the y-values\n            boolean iterate = false;\n            double oldY = existing.getYValue();\n            if (!Double.isNaN(oldY)) {\n                iterate = oldY <= this.minY || oldY >= this.maxY;\n            }\n            existing.setY(item.getY());\n\n            if (iterate) {\n                findBoundsByIteration();\n            }\n            else if (item.getY() != null) {\n                double yy = item.getY().doubleValue();\n                this.minY = minIgnoreNaN(this.minY, yy);\n                this.maxY = minIgnoreNaN(this.maxY, yy);\n            }\n        }\n        else {\n            // if the series is sorted, the negative index is a result from\n            // Collections.binarySearch() and tells us where to insert the\n            // new item...otherwise it will be just -1 and we should just\n            // append the value to the list...\n            item = (XYDataItem) item.clone();\n            if (this.autoSort) {\nfindBoundsByIteration();\n                this.data.add(~index - 1, item);            }\n            else {\n                this.data.add(item);\n            }\n            updateBoundsForAddedItem(item);\n\n            // check if this addition will exceed the maximum item count...\n            if (getItemCount() > this.maximumItemCount) {\n                XYDataItem removed = (XYDataItem) this.data.remove(0);\n                updateBoundsForRemovedItem(removed);\n            }\n        }\n        fireSeriesChanged();\n        return overwritten;\n    }",
          "24": "    public XYDataItem addOrUpdate(XYDataItem item) {\n        if (item == null) {\n            throw new IllegalArgumentException(\"Null 'item' argument.\");\n        }\n        if (this.allowDuplicateXValues) {\n            add(item);\n            return null;\n        }\n\n        // if we get to here, we know that duplicate X values are not permitted\n        XYDataItem overwritten = null;\n        int index = indexOf(item.getX());\n        if (index >= 0) {\n            XYDataItem existing = (XYDataItem) this.data.get(index);\n            overwritten = (XYDataItem) existing.clone();\n            // figure out if we need to iterate through all the y-values\n            boolean iterate = false;\n            double oldY = existing.getYValue();\n            if (!Double.isNaN(oldY)) {\n                iterate = oldY <= this.minY || oldY >= this.maxY;\n            }\n            existing.setY(item.getY());\n\n            if (iterate) {\n                findBoundsByIteration();\n            }\n            else if (item.getY() != null) {\n                double yy = item.getY().doubleValue();\n                this.minY = minIgnoreNaN(this.minY, yy);\n                this.maxY = minIgnoreNaN(this.maxY, yy);\n            }\n        }\n        else {\n            // if the series is sorted, the negative index is a result from\n            // Collections.binarySearch() and tells us where to insert the\n            // new item...otherwise it will be just -1 and we should just\n            // append the value to the list...\n            item = (XYDataItem) item.clone();\n            if (this.autoSort) {\nclear();\n                this.data.add(~index - 1, item);            }\n            else {\n                this.data.add(item);\n            }\n            updateBoundsForAddedItem(item);\n\n            // check if this addition will exceed the maximum item count...\n            if (getItemCount() > this.maximumItemCount) {\n                XYDataItem removed = (XYDataItem) this.data.remove(0);\n                updateBoundsForRemovedItem(removed);\n            }\n        }\n        fireSeriesChanged();\n        return overwritten;\n    }",
          "25": "    public XYDataItem addOrUpdate(XYDataItem item) {\n        if (item == null) {\n            throw new IllegalArgumentException(\"Null 'item' argument.\");\n        }\n        if (this.allowDuplicateXValues) {\n            add(item);\n            return null;\n        }\n\n        // if we get to here, we know that duplicate X values are not permitted\n        XYDataItem overwritten = null;\n        int index = indexOf(item.getX());\n        if (index >= 0) {\n            XYDataItem existing = (XYDataItem) this.data.get(index);\n            overwritten = (XYDataItem) existing.clone();\n            // figure out if we need to iterate through all the y-values\n            boolean iterate = false;\n            double oldY = existing.getYValue();\n            if (!Double.isNaN(oldY)) {\n                iterate = oldY <= this.minY || oldY >= this.maxY;\n            }\n            existing.setY(item.getY());\n\n            if (iterate) {\n                findBoundsByIteration();\n            }\n            else if (item.getY() != null) {\n                double yy = item.getY().doubleValue();\n                this.minY = minIgnoreNaN(this.minY, yy);\n                this.maxY = minIgnoreNaN(this.maxY, yy);\n            }\n        }\n        else {\n            // if the series is sorted, the negative index is a result from\n            // Collections.binarySearch() and tells us where to insert the\n            // new item...otherwise it will be just -1 and we should just\n            // append the value to the list...\n            item = (XYDataItem) item.clone();\n            if (this.autoSort) {\noverwritten = (XYDataItem)existing.clone();\n            }\n            else {\n                this.data.add(item);\n            }\n            updateBoundsForAddedItem(item);\n\n            // check if this addition will exceed the maximum item count...\n            if (getItemCount() > this.maximumItemCount) {\n                XYDataItem removed = (XYDataItem) this.data.remove(0);\n                updateBoundsForRemovedItem(removed);\n            }\n        }\n        fireSeriesChanged();\n        return overwritten;\n    }",
          "26": "    public XYDataItem addOrUpdate(XYDataItem item) {\n        if (item == null) {\n            throw new IllegalArgumentException(\"Null 'item' argument.\");\n        }\n        if (this.allowDuplicateXValues) {\n            add(item);\n            return null;\n        }\n\n        // if we get to here, we know that duplicate X values are not permitted\n        XYDataItem overwritten = null;\n        int index = indexOf(item.getX());\n        if (index >= 0) {\n            XYDataItem existing = (XYDataItem) this.data.get(index);\n            overwritten = (XYDataItem) existing.clone();\n            // figure out if we need to iterate through all the y-values\n            boolean iterate = false;\n            double oldY = existing.getYValue();\n            if (!Double.isNaN(oldY)) {\n                iterate = oldY <= this.minY || oldY >= this.maxY;\n            }\n            existing.setY(item.getY());\n\n            if (iterate) {\n                findBoundsByIteration();\n            }\n            else if (item.getY() != null) {\n                double yy = item.getY().doubleValue();\n                this.minY = minIgnoreNaN(this.minY, yy);\n                this.maxY = minIgnoreNaN(this.maxY, yy);\n            }\n        }\n        else {\n            // if the series is sorted, the negative index is a result from\n            // Collections.binarySearch() and tells us where to insert the\n            // new item...otherwise it will be just -1 and we should just\n            // append the value to the list...\n            item = (XYDataItem) item.clone();\n            if (this.autoSort) {\nthis.data.add((oldY - 1), item);\n            }\n            else {\n                this.data.add(item);\n            }\n            updateBoundsForAddedItem(item);\n\n            // check if this addition will exceed the maximum item count...\n            if (getItemCount() > this.maximumItemCount) {\n                XYDataItem removed = (XYDataItem) this.data.remove(0);\n                updateBoundsForRemovedItem(removed);\n            }\n        }\n        fireSeriesChanged();\n        return overwritten;\n    }",
          "27": "    public XYDataItem addOrUpdate(XYDataItem item) {\n        if (item == null) {\n            throw new IllegalArgumentException(\"Null 'item' argument.\");\n        }\n        if (this.allowDuplicateXValues) {\n            add(item);\n            return null;\n        }\n\n        // if we get to here, we know that duplicate X values are not permitted\n        XYDataItem overwritten = null;\n        int index = indexOf(item.getX());\n        if (index >= 0) {\n            XYDataItem existing = (XYDataItem) this.data.get(index);\n            overwritten = (XYDataItem) existing.clone();\n            // figure out if we need to iterate through all the y-values\n            boolean iterate = false;\n            double oldY = existing.getYValue();\n            if (!Double.isNaN(oldY)) {\n                iterate = oldY <= this.minY || oldY >= this.maxY;\n            }\n            existing.setY(item.getY());\n\n            if (iterate) {\n                findBoundsByIteration();\n            }\n            else if (item.getY() != null) {\n                double yy = item.getY().doubleValue();\n                this.minY = minIgnoreNaN(this.minY, yy);\n                this.maxY = minIgnoreNaN(this.maxY, yy);\n            }\n        }\n        else {\n            // if the series is sorted, the negative index is a result from\n            // Collections.binarySearch() and tells us where to insert the\n            // new item...otherwise it will be just -1 and we should just\n            // append the value to the list...\n            item = (XYDataItem) item.clone();\n            if (this.autoSort) {\nthis.maxY = minIgnoreNaN(this.maxY, yy);\n                this.data.add(~index - 1, item);            }\n            else {\n                this.data.add(item);\n            }\n            updateBoundsForAddedItem(item);\n\n            // check if this addition will exceed the maximum item count...\n            if (getItemCount() > this.maximumItemCount) {\n                XYDataItem removed = (XYDataItem) this.data.remove(0);\n                updateBoundsForRemovedItem(removed);\n            }\n        }\n        fireSeriesChanged();\n        return overwritten;\n    }",
          "28": "    public XYDataItem addOrUpdate(XYDataItem item) {\n        if (item == null) {\n            throw new IllegalArgumentException(\"Null 'item' argument.\");\n        }\n        if (this.allowDuplicateXValues) {\n            add(item);\n            return null;\n        }\n\n        // if we get to here, we know that duplicate X values are not permitted\n        XYDataItem overwritten = null;\n        int index = indexOf(item.getX());\n        if (index >= 0) {\n            XYDataItem existing = (XYDataItem) this.data.get(index);\n            overwritten = (XYDataItem) existing.clone();\n            // figure out if we need to iterate through all the y-values\n            boolean iterate = false;\n            double oldY = existing.getYValue();\n            if (!Double.isNaN(oldY)) {\n                iterate = oldY <= this.minY || oldY >= this.maxY;\n            }\n            existing.setY(item.getY());\n\n            if (iterate) {\n                findBoundsByIteration();\n            }\n            else if (item.getY() != null) {\n                double yy = item.getY().doubleValue();\n                this.minY = minIgnoreNaN(this.minY, yy);\n                this.maxY = minIgnoreNaN(this.maxY, yy);\n            }\n        }\n        else {\n            // if the series is sorted, the negative index is a result from\n            // Collections.binarySearch() and tells us where to insert the\n            // new item...otherwise it will be just -1 and we should just\n            // append the value to the list...\n            item = (XYDataItem) item.clone();\n            if (this.autoSort) {\nthis.data.add((~index - -1), item);\n            }\n            else {\n                this.data.add(item);\n            }\n            updateBoundsForAddedItem(item);\n\n            // check if this addition will exceed the maximum item count...\n            if (getItemCount() > this.maximumItemCount) {\n                XYDataItem removed = (XYDataItem) this.data.remove(0);\n                updateBoundsForRemovedItem(removed);\n            }\n        }\n        fireSeriesChanged();\n        return overwritten;\n    }",
          "29": "    public XYDataItem addOrUpdate(XYDataItem item) {\n        if (item == null) {\n            throw new IllegalArgumentException(\"Null 'item' argument.\");\n        }\n        if (this.allowDuplicateXValues) {\n            add(item);\n            return null;\n        }\n\n        // if we get to here, we know that duplicate X values are not permitted\n        XYDataItem overwritten = null;\n        int index = indexOf(item.getX());\n        if (index >= 0) {\n            XYDataItem existing = (XYDataItem) this.data.get(index);\n            overwritten = (XYDataItem) existing.clone();\n            // figure out if we need to iterate through all the y-values\n            boolean iterate = false;\n            double oldY = existing.getYValue();\n            if (!Double.isNaN(oldY)) {\n                iterate = oldY <= this.minY || oldY >= this.maxY;\n            }\n            existing.setY(item.getY());\n\n            if (iterate) {\n                findBoundsByIteration();\n            }\n            else if (item.getY() != null) {\n                double yy = item.getY().doubleValue();\n                this.minY = minIgnoreNaN(this.minY, yy);\n                this.maxY = minIgnoreNaN(this.maxY, yy);\n            }\n        }\n        else {\n            // if the series is sorted, the negative index is a result from\n            // Collections.binarySearch() and tells us where to insert the\n            // new item...otherwise it will be just -1 and we should just\n            // append the value to the list...\n            item = (XYDataItem) item.clone();\n            if (this.autoSort) {\nthis.maxY.add((~index - 1), item);\n            }\n            else {\n                this.data.add(item);\n            }\n            updateBoundsForAddedItem(item);\n\n            // check if this addition will exceed the maximum item count...\n            if (getItemCount() > this.maximumItemCount) {\n                XYDataItem removed = (XYDataItem) this.data.remove(0);\n                updateBoundsForRemovedItem(removed);\n            }\n        }\n        fireSeriesChanged();\n        return overwritten;\n    }",
          "30": "    public XYDataItem addOrUpdate(XYDataItem item) {\n        if (item == null) {\n            throw new IllegalArgumentException(\"Null 'item' argument.\");\n        }\n        if (this.allowDuplicateXValues) {\n            add(item);\n            return null;\n        }\n\n        // if we get to here, we know that duplicate X values are not permitted\n        XYDataItem overwritten = null;\n        int index = indexOf(item.getX());\n        if (index >= 0) {\n            XYDataItem existing = (XYDataItem) this.data.get(index);\n            overwritten = (XYDataItem) existing.clone();\n            // figure out if we need to iterate through all the y-values\n            boolean iterate = false;\n            double oldY = existing.getYValue();\n            if (!Double.isNaN(oldY)) {\n                iterate = oldY <= this.minY || oldY >= this.maxY;\n            }\n            existing.setY(item.getY());\n\n            if (iterate) {\n                findBoundsByIteration();\n            }\n            else if (item.getY() != null) {\n                double yy = item.getY().doubleValue();\n                this.minY = minIgnoreNaN(this.minY, yy);\n                this.maxY = minIgnoreNaN(this.maxY, yy);\n            }\n        }\n        else {\n            // if the series is sorted, the negative index is a result from\n            // Collections.binarySearch() and tells us where to insert the\n            // new item...otherwise it will be just -1 and we should just\n            // append the value to the list...\n            item = (XYDataItem) item.clone();\n            if (this.autoSort) {\niterate = ((oldY <= this.minY) || (oldY >= this.maxY));\n                this.data.add(~index - 1, item);            }\n            else {\n                this.data.add(item);\n            }\n            updateBoundsForAddedItem(item);\n\n            // check if this addition will exceed the maximum item count...\n            if (getItemCount() > this.maximumItemCount) {\n                XYDataItem removed = (XYDataItem) this.data.remove(0);\n                updateBoundsForRemovedItem(removed);\n            }\n        }\n        fireSeriesChanged();\n        return overwritten;\n    }",
          "31": "    public XYDataItem addOrUpdate(XYDataItem item) {\n        if (item == null) {\n            throw new IllegalArgumentException(\"Null 'item' argument.\");\n        }\n        if (this.allowDuplicateXValues) {\n            add(item);\n            return null;\n        }\n\n        // if we get to here, we know that duplicate X values are not permitted\n        XYDataItem overwritten = null;\n        int index = indexOf(item.getX());\n        if (index >= 0) {\n            XYDataItem existing = (XYDataItem) this.data.get(index);\n            overwritten = (XYDataItem) existing.clone();\n            // figure out if we need to iterate through all the y-values\n            boolean iterate = false;\n            double oldY = existing.getYValue();\n            if (!Double.isNaN(oldY)) {\n                iterate = oldY <= this.minY || oldY >= this.maxY;\n            }\n            existing.setY(item.getY());\n\n            if (iterate) {\n                findBoundsByIteration();\n            }\n            else if (item.getY() != null) {\n                double yy = item.getY().doubleValue();\n                this.minY = minIgnoreNaN(this.minY, yy);\n                this.maxY = minIgnoreNaN(this.maxY, yy);\n            }\n        }\n        else {\n            // if the series is sorted, the negative index is a result from\n            // Collections.binarySearch() and tells us where to insert the\n            // new item...otherwise it will be just -1 and we should just\n            // append the value to the list...\n            item = (XYDataItem) item.clone();\n            if (this.autoSort) {\nthis.data.add((~index - 0), item);\n            }\n            else {\n                this.data.add(item);\n            }\n            updateBoundsForAddedItem(item);\n\n            // check if this addition will exceed the maximum item count...\n            if (getItemCount() > this.maximumItemCount) {\n                XYDataItem removed = (XYDataItem) this.data.remove(0);\n                updateBoundsForRemovedItem(removed);\n            }\n        }\n        fireSeriesChanged();\n        return overwritten;\n    }",
          "32": "    public XYDataItem addOrUpdate(XYDataItem item) {\n        if (item == null) {\n            throw new IllegalArgumentException(\"Null 'item' argument.\");\n        }\n        if (this.allowDuplicateXValues) {\n            add(item);\n            return null;\n        }\n\n        // if we get to here, we know that duplicate X values are not permitted\n        XYDataItem overwritten = null;\n        int index = indexOf(item.getX());\n        if (index >= 0) {\n            XYDataItem existing = (XYDataItem) this.data.get(index);\n            overwritten = (XYDataItem) existing.clone();\n            // figure out if we need to iterate through all the y-values\n            boolean iterate = false;\n            double oldY = existing.getYValue();\n            if (!Double.isNaN(oldY)) {\n                iterate = oldY <= this.minY || oldY >= this.maxY;\n            }\n            existing.setY(item.getY());\n\n            if (iterate) {\n                findBoundsByIteration();\n            }\n            else if (item.getY() != null) {\n                double yy = item.getY().doubleValue();\n                this.minY = minIgnoreNaN(this.minY, yy);\n                this.maxY = minIgnoreNaN(this.maxY, yy);\n            }\n        }\n        else {\n            // if the series is sorted, the negative index is a result from\n            // Collections.binarySearch() and tells us where to insert the\n            // new item...otherwise it will be just -1 and we should just\n            // append the value to the list...\n            item = (XYDataItem) item.clone();\n            if (this.autoSort) {\nthis.data.add((~index > 1), item);\n            }\n            else {\n                this.data.add(item);\n            }\n            updateBoundsForAddedItem(item);\n\n            // check if this addition will exceed the maximum item count...\n            if (getItemCount() > this.maximumItemCount) {\n                XYDataItem removed = (XYDataItem) this.data.remove(0);\n                updateBoundsForRemovedItem(removed);\n            }\n        }\n        fireSeriesChanged();\n        return overwritten;\n    }",
          "33": "    public XYDataItem addOrUpdate(XYDataItem item) {\n        if (item == null) {\n            throw new IllegalArgumentException(\"Null 'item' argument.\");\n        }\n        if (this.allowDuplicateXValues) {\n            add(item);\n            return null;\n        }\n\n        // if we get to here, we know that duplicate X values are not permitted\n        XYDataItem overwritten = null;\n        int index = indexOf(item.getX());\n        if (index >= 0) {\n            XYDataItem existing = (XYDataItem) this.data.get(index);\n            overwritten = (XYDataItem) existing.clone();\n            // figure out if we need to iterate through all the y-values\n            boolean iterate = false;\n            double oldY = existing.getYValue();\n            if (!Double.isNaN(oldY)) {\n                iterate = oldY <= this.minY || oldY >= this.maxY;\n            }\n            existing.setY(item.getY());\n\n            if (iterate) {\n                findBoundsByIteration();\n            }\n            else if (item.getY() != null) {\n                double yy = item.getY().doubleValue();\n                this.minY = minIgnoreNaN(this.minY, yy);\n                this.maxY = minIgnoreNaN(this.maxY, yy);\n            }\n        }\n        else {\n            // if the series is sorted, the negative index is a result from\n            // Collections.binarySearch() and tells us where to insert the\n            // new item...otherwise it will be just -1 and we should just\n            // append the value to the list...\n            item = (XYDataItem) item.clone();\n            if (this.autoSort) {\nthis.minY = minIgnoreNaN(this.minY, yy);\n                this.data.add(~index - 1, item);            }\n            else {\n                this.data.add(item);\n            }\n            updateBoundsForAddedItem(item);\n\n            // check if this addition will exceed the maximum item count...\n            if (getItemCount() > this.maximumItemCount) {\n                XYDataItem removed = (XYDataItem) this.data.remove(0);\n                updateBoundsForRemovedItem(removed);\n            }\n        }\n        fireSeriesChanged();\n        return overwritten;\n    }",
          "34": "    public XYDataItem addOrUpdate(XYDataItem item) {\n        if (item == null) {\n            throw new IllegalArgumentException(\"Null 'item' argument.\");\n        }\n        if (this.allowDuplicateXValues) {\n            add(item);\n            return null;\n        }\n\n        // if we get to here, we know that duplicate X values are not permitted\n        XYDataItem overwritten = null;\n        int index = indexOf(item.getX());\n        if (index >= 0) {\n            XYDataItem existing = (XYDataItem) this.data.get(index);\n            overwritten = (XYDataItem) existing.clone();\n            // figure out if we need to iterate through all the y-values\n            boolean iterate = false;\n            double oldY = existing.getYValue();\n            if (!Double.isNaN(oldY)) {\n                iterate = oldY <= this.minY || oldY >= this.maxY;\n            }\n            existing.setY(item.getY());\n\n            if (iterate) {\n                findBoundsByIteration();\n            }\n            else if (item.getY() != null) {\n                double yy = item.getY().doubleValue();\n                this.minY = minIgnoreNaN(this.minY, yy);\n                this.maxY = minIgnoreNaN(this.maxY, yy);\n            }\n        }\n        else {\n            // if the series is sorted, the negative index is a result from\n            // Collections.binarySearch() and tells us where to insert the\n            // new item...otherwise it will be just -1 and we should just\n            // append the value to the list...\n            item = (XYDataItem) item.clone();\n            if (this.autoSort) {\nthis.data.add(item);\n                this.data.add(~index - 1, item);            }\n            else {\n                this.data.add(item);\n            }\n            updateBoundsForAddedItem(item);\n\n            // check if this addition will exceed the maximum item count...\n            if (getItemCount() > this.maximumItemCount) {\n                XYDataItem removed = (XYDataItem) this.data.remove(0);\n                updateBoundsForRemovedItem(removed);\n            }\n        }\n        fireSeriesChanged();\n        return overwritten;\n    }",
          "35": "    public XYDataItem addOrUpdate(XYDataItem item) {\n        if (item == null) {\n            throw new IllegalArgumentException(\"Null 'item' argument.\");\n        }\n        if (this.allowDuplicateXValues) {\n            add(item);\n            return null;\n        }\n\n        // if we get to here, we know that duplicate X values are not permitted\n        XYDataItem overwritten = null;\n        int index = indexOf(item.getX());\n        if (index >= 0) {\n            XYDataItem existing = (XYDataItem) this.data.get(index);\n            overwritten = (XYDataItem) existing.clone();\n            // figure out if we need to iterate through all the y-values\n            boolean iterate = false;\n            double oldY = existing.getYValue();\n            if (!Double.isNaN(oldY)) {\n                iterate = oldY <= this.minY || oldY >= this.maxY;\n            }\n            existing.setY(item.getY());\n\n            if (iterate) {\n                findBoundsByIteration();\n            }\n            else if (item.getY() != null) {\n                double yy = item.getY().doubleValue();\n                this.minY = minIgnoreNaN(this.minY, yy);\n                this.maxY = minIgnoreNaN(this.maxY, yy);\n            }\n        }\n        else {\n            // if the series is sorted, the negative index is a result from\n            // Collections.binarySearch() and tells us where to insert the\n            // new item...otherwise it will be just -1 and we should just\n            // append the value to the list...\n            item = (XYDataItem) item.clone();\n            if (this.autoSort) {\nthis.data.add((item - 1), item);\n            }\n            else {\n                this.data.add(item);\n            }\n            updateBoundsForAddedItem(item);\n\n            // check if this addition will exceed the maximum item count...\n            if (getItemCount() > this.maximumItemCount) {\n                XYDataItem removed = (XYDataItem) this.data.remove(0);\n                updateBoundsForRemovedItem(removed);\n            }\n        }\n        fireSeriesChanged();\n        return overwritten;\n    }",
          "36": "    public XYDataItem addOrUpdate(XYDataItem item) {\n        if (item == null) {\n            throw new IllegalArgumentException(\"Null 'item' argument.\");\n        }\n        if (this.allowDuplicateXValues) {\n            add(item);\n            return null;\n        }\n\n        // if we get to here, we know that duplicate X values are not permitted\n        XYDataItem overwritten = null;\n        int index = indexOf(item.getX());\n        if (index >= 0) {\n            XYDataItem existing = (XYDataItem) this.data.get(index);\n            overwritten = (XYDataItem) existing.clone();\n            // figure out if we need to iterate through all the y-values\n            boolean iterate = false;\n            double oldY = existing.getYValue();\n            if (!Double.isNaN(oldY)) {\n                iterate = oldY <= this.minY || oldY >= this.maxY;\n            }\n            existing.setY(item.getY());\n\n            if (iterate) {\n                findBoundsByIteration();\n            }\n            else if (item.getY() != null) {\n                double yy = item.getY().doubleValue();\n                this.minY = minIgnoreNaN(this.minY, yy);\n                this.maxY = minIgnoreNaN(this.maxY, yy);\n            }\n        }\n        else {\n            // if the series is sorted, the negative index is a result from\n            // Collections.binarySearch() and tells us where to insert the\n            // new item...otherwise it will be just -1 and we should just\n            // append the value to the list...\n            item = (XYDataItem) item.clone();\n            if (this.autoSort) {\nthis.data.add((data - 1), item);\n            }\n            else {\n                this.data.add(item);\n            }\n            updateBoundsForAddedItem(item);\n\n            // check if this addition will exceed the maximum item count...\n            if (getItemCount() > this.maximumItemCount) {\n                XYDataItem removed = (XYDataItem) this.data.remove(0);\n                updateBoundsForRemovedItem(removed);\n            }\n        }\n        fireSeriesChanged();\n        return overwritten;\n    }",
          "37": "    public XYDataItem addOrUpdate(XYDataItem item) {\n        if (item == null) {\n            throw new IllegalArgumentException(\"Null 'item' argument.\");\n        }\n        if (this.allowDuplicateXValues) {\n            add(item);\n            return null;\n        }\n\n        // if we get to here, we know that duplicate X values are not permitted\n        XYDataItem overwritten = null;\n        int index = indexOf(item.getX());\n        if (index >= 0) {\n            XYDataItem existing = (XYDataItem) this.data.get(index);\n            overwritten = (XYDataItem) existing.clone();\n            // figure out if we need to iterate through all the y-values\n            boolean iterate = false;\n            double oldY = existing.getYValue();\n            if (!Double.isNaN(oldY)) {\n                iterate = oldY <= this.minY || oldY >= this.maxY;\n            }\n            existing.setY(item.getY());\n\n            if (iterate) {\n                findBoundsByIteration();\n            }\n            else if (item.getY() != null) {\n                double yy = item.getY().doubleValue();\n                this.minY = minIgnoreNaN(this.minY, yy);\n                this.maxY = minIgnoreNaN(this.maxY, yy);\n            }\n        }\n        else {\n            // if the series is sorted, the negative index is a result from\n            // Collections.binarySearch() and tells us where to insert the\n            // new item...otherwise it will be just -1 and we should just\n            // append the value to the list...\n            item = (XYDataItem) item.clone();\n            if (this.autoSort) {\nitem = (XYDataItem)item.clone();\n                this.data.add(~index - 1, item);            }\n            else {\n                this.data.add(item);\n            }\n            updateBoundsForAddedItem(item);\n\n            // check if this addition will exceed the maximum item count...\n            if (getItemCount() > this.maximumItemCount) {\n                XYDataItem removed = (XYDataItem) this.data.remove(0);\n                updateBoundsForRemovedItem(removed);\n            }\n        }\n        fireSeriesChanged();\n        return overwritten;\n    }",
          "38": "    public XYDataItem addOrUpdate(XYDataItem item) {\n        if (item == null) {\n            throw new IllegalArgumentException(\"Null 'item' argument.\");\n        }\n        if (this.allowDuplicateXValues) {\n            add(item);\n            return null;\n        }\n\n        // if we get to here, we know that duplicate X values are not permitted\n        XYDataItem overwritten = null;\n        int index = indexOf(item.getX());\n        if (index >= 0) {\n            XYDataItem existing = (XYDataItem) this.data.get(index);\n            overwritten = (XYDataItem) existing.clone();\n            // figure out if we need to iterate through all the y-values\n            boolean iterate = false;\n            double oldY = existing.getYValue();\n            if (!Double.isNaN(oldY)) {\n                iterate = oldY <= this.minY || oldY >= this.maxY;\n            }\n            existing.setY(item.getY());\n\n            if (iterate) {\n                findBoundsByIteration();\n            }\n            else if (item.getY() != null) {\n                double yy = item.getY().doubleValue();\n                this.minY = minIgnoreNaN(this.minY, yy);\n                this.maxY = minIgnoreNaN(this.maxY, yy);\n            }\n        }\n        else {\n            // if the series is sorted, the negative index is a result from\n            // Collections.binarySearch() and tells us where to insert the\n            // new item...otherwise it will be just -1 and we should just\n            // append the value to the list...\n            item = (XYDataItem) item.clone();\n            if (this.autoSort) {\nthis.item.add(item);\n            }\n            else {\n                this.data.add(item);\n            }\n            updateBoundsForAddedItem(item);\n\n            // check if this addition will exceed the maximum item count...\n            if (getItemCount() > this.maximumItemCount) {\n                XYDataItem removed = (XYDataItem) this.data.remove(0);\n                updateBoundsForRemovedItem(removed);\n            }\n        }\n        fireSeriesChanged();\n        return overwritten;\n    }",
          "39": "    public XYDataItem addOrUpdate(XYDataItem item) {\n        if (item == null) {\n            throw new IllegalArgumentException(\"Null 'item' argument.\");\n        }\n        if (this.allowDuplicateXValues) {\n            add(item);\n            return null;\n        }\n\n        // if we get to here, we know that duplicate X values are not permitted\n        XYDataItem overwritten = null;\n        int index = indexOf(item.getX());\n        if (index >= 0) {\n            XYDataItem existing = (XYDataItem) this.data.get(index);\n            overwritten = (XYDataItem) existing.clone();\n            // figure out if we need to iterate through all the y-values\n            boolean iterate = false;\n            double oldY = existing.getYValue();\n            if (!Double.isNaN(oldY)) {\n                iterate = oldY <= this.minY || oldY >= this.maxY;\n            }\n            existing.setY(item.getY());\n\n            if (iterate) {\n                findBoundsByIteration();\n            }\n            else if (item.getY() != null) {\n                double yy = item.getY().doubleValue();\n                this.minY = minIgnoreNaN(this.minY, yy);\n                this.maxY = minIgnoreNaN(this.maxY, yy);\n            }\n        }\n        else {\n            // if the series is sorted, the negative index is a result from\n            // Collections.binarySearch() and tells us where to insert the\n            // new item...otherwise it will be just -1 and we should just\n            // append the value to the list...\n            item = (XYDataItem) item.clone();\n            if (this.autoSort) {\nthis.data.add((maxY - 1), item);\n            }\n            else {\n                this.data.add(item);\n            }\n            updateBoundsForAddedItem(item);\n\n            // check if this addition will exceed the maximum item count...\n            if (getItemCount() > this.maximumItemCount) {\n                XYDataItem removed = (XYDataItem) this.data.remove(0);\n                updateBoundsForRemovedItem(removed);\n            }\n        }\n        fireSeriesChanged();\n        return overwritten;\n    }",
          "40": "    public XYDataItem addOrUpdate(XYDataItem item) {\n        if (item == null) {\n            throw new IllegalArgumentException(\"Null 'item' argument.\");\n        }\n        if (this.allowDuplicateXValues) {\n            add(item);\n            return null;\n        }\n\n        // if we get to here, we know that duplicate X values are not permitted\n        XYDataItem overwritten = null;\n        int index = indexOf(item.getX());\n        if (index >= 0) {\n            XYDataItem existing = (XYDataItem) this.data.get(index);\n            overwritten = (XYDataItem) existing.clone();\n            // figure out if we need to iterate through all the y-values\n            boolean iterate = false;\n            double oldY = existing.getYValue();\n            if (!Double.isNaN(oldY)) {\n                iterate = oldY <= this.minY || oldY >= this.maxY;\n            }\n            existing.setY(item.getY());\n\n            if (iterate) {\n                findBoundsByIteration();\n            }\n            else if (item.getY() != null) {\n                double yy = item.getY().doubleValue();\n                this.minY = minIgnoreNaN(this.minY, yy);\n                this.maxY = minIgnoreNaN(this.maxY, yy);\n            }\n        }\n        else {\n            // if the series is sorted, the negative index is a result from\n            // Collections.binarySearch() and tells us where to insert the\n            // new item...otherwise it will be just -1 and we should just\n            // append the value to the list...\n            item = (XYDataItem) item.clone();\n            if (this.autoSort) {\nfireSeriesChanged();\n                this.data.add(~index - 1, item);            }\n            else {\n                this.data.add(item);\n            }\n            updateBoundsForAddedItem(item);\n\n            // check if this addition will exceed the maximum item count...\n            if (getItemCount() > this.maximumItemCount) {\n                XYDataItem removed = (XYDataItem) this.data.remove(0);\n                updateBoundsForRemovedItem(removed);\n            }\n        }\n        fireSeriesChanged();\n        return overwritten;\n    }",
          "41": "    public XYDataItem addOrUpdate(XYDataItem item) {\n        if (item == null) {\n            throw new IllegalArgumentException(\"Null 'item' argument.\");\n        }\n        if (this.allowDuplicateXValues) {\n            add(item);\n            return null;\n        }\n\n        // if we get to here, we know that duplicate X values are not permitted\n        XYDataItem overwritten = null;\n        int index = indexOf(item.getX());\n        if (index >= 0) {\n            XYDataItem existing = (XYDataItem) this.data.get(index);\n            overwritten = (XYDataItem) existing.clone();\n            // figure out if we need to iterate through all the y-values\n            boolean iterate = false;\n            double oldY = existing.getYValue();\n            if (!Double.isNaN(oldY)) {\n                iterate = oldY <= this.minY || oldY >= this.maxY;\n            }\n            existing.setY(item.getY());\n\n            if (iterate) {\n                findBoundsByIteration();\n            }\n            else if (item.getY() != null) {\n                double yy = item.getY().doubleValue();\n                this.minY = minIgnoreNaN(this.minY, yy);\n                this.maxY = minIgnoreNaN(this.maxY, yy);\n            }\n        }\n        else {\n            // if the series is sorted, the negative index is a result from\n            // Collections.binarySearch() and tells us where to insert the\n            // new item...otherwise it will be just -1 and we should just\n            // append the value to the list...\n            item = (XYDataItem) item.clone();\n            if (this.autoSort) {\nthis.data.add((minY - 1), item);\n            }\n            else {\n                this.data.add(item);\n            }\n            updateBoundsForAddedItem(item);\n\n            // check if this addition will exceed the maximum item count...\n            if (getItemCount() > this.maximumItemCount) {\n                XYDataItem removed = (XYDataItem) this.data.remove(0);\n                updateBoundsForRemovedItem(removed);\n            }\n        }\n        fireSeriesChanged();\n        return overwritten;\n    }",
          "42": "    public XYDataItem addOrUpdate(XYDataItem item) {\n        if (item == null) {\n            throw new IllegalArgumentException(\"Null 'item' argument.\");\n        }\n        if (this.allowDuplicateXValues) {\n            add(item);\n            return null;\n        }\n\n        // if we get to here, we know that duplicate X values are not permitted\n        XYDataItem overwritten = null;\n        int index = indexOf(item.getX());\n        if (index >= 0) {\n            XYDataItem existing = (XYDataItem) this.data.get(index);\n            overwritten = (XYDataItem) existing.clone();\n            // figure out if we need to iterate through all the y-values\n            boolean iterate = false;\n            double oldY = existing.getYValue();\n            if (!Double.isNaN(oldY)) {\n                iterate = oldY <= this.minY || oldY >= this.maxY;\n            }\n            existing.setY(item.getY());\n\n            if (iterate) {\n                findBoundsByIteration();\n            }\n            else if (item.getY() != null) {\n                double yy = item.getY().doubleValue();\n                this.minY = minIgnoreNaN(this.minY, yy);\n                this.maxY = minIgnoreNaN(this.maxY, yy);\n            }\n        }\n        else {\n            // if the series is sorted, the negative index is a result from\n            // Collections.binarySearch() and tells us where to insert the\n            // new item...otherwise it will be just -1 and we should just\n            // append the value to the list...\n            item = (XYDataItem) item.clone();\n            if (this.autoSort) {\nadd(item);\n                this.data.add(~index - 1, item);            }\n            else {\n                this.data.add(item);\n            }\n            updateBoundsForAddedItem(item);\n\n            // check if this addition will exceed the maximum item count...\n            if (getItemCount() > this.maximumItemCount) {\n                XYDataItem removed = (XYDataItem) this.data.remove(0);\n                updateBoundsForRemovedItem(removed);\n            }\n        }\n        fireSeriesChanged();\n        return overwritten;\n    }",
          "43": "    public XYDataItem addOrUpdate(XYDataItem item) {\n        if (item == null) {\n            throw new IllegalArgumentException(\"Null 'item' argument.\");\n        }\n        if (this.allowDuplicateXValues) {\n            add(item);\n            return null;\n        }\n\n        // if we get to here, we know that duplicate X values are not permitted\n        XYDataItem overwritten = null;\n        int index = indexOf(item.getX());\n        if (index >= 0) {\n            XYDataItem existing = (XYDataItem) this.data.get(index);\n            overwritten = (XYDataItem) existing.clone();\n            // figure out if we need to iterate through all the y-values\n            boolean iterate = false;\n            double oldY = existing.getYValue();\n            if (!Double.isNaN(oldY)) {\n                iterate = oldY <= this.minY || oldY >= this.maxY;\n            }\n            existing.setY(item.getY());\n\n            if (iterate) {\n                findBoundsByIteration();\n            }\n            else if (item.getY() != null) {\n                double yy = item.getY().doubleValue();\n                this.minY = minIgnoreNaN(this.minY, yy);\n                this.maxY = minIgnoreNaN(this.maxY, yy);\n            }\n        }\n        else {\n            // if the series is sorted, the negative index is a result from\n            // Collections.binarySearch() and tells us where to insert the\n            // new item...otherwise it will be just -1 and we should just\n            // append the value to the list...\n            item = (XYDataItem) item.clone();\n            if (this.autoSort) {\nif((~index - 1)){\n}\n                this.data.add(~index - 1, item);            }\n            else {\n                this.data.add(item);\n            }\n            updateBoundsForAddedItem(item);\n\n            // check if this addition will exceed the maximum item count...\n            if (getItemCount() > this.maximumItemCount) {\n                XYDataItem removed = (XYDataItem) this.data.remove(0);\n                updateBoundsForRemovedItem(removed);\n            }\n        }\n        fireSeriesChanged();\n        return overwritten;\n    }",
          "44": "    public XYDataItem addOrUpdate(XYDataItem item) {\n        if (item == null) {\n            throw new IllegalArgumentException(\"Null 'item' argument.\");\n        }\n        if (this.allowDuplicateXValues) {\n            add(item);\n            return null;\n        }\n\n        // if we get to here, we know that duplicate X values are not permitted\n        XYDataItem overwritten = null;\n        int index = indexOf(item.getX());\n        if (index >= 0) {\n            XYDataItem existing = (XYDataItem) this.data.get(index);\n            overwritten = (XYDataItem) existing.clone();\n            // figure out if we need to iterate through all the y-values\n            boolean iterate = false;\n            double oldY = existing.getYValue();\n            if (!Double.isNaN(oldY)) {\n                iterate = oldY <= this.minY || oldY >= this.maxY;\n            }\n            existing.setY(item.getY());\n\n            if (iterate) {\n                findBoundsByIteration();\n            }\n            else if (item.getY() != null) {\n                double yy = item.getY().doubleValue();\n                this.minY = minIgnoreNaN(this.minY, yy);\n                this.maxY = minIgnoreNaN(this.maxY, yy);\n            }\n        }\n        else {\n            // if the series is sorted, the negative index is a result from\n            // Collections.binarySearch() and tells us where to insert the\n            // new item...otherwise it will be just -1 and we should just\n            // append the value to the list...\n            item = (XYDataItem) item.clone();\n            if (this.autoSort) {\nthis.data.add((~index - false), item);\n            }\n            else {\n                this.data.add(item);\n            }\n            updateBoundsForAddedItem(item);\n\n            // check if this addition will exceed the maximum item count...\n            if (getItemCount() > this.maximumItemCount) {\n                XYDataItem removed = (XYDataItem) this.data.remove(0);\n                updateBoundsForRemovedItem(removed);\n            }\n        }\n        fireSeriesChanged();\n        return overwritten;\n    }",
          "45": "    public XYDataItem addOrUpdate(XYDataItem item) {\n        if (item == null) {\n            throw new IllegalArgumentException(\"Null 'item' argument.\");\n        }\n        if (this.allowDuplicateXValues) {\n            add(item);\n            return null;\n        }\n\n        // if we get to here, we know that duplicate X values are not permitted\n        XYDataItem overwritten = null;\n        int index = indexOf(item.getX());\n        if (index >= 0) {\n            XYDataItem existing = (XYDataItem) this.data.get(index);\n            overwritten = (XYDataItem) existing.clone();\n            // figure out if we need to iterate through all the y-values\n            boolean iterate = false;\n            double oldY = existing.getYValue();\n            if (!Double.isNaN(oldY)) {\n                iterate = oldY <= this.minY || oldY >= this.maxY;\n            }\n            existing.setY(item.getY());\n\n            if (iterate) {\n                findBoundsByIteration();\n            }\n            else if (item.getY() != null) {\n                double yy = item.getY().doubleValue();\n                this.minY = minIgnoreNaN(this.minY, yy);\n                this.maxY = minIgnoreNaN(this.maxY, yy);\n            }\n        }\n        else {\n            // if the series is sorted, the negative index is a result from\n            // Collections.binarySearch() and tells us where to insert the\n            // new item...otherwise it will be just -1 and we should just\n            // append the value to the list...\n            item = (XYDataItem) item.clone();\n            if (this.autoSort) {\nif((oldY <= this.minY)){\n}\n                this.data.add(~index - 1, item);            }\n            else {\n                this.data.add(item);\n            }\n            updateBoundsForAddedItem(item);\n\n            // check if this addition will exceed the maximum item count...\n            if (getItemCount() > this.maximumItemCount) {\n                XYDataItem removed = (XYDataItem) this.data.remove(0);\n                updateBoundsForRemovedItem(removed);\n            }\n        }\n        fireSeriesChanged();\n        return overwritten;\n    }",
          "46": "    public XYDataItem addOrUpdate(XYDataItem item) {\n        if (item == null) {\n            throw new IllegalArgumentException(\"Null 'item' argument.\");\n        }\n        if (this.allowDuplicateXValues) {\n            add(item);\n            return null;\n        }\n\n        // if we get to here, we know that duplicate X values are not permitted\n        XYDataItem overwritten = null;\n        int index = indexOf(item.getX());\n        if (index >= 0) {\n            XYDataItem existing = (XYDataItem) this.data.get(index);\n            overwritten = (XYDataItem) existing.clone();\n            // figure out if we need to iterate through all the y-values\n            boolean iterate = false;\n            double oldY = existing.getYValue();\n            if (!Double.isNaN(oldY)) {\n                iterate = oldY <= this.minY || oldY >= this.maxY;\n            }\n            existing.setY(item.getY());\n\n            if (iterate) {\n                findBoundsByIteration();\n            }\n            else if (item.getY() != null) {\n                double yy = item.getY().doubleValue();\n                this.minY = minIgnoreNaN(this.minY, yy);\n                this.maxY = minIgnoreNaN(this.maxY, yy);\n            }\n        }\n        else {\n            // if the series is sorted, the negative index is a result from\n            // Collections.binarySearch() and tells us where to insert the\n            // new item...otherwise it will be just -1 and we should just\n            // append the value to the list...\n            item = (XYDataItem) item.clone();\n            if (this.autoSort) {\nthis.data.add((~index - null), item);\n            }\n            else {\n                this.data.add(item);\n            }\n            updateBoundsForAddedItem(item);\n\n            // check if this addition will exceed the maximum item count...\n            if (getItemCount() > this.maximumItemCount) {\n                XYDataItem removed = (XYDataItem) this.data.remove(0);\n                updateBoundsForRemovedItem(removed);\n            }\n        }\n        fireSeriesChanged();\n        return overwritten;\n    }",
          "47": "    public XYDataItem addOrUpdate(XYDataItem item) {\n        if (item == null) {\n            throw new IllegalArgumentException(\"Null 'item' argument.\");\n        }\n        if (this.allowDuplicateXValues) {\n            add(item);\n            return null;\n        }\n\n        // if we get to here, we know that duplicate X values are not permitted\n        XYDataItem overwritten = null;\n        int index = indexOf(item.getX());\n        if (index >= 0) {\n            XYDataItem existing = (XYDataItem) this.data.get(index);\n            overwritten = (XYDataItem) existing.clone();\n            // figure out if we need to iterate through all the y-values\n            boolean iterate = false;\n            double oldY = existing.getYValue();\n            if (!Double.isNaN(oldY)) {\n                iterate = oldY <= this.minY || oldY >= this.maxY;\n            }\n            existing.setY(item.getY());\n\n            if (iterate) {\n                findBoundsByIteration();\n            }\n            else if (item.getY() != null) {\n                double yy = item.getY().doubleValue();\n                this.minY = minIgnoreNaN(this.minY, yy);\n                this.maxY = minIgnoreNaN(this.maxY, yy);\n            }\n        }\n        else {\n            // if the series is sorted, the negative index is a result from\n            // Collections.binarySearch() and tells us where to insert the\n            // new item...otherwise it will be just -1 and we should just\n            // append the value to the list...\n            item = (XYDataItem) item.clone();\n            if (this.autoSort) {\nthis.data.add((~index != 1), item);\n            }\n            else {\n                this.data.add(item);\n            }\n            updateBoundsForAddedItem(item);\n\n            // check if this addition will exceed the maximum item count...\n            if (getItemCount() > this.maximumItemCount) {\n                XYDataItem removed = (XYDataItem) this.data.remove(0);\n                updateBoundsForRemovedItem(removed);\n            }\n        }\n        fireSeriesChanged();\n        return overwritten;\n    }",
          "48": "    public XYDataItem addOrUpdate(XYDataItem item) {\n        if (item == null) {\n            throw new IllegalArgumentException(\"Null 'item' argument.\");\n        }\n        if (this.allowDuplicateXValues) {\n            add(item);\n            return null;\n        }\n\n        // if we get to here, we know that duplicate X values are not permitted\n        XYDataItem overwritten = null;\n        int index = indexOf(item.getX());\n        if (index >= 0) {\n            XYDataItem existing = (XYDataItem) this.data.get(index);\n            overwritten = (XYDataItem) existing.clone();\n            // figure out if we need to iterate through all the y-values\n            boolean iterate = false;\n            double oldY = existing.getYValue();\n            if (!Double.isNaN(oldY)) {\n                iterate = oldY <= this.minY || oldY >= this.maxY;\n            }\n            existing.setY(item.getY());\n\n            if (iterate) {\n                findBoundsByIteration();\n            }\n            else if (item.getY() != null) {\n                double yy = item.getY().doubleValue();\n                this.minY = minIgnoreNaN(this.minY, yy);\n                this.maxY = minIgnoreNaN(this.maxY, yy);\n            }\n        }\n        else {\n            // if the series is sorted, the negative index is a result from\n            // Collections.binarySearch() and tells us where to insert the\n            // new item...otherwise it will be just -1 and we should just\n            // append the value to the list...\n            item = (XYDataItem) item.clone();\n            if (this.autoSort) {\nreturn overwritten;                this.data.add(~index - 1, item);            }\n            else {\n                this.data.add(item);\n            }\n            updateBoundsForAddedItem(item);\n\n            // check if this addition will exceed the maximum item count...\n            if (getItemCount() > this.maximumItemCount) {\n                XYDataItem removed = (XYDataItem) this.data.remove(0);\n                updateBoundsForRemovedItem(removed);\n            }\n        }\n        fireSeriesChanged();\n        return overwritten;\n    }",
          "49": "    public XYDataItem addOrUpdate(XYDataItem item) {\n        if (item == null) {\n            throw new IllegalArgumentException(\"Null 'item' argument.\");\n        }\n        if (this.allowDuplicateXValues) {\n            add(item);\n            return null;\n        }\n\n        // if we get to here, we know that duplicate X values are not permitted\n        XYDataItem overwritten = null;\n        int index = indexOf(item.getX());\n        if (index >= 0) {\n            XYDataItem existing = (XYDataItem) this.data.get(index);\n            overwritten = (XYDataItem) existing.clone();\n            // figure out if we need to iterate through all the y-values\n            boolean iterate = false;\n            double oldY = existing.getYValue();\n            if (!Double.isNaN(oldY)) {\n                iterate = oldY <= this.minY || oldY >= this.maxY;\n            }\n            existing.setY(item.getY());\n\n            if (iterate) {\n                findBoundsByIteration();\n            }\n            else if (item.getY() != null) {\n                double yy = item.getY().doubleValue();\n                this.minY = minIgnoreNaN(this.minY, yy);\n                this.maxY = minIgnoreNaN(this.maxY, yy);\n            }\n        }\n        else {\n            // if the series is sorted, the negative index is a result from\n            // Collections.binarySearch() and tells us where to insert the\n            // new item...otherwise it will be just -1 and we should just\n            // append the value to the list...\n            item = (XYDataItem) item.clone();\n            if (this.autoSort) {\nthis.data.add((~index < 1), item);\n            }\n            else {\n                this.data.add(item);\n            }\n            updateBoundsForAddedItem(item);\n\n            // check if this addition will exceed the maximum item count...\n            if (getItemCount() > this.maximumItemCount) {\n                XYDataItem removed = (XYDataItem) this.data.remove(0);\n                updateBoundsForRemovedItem(removed);\n            }\n        }\n        fireSeriesChanged();\n        return overwritten;\n    }",
          "50": "    public XYDataItem addOrUpdate(XYDataItem item) {\n        if (item == null) {\n            throw new IllegalArgumentException(\"Null 'item' argument.\");\n        }\n        if (this.allowDuplicateXValues) {\n            add(item);\n            return null;\n        }\n\n        // if we get to here, we know that duplicate X values are not permitted\n        XYDataItem overwritten = null;\n        int index = indexOf(item.getX());\n        if (index >= 0) {\n            XYDataItem existing = (XYDataItem) this.data.get(index);\n            overwritten = (XYDataItem) existing.clone();\n            // figure out if we need to iterate through all the y-values\n            boolean iterate = false;\n            double oldY = existing.getYValue();\n            if (!Double.isNaN(oldY)) {\n                iterate = oldY <= this.minY || oldY >= this.maxY;\n            }\n            existing.setY(item.getY());\n\n            if (iterate) {\n                findBoundsByIteration();\n            }\n            else if (item.getY() != null) {\n                double yy = item.getY().doubleValue();\n                this.minY = minIgnoreNaN(this.minY, yy);\n                this.maxY = minIgnoreNaN(this.maxY, yy);\n            }\n        }\n        else {\n            // if the series is sorted, the negative index is a result from\n            // Collections.binarySearch() and tells us where to insert the\n            // new item...otherwise it will be just -1 and we should just\n            // append the value to the list...\n            item = (XYDataItem) item.clone();\n            if (this.autoSort) {\nthis.data.add((~index + 1), item);\n            }\n            else {\n                this.data.add(item);\n            }\n            updateBoundsForAddedItem(item);\n\n            // check if this addition will exceed the maximum item count...\n            if (getItemCount() > this.maximumItemCount) {\n                XYDataItem removed = (XYDataItem) this.data.remove(0);\n                updateBoundsForRemovedItem(removed);\n            }\n        }\n        fireSeriesChanged();\n        return overwritten;\n    }",
          "51": "    public XYDataItem addOrUpdate(XYDataItem item) {\n        if (item == null) {\n            throw new IllegalArgumentException(\"Null 'item' argument.\");\n        }\n        if (this.allowDuplicateXValues) {\n            add(item);\n            return null;\n        }\n\n        // if we get to here, we know that duplicate X values are not permitted\n        XYDataItem overwritten = null;\n        int index = indexOf(item.getX());\n        if (index >= 0) {\n            XYDataItem existing = (XYDataItem) this.data.get(index);\n            overwritten = (XYDataItem) existing.clone();\n            // figure out if we need to iterate through all the y-values\n            boolean iterate = false;\n            double oldY = existing.getYValue();\n            if (!Double.isNaN(oldY)) {\n                iterate = oldY <= this.minY || oldY >= this.maxY;\n            }\n            existing.setY(item.getY());\n\n            if (iterate) {\n                findBoundsByIteration();\n            }\n            else if (item.getY() != null) {\n                double yy = item.getY().doubleValue();\n                this.minY = minIgnoreNaN(this.minY, yy);\n                this.maxY = minIgnoreNaN(this.maxY, yy);\n            }\n        }\n        else {\n            // if the series is sorted, the negative index is a result from\n            // Collections.binarySearch() and tells us where to insert the\n            // new item...otherwise it will be just -1 and we should just\n            // append the value to the list...\n            item = (XYDataItem) item.clone();\n            if (this.autoSort) {\nthis.item.add((~index - 1), index);\n            }\n            else {\n                this.data.add(item);\n            }\n            updateBoundsForAddedItem(item);\n\n            // check if this addition will exceed the maximum item count...\n            if (getItemCount() > this.maximumItemCount) {\n                XYDataItem removed = (XYDataItem) this.data.remove(0);\n                updateBoundsForRemovedItem(removed);\n            }\n        }\n        fireSeriesChanged();\n        return overwritten;\n    }",
          "52": "    public XYDataItem addOrUpdate(XYDataItem item) {\n        if (item == null) {\n            throw new IllegalArgumentException(\"Null 'item' argument.\");\n        }\n        if (this.allowDuplicateXValues) {\n            add(item);\n            return null;\n        }\n\n        // if we get to here, we know that duplicate X values are not permitted\n        XYDataItem overwritten = null;\n        int index = indexOf(item.getX());\n        if (index >= 0) {\n            XYDataItem existing = (XYDataItem) this.data.get(index);\n            overwritten = (XYDataItem) existing.clone();\n            // figure out if we need to iterate through all the y-values\n            boolean iterate = false;\n            double oldY = existing.getYValue();\n            if (!Double.isNaN(oldY)) {\n                iterate = oldY <= this.minY || oldY >= this.maxY;\n            }\n            existing.setY(item.getY());\n\n            if (iterate) {\n                findBoundsByIteration();\n            }\n            else if (item.getY() != null) {\n                double yy = item.getY().doubleValue();\n                this.minY = minIgnoreNaN(this.minY, yy);\n                this.maxY = minIgnoreNaN(this.maxY, yy);\n            }\n        }\n        else {\n            // if the series is sorted, the negative index is a result from\n            // Collections.binarySearch() and tells us where to insert the\n            // new item...otherwise it will be just -1 and we should just\n            // append the value to the list...\n            item = (XYDataItem) item.clone();\n            if (this.autoSort) {\nthis.data.add(index, (~index - 1));\n            }\n            else {\n                this.data.add(item);\n            }\n            updateBoundsForAddedItem(item);\n\n            // check if this addition will exceed the maximum item count...\n            if (getItemCount() > this.maximumItemCount) {\n                XYDataItem removed = (XYDataItem) this.data.remove(0);\n                updateBoundsForRemovedItem(removed);\n            }\n        }\n        fireSeriesChanged();\n        return overwritten;\n    }",
          "53": "    public XYDataItem addOrUpdate(XYDataItem item) {\n        if (item == null) {\n            throw new IllegalArgumentException(\"Null 'item' argument.\");\n        }\n        if (this.allowDuplicateXValues) {\n            add(item);\n            return null;\n        }\n\n        // if we get to here, we know that duplicate X values are not permitted\n        XYDataItem overwritten = null;\n        int index = indexOf(item.getX());\n        if (index >= 0) {\n            XYDataItem existing = (XYDataItem) this.data.get(index);\n            overwritten = (XYDataItem) existing.clone();\n            // figure out if we need to iterate through all the y-values\n            boolean iterate = false;\n            double oldY = existing.getYValue();\n            if (!Double.isNaN(oldY)) {\n                iterate = oldY <= this.minY || oldY >= this.maxY;\n            }\n            existing.setY(item.getY());\n\n            if (iterate) {\n                findBoundsByIteration();\n            }\n            else if (item.getY() != null) {\n                double yy = item.getY().doubleValue();\n                this.minY = minIgnoreNaN(this.minY, yy);\n                this.maxY = minIgnoreNaN(this.maxY, yy);\n            }\n        }\n        else {\n            // if the series is sorted, the negative index is a result from\n            // Collections.binarySearch() and tells us where to insert the\n            // new item...otherwise it will be just -1 and we should just\n            // append the value to the list...\n            item = (XYDataItem) item.clone();\n            if (this.autoSort) {\nif(this.autoSort){\n}\n                this.data.add(~index - 1, item);            }\n            else {\n                this.data.add(item);\n            }\n            updateBoundsForAddedItem(item);\n\n            // check if this addition will exceed the maximum item count...\n            if (getItemCount() > this.maximumItemCount) {\n                XYDataItem removed = (XYDataItem) this.data.remove(0);\n                updateBoundsForRemovedItem(removed);\n            }\n        }\n        fireSeriesChanged();\n        return overwritten;\n    }",
          "54": "    public XYDataItem addOrUpdate(XYDataItem item) {\n        if (item == null) {\n            throw new IllegalArgumentException(\"Null 'item' argument.\");\n        }\n        if (this.allowDuplicateXValues) {\n            add(item);\n            return null;\n        }\n\n        // if we get to here, we know that duplicate X values are not permitted\n        XYDataItem overwritten = null;\n        int index = indexOf(item.getX());\n        if (index >= 0) {\n            XYDataItem existing = (XYDataItem) this.data.get(index);\n            overwritten = (XYDataItem) existing.clone();\n            // figure out if we need to iterate through all the y-values\n            boolean iterate = false;\n            double oldY = existing.getYValue();\n            if (!Double.isNaN(oldY)) {\n                iterate = oldY <= this.minY || oldY >= this.maxY;\n            }\n            existing.setY(item.getY());\n\n            if (iterate) {\n                findBoundsByIteration();\n            }\n            else if (item.getY() != null) {\n                double yy = item.getY().doubleValue();\n                this.minY = minIgnoreNaN(this.minY, yy);\n                this.maxY = minIgnoreNaN(this.maxY, yy);\n            }\n        }\n        else {\n            // if the series is sorted, the negative index is a result from\n            // Collections.binarySearch() and tells us where to insert the\n            // new item...otherwise it will be just -1 and we should just\n            // append the value to the list...\n            item = (XYDataItem) item.clone();\n            if (this.autoSort) {\nthis.add((~index - 1), item);\n            }\n            else {\n                this.data.add(item);\n            }\n            updateBoundsForAddedItem(item);\n\n            // check if this addition will exceed the maximum item count...\n            if (getItemCount() > this.maximumItemCount) {\n                XYDataItem removed = (XYDataItem) this.data.remove(0);\n                updateBoundsForRemovedItem(removed);\n            }\n        }\n        fireSeriesChanged();\n        return overwritten;\n    }",
          "55": "    public XYDataItem addOrUpdate(XYDataItem item) {\n        if (item == null) {\n            throw new IllegalArgumentException(\"Null 'item' argument.\");\n        }\n        if (this.allowDuplicateXValues) {\n            add(item);\n            return null;\n        }\n\n        // if we get to here, we know that duplicate X values are not permitted\n        XYDataItem overwritten = null;\n        int index = indexOf(item.getX());\n        if (index >= 0) {\n            XYDataItem existing = (XYDataItem) this.data.get(index);\n            overwritten = (XYDataItem) existing.clone();\n            // figure out if we need to iterate through all the y-values\n            boolean iterate = false;\n            double oldY = existing.getYValue();\n            if (!Double.isNaN(oldY)) {\n                iterate = oldY <= this.minY || oldY >= this.maxY;\n            }\n            existing.setY(item.getY());\n\n            if (iterate) {\n                findBoundsByIteration();\n            }\n            else if (item.getY() != null) {\n                double yy = item.getY().doubleValue();\n                this.minY = minIgnoreNaN(this.minY, yy);\n                this.maxY = minIgnoreNaN(this.maxY, yy);\n            }\n        }\n        else {\n            // if the series is sorted, the negative index is a result from\n            // Collections.binarySearch() and tells us where to insert the\n            // new item...otherwise it will be just -1 and we should just\n            // append the value to the list...\n            item = (XYDataItem) item.clone();\n            if (this.autoSort) {\nthis.oldY.add((~index - 1), item);\n            }\n            else {\n                this.data.add(item);\n            }\n            updateBoundsForAddedItem(item);\n\n            // check if this addition will exceed the maximum item count...\n            if (getItemCount() > this.maximumItemCount) {\n                XYDataItem removed = (XYDataItem) this.data.remove(0);\n                updateBoundsForRemovedItem(removed);\n            }\n        }\n        fireSeriesChanged();\n        return overwritten;\n    }",
          "56": "    public XYDataItem addOrUpdate(XYDataItem item) {\n        if (item == null) {\n            throw new IllegalArgumentException(\"Null 'item' argument.\");\n        }\n        if (this.allowDuplicateXValues) {\n            add(item);\n            return null;\n        }\n\n        // if we get to here, we know that duplicate X values are not permitted\n        XYDataItem overwritten = null;\n        int index = indexOf(item.getX());\n        if (index >= 0) {\n            XYDataItem existing = (XYDataItem) this.data.get(index);\n            overwritten = (XYDataItem) existing.clone();\n            // figure out if we need to iterate through all the y-values\n            boolean iterate = false;\n            double oldY = existing.getYValue();\n            if (!Double.isNaN(oldY)) {\n                iterate = oldY <= this.minY || oldY >= this.maxY;\n            }\n            existing.setY(item.getY());\n\n            if (iterate) {\n                findBoundsByIteration();\n            }\n            else if (item.getY() != null) {\n                double yy = item.getY().doubleValue();\n                this.minY = minIgnoreNaN(this.minY, yy);\n                this.maxY = minIgnoreNaN(this.maxY, yy);\n            }\n        }\n        else {\n            // if the series is sorted, the negative index is a result from\n            // Collections.binarySearch() and tells us where to insert the\n            // new item...otherwise it will be just -1 and we should just\n            // append the value to the list...\n            item = (XYDataItem) item.clone();\n            if (this.autoSort) {\nthis.data.add((-index - 1), item);\n            }\n            else {\n                this.data.add(item);\n            }\n            updateBoundsForAddedItem(item);\n\n            // check if this addition will exceed the maximum item count...\n            if (getItemCount() > this.maximumItemCount) {\n                XYDataItem removed = (XYDataItem) this.data.remove(0);\n                updateBoundsForRemovedItem(removed);\n            }\n        }\n        fireSeriesChanged();\n        return overwritten;\n    }",
          "57": "    public XYDataItem addOrUpdate(XYDataItem item) {\n        if (item == null) {\n            throw new IllegalArgumentException(\"Null 'item' argument.\");\n        }\n        if (this.allowDuplicateXValues) {\n            add(item);\n            return null;\n        }\n\n        // if we get to here, we know that duplicate X values are not permitted\n        XYDataItem overwritten = null;\n        int index = indexOf(item.getX());\n        if (index >= 0) {\n            XYDataItem existing = (XYDataItem) this.data.get(index);\n            overwritten = (XYDataItem) existing.clone();\n            // figure out if we need to iterate through all the y-values\n            boolean iterate = false;\n            double oldY = existing.getYValue();\n            if (!Double.isNaN(oldY)) {\n                iterate = oldY <= this.minY || oldY >= this.maxY;\n            }\n            existing.setY(item.getY());\n\n            if (iterate) {\n                findBoundsByIteration();\n            }\n            else if (item.getY() != null) {\n                double yy = item.getY().doubleValue();\n                this.minY = minIgnoreNaN(this.minY, yy);\n                this.maxY = minIgnoreNaN(this.maxY, yy);\n            }\n        }\n        else {\n            // if the series is sorted, the negative index is a result from\n            // Collections.binarySearch() and tells us where to insert the\n            // new item...otherwise it will be just -1 and we should just\n            // append the value to the list...\n            item = (XYDataItem) item.clone();\n            if (this.autoSort) {\nthis.item.add(index, 0);\n            }\n            else {\n                this.data.add(item);\n            }\n            updateBoundsForAddedItem(item);\n\n            // check if this addition will exceed the maximum item count...\n            if (getItemCount() > this.maximumItemCount) {\n                XYDataItem removed = (XYDataItem) this.data.remove(0);\n                updateBoundsForRemovedItem(removed);\n            }\n        }\n        fireSeriesChanged();\n        return overwritten;\n    }",
          "58": "    public XYDataItem addOrUpdate(XYDataItem item) {\n        if (item == null) {\n            throw new IllegalArgumentException(\"Null 'item' argument.\");\n        }\n        if (this.allowDuplicateXValues) {\n            add(item);\n            return null;\n        }\n\n        // if we get to here, we know that duplicate X values are not permitted\n        XYDataItem overwritten = null;\n        int index = indexOf(item.getX());\n        if (index >= 0) {\n            XYDataItem existing = (XYDataItem) this.data.get(index);\n            overwritten = (XYDataItem) existing.clone();\n            // figure out if we need to iterate through all the y-values\n            boolean iterate = false;\n            double oldY = existing.getYValue();\n            if (!Double.isNaN(oldY)) {\n                iterate = oldY <= this.minY || oldY >= this.maxY;\n            }\n            existing.setY(item.getY());\n\n            if (iterate) {\n                findBoundsByIteration();\n            }\n            else if (item.getY() != null) {\n                double yy = item.getY().doubleValue();\n                this.minY = minIgnoreNaN(this.minY, yy);\n                this.maxY = minIgnoreNaN(this.maxY, yy);\n            }\n        }\n        else {\n            // if the series is sorted, the negative index is a result from\n            // Collections.binarySearch() and tells us where to insert the\n            // new item...otherwise it will be just -1 and we should just\n            // append the value to the list...\n            item = (XYDataItem) item.clone();\n            if (this.autoSort) {\nthis.data.add((~index - 1));\n            }\n            else {\n                this.data.add(item);\n            }\n            updateBoundsForAddedItem(item);\n\n            // check if this addition will exceed the maximum item count...\n            if (getItemCount() > this.maximumItemCount) {\n                XYDataItem removed = (XYDataItem) this.data.remove(0);\n                updateBoundsForRemovedItem(removed);\n            }\n        }\n        fireSeriesChanged();\n        return overwritten;\n    }",
          "59": "    public XYDataItem addOrUpdate(XYDataItem item) {\n        if (item == null) {\n            throw new IllegalArgumentException(\"Null 'item' argument.\");\n        }\n        if (this.allowDuplicateXValues) {\n            add(item);\n            return null;\n        }\n\n        // if we get to here, we know that duplicate X values are not permitted\n        XYDataItem overwritten = null;\n        int index = indexOf(item.getX());\n        if (index >= 0) {\n            XYDataItem existing = (XYDataItem) this.data.get(index);\n            overwritten = (XYDataItem) existing.clone();\n            // figure out if we need to iterate through all the y-values\n            boolean iterate = false;\n            double oldY = existing.getYValue();\n            if (!Double.isNaN(oldY)) {\n                iterate = oldY <= this.minY || oldY >= this.maxY;\n            }\n            existing.setY(item.getY());\n\n            if (iterate) {\n                findBoundsByIteration();\n            }\n            else if (item.getY() != null) {\n                double yy = item.getY().doubleValue();\n                this.minY = minIgnoreNaN(this.minY, yy);\n                this.maxY = minIgnoreNaN(this.maxY, yy);\n            }\n        }\n        else {\n            // if the series is sorted, the negative index is a result from\n            // Collections.binarySearch() and tells us where to insert the\n            // new item...otherwise it will be just -1 and we should just\n            // append the value to the list...\n            item = (XYDataItem) item.clone();\n            if (this.autoSort) {\nif((oldY >= this.maxY)){\n}\n                this.data.add(~index - 1, item);            }\n            else {\n                this.data.add(item);\n            }\n            updateBoundsForAddedItem(item);\n\n            // check if this addition will exceed the maximum item count...\n            if (getItemCount() > this.maximumItemCount) {\n                XYDataItem removed = (XYDataItem) this.data.remove(0);\n                updateBoundsForRemovedItem(removed);\n            }\n        }\n        fireSeriesChanged();\n        return overwritten;\n    }",
          "60": "    public XYDataItem addOrUpdate(XYDataItem item) {\n        if (item == null) {\n            throw new IllegalArgumentException(\"Null 'item' argument.\");\n        }\n        if (this.allowDuplicateXValues) {\n            add(item);\n            return null;\n        }\n\n        // if we get to here, we know that duplicate X values are not permitted\n        XYDataItem overwritten = null;\n        int index = indexOf(item.getX());\n        if (index >= 0) {\n            XYDataItem existing = (XYDataItem) this.data.get(index);\n            overwritten = (XYDataItem) existing.clone();\n            // figure out if we need to iterate through all the y-values\n            boolean iterate = false;\n            double oldY = existing.getYValue();\n            if (!Double.isNaN(oldY)) {\n                iterate = oldY <= this.minY || oldY >= this.maxY;\n            }\n            existing.setY(item.getY());\n\n            if (iterate) {\n                findBoundsByIteration();\n            }\n            else if (item.getY() != null) {\n                double yy = item.getY().doubleValue();\n                this.minY = minIgnoreNaN(this.minY, yy);\n                this.maxY = minIgnoreNaN(this.maxY, yy);\n            }\n        }\n        else {\n            // if the series is sorted, the negative index is a result from\n            // Collections.binarySearch() and tells us where to insert the\n            // new item...otherwise it will be just -1 and we should just\n            // append the value to the list...\n            item = (XYDataItem) item.clone();\n            if (this.autoSort) {\nthis.minY.add((~index - 1), item);\n            }\n            else {\n                this.data.add(item);\n            }\n            updateBoundsForAddedItem(item);\n\n            // check if this addition will exceed the maximum item count...\n            if (getItemCount() > this.maximumItemCount) {\n                XYDataItem removed = (XYDataItem) this.data.remove(0);\n                updateBoundsForRemovedItem(removed);\n            }\n        }\n        fireSeriesChanged();\n        return overwritten;\n    }",
          "61": "    public XYDataItem addOrUpdate(XYDataItem item) {\n        if (item == null) {\n            throw new IllegalArgumentException(\"Null 'item' argument.\");\n        }\n        if (this.allowDuplicateXValues) {\n            add(item);\n            return null;\n        }\n\n        // if we get to here, we know that duplicate X values are not permitted\n        XYDataItem overwritten = null;\n        int index = indexOf(item.getX());\n        if (index >= 0) {\n            XYDataItem existing = (XYDataItem) this.data.get(index);\n            overwritten = (XYDataItem) existing.clone();\n            // figure out if we need to iterate through all the y-values\n            boolean iterate = false;\n            double oldY = existing.getYValue();\n            if (!Double.isNaN(oldY)) {\n                iterate = oldY <= this.minY || oldY >= this.maxY;\n            }\n            existing.setY(item.getY());\n\n            if (iterate) {\n                findBoundsByIteration();\n            }\n            else if (item.getY() != null) {\n                double yy = item.getY().doubleValue();\n                this.minY = minIgnoreNaN(this.minY, yy);\n                this.maxY = minIgnoreNaN(this.maxY, yy);\n            }\n        }\n        else {\n            // if the series is sorted, the negative index is a result from\n            // Collections.binarySearch() and tells us where to insert the\n            // new item...otherwise it will be just -1 and we should just\n            // append the value to the list...\n            item = (XYDataItem) item.clone();\n            if (this.autoSort) {\nif((item.getY() != null)){\n}\n                this.data.add(~index - 1, item);            }\n            else {\n                this.data.add(item);\n            }\n            updateBoundsForAddedItem(item);\n\n            // check if this addition will exceed the maximum item count...\n            if (getItemCount() > this.maximumItemCount) {\n                XYDataItem removed = (XYDataItem) this.data.remove(0);\n                updateBoundsForRemovedItem(removed);\n            }\n        }\n        fireSeriesChanged();\n        return overwritten;\n    }",
          "62": "    public XYDataItem addOrUpdate(XYDataItem item) {\n        if (item == null) {\n            throw new IllegalArgumentException(\"Null 'item' argument.\");\n        }\n        if (this.allowDuplicateXValues) {\n            add(item);\n            return null;\n        }\n\n        // if we get to here, we know that duplicate X values are not permitted\n        XYDataItem overwritten = null;\n        int index = indexOf(item.getX());\n        if (index >= 0) {\n            XYDataItem existing = (XYDataItem) this.data.get(index);\n            overwritten = (XYDataItem) existing.clone();\n            // figure out if we need to iterate through all the y-values\n            boolean iterate = false;\n            double oldY = existing.getYValue();\n            if (!Double.isNaN(oldY)) {\n                iterate = oldY <= this.minY || oldY >= this.maxY;\n            }\n            existing.setY(item.getY());\n\n            if (iterate) {\n                findBoundsByIteration();\n            }\n            else if (item.getY() != null) {\n                double yy = item.getY().doubleValue();\n                this.minY = minIgnoreNaN(this.minY, yy);\n                this.maxY = minIgnoreNaN(this.maxY, yy);\n            }\n        }\n        else {\n            // if the series is sorted, the negative index is a result from\n            // Collections.binarySearch() and tells us where to insert the\n            // new item...otherwise it will be just -1 and we should just\n            // append the value to the list...\n            item = (XYDataItem) item.clone();\n            if (this.autoSort) {\nif((getItemCount() > this.maximumItemCount)){\n}\n                this.data.add(~index - 1, item);            }\n            else {\n                this.data.add(item);\n            }\n            updateBoundsForAddedItem(item);\n\n            // check if this addition will exceed the maximum item count...\n            if (getItemCount() > this.maximumItemCount) {\n                XYDataItem removed = (XYDataItem) this.data.remove(0);\n                updateBoundsForRemovedItem(removed);\n            }\n        }\n        fireSeriesChanged();\n        return overwritten;\n    }",
          "63": "    public XYDataItem addOrUpdate(XYDataItem item) {\n        if (item == null) {\n            throw new IllegalArgumentException(\"Null 'item' argument.\");\n        }\n        if (this.allowDuplicateXValues) {\n            add(item);\n            return null;\n        }\n\n        // if we get to here, we know that duplicate X values are not permitted\n        XYDataItem overwritten = null;\n        int index = indexOf(item.getX());\n        if (index >= 0) {\n            XYDataItem existing = (XYDataItem) this.data.get(index);\n            overwritten = (XYDataItem) existing.clone();\n            // figure out if we need to iterate through all the y-values\n            boolean iterate = false;\n            double oldY = existing.getYValue();\n            if (!Double.isNaN(oldY)) {\n                iterate = oldY <= this.minY || oldY >= this.maxY;\n            }\n            existing.setY(item.getY());\n\n            if (iterate) {\n                findBoundsByIteration();\n            }\n            else if (item.getY() != null) {\n                double yy = item.getY().doubleValue();\n                this.minY = minIgnoreNaN(this.minY, yy);\n                this.maxY = minIgnoreNaN(this.maxY, yy);\n            }\n        }\n        else {\n            // if the series is sorted, the negative index is a result from\n            // Collections.binarySearch() and tells us where to insert the\n            // new item...otherwise it will be just -1 and we should just\n            // append the value to the list...\n            item = (XYDataItem) item.clone();\n            if (this.autoSort) {\nthis.item.add(index, minX);\n            }\n            else {\n                this.data.add(item);\n            }\n            updateBoundsForAddedItem(item);\n\n            // check if this addition will exceed the maximum item count...\n            if (getItemCount() > this.maximumItemCount) {\n                XYDataItem removed = (XYDataItem) this.data.remove(0);\n                updateBoundsForRemovedItem(removed);\n            }\n        }\n        fireSeriesChanged();\n        return overwritten;\n    }",
          "64": "    public XYDataItem addOrUpdate(XYDataItem item) {\n        if (item == null) {\n            throw new IllegalArgumentException(\"Null 'item' argument.\");\n        }\n        if (this.allowDuplicateXValues) {\n            add(item);\n            return null;\n        }\n\n        // if we get to here, we know that duplicate X values are not permitted\n        XYDataItem overwritten = null;\n        int index = indexOf(item.getX());\n        if (index >= 0) {\n            XYDataItem existing = (XYDataItem) this.data.get(index);\n            overwritten = (XYDataItem) existing.clone();\n            // figure out if we need to iterate through all the y-values\n            boolean iterate = false;\n            double oldY = existing.getYValue();\n            if (!Double.isNaN(oldY)) {\n                iterate = oldY <= this.minY || oldY >= this.maxY;\n            }\n            existing.setY(item.getY());\n\n            if (iterate) {\n                findBoundsByIteration();\n            }\n            else if (item.getY() != null) {\n                double yy = item.getY().doubleValue();\n                this.minY = minIgnoreNaN(this.minY, yy);\n                this.maxY = minIgnoreNaN(this.maxY, yy);\n            }\n        }\n        else {\n            // if the series is sorted, the negative index is a result from\n            // Collections.binarySearch() and tells us where to insert the\n            // new item...otherwise it will be just -1 and we should just\n            // append the value to the list...\n            item = (XYDataItem) item.clone();\n            if (this.autoSort) {\nthis.item.add(index, maxX);\n            }\n            else {\n                this.data.add(item);\n            }\n            updateBoundsForAddedItem(item);\n\n            // check if this addition will exceed the maximum item count...\n            if (getItemCount() > this.maximumItemCount) {\n                XYDataItem removed = (XYDataItem) this.data.remove(0);\n                updateBoundsForRemovedItem(removed);\n            }\n        }\n        fireSeriesChanged();\n        return overwritten;\n    }",
          "65": "    public XYDataItem addOrUpdate(XYDataItem item) {\n        if (item == null) {\n            throw new IllegalArgumentException(\"Null 'item' argument.\");\n        }\n        if (this.allowDuplicateXValues) {\n            add(item);\n            return null;\n        }\n\n        // if we get to here, we know that duplicate X values are not permitted\n        XYDataItem overwritten = null;\n        int index = indexOf(item.getX());\n        if (index >= 0) {\n            XYDataItem existing = (XYDataItem) this.data.get(index);\n            overwritten = (XYDataItem) existing.clone();\n            // figure out if we need to iterate through all the y-values\n            boolean iterate = false;\n            double oldY = existing.getYValue();\n            if (!Double.isNaN(oldY)) {\n                iterate = oldY <= this.minY || oldY >= this.maxY;\n            }\n            existing.setY(item.getY());\n\n            if (iterate) {\n                findBoundsByIteration();\n            }\n            else if (item.getY() != null) {\n                double yy = item.getY().doubleValue();\n                this.minY = minIgnoreNaN(this.minY, yy);\n                this.maxY = minIgnoreNaN(this.maxY, yy);\n            }\n        }\n        else {\n            // if the series is sorted, the negative index is a result from\n            // Collections.binarySearch() and tells us where to insert the\n            // new item...otherwise it will be just -1 and we should just\n            // append the value to the list...\n            item = (XYDataItem) item.clone();\n            if (this.autoSort) {\nthis.item.add(index, minY);\n            }\n            else {\n                this.data.add(item);\n            }\n            updateBoundsForAddedItem(item);\n\n            // check if this addition will exceed the maximum item count...\n            if (getItemCount() > this.maximumItemCount) {\n                XYDataItem removed = (XYDataItem) this.data.remove(0);\n                updateBoundsForRemovedItem(removed);\n            }\n        }\n        fireSeriesChanged();\n        return overwritten;\n    }",
          "66": "    public XYDataItem addOrUpdate(XYDataItem item) {\n        if (item == null) {\n            throw new IllegalArgumentException(\"Null 'item' argument.\");\n        }\n        if (this.allowDuplicateXValues) {\n            add(item);\n            return null;\n        }\n\n        // if we get to here, we know that duplicate X values are not permitted\n        XYDataItem overwritten = null;\n        int index = indexOf(item.getX());\n        if (index >= 0) {\n            XYDataItem existing = (XYDataItem) this.data.get(index);\n            overwritten = (XYDataItem) existing.clone();\n            // figure out if we need to iterate through all the y-values\n            boolean iterate = false;\n            double oldY = existing.getYValue();\n            if (!Double.isNaN(oldY)) {\n                iterate = oldY <= this.minY || oldY >= this.maxY;\n            }\n            existing.setY(item.getY());\n\n            if (iterate) {\n                findBoundsByIteration();\n            }\n            else if (item.getY() != null) {\n                double yy = item.getY().doubleValue();\n                this.minY = minIgnoreNaN(this.minY, yy);\n                this.maxY = minIgnoreNaN(this.maxY, yy);\n            }\n        }\n        else {\n            // if the series is sorted, the negative index is a result from\n            // Collections.binarySearch() and tells us where to insert the\n            // new item...otherwise it will be just -1 and we should just\n            // append the value to the list...\n            item = (XYDataItem) item.clone();\n            if (this.autoSort) {\nthis.item.add(index, maxY);\n            }\n            else {\n                this.data.add(item);\n            }\n            updateBoundsForAddedItem(item);\n\n            // check if this addition will exceed the maximum item count...\n            if (getItemCount() > this.maximumItemCount) {\n                XYDataItem removed = (XYDataItem) this.data.remove(0);\n                updateBoundsForRemovedItem(removed);\n            }\n        }\n        fireSeriesChanged();\n        return overwritten;\n    }",
          "67": "    public XYDataItem addOrUpdate(XYDataItem item) {\n        if (item == null) {\n            throw new IllegalArgumentException(\"Null 'item' argument.\");\n        }\n        if (this.allowDuplicateXValues) {\n            add(item);\n            return null;\n        }\n\n        // if we get to here, we know that duplicate X values are not permitted\n        XYDataItem overwritten = null;\n        int index = indexOf(item.getX());\n        if (index >= 0) {\n            XYDataItem existing = (XYDataItem) this.data.get(index);\n            overwritten = (XYDataItem) existing.clone();\n            // figure out if we need to iterate through all the y-values\n            boolean iterate = false;\n            double oldY = existing.getYValue();\n            if (!Double.isNaN(oldY)) {\n                iterate = oldY <= this.minY || oldY >= this.maxY;\n            }\n            existing.setY(item.getY());\n\n            if (iterate) {\n                findBoundsByIteration();\n            }\n            else if (item.getY() != null) {\n                double yy = item.getY().doubleValue();\n                this.minY = minIgnoreNaN(this.minY, yy);\n                this.maxY = minIgnoreNaN(this.maxY, yy);\n            }\n        }\n        else {\n            // if the series is sorted, the negative index is a result from\n            // Collections.binarySearch() and tells us where to insert the\n            // new item...otherwise it will be just -1 and we should just\n            // append the value to the list...\n            item = (XYDataItem) item.clone();\n            if (this.autoSort) {\nthis.item.add((~index - 1), (~index - 1));\n            }\n            else {\n                this.data.add(item);\n            }\n            updateBoundsForAddedItem(item);\n\n            // check if this addition will exceed the maximum item count...\n            if (getItemCount() > this.maximumItemCount) {\n                XYDataItem removed = (XYDataItem) this.data.remove(0);\n                updateBoundsForRemovedItem(removed);\n            }\n        }\n        fireSeriesChanged();\n        return overwritten;\n    }",
          "68": "    public XYDataItem addOrUpdate(XYDataItem item) {\n        if (item == null) {\n            throw new IllegalArgumentException(\"Null 'item' argument.\");\n        }\n        if (this.allowDuplicateXValues) {\n            add(item);\n            return null;\n        }\n\n        // if we get to here, we know that duplicate X values are not permitted\n        XYDataItem overwritten = null;\n        int index = indexOf(item.getX());\n        if (index >= 0) {\n            XYDataItem existing = (XYDataItem) this.data.get(index);\n            overwritten = (XYDataItem) existing.clone();\n            // figure out if we need to iterate through all the y-values\n            boolean iterate = false;\n            double oldY = existing.getYValue();\n            if (!Double.isNaN(oldY)) {\n                iterate = oldY <= this.minY || oldY >= this.maxY;\n            }\n            existing.setY(item.getY());\n\n            if (iterate) {\n                findBoundsByIteration();\n            }\n            else if (item.getY() != null) {\n                double yy = item.getY().doubleValue();\n                this.minY = minIgnoreNaN(this.minY, yy);\n                this.maxY = minIgnoreNaN(this.maxY, yy);\n            }\n        }\n        else {\n            // if the series is sorted, the negative index is a result from\n            // Collections.binarySearch() and tells us where to insert the\n            // new item...otherwise it will be just -1 and we should just\n            // append the value to the list...\n            item = (XYDataItem) item.clone();\n            if (this.autoSort) {\nif(iterate){\n}\n                this.data.add(~index - 1, item);            }\n            else {\n                this.data.add(item);\n            }\n            updateBoundsForAddedItem(item);\n\n            // check if this addition will exceed the maximum item count...\n            if (getItemCount() > this.maximumItemCount) {\n                XYDataItem removed = (XYDataItem) this.data.remove(0);\n                updateBoundsForRemovedItem(removed);\n            }\n        }\n        fireSeriesChanged();\n        return overwritten;\n    }",
          "69": "    public XYDataItem addOrUpdate(XYDataItem item) {\n        if (item == null) {\n            throw new IllegalArgumentException(\"Null 'item' argument.\");\n        }\n        if (this.allowDuplicateXValues) {\n            add(item);\n            return null;\n        }\n\n        // if we get to here, we know that duplicate X values are not permitted\n        XYDataItem overwritten = null;\n        int index = indexOf(item.getX());\n        if (index >= 0) {\n            XYDataItem existing = (XYDataItem) this.data.get(index);\n            overwritten = (XYDataItem) existing.clone();\n            // figure out if we need to iterate through all the y-values\n            boolean iterate = false;\n            double oldY = existing.getYValue();\n            if (!Double.isNaN(oldY)) {\n                iterate = oldY <= this.minY || oldY >= this.maxY;\n            }\n            existing.setY(item.getY());\n\n            if (iterate) {\n                findBoundsByIteration();\n            }\n            else if (item.getY() != null) {\n                double yy = item.getY().doubleValue();\n                this.minY = minIgnoreNaN(this.minY, yy);\n                this.maxY = minIgnoreNaN(this.maxY, yy);\n            }\n        }\n        else {\n            // if the series is sorted, the negative index is a result from\n            // Collections.binarySearch() and tells us where to insert the\n            // new item...otherwise it will be just -1 and we should just\n            // append the value to the list...\n            item = (XYDataItem) item.clone();\n            if (this.autoSort) {\nthis.data.add((~index - 1), existing);\n            }\n            else {\n                this.data.add(item);\n            }\n            updateBoundsForAddedItem(item);\n\n            // check if this addition will exceed the maximum item count...\n            if (getItemCount() > this.maximumItemCount) {\n                XYDataItem removed = (XYDataItem) this.data.remove(0);\n                updateBoundsForRemovedItem(removed);\n            }\n        }\n        fireSeriesChanged();\n        return overwritten;\n    }",
          "70": "    public XYDataItem addOrUpdate(XYDataItem item) {\n        if (item == null) {\n            throw new IllegalArgumentException(\"Null 'item' argument.\");\n        }\n        if (this.allowDuplicateXValues) {\n            add(item);\n            return null;\n        }\n\n        // if we get to here, we know that duplicate X values are not permitted\n        XYDataItem overwritten = null;\n        int index = indexOf(item.getX());\n        if (index >= 0) {\n            XYDataItem existing = (XYDataItem) this.data.get(index);\n            overwritten = (XYDataItem) existing.clone();\n            // figure out if we need to iterate through all the y-values\n            boolean iterate = false;\n            double oldY = existing.getYValue();\n            if (!Double.isNaN(oldY)) {\n                iterate = oldY <= this.minY || oldY >= this.maxY;\n            }\n            existing.setY(item.getY());\n\n            if (iterate) {\n                findBoundsByIteration();\n            }\n            else if (item.getY() != null) {\n                double yy = item.getY().doubleValue();\n                this.minY = minIgnoreNaN(this.minY, yy);\n                this.maxY = minIgnoreNaN(this.maxY, yy);\n            }\n        }\n        else {\n            // if the series is sorted, the negative index is a result from\n            // Collections.binarySearch() and tells us where to insert the\n            // new item...otherwise it will be just -1 and we should just\n            // append the value to the list...\n            item = (XYDataItem) item.clone();\n            if (this.autoSort) {\nthis.data.add((~index - 1), oldY);\n            }\n            else {\n                this.data.add(item);\n            }\n            updateBoundsForAddedItem(item);\n\n            // check if this addition will exceed the maximum item count...\n            if (getItemCount() > this.maximumItemCount) {\n                XYDataItem removed = (XYDataItem) this.data.remove(0);\n                updateBoundsForRemovedItem(removed);\n            }\n        }\n        fireSeriesChanged();\n        return overwritten;\n    }",
          "71": "    public XYDataItem addOrUpdate(XYDataItem item) {\n        if (item == null) {\n            throw new IllegalArgumentException(\"Null 'item' argument.\");\n        }\n        if (this.allowDuplicateXValues) {\n            add(item);\n            return null;\n        }\n\n        // if we get to here, we know that duplicate X values are not permitted\n        XYDataItem overwritten = null;\n        int index = indexOf(item.getX());\n        if (index >= 0) {\n            XYDataItem existing = (XYDataItem) this.data.get(index);\n            overwritten = (XYDataItem) existing.clone();\n            // figure out if we need to iterate through all the y-values\n            boolean iterate = false;\n            double oldY = existing.getYValue();\n            if (!Double.isNaN(oldY)) {\n                iterate = oldY <= this.minY || oldY >= this.maxY;\n            }\n            existing.setY(item.getY());\n\n            if (iterate) {\n                findBoundsByIteration();\n            }\n            else if (item.getY() != null) {\n                double yy = item.getY().doubleValue();\n                this.minY = minIgnoreNaN(this.minY, yy);\n                this.maxY = minIgnoreNaN(this.maxY, yy);\n            }\n        }\n        else {\n            // if the series is sorted, the negative index is a result from\n            // Collections.binarySearch() and tells us where to insert the\n            // new item...otherwise it will be just -1 and we should just\n            // append the value to the list...\n            item = (XYDataItem) item.clone();\n            if (this.autoSort) {\nthis.item.add(index, false);\n            }\n            else {\n                this.data.add(item);\n            }\n            updateBoundsForAddedItem(item);\n\n            // check if this addition will exceed the maximum item count...\n            if (getItemCount() > this.maximumItemCount) {\n                XYDataItem removed = (XYDataItem) this.data.remove(0);\n                updateBoundsForRemovedItem(removed);\n            }\n        }\n        fireSeriesChanged();\n        return overwritten;\n    }",
          "72": "    public XYDataItem addOrUpdate(XYDataItem item) {\n        if (item == null) {\n            throw new IllegalArgumentException(\"Null 'item' argument.\");\n        }\n        if (this.allowDuplicateXValues) {\n            add(item);\n            return null;\n        }\n\n        // if we get to here, we know that duplicate X values are not permitted\n        XYDataItem overwritten = null;\n        int index = indexOf(item.getX());\n        if (index >= 0) {\n            XYDataItem existing = (XYDataItem) this.data.get(index);\n            overwritten = (XYDataItem) existing.clone();\n            // figure out if we need to iterate through all the y-values\n            boolean iterate = false;\n            double oldY = existing.getYValue();\n            if (!Double.isNaN(oldY)) {\n                iterate = oldY <= this.minY || oldY >= this.maxY;\n            }\n            existing.setY(item.getY());\n\n            if (iterate) {\n                findBoundsByIteration();\n            }\n            else if (item.getY() != null) {\n                double yy = item.getY().doubleValue();\n                this.minY = minIgnoreNaN(this.minY, yy);\n                this.maxY = minIgnoreNaN(this.maxY, yy);\n            }\n        }\n        else {\n            // if the series is sorted, the negative index is a result from\n            // Collections.binarySearch() and tells us where to insert the\n            // new item...otherwise it will be just -1 and we should just\n            // append the value to the list...\n            item = (XYDataItem) item.clone();\n            if (this.autoSort) {\nreturn null;                this.data.add(~index - 1, item);            }\n            else {\n                this.data.add(item);\n            }\n            updateBoundsForAddedItem(item);\n\n            // check if this addition will exceed the maximum item count...\n            if (getItemCount() > this.maximumItemCount) {\n                XYDataItem removed = (XYDataItem) this.data.remove(0);\n                updateBoundsForRemovedItem(removed);\n            }\n        }\n        fireSeriesChanged();\n        return overwritten;\n    }",
          "73": "    public XYDataItem addOrUpdate(XYDataItem item) {\n        if (item == null) {\n            throw new IllegalArgumentException(\"Null 'item' argument.\");\n        }\n        if (this.allowDuplicateXValues) {\n            add(item);\n            return null;\n        }\n\n        // if we get to here, we know that duplicate X values are not permitted\n        XYDataItem overwritten = null;\n        int index = indexOf(item.getX());\n        if (index >= 0) {\n            XYDataItem existing = (XYDataItem) this.data.get(index);\n            overwritten = (XYDataItem) existing.clone();\n            // figure out if we need to iterate through all the y-values\n            boolean iterate = false;\n            double oldY = existing.getYValue();\n            if (!Double.isNaN(oldY)) {\n                iterate = oldY <= this.minY || oldY >= this.maxY;\n            }\n            existing.setY(item.getY());\n\n            if (iterate) {\n                findBoundsByIteration();\n            }\n            else if (item.getY() != null) {\n                double yy = item.getY().doubleValue();\n                this.minY = minIgnoreNaN(this.minY, yy);\n                this.maxY = minIgnoreNaN(this.maxY, yy);\n            }\n        }\n        else {\n            // if the series is sorted, the negative index is a result from\n            // Collections.binarySearch() and tells us where to insert the\n            // new item...otherwise it will be just -1 and we should just\n            // append the value to the list...\n            item = (XYDataItem) item.clone();\n            if (this.autoSort) {\nthis.item.add(index, existing);\n            }\n            else {\n                this.data.add(item);\n            }\n            updateBoundsForAddedItem(item);\n\n            // check if this addition will exceed the maximum item count...\n            if (getItemCount() > this.maximumItemCount) {\n                XYDataItem removed = (XYDataItem) this.data.remove(0);\n                updateBoundsForRemovedItem(removed);\n            }\n        }\n        fireSeriesChanged();\n        return overwritten;\n    }",
          "74": "    public XYDataItem addOrUpdate(XYDataItem item) {\n        if (item == null) {\n            throw new IllegalArgumentException(\"Null 'item' argument.\");\n        }\n        if (this.allowDuplicateXValues) {\n            add(item);\n            return null;\n        }\n\n        // if we get to here, we know that duplicate X values are not permitted\n        XYDataItem overwritten = null;\n        int index = indexOf(item.getX());\n        if (index >= 0) {\n            XYDataItem existing = (XYDataItem) this.data.get(index);\n            overwritten = (XYDataItem) existing.clone();\n            // figure out if we need to iterate through all the y-values\n            boolean iterate = false;\n            double oldY = existing.getYValue();\n            if (!Double.isNaN(oldY)) {\n                iterate = oldY <= this.minY || oldY >= this.maxY;\n            }\n            existing.setY(item.getY());\n\n            if (iterate) {\n                findBoundsByIteration();\n            }\n            else if (item.getY() != null) {\n                double yy = item.getY().doubleValue();\n                this.minY = minIgnoreNaN(this.minY, yy);\n                this.maxY = minIgnoreNaN(this.maxY, yy);\n            }\n        }\n        else {\n            // if the series is sorted, the negative index is a result from\n            // Collections.binarySearch() and tells us where to insert the\n            // new item...otherwise it will be just -1 and we should just\n            // append the value to the list...\n            item = (XYDataItem) item.clone();\n            if (this.autoSort) {\nthis.item.add(index, 1);\n            }\n            else {\n                this.data.add(item);\n            }\n            updateBoundsForAddedItem(item);\n\n            // check if this addition will exceed the maximum item count...\n            if (getItemCount() > this.maximumItemCount) {\n                XYDataItem removed = (XYDataItem) this.data.remove(0);\n                updateBoundsForRemovedItem(removed);\n            }\n        }\n        fireSeriesChanged();\n        return overwritten;\n    }",
          "75": "    public XYDataItem addOrUpdate(XYDataItem item) {\n        if (item == null) {\n            throw new IllegalArgumentException(\"Null 'item' argument.\");\n        }\n        if (this.allowDuplicateXValues) {\n            add(item);\n            return null;\n        }\n\n        // if we get to here, we know that duplicate X values are not permitted\n        XYDataItem overwritten = null;\n        int index = indexOf(item.getX());\n        if (index >= 0) {\n            XYDataItem existing = (XYDataItem) this.data.get(index);\n            overwritten = (XYDataItem) existing.clone();\n            // figure out if we need to iterate through all the y-values\n            boolean iterate = false;\n            double oldY = existing.getYValue();\n            if (!Double.isNaN(oldY)) {\n                iterate = oldY <= this.minY || oldY >= this.maxY;\n            }\n            existing.setY(item.getY());\n\n            if (iterate) {\n                findBoundsByIteration();\n            }\n            else if (item.getY() != null) {\n                double yy = item.getY().doubleValue();\n                this.minY = minIgnoreNaN(this.minY, yy);\n                this.maxY = minIgnoreNaN(this.maxY, yy);\n            }\n        }\n        else {\n            // if the series is sorted, the negative index is a result from\n            // Collections.binarySearch() and tells us where to insert the\n            // new item...otherwise it will be just -1 and we should just\n            // append the value to the list...\n            item = (XYDataItem) item.clone();\n            if (this.autoSort) {\nthis.item.add(index, index);\n            }\n            else {\n                this.data.add(item);\n            }\n            updateBoundsForAddedItem(item);\n\n            // check if this addition will exceed the maximum item count...\n            if (getItemCount() > this.maximumItemCount) {\n                XYDataItem removed = (XYDataItem) this.data.remove(0);\n                updateBoundsForRemovedItem(removed);\n            }\n        }\n        fireSeriesChanged();\n        return overwritten;\n    }",
          "76": "    public XYDataItem addOrUpdate(XYDataItem item) {\n        if (item == null) {\n            throw new IllegalArgumentException(\"Null 'item' argument.\");\n        }\n        if (this.allowDuplicateXValues) {\n            add(item);\n            return null;\n        }\n\n        // if we get to here, we know that duplicate X values are not permitted\n        XYDataItem overwritten = null;\n        int index = indexOf(item.getX());\n        if (index >= 0) {\n            XYDataItem existing = (XYDataItem) this.data.get(index);\n            overwritten = (XYDataItem) existing.clone();\n            // figure out if we need to iterate through all the y-values\n            boolean iterate = false;\n            double oldY = existing.getYValue();\n            if (!Double.isNaN(oldY)) {\n                iterate = oldY <= this.minY || oldY >= this.maxY;\n            }\n            existing.setY(item.getY());\n\n            if (iterate) {\n                findBoundsByIteration();\n            }\n            else if (item.getY() != null) {\n                double yy = item.getY().doubleValue();\n                this.minY = minIgnoreNaN(this.minY, yy);\n                this.maxY = minIgnoreNaN(this.maxY, yy);\n            }\n        }\n        else {\n            // if the series is sorted, the negative index is a result from\n            // Collections.binarySearch() and tells us where to insert the\n            // new item...otherwise it will be just -1 and we should just\n            // append the value to the list...\n            item = (XYDataItem) item.clone();\n            if (this.autoSort) {\nthis.item.add(index, true);\n            }\n            else {\n                this.data.add(item);\n            }\n            updateBoundsForAddedItem(item);\n\n            // check if this addition will exceed the maximum item count...\n            if (getItemCount() > this.maximumItemCount) {\n                XYDataItem removed = (XYDataItem) this.data.remove(0);\n                updateBoundsForRemovedItem(removed);\n            }\n        }\n        fireSeriesChanged();\n        return overwritten;\n    }",
          "77": "    public XYDataItem addOrUpdate(XYDataItem item) {\n        if (item == null) {\n            throw new IllegalArgumentException(\"Null 'item' argument.\");\n        }\n        if (this.allowDuplicateXValues) {\n            add(item);\n            return null;\n        }\n\n        // if we get to here, we know that duplicate X values are not permitted\n        XYDataItem overwritten = null;\n        int index = indexOf(item.getX());\n        if (index >= 0) {\n            XYDataItem existing = (XYDataItem) this.data.get(index);\n            overwritten = (XYDataItem) existing.clone();\n            // figure out if we need to iterate through all the y-values\n            boolean iterate = false;\n            double oldY = existing.getYValue();\n            if (!Double.isNaN(oldY)) {\n                iterate = oldY <= this.minY || oldY >= this.maxY;\n            }\n            existing.setY(item.getY());\n\n            if (iterate) {\n                findBoundsByIteration();\n            }\n            else if (item.getY() != null) {\n                double yy = item.getY().doubleValue();\n                this.minY = minIgnoreNaN(this.minY, yy);\n                this.maxY = minIgnoreNaN(this.maxY, yy);\n            }\n        }\n        else {\n            // if the series is sorted, the negative index is a result from\n            // Collections.binarySearch() and tells us where to insert the\n            // new item...otherwise it will be just -1 and we should just\n            // append the value to the list...\n            item = (XYDataItem) item.clone();\n            if (this.autoSort) {\nthis.data.addOrUpdate((~index - 1), item);\n            }\n            else {\n                this.data.add(item);\n            }\n            updateBoundsForAddedItem(item);\n\n            // check if this addition will exceed the maximum item count...\n            if (getItemCount() > this.maximumItemCount) {\n                XYDataItem removed = (XYDataItem) this.data.remove(0);\n                updateBoundsForRemovedItem(removed);\n            }\n        }\n        fireSeriesChanged();\n        return overwritten;\n    }",
          "78": "    public XYDataItem addOrUpdate(XYDataItem item) {\n        if (item == null) {\n            throw new IllegalArgumentException(\"Null 'item' argument.\");\n        }\n        if (this.allowDuplicateXValues) {\n            add(item);\n            return null;\n        }\n\n        // if we get to here, we know that duplicate X values are not permitted\n        XYDataItem overwritten = null;\n        int index = indexOf(item.getX());\n        if (index >= 0) {\n            XYDataItem existing = (XYDataItem) this.data.get(index);\n            overwritten = (XYDataItem) existing.clone();\n            // figure out if we need to iterate through all the y-values\n            boolean iterate = false;\n            double oldY = existing.getYValue();\n            if (!Double.isNaN(oldY)) {\n                iterate = oldY <= this.minY || oldY >= this.maxY;\n            }\n            existing.setY(item.getY());\n\n            if (iterate) {\n                findBoundsByIteration();\n            }\n            else if (item.getY() != null) {\n                double yy = item.getY().doubleValue();\n                this.minY = minIgnoreNaN(this.minY, yy);\n                this.maxY = minIgnoreNaN(this.maxY, yy);\n            }\n        }\n        else {\n            // if the series is sorted, the negative index is a result from\n            // Collections.binarySearch() and tells us where to insert the\n            // new item...otherwise it will be just -1 and we should just\n            // append the value to the list...\n            item = (XYDataItem) item.clone();\n            if (this.autoSort) {\nthis.item.add((~index - 1), 0);\n            }\n            else {\n                this.data.add(item);\n            }\n            updateBoundsForAddedItem(item);\n\n            // check if this addition will exceed the maximum item count...\n            if (getItemCount() > this.maximumItemCount) {\n                XYDataItem removed = (XYDataItem) this.data.remove(0);\n                updateBoundsForRemovedItem(removed);\n            }\n        }\n        fireSeriesChanged();\n        return overwritten;\n    }",
          "79": "    public XYDataItem addOrUpdate(XYDataItem item) {\n        if (item == null) {\n            throw new IllegalArgumentException(\"Null 'item' argument.\");\n        }\n        if (this.allowDuplicateXValues) {\n            add(item);\n            return null;\n        }\n\n        // if we get to here, we know that duplicate X values are not permitted\n        XYDataItem overwritten = null;\n        int index = indexOf(item.getX());\n        if (index >= 0) {\n            XYDataItem existing = (XYDataItem) this.data.get(index);\n            overwritten = (XYDataItem) existing.clone();\n            // figure out if we need to iterate through all the y-values\n            boolean iterate = false;\n            double oldY = existing.getYValue();\n            if (!Double.isNaN(oldY)) {\n                iterate = oldY <= this.minY || oldY >= this.maxY;\n            }\n            existing.setY(item.getY());\n\n            if (iterate) {\n                findBoundsByIteration();\n            }\n            else if (item.getY() != null) {\n                double yy = item.getY().doubleValue();\n                this.minY = minIgnoreNaN(this.minY, yy);\n                this.maxY = minIgnoreNaN(this.maxY, yy);\n            }\n        }\n        else {\n            // if the series is sorted, the negative index is a result from\n            // Collections.binarySearch() and tells us where to insert the\n            // new item...otherwise it will be just -1 and we should just\n            // append the value to the list...\n            item = (XYDataItem) item.clone();\n            if (this.autoSort) {\nthis.data.minIgnoreNaN((~index - 1), item);\n            }\n            else {\n                this.data.add(item);\n            }\n            updateBoundsForAddedItem(item);\n\n            // check if this addition will exceed the maximum item count...\n            if (getItemCount() > this.maximumItemCount) {\n                XYDataItem removed = (XYDataItem) this.data.remove(0);\n                updateBoundsForRemovedItem(removed);\n            }\n        }\n        fireSeriesChanged();\n        return overwritten;\n    }",
          "80": "    public XYDataItem addOrUpdate(XYDataItem item) {\n        if (item == null) {\n            throw new IllegalArgumentException(\"Null 'item' argument.\");\n        }\n        if (this.allowDuplicateXValues) {\n            add(item);\n            return null;\n        }\n\n        // if we get to here, we know that duplicate X values are not permitted\n        XYDataItem overwritten = null;\n        int index = indexOf(item.getX());\n        if (index >= 0) {\n            XYDataItem existing = (XYDataItem) this.data.get(index);\n            overwritten = (XYDataItem) existing.clone();\n            // figure out if we need to iterate through all the y-values\n            boolean iterate = false;\n            double oldY = existing.getYValue();\n            if (!Double.isNaN(oldY)) {\n                iterate = oldY <= this.minY || oldY >= this.maxY;\n            }\n            existing.setY(item.getY());\n\n            if (iterate) {\n                findBoundsByIteration();\n            }\n            else if (item.getY() != null) {\n                double yy = item.getY().doubleValue();\n                this.minY = minIgnoreNaN(this.minY, yy);\n                this.maxY = minIgnoreNaN(this.maxY, yy);\n            }\n        }\n        else {\n            // if the series is sorted, the negative index is a result from\n            // Collections.binarySearch() and tells us where to insert the\n            // new item...otherwise it will be just -1 and we should just\n            // append the value to the list...\n            item = (XYDataItem) item.clone();\n            if (this.autoSort) {\nreturn;\n                this.data.add(~index - 1, item);            }\n            else {\n                this.data.add(item);\n            }\n            updateBoundsForAddedItem(item);\n\n            // check if this addition will exceed the maximum item count...\n            if (getItemCount() > this.maximumItemCount) {\n                XYDataItem removed = (XYDataItem) this.data.remove(0);\n                updateBoundsForRemovedItem(removed);\n            }\n        }\n        fireSeriesChanged();\n        return overwritten;\n    }",
          "81": "    public XYDataItem addOrUpdate(XYDataItem item) {\n        if (item == null) {\n            throw new IllegalArgumentException(\"Null 'item' argument.\");\n        }\n        if (this.allowDuplicateXValues) {\n            add(item);\n            return null;\n        }\n\n        // if we get to here, we know that duplicate X values are not permitted\n        XYDataItem overwritten = null;\n        int index = indexOf(item.getX());\n        if (index >= 0) {\n            XYDataItem existing = (XYDataItem) this.data.get(index);\n            overwritten = (XYDataItem) existing.clone();\n            // figure out if we need to iterate through all the y-values\n            boolean iterate = false;\n            double oldY = existing.getYValue();\n            if (!Double.isNaN(oldY)) {\n                iterate = oldY <= this.minY || oldY >= this.maxY;\n            }\n            existing.setY(item.getY());\n\n            if (iterate) {\n                findBoundsByIteration();\n            }\n            else if (item.getY() != null) {\n                double yy = item.getY().doubleValue();\n                this.minY = minIgnoreNaN(this.minY, yy);\n                this.maxY = minIgnoreNaN(this.maxY, yy);\n            }\n        }\n        else {\n            // if the series is sorted, the negative index is a result from\n            // Collections.binarySearch() and tells us where to insert the\n            // new item...otherwise it will be just -1 and we should just\n            // append the value to the list...\n            item = (XYDataItem) item.clone();\n            if (this.autoSort) {\nbreak;\n                this.data.add(~index - 1, item);            }\n            else {\n                this.data.add(item);\n            }\n            updateBoundsForAddedItem(item);\n\n            // check if this addition will exceed the maximum item count...\n            if (getItemCount() > this.maximumItemCount) {\n                XYDataItem removed = (XYDataItem) this.data.remove(0);\n                updateBoundsForRemovedItem(removed);\n            }\n        }\n        fireSeriesChanged();\n        return overwritten;\n    }",
          "82": "    public XYDataItem addOrUpdate(XYDataItem item) {\n        if (item == null) {\n            throw new IllegalArgumentException(\"Null 'item' argument.\");\n        }\n        if (this.allowDuplicateXValues) {\n            add(item);\n            return null;\n        }\n\n        // if we get to here, we know that duplicate X values are not permitted\n        XYDataItem overwritten = null;\n        int index = indexOf(item.getX());\n        if (index >= 0) {\n            XYDataItem existing = (XYDataItem) this.data.get(index);\n            overwritten = (XYDataItem) existing.clone();\n            // figure out if we need to iterate through all the y-values\n            boolean iterate = false;\n            double oldY = existing.getYValue();\n            if (!Double.isNaN(oldY)) {\n                iterate = oldY <= this.minY || oldY >= this.maxY;\n            }\n            existing.setY(item.getY());\n\n            if (iterate) {\n                findBoundsByIteration();\n            }\n            else if (item.getY() != null) {\n                double yy = item.getY().doubleValue();\n                this.minY = minIgnoreNaN(this.minY, yy);\n                this.maxY = minIgnoreNaN(this.maxY, yy);\n            }\n        }\n        else {\n            // if the series is sorted, the negative index is a result from\n            // Collections.binarySearch() and tells us where to insert the\n            // new item...otherwise it will be just -1 and we should just\n            // append the value to the list...\n            item = (XYDataItem) item.clone();\n            if (this.autoSort) {\nthis.item.add(item, (~index - 1));\n            }\n            else {\n                this.data.add(item);\n            }\n            updateBoundsForAddedItem(item);\n\n            // check if this addition will exceed the maximum item count...\n            if (getItemCount() > this.maximumItemCount) {\n                XYDataItem removed = (XYDataItem) this.data.remove(0);\n                updateBoundsForRemovedItem(removed);\n            }\n        }\n        fireSeriesChanged();\n        return overwritten;\n    }",
          "83": "    public XYDataItem addOrUpdate(XYDataItem item) {\n        if (item == null) {\n            throw new IllegalArgumentException(\"Null 'item' argument.\");\n        }\n        if (this.allowDuplicateXValues) {\n            add(item);\n            return null;\n        }\n\n        // if we get to here, we know that duplicate X values are not permitted\n        XYDataItem overwritten = null;\n        int index = indexOf(item.getX());\n        if (index >= 0) {\n            XYDataItem existing = (XYDataItem) this.data.get(index);\n            overwritten = (XYDataItem) existing.clone();\n            // figure out if we need to iterate through all the y-values\n            boolean iterate = false;\n            double oldY = existing.getYValue();\n            if (!Double.isNaN(oldY)) {\n                iterate = oldY <= this.minY || oldY >= this.maxY;\n            }\n            existing.setY(item.getY());\n\n            if (iterate) {\n                findBoundsByIteration();\n            }\n            else if (item.getY() != null) {\n                double yy = item.getY().doubleValue();\n                this.minY = minIgnoreNaN(this.minY, yy);\n                this.maxY = minIgnoreNaN(this.maxY, yy);\n            }\n        }\n        else {\n            // if the series is sorted, the negative index is a result from\n            // Collections.binarySearch() and tells us where to insert the\n            // new item...otherwise it will be just -1 and we should just\n            // append the value to the list...\n            item = (XYDataItem) item.clone();\n            if (this.autoSort) {\nthis.data.add(index, 0);\n            }\n            else {\n                this.data.add(item);\n            }\n            updateBoundsForAddedItem(item);\n\n            // check if this addition will exceed the maximum item count...\n            if (getItemCount() > this.maximumItemCount) {\n                XYDataItem removed = (XYDataItem) this.data.remove(0);\n                updateBoundsForRemovedItem(removed);\n            }\n        }\n        fireSeriesChanged();\n        return overwritten;\n    }",
          "84": "    public XYDataItem addOrUpdate(XYDataItem item) {\n        if (item == null) {\n            throw new IllegalArgumentException(\"Null 'item' argument.\");\n        }\n        if (this.allowDuplicateXValues) {\n            add(item);\n            return null;\n        }\n\n        // if we get to here, we know that duplicate X values are not permitted\n        XYDataItem overwritten = null;\n        int index = indexOf(item.getX());\n        if (index >= 0) {\n            XYDataItem existing = (XYDataItem) this.data.get(index);\n            overwritten = (XYDataItem) existing.clone();\n            // figure out if we need to iterate through all the y-values\n            boolean iterate = false;\n            double oldY = existing.getYValue();\n            if (!Double.isNaN(oldY)) {\n                iterate = oldY <= this.minY || oldY >= this.maxY;\n            }\n            existing.setY(item.getY());\n\n            if (iterate) {\n                findBoundsByIteration();\n            }\n            else if (item.getY() != null) {\n                double yy = item.getY().doubleValue();\n                this.minY = minIgnoreNaN(this.minY, yy);\n                this.maxY = minIgnoreNaN(this.maxY, yy);\n            }\n        }\n        else {\n            // if the series is sorted, the negative index is a result from\n            // Collections.binarySearch() and tells us where to insert the\n            // new item...otherwise it will be just -1 and we should just\n            // append the value to the list...\n            item = (XYDataItem) item.clone();\n            if (this.autoSort) {\nthis.item.add(index, (~index - 1), 0);\n            }\n            else {\n                this.data.add(item);\n            }\n            updateBoundsForAddedItem(item);\n\n            // check if this addition will exceed the maximum item count...\n            if (getItemCount() > this.maximumItemCount) {\n                XYDataItem removed = (XYDataItem) this.data.remove(0);\n                updateBoundsForRemovedItem(removed);\n            }\n        }\n        fireSeriesChanged();\n        return overwritten;\n    }",
          "85": "    public XYDataItem addOrUpdate(XYDataItem item) {\n        if (item == null) {\n            throw new IllegalArgumentException(\"Null 'item' argument.\");\n        }\n        if (this.allowDuplicateXValues) {\n            add(item);\n            return null;\n        }\n\n        // if we get to here, we know that duplicate X values are not permitted\n        XYDataItem overwritten = null;\n        int index = indexOf(item.getX());\n        if (index >= 0) {\n            XYDataItem existing = (XYDataItem) this.data.get(index);\n            overwritten = (XYDataItem) existing.clone();\n            // figure out if we need to iterate through all the y-values\n            boolean iterate = false;\n            double oldY = existing.getYValue();\n            if (!Double.isNaN(oldY)) {\n                iterate = oldY <= this.minY || oldY >= this.maxY;\n            }\n            existing.setY(item.getY());\n\n            if (iterate) {\n                findBoundsByIteration();\n            }\n            else if (item.getY() != null) {\n                double yy = item.getY().doubleValue();\n                this.minY = minIgnoreNaN(this.minY, yy);\n                this.maxY = minIgnoreNaN(this.maxY, yy);\n            }\n        }\n        else {\n            // if the series is sorted, the negative index is a result from\n            // Collections.binarySearch() and tells us where to insert the\n            // new item...otherwise it will be just -1 and we should just\n            // append the value to the list...\n            item = (XYDataItem) item.clone();\n            if (this.autoSort) {\nthis.item.add(index, ((~index - 1) + 1));\n            }\n            else {\n                this.data.add(item);\n            }\n            updateBoundsForAddedItem(item);\n\n            // check if this addition will exceed the maximum item count...\n            if (getItemCount() > this.maximumItemCount) {\n                XYDataItem removed = (XYDataItem) this.data.remove(0);\n                updateBoundsForRemovedItem(removed);\n            }\n        }\n        fireSeriesChanged();\n        return overwritten;\n    }",
          "86": "    public XYDataItem addOrUpdate(XYDataItem item) {\n        if (item == null) {\n            throw new IllegalArgumentException(\"Null 'item' argument.\");\n        }\n        if (this.allowDuplicateXValues) {\n            add(item);\n            return null;\n        }\n\n        // if we get to here, we know that duplicate X values are not permitted\n        XYDataItem overwritten = null;\n        int index = indexOf(item.getX());\n        if (index >= 0) {\n            XYDataItem existing = (XYDataItem) this.data.get(index);\n            overwritten = (XYDataItem) existing.clone();\n            // figure out if we need to iterate through all the y-values\n            boolean iterate = false;\n            double oldY = existing.getYValue();\n            if (!Double.isNaN(oldY)) {\n                iterate = oldY <= this.minY || oldY >= this.maxY;\n            }\n            existing.setY(item.getY());\n\n            if (iterate) {\n                findBoundsByIteration();\n            }\n            else if (item.getY() != null) {\n                double yy = item.getY().doubleValue();\n                this.minY = minIgnoreNaN(this.minY, yy);\n                this.maxY = minIgnoreNaN(this.maxY, yy);\n            }\n        }\n        else {\n            // if the series is sorted, the negative index is a result from\n            // Collections.binarySearch() and tells us where to insert the\n            // new item...otherwise it will be just -1 and we should just\n            // append the value to the list...\n            item = (XYDataItem) item.clone();\n            if (this.autoSort) {\ncontinue;\n                this.data.add(~index - 1, item);            }\n            else {\n                this.data.add(item);\n            }\n            updateBoundsForAddedItem(item);\n\n            // check if this addition will exceed the maximum item count...\n            if (getItemCount() > this.maximumItemCount) {\n                XYDataItem removed = (XYDataItem) this.data.remove(0);\n                updateBoundsForRemovedItem(removed);\n            }\n        }\n        fireSeriesChanged();\n        return overwritten;\n    }",
          "87": "    public XYDataItem addOrUpdate(XYDataItem item) {\n        if (item == null) {\n            throw new IllegalArgumentException(\"Null 'item' argument.\");\n        }\n        if (this.allowDuplicateXValues) {\n            add(item);\n            return null;\n        }\n\n        // if we get to here, we know that duplicate X values are not permitted\n        XYDataItem overwritten = null;\n        int index = indexOf(item.getX());\n        if (index >= 0) {\n            XYDataItem existing = (XYDataItem) this.data.get(index);\n            overwritten = (XYDataItem) existing.clone();\n            // figure out if we need to iterate through all the y-values\n            boolean iterate = false;\n            double oldY = existing.getYValue();\n            if (!Double.isNaN(oldY)) {\n                iterate = oldY <= this.minY || oldY >= this.maxY;\n            }\n            existing.setY(item.getY());\n\n            if (iterate) {\n                findBoundsByIteration();\n            }\n            else if (item.getY() != null) {\n                double yy = item.getY().doubleValue();\n                this.minY = minIgnoreNaN(this.minY, yy);\n                this.maxY = minIgnoreNaN(this.maxY, yy);\n            }\n        }\n        else {\n            // if the series is sorted, the negative index is a result from\n            // Collections.binarySearch() and tells us where to insert the\n            // new item...otherwise it will be just -1 and we should just\n            // append the value to the list...\n            item = (XYDataItem) item.clone();\n            if (this.autoSort) {\nthis.item.add(index, (existing - 1));\n            }\n            else {\n                this.data.add(item);\n            }\n            updateBoundsForAddedItem(item);\n\n            // check if this addition will exceed the maximum item count...\n            if (getItemCount() > this.maximumItemCount) {\n                XYDataItem removed = (XYDataItem) this.data.remove(0);\n                updateBoundsForRemovedItem(removed);\n            }\n        }\n        fireSeriesChanged();\n        return overwritten;\n    }"
}