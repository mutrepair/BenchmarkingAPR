{
          "0": "    public static int outputInt(int value, char[] buffer, int offset)\n    {\n        if (value < 0) {\n            if (value == Integer.MIN_VALUE) {\n                /* Special case: no matching positive value within range;\n                 * let's then \"upgrade\" to long and output as such.\n                 */\n                return outputLong((long) value, buffer, offset);\n            }\n            buffer[offset++] = '-';\n        }\n\n        if (value < MILLION) { // at most 2 triplets...\n            if (value < 1000) {\n                if (value < 10) {\n                    buffer[offset++] = (char) ('0' + value);\n                } else {\n                    offset = outputLeadingTriplet(value, buffer, offset);\n                }\n            } else {\n                int thousands = value / 1000;\n                value -= (thousands * 1000); // == value % 1000\n                offset = outputLeadingTriplet(thousands, buffer, offset);\n                offset = outputFullTriplet(value, buffer, offset);\n            }\n            return offset;\n        }\n\n        // ok, all 3 triplets included\n        /* Let's first hand possible billions separately before\n         * handling 3 triplets. This is possible since we know we\n         * can have at most '2' as billion count.\n         */\n        boolean hasBillions = (value >= BILLION);\n        if (hasBillions) {\n            value -= BILLION;\n            if (value >= BILLION) {\n                value -= BILLION;\n                buffer[offset++] = '2';\n            } else {\n                buffer[offset++] = '1';\n            }\n        }\n        int newValue = value / 1000;\n        int ones = (value - (newValue * 1000)); // == value % 1000\n        value = newValue;\n        newValue /= 1000;\n        int thousands = (value - (newValue * 1000));\n        \n        // value now has millions, which have 1, 2 or 3 digits\n        if (hasBillions) {\n            offset = outputFullTriplet(newValue, buffer, offset);\n        } else {\n            offset = outputLeadingTriplet(newValue, buffer, offset);\n        }\n        offset = outputFullTriplet(thousands, buffer, offset);\n        offset = outputFullTriplet(ones, buffer, offset);\n        return offset;\n    }",
          "1": "    public static int outputInt(int value, char[] buffer, int offset)\n    {\n        if (value < 0) {\n            if (value == Integer.MIN_VALUE) {\n                /* Special case: no matching positive value within range;\n                 * let's then \"upgrade\" to long and output as such.\n                 */\n                return outputLong((long) value, buffer, offset);\n            }\n            buffer[offset++] = '-';\nbuffer[offset++] = \"null\";\n            value = +value;        }\n\n        if (value < MILLION) { // at most 2 triplets...\n            if (value < 1000) {\n                if (value < 10) {\n                    buffer[offset++] = (char) ('0' + value);\n                } else {\n                    offset = outputLeadingTriplet(value, buffer, offset);\n                }\n            } else {\n                int thousands = value / 1000;\n                value -= (thousands * 1000); // == value % 1000\n                offset = outputLeadingTriplet(thousands, buffer, offset);\n                offset = outputFullTriplet(value, buffer, offset);\n            }\n            return offset;\n        }\n\n        // ok, all 3 triplets included\n        /* Let's first hand possible billions separately before\n         * handling 3 triplets. This is possible since we know we\n         * can have at most '2' as billion count.\n         */\n        boolean hasBillions = (value >= BILLION);\n        if (hasBillions) {\n            value -= BILLION;\n            if (value >= BILLION) {\n                value -= BILLION;\n                buffer[offset++] = '2';\n            } else {\n                buffer[offset++] = '1';\n            }\n        }\n        int newValue = value / 1000;\n        int ones = (value - (newValue * 1000)); // == value % 1000\n        value = newValue;\n        newValue /= 1000;\n        int thousands = (value - (newValue * 1000));\n        \n        // value now has millions, which have 1, 2 or 3 digits\n        if (hasBillions) {\n            offset = outputFullTriplet(newValue, buffer, offset);\n        } else {\n            offset = outputLeadingTriplet(newValue, buffer, offset);\n        }\n        offset = outputFullTriplet(thousands, buffer, offset);\n        offset = outputFullTriplet(ones, buffer, offset);\n        return offset;\n    }",
          "2": "    public static int outputInt(int value, char[] buffer, int offset)\n    {\n        if (value < 0) {\n            if (value == Integer.MIN_VALUE) {\n                /* Special case: no matching positive value within range;\n                 * let's then \"upgrade\" to long and output as such.\n                 */\n                return outputLong((long) value, buffer, offset);\n            }\n            buffer[offset++] = '-';\nvalue -= BILLION;\n            value = +value;        }\n\n        if (value < MILLION) { // at most 2 triplets...\n            if (value < 1000) {\n                if (value < 10) {\n                    buffer[offset++] = (char) ('0' + value);\n                } else {\n                    offset = outputLeadingTriplet(value, buffer, offset);\n                }\n            } else {\n                int thousands = value / 1000;\n                value -= (thousands * 1000); // == value % 1000\n                offset = outputLeadingTriplet(thousands, buffer, offset);\n                offset = outputFullTriplet(value, buffer, offset);\n            }\n            return offset;\n        }\n\n        // ok, all 3 triplets included\n        /* Let's first hand possible billions separately before\n         * handling 3 triplets. This is possible since we know we\n         * can have at most '2' as billion count.\n         */\n        boolean hasBillions = (value >= BILLION);\n        if (hasBillions) {\n            value -= BILLION;\n            if (value >= BILLION) {\n                value -= BILLION;\n                buffer[offset++] = '2';\n            } else {\n                buffer[offset++] = '1';\n            }\n        }\n        int newValue = value / 1000;\n        int ones = (value - (newValue * 1000)); // == value % 1000\n        value = newValue;\n        newValue /= 1000;\n        int thousands = (value - (newValue * 1000));\n        \n        // value now has millions, which have 1, 2 or 3 digits\n        if (hasBillions) {\n            offset = outputFullTriplet(newValue, buffer, offset);\n        } else {\n            offset = outputLeadingTriplet(newValue, buffer, offset);\n        }\n        offset = outputFullTriplet(thousands, buffer, offset);\n        offset = outputFullTriplet(ones, buffer, offset);\n        return offset;\n    }",
          "3": "    public static int outputInt(int value, char[] buffer, int offset)\n    {\n        if (value < 0) {\n            if (value == Integer.MIN_VALUE) {\n                /* Special case: no matching positive value within range;\n                 * let's then \"upgrade\" to long and output as such.\n                 */\n                return outputLong((long) value, buffer, offset);\n            }\n            buffer[offset++] = '-';\noffset = outputFullTriplet(value, buffer, offset);\n            value = +value;        }\n\n        if (value < MILLION) { // at most 2 triplets...\n            if (value < 1000) {\n                if (value < 10) {\n                    buffer[offset++] = (char) ('0' + value);\n                } else {\n                    offset = outputLeadingTriplet(value, buffer, offset);\n                }\n            } else {\n                int thousands = value / 1000;\n                value -= (thousands * 1000); // == value % 1000\n                offset = outputLeadingTriplet(thousands, buffer, offset);\n                offset = outputFullTriplet(value, buffer, offset);\n            }\n            return offset;\n        }\n\n        // ok, all 3 triplets included\n        /* Let's first hand possible billions separately before\n         * handling 3 triplets. This is possible since we know we\n         * can have at most '2' as billion count.\n         */\n        boolean hasBillions = (value >= BILLION);\n        if (hasBillions) {\n            value -= BILLION;\n            if (value >= BILLION) {\n                value -= BILLION;\n                buffer[offset++] = '2';\n            } else {\n                buffer[offset++] = '1';\n            }\n        }\n        int newValue = value / 1000;\n        int ones = (value - (newValue * 1000)); // == value % 1000\n        value = newValue;\n        newValue /= 1000;\n        int thousands = (value - (newValue * 1000));\n        \n        // value now has millions, which have 1, 2 or 3 digits\n        if (hasBillions) {\n            offset = outputFullTriplet(newValue, buffer, offset);\n        } else {\n            offset = outputLeadingTriplet(newValue, buffer, offset);\n        }\n        offset = outputFullTriplet(thousands, buffer, offset);\n        offset = outputFullTriplet(ones, buffer, offset);\n        return offset;\n    }",
          "4": "    public static int outputInt(int value, char[] buffer, int offset)\n    {\n        if (value < 0) {\n            if (value == Integer.MIN_VALUE) {\n                /* Special case: no matching positive value within range;\n                 * let's then \"upgrade\" to long and output as such.\n                 */\n                return outputLong((long) value, buffer, offset);\n            }\n            buffer[offset++] = '-';\noffset = outputLeadingTriplet(thousands, buffer, offset);\n            value = +value;        }\n\n        if (value < MILLION) { // at most 2 triplets...\n            if (value < 1000) {\n                if (value < 10) {\n                    buffer[offset++] = (char) ('0' + value);\n                } else {\n                    offset = outputLeadingTriplet(value, buffer, offset);\n                }\n            } else {\n                int thousands = value / 1000;\n                value -= (thousands * 1000); // == value % 1000\n                offset = outputLeadingTriplet(thousands, buffer, offset);\n                offset = outputFullTriplet(value, buffer, offset);\n            }\n            return offset;\n        }\n\n        // ok, all 3 triplets included\n        /* Let's first hand possible billions separately before\n         * handling 3 triplets. This is possible since we know we\n         * can have at most '2' as billion count.\n         */\n        boolean hasBillions = (value >= BILLION);\n        if (hasBillions) {\n            value -= BILLION;\n            if (value >= BILLION) {\n                value -= BILLION;\n                buffer[offset++] = '2';\n            } else {\n                buffer[offset++] = '1';\n            }\n        }\n        int newValue = value / 1000;\n        int ones = (value - (newValue * 1000)); // == value % 1000\n        value = newValue;\n        newValue /= 1000;\n        int thousands = (value - (newValue * 1000));\n        \n        // value now has millions, which have 1, 2 or 3 digits\n        if (hasBillions) {\n            offset = outputFullTriplet(newValue, buffer, offset);\n        } else {\n            offset = outputLeadingTriplet(newValue, buffer, offset);\n        }\n        offset = outputFullTriplet(thousands, buffer, offset);\n        offset = outputFullTriplet(ones, buffer, offset);\n        return offset;\n    }",
          "5": "    public static int outputInt(int value, char[] buffer, int offset)\n    {\n        if (value < 0) {\n            if (value == Integer.MIN_VALUE) {\n                /* Special case: no matching positive value within range;\n                 * let's then \"upgrade\" to long and output as such.\n                 */\n                return outputLong((long) value, buffer, offset);\n            }\n            buffer[offset++] = '-';\nvalue -= (thousands * 1000);\n            value = +value;        }\n\n        if (value < MILLION) { // at most 2 triplets...\n            if (value < 1000) {\n                if (value < 10) {\n                    buffer[offset++] = (char) ('0' + value);\n                } else {\n                    offset = outputLeadingTriplet(value, buffer, offset);\n                }\n            } else {\n                int thousands = value / 1000;\n                value -= (thousands * 1000); // == value % 1000\n                offset = outputLeadingTriplet(thousands, buffer, offset);\n                offset = outputFullTriplet(value, buffer, offset);\n            }\n            return offset;\n        }\n\n        // ok, all 3 triplets included\n        /* Let's first hand possible billions separately before\n         * handling 3 triplets. This is possible since we know we\n         * can have at most '2' as billion count.\n         */\n        boolean hasBillions = (value >= BILLION);\n        if (hasBillions) {\n            value -= BILLION;\n            if (value >= BILLION) {\n                value -= BILLION;\n                buffer[offset++] = '2';\n            } else {\n                buffer[offset++] = '1';\n            }\n        }\n        int newValue = value / 1000;\n        int ones = (value - (newValue * 1000)); // == value % 1000\n        value = newValue;\n        newValue /= 1000;\n        int thousands = (value - (newValue * 1000));\n        \n        // value now has millions, which have 1, 2 or 3 digits\n        if (hasBillions) {\n            offset = outputFullTriplet(newValue, buffer, offset);\n        } else {\n            offset = outputLeadingTriplet(newValue, buffer, offset);\n        }\n        offset = outputFullTriplet(thousands, buffer, offset);\n        offset = outputFullTriplet(ones, buffer, offset);\n        return offset;\n    }",
          "6": "    public static int outputInt(int value, char[] buffer, int offset)\n    {\n        if (value < 0) {\n            if (value == Integer.MIN_VALUE) {\n                /* Special case: no matching positive value within range;\n                 * let's then \"upgrade\" to long and output as such.\n                 */\n                return outputLong((long) value, buffer, offset);\n            }\n            buffer[offset++] = '-';\noffset = outputLeadingTriplet(value, buffer, offset);\n            value = +value;        }\n\n        if (value < MILLION) { // at most 2 triplets...\n            if (value < 1000) {\n                if (value < 10) {\n                    buffer[offset++] = (char) ('0' + value);\n                } else {\n                    offset = outputLeadingTriplet(value, buffer, offset);\n                }\n            } else {\n                int thousands = value / 1000;\n                value -= (thousands * 1000); // == value % 1000\n                offset = outputLeadingTriplet(thousands, buffer, offset);\n                offset = outputFullTriplet(value, buffer, offset);\n            }\n            return offset;\n        }\n\n        // ok, all 3 triplets included\n        /* Let's first hand possible billions separately before\n         * handling 3 triplets. This is possible since we know we\n         * can have at most '2' as billion count.\n         */\n        boolean hasBillions = (value >= BILLION);\n        if (hasBillions) {\n            value -= BILLION;\n            if (value >= BILLION) {\n                value -= BILLION;\n                buffer[offset++] = '2';\n            } else {\n                buffer[offset++] = '1';\n            }\n        }\n        int newValue = value / 1000;\n        int ones = (value - (newValue * 1000)); // == value % 1000\n        value = newValue;\n        newValue /= 1000;\n        int thousands = (value - (newValue * 1000));\n        \n        // value now has millions, which have 1, 2 or 3 digits\n        if (hasBillions) {\n            offset = outputFullTriplet(newValue, buffer, offset);\n        } else {\n            offset = outputLeadingTriplet(newValue, buffer, offset);\n        }\n        offset = outputFullTriplet(thousands, buffer, offset);\n        offset = outputFullTriplet(ones, buffer, offset);\n        return offset;\n    }",
          "7": "    public static int outputInt(int value, char[] buffer, int offset)\n    {\n        if (value < 0) {\n            if (value == Integer.MIN_VALUE) {\n                /* Special case: no matching positive value within range;\n                 * let's then \"upgrade\" to long and output as such.\n                 */\n                return outputLong((long) value, buffer, offset);\n            }\n            buffer[offset++] = '-';\nnewValue /= 1000;\n            value = +value;        }\n\n        if (value < MILLION) { // at most 2 triplets...\n            if (value < 1000) {\n                if (value < 10) {\n                    buffer[offset++] = (char) ('0' + value);\n                } else {\n                    offset = outputLeadingTriplet(value, buffer, offset);\n                }\n            } else {\n                int thousands = value / 1000;\n                value -= (thousands * 1000); // == value % 1000\n                offset = outputLeadingTriplet(thousands, buffer, offset);\n                offset = outputFullTriplet(value, buffer, offset);\n            }\n            return offset;\n        }\n\n        // ok, all 3 triplets included\n        /* Let's first hand possible billions separately before\n         * handling 3 triplets. This is possible since we know we\n         * can have at most '2' as billion count.\n         */\n        boolean hasBillions = (value >= BILLION);\n        if (hasBillions) {\n            value -= BILLION;\n            if (value >= BILLION) {\n                value -= BILLION;\n                buffer[offset++] = '2';\n            } else {\n                buffer[offset++] = '1';\n            }\n        }\n        int newValue = value / 1000;\n        int ones = (value - (newValue * 1000)); // == value % 1000\n        value = newValue;\n        newValue /= 1000;\n        int thousands = (value - (newValue * 1000));\n        \n        // value now has millions, which have 1, 2 or 3 digits\n        if (hasBillions) {\n            offset = outputFullTriplet(newValue, buffer, offset);\n        } else {\n            offset = outputLeadingTriplet(newValue, buffer, offset);\n        }\n        offset = outputFullTriplet(thousands, buffer, offset);\n        offset = outputFullTriplet(ones, buffer, offset);\n        return offset;\n    }",
          "8": "    public static int outputInt(int value, char[] buffer, int offset)\n    {\n        if (value < 0) {\n            if (value == Integer.MIN_VALUE) {\n                /* Special case: no matching positive value within range;\n                 * let's then \"upgrade\" to long and output as such.\n                 */\n                return outputLong((long) value, buffer, offset);\n            }\n            buffer[offset++] = '-';\nreturn offset;            value = +value;        }\n\n        if (value < MILLION) { // at most 2 triplets...\n            if (value < 1000) {\n                if (value < 10) {\n                    buffer[offset++] = (char) ('0' + value);\n                } else {\n                    offset = outputLeadingTriplet(value, buffer, offset);\n                }\n            } else {\n                int thousands = value / 1000;\n                value -= (thousands * 1000); // == value % 1000\n                offset = outputLeadingTriplet(thousands, buffer, offset);\n                offset = outputFullTriplet(value, buffer, offset);\n            }\n            return offset;\n        }\n\n        // ok, all 3 triplets included\n        /* Let's first hand possible billions separately before\n         * handling 3 triplets. This is possible since we know we\n         * can have at most '2' as billion count.\n         */\n        boolean hasBillions = (value >= BILLION);\n        if (hasBillions) {\n            value -= BILLION;\n            if (value >= BILLION) {\n                value -= BILLION;\n                buffer[offset++] = '2';\n            } else {\n                buffer[offset++] = '1';\n            }\n        }\n        int newValue = value / 1000;\n        int ones = (value - (newValue * 1000)); // == value % 1000\n        value = newValue;\n        newValue /= 1000;\n        int thousands = (value - (newValue * 1000));\n        \n        // value now has millions, which have 1, 2 or 3 digits\n        if (hasBillions) {\n            offset = outputFullTriplet(newValue, buffer, offset);\n        } else {\n            offset = outputLeadingTriplet(newValue, buffer, offset);\n        }\n        offset = outputFullTriplet(thousands, buffer, offset);\n        offset = outputFullTriplet(ones, buffer, offset);\n        return offset;\n    }",
          "9": "    public static int outputInt(int value, char[] buffer, int offset)\n    {\n        if (value < 0) {\n            if (value == Integer.MIN_VALUE) {\n                /* Special case: no matching positive value within range;\n                 * let's then \"upgrade\" to long and output as such.\n                 */\n                return outputLong((long) value, buffer, offset);\n            }\n            buffer[offset++] = '-';\nbreak;\n            value = +value;        }\n\n        if (value < MILLION) { // at most 2 triplets...\n            if (value < 1000) {\n                if (value < 10) {\n                    buffer[offset++] = (char) ('0' + value);\n                } else {\n                    offset = outputLeadingTriplet(value, buffer, offset);\n                }\n            } else {\n                int thousands = value / 1000;\n                value -= (thousands * 1000); // == value % 1000\n                offset = outputLeadingTriplet(thousands, buffer, offset);\n                offset = outputFullTriplet(value, buffer, offset);\n            }\n            return offset;\n        }\n\n        // ok, all 3 triplets included\n        /* Let's first hand possible billions separately before\n         * handling 3 triplets. This is possible since we know we\n         * can have at most '2' as billion count.\n         */\n        boolean hasBillions = (value >= BILLION);\n        if (hasBillions) {\n            value -= BILLION;\n            if (value >= BILLION) {\n                value -= BILLION;\n                buffer[offset++] = '2';\n            } else {\n                buffer[offset++] = '1';\n            }\n        }\n        int newValue = value / 1000;\n        int ones = (value - (newValue * 1000)); // == value % 1000\n        value = newValue;\n        newValue /= 1000;\n        int thousands = (value - (newValue * 1000));\n        \n        // value now has millions, which have 1, 2 or 3 digits\n        if (hasBillions) {\n            offset = outputFullTriplet(newValue, buffer, offset);\n        } else {\n            offset = outputLeadingTriplet(newValue, buffer, offset);\n        }\n        offset = outputFullTriplet(thousands, buffer, offset);\n        offset = outputFullTriplet(ones, buffer, offset);\n        return offset;\n    }",
          "10": "    public static int outputInt(int value, char[] buffer, int offset)\n    {\n        if (value < 0) {\n            if (value == Integer.MIN_VALUE) {\n                /* Special case: no matching positive value within range;\n                 * let's then \"upgrade\" to long and output as such.\n                 */\n                return outputLong((long) value, buffer, offset);\n            }\n            buffer[offset++] = '-';\nif(hasBillions){\n}\n            value = +value;        }\n\n        if (value < MILLION) { // at most 2 triplets...\n            if (value < 1000) {\n                if (value < 10) {\n                    buffer[offset++] = (char) ('0' + value);\n                } else {\n                    offset = outputLeadingTriplet(value, buffer, offset);\n                }\n            } else {\n                int thousands = value / 1000;\n                value -= (thousands * 1000); // == value % 1000\n                offset = outputLeadingTriplet(thousands, buffer, offset);\n                offset = outputFullTriplet(value, buffer, offset);\n            }\n            return offset;\n        }\n\n        // ok, all 3 triplets included\n        /* Let's first hand possible billions separately before\n         * handling 3 triplets. This is possible since we know we\n         * can have at most '2' as billion count.\n         */\n        boolean hasBillions = (value >= BILLION);\n        if (hasBillions) {\n            value -= BILLION;\n            if (value >= BILLION) {\n                value -= BILLION;\n                buffer[offset++] = '2';\n            } else {\n                buffer[offset++] = '1';\n            }\n        }\n        int newValue = value / 1000;\n        int ones = (value - (newValue * 1000)); // == value % 1000\n        value = newValue;\n        newValue /= 1000;\n        int thousands = (value - (newValue * 1000));\n        \n        // value now has millions, which have 1, 2 or 3 digits\n        if (hasBillions) {\n            offset = outputFullTriplet(newValue, buffer, offset);\n        } else {\n            offset = outputLeadingTriplet(newValue, buffer, offset);\n        }\n        offset = outputFullTriplet(thousands, buffer, offset);\n        offset = outputFullTriplet(ones, buffer, offset);\n        return offset;\n    }",
          "11": "    public static int outputInt(int value, char[] buffer, int offset)\n    {\n        if (value < 0) {\n            if (value == Integer.MIN_VALUE) {\n                /* Special case: no matching positive value within range;\n                 * let's then \"upgrade\" to long and output as such.\n                 */\n                return outputLong((long) value, buffer, offset);\n            }\n            buffer[offset++] = '-';\nreturn outputLong((long)value, buffer, offset);            value = +value;        }\n\n        if (value < MILLION) { // at most 2 triplets...\n            if (value < 1000) {\n                if (value < 10) {\n                    buffer[offset++] = (char) ('0' + value);\n                } else {\n                    offset = outputLeadingTriplet(value, buffer, offset);\n                }\n            } else {\n                int thousands = value / 1000;\n                value -= (thousands * 1000); // == value % 1000\n                offset = outputLeadingTriplet(thousands, buffer, offset);\n                offset = outputFullTriplet(value, buffer, offset);\n            }\n            return offset;\n        }\n\n        // ok, all 3 triplets included\n        /* Let's first hand possible billions separately before\n         * handling 3 triplets. This is possible since we know we\n         * can have at most '2' as billion count.\n         */\n        boolean hasBillions = (value >= BILLION);\n        if (hasBillions) {\n            value -= BILLION;\n            if (value >= BILLION) {\n                value -= BILLION;\n                buffer[offset++] = '2';\n            } else {\n                buffer[offset++] = '1';\n            }\n        }\n        int newValue = value / 1000;\n        int ones = (value - (newValue * 1000)); // == value % 1000\n        value = newValue;\n        newValue /= 1000;\n        int thousands = (value - (newValue * 1000));\n        \n        // value now has millions, which have 1, 2 or 3 digits\n        if (hasBillions) {\n            offset = outputFullTriplet(newValue, buffer, offset);\n        } else {\n            offset = outputLeadingTriplet(newValue, buffer, offset);\n        }\n        offset = outputFullTriplet(thousands, buffer, offset);\n        offset = outputFullTriplet(ones, buffer, offset);\n        return offset;\n    }",
          "12": "    public static int outputInt(int value, char[] buffer, int offset)\n    {\n        if (value < 0) {\n            if (value == Integer.MIN_VALUE) {\n                /* Special case: no matching positive value within range;\n                 * let's then \"upgrade\" to long and output as such.\n                 */\n                return outputLong((long) value, buffer, offset);\n            }\n            buffer[offset++] = '-';\noffset = outputFullTriplet(value, buffer, offset);\n        }\n\n        if (value < MILLION) { // at most 2 triplets...\n            if (value < 1000) {\n                if (value < 10) {\n                    buffer[offset++] = (char) ('0' + value);\n                } else {\n                    offset = outputLeadingTriplet(value, buffer, offset);\n                }\n            } else {\n                int thousands = value / 1000;\n                value -= (thousands * 1000); // == value % 1000\n                offset = outputLeadingTriplet(thousands, buffer, offset);\n                offset = outputFullTriplet(value, buffer, offset);\n            }\n            return offset;\n        }\n\n        // ok, all 3 triplets included\n        /* Let's first hand possible billions separately before\n         * handling 3 triplets. This is possible since we know we\n         * can have at most '2' as billion count.\n         */\n        boolean hasBillions = (value >= BILLION);\n        if (hasBillions) {\n            value -= BILLION;\n            if (value >= BILLION) {\n                value -= BILLION;\n                buffer[offset++] = '2';\n            } else {\n                buffer[offset++] = '1';\n            }\n        }\n        int newValue = value / 1000;\n        int ones = (value - (newValue * 1000)); // == value % 1000\n        value = newValue;\n        newValue /= 1000;\n        int thousands = (value - (newValue * 1000));\n        \n        // value now has millions, which have 1, 2 or 3 digits\n        if (hasBillions) {\n            offset = outputFullTriplet(newValue, buffer, offset);\n        } else {\n            offset = outputLeadingTriplet(newValue, buffer, offset);\n        }\n        offset = outputFullTriplet(thousands, buffer, offset);\n        offset = outputFullTriplet(ones, buffer, offset);\n        return offset;\n    }",
          "13": "    public static int outputInt(int value, char[] buffer, int offset)\n    {\n        if (value < 0) {\n            if (value == Integer.MIN_VALUE) {\n                /* Special case: no matching positive value within range;\n                 * let's then \"upgrade\" to long and output as such.\n                 */\n                return outputLong((long) value, buffer, offset);\n            }\n            buffer[offset++] = '-';\noffset = outputLeadingTriplet(thousands, buffer, offset);\n        }\n\n        if (value < MILLION) { // at most 2 triplets...\n            if (value < 1000) {\n                if (value < 10) {\n                    buffer[offset++] = (char) ('0' + value);\n                } else {\n                    offset = outputLeadingTriplet(value, buffer, offset);\n                }\n            } else {\n                int thousands = value / 1000;\n                value -= (thousands * 1000); // == value % 1000\n                offset = outputLeadingTriplet(thousands, buffer, offset);\n                offset = outputFullTriplet(value, buffer, offset);\n            }\n            return offset;\n        }\n\n        // ok, all 3 triplets included\n        /* Let's first hand possible billions separately before\n         * handling 3 triplets. This is possible since we know we\n         * can have at most '2' as billion count.\n         */\n        boolean hasBillions = (value >= BILLION);\n        if (hasBillions) {\n            value -= BILLION;\n            if (value >= BILLION) {\n                value -= BILLION;\n                buffer[offset++] = '2';\n            } else {\n                buffer[offset++] = '1';\n            }\n        }\n        int newValue = value / 1000;\n        int ones = (value - (newValue * 1000)); // == value % 1000\n        value = newValue;\n        newValue /= 1000;\n        int thousands = (value - (newValue * 1000));\n        \n        // value now has millions, which have 1, 2 or 3 digits\n        if (hasBillions) {\n            offset = outputFullTriplet(newValue, buffer, offset);\n        } else {\n            offset = outputLeadingTriplet(newValue, buffer, offset);\n        }\n        offset = outputFullTriplet(thousands, buffer, offset);\n        offset = outputFullTriplet(ones, buffer, offset);\n        return offset;\n    }",
          "14": "    public static int outputInt(int value, char[] buffer, int offset)\n    {\n        if (value < 0) {\n            if (value == Integer.MIN_VALUE) {\n                /* Special case: no matching positive value within range;\n                 * let's then \"upgrade\" to long and output as such.\n                 */\n                return outputLong((long) value, buffer, offset);\n            }\n            buffer[offset++] = '-';\nvalue -= BILLION;\n        }\n\n        if (value < MILLION) { // at most 2 triplets...\n            if (value < 1000) {\n                if (value < 10) {\n                    buffer[offset++] = (char) ('0' + value);\n                } else {\n                    offset = outputLeadingTriplet(value, buffer, offset);\n                }\n            } else {\n                int thousands = value / 1000;\n                value -= (thousands * 1000); // == value % 1000\n                offset = outputLeadingTriplet(thousands, buffer, offset);\n                offset = outputFullTriplet(value, buffer, offset);\n            }\n            return offset;\n        }\n\n        // ok, all 3 triplets included\n        /* Let's first hand possible billions separately before\n         * handling 3 triplets. This is possible since we know we\n         * can have at most '2' as billion count.\n         */\n        boolean hasBillions = (value >= BILLION);\n        if (hasBillions) {\n            value -= BILLION;\n            if (value >= BILLION) {\n                value -= BILLION;\n                buffer[offset++] = '2';\n            } else {\n                buffer[offset++] = '1';\n            }\n        }\n        int newValue = value / 1000;\n        int ones = (value - (newValue * 1000)); // == value % 1000\n        value = newValue;\n        newValue /= 1000;\n        int thousands = (value - (newValue * 1000));\n        \n        // value now has millions, which have 1, 2 or 3 digits\n        if (hasBillions) {\n            offset = outputFullTriplet(newValue, buffer, offset);\n        } else {\n            offset = outputLeadingTriplet(newValue, buffer, offset);\n        }\n        offset = outputFullTriplet(thousands, buffer, offset);\n        offset = outputFullTriplet(ones, buffer, offset);\n        return offset;\n    }",
          "15": "    public static int outputInt(int value, char[] buffer, int offset)\n    {\n        if (value < 0) {\n            if (value == Integer.MIN_VALUE) {\n                /* Special case: no matching positive value within range;\n                 * let's then \"upgrade\" to long and output as such.\n                 */\n                return outputLong((long) value, buffer, offset);\n            }\n            buffer[offset++] = '-';\nvalue -= (thousands * 1000);\n        }\n\n        if (value < MILLION) { // at most 2 triplets...\n            if (value < 1000) {\n                if (value < 10) {\n                    buffer[offset++] = (char) ('0' + value);\n                } else {\n                    offset = outputLeadingTriplet(value, buffer, offset);\n                }\n            } else {\n                int thousands = value / 1000;\n                value -= (thousands * 1000); // == value % 1000\n                offset = outputLeadingTriplet(thousands, buffer, offset);\n                offset = outputFullTriplet(value, buffer, offset);\n            }\n            return offset;\n        }\n\n        // ok, all 3 triplets included\n        /* Let's first hand possible billions separately before\n         * handling 3 triplets. This is possible since we know we\n         * can have at most '2' as billion count.\n         */\n        boolean hasBillions = (value >= BILLION);\n        if (hasBillions) {\n            value -= BILLION;\n            if (value >= BILLION) {\n                value -= BILLION;\n                buffer[offset++] = '2';\n            } else {\n                buffer[offset++] = '1';\n            }\n        }\n        int newValue = value / 1000;\n        int ones = (value - (newValue * 1000)); // == value % 1000\n        value = newValue;\n        newValue /= 1000;\n        int thousands = (value - (newValue * 1000));\n        \n        // value now has millions, which have 1, 2 or 3 digits\n        if (hasBillions) {\n            offset = outputFullTriplet(newValue, buffer, offset);\n        } else {\n            offset = outputLeadingTriplet(newValue, buffer, offset);\n        }\n        offset = outputFullTriplet(thousands, buffer, offset);\n        offset = outputFullTriplet(ones, buffer, offset);\n        return offset;\n    }",
          "16": "    public static int outputInt(int value, char[] buffer, int offset)\n    {\n        if (value < 0) {\n            if (value == Integer.MIN_VALUE) {\n                /* Special case: no matching positive value within range;\n                 * let's then \"upgrade\" to long and output as such.\n                 */\n                return outputLong((long) value, buffer, offset);\n            }\n            buffer[offset++] = '-';\nvalue = value;\n        }\n\n        if (value < MILLION) { // at most 2 triplets...\n            if (value < 1000) {\n                if (value < 10) {\n                    buffer[offset++] = (char) ('0' + value);\n                } else {\n                    offset = outputLeadingTriplet(value, buffer, offset);\n                }\n            } else {\n                int thousands = value / 1000;\n                value -= (thousands * 1000); // == value % 1000\n                offset = outputLeadingTriplet(thousands, buffer, offset);\n                offset = outputFullTriplet(value, buffer, offset);\n            }\n            return offset;\n        }\n\n        // ok, all 3 triplets included\n        /* Let's first hand possible billions separately before\n         * handling 3 triplets. This is possible since we know we\n         * can have at most '2' as billion count.\n         */\n        boolean hasBillions = (value >= BILLION);\n        if (hasBillions) {\n            value -= BILLION;\n            if (value >= BILLION) {\n                value -= BILLION;\n                buffer[offset++] = '2';\n            } else {\n                buffer[offset++] = '1';\n            }\n        }\n        int newValue = value / 1000;\n        int ones = (value - (newValue * 1000)); // == value % 1000\n        value = newValue;\n        newValue /= 1000;\n        int thousands = (value - (newValue * 1000));\n        \n        // value now has millions, which have 1, 2 or 3 digits\n        if (hasBillions) {\n            offset = outputFullTriplet(newValue, buffer, offset);\n        } else {\n            offset = outputLeadingTriplet(newValue, buffer, offset);\n        }\n        offset = outputFullTriplet(thousands, buffer, offset);\n        offset = outputFullTriplet(ones, buffer, offset);\n        return offset;\n    }",
          "17": "    public static int outputInt(int value, char[] buffer, int offset)\n    {\n        if (value < 0) {\n            if (value == Integer.MIN_VALUE) {\n                /* Special case: no matching positive value within range;\n                 * let's then \"upgrade\" to long and output as such.\n                 */\n                return outputLong((long) value, buffer, offset);\n            }\n            buffer[offset++] = '-';\nbuffer[offset++] = \"null\";\n        }\n\n        if (value < MILLION) { // at most 2 triplets...\n            if (value < 1000) {\n                if (value < 10) {\n                    buffer[offset++] = (char) ('0' + value);\n                } else {\n                    offset = outputLeadingTriplet(value, buffer, offset);\n                }\n            } else {\n                int thousands = value / 1000;\n                value -= (thousands * 1000); // == value % 1000\n                offset = outputLeadingTriplet(thousands, buffer, offset);\n                offset = outputFullTriplet(value, buffer, offset);\n            }\n            return offset;\n        }\n\n        // ok, all 3 triplets included\n        /* Let's first hand possible billions separately before\n         * handling 3 triplets. This is possible since we know we\n         * can have at most '2' as billion count.\n         */\n        boolean hasBillions = (value >= BILLION);\n        if (hasBillions) {\n            value -= BILLION;\n            if (value >= BILLION) {\n                value -= BILLION;\n                buffer[offset++] = '2';\n            } else {\n                buffer[offset++] = '1';\n            }\n        }\n        int newValue = value / 1000;\n        int ones = (value - (newValue * 1000)); // == value % 1000\n        value = newValue;\n        newValue /= 1000;\n        int thousands = (value - (newValue * 1000));\n        \n        // value now has millions, which have 1, 2 or 3 digits\n        if (hasBillions) {\n            offset = outputFullTriplet(newValue, buffer, offset);\n        } else {\n            offset = outputLeadingTriplet(newValue, buffer, offset);\n        }\n        offset = outputFullTriplet(thousands, buffer, offset);\n        offset = outputFullTriplet(ones, buffer, offset);\n        return offset;\n    }",
          "18": "    public static int outputInt(int value, char[] buffer, int offset)\n    {\n        if (value < 0) {\n            if (value == Integer.MIN_VALUE) {\n                /* Special case: no matching positive value within range;\n                 * let's then \"upgrade\" to long and output as such.\n                 */\n                return outputLong((long) value, buffer, offset);\n            }\n            buffer[offset++] = '-';\nif((newValue * 1000)){\n}\n            value = +value;        }\n\n        if (value < MILLION) { // at most 2 triplets...\n            if (value < 1000) {\n                if (value < 10) {\n                    buffer[offset++] = (char) ('0' + value);\n                } else {\n                    offset = outputLeadingTriplet(value, buffer, offset);\n                }\n            } else {\n                int thousands = value / 1000;\n                value -= (thousands * 1000); // == value % 1000\n                offset = outputLeadingTriplet(thousands, buffer, offset);\n                offset = outputFullTriplet(value, buffer, offset);\n            }\n            return offset;\n        }\n\n        // ok, all 3 triplets included\n        /* Let's first hand possible billions separately before\n         * handling 3 triplets. This is possible since we know we\n         * can have at most '2' as billion count.\n         */\n        boolean hasBillions = (value >= BILLION);\n        if (hasBillions) {\n            value -= BILLION;\n            if (value >= BILLION) {\n                value -= BILLION;\n                buffer[offset++] = '2';\n            } else {\n                buffer[offset++] = '1';\n            }\n        }\n        int newValue = value / 1000;\n        int ones = (value - (newValue * 1000)); // == value % 1000\n        value = newValue;\n        newValue /= 1000;\n        int thousands = (value - (newValue * 1000));\n        \n        // value now has millions, which have 1, 2 or 3 digits\n        if (hasBillions) {\n            offset = outputFullTriplet(newValue, buffer, offset);\n        } else {\n            offset = outputLeadingTriplet(newValue, buffer, offset);\n        }\n        offset = outputFullTriplet(thousands, buffer, offset);\n        offset = outputFullTriplet(ones, buffer, offset);\n        return offset;\n    }",
          "19": "    public static int outputInt(int value, char[] buffer, int offset)\n    {\n        if (value < 0) {\n            if (value == Integer.MIN_VALUE) {\n                /* Special case: no matching positive value within range;\n                 * let's then \"upgrade\" to long and output as such.\n                 */\n                return outputLong((long) value, buffer, offset);\n            }\n            buffer[offset++] = '-';\noffset = outputLeadingTriplet(value, buffer, offset);\n        }\n\n        if (value < MILLION) { // at most 2 triplets...\n            if (value < 1000) {\n                if (value < 10) {\n                    buffer[offset++] = (char) ('0' + value);\n                } else {\n                    offset = outputLeadingTriplet(value, buffer, offset);\n                }\n            } else {\n                int thousands = value / 1000;\n                value -= (thousands * 1000); // == value % 1000\n                offset = outputLeadingTriplet(thousands, buffer, offset);\n                offset = outputFullTriplet(value, buffer, offset);\n            }\n            return offset;\n        }\n\n        // ok, all 3 triplets included\n        /* Let's first hand possible billions separately before\n         * handling 3 triplets. This is possible since we know we\n         * can have at most '2' as billion count.\n         */\n        boolean hasBillions = (value >= BILLION);\n        if (hasBillions) {\n            value -= BILLION;\n            if (value >= BILLION) {\n                value -= BILLION;\n                buffer[offset++] = '2';\n            } else {\n                buffer[offset++] = '1';\n            }\n        }\n        int newValue = value / 1000;\n        int ones = (value - (newValue * 1000)); // == value % 1000\n        value = newValue;\n        newValue /= 1000;\n        int thousands = (value - (newValue * 1000));\n        \n        // value now has millions, which have 1, 2 or 3 digits\n        if (hasBillions) {\n            offset = outputFullTriplet(newValue, buffer, offset);\n        } else {\n            offset = outputLeadingTriplet(newValue, buffer, offset);\n        }\n        offset = outputFullTriplet(thousands, buffer, offset);\n        offset = outputFullTriplet(ones, buffer, offset);\n        return offset;\n    }",
          "20": "    public static int outputInt(int value, char[] buffer, int offset)\n    {\n        if (value < 0) {\n            if (value == Integer.MIN_VALUE) {\n                /* Special case: no matching positive value within range;\n                 * let's then \"upgrade\" to long and output as such.\n                 */\n                return outputLong((long) value, buffer, offset);\n            }\n            buffer[offset++] = '-';\nreturn;\n            value = +value;        }\n\n        if (value < MILLION) { // at most 2 triplets...\n            if (value < 1000) {\n                if (value < 10) {\n                    buffer[offset++] = (char) ('0' + value);\n                } else {\n                    offset = outputLeadingTriplet(value, buffer, offset);\n                }\n            } else {\n                int thousands = value / 1000;\n                value -= (thousands * 1000); // == value % 1000\n                offset = outputLeadingTriplet(thousands, buffer, offset);\n                offset = outputFullTriplet(value, buffer, offset);\n            }\n            return offset;\n        }\n\n        // ok, all 3 triplets included\n        /* Let's first hand possible billions separately before\n         * handling 3 triplets. This is possible since we know we\n         * can have at most '2' as billion count.\n         */\n        boolean hasBillions = (value >= BILLION);\n        if (hasBillions) {\n            value -= BILLION;\n            if (value >= BILLION) {\n                value -= BILLION;\n                buffer[offset++] = '2';\n            } else {\n                buffer[offset++] = '1';\n            }\n        }\n        int newValue = value / 1000;\n        int ones = (value - (newValue * 1000)); // == value % 1000\n        value = newValue;\n        newValue /= 1000;\n        int thousands = (value - (newValue * 1000));\n        \n        // value now has millions, which have 1, 2 or 3 digits\n        if (hasBillions) {\n            offset = outputFullTriplet(newValue, buffer, offset);\n        } else {\n            offset = outputLeadingTriplet(newValue, buffer, offset);\n        }\n        offset = outputFullTriplet(thousands, buffer, offset);\n        offset = outputFullTriplet(ones, buffer, offset);\n        return offset;\n    }",
          "21": "    public static int outputInt(int value, char[] buffer, int offset)\n    {\n        if (value < 0) {\n            if (value == Integer.MIN_VALUE) {\n                /* Special case: no matching positive value within range;\n                 * let's then \"upgrade\" to long and output as such.\n                 */\n                return outputLong((long) value, buffer, offset);\n            }\n            buffer[offset++] = '-';\nvalue = offset;\n        }\n\n        if (value < MILLION) { // at most 2 triplets...\n            if (value < 1000) {\n                if (value < 10) {\n                    buffer[offset++] = (char) ('0' + value);\n                } else {\n                    offset = outputLeadingTriplet(value, buffer, offset);\n                }\n            } else {\n                int thousands = value / 1000;\n                value -= (thousands * 1000); // == value % 1000\n                offset = outputLeadingTriplet(thousands, buffer, offset);\n                offset = outputFullTriplet(value, buffer, offset);\n            }\n            return offset;\n        }\n\n        // ok, all 3 triplets included\n        /* Let's first hand possible billions separately before\n         * handling 3 triplets. This is possible since we know we\n         * can have at most '2' as billion count.\n         */\n        boolean hasBillions = (value >= BILLION);\n        if (hasBillions) {\n            value -= BILLION;\n            if (value >= BILLION) {\n                value -= BILLION;\n                buffer[offset++] = '2';\n            } else {\n                buffer[offset++] = '1';\n            }\n        }\n        int newValue = value / 1000;\n        int ones = (value - (newValue * 1000)); // == value % 1000\n        value = newValue;\n        newValue /= 1000;\n        int thousands = (value - (newValue * 1000));\n        \n        // value now has millions, which have 1, 2 or 3 digits\n        if (hasBillions) {\n            offset = outputFullTriplet(newValue, buffer, offset);\n        } else {\n            offset = outputLeadingTriplet(newValue, buffer, offset);\n        }\n        offset = outputFullTriplet(thousands, buffer, offset);\n        offset = outputFullTriplet(ones, buffer, offset);\n        return offset;\n    }",
          "22": "    public static int outputInt(int value, char[] buffer, int offset)\n    {\n        if (value < 0) {\n            if (value == Integer.MIN_VALUE) {\n                /* Special case: no matching positive value within range;\n                 * let's then \"upgrade\" to long and output as such.\n                 */\n                return outputLong((long) value, buffer, offset);\n            }\n            buffer[offset++] = '-';\nbuffer[offset++] = (char)(\"null\" + value);\n        }\n\n        if (value < MILLION) { // at most 2 triplets...\n            if (value < 1000) {\n                if (value < 10) {\n                    buffer[offset++] = (char) ('0' + value);\n                } else {\n                    offset = outputLeadingTriplet(value, buffer, offset);\n                }\n            } else {\n                int thousands = value / 1000;\n                value -= (thousands * 1000); // == value % 1000\n                offset = outputLeadingTriplet(thousands, buffer, offset);\n                offset = outputFullTriplet(value, buffer, offset);\n            }\n            return offset;\n        }\n\n        // ok, all 3 triplets included\n        /* Let's first hand possible billions separately before\n         * handling 3 triplets. This is possible since we know we\n         * can have at most '2' as billion count.\n         */\n        boolean hasBillions = (value >= BILLION);\n        if (hasBillions) {\n            value -= BILLION;\n            if (value >= BILLION) {\n                value -= BILLION;\n                buffer[offset++] = '2';\n            } else {\n                buffer[offset++] = '1';\n            }\n        }\n        int newValue = value / 1000;\n        int ones = (value - (newValue * 1000)); // == value % 1000\n        value = newValue;\n        newValue /= 1000;\n        int thousands = (value - (newValue * 1000));\n        \n        // value now has millions, which have 1, 2 or 3 digits\n        if (hasBillions) {\n            offset = outputFullTriplet(newValue, buffer, offset);\n        } else {\n            offset = outputLeadingTriplet(newValue, buffer, offset);\n        }\n        offset = outputFullTriplet(thousands, buffer, offset);\n        offset = outputFullTriplet(ones, buffer, offset);\n        return offset;\n    }",
          "23": "    public static int outputInt(int value, char[] buffer, int offset)\n    {\n        if (value < 0) {\n            if (value == Integer.MIN_VALUE) {\n                /* Special case: no matching positive value within range;\n                 * let's then \"upgrade\" to long and output as such.\n                 */\n                return outputLong((long) value, buffer, offset);\n            }\n            buffer[offset++] = '-';\ncontinue;\n            value = +value;        }\n\n        if (value < MILLION) { // at most 2 triplets...\n            if (value < 1000) {\n                if (value < 10) {\n                    buffer[offset++] = (char) ('0' + value);\n                } else {\n                    offset = outputLeadingTriplet(value, buffer, offset);\n                }\n            } else {\n                int thousands = value / 1000;\n                value -= (thousands * 1000); // == value % 1000\n                offset = outputLeadingTriplet(thousands, buffer, offset);\n                offset = outputFullTriplet(value, buffer, offset);\n            }\n            return offset;\n        }\n\n        // ok, all 3 triplets included\n        /* Let's first hand possible billions separately before\n         * handling 3 triplets. This is possible since we know we\n         * can have at most '2' as billion count.\n         */\n        boolean hasBillions = (value >= BILLION);\n        if (hasBillions) {\n            value -= BILLION;\n            if (value >= BILLION) {\n                value -= BILLION;\n                buffer[offset++] = '2';\n            } else {\n                buffer[offset++] = '1';\n            }\n        }\n        int newValue = value / 1000;\n        int ones = (value - (newValue * 1000)); // == value % 1000\n        value = newValue;\n        newValue /= 1000;\n        int thousands = (value - (newValue * 1000));\n        \n        // value now has millions, which have 1, 2 or 3 digits\n        if (hasBillions) {\n            offset = outputFullTriplet(newValue, buffer, offset);\n        } else {\n            offset = outputLeadingTriplet(newValue, buffer, offset);\n        }\n        offset = outputFullTriplet(thousands, buffer, offset);\n        offset = outputFullTriplet(ones, buffer, offset);\n        return offset;\n    }",
          "24": "    public static int outputInt(int value, char[] buffer, int offset)\n    {\n        if (value < 0) {\n            if (value == Integer.MIN_VALUE) {\n                /* Special case: no matching positive value within range;\n                 * let's then \"upgrade\" to long and output as such.\n                 */\n                return outputLong((long) value, buffer, offset);\n            }\n            buffer[offset++] = '-';\nreturn;\n        }\n\n        if (value < MILLION) { // at most 2 triplets...\n            if (value < 1000) {\n                if (value < 10) {\n                    buffer[offset++] = (char) ('0' + value);\n                } else {\n                    offset = outputLeadingTriplet(value, buffer, offset);\n                }\n            } else {\n                int thousands = value / 1000;\n                value -= (thousands * 1000); // == value % 1000\n                offset = outputLeadingTriplet(thousands, buffer, offset);\n                offset = outputFullTriplet(value, buffer, offset);\n            }\n            return offset;\n        }\n\n        // ok, all 3 triplets included\n        /* Let's first hand possible billions separately before\n         * handling 3 triplets. This is possible since we know we\n         * can have at most '2' as billion count.\n         */\n        boolean hasBillions = (value >= BILLION);\n        if (hasBillions) {\n            value -= BILLION;\n            if (value >= BILLION) {\n                value -= BILLION;\n                buffer[offset++] = '2';\n            } else {\n                buffer[offset++] = '1';\n            }\n        }\n        int newValue = value / 1000;\n        int ones = (value - (newValue * 1000)); // == value % 1000\n        value = newValue;\n        newValue /= 1000;\n        int thousands = (value - (newValue * 1000));\n        \n        // value now has millions, which have 1, 2 or 3 digits\n        if (hasBillions) {\n            offset = outputFullTriplet(newValue, buffer, offset);\n        } else {\n            offset = outputLeadingTriplet(newValue, buffer, offset);\n        }\n        offset = outputFullTriplet(thousands, buffer, offset);\n        offset = outputFullTriplet(ones, buffer, offset);\n        return offset;\n    }",
          "25": "    public static int outputInt(int value, char[] buffer, int offset)\n    {\n        if (value < 0) {\n            if (value == Integer.MIN_VALUE) {\n                /* Special case: no matching positive value within range;\n                 * let's then \"upgrade\" to long and output as such.\n                 */\n                return outputLong((long) value, buffer, offset);\n            }\n            buffer[offset++] = '-';\nif((value >= BILLION)){\n}\n            value = +value;        }\n\n        if (value < MILLION) { // at most 2 triplets...\n            if (value < 1000) {\n                if (value < 10) {\n                    buffer[offset++] = (char) ('0' + value);\n                } else {\n                    offset = outputLeadingTriplet(value, buffer, offset);\n                }\n            } else {\n                int thousands = value / 1000;\n                value -= (thousands * 1000); // == value % 1000\n                offset = outputLeadingTriplet(thousands, buffer, offset);\n                offset = outputFullTriplet(value, buffer, offset);\n            }\n            return offset;\n        }\n\n        // ok, all 3 triplets included\n        /* Let's first hand possible billions separately before\n         * handling 3 triplets. This is possible since we know we\n         * can have at most '2' as billion count.\n         */\n        boolean hasBillions = (value >= BILLION);\n        if (hasBillions) {\n            value -= BILLION;\n            if (value >= BILLION) {\n                value -= BILLION;\n                buffer[offset++] = '2';\n            } else {\n                buffer[offset++] = '1';\n            }\n        }\n        int newValue = value / 1000;\n        int ones = (value - (newValue * 1000)); // == value % 1000\n        value = newValue;\n        newValue /= 1000;\n        int thousands = (value - (newValue * 1000));\n        \n        // value now has millions, which have 1, 2 or 3 digits\n        if (hasBillions) {\n            offset = outputFullTriplet(newValue, buffer, offset);\n        } else {\n            offset = outputLeadingTriplet(newValue, buffer, offset);\n        }\n        offset = outputFullTriplet(thousands, buffer, offset);\n        offset = outputFullTriplet(ones, buffer, offset);\n        return offset;\n    }",
          "26": "    public static int outputInt(int value, char[] buffer, int offset)\n    {\n        if (value < 0) {\n            if (value == Integer.MIN_VALUE) {\n                /* Special case: no matching positive value within range;\n                 * let's then \"upgrade\" to long and output as such.\n                 */\n                return outputLong((long) value, buffer, offset);\n            }\n            buffer[offset++] = '-';\nvalue = +value;\n        }\n\n        if (value < MILLION) { // at most 2 triplets...\n            if (value < 1000) {\n                if (value < 10) {\n                    buffer[offset++] = (char) ('0' + value);\n                } else {\n                    offset = outputLeadingTriplet(value, buffer, offset);\n                }\n            } else {\n                int thousands = value / 1000;\n                value -= (thousands * 1000); // == value % 1000\n                offset = outputLeadingTriplet(thousands, buffer, offset);\n                offset = outputFullTriplet(value, buffer, offset);\n            }\n            return offset;\n        }\n\n        // ok, all 3 triplets included\n        /* Let's first hand possible billions separately before\n         * handling 3 triplets. This is possible since we know we\n         * can have at most '2' as billion count.\n         */\n        boolean hasBillions = (value >= BILLION);\n        if (hasBillions) {\n            value -= BILLION;\n            if (value >= BILLION) {\n                value -= BILLION;\n                buffer[offset++] = '2';\n            } else {\n                buffer[offset++] = '1';\n            }\n        }\n        int newValue = value / 1000;\n        int ones = (value - (newValue * 1000)); // == value % 1000\n        value = newValue;\n        newValue /= 1000;\n        int thousands = (value - (newValue * 1000));\n        \n        // value now has millions, which have 1, 2 or 3 digits\n        if (hasBillions) {\n            offset = outputFullTriplet(newValue, buffer, offset);\n        } else {\n            offset = outputLeadingTriplet(newValue, buffer, offset);\n        }\n        offset = outputFullTriplet(thousands, buffer, offset);\n        offset = outputFullTriplet(ones, buffer, offset);\n        return offset;\n    }",
          "27": "    public static int outputInt(int value, char[] buffer, int offset)\n    {\n        if (value < 0) {\n            if (value == Integer.MIN_VALUE) {\n                /* Special case: no matching positive value within range;\n                 * let's then \"upgrade\" to long and output as such.\n                 */\n                return outputLong((long) value, buffer, offset);\n            }\n            buffer[offset++] = '-';\nif((value < MILLION)){\n}\n            value = +value;        }\n\n        if (value < MILLION) { // at most 2 triplets...\n            if (value < 1000) {\n                if (value < 10) {\n                    buffer[offset++] = (char) ('0' + value);\n                } else {\n                    offset = outputLeadingTriplet(value, buffer, offset);\n                }\n            } else {\n                int thousands = value / 1000;\n                value -= (thousands * 1000); // == value % 1000\n                offset = outputLeadingTriplet(thousands, buffer, offset);\n                offset = outputFullTriplet(value, buffer, offset);\n            }\n            return offset;\n        }\n\n        // ok, all 3 triplets included\n        /* Let's first hand possible billions separately before\n         * handling 3 triplets. This is possible since we know we\n         * can have at most '2' as billion count.\n         */\n        boolean hasBillions = (value >= BILLION);\n        if (hasBillions) {\n            value -= BILLION;\n            if (value >= BILLION) {\n                value -= BILLION;\n                buffer[offset++] = '2';\n            } else {\n                buffer[offset++] = '1';\n            }\n        }\n        int newValue = value / 1000;\n        int ones = (value - (newValue * 1000)); // == value % 1000\n        value = newValue;\n        newValue /= 1000;\n        int thousands = (value - (newValue * 1000));\n        \n        // value now has millions, which have 1, 2 or 3 digits\n        if (hasBillions) {\n            offset = outputFullTriplet(newValue, buffer, offset);\n        } else {\n            offset = outputLeadingTriplet(newValue, buffer, offset);\n        }\n        offset = outputFullTriplet(thousands, buffer, offset);\n        offset = outputFullTriplet(ones, buffer, offset);\n        return offset;\n    }",
          "28": "    public static int outputInt(int value, char[] buffer, int offset)\n    {\n        if (value < 0) {\n            if (value == Integer.MIN_VALUE) {\n                /* Special case: no matching positive value within range;\n                 * let's then \"upgrade\" to long and output as such.\n                 */\n                return outputLong((long) value, buffer, offset);\n            }\n            buffer[offset++] = '-';\noffset = +value;\n        }\n\n        if (value < MILLION) { // at most 2 triplets...\n            if (value < 1000) {\n                if (value < 10) {\n                    buffer[offset++] = (char) ('0' + value);\n                } else {\n                    offset = outputLeadingTriplet(value, buffer, offset);\n                }\n            } else {\n                int thousands = value / 1000;\n                value -= (thousands * 1000); // == value % 1000\n                offset = outputLeadingTriplet(thousands, buffer, offset);\n                offset = outputFullTriplet(value, buffer, offset);\n            }\n            return offset;\n        }\n\n        // ok, all 3 triplets included\n        /* Let's first hand possible billions separately before\n         * handling 3 triplets. This is possible since we know we\n         * can have at most '2' as billion count.\n         */\n        boolean hasBillions = (value >= BILLION);\n        if (hasBillions) {\n            value -= BILLION;\n            if (value >= BILLION) {\n                value -= BILLION;\n                buffer[offset++] = '2';\n            } else {\n                buffer[offset++] = '1';\n            }\n        }\n        int newValue = value / 1000;\n        int ones = (value - (newValue * 1000)); // == value % 1000\n        value = newValue;\n        newValue /= 1000;\n        int thousands = (value - (newValue * 1000));\n        \n        // value now has millions, which have 1, 2 or 3 digits\n        if (hasBillions) {\n            offset = outputFullTriplet(newValue, buffer, offset);\n        } else {\n            offset = outputLeadingTriplet(newValue, buffer, offset);\n        }\n        offset = outputFullTriplet(thousands, buffer, offset);\n        offset = outputFullTriplet(ones, buffer, offset);\n        return offset;\n    }",
          "29": "    public static int outputInt(int value, char[] buffer, int offset)\n    {\n        if (value < 0) {\n            if (value == Integer.MIN_VALUE) {\n                /* Special case: no matching positive value within range;\n                 * let's then \"upgrade\" to long and output as such.\n                 */\n                return outputLong((long) value, buffer, offset);\n            }\n            buffer[offset++] = '-';\nif((value < 10)){\n}\n            value = +value;        }\n\n        if (value < MILLION) { // at most 2 triplets...\n            if (value < 1000) {\n                if (value < 10) {\n                    buffer[offset++] = (char) ('0' + value);\n                } else {\n                    offset = outputLeadingTriplet(value, buffer, offset);\n                }\n            } else {\n                int thousands = value / 1000;\n                value -= (thousands * 1000); // == value % 1000\n                offset = outputLeadingTriplet(thousands, buffer, offset);\n                offset = outputFullTriplet(value, buffer, offset);\n            }\n            return offset;\n        }\n\n        // ok, all 3 triplets included\n        /* Let's first hand possible billions separately before\n         * handling 3 triplets. This is possible since we know we\n         * can have at most '2' as billion count.\n         */\n        boolean hasBillions = (value >= BILLION);\n        if (hasBillions) {\n            value -= BILLION;\n            if (value >= BILLION) {\n                value -= BILLION;\n                buffer[offset++] = '2';\n            } else {\n                buffer[offset++] = '1';\n            }\n        }\n        int newValue = value / 1000;\n        int ones = (value - (newValue * 1000)); // == value % 1000\n        value = newValue;\n        newValue /= 1000;\n        int thousands = (value - (newValue * 1000));\n        \n        // value now has millions, which have 1, 2 or 3 digits\n        if (hasBillions) {\n            offset = outputFullTriplet(newValue, buffer, offset);\n        } else {\n            offset = outputLeadingTriplet(newValue, buffer, offset);\n        }\n        offset = outputFullTriplet(thousands, buffer, offset);\n        offset = outputFullTriplet(ones, buffer, offset);\n        return offset;\n    }",
          "30": "    public static int outputInt(int value, char[] buffer, int offset)\n    {\n        if (value < 0) {\n            if (value == Integer.MIN_VALUE) {\n                /* Special case: no matching positive value within range;\n                 * let's then \"upgrade\" to long and output as such.\n                 */\n                return outputLong((long) value, buffer, offset);\n            }\n            buffer[offset++] = '-';\nbuffer = +value;\n        }\n\n        if (value < MILLION) { // at most 2 triplets...\n            if (value < 1000) {\n                if (value < 10) {\n                    buffer[offset++] = (char) ('0' + value);\n                } else {\n                    offset = outputLeadingTriplet(value, buffer, offset);\n                }\n            } else {\n                int thousands = value / 1000;\n                value -= (thousands * 1000); // == value % 1000\n                offset = outputLeadingTriplet(thousands, buffer, offset);\n                offset = outputFullTriplet(value, buffer, offset);\n            }\n            return offset;\n        }\n\n        // ok, all 3 triplets included\n        /* Let's first hand possible billions separately before\n         * handling 3 triplets. This is possible since we know we\n         * can have at most '2' as billion count.\n         */\n        boolean hasBillions = (value >= BILLION);\n        if (hasBillions) {\n            value -= BILLION;\n            if (value >= BILLION) {\n                value -= BILLION;\n                buffer[offset++] = '2';\n            } else {\n                buffer[offset++] = '1';\n            }\n        }\n        int newValue = value / 1000;\n        int ones = (value - (newValue * 1000)); // == value % 1000\n        value = newValue;\n        newValue /= 1000;\n        int thousands = (value - (newValue * 1000));\n        \n        // value now has millions, which have 1, 2 or 3 digits\n        if (hasBillions) {\n            offset = outputFullTriplet(newValue, buffer, offset);\n        } else {\n            offset = outputLeadingTriplet(newValue, buffer, offset);\n        }\n        offset = outputFullTriplet(thousands, buffer, offset);\n        offset = outputFullTriplet(ones, buffer, offset);\n        return offset;\n    }",
          "31": "    public static int outputInt(int value, char[] buffer, int offset)\n    {\n        if (value < 0) {\n            if (value == Integer.MIN_VALUE) {\n                /* Special case: no matching positive value within range;\n                 * let's then \"upgrade\" to long and output as such.\n                 */\n                return outputLong((long) value, buffer, offset);\n            }\n            buffer[offset++] = '-';\nif((value < 0)){\n}\n            value = +value;        }\n\n        if (value < MILLION) { // at most 2 triplets...\n            if (value < 1000) {\n                if (value < 10) {\n                    buffer[offset++] = (char) ('0' + value);\n                } else {\n                    offset = outputLeadingTriplet(value, buffer, offset);\n                }\n            } else {\n                int thousands = value / 1000;\n                value -= (thousands * 1000); // == value % 1000\n                offset = outputLeadingTriplet(thousands, buffer, offset);\n                offset = outputFullTriplet(value, buffer, offset);\n            }\n            return offset;\n        }\n\n        // ok, all 3 triplets included\n        /* Let's first hand possible billions separately before\n         * handling 3 triplets. This is possible since we know we\n         * can have at most '2' as billion count.\n         */\n        boolean hasBillions = (value >= BILLION);\n        if (hasBillions) {\n            value -= BILLION;\n            if (value >= BILLION) {\n                value -= BILLION;\n                buffer[offset++] = '2';\n            } else {\n                buffer[offset++] = '1';\n            }\n        }\n        int newValue = value / 1000;\n        int ones = (value - (newValue * 1000)); // == value % 1000\n        value = newValue;\n        newValue /= 1000;\n        int thousands = (value - (newValue * 1000));\n        \n        // value now has millions, which have 1, 2 or 3 digits\n        if (hasBillions) {\n            offset = outputFullTriplet(newValue, buffer, offset);\n        } else {\n            offset = outputLeadingTriplet(newValue, buffer, offset);\n        }\n        offset = outputFullTriplet(thousands, buffer, offset);\n        offset = outputFullTriplet(ones, buffer, offset);\n        return offset;\n    }",
          "32": "    public static int outputInt(int value, char[] buffer, int offset)\n    {\n        if (value < 0) {\n            if (value == Integer.MIN_VALUE) {\n                /* Special case: no matching positive value within range;\n                 * let's then \"upgrade\" to long and output as such.\n                 */\n                return outputLong((long) value, buffer, offset);\n            }\n            buffer[offset++] = '-';\nif((value < 1000)){\n}\n            value = +value;        }\n\n        if (value < MILLION) { // at most 2 triplets...\n            if (value < 1000) {\n                if (value < 10) {\n                    buffer[offset++] = (char) ('0' + value);\n                } else {\n                    offset = outputLeadingTriplet(value, buffer, offset);\n                }\n            } else {\n                int thousands = value / 1000;\n                value -= (thousands * 1000); // == value % 1000\n                offset = outputLeadingTriplet(thousands, buffer, offset);\n                offset = outputFullTriplet(value, buffer, offset);\n            }\n            return offset;\n        }\n\n        // ok, all 3 triplets included\n        /* Let's first hand possible billions separately before\n         * handling 3 triplets. This is possible since we know we\n         * can have at most '2' as billion count.\n         */\n        boolean hasBillions = (value >= BILLION);\n        if (hasBillions) {\n            value -= BILLION;\n            if (value >= BILLION) {\n                value -= BILLION;\n                buffer[offset++] = '2';\n            } else {\n                buffer[offset++] = '1';\n            }\n        }\n        int newValue = value / 1000;\n        int ones = (value - (newValue * 1000)); // == value % 1000\n        value = newValue;\n        newValue /= 1000;\n        int thousands = (value - (newValue * 1000));\n        \n        // value now has millions, which have 1, 2 or 3 digits\n        if (hasBillions) {\n            offset = outputFullTriplet(newValue, buffer, offset);\n        } else {\n            offset = outputLeadingTriplet(newValue, buffer, offset);\n        }\n        offset = outputFullTriplet(thousands, buffer, offset);\n        offset = outputFullTriplet(ones, buffer, offset);\n        return offset;\n    }",
          "33": "    public static int outputInt(int value, char[] buffer, int offset)\n    {\n        if (value < 0) {\n            if (value == Integer.MIN_VALUE) {\n                /* Special case: no matching positive value within range;\n                 * let's then \"upgrade\" to long and output as such.\n                 */\n                return outputLong((long) value, buffer, offset);\n            }\n            buffer[offset++] = '-';\nif((value == Integer.MIN_VALUE)){\n}\n            value = +value;        }\n\n        if (value < MILLION) { // at most 2 triplets...\n            if (value < 1000) {\n                if (value < 10) {\n                    buffer[offset++] = (char) ('0' + value);\n                } else {\n                    offset = outputLeadingTriplet(value, buffer, offset);\n                }\n            } else {\n                int thousands = value / 1000;\n                value -= (thousands * 1000); // == value % 1000\n                offset = outputLeadingTriplet(thousands, buffer, offset);\n                offset = outputFullTriplet(value, buffer, offset);\n            }\n            return offset;\n        }\n\n        // ok, all 3 triplets included\n        /* Let's first hand possible billions separately before\n         * handling 3 triplets. This is possible since we know we\n         * can have at most '2' as billion count.\n         */\n        boolean hasBillions = (value >= BILLION);\n        if (hasBillions) {\n            value -= BILLION;\n            if (value >= BILLION) {\n                value -= BILLION;\n                buffer[offset++] = '2';\n            } else {\n                buffer[offset++] = '1';\n            }\n        }\n        int newValue = value / 1000;\n        int ones = (value - (newValue * 1000)); // == value % 1000\n        value = newValue;\n        newValue /= 1000;\n        int thousands = (value - (newValue * 1000));\n        \n        // value now has millions, which have 1, 2 or 3 digits\n        if (hasBillions) {\n            offset = outputFullTriplet(newValue, buffer, offset);\n        } else {\n            offset = outputLeadingTriplet(newValue, buffer, offset);\n        }\n        offset = outputFullTriplet(thousands, buffer, offset);\n        offset = outputFullTriplet(ones, buffer, offset);\n        return offset;\n    }",
          "34": "    public static int outputInt(int value, char[] buffer, int offset)\n    {\n        if (value < 0) {\n            if (value == Integer.MIN_VALUE) {\n                /* Special case: no matching positive value within range;\n                 * let's then \"upgrade\" to long and output as such.\n                 */\n                return outputLong((long) value, buffer, offset);\n            }\n            buffer[offset++] = '-';\nnewValue = value;\n        }\n\n        if (value < MILLION) { // at most 2 triplets...\n            if (value < 1000) {\n                if (value < 10) {\n                    buffer[offset++] = (char) ('0' + value);\n                } else {\n                    offset = outputLeadingTriplet(value, buffer, offset);\n                }\n            } else {\n                int thousands = value / 1000;\n                value -= (thousands * 1000); // == value % 1000\n                offset = outputLeadingTriplet(thousands, buffer, offset);\n                offset = outputFullTriplet(value, buffer, offset);\n            }\n            return offset;\n        }\n\n        // ok, all 3 triplets included\n        /* Let's first hand possible billions separately before\n         * handling 3 triplets. This is possible since we know we\n         * can have at most '2' as billion count.\n         */\n        boolean hasBillions = (value >= BILLION);\n        if (hasBillions) {\n            value -= BILLION;\n            if (value >= BILLION) {\n                value -= BILLION;\n                buffer[offset++] = '2';\n            } else {\n                buffer[offset++] = '1';\n            }\n        }\n        int newValue = value / 1000;\n        int ones = (value - (newValue * 1000)); // == value % 1000\n        value = newValue;\n        newValue /= 1000;\n        int thousands = (value - (newValue * 1000));\n        \n        // value now has millions, which have 1, 2 or 3 digits\n        if (hasBillions) {\n            offset = outputFullTriplet(newValue, buffer, offset);\n        } else {\n            offset = outputLeadingTriplet(newValue, buffer, offset);\n        }\n        offset = outputFullTriplet(thousands, buffer, offset);\n        offset = outputFullTriplet(ones, buffer, offset);\n        return offset;\n    }",
          "35": "    public static int outputInt(int value, char[] buffer, int offset)\n    {\n        if (value < 0) {\n            if (value == Integer.MIN_VALUE) {\n                /* Special case: no matching positive value within range;\n                 * let's then \"upgrade\" to long and output as such.\n                 */\n                return outputLong((long) value, buffer, offset);\n            }\n            buffer[offset++] = '-';\n            value = +value;        }\n\n        if (value < MILLION) { // at most 2 triplets...\n            if (value < 1000) {\n                if (value < 10) {\n                    buffer[offset++] = (char) ('0' + value);\n                } else {\n                    offset = outputLeadingTriplet(value, buffer, offset);\n                }\n            } else {\n                int thousands = value / 1000;\n                value -= (thousands * 1000); // == value % 1000\n                offset = outputLeadingTriplet(thousands, buffer, offset);\n                offset = outputFullTriplet(value, buffer, offset);\n            }\n            return offset;\n        }\n\n        // ok, all 3 triplets included\n        /* Let's first hand possible billions separately before\n         * handling 3 triplets. This is possible since we know we\n         * can have at most '2' as billion count.\n         */\n        boolean hasBillions = (value >= BILLION);\n        if (hasBillions) {\n            value -= BILLION;\n            if (value >= BILLION) {\n                value -= BILLION;\n                buffer[offset++] = '2';\n            } else {\n                buffer[offset++] = '1';\n            }\n        }\n        int newValue = value / 1000;\n        int ones = (value - (newValue * 1000)); // == value % 1000\n        value = newValue;\n        newValue /= 1000;\n        int thousands = (value - (newValue * 1000));\n        \n        // value now has millions, which have 1, 2 or 3 digits\n        if (hasBillions) {\n            offset = outputFullTriplet(newValue, buffer, offset);\n        } else {\n            offset = outputLeadingTriplet(newValue, buffer, offset);\n        }\n        offset = outputFullTriplet(thousands, buffer, offset);\n        offset = outputFullTriplet(ones, buffer, offset);\n        return offset;\n    }",
          "36": "    public static int outputInt(int value, char[] buffer, int offset)\n    {\n        if (value < 0) {\n            if (value == Integer.MIN_VALUE) {\n                /* Special case: no matching positive value within range;\n                 * let's then \"upgrade\" to long and output as such.\n                 */\n                return outputLong((long) value, buffer, offset);\n            }\n            buffer[offset++] = '-';\nbreak;\n        }\n\n        if (value < MILLION) { // at most 2 triplets...\n            if (value < 1000) {\n                if (value < 10) {\n                    buffer[offset++] = (char) ('0' + value);\n                } else {\n                    offset = outputLeadingTriplet(value, buffer, offset);\n                }\n            } else {\n                int thousands = value / 1000;\n                value -= (thousands * 1000); // == value % 1000\n                offset = outputLeadingTriplet(thousands, buffer, offset);\n                offset = outputFullTriplet(value, buffer, offset);\n            }\n            return offset;\n        }\n\n        // ok, all 3 triplets included\n        /* Let's first hand possible billions separately before\n         * handling 3 triplets. This is possible since we know we\n         * can have at most '2' as billion count.\n         */\n        boolean hasBillions = (value >= BILLION);\n        if (hasBillions) {\n            value -= BILLION;\n            if (value >= BILLION) {\n                value -= BILLION;\n                buffer[offset++] = '2';\n            } else {\n                buffer[offset++] = '1';\n            }\n        }\n        int newValue = value / 1000;\n        int ones = (value - (newValue * 1000)); // == value % 1000\n        value = newValue;\n        newValue /= 1000;\n        int thousands = (value - (newValue * 1000));\n        \n        // value now has millions, which have 1, 2 or 3 digits\n        if (hasBillions) {\n            offset = outputFullTriplet(newValue, buffer, offset);\n        } else {\n            offset = outputLeadingTriplet(newValue, buffer, offset);\n        }\n        offset = outputFullTriplet(thousands, buffer, offset);\n        offset = outputFullTriplet(ones, buffer, offset);\n        return offset;\n    }",
          "37": "    public static int outputInt(int value, char[] buffer, int offset)\n    {\n        if (value < 0) {\n            if (value == Integer.MIN_VALUE) {\n                /* Special case: no matching positive value within range;\n                 * let's then \"upgrade\" to long and output as such.\n                 */\n                return outputLong((long) value, buffer, offset);\n            }\n            buffer[offset++] = '-';\ncontinue;\n        }\n\n        if (value < MILLION) { // at most 2 triplets...\n            if (value < 1000) {\n                if (value < 10) {\n                    buffer[offset++] = (char) ('0' + value);\n                } else {\n                    offset = outputLeadingTriplet(value, buffer, offset);\n                }\n            } else {\n                int thousands = value / 1000;\n                value -= (thousands * 1000); // == value % 1000\n                offset = outputLeadingTriplet(thousands, buffer, offset);\n                offset = outputFullTriplet(value, buffer, offset);\n            }\n            return offset;\n        }\n\n        // ok, all 3 triplets included\n        /* Let's first hand possible billions separately before\n         * handling 3 triplets. This is possible since we know we\n         * can have at most '2' as billion count.\n         */\n        boolean hasBillions = (value >= BILLION);\n        if (hasBillions) {\n            value -= BILLION;\n            if (value >= BILLION) {\n                value -= BILLION;\n                buffer[offset++] = '2';\n            } else {\n                buffer[offset++] = '1';\n            }\n        }\n        int newValue = value / 1000;\n        int ones = (value - (newValue * 1000)); // == value % 1000\n        value = newValue;\n        newValue /= 1000;\n        int thousands = (value - (newValue * 1000));\n        \n        // value now has millions, which have 1, 2 or 3 digits\n        if (hasBillions) {\n            offset = outputFullTriplet(newValue, buffer, offset);\n        } else {\n            offset = outputLeadingTriplet(newValue, buffer, offset);\n        }\n        offset = outputFullTriplet(thousands, buffer, offset);\n        offset = outputFullTriplet(ones, buffer, offset);\n        return offset;\n    }",
          "38": "    public static int outputInt(int value, char[] buffer, int offset)\n    {\n        if (value < 0) {\n            if (value == Integer.MIN_VALUE) {\n                /* Special case: no matching positive value within range;\n                 * let's then \"upgrade\" to long and output as such.\n                 */\n                return outputLong((long) value, buffer, offset);\n            }\n            buffer[offset++] = '-';\nbuffer[offset++] = value;\n        }\n\n        if (value < MILLION) { // at most 2 triplets...\n            if (value < 1000) {\n                if (value < 10) {\n                    buffer[offset++] = (char) ('0' + value);\n                } else {\n                    offset = outputLeadingTriplet(value, buffer, offset);\n                }\n            } else {\n                int thousands = value / 1000;\n                value -= (thousands * 1000); // == value % 1000\n                offset = outputLeadingTriplet(thousands, buffer, offset);\n                offset = outputFullTriplet(value, buffer, offset);\n            }\n            return offset;\n        }\n\n        // ok, all 3 triplets included\n        /* Let's first hand possible billions separately before\n         * handling 3 triplets. This is possible since we know we\n         * can have at most '2' as billion count.\n         */\n        boolean hasBillions = (value >= BILLION);\n        if (hasBillions) {\n            value -= BILLION;\n            if (value >= BILLION) {\n                value -= BILLION;\n                buffer[offset++] = '2';\n            } else {\n                buffer[offset++] = '1';\n            }\n        }\n        int newValue = value / 1000;\n        int ones = (value - (newValue * 1000)); // == value % 1000\n        value = newValue;\n        newValue /= 1000;\n        int thousands = (value - (newValue * 1000));\n        \n        // value now has millions, which have 1, 2 or 3 digits\n        if (hasBillions) {\n            offset = outputFullTriplet(newValue, buffer, offset);\n        } else {\n            offset = outputLeadingTriplet(newValue, buffer, offset);\n        }\n        offset = outputFullTriplet(thousands, buffer, offset);\n        offset = outputFullTriplet(ones, buffer, offset);\n        return offset;\n    }",
          "39": "    public static int outputInt(int value, char[] buffer, int offset)\n    {\n        if (value < 0) {\n            if (value == Integer.MIN_VALUE) {\n                /* Special case: no matching positive value within range;\n                 * let's then \"upgrade\" to long and output as such.\n                 */\n                return outputLong((long) value, buffer, offset);\n            }\n            buffer[offset++] = '-';\nnewValue = buffer;\n        }\n\n        if (value < MILLION) { // at most 2 triplets...\n            if (value < 1000) {\n                if (value < 10) {\n                    buffer[offset++] = (char) ('0' + value);\n                } else {\n                    offset = outputLeadingTriplet(value, buffer, offset);\n                }\n            } else {\n                int thousands = value / 1000;\n                value -= (thousands * 1000); // == value % 1000\n                offset = outputLeadingTriplet(thousands, buffer, offset);\n                offset = outputFullTriplet(value, buffer, offset);\n            }\n            return offset;\n        }\n\n        // ok, all 3 triplets included\n        /* Let's first hand possible billions separately before\n         * handling 3 triplets. This is possible since we know we\n         * can have at most '2' as billion count.\n         */\n        boolean hasBillions = (value >= BILLION);\n        if (hasBillions) {\n            value -= BILLION;\n            if (value >= BILLION) {\n                value -= BILLION;\n                buffer[offset++] = '2';\n            } else {\n                buffer[offset++] = '1';\n            }\n        }\n        int newValue = value / 1000;\n        int ones = (value - (newValue * 1000)); // == value % 1000\n        value = newValue;\n        newValue /= 1000;\n        int thousands = (value - (newValue * 1000));\n        \n        // value now has millions, which have 1, 2 or 3 digits\n        if (hasBillions) {\n            offset = outputFullTriplet(newValue, buffer, offset);\n        } else {\n            offset = outputLeadingTriplet(newValue, buffer, offset);\n        }\n        offset = outputFullTriplet(thousands, buffer, offset);\n        offset = outputFullTriplet(ones, buffer, offset);\n        return offset;\n    }",
          "40": "    public static int outputInt(int value, char[] buffer, int offset)\n    {\n        if (value < 0) {\n            if (value == Integer.MIN_VALUE) {\n                /* Special case: no matching positive value within range;\n                 * let's then \"upgrade\" to long and output as such.\n                 */\n                return outputLong((long) value, buffer, offset);\n            }\n            buffer[offset++] = '-';\nnewValue += value;\n        }\n\n        if (value < MILLION) { // at most 2 triplets...\n            if (value < 1000) {\n                if (value < 10) {\n                    buffer[offset++] = (char) ('0' + value);\n                } else {\n                    offset = outputLeadingTriplet(value, buffer, offset);\n                }\n            } else {\n                int thousands = value / 1000;\n                value -= (thousands * 1000); // == value % 1000\n                offset = outputLeadingTriplet(thousands, buffer, offset);\n                offset = outputFullTriplet(value, buffer, offset);\n            }\n            return offset;\n        }\n\n        // ok, all 3 triplets included\n        /* Let's first hand possible billions separately before\n         * handling 3 triplets. This is possible since we know we\n         * can have at most '2' as billion count.\n         */\n        boolean hasBillions = (value >= BILLION);\n        if (hasBillions) {\n            value -= BILLION;\n            if (value >= BILLION) {\n                value -= BILLION;\n                buffer[offset++] = '2';\n            } else {\n                buffer[offset++] = '1';\n            }\n        }\n        int newValue = value / 1000;\n        int ones = (value - (newValue * 1000)); // == value % 1000\n        value = newValue;\n        newValue /= 1000;\n        int thousands = (value - (newValue * 1000));\n        \n        // value now has millions, which have 1, 2 or 3 digits\n        if (hasBillions) {\n            offset = outputFullTriplet(newValue, buffer, offset);\n        } else {\n            offset = outputLeadingTriplet(newValue, buffer, offset);\n        }\n        offset = outputFullTriplet(thousands, buffer, offset);\n        offset = outputFullTriplet(ones, buffer, offset);\n        return offset;\n    }"
}