{
          "0": "    public static double tan(double x) {\n        boolean negative = false;\n        int quadrant = 0;\n\n        /* Take absolute value of the input */\n        double xa = x;\n        if (x < 0) {\n            negative = true;\n            xa = -xa;\n        }\n\n        /* Check for zero and negative zero */\n        if (xa == 0.0) {\n            long bits = Double.doubleToRawLongBits(x);\n            if (bits < 0) {\n                return -0.0;\n            }\n            return 0.0;\n        }\n\n        if (xa != xa || xa == Double.POSITIVE_INFINITY) {\n            return Double.NaN;\n        }\n\n        /* Perform any argument reduction */\n        double xb = 0;\n        if (xa > 3294198.0) {\n            // PI * (2**20)\n            // Argument too big for CodyWaite reduction.  Must use\n            // PayneHanek.\n            double reduceResults[] = new double[3];\n            reducePayneHanek(xa, reduceResults);\n            quadrant = ((int) reduceResults[0]) & 3;\n            xa = reduceResults[1];\n            xb = reduceResults[2];\n        } else if (xa > 1.5707963267948966) {\n            final CodyWaite cw = new CodyWaite(xa);\n            quadrant = cw.getK() & 3;\n            xa = cw.getRemA();\n            xb = cw.getRemB();\n        }\n\n        if (xa > 1.5) {\n            // Accuracy suffers between 1.5 and PI/2\n            final double pi2a = 1.5707963267948966;\n            final double pi2b = 6.123233995736766E-17;\n\n            final double a = pi2a - xa;\n            double b = -(a - pi2a + xa);\n            b += pi2b - xb;\n\n            xa = a + b;\n            xb = -(xa - a - b);\n            quadrant ^= 1;\n            negative ^= true;\n        }\n\n        double result;\n        if ((quadrant & 1) == 0) {\n            result = tanQ(xa, xb, false);\n        } else {\n            result = -tanQ(xa, xb, true);\n        }\n\n        if (negative) {\n        }\n\n        return result;\n    }",
          "1": "    public static double tan(double x) {\n        boolean negative = false;\n        int quadrant = 0;\n\n        /* Take absolute value of the input */\n        double xa = x;\n        if (x < 0) {\n            negative = true;\n            xa = -xa;\n        }\n\n        /* Check for zero and negative zero */\n        if (xa == 0.0) {\n            long bits = Double.doubleToRawLongBits(x);\n            if (bits < 0) {\n                return -0.0;\n            }\n            return 0.0;\n        }\n\n        if (xa != xa || xa == Double.POSITIVE_INFINITY) {\n            return Double.NaN;\n        }\n\n        /* Perform any argument reduction */\n        double xb = 0;\n        if (xa > 3294198.0) {\n            // PI * (2**20)\n            // Argument too big for CodyWaite reduction.  Must use\n            // PayneHanek.\n            double reduceResults[] = new double[3];\n            reducePayneHanek(xa, reduceResults);\n            quadrant = ((int) reduceResults[0]) & 3;\n            xa = reduceResults[1];\n            xb = reduceResults[2];\n        } else if (xa > 1.5707963267948966) {\n            final CodyWaite cw = new CodyWaite(xa);\n            quadrant = cw.getK() & 3;\n            xa = cw.getRemA();\n            xb = cw.getRemB();\n        }\n\n        if (xa > 1.5) {\n            // Accuracy suffers between 1.5 and PI/2\n            final double pi2a = 1.5707963267948966;\n            final double pi2b = 6.123233995736766E-17;\n\n            final double a = pi2a - xa;\n            double b = -(a - pi2a + xa);\n            b += pi2b - xb;\n\n            xa = a + b;\n            xb = -(xa - a - b);\n            quadrant ^= 1;\n            negative ^= true;\n        }\n\n        double result;\n        if ((quadrant & 1) == 0) {\n            result = tanQ(xa, xb, false);\n        } else {\n            result = -tanQ(xa, xb, true);\n        }\n\n        if (negative) {\nresult = -tanQ(xa, xb, true);\n        }\n\n        return result;\n    }",
          "2": "    public static double tan(double x) {\n        boolean negative = false;\n        int quadrant = 0;\n\n        /* Take absolute value of the input */\n        double xa = x;\n        if (x < 0) {\n            negative = true;\n            xa = -xa;\n        }\n\n        /* Check for zero and negative zero */\n        if (xa == 0.0) {\n            long bits = Double.doubleToRawLongBits(x);\n            if (bits < 0) {\n                return -0.0;\n            }\n            return 0.0;\n        }\n\n        if (xa != xa || xa == Double.POSITIVE_INFINITY) {\n            return Double.NaN;\n        }\n\n        /* Perform any argument reduction */\n        double xb = 0;\n        if (xa > 3294198.0) {\n            // PI * (2**20)\n            // Argument too big for CodyWaite reduction.  Must use\n            // PayneHanek.\n            double reduceResults[] = new double[3];\n            reducePayneHanek(xa, reduceResults);\n            quadrant = ((int) reduceResults[0]) & 3;\n            xa = reduceResults[1];\n            xb = reduceResults[2];\n        } else if (xa > 1.5707963267948966) {\n            final CodyWaite cw = new CodyWaite(xa);\n            quadrant = cw.getK() & 3;\n            xa = cw.getRemA();\n            xb = cw.getRemB();\n        }\n\n        if (xa > 1.5) {\n            // Accuracy suffers between 1.5 and PI/2\n            final double pi2a = 1.5707963267948966;\n            final double pi2b = 6.123233995736766E-17;\n\n            final double a = pi2a - xa;\n            double b = -(a - pi2a + xa);\n            b += pi2b - xb;\n\n            xa = a + b;\n            xb = -(xa - a - b);\n            quadrant ^= 1;\n            negative ^= true;\n        }\n\n        double result;\n        if ((quadrant & 1) == 0) {\n            result = tanQ(xa, xb, false);\n        } else {\n            result = -tanQ(xa, xb, true);\n        }\n\n        if (negative) {\nresult = tanQ(xa, xb, false);\n        }\n\n        return result;\n    }",
          "3": "    public static double tan(double x) {\n        boolean negative = false;\n        int quadrant = 0;\n\n        /* Take absolute value of the input */\n        double xa = x;\n        if (x < 0) {\n            negative = true;\n            xa = -xa;\n        }\n\n        /* Check for zero and negative zero */\n        if (xa == 0.0) {\n            long bits = Double.doubleToRawLongBits(x);\n            if (bits < 0) {\n                return -0.0;\n            }\n            return 0.0;\n        }\n\n        if (xa != xa || xa == Double.POSITIVE_INFINITY) {\n            return Double.NaN;\n        }\n\n        /* Perform any argument reduction */\n        double xb = 0;\n        if (xa > 3294198.0) {\n            // PI * (2**20)\n            // Argument too big for CodyWaite reduction.  Must use\n            // PayneHanek.\n            double reduceResults[] = new double[3];\n            reducePayneHanek(xa, reduceResults);\n            quadrant = ((int) reduceResults[0]) & 3;\n            xa = reduceResults[1];\n            xb = reduceResults[2];\n        } else if (xa > 1.5707963267948966) {\n            final CodyWaite cw = new CodyWaite(xa);\n            quadrant = cw.getK() & 3;\n            xa = cw.getRemA();\n            xb = cw.getRemB();\n        }\n\n        if (xa > 1.5) {\n            // Accuracy suffers between 1.5 and PI/2\n            final double pi2a = 1.5707963267948966;\n            final double pi2b = 6.123233995736766E-17;\n\n            final double a = pi2a - xa;\n            double b = -(a - pi2a + xa);\n            b += pi2b - xb;\n\n            xa = a + b;\n            xb = -(xa - a - b);\n            quadrant ^= 1;\n            negative ^= true;\n        }\n\n        double result;\n        if ((quadrant & 1) == 0) {\n            result = tanQ(xa, xb, false);\n        } else {\n            result = -tanQ(xa, xb, true);\n        }\n\n        if (negative) {\nresult = -tanQ(xa, xb, true);\n            result = +result;        }\n\n        return result;\n    }",
          "4": "    public static double tan(double x) {\n        boolean negative = false;\n        int quadrant = 0;\n\n        /* Take absolute value of the input */\n        double xa = x;\n        if (x < 0) {\n            negative = true;\n            xa = -xa;\n        }\n\n        /* Check for zero and negative zero */\n        if (xa == 0.0) {\n            long bits = Double.doubleToRawLongBits(x);\n            if (bits < 0) {\n                return -0.0;\n            }\n            return 0.0;\n        }\n\n        if (xa != xa || xa == Double.POSITIVE_INFINITY) {\n            return Double.NaN;\n        }\n\n        /* Perform any argument reduction */\n        double xb = 0;\n        if (xa > 3294198.0) {\n            // PI * (2**20)\n            // Argument too big for CodyWaite reduction.  Must use\n            // PayneHanek.\n            double reduceResults[] = new double[3];\n            reducePayneHanek(xa, reduceResults);\n            quadrant = ((int) reduceResults[0]) & 3;\n            xa = reduceResults[1];\n            xb = reduceResults[2];\n        } else if (xa > 1.5707963267948966) {\n            final CodyWaite cw = new CodyWaite(xa);\n            quadrant = cw.getK() & 3;\n            xa = cw.getRemA();\n            xb = cw.getRemB();\n        }\n\n        if (xa > 1.5) {\n            // Accuracy suffers between 1.5 and PI/2\n            final double pi2a = 1.5707963267948966;\n            final double pi2b = 6.123233995736766E-17;\n\n            final double a = pi2a - xa;\n            double b = -(a - pi2a + xa);\n            b += pi2b - xb;\n\n            xa = a + b;\n            xb = -(xa - a - b);\n            quadrant ^= 1;\n            negative ^= true;\n        }\n\n        double result;\n        if ((quadrant & 1) == 0) {\n            result = tanQ(xa, xb, false);\n        } else {\n            result = -tanQ(xa, xb, true);\n        }\n\n        if (negative) {\nif(negative){\n}\n            result = +result;        }\n\n        return result;\n    }",
          "5": "    public static double tan(double x) {\n        boolean negative = false;\n        int quadrant = 0;\n\n        /* Take absolute value of the input */\n        double xa = x;\n        if (x < 0) {\n            negative = true;\n            xa = -xa;\n        }\n\n        /* Check for zero and negative zero */\n        if (xa == 0.0) {\n            long bits = Double.doubleToRawLongBits(x);\n            if (bits < 0) {\n                return -0.0;\n            }\n            return 0.0;\n        }\n\n        if (xa != xa || xa == Double.POSITIVE_INFINITY) {\n            return Double.NaN;\n        }\n\n        /* Perform any argument reduction */\n        double xb = 0;\n        if (xa > 3294198.0) {\n            // PI * (2**20)\n            // Argument too big for CodyWaite reduction.  Must use\n            // PayneHanek.\n            double reduceResults[] = new double[3];\n            reducePayneHanek(xa, reduceResults);\n            quadrant = ((int) reduceResults[0]) & 3;\n            xa = reduceResults[1];\n            xb = reduceResults[2];\n        } else if (xa > 1.5707963267948966) {\n            final CodyWaite cw = new CodyWaite(xa);\n            quadrant = cw.getK() & 3;\n            xa = cw.getRemA();\n            xb = cw.getRemB();\n        }\n\n        if (xa > 1.5) {\n            // Accuracy suffers between 1.5 and PI/2\n            final double pi2a = 1.5707963267948966;\n            final double pi2b = 6.123233995736766E-17;\n\n            final double a = pi2a - xa;\n            double b = -(a - pi2a + xa);\n            b += pi2b - xb;\n\n            xa = a + b;\n            xb = -(xa - a - b);\n            quadrant ^= 1;\n            negative ^= true;\n        }\n\n        double result;\n        if ((quadrant & 1) == 0) {\n            result = tanQ(xa, xb, false);\n        } else {\n            result = -tanQ(xa, xb, true);\n        }\n\n        if (negative) {\nresult = tanQ(xa, xb, false);\n            result = +result;        }\n\n        return result;\n    }",
          "6": "    public static double tan(double x) {\n        boolean negative = false;\n        int quadrant = 0;\n\n        /* Take absolute value of the input */\n        double xa = x;\n        if (x < 0) {\n            negative = true;\n            xa = -xa;\n        }\n\n        /* Check for zero and negative zero */\n        if (xa == 0.0) {\n            long bits = Double.doubleToRawLongBits(x);\n            if (bits < 0) {\n                return -0.0;\n            }\n            return 0.0;\n        }\n\n        if (xa != xa || xa == Double.POSITIVE_INFINITY) {\n            return Double.NaN;\n        }\n\n        /* Perform any argument reduction */\n        double xb = 0;\n        if (xa > 3294198.0) {\n            // PI * (2**20)\n            // Argument too big for CodyWaite reduction.  Must use\n            // PayneHanek.\n            double reduceResults[] = new double[3];\n            reducePayneHanek(xa, reduceResults);\n            quadrant = ((int) reduceResults[0]) & 3;\n            xa = reduceResults[1];\n            xb = reduceResults[2];\n        } else if (xa > 1.5707963267948966) {\n            final CodyWaite cw = new CodyWaite(xa);\n            quadrant = cw.getK() & 3;\n            xa = cw.getRemA();\n            xb = cw.getRemB();\n        }\n\n        if (xa > 1.5) {\n            // Accuracy suffers between 1.5 and PI/2\n            final double pi2a = 1.5707963267948966;\n            final double pi2b = 6.123233995736766E-17;\n\n            final double a = pi2a - xa;\n            double b = -(a - pi2a + xa);\n            b += pi2b - xb;\n\n            xa = a + b;\n            xb = -(xa - a - b);\n            quadrant ^= 1;\n            negative ^= true;\n        }\n\n        double result;\n        if ((quadrant & 1) == 0) {\n            result = tanQ(xa, xb, false);\n        } else {\n            result = -tanQ(xa, xb, true);\n        }\n\n        if (negative) {\nresult = result;\n        }\n\n        return result;\n    }",
          "7": "    public static double tan(double x) {\n        boolean negative = false;\n        int quadrant = 0;\n\n        /* Take absolute value of the input */\n        double xa = x;\n        if (x < 0) {\n            negative = true;\n            xa = -xa;\n        }\n\n        /* Check for zero and negative zero */\n        if (xa == 0.0) {\n            long bits = Double.doubleToRawLongBits(x);\n            if (bits < 0) {\n                return -0.0;\n            }\n            return 0.0;\n        }\n\n        if (xa != xa || xa == Double.POSITIVE_INFINITY) {\n            return Double.NaN;\n        }\n\n        /* Perform any argument reduction */\n        double xb = 0;\n        if (xa > 3294198.0) {\n            // PI * (2**20)\n            // Argument too big for CodyWaite reduction.  Must use\n            // PayneHanek.\n            double reduceResults[] = new double[3];\n            reducePayneHanek(xa, reduceResults);\n            quadrant = ((int) reduceResults[0]) & 3;\n            xa = reduceResults[1];\n            xb = reduceResults[2];\n        } else if (xa > 1.5707963267948966) {\n            final CodyWaite cw = new CodyWaite(xa);\n            quadrant = cw.getK() & 3;\n            xa = cw.getRemA();\n            xb = cw.getRemB();\n        }\n\n        if (xa > 1.5) {\n            // Accuracy suffers between 1.5 and PI/2\n            final double pi2a = 1.5707963267948966;\n            final double pi2b = 6.123233995736766E-17;\n\n            final double a = pi2a - xa;\n            double b = -(a - pi2a + xa);\n            b += pi2b - xb;\n\n            xa = a + b;\n            xb = -(xa - a - b);\n            quadrant ^= 1;\n            negative ^= true;\n        }\n\n        double result;\n        if ((quadrant & 1) == 0) {\n            result = tanQ(xa, xb, false);\n        } else {\n            result = -tanQ(xa, xb, true);\n        }\n\n        if (negative) {\nresult = xb;\n        }\n\n        return result;\n    }",
          "8": "    public static double tan(double x) {\n        boolean negative = false;\n        int quadrant = 0;\n\n        /* Take absolute value of the input */\n        double xa = x;\n        if (x < 0) {\n            negative = true;\n            xa = -xa;\n        }\n\n        /* Check for zero and negative zero */\n        if (xa == 0.0) {\n            long bits = Double.doubleToRawLongBits(x);\n            if (bits < 0) {\n                return -0.0;\n            }\n            return 0.0;\n        }\n\n        if (xa != xa || xa == Double.POSITIVE_INFINITY) {\n            return Double.NaN;\n        }\n\n        /* Perform any argument reduction */\n        double xb = 0;\n        if (xa > 3294198.0) {\n            // PI * (2**20)\n            // Argument too big for CodyWaite reduction.  Must use\n            // PayneHanek.\n            double reduceResults[] = new double[3];\n            reducePayneHanek(xa, reduceResults);\n            quadrant = ((int) reduceResults[0]) & 3;\n            xa = reduceResults[1];\n            xb = reduceResults[2];\n        } else if (xa > 1.5707963267948966) {\n            final CodyWaite cw = new CodyWaite(xa);\n            quadrant = cw.getK() & 3;\n            xa = cw.getRemA();\n            xb = cw.getRemB();\n        }\n\n        if (xa > 1.5) {\n            // Accuracy suffers between 1.5 and PI/2\n            final double pi2a = 1.5707963267948966;\n            final double pi2b = 6.123233995736766E-17;\n\n            final double a = pi2a - xa;\n            double b = -(a - pi2a + xa);\n            b += pi2b - xb;\n\n            xa = a + b;\n            xb = -(xa - a - b);\n            quadrant ^= 1;\n            negative ^= true;\n        }\n\n        double result;\n        if ((quadrant & 1) == 0) {\n            result = tanQ(xa, xb, false);\n        } else {\n            result = -tanQ(xa, xb, true);\n        }\n\n        if (negative) {\nresult = xa;\n        }\n\n        return result;\n    }",
          "9": "    public static double tan(double x) {\n        boolean negative = false;\n        int quadrant = 0;\n\n        /* Take absolute value of the input */\n        double xa = x;\n        if (x < 0) {\n            negative = true;\n            xa = -xa;\n        }\n\n        /* Check for zero and negative zero */\n        if (xa == 0.0) {\n            long bits = Double.doubleToRawLongBits(x);\n            if (bits < 0) {\n                return -0.0;\n            }\n            return 0.0;\n        }\n\n        if (xa != xa || xa == Double.POSITIVE_INFINITY) {\n            return Double.NaN;\n        }\n\n        /* Perform any argument reduction */\n        double xb = 0;\n        if (xa > 3294198.0) {\n            // PI * (2**20)\n            // Argument too big for CodyWaite reduction.  Must use\n            // PayneHanek.\n            double reduceResults[] = new double[3];\n            reducePayneHanek(xa, reduceResults);\n            quadrant = ((int) reduceResults[0]) & 3;\n            xa = reduceResults[1];\n            xb = reduceResults[2];\n        } else if (xa > 1.5707963267948966) {\n            final CodyWaite cw = new CodyWaite(xa);\n            quadrant = cw.getK() & 3;\n            xa = cw.getRemA();\n            xb = cw.getRemB();\n        }\n\n        if (xa > 1.5) {\n            // Accuracy suffers between 1.5 and PI/2\n            final double pi2a = 1.5707963267948966;\n            final double pi2b = 6.123233995736766E-17;\n\n            final double a = pi2a - xa;\n            double b = -(a - pi2a + xa);\n            b += pi2b - xb;\n\n            xa = a + b;\n            xb = -(xa - a - b);\n            quadrant ^= 1;\n            negative ^= true;\n        }\n\n        double result;\n        if ((quadrant & 1) == 0) {\n            result = tanQ(xa, xb, false);\n        } else {\n            result = -tanQ(xa, xb, true);\n        }\n\n        if (negative) {\nresult = negative;\n        }\n\n        return result;\n    }",
          "10": "    public static double tan(double x) {\n        boolean negative = false;\n        int quadrant = 0;\n\n        /* Take absolute value of the input */\n        double xa = x;\n        if (x < 0) {\n            negative = true;\n            xa = -xa;\n        }\n\n        /* Check for zero and negative zero */\n        if (xa == 0.0) {\n            long bits = Double.doubleToRawLongBits(x);\n            if (bits < 0) {\n                return -0.0;\n            }\n            return 0.0;\n        }\n\n        if (xa != xa || xa == Double.POSITIVE_INFINITY) {\n            return Double.NaN;\n        }\n\n        /* Perform any argument reduction */\n        double xb = 0;\n        if (xa > 3294198.0) {\n            // PI * (2**20)\n            // Argument too big for CodyWaite reduction.  Must use\n            // PayneHanek.\n            double reduceResults[] = new double[3];\n            reducePayneHanek(xa, reduceResults);\n            quadrant = ((int) reduceResults[0]) & 3;\n            xa = reduceResults[1];\n            xb = reduceResults[2];\n        } else if (xa > 1.5707963267948966) {\n            final CodyWaite cw = new CodyWaite(xa);\n            quadrant = cw.getK() & 3;\n            xa = cw.getRemA();\n            xb = cw.getRemB();\n        }\n\n        if (xa > 1.5) {\n            // Accuracy suffers between 1.5 and PI/2\n            final double pi2a = 1.5707963267948966;\n            final double pi2b = 6.123233995736766E-17;\n\n            final double a = pi2a - xa;\n            double b = -(a - pi2a + xa);\n            b += pi2b - xb;\n\n            xa = a + b;\n            xb = -(xa - a - b);\n            quadrant ^= 1;\n            negative ^= true;\n        }\n\n        double result;\n        if ((quadrant & 1) == 0) {\n            result = tanQ(xa, xb, false);\n        } else {\n            result = -tanQ(xa, xb, true);\n        }\n\n        if (negative) {\nif(((quadrant & 1) == 0)){\n}\n            result = +result;        }\n\n        return result;\n    }",
          "11": "    public static double tan(double x) {\n        boolean negative = false;\n        int quadrant = 0;\n\n        /* Take absolute value of the input */\n        double xa = x;\n        if (x < 0) {\n            negative = true;\n            xa = -xa;\n        }\n\n        /* Check for zero and negative zero */\n        if (xa == 0.0) {\n            long bits = Double.doubleToRawLongBits(x);\n            if (bits < 0) {\n                return -0.0;\n            }\n            return 0.0;\n        }\n\n        if (xa != xa || xa == Double.POSITIVE_INFINITY) {\n            return Double.NaN;\n        }\n\n        /* Perform any argument reduction */\n        double xb = 0;\n        if (xa > 3294198.0) {\n            // PI * (2**20)\n            // Argument too big for CodyWaite reduction.  Must use\n            // PayneHanek.\n            double reduceResults[] = new double[3];\n            reducePayneHanek(xa, reduceResults);\n            quadrant = ((int) reduceResults[0]) & 3;\n            xa = reduceResults[1];\n            xb = reduceResults[2];\n        } else if (xa > 1.5707963267948966) {\n            final CodyWaite cw = new CodyWaite(xa);\n            quadrant = cw.getK() & 3;\n            xa = cw.getRemA();\n            xb = cw.getRemB();\n        }\n\n        if (xa > 1.5) {\n            // Accuracy suffers between 1.5 and PI/2\n            final double pi2a = 1.5707963267948966;\n            final double pi2b = 6.123233995736766E-17;\n\n            final double a = pi2a - xa;\n            double b = -(a - pi2a + xa);\n            b += pi2b - xb;\n\n            xa = a + b;\n            xb = -(xa - a - b);\n            quadrant ^= 1;\n            negative ^= true;\n        }\n\n        double result;\n        if ((quadrant & 1) == 0) {\n            result = tanQ(xa, xb, false);\n        } else {\n            result = -tanQ(xa, xb, true);\n        }\n\n        if (negative) {\nreturn;\n        }\n\n        return result;\n    }",
          "12": "    public static double tan(double x) {\n        boolean negative = false;\n        int quadrant = 0;\n\n        /* Take absolute value of the input */\n        double xa = x;\n        if (x < 0) {\n            negative = true;\n            xa = -xa;\n        }\n\n        /* Check for zero and negative zero */\n        if (xa == 0.0) {\n            long bits = Double.doubleToRawLongBits(x);\n            if (bits < 0) {\n                return -0.0;\n            }\n            return 0.0;\n        }\n\n        if (xa != xa || xa == Double.POSITIVE_INFINITY) {\n            return Double.NaN;\n        }\n\n        /* Perform any argument reduction */\n        double xb = 0;\n        if (xa > 3294198.0) {\n            // PI * (2**20)\n            // Argument too big for CodyWaite reduction.  Must use\n            // PayneHanek.\n            double reduceResults[] = new double[3];\n            reducePayneHanek(xa, reduceResults);\n            quadrant = ((int) reduceResults[0]) & 3;\n            xa = reduceResults[1];\n            xb = reduceResults[2];\n        } else if (xa > 1.5707963267948966) {\n            final CodyWaite cw = new CodyWaite(xa);\n            quadrant = cw.getK() & 3;\n            xa = cw.getRemA();\n            xb = cw.getRemB();\n        }\n\n        if (xa > 1.5) {\n            // Accuracy suffers between 1.5 and PI/2\n            final double pi2a = 1.5707963267948966;\n            final double pi2b = 6.123233995736766E-17;\n\n            final double a = pi2a - xa;\n            double b = -(a - pi2a + xa);\n            b += pi2b - xb;\n\n            xa = a + b;\n            xb = -(xa - a - b);\n            quadrant ^= 1;\n            negative ^= true;\n        }\n\n        double result;\n        if ((quadrant & 1) == 0) {\n            result = tanQ(xa, xb, false);\n        } else {\n            result = -tanQ(xa, xb, true);\n        }\n\n        if (negative) {\nresult = +result;\n        }\n\n        return result;\n    }",
          "13": "    public static double tan(double x) {\n        boolean negative = false;\n        int quadrant = 0;\n\n        /* Take absolute value of the input */\n        double xa = x;\n        if (x < 0) {\n            negative = true;\n            xa = -xa;\n        }\n\n        /* Check for zero and negative zero */\n        if (xa == 0.0) {\n            long bits = Double.doubleToRawLongBits(x);\n            if (bits < 0) {\n                return -0.0;\n            }\n            return 0.0;\n        }\n\n        if (xa != xa || xa == Double.POSITIVE_INFINITY) {\n            return Double.NaN;\n        }\n\n        /* Perform any argument reduction */\n        double xb = 0;\n        if (xa > 3294198.0) {\n            // PI * (2**20)\n            // Argument too big for CodyWaite reduction.  Must use\n            // PayneHanek.\n            double reduceResults[] = new double[3];\n            reducePayneHanek(xa, reduceResults);\n            quadrant = ((int) reduceResults[0]) & 3;\n            xa = reduceResults[1];\n            xb = reduceResults[2];\n        } else if (xa > 1.5707963267948966) {\n            final CodyWaite cw = new CodyWaite(xa);\n            quadrant = cw.getK() & 3;\n            xa = cw.getRemA();\n            xb = cw.getRemB();\n        }\n\n        if (xa > 1.5) {\n            // Accuracy suffers between 1.5 and PI/2\n            final double pi2a = 1.5707963267948966;\n            final double pi2b = 6.123233995736766E-17;\n\n            final double a = pi2a - xa;\n            double b = -(a - pi2a + xa);\n            b += pi2b - xb;\n\n            xa = a + b;\n            xb = -(xa - a - b);\n            quadrant ^= 1;\n            negative ^= true;\n        }\n\n        double result;\n        if ((quadrant & 1) == 0) {\n            result = tanQ(xa, xb, false);\n        } else {\n            result = -tanQ(xa, xb, true);\n        }\n\n        if (negative) {\nxb = +result;\n        }\n\n        return result;\n    }",
          "14": "    public static double tan(double x) {\n        boolean negative = false;\n        int quadrant = 0;\n\n        /* Take absolute value of the input */\n        double xa = x;\n        if (x < 0) {\n            negative = true;\n            xa = -xa;\n        }\n\n        /* Check for zero and negative zero */\n        if (xa == 0.0) {\n            long bits = Double.doubleToRawLongBits(x);\n            if (bits < 0) {\n                return -0.0;\n            }\n            return 0.0;\n        }\n\n        if (xa != xa || xa == Double.POSITIVE_INFINITY) {\n            return Double.NaN;\n        }\n\n        /* Perform any argument reduction */\n        double xb = 0;\n        if (xa > 3294198.0) {\n            // PI * (2**20)\n            // Argument too big for CodyWaite reduction.  Must use\n            // PayneHanek.\n            double reduceResults[] = new double[3];\n            reducePayneHanek(xa, reduceResults);\n            quadrant = ((int) reduceResults[0]) & 3;\n            xa = reduceResults[1];\n            xb = reduceResults[2];\n        } else if (xa > 1.5707963267948966) {\n            final CodyWaite cw = new CodyWaite(xa);\n            quadrant = cw.getK() & 3;\n            xa = cw.getRemA();\n            xb = cw.getRemB();\n        }\n\n        if (xa > 1.5) {\n            // Accuracy suffers between 1.5 and PI/2\n            final double pi2a = 1.5707963267948966;\n            final double pi2b = 6.123233995736766E-17;\n\n            final double a = pi2a - xa;\n            double b = -(a - pi2a + xa);\n            b += pi2b - xb;\n\n            xa = a + b;\n            xb = -(xa - a - b);\n            quadrant ^= 1;\n            negative ^= true;\n        }\n\n        double result;\n        if ((quadrant & 1) == 0) {\n            result = tanQ(xa, xb, false);\n        } else {\n            result = -tanQ(xa, xb, true);\n        }\n\n        if (negative) {\nxa = +result;\n        }\n\n        return result;\n    }",
          "15": "    public static double tan(double x) {\n        boolean negative = false;\n        int quadrant = 0;\n\n        /* Take absolute value of the input */\n        double xa = x;\n        if (x < 0) {\n            negative = true;\n            xa = -xa;\n        }\n\n        /* Check for zero and negative zero */\n        if (xa == 0.0) {\n            long bits = Double.doubleToRawLongBits(x);\n            if (bits < 0) {\n                return -0.0;\n            }\n            return 0.0;\n        }\n\n        if (xa != xa || xa == Double.POSITIVE_INFINITY) {\n            return Double.NaN;\n        }\n\n        /* Perform any argument reduction */\n        double xb = 0;\n        if (xa > 3294198.0) {\n            // PI * (2**20)\n            // Argument too big for CodyWaite reduction.  Must use\n            // PayneHanek.\n            double reduceResults[] = new double[3];\n            reducePayneHanek(xa, reduceResults);\n            quadrant = ((int) reduceResults[0]) & 3;\n            xa = reduceResults[1];\n            xb = reduceResults[2];\n        } else if (xa > 1.5707963267948966) {\n            final CodyWaite cw = new CodyWaite(xa);\n            quadrant = cw.getK() & 3;\n            xa = cw.getRemA();\n            xb = cw.getRemB();\n        }\n\n        if (xa > 1.5) {\n            // Accuracy suffers between 1.5 and PI/2\n            final double pi2a = 1.5707963267948966;\n            final double pi2b = 6.123233995736766E-17;\n\n            final double a = pi2a - xa;\n            double b = -(a - pi2a + xa);\n            b += pi2b - xb;\n\n            xa = a + b;\n            xb = -(xa - a - b);\n            quadrant ^= 1;\n            negative ^= true;\n        }\n\n        double result;\n        if ((quadrant & 1) == 0) {\n            result = tanQ(xa, xb, false);\n        } else {\n            result = -tanQ(xa, xb, true);\n        }\n\n        if (negative) {\nnegative = +result;\n        }\n\n        return result;\n    }",
          "16": "    public static double tan(double x) {\n        boolean negative = false;\n        int quadrant = 0;\n\n        /* Take absolute value of the input */\n        double xa = x;\n        if (x < 0) {\n            negative = true;\n            xa = -xa;\n        }\n\n        /* Check for zero and negative zero */\n        if (xa == 0.0) {\n            long bits = Double.doubleToRawLongBits(x);\n            if (bits < 0) {\n                return -0.0;\n            }\n            return 0.0;\n        }\n\n        if (xa != xa || xa == Double.POSITIVE_INFINITY) {\n            return Double.NaN;\n        }\n\n        /* Perform any argument reduction */\n        double xb = 0;\n        if (xa > 3294198.0) {\n            // PI * (2**20)\n            // Argument too big for CodyWaite reduction.  Must use\n            // PayneHanek.\n            double reduceResults[] = new double[3];\n            reducePayneHanek(xa, reduceResults);\n            quadrant = ((int) reduceResults[0]) & 3;\n            xa = reduceResults[1];\n            xb = reduceResults[2];\n        } else if (xa > 1.5707963267948966) {\n            final CodyWaite cw = new CodyWaite(xa);\n            quadrant = cw.getK() & 3;\n            xa = cw.getRemA();\n            xb = cw.getRemB();\n        }\n\n        if (xa > 1.5) {\n            // Accuracy suffers between 1.5 and PI/2\n            final double pi2a = 1.5707963267948966;\n            final double pi2b = 6.123233995736766E-17;\n\n            final double a = pi2a - xa;\n            double b = -(a - pi2a + xa);\n            b += pi2b - xb;\n\n            xa = a + b;\n            xb = -(xa - a - b);\n            quadrant ^= 1;\n            negative ^= true;\n        }\n\n        double result;\n        if ((quadrant & 1) == 0) {\n            result = tanQ(xa, xb, false);\n        } else {\n            result = -tanQ(xa, xb, true);\n        }\n\n        if (negative) {\nresult = -result;\n        }\n\n        return result;\n    }",
          "17": "    public static double tan(double x) {\n        boolean negative = false;\n        int quadrant = 0;\n\n        /* Take absolute value of the input */\n        double xa = x;\n        if (x < 0) {\n            negative = true;\n            xa = -xa;\n        }\n\n        /* Check for zero and negative zero */\n        if (xa == 0.0) {\n            long bits = Double.doubleToRawLongBits(x);\n            if (bits < 0) {\n                return -0.0;\n            }\n            return 0.0;\n        }\n\n        if (xa != xa || xa == Double.POSITIVE_INFINITY) {\n            return Double.NaN;\n        }\n\n        /* Perform any argument reduction */\n        double xb = 0;\n        if (xa > 3294198.0) {\n            // PI * (2**20)\n            // Argument too big for CodyWaite reduction.  Must use\n            // PayneHanek.\n            double reduceResults[] = new double[3];\n            reducePayneHanek(xa, reduceResults);\n            quadrant = ((int) reduceResults[0]) & 3;\n            xa = reduceResults[1];\n            xb = reduceResults[2];\n        } else if (xa > 1.5707963267948966) {\n            final CodyWaite cw = new CodyWaite(xa);\n            quadrant = cw.getK() & 3;\n            xa = cw.getRemA();\n            xb = cw.getRemB();\n        }\n\n        if (xa > 1.5) {\n            // Accuracy suffers between 1.5 and PI/2\n            final double pi2a = 1.5707963267948966;\n            final double pi2b = 6.123233995736766E-17;\n\n            final double a = pi2a - xa;\n            double b = -(a - pi2a + xa);\n            b += pi2b - xb;\n\n            xa = a + b;\n            xb = -(xa - a - b);\n            quadrant ^= 1;\n            negative ^= true;\n        }\n\n        double result;\n        if ((quadrant & 1) == 0) {\n            result = tanQ(xa, xb, false);\n        } else {\n            result = -tanQ(xa, xb, true);\n        }\n\n        if (negative) {\nif((quadrant & 1)){\n}\n            result = +result;        }\n\n        return result;\n    }",
          "18": "    public static double tan(double x) {\n        boolean negative = false;\n        int quadrant = 0;\n\n        /* Take absolute value of the input */\n        double xa = x;\n        if (x < 0) {\n            negative = true;\n            xa = -xa;\n        }\n\n        /* Check for zero and negative zero */\n        if (xa == 0.0) {\n            long bits = Double.doubleToRawLongBits(x);\n            if (bits < 0) {\n                return -0.0;\n            }\n            return 0.0;\n        }\n\n        if (xa != xa || xa == Double.POSITIVE_INFINITY) {\n            return Double.NaN;\n        }\n\n        /* Perform any argument reduction */\n        double xb = 0;\n        if (xa > 3294198.0) {\n            // PI * (2**20)\n            // Argument too big for CodyWaite reduction.  Must use\n            // PayneHanek.\n            double reduceResults[] = new double[3];\n            reducePayneHanek(xa, reduceResults);\n            quadrant = ((int) reduceResults[0]) & 3;\n            xa = reduceResults[1];\n            xb = reduceResults[2];\n        } else if (xa > 1.5707963267948966) {\n            final CodyWaite cw = new CodyWaite(xa);\n            quadrant = cw.getK() & 3;\n            xa = cw.getRemA();\n            xb = cw.getRemB();\n        }\n\n        if (xa > 1.5) {\n            // Accuracy suffers between 1.5 and PI/2\n            final double pi2a = 1.5707963267948966;\n            final double pi2b = 6.123233995736766E-17;\n\n            final double a = pi2a - xa;\n            double b = -(a - pi2a + xa);\n            b += pi2b - xb;\n\n            xa = a + b;\n            xb = -(xa - a - b);\n            quadrant ^= 1;\n            negative ^= true;\n        }\n\n        double result;\n        if ((quadrant & 1) == 0) {\n            result = tanQ(xa, xb, false);\n        } else {\n            result = -tanQ(xa, xb, true);\n        }\n\n        if (negative) {\nquadrant = +result;\n        }\n\n        return result;\n    }",
          "19": "    public static double tan(double x) {\n        boolean negative = false;\n        int quadrant = 0;\n\n        /* Take absolute value of the input */\n        double xa = x;\n        if (x < 0) {\n            negative = true;\n            xa = -xa;\n        }\n\n        /* Check for zero and negative zero */\n        if (xa == 0.0) {\n            long bits = Double.doubleToRawLongBits(x);\n            if (bits < 0) {\n                return -0.0;\n            }\n            return 0.0;\n        }\n\n        if (xa != xa || xa == Double.POSITIVE_INFINITY) {\n            return Double.NaN;\n        }\n\n        /* Perform any argument reduction */\n        double xb = 0;\n        if (xa > 3294198.0) {\n            // PI * (2**20)\n            // Argument too big for CodyWaite reduction.  Must use\n            // PayneHanek.\n            double reduceResults[] = new double[3];\n            reducePayneHanek(xa, reduceResults);\n            quadrant = ((int) reduceResults[0]) & 3;\n            xa = reduceResults[1];\n            xb = reduceResults[2];\n        } else if (xa > 1.5707963267948966) {\n            final CodyWaite cw = new CodyWaite(xa);\n            quadrant = cw.getK() & 3;\n            xa = cw.getRemA();\n            xb = cw.getRemB();\n        }\n\n        if (xa > 1.5) {\n            // Accuracy suffers between 1.5 and PI/2\n            final double pi2a = 1.5707963267948966;\n            final double pi2b = 6.123233995736766E-17;\n\n            final double a = pi2a - xa;\n            double b = -(a - pi2a + xa);\n            b += pi2b - xb;\n\n            xa = a + b;\n            xb = -(xa - a - b);\n            quadrant ^= 1;\n            negative ^= true;\n        }\n\n        double result;\n        if ((quadrant & 1) == 0) {\n            result = tanQ(xa, xb, false);\n        } else {\n            result = -tanQ(xa, xb, true);\n        }\n\n        if (negative) {\nresult = true;\n        }\n\n        return result;\n    }",
          "20": "    public static double tan(double x) {\n        boolean negative = false;\n        int quadrant = 0;\n\n        /* Take absolute value of the input */\n        double xa = x;\n        if (x < 0) {\n            negative = true;\n            xa = -xa;\n        }\n\n        /* Check for zero and negative zero */\n        if (xa == 0.0) {\n            long bits = Double.doubleToRawLongBits(x);\n            if (bits < 0) {\n                return -0.0;\n            }\n            return 0.0;\n        }\n\n        if (xa != xa || xa == Double.POSITIVE_INFINITY) {\n            return Double.NaN;\n        }\n\n        /* Perform any argument reduction */\n        double xb = 0;\n        if (xa > 3294198.0) {\n            // PI * (2**20)\n            // Argument too big for CodyWaite reduction.  Must use\n            // PayneHanek.\n            double reduceResults[] = new double[3];\n            reducePayneHanek(xa, reduceResults);\n            quadrant = ((int) reduceResults[0]) & 3;\n            xa = reduceResults[1];\n            xb = reduceResults[2];\n        } else if (xa > 1.5707963267948966) {\n            final CodyWaite cw = new CodyWaite(xa);\n            quadrant = cw.getK() & 3;\n            xa = cw.getRemA();\n            xb = cw.getRemB();\n        }\n\n        if (xa > 1.5) {\n            // Accuracy suffers between 1.5 and PI/2\n            final double pi2a = 1.5707963267948966;\n            final double pi2b = 6.123233995736766E-17;\n\n            final double a = pi2a - xa;\n            double b = -(a - pi2a + xa);\n            b += pi2b - xb;\n\n            xa = a + b;\n            xb = -(xa - a - b);\n            quadrant ^= 1;\n            negative ^= true;\n        }\n\n        double result;\n        if ((quadrant & 1) == 0) {\n            result = tanQ(xa, xb, false);\n        } else {\n            result = -tanQ(xa, xb, true);\n        }\n\n        if (negative) {\nresult = false;\n        }\n\n        return result;\n    }",
          "21": "    public static double tan(double x) {\n        boolean negative = false;\n        int quadrant = 0;\n\n        /* Take absolute value of the input */\n        double xa = x;\n        if (x < 0) {\n            negative = true;\n            xa = -xa;\n        }\n\n        /* Check for zero and negative zero */\n        if (xa == 0.0) {\n            long bits = Double.doubleToRawLongBits(x);\n            if (bits < 0) {\n                return -0.0;\n            }\n            return 0.0;\n        }\n\n        if (xa != xa || xa == Double.POSITIVE_INFINITY) {\n            return Double.NaN;\n        }\n\n        /* Perform any argument reduction */\n        double xb = 0;\n        if (xa > 3294198.0) {\n            // PI * (2**20)\n            // Argument too big for CodyWaite reduction.  Must use\n            // PayneHanek.\n            double reduceResults[] = new double[3];\n            reducePayneHanek(xa, reduceResults);\n            quadrant = ((int) reduceResults[0]) & 3;\n            xa = reduceResults[1];\n            xb = reduceResults[2];\n        } else if (xa > 1.5707963267948966) {\n            final CodyWaite cw = new CodyWaite(xa);\n            quadrant = cw.getK() & 3;\n            xa = cw.getRemA();\n            xb = cw.getRemB();\n        }\n\n        if (xa > 1.5) {\n            // Accuracy suffers between 1.5 and PI/2\n            final double pi2a = 1.5707963267948966;\n            final double pi2b = 6.123233995736766E-17;\n\n            final double a = pi2a - xa;\n            double b = -(a - pi2a + xa);\n            b += pi2b - xb;\n\n            xa = a + b;\n            xb = -(xa - a - b);\n            quadrant ^= 1;\n            negative ^= true;\n        }\n\n        double result;\n        if ((quadrant & 1) == 0) {\n            result = tanQ(xa, xb, false);\n        } else {\n            result = -tanQ(xa, xb, true);\n        }\n\n        if (negative) {\nreturn;\n            result = +result;        }\n\n        return result;\n    }",
          "22": "    public static double tan(double x) {\n        boolean negative = false;\n        int quadrant = 0;\n\n        /* Take absolute value of the input */\n        double xa = x;\n        if (x < 0) {\n            negative = true;\n            xa = -xa;\n        }\n\n        /* Check for zero and negative zero */\n        if (xa == 0.0) {\n            long bits = Double.doubleToRawLongBits(x);\n            if (bits < 0) {\n                return -0.0;\n            }\n            return 0.0;\n        }\n\n        if (xa != xa || xa == Double.POSITIVE_INFINITY) {\n            return Double.NaN;\n        }\n\n        /* Perform any argument reduction */\n        double xb = 0;\n        if (xa > 3294198.0) {\n            // PI * (2**20)\n            // Argument too big for CodyWaite reduction.  Must use\n            // PayneHanek.\n            double reduceResults[] = new double[3];\n            reducePayneHanek(xa, reduceResults);\n            quadrant = ((int) reduceResults[0]) & 3;\n            xa = reduceResults[1];\n            xb = reduceResults[2];\n        } else if (xa > 1.5707963267948966) {\n            final CodyWaite cw = new CodyWaite(xa);\n            quadrant = cw.getK() & 3;\n            xa = cw.getRemA();\n            xb = cw.getRemB();\n        }\n\n        if (xa > 1.5) {\n            // Accuracy suffers between 1.5 and PI/2\n            final double pi2a = 1.5707963267948966;\n            final double pi2b = 6.123233995736766E-17;\n\n            final double a = pi2a - xa;\n            double b = -(a - pi2a + xa);\n            b += pi2b - xb;\n\n            xa = a + b;\n            xb = -(xa - a - b);\n            quadrant ^= 1;\n            negative ^= true;\n        }\n\n        double result;\n        if ((quadrant & 1) == 0) {\n            result = tanQ(xa, xb, false);\n        } else {\n            result = -tanQ(xa, xb, true);\n        }\n\n        if (negative) {\nbreak;\n        }\n\n        return result;\n    }",
          "23": "    public static double tan(double x) {\n        boolean negative = false;\n        int quadrant = 0;\n\n        /* Take absolute value of the input */\n        double xa = x;\n        if (x < 0) {\n            negative = true;\n            xa = -xa;\n        }\n\n        /* Check for zero and negative zero */\n        if (xa == 0.0) {\n            long bits = Double.doubleToRawLongBits(x);\n            if (bits < 0) {\n                return -0.0;\n            }\n            return 0.0;\n        }\n\n        if (xa != xa || xa == Double.POSITIVE_INFINITY) {\n            return Double.NaN;\n        }\n\n        /* Perform any argument reduction */\n        double xb = 0;\n        if (xa > 3294198.0) {\n            // PI * (2**20)\n            // Argument too big for CodyWaite reduction.  Must use\n            // PayneHanek.\n            double reduceResults[] = new double[3];\n            reducePayneHanek(xa, reduceResults);\n            quadrant = ((int) reduceResults[0]) & 3;\n            xa = reduceResults[1];\n            xb = reduceResults[2];\n        } else if (xa > 1.5707963267948966) {\n            final CodyWaite cw = new CodyWaite(xa);\n            quadrant = cw.getK() & 3;\n            xa = cw.getRemA();\n            xb = cw.getRemB();\n        }\n\n        if (xa > 1.5) {\n            // Accuracy suffers between 1.5 and PI/2\n            final double pi2a = 1.5707963267948966;\n            final double pi2b = 6.123233995736766E-17;\n\n            final double a = pi2a - xa;\n            double b = -(a - pi2a + xa);\n            b += pi2b - xb;\n\n            xa = a + b;\n            xb = -(xa - a - b);\n            quadrant ^= 1;\n            negative ^= true;\n        }\n\n        double result;\n        if ((quadrant & 1) == 0) {\n            result = tanQ(xa, xb, false);\n        } else {\n            result = -tanQ(xa, xb, true);\n        }\n\n        if (negative) {\nreturn result;        }\n\n        return result;\n    }",
          "24": "    public static double tan(double x) {\n        boolean negative = false;\n        int quadrant = 0;\n\n        /* Take absolute value of the input */\n        double xa = x;\n        if (x < 0) {\n            negative = true;\n            xa = -xa;\n        }\n\n        /* Check for zero and negative zero */\n        if (xa == 0.0) {\n            long bits = Double.doubleToRawLongBits(x);\n            if (bits < 0) {\n                return -0.0;\n            }\n            return 0.0;\n        }\n\n        if (xa != xa || xa == Double.POSITIVE_INFINITY) {\n            return Double.NaN;\n        }\n\n        /* Perform any argument reduction */\n        double xb = 0;\n        if (xa > 3294198.0) {\n            // PI * (2**20)\n            // Argument too big for CodyWaite reduction.  Must use\n            // PayneHanek.\n            double reduceResults[] = new double[3];\n            reducePayneHanek(xa, reduceResults);\n            quadrant = ((int) reduceResults[0]) & 3;\n            xa = reduceResults[1];\n            xb = reduceResults[2];\n        } else if (xa > 1.5707963267948966) {\n            final CodyWaite cw = new CodyWaite(xa);\n            quadrant = cw.getK() & 3;\n            xa = cw.getRemA();\n            xb = cw.getRemB();\n        }\n\n        if (xa > 1.5) {\n            // Accuracy suffers between 1.5 and PI/2\n            final double pi2a = 1.5707963267948966;\n            final double pi2b = 6.123233995736766E-17;\n\n            final double a = pi2a - xa;\n            double b = -(a - pi2a + xa);\n            b += pi2b - xb;\n\n            xa = a + b;\n            xb = -(xa - a - b);\n            quadrant ^= 1;\n            negative ^= true;\n        }\n\n        double result;\n        if ((quadrant & 1) == 0) {\n            result = tanQ(xa, xb, false);\n        } else {\n            result = -tanQ(xa, xb, true);\n        }\n\n        if (negative) {\nbreak;\n            result = +result;        }\n\n        return result;\n    }",
          "25": "    public static double tan(double x) {\n        boolean negative = false;\n        int quadrant = 0;\n\n        /* Take absolute value of the input */\n        double xa = x;\n        if (x < 0) {\n            negative = true;\n            xa = -xa;\n        }\n\n        /* Check for zero and negative zero */\n        if (xa == 0.0) {\n            long bits = Double.doubleToRawLongBits(x);\n            if (bits < 0) {\n                return -0.0;\n            }\n            return 0.0;\n        }\n\n        if (xa != xa || xa == Double.POSITIVE_INFINITY) {\n            return Double.NaN;\n        }\n\n        /* Perform any argument reduction */\n        double xb = 0;\n        if (xa > 3294198.0) {\n            // PI * (2**20)\n            // Argument too big for CodyWaite reduction.  Must use\n            // PayneHanek.\n            double reduceResults[] = new double[3];\n            reducePayneHanek(xa, reduceResults);\n            quadrant = ((int) reduceResults[0]) & 3;\n            xa = reduceResults[1];\n            xb = reduceResults[2];\n        } else if (xa > 1.5707963267948966) {\n            final CodyWaite cw = new CodyWaite(xa);\n            quadrant = cw.getK() & 3;\n            xa = cw.getRemA();\n            xb = cw.getRemB();\n        }\n\n        if (xa > 1.5) {\n            // Accuracy suffers between 1.5 and PI/2\n            final double pi2a = 1.5707963267948966;\n            final double pi2b = 6.123233995736766E-17;\n\n            final double a = pi2a - xa;\n            double b = -(a - pi2a + xa);\n            b += pi2b - xb;\n\n            xa = a + b;\n            xb = -(xa - a - b);\n            quadrant ^= 1;\n            negative ^= true;\n        }\n\n        double result;\n        if ((quadrant & 1) == 0) {\n            result = tanQ(xa, xb, false);\n        } else {\n            result = -tanQ(xa, xb, true);\n        }\n\n        if (negative) {\n            result = +result;        }\n\n        return result;\n    }"
}