{
          "0": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (-0.5 * doubleHighPart(+x));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "1": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (-0.5 * sqrt(+x));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "2": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (-0.5 * cosh(+x));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "3": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (-0.5 * sinh(+x));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "4": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (-0.5 * tanh(+x));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "5": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (-0.5 * acosh(+x));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "6": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (-0.5 * asinh(+x));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "7": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (-0.5 * atanh(+x));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "8": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (-0.5 * signum(+x));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "9": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (-0.5 * nextUp(+x));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "10": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (-0.5 * exp(+x));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "11": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (-0.5 * expm1(+x));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "12": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (-0.5 * log(+x));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "13": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (-0.5 * log1p(+x));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "14": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (-0.5 * log10(+x));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "15": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (-0.5 * polySine(+x));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "16": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (-0.5 * polyCosine(+x));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "17": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (-0.5 * sin(+x));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "18": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (-0.5 * cos(+x));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "19": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (-0.5 * tan(+x));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "20": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (-0.5 * atan(+x));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "21": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (-0.5 * asin(+x));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "22": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (-0.5 * acos(+x));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "23": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (-0.5 * cbrt(+x));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "24": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (-0.5 * toRadians(+x));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "25": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (-0.5 * toDegrees(+x));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "26": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (-0.5 * abs(+x));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "27": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (-0.5 * ulp(+x));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "28": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (-0.5 * floor(+x));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "29": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (-0.5 * ceil(+x));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "30": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (-0.5 * rint(+x));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "31": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn x;          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "32": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (1 * exp(+x));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "33": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (2 * exp(+x));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "34": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn ((-0.5 * t) * t);          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "35": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (-0.5 * t);          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "36": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (0 * exp(+x));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "37": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn x;              return -0.5 * exp(+x);          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "38": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (-1 * exp(+x));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "39": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn ((0.5 * t) * t);          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "40": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn exp(+x);          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "41": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (0.5 * x);          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "42": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (0.5 * exp(x));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "43": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (-0.5 * x);          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "44": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (0.5 * t);          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "45": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\n          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "46": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (x != x);          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "47": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (-0.5 * exp(t));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "48": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (exp(+x) * exp(+x));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "49": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (-0.5 * debug(+x));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "50": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn ((-0.5 * t) * t);              return -0.5 * exp(+x);          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "51": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (-0.5 * exp(x));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "52": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn t;          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "53": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (-0.5 + exp(+x));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "54": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (x * exp(+x));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "55": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (-0.5 - exp(+x));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "56": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (exp(+x) / exp(+x));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "57": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (-2 * exp(+x));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "58": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (exp(+x) + exp(+x));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "59": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (0.5 * exp(+x));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "60": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (-0.5 / exp(+x));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "61": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (-20 * exp(+x));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "62": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (-0.5 * exp());          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "63": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn ((0.5 * t) * t);              return -0.5 * exp(+x);          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "64": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (0.5 * exp(x));              return -0.5 * exp(+x);          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "65": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (-0.5 | exp(+x));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "66": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nbreak;\n              return -0.5 * exp(+x);          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "67": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (exp(x) * exp(+x));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "68": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (exp(+x) * x);          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "69": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (-0.5 * exp(PI));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "70": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (-0.5 * exp(E));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "71": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (-0.5 * exp(LOG_MAX_VALUE));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "72": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (-0.5 * exp(LN_2_A));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "73": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (-0.5 * exp(LN_2_B));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "74": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (-0.5 * exp(LN_QUICK_COEF));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "75": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (-0.5 * exp(LN_HI_PREC_COEF));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "76": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (-0.5 * exp(SINE_TABLE_A));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "77": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (-0.5 * exp(SINE_TABLE_B));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "78": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (-0.5 * exp(COSINE_TABLE_A));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "79": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (-0.5 * exp(COSINE_TABLE_B));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "80": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (-0.5 * exp(TANGENT_TABLE_A));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "81": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (-0.5 * exp(TANGENT_TABLE_B));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "82": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (-0.5 * exp(EIGHTHS));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "83": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (-0.5 * exp(CBRTTWO));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "84": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (-0.5 * exp(TWO_POWER_52));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "85": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (-0.5 * exp(TWO_POWER_53));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "86": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (-0.5 * exp(F_1_3));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "87": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (-0.5 * exp(F_1_5));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "88": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (-0.5 * exp(F_1_7));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "89": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (-0.5 * exp(F_1_9));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "90": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (-0.5 * exp(F_1_11));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "91": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (-0.5 * exp(F_1_13));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "92": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (-0.5 * exp(F_1_15));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "93": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (-0.5 * exp(F_1_17));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "94": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (-0.5 * exp(F_3_4));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "95": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (-0.5 * exp(F_15_16));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "96": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (-0.5 * exp(F_13_14));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "97": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (-0.5 * exp(F_11_12));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "98": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (-0.5 * exp(F_9_10));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "99": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (-0.5 * exp(F_7_8));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "100": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (-0.5 * exp(F_5_6));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "101": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (-0.5 * exp(F_1_2));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "102": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (-0.5 * exp(F_1_4));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "103": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (-0.5 * exp(EXP_INT_TABLE_A));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "104": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (-0.5 * exp(EXP_INT_TABLE_B));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "105": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (-0.5 * exp(EXP_FRAC_TABLE_A));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "106": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (-0.5 * exp(EXP_FRAC_TABLE_B));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "107": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (-0.5 * exp(LN_MANT));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "108": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (-0.5 * exp(finalRemA));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "109": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (-0.5 * exp(finalRemB));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "110": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (-0.5 & exp(+x));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "111": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (exp(+x) - exp(+x));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "112": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (exp(PI) * exp(+x));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "113": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (exp(E) * exp(+x));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "114": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (exp(LOG_MAX_VALUE) * exp(+x));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "115": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (exp(LN_2_A) * exp(+x));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "116": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (exp(LN_2_B) * exp(+x));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "117": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (exp(LN_QUICK_COEF) * exp(+x));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "118": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (exp(LN_HI_PREC_COEF) * exp(+x));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "119": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (exp(SINE_TABLE_A) * exp(+x));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "120": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (exp(SINE_TABLE_B) * exp(+x));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "121": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (exp(COSINE_TABLE_A) * exp(+x));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "122": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (exp(COSINE_TABLE_B) * exp(+x));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "123": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (exp(TANGENT_TABLE_A) * exp(+x));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "124": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (exp(TANGENT_TABLE_B) * exp(+x));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "125": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (exp(EIGHTHS) * exp(+x));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "126": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (exp(CBRTTWO) * exp(+x));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "127": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (exp(TWO_POWER_52) * exp(+x));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "128": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (exp(TWO_POWER_53) * exp(+x));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "129": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (exp(F_1_3) * exp(+x));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "130": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (exp(F_1_5) * exp(+x));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "131": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (exp(F_1_7) * exp(+x));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "132": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (exp(F_1_9) * exp(+x));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "133": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (exp(F_1_11) * exp(+x));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "134": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (exp(F_1_13) * exp(+x));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "135": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (exp(F_1_15) * exp(+x));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "136": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (exp(F_1_17) * exp(+x));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "137": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (exp(F_3_4) * exp(+x));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "138": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (exp(F_15_16) * exp(+x));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "139": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (exp(F_13_14) * exp(+x));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "140": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (exp(F_11_12) * exp(+x));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "141": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (exp(F_9_10) * exp(+x));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "142": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (exp(F_7_8) * exp(+x));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "143": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (exp(F_5_6) * exp(+x));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "144": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (exp(F_1_2) * exp(+x));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "145": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (exp(F_1_4) * exp(+x));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "146": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (exp(EXP_INT_TABLE_A) * exp(+x));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "147": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (exp(EXP_INT_TABLE_B) * exp(+x));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "148": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (exp(EXP_FRAC_TABLE_A) * exp(+x));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "149": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (exp(EXP_FRAC_TABLE_B) * exp(+x));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "150": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (exp(LN_MANT) * exp(+x));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "151": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (exp(finalRemA) * exp(+x));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "152": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (exp(finalRemB) * exp(+x));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "153": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (exp(t) * exp(+x));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "154": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (exp(x, x) * exp(+x));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "155": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn ((x * x) * exp(+x));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "156": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (exp(+x) * exp(PI));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "157": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (exp(+x) * exp(E));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "158": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (exp(+x) * exp(LOG_MAX_VALUE));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "159": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (exp(+x) * exp(LN_2_A));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "160": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (exp(+x) * exp(LN_2_B));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "161": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (exp(+x) * exp(LN_QUICK_COEF));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "162": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (exp(+x) * exp(LN_HI_PREC_COEF));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "163": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (exp(+x) * exp(SINE_TABLE_A));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "164": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (exp(+x) * exp(SINE_TABLE_B));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "165": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (exp(+x) * exp(COSINE_TABLE_A));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "166": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (exp(+x) * exp(COSINE_TABLE_B));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "167": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (exp(+x) * exp(TANGENT_TABLE_A));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "168": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (exp(+x) * exp(TANGENT_TABLE_B));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "169": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (exp(+x) * exp(EIGHTHS));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "170": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (exp(+x) * exp(CBRTTWO));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "171": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (exp(+x) * exp(TWO_POWER_52));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "172": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (exp(+x) * exp(TWO_POWER_53));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "173": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (exp(+x) * exp(F_1_3));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "174": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (exp(+x) * exp(F_1_5));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "175": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (exp(+x) * exp(F_1_7));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "176": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (exp(+x) * exp(F_1_9));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "177": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (exp(+x) * exp(F_1_11));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "178": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (exp(+x) * exp(F_1_13));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "179": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (exp(+x) * exp(F_1_15));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "180": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (exp(+x) * exp(F_1_17));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "181": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (exp(+x) * exp(F_3_4));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "182": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (exp(+x) * exp(F_15_16));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "183": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (exp(+x) * exp(F_13_14));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "184": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (exp(+x) * exp(F_11_12));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "185": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (exp(+x) * exp(F_9_10));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "186": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (exp(+x) * exp(F_7_8));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "187": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (exp(+x) * exp(F_5_6));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "188": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (exp(+x) * exp(F_1_2));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "189": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (exp(+x) * exp(F_1_4));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "190": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (exp(+x) * exp(EXP_INT_TABLE_A));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "191": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (exp(+x) * exp(EXP_INT_TABLE_B));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "192": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (exp(+x) * exp(EXP_FRAC_TABLE_A));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "193": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (exp(+x) * exp(EXP_FRAC_TABLE_B));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "194": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (exp(+x) * exp(LN_MANT));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "195": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (exp(+x) * exp(finalRemA));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "196": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (exp(+x) * exp(finalRemB));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "197": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (exp(x, 0) * exp(+x));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "198": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn;\n              return -0.5 * exp(+x);          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "199": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\ncontinue;\n              return -0.5 * exp(+x);          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "200": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (-0.5 * exp(x, x));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "201": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (exp(+x) * exp(x));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "202": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn ((exp(+x) * x) * exp(+x));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "203": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (exp(x) * exp(PI));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "204": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (exp(x) * exp(E));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "205": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (exp(x) * exp(LOG_MAX_VALUE));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "206": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (exp(x) * exp(LN_2_A));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "207": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (exp(x) * exp(LN_2_B));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "208": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (exp(x) * exp(LN_QUICK_COEF));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "209": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (exp(x) * exp(LN_HI_PREC_COEF));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "210": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (exp(x) * exp(SINE_TABLE_A));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "211": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (exp(x) * exp(SINE_TABLE_B));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "212": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (exp(x) * exp(COSINE_TABLE_A));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "213": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (exp(x) * exp(COSINE_TABLE_B));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "214": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (exp(x) * exp(TANGENT_TABLE_A));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "215": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (exp(x) * exp(TANGENT_TABLE_B));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "216": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (exp(x) * exp(EIGHTHS));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "217": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (exp(x) * exp(CBRTTWO));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "218": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (exp(x) * exp(TWO_POWER_52));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "219": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (exp(x) * exp(TWO_POWER_53));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "220": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (exp(x) * exp(F_1_3));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "221": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (exp(x) * exp(F_1_5));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "222": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (exp(x) * exp(F_1_7));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "223": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (exp(x) * exp(F_1_9));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "224": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (exp(x) * exp(F_1_11));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "225": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (exp(x) * exp(F_1_13));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "226": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (exp(x) * exp(F_1_15));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "227": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (exp(x) * exp(F_1_17));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "228": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (exp(x) * exp(F_3_4));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "229": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (exp(x) * exp(F_15_16));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "230": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (exp(x) * exp(F_13_14));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "231": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (exp(x) * exp(F_11_12));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "232": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (exp(x) * exp(F_9_10));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "233": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (exp(x) * exp(F_7_8));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "234": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (exp(x) * exp(F_5_6));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "235": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (exp(x) * exp(F_1_2));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "236": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (exp(x) * exp(F_1_4));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "237": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (exp(x) * exp(EXP_INT_TABLE_A));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "238": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (exp(x) * exp(EXP_INT_TABLE_B));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "239": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (exp(x) * exp(EXP_FRAC_TABLE_A));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "240": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (exp(x) * exp(EXP_FRAC_TABLE_B));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "241": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (exp(x) * exp(LN_MANT));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "242": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (exp(x) * exp(finalRemA));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "243": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (exp(x) * exp(finalRemB));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "244": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (-0.5 * (exp(x) * x));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "245": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (exp(x, x) * exp(PI));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "246": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (exp(x, x) * exp(E));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "247": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (exp(x, x) * exp(LOG_MAX_VALUE));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "248": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (exp(x, x) * exp(LN_2_A));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "249": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (exp(x, x) * exp(LN_2_B));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "250": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (exp(x, x) * exp(LN_QUICK_COEF));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "251": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (exp(x, x) * exp(LN_HI_PREC_COEF));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "252": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (exp(x, x) * exp(SINE_TABLE_A));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "253": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (exp(x, x) * exp(SINE_TABLE_B));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "254": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (exp(x, x) * exp(COSINE_TABLE_A));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "255": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (exp(x, x) * exp(COSINE_TABLE_B));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "256": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (exp(x, x) * exp(TANGENT_TABLE_A));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "257": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (exp(x, x) * exp(TANGENT_TABLE_B));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "258": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (exp(x, x) * exp(EIGHTHS));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "259": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (exp(x, x) * exp(CBRTTWO));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "260": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (exp(x, x) * exp(TWO_POWER_52));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "261": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (exp(x, x) * exp(TWO_POWER_53));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "262": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (exp(x, x) * exp(F_1_3));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "263": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (exp(x, x) * exp(F_1_5));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "264": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (exp(x, x) * exp(F_1_7));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "265": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (exp(x, x) * exp(F_1_9));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "266": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (exp(x, x) * exp(F_1_11));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "267": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (exp(x, x) * exp(F_1_13));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "268": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (exp(x, x) * exp(F_1_15));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "269": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (exp(x, x) * exp(F_1_17));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "270": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (exp(x, x) * exp(F_3_4));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "271": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (exp(x, x) * exp(F_15_16));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "272": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (exp(x, x) * exp(F_13_14));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "273": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (exp(x, x) * exp(F_11_12));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "274": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (exp(x, x) * exp(F_9_10));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "275": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (exp(x, x) * exp(F_7_8));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "276": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (exp(x, x) * exp(F_5_6));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "277": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (exp(x, x) * exp(F_1_2));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "278": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (exp(x, x) * exp(F_1_4));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "279": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (exp(x, x) * exp(EXP_INT_TABLE_A));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "280": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (exp(x, x) * exp(EXP_INT_TABLE_B));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "281": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (exp(x, x) * exp(EXP_FRAC_TABLE_A));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "282": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (exp(x, x) * exp(EXP_FRAC_TABLE_B));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "283": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (exp(x, x) * exp(LN_MANT));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "284": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (exp(x, x) * exp(finalRemA));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "285": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\nreturn (exp(x, x) * exp(finalRemB));          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }"
}