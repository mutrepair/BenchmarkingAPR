{
          "0": "  public double[] getAngles(RotationOrder order)\n    throws CardanEulerSingularityException {\n\n    if (order == RotationOrder.XYZ) {\n\n      // r (Vector3D.plusK) coordinates are :\n      //  sin (theta), -cos (theta) sin (phi), cos (theta) cos (phi)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (psi) cos (theta), -sin (psi) cos (theta), sin (theta)\n      // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if  ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(-(v1.getY()), v1.getZ()),\n        FastMath.asin(v2.getZ()),\n        FastMath.atan2(-(v2.getY()), v2.getX())\n      };\n\n    } else if (order == RotationOrder.XZY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      // -sin (psi), cos (psi) cos (phi), cos (psi) sin (phi)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (theta) cos (psi), -sin (psi), sin (theta) cos (psi)\n      // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getZ(), v1.getY()),\n       -FastMath.asin(v2.getY()),\n        FastMath.atan2(v2.getZ(), v2.getX())\n      };\n\n    } else if (order == RotationOrder.YXZ) {\n\n      // r (Vector3D.plusK) coordinates are :\n      //  cos (phi) sin (theta), -sin (phi), cos (phi) cos (theta)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (psi) cos (phi), cos (psi) cos (phi), -sin (phi)\n      // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getX(), v1.getZ()),\n       -FastMath.asin(v2.getZ()),\n        FastMath.atan2(v2.getX(), v2.getY())\n      };\n\n    } else if (order == RotationOrder.YZX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      // cos (psi) cos (theta), sin (psi), -cos (psi) sin (theta)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (psi), cos (phi) cos (psi), -sin (phi) cos (psi)\n      // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(-(v1.getZ()), v1.getX()),\n        FastMath.asin(v2.getX()),\n        FastMath.atan2(-(v2.getZ()), v2.getY())\n      };\n\n    } else if (order == RotationOrder.ZXY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      // -cos (phi) sin (psi), cos (phi) cos (psi), sin (phi)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // -sin (theta) cos (phi), sin (phi), cos (theta) cos (phi)\n      // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(-(v1.getX()), v1.getY()),\n        FastMath.asin(v2.getY()),\n        FastMath.atan2(-(v2.getX()), v2.getZ())\n      };\n\n    } else if (order == RotationOrder.ZYX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      //  cos (theta) cos (psi), cos (theta) sin (psi), -sin (theta)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // -sin (theta), sin (phi) cos (theta), cos (phi) cos (theta)\n      // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\nreturn null;      };\n\n    } else if (order == RotationOrder.XYX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      //  cos (theta), sin (phi1) sin (theta), -cos (phi1) sin (theta)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (theta), sin (theta) sin (phi2), sin (theta) cos (phi2)\n      // and we can choose to have theta in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getY(), -v1.getZ()),\n        FastMath.acos(v2.getX()),\n        FastMath.atan2(v2.getY(), v2.getZ())\n      };\n\n    } else if (order == RotationOrder.XZX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      //  cos (psi), cos (phi1) sin (psi), sin (phi1) sin (psi)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (psi), -sin (psi) cos (phi2), sin (psi) sin (phi2)\n      // and we can choose to have psi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getZ(), v1.getY()),\n        FastMath.acos(v2.getX()),\n        FastMath.atan2(v2.getZ(), -v2.getY())\n      };\n\n    } else if (order == RotationOrder.YXY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      //  sin (theta1) sin (phi), cos (phi), cos (theta1) sin (phi)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (phi) sin (theta2), cos (phi), -sin (phi) cos (theta2)\n      // and we can choose to have phi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getX(), v1.getZ()),\n        FastMath.acos(v2.getY()),\n        FastMath.atan2(v2.getX(), -v2.getZ())\n      };\n\n    } else if (order == RotationOrder.YZY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      //  -cos (theta1) sin (psi), cos (psi), sin (theta1) sin (psi)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (psi) cos (theta2), cos (psi), sin (psi) sin (theta2)\n      // and we can choose to have psi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getZ(), -v1.getX()),\n        FastMath.acos(v2.getY()),\n        FastMath.atan2(v2.getZ(), v2.getX())\n      };\n\n    } else if (order == RotationOrder.ZXZ) {\n\n      // r (Vector3D.plusK) coordinates are :\n      //  sin (psi1) sin (phi), -cos (psi1) sin (phi), cos (phi)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // sin (phi) sin (psi2), sin (phi) cos (psi2), cos (phi)\n      // and we can choose to have phi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getX(), -v1.getY()),\n        FastMath.acos(v2.getZ()),\n        FastMath.atan2(v2.getX(), v2.getY())\n      };\n\n    } else { // last possibility is ZYZ\n\n      // r (Vector3D.plusK) coordinates are :\n      //  cos (psi1) sin (theta), sin (psi1) sin (theta), cos (theta)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // -sin (theta) cos (psi2), sin (theta) sin (psi2), cos (theta)\n      // and we can choose to have theta in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getY(), v1.getX()),\n        FastMath.acos(v2.getZ()),\n        FastMath.atan2(v2.getY(), -v2.getX())\n      };\n\n    }\n\n  }",
          "1": "  public double[] getAngles(RotationOrder order)\n    throws CardanEulerSingularityException {\n\n    if (order == RotationOrder.XYZ) {\n\n      // r (Vector3D.plusK) coordinates are :\n      //  sin (theta), -cos (theta) sin (phi), cos (theta) cos (phi)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (psi) cos (theta), -sin (psi) cos (theta), sin (theta)\n      // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if  ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(-(v1.getY()), v1.getZ()),\n        FastMath.asin(v2.getZ()),\n        FastMath.atan2(-(v2.getY()), v2.getX())\n      };\n\n    } else if (order == RotationOrder.XZY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      // -sin (psi), cos (psi) cos (phi), cos (psi) sin (phi)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (theta) cos (psi), -sin (psi), sin (theta) cos (psi)\n      // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getZ(), v1.getY()),\n       -FastMath.asin(v2.getY()),\n        FastMath.atan2(v2.getZ(), v2.getX())\n      };\n\n    } else if (order == RotationOrder.YXZ) {\n\n      // r (Vector3D.plusK) coordinates are :\n      //  cos (phi) sin (theta), -sin (phi), cos (phi) cos (theta)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (psi) cos (phi), cos (psi) cos (phi), -sin (phi)\n      // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getX(), v1.getZ()),\n       -FastMath.asin(v2.getZ()),\n        FastMath.atan2(v2.getX(), v2.getY())\n      };\n\n    } else if (order == RotationOrder.YZX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      // cos (psi) cos (theta), sin (psi), -cos (psi) sin (theta)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (psi), cos (phi) cos (psi), -sin (phi) cos (psi)\n      // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(-(v1.getZ()), v1.getX()),\n        FastMath.asin(v2.getX()),\n        FastMath.atan2(-(v2.getZ()), v2.getY())\n      };\n\n    } else if (order == RotationOrder.ZXY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      // -cos (phi) sin (psi), cos (phi) cos (psi), sin (phi)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // -sin (theta) cos (phi), sin (phi), cos (theta) cos (phi)\n      // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(-(v1.getX()), v1.getY()),\n        FastMath.asin(v2.getY()),\n        FastMath.atan2(-(v2.getX()), v2.getZ())\n      };\n\n    } else if (order == RotationOrder.ZYX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      //  cos (theta) cos (psi), cos (theta) sin (psi), -sin (theta)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // -sin (theta), sin (phi) cos (theta), cos (phi) cos (theta)\n      // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\nreturn true;      };\n\n    } else if (order == RotationOrder.XYX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      //  cos (theta), sin (phi1) sin (theta), -cos (phi1) sin (theta)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (theta), sin (theta) sin (phi2), sin (theta) cos (phi2)\n      // and we can choose to have theta in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getY(), -v1.getZ()),\n        FastMath.acos(v2.getX()),\n        FastMath.atan2(v2.getY(), v2.getZ())\n      };\n\n    } else if (order == RotationOrder.XZX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      //  cos (psi), cos (phi1) sin (psi), sin (phi1) sin (psi)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (psi), -sin (psi) cos (phi2), sin (psi) sin (phi2)\n      // and we can choose to have psi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getZ(), v1.getY()),\n        FastMath.acos(v2.getX()),\n        FastMath.atan2(v2.getZ(), -v2.getY())\n      };\n\n    } else if (order == RotationOrder.YXY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      //  sin (theta1) sin (phi), cos (phi), cos (theta1) sin (phi)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (phi) sin (theta2), cos (phi), -sin (phi) cos (theta2)\n      // and we can choose to have phi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getX(), v1.getZ()),\n        FastMath.acos(v2.getY()),\n        FastMath.atan2(v2.getX(), -v2.getZ())\n      };\n\n    } else if (order == RotationOrder.YZY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      //  -cos (theta1) sin (psi), cos (psi), sin (theta1) sin (psi)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (psi) cos (theta2), cos (psi), sin (psi) sin (theta2)\n      // and we can choose to have psi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getZ(), -v1.getX()),\n        FastMath.acos(v2.getY()),\n        FastMath.atan2(v2.getZ(), v2.getX())\n      };\n\n    } else if (order == RotationOrder.ZXZ) {\n\n      // r (Vector3D.plusK) coordinates are :\n      //  sin (psi1) sin (phi), -cos (psi1) sin (phi), cos (phi)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // sin (phi) sin (psi2), sin (phi) cos (psi2), cos (phi)\n      // and we can choose to have phi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getX(), -v1.getY()),\n        FastMath.acos(v2.getZ()),\n        FastMath.atan2(v2.getX(), v2.getY())\n      };\n\n    } else { // last possibility is ZYZ\n\n      // r (Vector3D.plusK) coordinates are :\n      //  cos (psi1) sin (theta), sin (psi1) sin (theta), cos (theta)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // -sin (theta) cos (psi2), sin (theta) sin (psi2), cos (theta)\n      // and we can choose to have theta in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getY(), v1.getX()),\n        FastMath.acos(v2.getZ()),\n        FastMath.atan2(v2.getY(), -v2.getX())\n      };\n\n    }\n\n  }",
          "2": "  public double[] getAngles(RotationOrder order)\n    throws CardanEulerSingularityException {\n\n    if (order == RotationOrder.XYZ) {\n\n      // r (Vector3D.plusK) coordinates are :\n      //  sin (theta), -cos (theta) sin (phi), cos (theta) cos (phi)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (psi) cos (theta), -sin (psi) cos (theta), sin (theta)\n      // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if  ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(-(v1.getY()), v1.getZ()),\n        FastMath.asin(v2.getZ()),\n        FastMath.atan2(-(v2.getY()), v2.getX())\n      };\n\n    } else if (order == RotationOrder.XZY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      // -sin (psi), cos (psi) cos (phi), cos (psi) sin (phi)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (theta) cos (psi), -sin (psi), sin (theta) cos (psi)\n      // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getZ(), v1.getY()),\n       -FastMath.asin(v2.getY()),\n        FastMath.atan2(v2.getZ(), v2.getX())\n      };\n\n    } else if (order == RotationOrder.YXZ) {\n\n      // r (Vector3D.plusK) coordinates are :\n      //  cos (phi) sin (theta), -sin (phi), cos (phi) cos (theta)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (psi) cos (phi), cos (psi) cos (phi), -sin (phi)\n      // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getX(), v1.getZ()),\n       -FastMath.asin(v2.getZ()),\n        FastMath.atan2(v2.getX(), v2.getY())\n      };\n\n    } else if (order == RotationOrder.YZX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      // cos (psi) cos (theta), sin (psi), -cos (psi) sin (theta)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (psi), cos (phi) cos (psi), -sin (phi) cos (psi)\n      // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(-(v1.getZ()), v1.getX()),\n        FastMath.asin(v2.getX()),\n        FastMath.atan2(-(v2.getZ()), v2.getY())\n      };\n\n    } else if (order == RotationOrder.ZXY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      // -cos (phi) sin (psi), cos (phi) cos (psi), sin (phi)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // -sin (theta) cos (phi), sin (phi), cos (theta) cos (phi)\n      // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(-(v1.getX()), v1.getY()),\n        FastMath.asin(v2.getY()),\n        FastMath.atan2(-(v2.getX()), v2.getZ())\n      };\n\n    } else if (order == RotationOrder.ZYX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      //  cos (theta) cos (psi), cos (theta) sin (psi), -sin (theta)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // -sin (theta), sin (phi) cos (theta), cos (phi) cos (theta)\n      // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\nreturn \"null\";      };\n\n    } else if (order == RotationOrder.XYX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      //  cos (theta), sin (phi1) sin (theta), -cos (phi1) sin (theta)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (theta), sin (theta) sin (phi2), sin (theta) cos (phi2)\n      // and we can choose to have theta in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getY(), -v1.getZ()),\n        FastMath.acos(v2.getX()),\n        FastMath.atan2(v2.getY(), v2.getZ())\n      };\n\n    } else if (order == RotationOrder.XZX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      //  cos (psi), cos (phi1) sin (psi), sin (phi1) sin (psi)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (psi), -sin (psi) cos (phi2), sin (psi) sin (phi2)\n      // and we can choose to have psi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getZ(), v1.getY()),\n        FastMath.acos(v2.getX()),\n        FastMath.atan2(v2.getZ(), -v2.getY())\n      };\n\n    } else if (order == RotationOrder.YXY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      //  sin (theta1) sin (phi), cos (phi), cos (theta1) sin (phi)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (phi) sin (theta2), cos (phi), -sin (phi) cos (theta2)\n      // and we can choose to have phi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getX(), v1.getZ()),\n        FastMath.acos(v2.getY()),\n        FastMath.atan2(v2.getX(), -v2.getZ())\n      };\n\n    } else if (order == RotationOrder.YZY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      //  -cos (theta1) sin (psi), cos (psi), sin (theta1) sin (psi)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (psi) cos (theta2), cos (psi), sin (psi) sin (theta2)\n      // and we can choose to have psi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getZ(), -v1.getX()),\n        FastMath.acos(v2.getY()),\n        FastMath.atan2(v2.getZ(), v2.getX())\n      };\n\n    } else if (order == RotationOrder.ZXZ) {\n\n      // r (Vector3D.plusK) coordinates are :\n      //  sin (psi1) sin (phi), -cos (psi1) sin (phi), cos (phi)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // sin (phi) sin (psi2), sin (phi) cos (psi2), cos (phi)\n      // and we can choose to have phi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getX(), -v1.getY()),\n        FastMath.acos(v2.getZ()),\n        FastMath.atan2(v2.getX(), v2.getY())\n      };\n\n    } else { // last possibility is ZYZ\n\n      // r (Vector3D.plusK) coordinates are :\n      //  cos (psi1) sin (theta), sin (psi1) sin (theta), cos (theta)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // -sin (theta) cos (psi2), sin (theta) sin (psi2), cos (theta)\n      // and we can choose to have theta in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getY(), v1.getX()),\n        FastMath.acos(v2.getZ()),\n        FastMath.atan2(v2.getY(), -v2.getX())\n      };\n\n    }\n\n  }",
          "3": "  public double[] getAngles(RotationOrder order)\n    throws CardanEulerSingularityException {\n\n    if (order == RotationOrder.XYZ) {\n\n      // r (Vector3D.plusK) coordinates are :\n      //  sin (theta), -cos (theta) sin (phi), cos (theta) cos (phi)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (psi) cos (theta), -sin (psi) cos (theta), sin (theta)\n      // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if  ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(-(v1.getY()), v1.getZ()),\n        FastMath.asin(v2.getZ()),\n        FastMath.atan2(-(v2.getY()), v2.getX())\n      };\n\n    } else if (order == RotationOrder.XZY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      // -sin (psi), cos (psi) cos (phi), cos (psi) sin (phi)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (theta) cos (psi), -sin (psi), sin (theta) cos (psi)\n      // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getZ(), v1.getY()),\n       -FastMath.asin(v2.getY()),\n        FastMath.atan2(v2.getZ(), v2.getX())\n      };\n\n    } else if (order == RotationOrder.YXZ) {\n\n      // r (Vector3D.plusK) coordinates are :\n      //  cos (phi) sin (theta), -sin (phi), cos (phi) cos (theta)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (psi) cos (phi), cos (psi) cos (phi), -sin (phi)\n      // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getX(), v1.getZ()),\n       -FastMath.asin(v2.getZ()),\n        FastMath.atan2(v2.getX(), v2.getY())\n      };\n\n    } else if (order == RotationOrder.YZX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      // cos (psi) cos (theta), sin (psi), -cos (psi) sin (theta)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (psi), cos (phi) cos (psi), -sin (phi) cos (psi)\n      // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(-(v1.getZ()), v1.getX()),\n        FastMath.asin(v2.getX()),\n        FastMath.atan2(-(v2.getZ()), v2.getY())\n      };\n\n    } else if (order == RotationOrder.ZXY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      // -cos (phi) sin (psi), cos (phi) cos (psi), sin (phi)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // -sin (theta) cos (phi), sin (phi), cos (theta) cos (phi)\n      // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(-(v1.getX()), v1.getY()),\n        FastMath.asin(v2.getY()),\n        FastMath.atan2(-(v2.getX()), v2.getZ())\n      };\n\n    } else if (order == RotationOrder.ZYX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      //  cos (theta) cos (psi), cos (theta) sin (psi), -sin (theta)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // -sin (theta), sin (phi) cos (theta), cos (phi) cos (theta)\n      // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\nreturn new double[[]]{FastMath.atan2(v1.getY(), v1.getX()),+FastMath.asin(v2.getX()),FastMath.atan2(v2.getY(), v2.getName())};      };\n\n    } else if (order == RotationOrder.XYX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      //  cos (theta), sin (phi1) sin (theta), -cos (phi1) sin (theta)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (theta), sin (theta) sin (phi2), sin (theta) cos (phi2)\n      // and we can choose to have theta in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getY(), -v1.getZ()),\n        FastMath.acos(v2.getX()),\n        FastMath.atan2(v2.getY(), v2.getZ())\n      };\n\n    } else if (order == RotationOrder.XZX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      //  cos (psi), cos (phi1) sin (psi), sin (phi1) sin (psi)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (psi), -sin (psi) cos (phi2), sin (psi) sin (phi2)\n      // and we can choose to have psi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getZ(), v1.getY()),\n        FastMath.acos(v2.getX()),\n        FastMath.atan2(v2.getZ(), -v2.getY())\n      };\n\n    } else if (order == RotationOrder.YXY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      //  sin (theta1) sin (phi), cos (phi), cos (theta1) sin (phi)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (phi) sin (theta2), cos (phi), -sin (phi) cos (theta2)\n      // and we can choose to have phi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getX(), v1.getZ()),\n        FastMath.acos(v2.getY()),\n        FastMath.atan2(v2.getX(), -v2.getZ())\n      };\n\n    } else if (order == RotationOrder.YZY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      //  -cos (theta1) sin (psi), cos (psi), sin (theta1) sin (psi)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (psi) cos (theta2), cos (psi), sin (psi) sin (theta2)\n      // and we can choose to have psi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getZ(), -v1.getX()),\n        FastMath.acos(v2.getY()),\n        FastMath.atan2(v2.getZ(), v2.getX())\n      };\n\n    } else if (order == RotationOrder.ZXZ) {\n\n      // r (Vector3D.plusK) coordinates are :\n      //  sin (psi1) sin (phi), -cos (psi1) sin (phi), cos (phi)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // sin (phi) sin (psi2), sin (phi) cos (psi2), cos (phi)\n      // and we can choose to have phi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getX(), -v1.getY()),\n        FastMath.acos(v2.getZ()),\n        FastMath.atan2(v2.getX(), v2.getY())\n      };\n\n    } else { // last possibility is ZYZ\n\n      // r (Vector3D.plusK) coordinates are :\n      //  cos (psi1) sin (theta), sin (psi1) sin (theta), cos (theta)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // -sin (theta) cos (psi2), sin (theta) sin (psi2), cos (theta)\n      // and we can choose to have theta in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getY(), v1.getX()),\n        FastMath.acos(v2.getZ()),\n        FastMath.atan2(v2.getY(), -v2.getX())\n      };\n\n    }\n\n  }",
          "4": "  public double[] getAngles(RotationOrder order)\n    throws CardanEulerSingularityException {\n\n    if (order == RotationOrder.XYZ) {\n\n      // r (Vector3D.plusK) coordinates are :\n      //  sin (theta), -cos (theta) sin (phi), cos (theta) cos (phi)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (psi) cos (theta), -sin (psi) cos (theta), sin (theta)\n      // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if  ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(-(v1.getY()), v1.getZ()),\n        FastMath.asin(v2.getZ()),\n        FastMath.atan2(-(v2.getY()), v2.getX())\n      };\n\n    } else if (order == RotationOrder.XZY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      // -sin (psi), cos (psi) cos (phi), cos (psi) sin (phi)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (theta) cos (psi), -sin (psi), sin (theta) cos (psi)\n      // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getZ(), v1.getY()),\n       -FastMath.asin(v2.getY()),\n        FastMath.atan2(v2.getZ(), v2.getX())\n      };\n\n    } else if (order == RotationOrder.YXZ) {\n\n      // r (Vector3D.plusK) coordinates are :\n      //  cos (phi) sin (theta), -sin (phi), cos (phi) cos (theta)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (psi) cos (phi), cos (psi) cos (phi), -sin (phi)\n      // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getX(), v1.getZ()),\n       -FastMath.asin(v2.getZ()),\n        FastMath.atan2(v2.getX(), v2.getY())\n      };\n\n    } else if (order == RotationOrder.YZX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      // cos (psi) cos (theta), sin (psi), -cos (psi) sin (theta)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (psi), cos (phi) cos (psi), -sin (phi) cos (psi)\n      // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(-(v1.getZ()), v1.getX()),\n        FastMath.asin(v2.getX()),\n        FastMath.atan2(-(v2.getZ()), v2.getY())\n      };\n\n    } else if (order == RotationOrder.ZXY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      // -cos (phi) sin (psi), cos (phi) cos (psi), sin (phi)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // -sin (theta) cos (phi), sin (phi), cos (theta) cos (phi)\n      // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(-(v1.getX()), v1.getY()),\n        FastMath.asin(v2.getY()),\n        FastMath.atan2(-(v2.getX()), v2.getZ())\n      };\n\n    } else if (order == RotationOrder.ZYX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      //  cos (theta) cos (psi), cos (theta) sin (psi), -sin (theta)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // -sin (theta), sin (phi) cos (theta), cos (phi) cos (theta)\n      // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\nreturn false;      };\n\n    } else if (order == RotationOrder.XYX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      //  cos (theta), sin (phi1) sin (theta), -cos (phi1) sin (theta)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (theta), sin (theta) sin (phi2), sin (theta) cos (phi2)\n      // and we can choose to have theta in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getY(), -v1.getZ()),\n        FastMath.acos(v2.getX()),\n        FastMath.atan2(v2.getY(), v2.getZ())\n      };\n\n    } else if (order == RotationOrder.XZX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      //  cos (psi), cos (phi1) sin (psi), sin (phi1) sin (psi)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (psi), -sin (psi) cos (phi2), sin (psi) sin (phi2)\n      // and we can choose to have psi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getZ(), v1.getY()),\n        FastMath.acos(v2.getX()),\n        FastMath.atan2(v2.getZ(), -v2.getY())\n      };\n\n    } else if (order == RotationOrder.YXY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      //  sin (theta1) sin (phi), cos (phi), cos (theta1) sin (phi)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (phi) sin (theta2), cos (phi), -sin (phi) cos (theta2)\n      // and we can choose to have phi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getX(), v1.getZ()),\n        FastMath.acos(v2.getY()),\n        FastMath.atan2(v2.getX(), -v2.getZ())\n      };\n\n    } else if (order == RotationOrder.YZY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      //  -cos (theta1) sin (psi), cos (psi), sin (theta1) sin (psi)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (psi) cos (theta2), cos (psi), sin (psi) sin (theta2)\n      // and we can choose to have psi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getZ(), -v1.getX()),\n        FastMath.acos(v2.getY()),\n        FastMath.atan2(v2.getZ(), v2.getX())\n      };\n\n    } else if (order == RotationOrder.ZXZ) {\n\n      // r (Vector3D.plusK) coordinates are :\n      //  sin (psi1) sin (phi), -cos (psi1) sin (phi), cos (phi)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // sin (phi) sin (psi2), sin (phi) cos (psi2), cos (phi)\n      // and we can choose to have phi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getX(), -v1.getY()),\n        FastMath.acos(v2.getZ()),\n        FastMath.atan2(v2.getX(), v2.getY())\n      };\n\n    } else { // last possibility is ZYZ\n\n      // r (Vector3D.plusK) coordinates are :\n      //  cos (psi1) sin (theta), sin (psi1) sin (theta), cos (theta)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // -sin (theta) cos (psi2), sin (theta) sin (psi2), cos (theta)\n      // and we can choose to have theta in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getY(), v1.getX()),\n        FastMath.acos(v2.getZ()),\n        FastMath.atan2(v2.getY(), -v2.getX())\n      };\n\n    }\n\n  }",
          "5": "  public double[] getAngles(RotationOrder order)\n    throws CardanEulerSingularityException {\n\n    if (order == RotationOrder.XYZ) {\n\n      // r (Vector3D.plusK) coordinates are :\n      //  sin (theta), -cos (theta) sin (phi), cos (theta) cos (phi)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (psi) cos (theta), -sin (psi) cos (theta), sin (theta)\n      // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if  ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(-(v1.getY()), v1.getZ()),\n        FastMath.asin(v2.getZ()),\n        FastMath.atan2(-(v2.getY()), v2.getX())\n      };\n\n    } else if (order == RotationOrder.XZY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      // -sin (psi), cos (psi) cos (phi), cos (psi) sin (phi)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (theta) cos (psi), -sin (psi), sin (theta) cos (psi)\n      // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getZ(), v1.getY()),\n       -FastMath.asin(v2.getY()),\n        FastMath.atan2(v2.getZ(), v2.getX())\n      };\n\n    } else if (order == RotationOrder.YXZ) {\n\n      // r (Vector3D.plusK) coordinates are :\n      //  cos (phi) sin (theta), -sin (phi), cos (phi) cos (theta)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (psi) cos (phi), cos (psi) cos (phi), -sin (phi)\n      // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getX(), v1.getZ()),\n       -FastMath.asin(v2.getZ()),\n        FastMath.atan2(v2.getX(), v2.getY())\n      };\n\n    } else if (order == RotationOrder.YZX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      // cos (psi) cos (theta), sin (psi), -cos (psi) sin (theta)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (psi), cos (phi) cos (psi), -sin (phi) cos (psi)\n      // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(-(v1.getZ()), v1.getX()),\n        FastMath.asin(v2.getX()),\n        FastMath.atan2(-(v2.getZ()), v2.getY())\n      };\n\n    } else if (order == RotationOrder.ZXY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      // -cos (phi) sin (psi), cos (phi) cos (psi), sin (phi)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // -sin (theta) cos (phi), sin (phi), cos (theta) cos (phi)\n      // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(-(v1.getX()), v1.getY()),\n        FastMath.asin(v2.getY()),\n        FastMath.atan2(-(v2.getX()), v2.getZ())\n      };\n\n    } else if (order == RotationOrder.ZYX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      //  cos (theta) cos (psi), cos (theta) sin (psi), -sin (theta)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // -sin (theta), sin (phi) cos (theta), cos (phi) cos (theta)\n      // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\nreturn new double[[]]{FastMath.atan2(v1.getY(), v1.getX()),+FastMath.asin(v2.getName()),FastMath.atan2(v2.getY(), v2.getZ())};      };\n\n    } else if (order == RotationOrder.XYX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      //  cos (theta), sin (phi1) sin (theta), -cos (phi1) sin (theta)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (theta), sin (theta) sin (phi2), sin (theta) cos (phi2)\n      // and we can choose to have theta in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getY(), -v1.getZ()),\n        FastMath.acos(v2.getX()),\n        FastMath.atan2(v2.getY(), v2.getZ())\n      };\n\n    } else if (order == RotationOrder.XZX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      //  cos (psi), cos (phi1) sin (psi), sin (phi1) sin (psi)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (psi), -sin (psi) cos (phi2), sin (psi) sin (phi2)\n      // and we can choose to have psi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getZ(), v1.getY()),\n        FastMath.acos(v2.getX()),\n        FastMath.atan2(v2.getZ(), -v2.getY())\n      };\n\n    } else if (order == RotationOrder.YXY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      //  sin (theta1) sin (phi), cos (phi), cos (theta1) sin (phi)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (phi) sin (theta2), cos (phi), -sin (phi) cos (theta2)\n      // and we can choose to have phi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getX(), v1.getZ()),\n        FastMath.acos(v2.getY()),\n        FastMath.atan2(v2.getX(), -v2.getZ())\n      };\n\n    } else if (order == RotationOrder.YZY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      //  -cos (theta1) sin (psi), cos (psi), sin (theta1) sin (psi)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (psi) cos (theta2), cos (psi), sin (psi) sin (theta2)\n      // and we can choose to have psi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getZ(), -v1.getX()),\n        FastMath.acos(v2.getY()),\n        FastMath.atan2(v2.getZ(), v2.getX())\n      };\n\n    } else if (order == RotationOrder.ZXZ) {\n\n      // r (Vector3D.plusK) coordinates are :\n      //  sin (psi1) sin (phi), -cos (psi1) sin (phi), cos (phi)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // sin (phi) sin (psi2), sin (phi) cos (psi2), cos (phi)\n      // and we can choose to have phi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getX(), -v1.getY()),\n        FastMath.acos(v2.getZ()),\n        FastMath.atan2(v2.getX(), v2.getY())\n      };\n\n    } else { // last possibility is ZYZ\n\n      // r (Vector3D.plusK) coordinates are :\n      //  cos (psi1) sin (theta), sin (psi1) sin (theta), cos (theta)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // -sin (theta) cos (psi2), sin (theta) sin (psi2), cos (theta)\n      // and we can choose to have theta in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getY(), v1.getX()),\n        FastMath.acos(v2.getZ()),\n        FastMath.atan2(v2.getY(), -v2.getX())\n      };\n\n    }\n\n  }",
          "6": "  public double[] getAngles(RotationOrder order)\n    throws CardanEulerSingularityException {\n\n    if (order == RotationOrder.XYZ) {\n\n      // r (Vector3D.plusK) coordinates are :\n      //  sin (theta), -cos (theta) sin (phi), cos (theta) cos (phi)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (psi) cos (theta), -sin (psi) cos (theta), sin (theta)\n      // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if  ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(-(v1.getY()), v1.getZ()),\n        FastMath.asin(v2.getZ()),\n        FastMath.atan2(-(v2.getY()), v2.getX())\n      };\n\n    } else if (order == RotationOrder.XZY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      // -sin (psi), cos (psi) cos (phi), cos (psi) sin (phi)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (theta) cos (psi), -sin (psi), sin (theta) cos (psi)\n      // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getZ(), v1.getY()),\n       -FastMath.asin(v2.getY()),\n        FastMath.atan2(v2.getZ(), v2.getX())\n      };\n\n    } else if (order == RotationOrder.YXZ) {\n\n      // r (Vector3D.plusK) coordinates are :\n      //  cos (phi) sin (theta), -sin (phi), cos (phi) cos (theta)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (psi) cos (phi), cos (psi) cos (phi), -sin (phi)\n      // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getX(), v1.getZ()),\n       -FastMath.asin(v2.getZ()),\n        FastMath.atan2(v2.getX(), v2.getY())\n      };\n\n    } else if (order == RotationOrder.YZX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      // cos (psi) cos (theta), sin (psi), -cos (psi) sin (theta)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (psi), cos (phi) cos (psi), -sin (phi) cos (psi)\n      // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(-(v1.getZ()), v1.getX()),\n        FastMath.asin(v2.getX()),\n        FastMath.atan2(-(v2.getZ()), v2.getY())\n      };\n\n    } else if (order == RotationOrder.ZXY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      // -cos (phi) sin (psi), cos (phi) cos (psi), sin (phi)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // -sin (theta) cos (phi), sin (phi), cos (theta) cos (phi)\n      // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(-(v1.getX()), v1.getY()),\n        FastMath.asin(v2.getY()),\n        FastMath.atan2(-(v2.getX()), v2.getZ())\n      };\n\n    } else if (order == RotationOrder.ZYX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      //  cos (theta) cos (psi), cos (theta) sin (psi), -sin (theta)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // -sin (theta), sin (phi) cos (theta), cos (phi) cos (theta)\n      // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\nreturn v1;      };\n\n    } else if (order == RotationOrder.XYX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      //  cos (theta), sin (phi1) sin (theta), -cos (phi1) sin (theta)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (theta), sin (theta) sin (phi2), sin (theta) cos (phi2)\n      // and we can choose to have theta in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getY(), -v1.getZ()),\n        FastMath.acos(v2.getX()),\n        FastMath.atan2(v2.getY(), v2.getZ())\n      };\n\n    } else if (order == RotationOrder.XZX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      //  cos (psi), cos (phi1) sin (psi), sin (phi1) sin (psi)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (psi), -sin (psi) cos (phi2), sin (psi) sin (phi2)\n      // and we can choose to have psi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getZ(), v1.getY()),\n        FastMath.acos(v2.getX()),\n        FastMath.atan2(v2.getZ(), -v2.getY())\n      };\n\n    } else if (order == RotationOrder.YXY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      //  sin (theta1) sin (phi), cos (phi), cos (theta1) sin (phi)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (phi) sin (theta2), cos (phi), -sin (phi) cos (theta2)\n      // and we can choose to have phi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getX(), v1.getZ()),\n        FastMath.acos(v2.getY()),\n        FastMath.atan2(v2.getX(), -v2.getZ())\n      };\n\n    } else if (order == RotationOrder.YZY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      //  -cos (theta1) sin (psi), cos (psi), sin (theta1) sin (psi)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (psi) cos (theta2), cos (psi), sin (psi) sin (theta2)\n      // and we can choose to have psi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getZ(), -v1.getX()),\n        FastMath.acos(v2.getY()),\n        FastMath.atan2(v2.getZ(), v2.getX())\n      };\n\n    } else if (order == RotationOrder.ZXZ) {\n\n      // r (Vector3D.plusK) coordinates are :\n      //  sin (psi1) sin (phi), -cos (psi1) sin (phi), cos (phi)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // sin (phi) sin (psi2), sin (phi) cos (psi2), cos (phi)\n      // and we can choose to have phi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getX(), -v1.getY()),\n        FastMath.acos(v2.getZ()),\n        FastMath.atan2(v2.getX(), v2.getY())\n      };\n\n    } else { // last possibility is ZYZ\n\n      // r (Vector3D.plusK) coordinates are :\n      //  cos (psi1) sin (theta), sin (psi1) sin (theta), cos (theta)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // -sin (theta) cos (psi2), sin (theta) sin (psi2), cos (theta)\n      // and we can choose to have theta in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getY(), v1.getX()),\n        FastMath.acos(v2.getZ()),\n        FastMath.atan2(v2.getY(), -v2.getX())\n      };\n\n    }\n\n  }",
          "7": "  public double[] getAngles(RotationOrder order)\n    throws CardanEulerSingularityException {\n\n    if (order == RotationOrder.XYZ) {\n\n      // r (Vector3D.plusK) coordinates are :\n      //  sin (theta), -cos (theta) sin (phi), cos (theta) cos (phi)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (psi) cos (theta), -sin (psi) cos (theta), sin (theta)\n      // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if  ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(-(v1.getY()), v1.getZ()),\n        FastMath.asin(v2.getZ()),\n        FastMath.atan2(-(v2.getY()), v2.getX())\n      };\n\n    } else if (order == RotationOrder.XZY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      // -sin (psi), cos (psi) cos (phi), cos (psi) sin (phi)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (theta) cos (psi), -sin (psi), sin (theta) cos (psi)\n      // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getZ(), v1.getY()),\n       -FastMath.asin(v2.getY()),\n        FastMath.atan2(v2.getZ(), v2.getX())\n      };\n\n    } else if (order == RotationOrder.YXZ) {\n\n      // r (Vector3D.plusK) coordinates are :\n      //  cos (phi) sin (theta), -sin (phi), cos (phi) cos (theta)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (psi) cos (phi), cos (psi) cos (phi), -sin (phi)\n      // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getX(), v1.getZ()),\n       -FastMath.asin(v2.getZ()),\n        FastMath.atan2(v2.getX(), v2.getY())\n      };\n\n    } else if (order == RotationOrder.YZX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      // cos (psi) cos (theta), sin (psi), -cos (psi) sin (theta)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (psi), cos (phi) cos (psi), -sin (phi) cos (psi)\n      // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(-(v1.getZ()), v1.getX()),\n        FastMath.asin(v2.getX()),\n        FastMath.atan2(-(v2.getZ()), v2.getY())\n      };\n\n    } else if (order == RotationOrder.ZXY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      // -cos (phi) sin (psi), cos (phi) cos (psi), sin (phi)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // -sin (theta) cos (phi), sin (phi), cos (theta) cos (phi)\n      // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(-(v1.getX()), v1.getY()),\n        FastMath.asin(v2.getY()),\n        FastMath.atan2(-(v2.getX()), v2.getZ())\n      };\n\n    } else if (order == RotationOrder.ZYX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      //  cos (theta) cos (psi), cos (theta) sin (psi), -sin (theta)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // -sin (theta), sin (phi) cos (theta), cos (phi) cos (theta)\n      // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\nreturn new double[[]]{FastMath.atan2(v1.getY(), v1.getX()),+FastMath.asin(v2.getX()),FastMath.atan2(v2.getName(), v2.getZ())};      };\n\n    } else if (order == RotationOrder.XYX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      //  cos (theta), sin (phi1) sin (theta), -cos (phi1) sin (theta)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (theta), sin (theta) sin (phi2), sin (theta) cos (phi2)\n      // and we can choose to have theta in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getY(), -v1.getZ()),\n        FastMath.acos(v2.getX()),\n        FastMath.atan2(v2.getY(), v2.getZ())\n      };\n\n    } else if (order == RotationOrder.XZX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      //  cos (psi), cos (phi1) sin (psi), sin (phi1) sin (psi)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (psi), -sin (psi) cos (phi2), sin (psi) sin (phi2)\n      // and we can choose to have psi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getZ(), v1.getY()),\n        FastMath.acos(v2.getX()),\n        FastMath.atan2(v2.getZ(), -v2.getY())\n      };\n\n    } else if (order == RotationOrder.YXY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      //  sin (theta1) sin (phi), cos (phi), cos (theta1) sin (phi)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (phi) sin (theta2), cos (phi), -sin (phi) cos (theta2)\n      // and we can choose to have phi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getX(), v1.getZ()),\n        FastMath.acos(v2.getY()),\n        FastMath.atan2(v2.getX(), -v2.getZ())\n      };\n\n    } else if (order == RotationOrder.YZY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      //  -cos (theta1) sin (psi), cos (psi), sin (theta1) sin (psi)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (psi) cos (theta2), cos (psi), sin (psi) sin (theta2)\n      // and we can choose to have psi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getZ(), -v1.getX()),\n        FastMath.acos(v2.getY()),\n        FastMath.atan2(v2.getZ(), v2.getX())\n      };\n\n    } else if (order == RotationOrder.ZXZ) {\n\n      // r (Vector3D.plusK) coordinates are :\n      //  sin (psi1) sin (phi), -cos (psi1) sin (phi), cos (phi)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // sin (phi) sin (psi2), sin (phi) cos (psi2), cos (phi)\n      // and we can choose to have phi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getX(), -v1.getY()),\n        FastMath.acos(v2.getZ()),\n        FastMath.atan2(v2.getX(), v2.getY())\n      };\n\n    } else { // last possibility is ZYZ\n\n      // r (Vector3D.plusK) coordinates are :\n      //  cos (psi1) sin (theta), sin (psi1) sin (theta), cos (theta)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // -sin (theta) cos (psi2), sin (theta) sin (psi2), cos (theta)\n      // and we can choose to have theta in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getY(), v1.getX()),\n        FastMath.acos(v2.getZ()),\n        FastMath.atan2(v2.getY(), -v2.getX())\n      };\n\n    }\n\n  }",
          "8": "  public double[] getAngles(RotationOrder order)\n    throws CardanEulerSingularityException {\n\n    if (order == RotationOrder.XYZ) {\n\n      // r (Vector3D.plusK) coordinates are :\n      //  sin (theta), -cos (theta) sin (phi), cos (theta) cos (phi)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (psi) cos (theta), -sin (psi) cos (theta), sin (theta)\n      // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if  ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(-(v1.getY()), v1.getZ()),\n        FastMath.asin(v2.getZ()),\n        FastMath.atan2(-(v2.getY()), v2.getX())\n      };\n\n    } else if (order == RotationOrder.XZY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      // -sin (psi), cos (psi) cos (phi), cos (psi) sin (phi)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (theta) cos (psi), -sin (psi), sin (theta) cos (psi)\n      // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getZ(), v1.getY()),\n       -FastMath.asin(v2.getY()),\n        FastMath.atan2(v2.getZ(), v2.getX())\n      };\n\n    } else if (order == RotationOrder.YXZ) {\n\n      // r (Vector3D.plusK) coordinates are :\n      //  cos (phi) sin (theta), -sin (phi), cos (phi) cos (theta)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (psi) cos (phi), cos (psi) cos (phi), -sin (phi)\n      // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getX(), v1.getZ()),\n       -FastMath.asin(v2.getZ()),\n        FastMath.atan2(v2.getX(), v2.getY())\n      };\n\n    } else if (order == RotationOrder.YZX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      // cos (psi) cos (theta), sin (psi), -cos (psi) sin (theta)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (psi), cos (phi) cos (psi), -sin (phi) cos (psi)\n      // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(-(v1.getZ()), v1.getX()),\n        FastMath.asin(v2.getX()),\n        FastMath.atan2(-(v2.getZ()), v2.getY())\n      };\n\n    } else if (order == RotationOrder.ZXY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      // -cos (phi) sin (psi), cos (phi) cos (psi), sin (phi)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // -sin (theta) cos (phi), sin (phi), cos (theta) cos (phi)\n      // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(-(v1.getX()), v1.getY()),\n        FastMath.asin(v2.getY()),\n        FastMath.atan2(-(v2.getX()), v2.getZ())\n      };\n\n    } else if (order == RotationOrder.ZYX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      //  cos (theta) cos (psi), cos (theta) sin (psi), -sin (theta)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // -sin (theta), sin (phi) cos (theta), cos (phi) cos (theta)\n      // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\nreturn new double[[]]{FastMath.atan2(v1.getY(), v1.getX()),+FastMath.asin(v2.getX()),FastMath.applyInverseTo(v2.getY(), v2.getZ())};      };\n\n    } else if (order == RotationOrder.XYX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      //  cos (theta), sin (phi1) sin (theta), -cos (phi1) sin (theta)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (theta), sin (theta) sin (phi2), sin (theta) cos (phi2)\n      // and we can choose to have theta in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getY(), -v1.getZ()),\n        FastMath.acos(v2.getX()),\n        FastMath.atan2(v2.getY(), v2.getZ())\n      };\n\n    } else if (order == RotationOrder.XZX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      //  cos (psi), cos (phi1) sin (psi), sin (phi1) sin (psi)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (psi), -sin (psi) cos (phi2), sin (psi) sin (phi2)\n      // and we can choose to have psi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getZ(), v1.getY()),\n        FastMath.acos(v2.getX()),\n        FastMath.atan2(v2.getZ(), -v2.getY())\n      };\n\n    } else if (order == RotationOrder.YXY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      //  sin (theta1) sin (phi), cos (phi), cos (theta1) sin (phi)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (phi) sin (theta2), cos (phi), -sin (phi) cos (theta2)\n      // and we can choose to have phi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getX(), v1.getZ()),\n        FastMath.acos(v2.getY()),\n        FastMath.atan2(v2.getX(), -v2.getZ())\n      };\n\n    } else if (order == RotationOrder.YZY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      //  -cos (theta1) sin (psi), cos (psi), sin (theta1) sin (psi)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (psi) cos (theta2), cos (psi), sin (psi) sin (theta2)\n      // and we can choose to have psi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getZ(), -v1.getX()),\n        FastMath.acos(v2.getY()),\n        FastMath.atan2(v2.getZ(), v2.getX())\n      };\n\n    } else if (order == RotationOrder.ZXZ) {\n\n      // r (Vector3D.plusK) coordinates are :\n      //  sin (psi1) sin (phi), -cos (psi1) sin (phi), cos (phi)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // sin (phi) sin (psi2), sin (phi) cos (psi2), cos (phi)\n      // and we can choose to have phi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getX(), -v1.getY()),\n        FastMath.acos(v2.getZ()),\n        FastMath.atan2(v2.getX(), v2.getY())\n      };\n\n    } else { // last possibility is ZYZ\n\n      // r (Vector3D.plusK) coordinates are :\n      //  cos (psi1) sin (theta), sin (psi1) sin (theta), cos (theta)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // -sin (theta) cos (psi2), sin (theta) sin (psi2), cos (theta)\n      // and we can choose to have theta in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getY(), v1.getX()),\n        FastMath.acos(v2.getZ()),\n        FastMath.atan2(v2.getY(), -v2.getX())\n      };\n\n    }\n\n  }",
          "9": "  public double[] getAngles(RotationOrder order)\n    throws CardanEulerSingularityException {\n\n    if (order == RotationOrder.XYZ) {\n\n      // r (Vector3D.plusK) coordinates are :\n      //  sin (theta), -cos (theta) sin (phi), cos (theta) cos (phi)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (psi) cos (theta), -sin (psi) cos (theta), sin (theta)\n      // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if  ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(-(v1.getY()), v1.getZ()),\n        FastMath.asin(v2.getZ()),\n        FastMath.atan2(-(v2.getY()), v2.getX())\n      };\n\n    } else if (order == RotationOrder.XZY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      // -sin (psi), cos (psi) cos (phi), cos (psi) sin (phi)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (theta) cos (psi), -sin (psi), sin (theta) cos (psi)\n      // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getZ(), v1.getY()),\n       -FastMath.asin(v2.getY()),\n        FastMath.atan2(v2.getZ(), v2.getX())\n      };\n\n    } else if (order == RotationOrder.YXZ) {\n\n      // r (Vector3D.plusK) coordinates are :\n      //  cos (phi) sin (theta), -sin (phi), cos (phi) cos (theta)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (psi) cos (phi), cos (psi) cos (phi), -sin (phi)\n      // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getX(), v1.getZ()),\n       -FastMath.asin(v2.getZ()),\n        FastMath.atan2(v2.getX(), v2.getY())\n      };\n\n    } else if (order == RotationOrder.YZX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      // cos (psi) cos (theta), sin (psi), -cos (psi) sin (theta)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (psi), cos (phi) cos (psi), -sin (phi) cos (psi)\n      // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(-(v1.getZ()), v1.getX()),\n        FastMath.asin(v2.getX()),\n        FastMath.atan2(-(v2.getZ()), v2.getY())\n      };\n\n    } else if (order == RotationOrder.ZXY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      // -cos (phi) sin (psi), cos (phi) cos (psi), sin (phi)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // -sin (theta) cos (phi), sin (phi), cos (theta) cos (phi)\n      // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(-(v1.getX()), v1.getY()),\n        FastMath.asin(v2.getY()),\n        FastMath.atan2(-(v2.getX()), v2.getZ())\n      };\n\n    } else if (order == RotationOrder.ZYX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      //  cos (theta) cos (psi), cos (theta) sin (psi), -sin (theta)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // -sin (theta), sin (phi) cos (theta), cos (phi) cos (theta)\n      // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\nreturn new double[[]]{FastMath.atan2(v1.getY(), v1.getX()),+FastMath.asin(v2.getX()),FastMath.atan2(v2.getY(), v2.getX())};      };\n\n    } else if (order == RotationOrder.XYX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      //  cos (theta), sin (phi1) sin (theta), -cos (phi1) sin (theta)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (theta), sin (theta) sin (phi2), sin (theta) cos (phi2)\n      // and we can choose to have theta in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getY(), -v1.getZ()),\n        FastMath.acos(v2.getX()),\n        FastMath.atan2(v2.getY(), v2.getZ())\n      };\n\n    } else if (order == RotationOrder.XZX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      //  cos (psi), cos (phi1) sin (psi), sin (phi1) sin (psi)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (psi), -sin (psi) cos (phi2), sin (psi) sin (phi2)\n      // and we can choose to have psi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getZ(), v1.getY()),\n        FastMath.acos(v2.getX()),\n        FastMath.atan2(v2.getZ(), -v2.getY())\n      };\n\n    } else if (order == RotationOrder.YXY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      //  sin (theta1) sin (phi), cos (phi), cos (theta1) sin (phi)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (phi) sin (theta2), cos (phi), -sin (phi) cos (theta2)\n      // and we can choose to have phi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getX(), v1.getZ()),\n        FastMath.acos(v2.getY()),\n        FastMath.atan2(v2.getX(), -v2.getZ())\n      };\n\n    } else if (order == RotationOrder.YZY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      //  -cos (theta1) sin (psi), cos (psi), sin (theta1) sin (psi)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (psi) cos (theta2), cos (psi), sin (psi) sin (theta2)\n      // and we can choose to have psi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getZ(), -v1.getX()),\n        FastMath.acos(v2.getY()),\n        FastMath.atan2(v2.getZ(), v2.getX())\n      };\n\n    } else if (order == RotationOrder.ZXZ) {\n\n      // r (Vector3D.plusK) coordinates are :\n      //  sin (psi1) sin (phi), -cos (psi1) sin (phi), cos (phi)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // sin (phi) sin (psi2), sin (phi) cos (psi2), cos (phi)\n      // and we can choose to have phi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getX(), -v1.getY()),\n        FastMath.acos(v2.getZ()),\n        FastMath.atan2(v2.getX(), v2.getY())\n      };\n\n    } else { // last possibility is ZYZ\n\n      // r (Vector3D.plusK) coordinates are :\n      //  cos (psi1) sin (theta), sin (psi1) sin (theta), cos (theta)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // -sin (theta) cos (psi2), sin (theta) sin (psi2), cos (theta)\n      // and we can choose to have theta in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getY(), v1.getX()),\n        FastMath.acos(v2.getZ()),\n        FastMath.atan2(v2.getY(), -v2.getX())\n      };\n\n    }\n\n  }",
          "10": "  public double[] getAngles(RotationOrder order)\n    throws CardanEulerSingularityException {\n\n    if (order == RotationOrder.XYZ) {\n\n      // r (Vector3D.plusK) coordinates are :\n      //  sin (theta), -cos (theta) sin (phi), cos (theta) cos (phi)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (psi) cos (theta), -sin (psi) cos (theta), sin (theta)\n      // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if  ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(-(v1.getY()), v1.getZ()),\n        FastMath.asin(v2.getZ()),\n        FastMath.atan2(-(v2.getY()), v2.getX())\n      };\n\n    } else if (order == RotationOrder.XZY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      // -sin (psi), cos (psi) cos (phi), cos (psi) sin (phi)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (theta) cos (psi), -sin (psi), sin (theta) cos (psi)\n      // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getZ(), v1.getY()),\n       -FastMath.asin(v2.getY()),\n        FastMath.atan2(v2.getZ(), v2.getX())\n      };\n\n    } else if (order == RotationOrder.YXZ) {\n\n      // r (Vector3D.plusK) coordinates are :\n      //  cos (phi) sin (theta), -sin (phi), cos (phi) cos (theta)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (psi) cos (phi), cos (psi) cos (phi), -sin (phi)\n      // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getX(), v1.getZ()),\n       -FastMath.asin(v2.getZ()),\n        FastMath.atan2(v2.getX(), v2.getY())\n      };\n\n    } else if (order == RotationOrder.YZX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      // cos (psi) cos (theta), sin (psi), -cos (psi) sin (theta)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (psi), cos (phi) cos (psi), -sin (phi) cos (psi)\n      // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(-(v1.getZ()), v1.getX()),\n        FastMath.asin(v2.getX()),\n        FastMath.atan2(-(v2.getZ()), v2.getY())\n      };\n\n    } else if (order == RotationOrder.ZXY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      // -cos (phi) sin (psi), cos (phi) cos (psi), sin (phi)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // -sin (theta) cos (phi), sin (phi), cos (theta) cos (phi)\n      // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(-(v1.getX()), v1.getY()),\n        FastMath.asin(v2.getY()),\n        FastMath.atan2(-(v2.getX()), v2.getZ())\n      };\n\n    } else if (order == RotationOrder.ZYX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      //  cos (theta) cos (psi), cos (theta) sin (psi), -sin (theta)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // -sin (theta), sin (phi) cos (theta), cos (phi) cos (theta)\n      // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\nreturn new double[[]]{FastMath.atan2(v1.getY(), v1.getX()),+FastMath.asin(v2.getX()),FastMath.atan2(v2.getX(), v2.getZ())};      };\n\n    } else if (order == RotationOrder.XYX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      //  cos (theta), sin (phi1) sin (theta), -cos (phi1) sin (theta)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (theta), sin (theta) sin (phi2), sin (theta) cos (phi2)\n      // and we can choose to have theta in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getY(), -v1.getZ()),\n        FastMath.acos(v2.getX()),\n        FastMath.atan2(v2.getY(), v2.getZ())\n      };\n\n    } else if (order == RotationOrder.XZX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      //  cos (psi), cos (phi1) sin (psi), sin (phi1) sin (psi)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (psi), -sin (psi) cos (phi2), sin (psi) sin (phi2)\n      // and we can choose to have psi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getZ(), v1.getY()),\n        FastMath.acos(v2.getX()),\n        FastMath.atan2(v2.getZ(), -v2.getY())\n      };\n\n    } else if (order == RotationOrder.YXY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      //  sin (theta1) sin (phi), cos (phi), cos (theta1) sin (phi)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (phi) sin (theta2), cos (phi), -sin (phi) cos (theta2)\n      // and we can choose to have phi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getX(), v1.getZ()),\n        FastMath.acos(v2.getY()),\n        FastMath.atan2(v2.getX(), -v2.getZ())\n      };\n\n    } else if (order == RotationOrder.YZY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      //  -cos (theta1) sin (psi), cos (psi), sin (theta1) sin (psi)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (psi) cos (theta2), cos (psi), sin (psi) sin (theta2)\n      // and we can choose to have psi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getZ(), -v1.getX()),\n        FastMath.acos(v2.getY()),\n        FastMath.atan2(v2.getZ(), v2.getX())\n      };\n\n    } else if (order == RotationOrder.ZXZ) {\n\n      // r (Vector3D.plusK) coordinates are :\n      //  sin (psi1) sin (phi), -cos (psi1) sin (phi), cos (phi)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // sin (phi) sin (psi2), sin (phi) cos (psi2), cos (phi)\n      // and we can choose to have phi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getX(), -v1.getY()),\n        FastMath.acos(v2.getZ()),\n        FastMath.atan2(v2.getX(), v2.getY())\n      };\n\n    } else { // last possibility is ZYZ\n\n      // r (Vector3D.plusK) coordinates are :\n      //  cos (psi1) sin (theta), sin (psi1) sin (theta), cos (theta)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // -sin (theta) cos (psi2), sin (theta) sin (psi2), cos (theta)\n      // and we can choose to have theta in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getY(), v1.getX()),\n        FastMath.acos(v2.getZ()),\n        FastMath.atan2(v2.getY(), -v2.getX())\n      };\n\n    }\n\n  }",
          "11": "  public double[] getAngles(RotationOrder order)\n    throws CardanEulerSingularityException {\n\n    if (order == RotationOrder.XYZ) {\n\n      // r (Vector3D.plusK) coordinates are :\n      //  sin (theta), -cos (theta) sin (phi), cos (theta) cos (phi)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (psi) cos (theta), -sin (psi) cos (theta), sin (theta)\n      // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if  ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(-(v1.getY()), v1.getZ()),\n        FastMath.asin(v2.getZ()),\n        FastMath.atan2(-(v2.getY()), v2.getX())\n      };\n\n    } else if (order == RotationOrder.XZY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      // -sin (psi), cos (psi) cos (phi), cos (psi) sin (phi)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (theta) cos (psi), -sin (psi), sin (theta) cos (psi)\n      // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getZ(), v1.getY()),\n       -FastMath.asin(v2.getY()),\n        FastMath.atan2(v2.getZ(), v2.getX())\n      };\n\n    } else if (order == RotationOrder.YXZ) {\n\n      // r (Vector3D.plusK) coordinates are :\n      //  cos (phi) sin (theta), -sin (phi), cos (phi) cos (theta)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (psi) cos (phi), cos (psi) cos (phi), -sin (phi)\n      // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getX(), v1.getZ()),\n       -FastMath.asin(v2.getZ()),\n        FastMath.atan2(v2.getX(), v2.getY())\n      };\n\n    } else if (order == RotationOrder.YZX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      // cos (psi) cos (theta), sin (psi), -cos (psi) sin (theta)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (psi), cos (phi) cos (psi), -sin (phi) cos (psi)\n      // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(-(v1.getZ()), v1.getX()),\n        FastMath.asin(v2.getX()),\n        FastMath.atan2(-(v2.getZ()), v2.getY())\n      };\n\n    } else if (order == RotationOrder.ZXY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      // -cos (phi) sin (psi), cos (phi) cos (psi), sin (phi)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // -sin (theta) cos (phi), sin (phi), cos (theta) cos (phi)\n      // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(-(v1.getX()), v1.getY()),\n        FastMath.asin(v2.getY()),\n        FastMath.atan2(-(v2.getX()), v2.getZ())\n      };\n\n    } else if (order == RotationOrder.ZYX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      //  cos (theta) cos (psi), cos (theta) sin (psi), -sin (theta)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // -sin (theta), sin (phi) cos (theta), cos (phi) cos (theta)\n      // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\nreturn new double[[]]{FastMath.atan2(v1.getY(), v1.getX()),+FastMath.asin(v2.getX()),FastMath.atan2(v2.getY(), v2.getZ())};      };\n\n    } else if (order == RotationOrder.XYX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      //  cos (theta), sin (phi1) sin (theta), -cos (phi1) sin (theta)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (theta), sin (theta) sin (phi2), sin (theta) cos (phi2)\n      // and we can choose to have theta in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getY(), -v1.getZ()),\n        FastMath.acos(v2.getX()),\n        FastMath.atan2(v2.getY(), v2.getZ())\n      };\n\n    } else if (order == RotationOrder.XZX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      //  cos (psi), cos (phi1) sin (psi), sin (phi1) sin (psi)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (psi), -sin (psi) cos (phi2), sin (psi) sin (phi2)\n      // and we can choose to have psi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getZ(), v1.getY()),\n        FastMath.acos(v2.getX()),\n        FastMath.atan2(v2.getZ(), -v2.getY())\n      };\n\n    } else if (order == RotationOrder.YXY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      //  sin (theta1) sin (phi), cos (phi), cos (theta1) sin (phi)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (phi) sin (theta2), cos (phi), -sin (phi) cos (theta2)\n      // and we can choose to have phi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getX(), v1.getZ()),\n        FastMath.acos(v2.getY()),\n        FastMath.atan2(v2.getX(), -v2.getZ())\n      };\n\n    } else if (order == RotationOrder.YZY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      //  -cos (theta1) sin (psi), cos (psi), sin (theta1) sin (psi)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (psi) cos (theta2), cos (psi), sin (psi) sin (theta2)\n      // and we can choose to have psi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getZ(), -v1.getX()),\n        FastMath.acos(v2.getY()),\n        FastMath.atan2(v2.getZ(), v2.getX())\n      };\n\n    } else if (order == RotationOrder.ZXZ) {\n\n      // r (Vector3D.plusK) coordinates are :\n      //  sin (psi1) sin (phi), -cos (psi1) sin (phi), cos (phi)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // sin (phi) sin (psi2), sin (phi) cos (psi2), cos (phi)\n      // and we can choose to have phi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getX(), -v1.getY()),\n        FastMath.acos(v2.getZ()),\n        FastMath.atan2(v2.getX(), v2.getY())\n      };\n\n    } else { // last possibility is ZYZ\n\n      // r (Vector3D.plusK) coordinates are :\n      //  cos (psi1) sin (theta), sin (psi1) sin (theta), cos (theta)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // -sin (theta) cos (psi2), sin (theta) sin (psi2), cos (theta)\n      // and we can choose to have theta in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getY(), v1.getX()),\n        FastMath.acos(v2.getZ()),\n        FastMath.atan2(v2.getY(), -v2.getX())\n      };\n\n    }\n\n  }",
          "12": "  public double[] getAngles(RotationOrder order)\n    throws CardanEulerSingularityException {\n\n    if (order == RotationOrder.XYZ) {\n\n      // r (Vector3D.plusK) coordinates are :\n      //  sin (theta), -cos (theta) sin (phi), cos (theta) cos (phi)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (psi) cos (theta), -sin (psi) cos (theta), sin (theta)\n      // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if  ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(-(v1.getY()), v1.getZ()),\n        FastMath.asin(v2.getZ()),\n        FastMath.atan2(-(v2.getY()), v2.getX())\n      };\n\n    } else if (order == RotationOrder.XZY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      // -sin (psi), cos (psi) cos (phi), cos (psi) sin (phi)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (theta) cos (psi), -sin (psi), sin (theta) cos (psi)\n      // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getZ(), v1.getY()),\n       -FastMath.asin(v2.getY()),\n        FastMath.atan2(v2.getZ(), v2.getX())\n      };\n\n    } else if (order == RotationOrder.YXZ) {\n\n      // r (Vector3D.plusK) coordinates are :\n      //  cos (phi) sin (theta), -sin (phi), cos (phi) cos (theta)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (psi) cos (phi), cos (psi) cos (phi), -sin (phi)\n      // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getX(), v1.getZ()),\n       -FastMath.asin(v2.getZ()),\n        FastMath.atan2(v2.getX(), v2.getY())\n      };\n\n    } else if (order == RotationOrder.YZX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      // cos (psi) cos (theta), sin (psi), -cos (psi) sin (theta)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (psi), cos (phi) cos (psi), -sin (phi) cos (psi)\n      // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(-(v1.getZ()), v1.getX()),\n        FastMath.asin(v2.getX()),\n        FastMath.atan2(-(v2.getZ()), v2.getY())\n      };\n\n    } else if (order == RotationOrder.ZXY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      // -cos (phi) sin (psi), cos (phi) cos (psi), sin (phi)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // -sin (theta) cos (phi), sin (phi), cos (theta) cos (phi)\n      // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(-(v1.getX()), v1.getY()),\n        FastMath.asin(v2.getY()),\n        FastMath.atan2(-(v2.getX()), v2.getZ())\n      };\n\n    } else if (order == RotationOrder.ZYX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      //  cos (theta) cos (psi), cos (theta) sin (psi), -sin (theta)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // -sin (theta), sin (phi) cos (theta), cos (phi) cos (theta)\n      // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\nreturn new double[[]]{FastMath.atan2(v1.getY(), v1.getX()),+FastMath.asin(v2.toString()),FastMath.atan2(v2.getY(), v2.getZ())};      };\n\n    } else if (order == RotationOrder.XYX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      //  cos (theta), sin (phi1) sin (theta), -cos (phi1) sin (theta)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (theta), sin (theta) sin (phi2), sin (theta) cos (phi2)\n      // and we can choose to have theta in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getY(), -v1.getZ()),\n        FastMath.acos(v2.getX()),\n        FastMath.atan2(v2.getY(), v2.getZ())\n      };\n\n    } else if (order == RotationOrder.XZX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      //  cos (psi), cos (phi1) sin (psi), sin (phi1) sin (psi)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (psi), -sin (psi) cos (phi2), sin (psi) sin (phi2)\n      // and we can choose to have psi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getZ(), v1.getY()),\n        FastMath.acos(v2.getX()),\n        FastMath.atan2(v2.getZ(), -v2.getY())\n      };\n\n    } else if (order == RotationOrder.YXY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      //  sin (theta1) sin (phi), cos (phi), cos (theta1) sin (phi)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (phi) sin (theta2), cos (phi), -sin (phi) cos (theta2)\n      // and we can choose to have phi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getX(), v1.getZ()),\n        FastMath.acos(v2.getY()),\n        FastMath.atan2(v2.getX(), -v2.getZ())\n      };\n\n    } else if (order == RotationOrder.YZY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      //  -cos (theta1) sin (psi), cos (psi), sin (theta1) sin (psi)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (psi) cos (theta2), cos (psi), sin (psi) sin (theta2)\n      // and we can choose to have psi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getZ(), -v1.getX()),\n        FastMath.acos(v2.getY()),\n        FastMath.atan2(v2.getZ(), v2.getX())\n      };\n\n    } else if (order == RotationOrder.ZXZ) {\n\n      // r (Vector3D.plusK) coordinates are :\n      //  sin (psi1) sin (phi), -cos (psi1) sin (phi), cos (phi)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // sin (phi) sin (psi2), sin (phi) cos (psi2), cos (phi)\n      // and we can choose to have phi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getX(), -v1.getY()),\n        FastMath.acos(v2.getZ()),\n        FastMath.atan2(v2.getX(), v2.getY())\n      };\n\n    } else { // last possibility is ZYZ\n\n      // r (Vector3D.plusK) coordinates are :\n      //  cos (psi1) sin (theta), sin (psi1) sin (theta), cos (theta)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // -sin (theta) cos (psi2), sin (theta) sin (psi2), cos (theta)\n      // and we can choose to have theta in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getY(), v1.getX()),\n        FastMath.acos(v2.getZ()),\n        FastMath.atan2(v2.getY(), -v2.getX())\n      };\n\n    }\n\n  }",
          "13": "  public double[] getAngles(RotationOrder order)\n    throws CardanEulerSingularityException {\n\n    if (order == RotationOrder.XYZ) {\n\n      // r (Vector3D.plusK) coordinates are :\n      //  sin (theta), -cos (theta) sin (phi), cos (theta) cos (phi)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (psi) cos (theta), -sin (psi) cos (theta), sin (theta)\n      // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if  ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(-(v1.getY()), v1.getZ()),\n        FastMath.asin(v2.getZ()),\n        FastMath.atan2(-(v2.getY()), v2.getX())\n      };\n\n    } else if (order == RotationOrder.XZY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      // -sin (psi), cos (psi) cos (phi), cos (psi) sin (phi)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (theta) cos (psi), -sin (psi), sin (theta) cos (psi)\n      // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getZ(), v1.getY()),\n       -FastMath.asin(v2.getY()),\n        FastMath.atan2(v2.getZ(), v2.getX())\n      };\n\n    } else if (order == RotationOrder.YXZ) {\n\n      // r (Vector3D.plusK) coordinates are :\n      //  cos (phi) sin (theta), -sin (phi), cos (phi) cos (theta)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (psi) cos (phi), cos (psi) cos (phi), -sin (phi)\n      // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getX(), v1.getZ()),\n       -FastMath.asin(v2.getZ()),\n        FastMath.atan2(v2.getX(), v2.getY())\n      };\n\n    } else if (order == RotationOrder.YZX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      // cos (psi) cos (theta), sin (psi), -cos (psi) sin (theta)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (psi), cos (phi) cos (psi), -sin (phi) cos (psi)\n      // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(-(v1.getZ()), v1.getX()),\n        FastMath.asin(v2.getX()),\n        FastMath.atan2(-(v2.getZ()), v2.getY())\n      };\n\n    } else if (order == RotationOrder.ZXY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      // -cos (phi) sin (psi), cos (phi) cos (psi), sin (phi)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // -sin (theta) cos (phi), sin (phi), cos (theta) cos (phi)\n      // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(-(v1.getX()), v1.getY()),\n        FastMath.asin(v2.getY()),\n        FastMath.atan2(-(v2.getX()), v2.getZ())\n      };\n\n    } else if (order == RotationOrder.ZYX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      //  cos (theta) cos (psi), cos (theta) sin (psi), -sin (theta)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // -sin (theta), sin (phi) cos (theta), cos (phi) cos (theta)\n      // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\nreturn new double[[]]{FastMath.atan2(v1.getY(), v1.getX()),+FastMath.asin(v2.getX()),FastMath.atan2(v2.getY(), v2.toString())};      };\n\n    } else if (order == RotationOrder.XYX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      //  cos (theta), sin (phi1) sin (theta), -cos (phi1) sin (theta)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (theta), sin (theta) sin (phi2), sin (theta) cos (phi2)\n      // and we can choose to have theta in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getY(), -v1.getZ()),\n        FastMath.acos(v2.getX()),\n        FastMath.atan2(v2.getY(), v2.getZ())\n      };\n\n    } else if (order == RotationOrder.XZX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      //  cos (psi), cos (phi1) sin (psi), sin (phi1) sin (psi)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (psi), -sin (psi) cos (phi2), sin (psi) sin (phi2)\n      // and we can choose to have psi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getZ(), v1.getY()),\n        FastMath.acos(v2.getX()),\n        FastMath.atan2(v2.getZ(), -v2.getY())\n      };\n\n    } else if (order == RotationOrder.YXY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      //  sin (theta1) sin (phi), cos (phi), cos (theta1) sin (phi)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (phi) sin (theta2), cos (phi), -sin (phi) cos (theta2)\n      // and we can choose to have phi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getX(), v1.getZ()),\n        FastMath.acos(v2.getY()),\n        FastMath.atan2(v2.getX(), -v2.getZ())\n      };\n\n    } else if (order == RotationOrder.YZY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      //  -cos (theta1) sin (psi), cos (psi), sin (theta1) sin (psi)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (psi) cos (theta2), cos (psi), sin (psi) sin (theta2)\n      // and we can choose to have psi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getZ(), -v1.getX()),\n        FastMath.acos(v2.getY()),\n        FastMath.atan2(v2.getZ(), v2.getX())\n      };\n\n    } else if (order == RotationOrder.ZXZ) {\n\n      // r (Vector3D.plusK) coordinates are :\n      //  sin (psi1) sin (phi), -cos (psi1) sin (phi), cos (phi)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // sin (phi) sin (psi2), sin (phi) cos (psi2), cos (phi)\n      // and we can choose to have phi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getX(), -v1.getY()),\n        FastMath.acos(v2.getZ()),\n        FastMath.atan2(v2.getX(), v2.getY())\n      };\n\n    } else { // last possibility is ZYZ\n\n      // r (Vector3D.plusK) coordinates are :\n      //  cos (psi1) sin (theta), sin (psi1) sin (theta), cos (theta)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // -sin (theta) cos (psi2), sin (theta) sin (psi2), cos (theta)\n      // and we can choose to have theta in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getY(), v1.getX()),\n        FastMath.acos(v2.getZ()),\n        FastMath.atan2(v2.getY(), -v2.getX())\n      };\n\n    }\n\n  }",
          "14": "  public double[] getAngles(RotationOrder order)\n    throws CardanEulerSingularityException {\n\n    if (order == RotationOrder.XYZ) {\n\n      // r (Vector3D.plusK) coordinates are :\n      //  sin (theta), -cos (theta) sin (phi), cos (theta) cos (phi)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (psi) cos (theta), -sin (psi) cos (theta), sin (theta)\n      // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if  ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(-(v1.getY()), v1.getZ()),\n        FastMath.asin(v2.getZ()),\n        FastMath.atan2(-(v2.getY()), v2.getX())\n      };\n\n    } else if (order == RotationOrder.XZY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      // -sin (psi), cos (psi) cos (phi), cos (psi) sin (phi)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (theta) cos (psi), -sin (psi), sin (theta) cos (psi)\n      // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getZ(), v1.getY()),\n       -FastMath.asin(v2.getY()),\n        FastMath.atan2(v2.getZ(), v2.getX())\n      };\n\n    } else if (order == RotationOrder.YXZ) {\n\n      // r (Vector3D.plusK) coordinates are :\n      //  cos (phi) sin (theta), -sin (phi), cos (phi) cos (theta)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (psi) cos (phi), cos (psi) cos (phi), -sin (phi)\n      // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getX(), v1.getZ()),\n       -FastMath.asin(v2.getZ()),\n        FastMath.atan2(v2.getX(), v2.getY())\n      };\n\n    } else if (order == RotationOrder.YZX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      // cos (psi) cos (theta), sin (psi), -cos (psi) sin (theta)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (psi), cos (phi) cos (psi), -sin (phi) cos (psi)\n      // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(-(v1.getZ()), v1.getX()),\n        FastMath.asin(v2.getX()),\n        FastMath.atan2(-(v2.getZ()), v2.getY())\n      };\n\n    } else if (order == RotationOrder.ZXY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      // -cos (phi) sin (psi), cos (phi) cos (psi), sin (phi)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // -sin (theta) cos (phi), sin (phi), cos (theta) cos (phi)\n      // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(-(v1.getX()), v1.getY()),\n        FastMath.asin(v2.getY()),\n        FastMath.atan2(-(v2.getX()), v2.getZ())\n      };\n\n    } else if (order == RotationOrder.ZYX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      //  cos (theta) cos (psi), cos (theta) sin (psi), -sin (theta)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // -sin (theta), sin (phi) cos (theta), cos (phi) cos (theta)\n      // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\nreturn new double[[]]{FastMath.atan2(v1.getY(), v1.getX()),+FastMath.applyTo(v2.getX()),FastMath.atan2(v2.getY(), v2.getZ())};      };\n\n    } else if (order == RotationOrder.XYX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      //  cos (theta), sin (phi1) sin (theta), -cos (phi1) sin (theta)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (theta), sin (theta) sin (phi2), sin (theta) cos (phi2)\n      // and we can choose to have theta in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getY(), -v1.getZ()),\n        FastMath.acos(v2.getX()),\n        FastMath.atan2(v2.getY(), v2.getZ())\n      };\n\n    } else if (order == RotationOrder.XZX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      //  cos (psi), cos (phi1) sin (psi), sin (phi1) sin (psi)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (psi), -sin (psi) cos (phi2), sin (psi) sin (phi2)\n      // and we can choose to have psi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getZ(), v1.getY()),\n        FastMath.acos(v2.getX()),\n        FastMath.atan2(v2.getZ(), -v2.getY())\n      };\n\n    } else if (order == RotationOrder.YXY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      //  sin (theta1) sin (phi), cos (phi), cos (theta1) sin (phi)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (phi) sin (theta2), cos (phi), -sin (phi) cos (theta2)\n      // and we can choose to have phi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getX(), v1.getZ()),\n        FastMath.acos(v2.getY()),\n        FastMath.atan2(v2.getX(), -v2.getZ())\n      };\n\n    } else if (order == RotationOrder.YZY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      //  -cos (theta1) sin (psi), cos (psi), sin (theta1) sin (psi)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (psi) cos (theta2), cos (psi), sin (psi) sin (theta2)\n      // and we can choose to have psi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getZ(), -v1.getX()),\n        FastMath.acos(v2.getY()),\n        FastMath.atan2(v2.getZ(), v2.getX())\n      };\n\n    } else if (order == RotationOrder.ZXZ) {\n\n      // r (Vector3D.plusK) coordinates are :\n      //  sin (psi1) sin (phi), -cos (psi1) sin (phi), cos (phi)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // sin (phi) sin (psi2), sin (phi) cos (psi2), cos (phi)\n      // and we can choose to have phi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getX(), -v1.getY()),\n        FastMath.acos(v2.getZ()),\n        FastMath.atan2(v2.getX(), v2.getY())\n      };\n\n    } else { // last possibility is ZYZ\n\n      // r (Vector3D.plusK) coordinates are :\n      //  cos (psi1) sin (theta), sin (psi1) sin (theta), cos (theta)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // -sin (theta) cos (psi2), sin (theta) sin (psi2), cos (theta)\n      // and we can choose to have theta in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getY(), v1.getX()),\n        FastMath.acos(v2.getZ()),\n        FastMath.atan2(v2.getY(), -v2.getX())\n      };\n\n    }\n\n  }",
          "15": "  public double[] getAngles(RotationOrder order)\n    throws CardanEulerSingularityException {\n\n    if (order == RotationOrder.XYZ) {\n\n      // r (Vector3D.plusK) coordinates are :\n      //  sin (theta), -cos (theta) sin (phi), cos (theta) cos (phi)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (psi) cos (theta), -sin (psi) cos (theta), sin (theta)\n      // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if  ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(-(v1.getY()), v1.getZ()),\n        FastMath.asin(v2.getZ()),\n        FastMath.atan2(-(v2.getY()), v2.getX())\n      };\n\n    } else if (order == RotationOrder.XZY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      // -sin (psi), cos (psi) cos (phi), cos (psi) sin (phi)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (theta) cos (psi), -sin (psi), sin (theta) cos (psi)\n      // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getZ(), v1.getY()),\n       -FastMath.asin(v2.getY()),\n        FastMath.atan2(v2.getZ(), v2.getX())\n      };\n\n    } else if (order == RotationOrder.YXZ) {\n\n      // r (Vector3D.plusK) coordinates are :\n      //  cos (phi) sin (theta), -sin (phi), cos (phi) cos (theta)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (psi) cos (phi), cos (psi) cos (phi), -sin (phi)\n      // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getX(), v1.getZ()),\n       -FastMath.asin(v2.getZ()),\n        FastMath.atan2(v2.getX(), v2.getY())\n      };\n\n    } else if (order == RotationOrder.YZX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      // cos (psi) cos (theta), sin (psi), -cos (psi) sin (theta)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (psi), cos (phi) cos (psi), -sin (phi) cos (psi)\n      // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(-(v1.getZ()), v1.getX()),\n        FastMath.asin(v2.getX()),\n        FastMath.atan2(-(v2.getZ()), v2.getY())\n      };\n\n    } else if (order == RotationOrder.ZXY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      // -cos (phi) sin (psi), cos (phi) cos (psi), sin (phi)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // -sin (theta) cos (phi), sin (phi), cos (theta) cos (phi)\n      // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(-(v1.getX()), v1.getY()),\n        FastMath.asin(v2.getY()),\n        FastMath.atan2(-(v2.getX()), v2.getZ())\n      };\n\n    } else if (order == RotationOrder.ZYX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      //  cos (theta) cos (psi), cos (theta) sin (psi), -sin (theta)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // -sin (theta), sin (phi) cos (theta), cos (phi) cos (theta)\n      // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\nreturn null;      return new double[] {\n        FastMath.atan2(v1.getY(), v1.getX()),\n       +FastMath.asin(v2.getX()),\n        FastMath.atan2(v2.getY(), v2.getZ())      };\n\n    } else if (order == RotationOrder.XYX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      //  cos (theta), sin (phi1) sin (theta), -cos (phi1) sin (theta)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (theta), sin (theta) sin (phi2), sin (theta) cos (phi2)\n      // and we can choose to have theta in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getY(), -v1.getZ()),\n        FastMath.acos(v2.getX()),\n        FastMath.atan2(v2.getY(), v2.getZ())\n      };\n\n    } else if (order == RotationOrder.XZX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      //  cos (psi), cos (phi1) sin (psi), sin (phi1) sin (psi)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (psi), -sin (psi) cos (phi2), sin (psi) sin (phi2)\n      // and we can choose to have psi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getZ(), v1.getY()),\n        FastMath.acos(v2.getX()),\n        FastMath.atan2(v2.getZ(), -v2.getY())\n      };\n\n    } else if (order == RotationOrder.YXY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      //  sin (theta1) sin (phi), cos (phi), cos (theta1) sin (phi)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (phi) sin (theta2), cos (phi), -sin (phi) cos (theta2)\n      // and we can choose to have phi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getX(), v1.getZ()),\n        FastMath.acos(v2.getY()),\n        FastMath.atan2(v2.getX(), -v2.getZ())\n      };\n\n    } else if (order == RotationOrder.YZY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      //  -cos (theta1) sin (psi), cos (psi), sin (theta1) sin (psi)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (psi) cos (theta2), cos (psi), sin (psi) sin (theta2)\n      // and we can choose to have psi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getZ(), -v1.getX()),\n        FastMath.acos(v2.getY()),\n        FastMath.atan2(v2.getZ(), v2.getX())\n      };\n\n    } else if (order == RotationOrder.ZXZ) {\n\n      // r (Vector3D.plusK) coordinates are :\n      //  sin (psi1) sin (phi), -cos (psi1) sin (phi), cos (phi)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // sin (phi) sin (psi2), sin (phi) cos (psi2), cos (phi)\n      // and we can choose to have phi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getX(), -v1.getY()),\n        FastMath.acos(v2.getZ()),\n        FastMath.atan2(v2.getX(), v2.getY())\n      };\n\n    } else { // last possibility is ZYZ\n\n      // r (Vector3D.plusK) coordinates are :\n      //  cos (psi1) sin (theta), sin (psi1) sin (theta), cos (theta)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // -sin (theta) cos (psi2), sin (theta) sin (psi2), cos (theta)\n      // and we can choose to have theta in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getY(), v1.getX()),\n        FastMath.acos(v2.getZ()),\n        FastMath.atan2(v2.getY(), -v2.getX())\n      };\n\n    }\n\n  }",
          "16": "  public double[] getAngles(RotationOrder order)\n    throws CardanEulerSingularityException {\n\n    if (order == RotationOrder.XYZ) {\n\n      // r (Vector3D.plusK) coordinates are :\n      //  sin (theta), -cos (theta) sin (phi), cos (theta) cos (phi)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (psi) cos (theta), -sin (psi) cos (theta), sin (theta)\n      // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if  ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(-(v1.getY()), v1.getZ()),\n        FastMath.asin(v2.getZ()),\n        FastMath.atan2(-(v2.getY()), v2.getX())\n      };\n\n    } else if (order == RotationOrder.XZY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      // -sin (psi), cos (psi) cos (phi), cos (psi) sin (phi)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (theta) cos (psi), -sin (psi), sin (theta) cos (psi)\n      // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getZ(), v1.getY()),\n       -FastMath.asin(v2.getY()),\n        FastMath.atan2(v2.getZ(), v2.getX())\n      };\n\n    } else if (order == RotationOrder.YXZ) {\n\n      // r (Vector3D.plusK) coordinates are :\n      //  cos (phi) sin (theta), -sin (phi), cos (phi) cos (theta)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (psi) cos (phi), cos (psi) cos (phi), -sin (phi)\n      // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getX(), v1.getZ()),\n       -FastMath.asin(v2.getZ()),\n        FastMath.atan2(v2.getX(), v2.getY())\n      };\n\n    } else if (order == RotationOrder.YZX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      // cos (psi) cos (theta), sin (psi), -cos (psi) sin (theta)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (psi), cos (phi) cos (psi), -sin (phi) cos (psi)\n      // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(-(v1.getZ()), v1.getX()),\n        FastMath.asin(v2.getX()),\n        FastMath.atan2(-(v2.getZ()), v2.getY())\n      };\n\n    } else if (order == RotationOrder.ZXY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      // -cos (phi) sin (psi), cos (phi) cos (psi), sin (phi)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // -sin (theta) cos (phi), sin (phi), cos (theta) cos (phi)\n      // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(-(v1.getX()), v1.getY()),\n        FastMath.asin(v2.getY()),\n        FastMath.atan2(-(v2.getX()), v2.getZ())\n      };\n\n    } else if (order == RotationOrder.ZYX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      //  cos (theta) cos (psi), cos (theta) sin (psi), -sin (theta)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // -sin (theta), sin (phi) cos (theta), cos (phi) cos (theta)\n      // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\nreturn new double[[]]{FastMath.atan2(v1.getY(), v1.getX()),+FastMath.asin(v2.getX()),FastMath.atan2(v2.toString(), v2.getZ())};      };\n\n    } else if (order == RotationOrder.XYX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      //  cos (theta), sin (phi1) sin (theta), -cos (phi1) sin (theta)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (theta), sin (theta) sin (phi2), sin (theta) cos (phi2)\n      // and we can choose to have theta in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getY(), -v1.getZ()),\n        FastMath.acos(v2.getX()),\n        FastMath.atan2(v2.getY(), v2.getZ())\n      };\n\n    } else if (order == RotationOrder.XZX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      //  cos (psi), cos (phi1) sin (psi), sin (phi1) sin (psi)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (psi), -sin (psi) cos (phi2), sin (psi) sin (phi2)\n      // and we can choose to have psi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getZ(), v1.getY()),\n        FastMath.acos(v2.getX()),\n        FastMath.atan2(v2.getZ(), -v2.getY())\n      };\n\n    } else if (order == RotationOrder.YXY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      //  sin (theta1) sin (phi), cos (phi), cos (theta1) sin (phi)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (phi) sin (theta2), cos (phi), -sin (phi) cos (theta2)\n      // and we can choose to have phi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getX(), v1.getZ()),\n        FastMath.acos(v2.getY()),\n        FastMath.atan2(v2.getX(), -v2.getZ())\n      };\n\n    } else if (order == RotationOrder.YZY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      //  -cos (theta1) sin (psi), cos (psi), sin (theta1) sin (psi)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (psi) cos (theta2), cos (psi), sin (psi) sin (theta2)\n      // and we can choose to have psi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getZ(), -v1.getX()),\n        FastMath.acos(v2.getY()),\n        FastMath.atan2(v2.getZ(), v2.getX())\n      };\n\n    } else if (order == RotationOrder.ZXZ) {\n\n      // r (Vector3D.plusK) coordinates are :\n      //  sin (psi1) sin (phi), -cos (psi1) sin (phi), cos (phi)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // sin (phi) sin (psi2), sin (phi) cos (psi2), cos (phi)\n      // and we can choose to have phi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getX(), -v1.getY()),\n        FastMath.acos(v2.getZ()),\n        FastMath.atan2(v2.getX(), v2.getY())\n      };\n\n    } else { // last possibility is ZYZ\n\n      // r (Vector3D.plusK) coordinates are :\n      //  cos (psi1) sin (theta), sin (psi1) sin (theta), cos (theta)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // -sin (theta) cos (psi2), sin (theta) sin (psi2), cos (theta)\n      // and we can choose to have theta in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getY(), v1.getX()),\n        FastMath.acos(v2.getZ()),\n        FastMath.atan2(v2.getY(), -v2.getX())\n      };\n\n    }\n\n  }",
          "17": "  public double[] getAngles(RotationOrder order)\n    throws CardanEulerSingularityException {\n\n    if (order == RotationOrder.XYZ) {\n\n      // r (Vector3D.plusK) coordinates are :\n      //  sin (theta), -cos (theta) sin (phi), cos (theta) cos (phi)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (psi) cos (theta), -sin (psi) cos (theta), sin (theta)\n      // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if  ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(-(v1.getY()), v1.getZ()),\n        FastMath.asin(v2.getZ()),\n        FastMath.atan2(-(v2.getY()), v2.getX())\n      };\n\n    } else if (order == RotationOrder.XZY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      // -sin (psi), cos (psi) cos (phi), cos (psi) sin (phi)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (theta) cos (psi), -sin (psi), sin (theta) cos (psi)\n      // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getZ(), v1.getY()),\n       -FastMath.asin(v2.getY()),\n        FastMath.atan2(v2.getZ(), v2.getX())\n      };\n\n    } else if (order == RotationOrder.YXZ) {\n\n      // r (Vector3D.plusK) coordinates are :\n      //  cos (phi) sin (theta), -sin (phi), cos (phi) cos (theta)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (psi) cos (phi), cos (psi) cos (phi), -sin (phi)\n      // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getX(), v1.getZ()),\n       -FastMath.asin(v2.getZ()),\n        FastMath.atan2(v2.getX(), v2.getY())\n      };\n\n    } else if (order == RotationOrder.YZX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      // cos (psi) cos (theta), sin (psi), -cos (psi) sin (theta)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (psi), cos (phi) cos (psi), -sin (phi) cos (psi)\n      // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(-(v1.getZ()), v1.getX()),\n        FastMath.asin(v2.getX()),\n        FastMath.atan2(-(v2.getZ()), v2.getY())\n      };\n\n    } else if (order == RotationOrder.ZXY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      // -cos (phi) sin (psi), cos (phi) cos (psi), sin (phi)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // -sin (theta) cos (phi), sin (phi), cos (theta) cos (phi)\n      // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(-(v1.getX()), v1.getY()),\n        FastMath.asin(v2.getY()),\n        FastMath.atan2(-(v2.getX()), v2.getZ())\n      };\n\n    } else if (order == RotationOrder.ZYX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      //  cos (theta) cos (psi), cos (theta) sin (psi), -sin (theta)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // -sin (theta), sin (phi) cos (theta), cos (phi) cos (theta)\n      // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\nreturn 0;      };\n\n    } else if (order == RotationOrder.XYX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      //  cos (theta), sin (phi1) sin (theta), -cos (phi1) sin (theta)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (theta), sin (theta) sin (phi2), sin (theta) cos (phi2)\n      // and we can choose to have theta in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getY(), -v1.getZ()),\n        FastMath.acos(v2.getX()),\n        FastMath.atan2(v2.getY(), v2.getZ())\n      };\n\n    } else if (order == RotationOrder.XZX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      //  cos (psi), cos (phi1) sin (psi), sin (phi1) sin (psi)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (psi), -sin (psi) cos (phi2), sin (psi) sin (phi2)\n      // and we can choose to have psi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getZ(), v1.getY()),\n        FastMath.acos(v2.getX()),\n        FastMath.atan2(v2.getZ(), -v2.getY())\n      };\n\n    } else if (order == RotationOrder.YXY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      //  sin (theta1) sin (phi), cos (phi), cos (theta1) sin (phi)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (phi) sin (theta2), cos (phi), -sin (phi) cos (theta2)\n      // and we can choose to have phi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getX(), v1.getZ()),\n        FastMath.acos(v2.getY()),\n        FastMath.atan2(v2.getX(), -v2.getZ())\n      };\n\n    } else if (order == RotationOrder.YZY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      //  -cos (theta1) sin (psi), cos (psi), sin (theta1) sin (psi)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (psi) cos (theta2), cos (psi), sin (psi) sin (theta2)\n      // and we can choose to have psi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getZ(), -v1.getX()),\n        FastMath.acos(v2.getY()),\n        FastMath.atan2(v2.getZ(), v2.getX())\n      };\n\n    } else if (order == RotationOrder.ZXZ) {\n\n      // r (Vector3D.plusK) coordinates are :\n      //  sin (psi1) sin (phi), -cos (psi1) sin (phi), cos (phi)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // sin (phi) sin (psi2), sin (phi) cos (psi2), cos (phi)\n      // and we can choose to have phi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getX(), -v1.getY()),\n        FastMath.acos(v2.getZ()),\n        FastMath.atan2(v2.getX(), v2.getY())\n      };\n\n    } else { // last possibility is ZYZ\n\n      // r (Vector3D.plusK) coordinates are :\n      //  cos (psi1) sin (theta), sin (psi1) sin (theta), cos (theta)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // -sin (theta) cos (psi2), sin (theta) sin (psi2), cos (theta)\n      // and we can choose to have theta in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getY(), v1.getX()),\n        FastMath.acos(v2.getZ()),\n        FastMath.atan2(v2.getY(), -v2.getX())\n      };\n\n    }\n\n  }",
          "18": "  public double[] getAngles(RotationOrder order)\n    throws CardanEulerSingularityException {\n\n    if (order == RotationOrder.XYZ) {\n\n      // r (Vector3D.plusK) coordinates are :\n      //  sin (theta), -cos (theta) sin (phi), cos (theta) cos (phi)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (psi) cos (theta), -sin (psi) cos (theta), sin (theta)\n      // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if  ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(-(v1.getY()), v1.getZ()),\n        FastMath.asin(v2.getZ()),\n        FastMath.atan2(-(v2.getY()), v2.getX())\n      };\n\n    } else if (order == RotationOrder.XZY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      // -sin (psi), cos (psi) cos (phi), cos (psi) sin (phi)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (theta) cos (psi), -sin (psi), sin (theta) cos (psi)\n      // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getZ(), v1.getY()),\n       -FastMath.asin(v2.getY()),\n        FastMath.atan2(v2.getZ(), v2.getX())\n      };\n\n    } else if (order == RotationOrder.YXZ) {\n\n      // r (Vector3D.plusK) coordinates are :\n      //  cos (phi) sin (theta), -sin (phi), cos (phi) cos (theta)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (psi) cos (phi), cos (psi) cos (phi), -sin (phi)\n      // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getX(), v1.getZ()),\n       -FastMath.asin(v2.getZ()),\n        FastMath.atan2(v2.getX(), v2.getY())\n      };\n\n    } else if (order == RotationOrder.YZX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      // cos (psi) cos (theta), sin (psi), -cos (psi) sin (theta)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (psi), cos (phi) cos (psi), -sin (phi) cos (psi)\n      // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(-(v1.getZ()), v1.getX()),\n        FastMath.asin(v2.getX()),\n        FastMath.atan2(-(v2.getZ()), v2.getY())\n      };\n\n    } else if (order == RotationOrder.ZXY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      // -cos (phi) sin (psi), cos (phi) cos (psi), sin (phi)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // -sin (theta) cos (phi), sin (phi), cos (theta) cos (phi)\n      // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(-(v1.getX()), v1.getY()),\n        FastMath.asin(v2.getY()),\n        FastMath.atan2(-(v2.getX()), v2.getZ())\n      };\n\n    } else if (order == RotationOrder.ZYX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      //  cos (theta) cos (psi), cos (theta) sin (psi), -sin (theta)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // -sin (theta), sin (phi) cos (theta), cos (phi) cos (theta)\n      // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\nreturn new double[[]]{FastMath.atan2(v1.getY(), v1.getX()),+.asin(v2.getX()),FastMath.atan2(v2.getY(), v2.getZ())};      };\n\n    } else if (order == RotationOrder.XYX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      //  cos (theta), sin (phi1) sin (theta), -cos (phi1) sin (theta)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (theta), sin (theta) sin (phi2), sin (theta) cos (phi2)\n      // and we can choose to have theta in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getY(), -v1.getZ()),\n        FastMath.acos(v2.getX()),\n        FastMath.atan2(v2.getY(), v2.getZ())\n      };\n\n    } else if (order == RotationOrder.XZX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      //  cos (psi), cos (phi1) sin (psi), sin (phi1) sin (psi)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (psi), -sin (psi) cos (phi2), sin (psi) sin (phi2)\n      // and we can choose to have psi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getZ(), v1.getY()),\n        FastMath.acos(v2.getX()),\n        FastMath.atan2(v2.getZ(), -v2.getY())\n      };\n\n    } else if (order == RotationOrder.YXY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      //  sin (theta1) sin (phi), cos (phi), cos (theta1) sin (phi)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (phi) sin (theta2), cos (phi), -sin (phi) cos (theta2)\n      // and we can choose to have phi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getX(), v1.getZ()),\n        FastMath.acos(v2.getY()),\n        FastMath.atan2(v2.getX(), -v2.getZ())\n      };\n\n    } else if (order == RotationOrder.YZY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      //  -cos (theta1) sin (psi), cos (psi), sin (theta1) sin (psi)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (psi) cos (theta2), cos (psi), sin (psi) sin (theta2)\n      // and we can choose to have psi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getZ(), -v1.getX()),\n        FastMath.acos(v2.getY()),\n        FastMath.atan2(v2.getZ(), v2.getX())\n      };\n\n    } else if (order == RotationOrder.ZXZ) {\n\n      // r (Vector3D.plusK) coordinates are :\n      //  sin (psi1) sin (phi), -cos (psi1) sin (phi), cos (phi)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // sin (phi) sin (psi2), sin (phi) cos (psi2), cos (phi)\n      // and we can choose to have phi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getX(), -v1.getY()),\n        FastMath.acos(v2.getZ()),\n        FastMath.atan2(v2.getX(), v2.getY())\n      };\n\n    } else { // last possibility is ZYZ\n\n      // r (Vector3D.plusK) coordinates are :\n      //  cos (psi1) sin (theta), sin (psi1) sin (theta), cos (theta)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // -sin (theta) cos (psi2), sin (theta) sin (psi2), cos (theta)\n      // and we can choose to have theta in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getY(), v1.getX()),\n        FastMath.acos(v2.getZ()),\n        FastMath.atan2(v2.getY(), -v2.getX())\n      };\n\n    }\n\n  }",
          "19": "  public double[] getAngles(RotationOrder order)\n    throws CardanEulerSingularityException {\n\n    if (order == RotationOrder.XYZ) {\n\n      // r (Vector3D.plusK) coordinates are :\n      //  sin (theta), -cos (theta) sin (phi), cos (theta) cos (phi)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (psi) cos (theta), -sin (psi) cos (theta), sin (theta)\n      // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if  ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(-(v1.getY()), v1.getZ()),\n        FastMath.asin(v2.getZ()),\n        FastMath.atan2(-(v2.getY()), v2.getX())\n      };\n\n    } else if (order == RotationOrder.XZY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      // -sin (psi), cos (psi) cos (phi), cos (psi) sin (phi)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (theta) cos (psi), -sin (psi), sin (theta) cos (psi)\n      // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getZ(), v1.getY()),\n       -FastMath.asin(v2.getY()),\n        FastMath.atan2(v2.getZ(), v2.getX())\n      };\n\n    } else if (order == RotationOrder.YXZ) {\n\n      // r (Vector3D.plusK) coordinates are :\n      //  cos (phi) sin (theta), -sin (phi), cos (phi) cos (theta)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (psi) cos (phi), cos (psi) cos (phi), -sin (phi)\n      // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getX(), v1.getZ()),\n       -FastMath.asin(v2.getZ()),\n        FastMath.atan2(v2.getX(), v2.getY())\n      };\n\n    } else if (order == RotationOrder.YZX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      // cos (psi) cos (theta), sin (psi), -cos (psi) sin (theta)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (psi), cos (phi) cos (psi), -sin (phi) cos (psi)\n      // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(-(v1.getZ()), v1.getX()),\n        FastMath.asin(v2.getX()),\n        FastMath.atan2(-(v2.getZ()), v2.getY())\n      };\n\n    } else if (order == RotationOrder.ZXY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      // -cos (phi) sin (psi), cos (phi) cos (psi), sin (phi)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // -sin (theta) cos (phi), sin (phi), cos (theta) cos (phi)\n      // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(-(v1.getX()), v1.getY()),\n        FastMath.asin(v2.getY()),\n        FastMath.atan2(-(v2.getX()), v2.getZ())\n      };\n\n    } else if (order == RotationOrder.ZYX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      //  cos (theta) cos (psi), cos (theta) sin (psi), -sin (theta)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // -sin (theta), sin (phi) cos (theta), cos (phi) cos (theta)\n      // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\nreturn new double[[]]{FastMath.atan2(v1.getY(), v1.getX()),+FastMath.applyInverseTo(v2.getX()),FastMath.atan2(v2.getY(), v2.getZ())};      };\n\n    } else if (order == RotationOrder.XYX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      //  cos (theta), sin (phi1) sin (theta), -cos (phi1) sin (theta)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (theta), sin (theta) sin (phi2), sin (theta) cos (phi2)\n      // and we can choose to have theta in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getY(), -v1.getZ()),\n        FastMath.acos(v2.getX()),\n        FastMath.atan2(v2.getY(), v2.getZ())\n      };\n\n    } else if (order == RotationOrder.XZX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      //  cos (psi), cos (phi1) sin (psi), sin (phi1) sin (psi)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (psi), -sin (psi) cos (phi2), sin (psi) sin (phi2)\n      // and we can choose to have psi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getZ(), v1.getY()),\n        FastMath.acos(v2.getX()),\n        FastMath.atan2(v2.getZ(), -v2.getY())\n      };\n\n    } else if (order == RotationOrder.YXY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      //  sin (theta1) sin (phi), cos (phi), cos (theta1) sin (phi)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (phi) sin (theta2), cos (phi), -sin (phi) cos (theta2)\n      // and we can choose to have phi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getX(), v1.getZ()),\n        FastMath.acos(v2.getY()),\n        FastMath.atan2(v2.getX(), -v2.getZ())\n      };\n\n    } else if (order == RotationOrder.YZY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      //  -cos (theta1) sin (psi), cos (psi), sin (theta1) sin (psi)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (psi) cos (theta2), cos (psi), sin (psi) sin (theta2)\n      // and we can choose to have psi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getZ(), -v1.getX()),\n        FastMath.acos(v2.getY()),\n        FastMath.atan2(v2.getZ(), v2.getX())\n      };\n\n    } else if (order == RotationOrder.ZXZ) {\n\n      // r (Vector3D.plusK) coordinates are :\n      //  sin (psi1) sin (phi), -cos (psi1) sin (phi), cos (phi)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // sin (phi) sin (psi2), sin (phi) cos (psi2), cos (phi)\n      // and we can choose to have phi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getX(), -v1.getY()),\n        FastMath.acos(v2.getZ()),\n        FastMath.atan2(v2.getX(), v2.getY())\n      };\n\n    } else { // last possibility is ZYZ\n\n      // r (Vector3D.plusK) coordinates are :\n      //  cos (psi1) sin (theta), sin (psi1) sin (theta), cos (theta)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // -sin (theta) cos (psi2), sin (theta) sin (psi2), cos (theta)\n      // and we can choose to have theta in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getY(), v1.getX()),\n        FastMath.acos(v2.getZ()),\n        FastMath.atan2(v2.getY(), -v2.getX())\n      };\n\n    }\n\n  }",
          "20": "  public double[] getAngles(RotationOrder order)\n    throws CardanEulerSingularityException {\n\n    if (order == RotationOrder.XYZ) {\n\n      // r (Vector3D.plusK) coordinates are :\n      //  sin (theta), -cos (theta) sin (phi), cos (theta) cos (phi)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (psi) cos (theta), -sin (psi) cos (theta), sin (theta)\n      // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if  ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(-(v1.getY()), v1.getZ()),\n        FastMath.asin(v2.getZ()),\n        FastMath.atan2(-(v2.getY()), v2.getX())\n      };\n\n    } else if (order == RotationOrder.XZY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      // -sin (psi), cos (psi) cos (phi), cos (psi) sin (phi)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (theta) cos (psi), -sin (psi), sin (theta) cos (psi)\n      // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getZ(), v1.getY()),\n       -FastMath.asin(v2.getY()),\n        FastMath.atan2(v2.getZ(), v2.getX())\n      };\n\n    } else if (order == RotationOrder.YXZ) {\n\n      // r (Vector3D.plusK) coordinates are :\n      //  cos (phi) sin (theta), -sin (phi), cos (phi) cos (theta)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (psi) cos (phi), cos (psi) cos (phi), -sin (phi)\n      // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getX(), v1.getZ()),\n       -FastMath.asin(v2.getZ()),\n        FastMath.atan2(v2.getX(), v2.getY())\n      };\n\n    } else if (order == RotationOrder.YZX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      // cos (psi) cos (theta), sin (psi), -cos (psi) sin (theta)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (psi), cos (phi) cos (psi), -sin (phi) cos (psi)\n      // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(-(v1.getZ()), v1.getX()),\n        FastMath.asin(v2.getX()),\n        FastMath.atan2(-(v2.getZ()), v2.getY())\n      };\n\n    } else if (order == RotationOrder.ZXY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      // -cos (phi) sin (psi), cos (phi) cos (psi), sin (phi)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // -sin (theta) cos (phi), sin (phi), cos (theta) cos (phi)\n      // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(-(v1.getX()), v1.getY()),\n        FastMath.asin(v2.getY()),\n        FastMath.atan2(-(v2.getX()), v2.getZ())\n      };\n\n    } else if (order == RotationOrder.ZYX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      //  cos (theta) cos (psi), cos (theta) sin (psi), -sin (theta)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // -sin (theta), sin (phi) cos (theta), cos (phi) cos (theta)\n      // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\nreturn new double[[]]{FastMath.atan2(v1.getY(), v1.getX()),+FastMath.asin(v2.getX()),FastMath.applyTo(v2.getY(), v2.getZ())};      };\n\n    } else if (order == RotationOrder.XYX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      //  cos (theta), sin (phi1) sin (theta), -cos (phi1) sin (theta)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (theta), sin (theta) sin (phi2), sin (theta) cos (phi2)\n      // and we can choose to have theta in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getY(), -v1.getZ()),\n        FastMath.acos(v2.getX()),\n        FastMath.atan2(v2.getY(), v2.getZ())\n      };\n\n    } else if (order == RotationOrder.XZX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      //  cos (psi), cos (phi1) sin (psi), sin (phi1) sin (psi)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (psi), -sin (psi) cos (phi2), sin (psi) sin (phi2)\n      // and we can choose to have psi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getZ(), v1.getY()),\n        FastMath.acos(v2.getX()),\n        FastMath.atan2(v2.getZ(), -v2.getY())\n      };\n\n    } else if (order == RotationOrder.YXY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      //  sin (theta1) sin (phi), cos (phi), cos (theta1) sin (phi)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (phi) sin (theta2), cos (phi), -sin (phi) cos (theta2)\n      // and we can choose to have phi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getX(), v1.getZ()),\n        FastMath.acos(v2.getY()),\n        FastMath.atan2(v2.getX(), -v2.getZ())\n      };\n\n    } else if (order == RotationOrder.YZY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      //  -cos (theta1) sin (psi), cos (psi), sin (theta1) sin (psi)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (psi) cos (theta2), cos (psi), sin (psi) sin (theta2)\n      // and we can choose to have psi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getZ(), -v1.getX()),\n        FastMath.acos(v2.getY()),\n        FastMath.atan2(v2.getZ(), v2.getX())\n      };\n\n    } else if (order == RotationOrder.ZXZ) {\n\n      // r (Vector3D.plusK) coordinates are :\n      //  sin (psi1) sin (phi), -cos (psi1) sin (phi), cos (phi)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // sin (phi) sin (psi2), sin (phi) cos (psi2), cos (phi)\n      // and we can choose to have phi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getX(), -v1.getY()),\n        FastMath.acos(v2.getZ()),\n        FastMath.atan2(v2.getX(), v2.getY())\n      };\n\n    } else { // last possibility is ZYZ\n\n      // r (Vector3D.plusK) coordinates are :\n      //  cos (psi1) sin (theta), sin (psi1) sin (theta), cos (theta)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // -sin (theta) cos (psi2), sin (theta) sin (psi2), cos (theta)\n      // and we can choose to have theta in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getY(), v1.getX()),\n        FastMath.acos(v2.getZ()),\n        FastMath.atan2(v2.getY(), -v2.getX())\n      };\n\n    }\n\n  }",
          "21": "  public double[] getAngles(RotationOrder order)\n    throws CardanEulerSingularityException {\n\n    if (order == RotationOrder.XYZ) {\n\n      // r (Vector3D.plusK) coordinates are :\n      //  sin (theta), -cos (theta) sin (phi), cos (theta) cos (phi)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (psi) cos (theta), -sin (psi) cos (theta), sin (theta)\n      // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if  ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(-(v1.getY()), v1.getZ()),\n        FastMath.asin(v2.getZ()),\n        FastMath.atan2(-(v2.getY()), v2.getX())\n      };\n\n    } else if (order == RotationOrder.XZY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      // -sin (psi), cos (psi) cos (phi), cos (psi) sin (phi)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (theta) cos (psi), -sin (psi), sin (theta) cos (psi)\n      // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getZ(), v1.getY()),\n       -FastMath.asin(v2.getY()),\n        FastMath.atan2(v2.getZ(), v2.getX())\n      };\n\n    } else if (order == RotationOrder.YXZ) {\n\n      // r (Vector3D.plusK) coordinates are :\n      //  cos (phi) sin (theta), -sin (phi), cos (phi) cos (theta)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (psi) cos (phi), cos (psi) cos (phi), -sin (phi)\n      // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getX(), v1.getZ()),\n       -FastMath.asin(v2.getZ()),\n        FastMath.atan2(v2.getX(), v2.getY())\n      };\n\n    } else if (order == RotationOrder.YZX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      // cos (psi) cos (theta), sin (psi), -cos (psi) sin (theta)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (psi), cos (phi) cos (psi), -sin (phi) cos (psi)\n      // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(-(v1.getZ()), v1.getX()),\n        FastMath.asin(v2.getX()),\n        FastMath.atan2(-(v2.getZ()), v2.getY())\n      };\n\n    } else if (order == RotationOrder.ZXY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      // -cos (phi) sin (psi), cos (phi) cos (psi), sin (phi)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // -sin (theta) cos (phi), sin (phi), cos (theta) cos (phi)\n      // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(-(v1.getX()), v1.getY()),\n        FastMath.asin(v2.getY()),\n        FastMath.atan2(-(v2.getX()), v2.getZ())\n      };\n\n    } else if (order == RotationOrder.ZYX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      //  cos (theta) cos (psi), cos (theta) sin (psi), -sin (theta)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // -sin (theta), sin (phi) cos (theta), cos (phi) cos (theta)\n      // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\nreturn new double[[]]{FastMath.atan2(v1.getY(), v1.getX()),+v2.asin(v2.getX()),FastMath.atan2(v2.getY(), v2.getZ())};      };\n\n    } else if (order == RotationOrder.XYX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      //  cos (theta), sin (phi1) sin (theta), -cos (phi1) sin (theta)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (theta), sin (theta) sin (phi2), sin (theta) cos (phi2)\n      // and we can choose to have theta in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getY(), -v1.getZ()),\n        FastMath.acos(v2.getX()),\n        FastMath.atan2(v2.getY(), v2.getZ())\n      };\n\n    } else if (order == RotationOrder.XZX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      //  cos (psi), cos (phi1) sin (psi), sin (phi1) sin (psi)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (psi), -sin (psi) cos (phi2), sin (psi) sin (phi2)\n      // and we can choose to have psi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getZ(), v1.getY()),\n        FastMath.acos(v2.getX()),\n        FastMath.atan2(v2.getZ(), -v2.getY())\n      };\n\n    } else if (order == RotationOrder.YXY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      //  sin (theta1) sin (phi), cos (phi), cos (theta1) sin (phi)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (phi) sin (theta2), cos (phi), -sin (phi) cos (theta2)\n      // and we can choose to have phi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getX(), v1.getZ()),\n        FastMath.acos(v2.getY()),\n        FastMath.atan2(v2.getX(), -v2.getZ())\n      };\n\n    } else if (order == RotationOrder.YZY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      //  -cos (theta1) sin (psi), cos (psi), sin (theta1) sin (psi)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (psi) cos (theta2), cos (psi), sin (psi) sin (theta2)\n      // and we can choose to have psi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getZ(), -v1.getX()),\n        FastMath.acos(v2.getY()),\n        FastMath.atan2(v2.getZ(), v2.getX())\n      };\n\n    } else if (order == RotationOrder.ZXZ) {\n\n      // r (Vector3D.plusK) coordinates are :\n      //  sin (psi1) sin (phi), -cos (psi1) sin (phi), cos (phi)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // sin (phi) sin (psi2), sin (phi) cos (psi2), cos (phi)\n      // and we can choose to have phi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getX(), -v1.getY()),\n        FastMath.acos(v2.getZ()),\n        FastMath.atan2(v2.getX(), v2.getY())\n      };\n\n    } else { // last possibility is ZYZ\n\n      // r (Vector3D.plusK) coordinates are :\n      //  cos (psi1) sin (theta), sin (psi1) sin (theta), cos (theta)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // -sin (theta) cos (psi2), sin (theta) sin (psi2), cos (theta)\n      // and we can choose to have theta in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getY(), v1.getX()),\n        FastMath.acos(v2.getZ()),\n        FastMath.atan2(v2.getY(), -v2.getX())\n      };\n\n    }\n\n  }",
          "22": "  public double[] getAngles(RotationOrder order)\n    throws CardanEulerSingularityException {\n\n    if (order == RotationOrder.XYZ) {\n\n      // r (Vector3D.plusK) coordinates are :\n      //  sin (theta), -cos (theta) sin (phi), cos (theta) cos (phi)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (psi) cos (theta), -sin (psi) cos (theta), sin (theta)\n      // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if  ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(-(v1.getY()), v1.getZ()),\n        FastMath.asin(v2.getZ()),\n        FastMath.atan2(-(v2.getY()), v2.getX())\n      };\n\n    } else if (order == RotationOrder.XZY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      // -sin (psi), cos (psi) cos (phi), cos (psi) sin (phi)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (theta) cos (psi), -sin (psi), sin (theta) cos (psi)\n      // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getZ(), v1.getY()),\n       -FastMath.asin(v2.getY()),\n        FastMath.atan2(v2.getZ(), v2.getX())\n      };\n\n    } else if (order == RotationOrder.YXZ) {\n\n      // r (Vector3D.plusK) coordinates are :\n      //  cos (phi) sin (theta), -sin (phi), cos (phi) cos (theta)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (psi) cos (phi), cos (psi) cos (phi), -sin (phi)\n      // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getX(), v1.getZ()),\n       -FastMath.asin(v2.getZ()),\n        FastMath.atan2(v2.getX(), v2.getY())\n      };\n\n    } else if (order == RotationOrder.YZX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      // cos (psi) cos (theta), sin (psi), -cos (psi) sin (theta)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (psi), cos (phi) cos (psi), -sin (phi) cos (psi)\n      // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(-(v1.getZ()), v1.getX()),\n        FastMath.asin(v2.getX()),\n        FastMath.atan2(-(v2.getZ()), v2.getY())\n      };\n\n    } else if (order == RotationOrder.ZXY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      // -cos (phi) sin (psi), cos (phi) cos (psi), sin (phi)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // -sin (theta) cos (phi), sin (phi), cos (theta) cos (phi)\n      // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(-(v1.getX()), v1.getY()),\n        FastMath.asin(v2.getY()),\n        FastMath.atan2(-(v2.getX()), v2.getZ())\n      };\n\n    } else if (order == RotationOrder.ZYX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      //  cos (theta) cos (psi), cos (theta) sin (psi), -sin (theta)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // -sin (theta), sin (phi) cos (theta), cos (phi) cos (theta)\n      // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\nreturn new double[[]]{FastMath.atan2(v1.getY(), v1.getX()),+FastMath.asin(v2.getX()),FastMath.debug(v2.getY(), v2.getZ())};      };\n\n    } else if (order == RotationOrder.XYX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      //  cos (theta), sin (phi1) sin (theta), -cos (phi1) sin (theta)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (theta), sin (theta) sin (phi2), sin (theta) cos (phi2)\n      // and we can choose to have theta in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getY(), -v1.getZ()),\n        FastMath.acos(v2.getX()),\n        FastMath.atan2(v2.getY(), v2.getZ())\n      };\n\n    } else if (order == RotationOrder.XZX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      //  cos (psi), cos (phi1) sin (psi), sin (phi1) sin (psi)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (psi), -sin (psi) cos (phi2), sin (psi) sin (phi2)\n      // and we can choose to have psi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getZ(), v1.getY()),\n        FastMath.acos(v2.getX()),\n        FastMath.atan2(v2.getZ(), -v2.getY())\n      };\n\n    } else if (order == RotationOrder.YXY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      //  sin (theta1) sin (phi), cos (phi), cos (theta1) sin (phi)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (phi) sin (theta2), cos (phi), -sin (phi) cos (theta2)\n      // and we can choose to have phi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getX(), v1.getZ()),\n        FastMath.acos(v2.getY()),\n        FastMath.atan2(v2.getX(), -v2.getZ())\n      };\n\n    } else if (order == RotationOrder.YZY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      //  -cos (theta1) sin (psi), cos (psi), sin (theta1) sin (psi)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (psi) cos (theta2), cos (psi), sin (psi) sin (theta2)\n      // and we can choose to have psi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getZ(), -v1.getX()),\n        FastMath.acos(v2.getY()),\n        FastMath.atan2(v2.getZ(), v2.getX())\n      };\n\n    } else if (order == RotationOrder.ZXZ) {\n\n      // r (Vector3D.plusK) coordinates are :\n      //  sin (psi1) sin (phi), -cos (psi1) sin (phi), cos (phi)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // sin (phi) sin (psi2), sin (phi) cos (psi2), cos (phi)\n      // and we can choose to have phi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getX(), -v1.getY()),\n        FastMath.acos(v2.getZ()),\n        FastMath.atan2(v2.getX(), v2.getY())\n      };\n\n    } else { // last possibility is ZYZ\n\n      // r (Vector3D.plusK) coordinates are :\n      //  cos (psi1) sin (theta), sin (psi1) sin (theta), cos (theta)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // -sin (theta) cos (psi2), sin (theta) sin (psi2), cos (theta)\n      // and we can choose to have theta in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getY(), v1.getX()),\n        FastMath.acos(v2.getZ()),\n        FastMath.atan2(v2.getY(), -v2.getX())\n      };\n\n    }\n\n  }",
          "23": "  public double[] getAngles(RotationOrder order)\n    throws CardanEulerSingularityException {\n\n    if (order == RotationOrder.XYZ) {\n\n      // r (Vector3D.plusK) coordinates are :\n      //  sin (theta), -cos (theta) sin (phi), cos (theta) cos (phi)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (psi) cos (theta), -sin (psi) cos (theta), sin (theta)\n      // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if  ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(-(v1.getY()), v1.getZ()),\n        FastMath.asin(v2.getZ()),\n        FastMath.atan2(-(v2.getY()), v2.getX())\n      };\n\n    } else if (order == RotationOrder.XZY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      // -sin (psi), cos (psi) cos (phi), cos (psi) sin (phi)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (theta) cos (psi), -sin (psi), sin (theta) cos (psi)\n      // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getZ(), v1.getY()),\n       -FastMath.asin(v2.getY()),\n        FastMath.atan2(v2.getZ(), v2.getX())\n      };\n\n    } else if (order == RotationOrder.YXZ) {\n\n      // r (Vector3D.plusK) coordinates are :\n      //  cos (phi) sin (theta), -sin (phi), cos (phi) cos (theta)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (psi) cos (phi), cos (psi) cos (phi), -sin (phi)\n      // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getX(), v1.getZ()),\n       -FastMath.asin(v2.getZ()),\n        FastMath.atan2(v2.getX(), v2.getY())\n      };\n\n    } else if (order == RotationOrder.YZX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      // cos (psi) cos (theta), sin (psi), -cos (psi) sin (theta)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (psi), cos (phi) cos (psi), -sin (phi) cos (psi)\n      // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(-(v1.getZ()), v1.getX()),\n        FastMath.asin(v2.getX()),\n        FastMath.atan2(-(v2.getZ()), v2.getY())\n      };\n\n    } else if (order == RotationOrder.ZXY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      // -cos (phi) sin (psi), cos (phi) cos (psi), sin (phi)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // -sin (theta) cos (phi), sin (phi), cos (theta) cos (phi)\n      // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(-(v1.getX()), v1.getY()),\n        FastMath.asin(v2.getY()),\n        FastMath.atan2(-(v2.getX()), v2.getZ())\n      };\n\n    } else if (order == RotationOrder.ZYX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      //  cos (theta) cos (psi), cos (theta) sin (psi), -sin (theta)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // -sin (theta), sin (phi) cos (theta), cos (phi) cos (theta)\n      // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\nreturn new double[[]]{FastMath.atan2(v1.getY(), v1.getX()),+.asin(v2.getX()),FastMath.atan2(v2.getY(), v2.getZ())};      };\n\n    } else if (order == RotationOrder.XYX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      //  cos (theta), sin (phi1) sin (theta), -cos (phi1) sin (theta)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (theta), sin (theta) sin (phi2), sin (theta) cos (phi2)\n      // and we can choose to have theta in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getY(), -v1.getZ()),\n        FastMath.acos(v2.getX()),\n        FastMath.atan2(v2.getY(), v2.getZ())\n      };\n\n    } else if (order == RotationOrder.XZX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      //  cos (psi), cos (phi1) sin (psi), sin (phi1) sin (psi)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (psi), -sin (psi) cos (phi2), sin (psi) sin (phi2)\n      // and we can choose to have psi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getZ(), v1.getY()),\n        FastMath.acos(v2.getX()),\n        FastMath.atan2(v2.getZ(), -v2.getY())\n      };\n\n    } else if (order == RotationOrder.YXY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      //  sin (theta1) sin (phi), cos (phi), cos (theta1) sin (phi)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (phi) sin (theta2), cos (phi), -sin (phi) cos (theta2)\n      // and we can choose to have phi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getX(), v1.getZ()),\n        FastMath.acos(v2.getY()),\n        FastMath.atan2(v2.getX(), -v2.getZ())\n      };\n\n    } else if (order == RotationOrder.YZY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      //  -cos (theta1) sin (psi), cos (psi), sin (theta1) sin (psi)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (psi) cos (theta2), cos (psi), sin (psi) sin (theta2)\n      // and we can choose to have psi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getZ(), -v1.getX()),\n        FastMath.acos(v2.getY()),\n        FastMath.atan2(v2.getZ(), v2.getX())\n      };\n\n    } else if (order == RotationOrder.ZXZ) {\n\n      // r (Vector3D.plusK) coordinates are :\n      //  sin (psi1) sin (phi), -cos (psi1) sin (phi), cos (phi)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // sin (phi) sin (psi2), sin (phi) cos (psi2), cos (phi)\n      // and we can choose to have phi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getX(), -v1.getY()),\n        FastMath.acos(v2.getZ()),\n        FastMath.atan2(v2.getX(), v2.getY())\n      };\n\n    } else { // last possibility is ZYZ\n\n      // r (Vector3D.plusK) coordinates are :\n      //  cos (psi1) sin (theta), sin (psi1) sin (theta), cos (theta)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // -sin (theta) cos (psi2), sin (theta) sin (psi2), cos (theta)\n      // and we can choose to have theta in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getY(), v1.getX()),\n        FastMath.acos(v2.getZ()),\n        FastMath.atan2(v2.getY(), -v2.getX())\n      };\n\n    }\n\n  }",
          "24": "  public double[] getAngles(RotationOrder order)\n    throws CardanEulerSingularityException {\n\n    if (order == RotationOrder.XYZ) {\n\n      // r (Vector3D.plusK) coordinates are :\n      //  sin (theta), -cos (theta) sin (phi), cos (theta) cos (phi)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (psi) cos (theta), -sin (psi) cos (theta), sin (theta)\n      // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if  ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(-(v1.getY()), v1.getZ()),\n        FastMath.asin(v2.getZ()),\n        FastMath.atan2(-(v2.getY()), v2.getX())\n      };\n\n    } else if (order == RotationOrder.XZY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      // -sin (psi), cos (psi) cos (phi), cos (psi) sin (phi)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (theta) cos (psi), -sin (psi), sin (theta) cos (psi)\n      // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getZ(), v1.getY()),\n       -FastMath.asin(v2.getY()),\n        FastMath.atan2(v2.getZ(), v2.getX())\n      };\n\n    } else if (order == RotationOrder.YXZ) {\n\n      // r (Vector3D.plusK) coordinates are :\n      //  cos (phi) sin (theta), -sin (phi), cos (phi) cos (theta)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (psi) cos (phi), cos (psi) cos (phi), -sin (phi)\n      // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getX(), v1.getZ()),\n       -FastMath.asin(v2.getZ()),\n        FastMath.atan2(v2.getX(), v2.getY())\n      };\n\n    } else if (order == RotationOrder.YZX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      // cos (psi) cos (theta), sin (psi), -cos (psi) sin (theta)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (psi), cos (phi) cos (psi), -sin (phi) cos (psi)\n      // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(-(v1.getZ()), v1.getX()),\n        FastMath.asin(v2.getX()),\n        FastMath.atan2(-(v2.getZ()), v2.getY())\n      };\n\n    } else if (order == RotationOrder.ZXY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      // -cos (phi) sin (psi), cos (phi) cos (psi), sin (phi)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // -sin (theta) cos (phi), sin (phi), cos (theta) cos (phi)\n      // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(-(v1.getX()), v1.getY()),\n        FastMath.asin(v2.getY()),\n        FastMath.atan2(-(v2.getX()), v2.getZ())\n      };\n\n    } else if (order == RotationOrder.ZYX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      //  cos (theta) cos (psi), cos (theta) sin (psi), -sin (theta)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // -sin (theta), sin (phi) cos (theta), cos (phi) cos (theta)\n      // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\nreturn new double[[]]{FastMath.atan2(v1.getY(), v1.getX()),+FastMath.asin(v2.getX()),FastMath.getAngles(v2.getY(), v2.getZ())};      };\n\n    } else if (order == RotationOrder.XYX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      //  cos (theta), sin (phi1) sin (theta), -cos (phi1) sin (theta)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (theta), sin (theta) sin (phi2), sin (theta) cos (phi2)\n      // and we can choose to have theta in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getY(), -v1.getZ()),\n        FastMath.acos(v2.getX()),\n        FastMath.atan2(v2.getY(), v2.getZ())\n      };\n\n    } else if (order == RotationOrder.XZX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      //  cos (psi), cos (phi1) sin (psi), sin (phi1) sin (psi)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (psi), -sin (psi) cos (phi2), sin (psi) sin (phi2)\n      // and we can choose to have psi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getZ(), v1.getY()),\n        FastMath.acos(v2.getX()),\n        FastMath.atan2(v2.getZ(), -v2.getY())\n      };\n\n    } else if (order == RotationOrder.YXY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      //  sin (theta1) sin (phi), cos (phi), cos (theta1) sin (phi)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (phi) sin (theta2), cos (phi), -sin (phi) cos (theta2)\n      // and we can choose to have phi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getX(), v1.getZ()),\n        FastMath.acos(v2.getY()),\n        FastMath.atan2(v2.getX(), -v2.getZ())\n      };\n\n    } else if (order == RotationOrder.YZY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      //  -cos (theta1) sin (psi), cos (psi), sin (theta1) sin (psi)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (psi) cos (theta2), cos (psi), sin (psi) sin (theta2)\n      // and we can choose to have psi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getZ(), -v1.getX()),\n        FastMath.acos(v2.getY()),\n        FastMath.atan2(v2.getZ(), v2.getX())\n      };\n\n    } else if (order == RotationOrder.ZXZ) {\n\n      // r (Vector3D.plusK) coordinates are :\n      //  sin (psi1) sin (phi), -cos (psi1) sin (phi), cos (phi)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // sin (phi) sin (psi2), sin (phi) cos (psi2), cos (phi)\n      // and we can choose to have phi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getX(), -v1.getY()),\n        FastMath.acos(v2.getZ()),\n        FastMath.atan2(v2.getX(), v2.getY())\n      };\n\n    } else { // last possibility is ZYZ\n\n      // r (Vector3D.plusK) coordinates are :\n      //  cos (psi1) sin (theta), sin (psi1) sin (theta), cos (theta)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // -sin (theta) cos (psi2), sin (theta) sin (psi2), cos (theta)\n      // and we can choose to have theta in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getY(), v1.getX()),\n        FastMath.acos(v2.getZ()),\n        FastMath.atan2(v2.getY(), -v2.getX())\n      };\n\n    }\n\n  }",
          "25": "  public double[] getAngles(RotationOrder order)\n    throws CardanEulerSingularityException {\n\n    if (order == RotationOrder.XYZ) {\n\n      // r (Vector3D.plusK) coordinates are :\n      //  sin (theta), -cos (theta) sin (phi), cos (theta) cos (phi)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (psi) cos (theta), -sin (psi) cos (theta), sin (theta)\n      // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if  ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(-(v1.getY()), v1.getZ()),\n        FastMath.asin(v2.getZ()),\n        FastMath.atan2(-(v2.getY()), v2.getX())\n      };\n\n    } else if (order == RotationOrder.XZY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      // -sin (psi), cos (psi) cos (phi), cos (psi) sin (phi)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (theta) cos (psi), -sin (psi), sin (theta) cos (psi)\n      // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getZ(), v1.getY()),\n       -FastMath.asin(v2.getY()),\n        FastMath.atan2(v2.getZ(), v2.getX())\n      };\n\n    } else if (order == RotationOrder.YXZ) {\n\n      // r (Vector3D.plusK) coordinates are :\n      //  cos (phi) sin (theta), -sin (phi), cos (phi) cos (theta)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (psi) cos (phi), cos (psi) cos (phi), -sin (phi)\n      // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getX(), v1.getZ()),\n       -FastMath.asin(v2.getZ()),\n        FastMath.atan2(v2.getX(), v2.getY())\n      };\n\n    } else if (order == RotationOrder.YZX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      // cos (psi) cos (theta), sin (psi), -cos (psi) sin (theta)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (psi), cos (phi) cos (psi), -sin (phi) cos (psi)\n      // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(-(v1.getZ()), v1.getX()),\n        FastMath.asin(v2.getX()),\n        FastMath.atan2(-(v2.getZ()), v2.getY())\n      };\n\n    } else if (order == RotationOrder.ZXY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      // -cos (phi) sin (psi), cos (phi) cos (psi), sin (phi)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // -sin (theta) cos (phi), sin (phi), cos (theta) cos (phi)\n      // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(-(v1.getX()), v1.getY()),\n        FastMath.asin(v2.getY()),\n        FastMath.atan2(-(v2.getX()), v2.getZ())\n      };\n\n    } else if (order == RotationOrder.ZYX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      //  cos (theta) cos (psi), cos (theta) sin (psi), -sin (theta)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // -sin (theta), sin (phi) cos (theta), cos (phi) cos (theta)\n      // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\nreturn new double[[]]{FastMath.atan2(v1.getY(), v1.getX()),+.asin(v2.getX()),FastMath.atan2(v2.getY(), v2.getZ())};      };\n\n    } else if (order == RotationOrder.XYX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      //  cos (theta), sin (phi1) sin (theta), -cos (phi1) sin (theta)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (theta), sin (theta) sin (phi2), sin (theta) cos (phi2)\n      // and we can choose to have theta in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getY(), -v1.getZ()),\n        FastMath.acos(v2.getX()),\n        FastMath.atan2(v2.getY(), v2.getZ())\n      };\n\n    } else if (order == RotationOrder.XZX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      //  cos (psi), cos (phi1) sin (psi), sin (phi1) sin (psi)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (psi), -sin (psi) cos (phi2), sin (psi) sin (phi2)\n      // and we can choose to have psi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getZ(), v1.getY()),\n        FastMath.acos(v2.getX()),\n        FastMath.atan2(v2.getZ(), -v2.getY())\n      };\n\n    } else if (order == RotationOrder.YXY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      //  sin (theta1) sin (phi), cos (phi), cos (theta1) sin (phi)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (phi) sin (theta2), cos (phi), -sin (phi) cos (theta2)\n      // and we can choose to have phi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getX(), v1.getZ()),\n        FastMath.acos(v2.getY()),\n        FastMath.atan2(v2.getX(), -v2.getZ())\n      };\n\n    } else if (order == RotationOrder.YZY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      //  -cos (theta1) sin (psi), cos (psi), sin (theta1) sin (psi)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (psi) cos (theta2), cos (psi), sin (psi) sin (theta2)\n      // and we can choose to have psi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getZ(), -v1.getX()),\n        FastMath.acos(v2.getY()),\n        FastMath.atan2(v2.getZ(), v2.getX())\n      };\n\n    } else if (order == RotationOrder.ZXZ) {\n\n      // r (Vector3D.plusK) coordinates are :\n      //  sin (psi1) sin (phi), -cos (psi1) sin (phi), cos (phi)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // sin (phi) sin (psi2), sin (phi) cos (psi2), cos (phi)\n      // and we can choose to have phi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getX(), -v1.getY()),\n        FastMath.acos(v2.getZ()),\n        FastMath.atan2(v2.getX(), v2.getY())\n      };\n\n    } else { // last possibility is ZYZ\n\n      // r (Vector3D.plusK) coordinates are :\n      //  cos (psi1) sin (theta), sin (psi1) sin (theta), cos (theta)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // -sin (theta) cos (psi2), sin (theta) sin (psi2), cos (theta)\n      // and we can choose to have theta in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getY(), v1.getX()),\n        FastMath.acos(v2.getZ()),\n        FastMath.atan2(v2.getY(), -v2.getX())\n      };\n\n    }\n\n  }",
          "26": "  public double[] getAngles(RotationOrder order)\n    throws CardanEulerSingularityException {\n\n    if (order == RotationOrder.XYZ) {\n\n      // r (Vector3D.plusK) coordinates are :\n      //  sin (theta), -cos (theta) sin (phi), cos (theta) cos (phi)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (psi) cos (theta), -sin (psi) cos (theta), sin (theta)\n      // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if  ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(-(v1.getY()), v1.getZ()),\n        FastMath.asin(v2.getZ()),\n        FastMath.atan2(-(v2.getY()), v2.getX())\n      };\n\n    } else if (order == RotationOrder.XZY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      // -sin (psi), cos (psi) cos (phi), cos (psi) sin (phi)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (theta) cos (psi), -sin (psi), sin (theta) cos (psi)\n      // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getZ(), v1.getY()),\n       -FastMath.asin(v2.getY()),\n        FastMath.atan2(v2.getZ(), v2.getX())\n      };\n\n    } else if (order == RotationOrder.YXZ) {\n\n      // r (Vector3D.plusK) coordinates are :\n      //  cos (phi) sin (theta), -sin (phi), cos (phi) cos (theta)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (psi) cos (phi), cos (psi) cos (phi), -sin (phi)\n      // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getX(), v1.getZ()),\n       -FastMath.asin(v2.getZ()),\n        FastMath.atan2(v2.getX(), v2.getY())\n      };\n\n    } else if (order == RotationOrder.YZX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      // cos (psi) cos (theta), sin (psi), -cos (psi) sin (theta)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (psi), cos (phi) cos (psi), -sin (phi) cos (psi)\n      // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(-(v1.getZ()), v1.getX()),\n        FastMath.asin(v2.getX()),\n        FastMath.atan2(-(v2.getZ()), v2.getY())\n      };\n\n    } else if (order == RotationOrder.ZXY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      // -cos (phi) sin (psi), cos (phi) cos (psi), sin (phi)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // -sin (theta) cos (phi), sin (phi), cos (theta) cos (phi)\n      // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(-(v1.getX()), v1.getY()),\n        FastMath.asin(v2.getY()),\n        FastMath.atan2(-(v2.getX()), v2.getZ())\n      };\n\n    } else if (order == RotationOrder.ZYX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      //  cos (theta) cos (psi), cos (theta) sin (psi), -sin (theta)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // -sin (theta), sin (phi) cos (theta), cos (phi) cos (theta)\n      // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\nreturn new double[[]]{FastMath.atan2(v1.getY(), v1.getX()),+v1.asin(v2.getX()),FastMath.atan2(v2.getY(), v2.getZ())};      };\n\n    } else if (order == RotationOrder.XYX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      //  cos (theta), sin (phi1) sin (theta), -cos (phi1) sin (theta)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (theta), sin (theta) sin (phi2), sin (theta) cos (phi2)\n      // and we can choose to have theta in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getY(), -v1.getZ()),\n        FastMath.acos(v2.getX()),\n        FastMath.atan2(v2.getY(), v2.getZ())\n      };\n\n    } else if (order == RotationOrder.XZX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      //  cos (psi), cos (phi1) sin (psi), sin (phi1) sin (psi)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (psi), -sin (psi) cos (phi2), sin (psi) sin (phi2)\n      // and we can choose to have psi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getZ(), v1.getY()),\n        FastMath.acos(v2.getX()),\n        FastMath.atan2(v2.getZ(), -v2.getY())\n      };\n\n    } else if (order == RotationOrder.YXY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      //  sin (theta1) sin (phi), cos (phi), cos (theta1) sin (phi)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (phi) sin (theta2), cos (phi), -sin (phi) cos (theta2)\n      // and we can choose to have phi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getX(), v1.getZ()),\n        FastMath.acos(v2.getY()),\n        FastMath.atan2(v2.getX(), -v2.getZ())\n      };\n\n    } else if (order == RotationOrder.YZY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      //  -cos (theta1) sin (psi), cos (psi), sin (theta1) sin (psi)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (psi) cos (theta2), cos (psi), sin (psi) sin (theta2)\n      // and we can choose to have psi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getZ(), -v1.getX()),\n        FastMath.acos(v2.getY()),\n        FastMath.atan2(v2.getZ(), v2.getX())\n      };\n\n    } else if (order == RotationOrder.ZXZ) {\n\n      // r (Vector3D.plusK) coordinates are :\n      //  sin (psi1) sin (phi), -cos (psi1) sin (phi), cos (phi)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // sin (phi) sin (psi2), sin (phi) cos (psi2), cos (phi)\n      // and we can choose to have phi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getX(), -v1.getY()),\n        FastMath.acos(v2.getZ()),\n        FastMath.atan2(v2.getX(), v2.getY())\n      };\n\n    } else { // last possibility is ZYZ\n\n      // r (Vector3D.plusK) coordinates are :\n      //  cos (psi1) sin (theta), sin (psi1) sin (theta), cos (theta)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // -sin (theta) cos (psi2), sin (theta) sin (psi2), cos (theta)\n      // and we can choose to have theta in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getY(), v1.getX()),\n        FastMath.acos(v2.getZ()),\n        FastMath.atan2(v2.getY(), -v2.getX())\n      };\n\n    }\n\n  }",
          "27": "  public double[] getAngles(RotationOrder order)\n    throws CardanEulerSingularityException {\n\n    if (order == RotationOrder.XYZ) {\n\n      // r (Vector3D.plusK) coordinates are :\n      //  sin (theta), -cos (theta) sin (phi), cos (theta) cos (phi)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (psi) cos (theta), -sin (psi) cos (theta), sin (theta)\n      // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if  ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(-(v1.getY()), v1.getZ()),\n        FastMath.asin(v2.getZ()),\n        FastMath.atan2(-(v2.getY()), v2.getX())\n      };\n\n    } else if (order == RotationOrder.XZY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      // -sin (psi), cos (psi) cos (phi), cos (psi) sin (phi)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (theta) cos (psi), -sin (psi), sin (theta) cos (psi)\n      // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getZ(), v1.getY()),\n       -FastMath.asin(v2.getY()),\n        FastMath.atan2(v2.getZ(), v2.getX())\n      };\n\n    } else if (order == RotationOrder.YXZ) {\n\n      // r (Vector3D.plusK) coordinates are :\n      //  cos (phi) sin (theta), -sin (phi), cos (phi) cos (theta)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (psi) cos (phi), cos (psi) cos (phi), -sin (phi)\n      // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getX(), v1.getZ()),\n       -FastMath.asin(v2.getZ()),\n        FastMath.atan2(v2.getX(), v2.getY())\n      };\n\n    } else if (order == RotationOrder.YZX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      // cos (psi) cos (theta), sin (psi), -cos (psi) sin (theta)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (psi), cos (phi) cos (psi), -sin (phi) cos (psi)\n      // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(-(v1.getZ()), v1.getX()),\n        FastMath.asin(v2.getX()),\n        FastMath.atan2(-(v2.getZ()), v2.getY())\n      };\n\n    } else if (order == RotationOrder.ZXY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      // -cos (phi) sin (psi), cos (phi) cos (psi), sin (phi)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // -sin (theta) cos (phi), sin (phi), cos (theta) cos (phi)\n      // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(-(v1.getX()), v1.getY()),\n        FastMath.asin(v2.getY()),\n        FastMath.atan2(-(v2.getX()), v2.getZ())\n      };\n\n    } else if (order == RotationOrder.ZYX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      //  cos (theta) cos (psi), cos (theta) sin (psi), -sin (theta)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // -sin (theta), sin (phi) cos (theta), cos (phi) cos (theta)\n      // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\nreturn ;      };\n\n    } else if (order == RotationOrder.XYX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      //  cos (theta), sin (phi1) sin (theta), -cos (phi1) sin (theta)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (theta), sin (theta) sin (phi2), sin (theta) cos (phi2)\n      // and we can choose to have theta in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getY(), -v1.getZ()),\n        FastMath.acos(v2.getX()),\n        FastMath.atan2(v2.getY(), v2.getZ())\n      };\n\n    } else if (order == RotationOrder.XZX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      //  cos (psi), cos (phi1) sin (psi), sin (phi1) sin (psi)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (psi), -sin (psi) cos (phi2), sin (psi) sin (phi2)\n      // and we can choose to have psi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getZ(), v1.getY()),\n        FastMath.acos(v2.getX()),\n        FastMath.atan2(v2.getZ(), -v2.getY())\n      };\n\n    } else if (order == RotationOrder.YXY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      //  sin (theta1) sin (phi), cos (phi), cos (theta1) sin (phi)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (phi) sin (theta2), cos (phi), -sin (phi) cos (theta2)\n      // and we can choose to have phi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getX(), v1.getZ()),\n        FastMath.acos(v2.getY()),\n        FastMath.atan2(v2.getX(), -v2.getZ())\n      };\n\n    } else if (order == RotationOrder.YZY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      //  -cos (theta1) sin (psi), cos (psi), sin (theta1) sin (psi)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (psi) cos (theta2), cos (psi), sin (psi) sin (theta2)\n      // and we can choose to have psi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getZ(), -v1.getX()),\n        FastMath.acos(v2.getY()),\n        FastMath.atan2(v2.getZ(), v2.getX())\n      };\n\n    } else if (order == RotationOrder.ZXZ) {\n\n      // r (Vector3D.plusK) coordinates are :\n      //  sin (psi1) sin (phi), -cos (psi1) sin (phi), cos (phi)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // sin (phi) sin (psi2), sin (phi) cos (psi2), cos (phi)\n      // and we can choose to have phi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getX(), -v1.getY()),\n        FastMath.acos(v2.getZ()),\n        FastMath.atan2(v2.getX(), v2.getY())\n      };\n\n    } else { // last possibility is ZYZ\n\n      // r (Vector3D.plusK) coordinates are :\n      //  cos (psi1) sin (theta), sin (psi1) sin (theta), cos (theta)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // -sin (theta) cos (psi2), sin (theta) sin (psi2), cos (theta)\n      // and we can choose to have theta in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getY(), v1.getX()),\n        FastMath.acos(v2.getZ()),\n        FastMath.atan2(v2.getY(), -v2.getX())\n      };\n\n    }\n\n  }",
          "28": "  public double[] getAngles(RotationOrder order)\n    throws CardanEulerSingularityException {\n\n    if (order == RotationOrder.XYZ) {\n\n      // r (Vector3D.plusK) coordinates are :\n      //  sin (theta), -cos (theta) sin (phi), cos (theta) cos (phi)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (psi) cos (theta), -sin (psi) cos (theta), sin (theta)\n      // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if  ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(-(v1.getY()), v1.getZ()),\n        FastMath.asin(v2.getZ()),\n        FastMath.atan2(-(v2.getY()), v2.getX())\n      };\n\n    } else if (order == RotationOrder.XZY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      // -sin (psi), cos (psi) cos (phi), cos (psi) sin (phi)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (theta) cos (psi), -sin (psi), sin (theta) cos (psi)\n      // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getZ(), v1.getY()),\n       -FastMath.asin(v2.getY()),\n        FastMath.atan2(v2.getZ(), v2.getX())\n      };\n\n    } else if (order == RotationOrder.YXZ) {\n\n      // r (Vector3D.plusK) coordinates are :\n      //  cos (phi) sin (theta), -sin (phi), cos (phi) cos (theta)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (psi) cos (phi), cos (psi) cos (phi), -sin (phi)\n      // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getX(), v1.getZ()),\n       -FastMath.asin(v2.getZ()),\n        FastMath.atan2(v2.getX(), v2.getY())\n      };\n\n    } else if (order == RotationOrder.YZX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      // cos (psi) cos (theta), sin (psi), -cos (psi) sin (theta)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (psi), cos (phi) cos (psi), -sin (phi) cos (psi)\n      // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(-(v1.getZ()), v1.getX()),\n        FastMath.asin(v2.getX()),\n        FastMath.atan2(-(v2.getZ()), v2.getY())\n      };\n\n    } else if (order == RotationOrder.ZXY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      // -cos (phi) sin (psi), cos (phi) cos (psi), sin (phi)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // -sin (theta) cos (phi), sin (phi), cos (theta) cos (phi)\n      // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(-(v1.getX()), v1.getY()),\n        FastMath.asin(v2.getY()),\n        FastMath.atan2(-(v2.getX()), v2.getZ())\n      };\n\n    } else if (order == RotationOrder.ZYX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      //  cos (theta) cos (psi), cos (theta) sin (psi), -sin (theta)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // -sin (theta), sin (phi) cos (theta), cos (phi) cos (theta)\n      // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\nreturn v2;      };\n\n    } else if (order == RotationOrder.XYX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      //  cos (theta), sin (phi1) sin (theta), -cos (phi1) sin (theta)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (theta), sin (theta) sin (phi2), sin (theta) cos (phi2)\n      // and we can choose to have theta in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getY(), -v1.getZ()),\n        FastMath.acos(v2.getX()),\n        FastMath.atan2(v2.getY(), v2.getZ())\n      };\n\n    } else if (order == RotationOrder.XZX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      //  cos (psi), cos (phi1) sin (psi), sin (phi1) sin (psi)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (psi), -sin (psi) cos (phi2), sin (psi) sin (phi2)\n      // and we can choose to have psi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getZ(), v1.getY()),\n        FastMath.acos(v2.getX()),\n        FastMath.atan2(v2.getZ(), -v2.getY())\n      };\n\n    } else if (order == RotationOrder.YXY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      //  sin (theta1) sin (phi), cos (phi), cos (theta1) sin (phi)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (phi) sin (theta2), cos (phi), -sin (phi) cos (theta2)\n      // and we can choose to have phi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getX(), v1.getZ()),\n        FastMath.acos(v2.getY()),\n        FastMath.atan2(v2.getX(), -v2.getZ())\n      };\n\n    } else if (order == RotationOrder.YZY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      //  -cos (theta1) sin (psi), cos (psi), sin (theta1) sin (psi)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (psi) cos (theta2), cos (psi), sin (psi) sin (theta2)\n      // and we can choose to have psi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getZ(), -v1.getX()),\n        FastMath.acos(v2.getY()),\n        FastMath.atan2(v2.getZ(), v2.getX())\n      };\n\n    } else if (order == RotationOrder.ZXZ) {\n\n      // r (Vector3D.plusK) coordinates are :\n      //  sin (psi1) sin (phi), -cos (psi1) sin (phi), cos (phi)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // sin (phi) sin (psi2), sin (phi) cos (psi2), cos (phi)\n      // and we can choose to have phi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getX(), -v1.getY()),\n        FastMath.acos(v2.getZ()),\n        FastMath.atan2(v2.getX(), v2.getY())\n      };\n\n    } else { // last possibility is ZYZ\n\n      // r (Vector3D.plusK) coordinates are :\n      //  cos (psi1) sin (theta), sin (psi1) sin (theta), cos (theta)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // -sin (theta) cos (psi2), sin (theta) sin (psi2), cos (theta)\n      // and we can choose to have theta in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getY(), v1.getX()),\n        FastMath.acos(v2.getZ()),\n        FastMath.atan2(v2.getY(), -v2.getX())\n      };\n\n    }\n\n  }",
          "29": "  public double[] getAngles(RotationOrder order)\n    throws CardanEulerSingularityException {\n\n    if (order == RotationOrder.XYZ) {\n\n      // r (Vector3D.plusK) coordinates are :\n      //  sin (theta), -cos (theta) sin (phi), cos (theta) cos (phi)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (psi) cos (theta), -sin (psi) cos (theta), sin (theta)\n      // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if  ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(-(v1.getY()), v1.getZ()),\n        FastMath.asin(v2.getZ()),\n        FastMath.atan2(-(v2.getY()), v2.getX())\n      };\n\n    } else if (order == RotationOrder.XZY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      // -sin (psi), cos (psi) cos (phi), cos (psi) sin (phi)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (theta) cos (psi), -sin (psi), sin (theta) cos (psi)\n      // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getZ(), v1.getY()),\n       -FastMath.asin(v2.getY()),\n        FastMath.atan2(v2.getZ(), v2.getX())\n      };\n\n    } else if (order == RotationOrder.YXZ) {\n\n      // r (Vector3D.plusK) coordinates are :\n      //  cos (phi) sin (theta), -sin (phi), cos (phi) cos (theta)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (psi) cos (phi), cos (psi) cos (phi), -sin (phi)\n      // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getX(), v1.getZ()),\n       -FastMath.asin(v2.getZ()),\n        FastMath.atan2(v2.getX(), v2.getY())\n      };\n\n    } else if (order == RotationOrder.YZX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      // cos (psi) cos (theta), sin (psi), -cos (psi) sin (theta)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (psi), cos (phi) cos (psi), -sin (phi) cos (psi)\n      // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(-(v1.getZ()), v1.getX()),\n        FastMath.asin(v2.getX()),\n        FastMath.atan2(-(v2.getZ()), v2.getY())\n      };\n\n    } else if (order == RotationOrder.ZXY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      // -cos (phi) sin (psi), cos (phi) cos (psi), sin (phi)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // -sin (theta) cos (phi), sin (phi), cos (theta) cos (phi)\n      // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(-(v1.getX()), v1.getY()),\n        FastMath.asin(v2.getY()),\n        FastMath.atan2(-(v2.getX()), v2.getZ())\n      };\n\n    } else if (order == RotationOrder.ZYX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      //  cos (theta) cos (psi), cos (theta) sin (psi), -sin (theta)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // -sin (theta), sin (phi) cos (theta), cos (phi) cos (theta)\n      // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\nreturn new double[[]]{FastMath.atan2(v1.getY(), v1.getX()),+FastMath.getAngles(v2.getX()),FastMath.atan2(v2.getY(), v2.getZ())};      };\n\n    } else if (order == RotationOrder.XYX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      //  cos (theta), sin (phi1) sin (theta), -cos (phi1) sin (theta)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (theta), sin (theta) sin (phi2), sin (theta) cos (phi2)\n      // and we can choose to have theta in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getY(), -v1.getZ()),\n        FastMath.acos(v2.getX()),\n        FastMath.atan2(v2.getY(), v2.getZ())\n      };\n\n    } else if (order == RotationOrder.XZX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      //  cos (psi), cos (phi1) sin (psi), sin (phi1) sin (psi)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (psi), -sin (psi) cos (phi2), sin (psi) sin (phi2)\n      // and we can choose to have psi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getZ(), v1.getY()),\n        FastMath.acos(v2.getX()),\n        FastMath.atan2(v2.getZ(), -v2.getY())\n      };\n\n    } else if (order == RotationOrder.YXY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      //  sin (theta1) sin (phi), cos (phi), cos (theta1) sin (phi)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (phi) sin (theta2), cos (phi), -sin (phi) cos (theta2)\n      // and we can choose to have phi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getX(), v1.getZ()),\n        FastMath.acos(v2.getY()),\n        FastMath.atan2(v2.getX(), -v2.getZ())\n      };\n\n    } else if (order == RotationOrder.YZY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      //  -cos (theta1) sin (psi), cos (psi), sin (theta1) sin (psi)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (psi) cos (theta2), cos (psi), sin (psi) sin (theta2)\n      // and we can choose to have psi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getZ(), -v1.getX()),\n        FastMath.acos(v2.getY()),\n        FastMath.atan2(v2.getZ(), v2.getX())\n      };\n\n    } else if (order == RotationOrder.ZXZ) {\n\n      // r (Vector3D.plusK) coordinates are :\n      //  sin (psi1) sin (phi), -cos (psi1) sin (phi), cos (phi)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // sin (phi) sin (psi2), sin (phi) cos (psi2), cos (phi)\n      // and we can choose to have phi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getX(), -v1.getY()),\n        FastMath.acos(v2.getZ()),\n        FastMath.atan2(v2.getX(), v2.getY())\n      };\n\n    } else { // last possibility is ZYZ\n\n      // r (Vector3D.plusK) coordinates are :\n      //  cos (psi1) sin (theta), sin (psi1) sin (theta), cos (theta)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // -sin (theta) cos (psi2), sin (theta) sin (psi2), cos (theta)\n      // and we can choose to have theta in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getY(), v1.getX()),\n        FastMath.acos(v2.getZ()),\n        FastMath.atan2(v2.getY(), -v2.getX())\n      };\n\n    }\n\n  }",
          "30": "  public double[] getAngles(RotationOrder order)\n    throws CardanEulerSingularityException {\n\n    if (order == RotationOrder.XYZ) {\n\n      // r (Vector3D.plusK) coordinates are :\n      //  sin (theta), -cos (theta) sin (phi), cos (theta) cos (phi)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (psi) cos (theta), -sin (psi) cos (theta), sin (theta)\n      // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if  ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(-(v1.getY()), v1.getZ()),\n        FastMath.asin(v2.getZ()),\n        FastMath.atan2(-(v2.getY()), v2.getX())\n      };\n\n    } else if (order == RotationOrder.XZY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      // -sin (psi), cos (psi) cos (phi), cos (psi) sin (phi)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (theta) cos (psi), -sin (psi), sin (theta) cos (psi)\n      // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getZ(), v1.getY()),\n       -FastMath.asin(v2.getY()),\n        FastMath.atan2(v2.getZ(), v2.getX())\n      };\n\n    } else if (order == RotationOrder.YXZ) {\n\n      // r (Vector3D.plusK) coordinates are :\n      //  cos (phi) sin (theta), -sin (phi), cos (phi) cos (theta)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (psi) cos (phi), cos (psi) cos (phi), -sin (phi)\n      // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getX(), v1.getZ()),\n       -FastMath.asin(v2.getZ()),\n        FastMath.atan2(v2.getX(), v2.getY())\n      };\n\n    } else if (order == RotationOrder.YZX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      // cos (psi) cos (theta), sin (psi), -cos (psi) sin (theta)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (psi), cos (phi) cos (psi), -sin (phi) cos (psi)\n      // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(-(v1.getZ()), v1.getX()),\n        FastMath.asin(v2.getX()),\n        FastMath.atan2(-(v2.getZ()), v2.getY())\n      };\n\n    } else if (order == RotationOrder.ZXY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      // -cos (phi) sin (psi), cos (phi) cos (psi), sin (phi)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // -sin (theta) cos (phi), sin (phi), cos (theta) cos (phi)\n      // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(-(v1.getX()), v1.getY()),\n        FastMath.asin(v2.getY()),\n        FastMath.atan2(-(v2.getX()), v2.getZ())\n      };\n\n    } else if (order == RotationOrder.ZYX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      //  cos (theta) cos (psi), cos (theta) sin (psi), -sin (theta)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // -sin (theta), sin (phi) cos (theta), cos (phi) cos (theta)\n      // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\nreturn new double[[]]{FastMath.atan2(v1.getY(), v1.getX()),+FastMath.asin(v2.getX()),FastMath.add(v2.getY(), v2.getZ())};      };\n\n    } else if (order == RotationOrder.XYX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      //  cos (theta), sin (phi1) sin (theta), -cos (phi1) sin (theta)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (theta), sin (theta) sin (phi2), sin (theta) cos (phi2)\n      // and we can choose to have theta in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getY(), -v1.getZ()),\n        FastMath.acos(v2.getX()),\n        FastMath.atan2(v2.getY(), v2.getZ())\n      };\n\n    } else if (order == RotationOrder.XZX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      //  cos (psi), cos (phi1) sin (psi), sin (phi1) sin (psi)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (psi), -sin (psi) cos (phi2), sin (psi) sin (phi2)\n      // and we can choose to have psi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getZ(), v1.getY()),\n        FastMath.acos(v2.getX()),\n        FastMath.atan2(v2.getZ(), -v2.getY())\n      };\n\n    } else if (order == RotationOrder.YXY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      //  sin (theta1) sin (phi), cos (phi), cos (theta1) sin (phi)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (phi) sin (theta2), cos (phi), -sin (phi) cos (theta2)\n      // and we can choose to have phi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getX(), v1.getZ()),\n        FastMath.acos(v2.getY()),\n        FastMath.atan2(v2.getX(), -v2.getZ())\n      };\n\n    } else if (order == RotationOrder.YZY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      //  -cos (theta1) sin (psi), cos (psi), sin (theta1) sin (psi)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (psi) cos (theta2), cos (psi), sin (psi) sin (theta2)\n      // and we can choose to have psi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getZ(), -v1.getX()),\n        FastMath.acos(v2.getY()),\n        FastMath.atan2(v2.getZ(), v2.getX())\n      };\n\n    } else if (order == RotationOrder.ZXZ) {\n\n      // r (Vector3D.plusK) coordinates are :\n      //  sin (psi1) sin (phi), -cos (psi1) sin (phi), cos (phi)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // sin (phi) sin (psi2), sin (phi) cos (psi2), cos (phi)\n      // and we can choose to have phi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getX(), -v1.getY()),\n        FastMath.acos(v2.getZ()),\n        FastMath.atan2(v2.getX(), v2.getY())\n      };\n\n    } else { // last possibility is ZYZ\n\n      // r (Vector3D.plusK) coordinates are :\n      //  cos (psi1) sin (theta), sin (psi1) sin (theta), cos (theta)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // -sin (theta) cos (psi2), sin (theta) sin (psi2), cos (theta)\n      // and we can choose to have theta in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getY(), v1.getX()),\n        FastMath.acos(v2.getZ()),\n        FastMath.atan2(v2.getY(), -v2.getX())\n      };\n\n    }\n\n  }",
          "31": "  public double[] getAngles(RotationOrder order)\n    throws CardanEulerSingularityException {\n\n    if (order == RotationOrder.XYZ) {\n\n      // r (Vector3D.plusK) coordinates are :\n      //  sin (theta), -cos (theta) sin (phi), cos (theta) cos (phi)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (psi) cos (theta), -sin (psi) cos (theta), sin (theta)\n      // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if  ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(-(v1.getY()), v1.getZ()),\n        FastMath.asin(v2.getZ()),\n        FastMath.atan2(-(v2.getY()), v2.getX())\n      };\n\n    } else if (order == RotationOrder.XZY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      // -sin (psi), cos (psi) cos (phi), cos (psi) sin (phi)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (theta) cos (psi), -sin (psi), sin (theta) cos (psi)\n      // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getZ(), v1.getY()),\n       -FastMath.asin(v2.getY()),\n        FastMath.atan2(v2.getZ(), v2.getX())\n      };\n\n    } else if (order == RotationOrder.YXZ) {\n\n      // r (Vector3D.plusK) coordinates are :\n      //  cos (phi) sin (theta), -sin (phi), cos (phi) cos (theta)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (psi) cos (phi), cos (psi) cos (phi), -sin (phi)\n      // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getX(), v1.getZ()),\n       -FastMath.asin(v2.getZ()),\n        FastMath.atan2(v2.getX(), v2.getY())\n      };\n\n    } else if (order == RotationOrder.YZX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      // cos (psi) cos (theta), sin (psi), -cos (psi) sin (theta)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (psi), cos (phi) cos (psi), -sin (phi) cos (psi)\n      // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(-(v1.getZ()), v1.getX()),\n        FastMath.asin(v2.getX()),\n        FastMath.atan2(-(v2.getZ()), v2.getY())\n      };\n\n    } else if (order == RotationOrder.ZXY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      // -cos (phi) sin (psi), cos (phi) cos (psi), sin (phi)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // -sin (theta) cos (phi), sin (phi), cos (theta) cos (phi)\n      // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(-(v1.getX()), v1.getY()),\n        FastMath.asin(v2.getY()),\n        FastMath.atan2(-(v2.getX()), v2.getZ())\n      };\n\n    } else if (order == RotationOrder.ZYX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      //  cos (theta) cos (psi), cos (theta) sin (psi), -sin (theta)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // -sin (theta), sin (phi) cos (theta), cos (phi) cos (theta)\n      // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\nreturn 1;      };\n\n    } else if (order == RotationOrder.XYX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      //  cos (theta), sin (phi1) sin (theta), -cos (phi1) sin (theta)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (theta), sin (theta) sin (phi2), sin (theta) cos (phi2)\n      // and we can choose to have theta in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getY(), -v1.getZ()),\n        FastMath.acos(v2.getX()),\n        FastMath.atan2(v2.getY(), v2.getZ())\n      };\n\n    } else if (order == RotationOrder.XZX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      //  cos (psi), cos (phi1) sin (psi), sin (phi1) sin (psi)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (psi), -sin (psi) cos (phi2), sin (psi) sin (phi2)\n      // and we can choose to have psi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getZ(), v1.getY()),\n        FastMath.acos(v2.getX()),\n        FastMath.atan2(v2.getZ(), -v2.getY())\n      };\n\n    } else if (order == RotationOrder.YXY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      //  sin (theta1) sin (phi), cos (phi), cos (theta1) sin (phi)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (phi) sin (theta2), cos (phi), -sin (phi) cos (theta2)\n      // and we can choose to have phi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getX(), v1.getZ()),\n        FastMath.acos(v2.getY()),\n        FastMath.atan2(v2.getX(), -v2.getZ())\n      };\n\n    } else if (order == RotationOrder.YZY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      //  -cos (theta1) sin (psi), cos (psi), sin (theta1) sin (psi)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (psi) cos (theta2), cos (psi), sin (psi) sin (theta2)\n      // and we can choose to have psi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getZ(), -v1.getX()),\n        FastMath.acos(v2.getY()),\n        FastMath.atan2(v2.getZ(), v2.getX())\n      };\n\n    } else if (order == RotationOrder.ZXZ) {\n\n      // r (Vector3D.plusK) coordinates are :\n      //  sin (psi1) sin (phi), -cos (psi1) sin (phi), cos (phi)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // sin (phi) sin (psi2), sin (phi) cos (psi2), cos (phi)\n      // and we can choose to have phi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getX(), -v1.getY()),\n        FastMath.acos(v2.getZ()),\n        FastMath.atan2(v2.getX(), v2.getY())\n      };\n\n    } else { // last possibility is ZYZ\n\n      // r (Vector3D.plusK) coordinates are :\n      //  cos (psi1) sin (theta), sin (psi1) sin (theta), cos (theta)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // -sin (theta) cos (psi2), sin (theta) sin (psi2), cos (theta)\n      // and we can choose to have theta in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getY(), v1.getX()),\n        FastMath.acos(v2.getZ()),\n        FastMath.atan2(v2.getY(), -v2.getX())\n      };\n\n    }\n\n  }",
          "32": "  public double[] getAngles(RotationOrder order)\n    throws CardanEulerSingularityException {\n\n    if (order == RotationOrder.XYZ) {\n\n      // r (Vector3D.plusK) coordinates are :\n      //  sin (theta), -cos (theta) sin (phi), cos (theta) cos (phi)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (psi) cos (theta), -sin (psi) cos (theta), sin (theta)\n      // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if  ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(-(v1.getY()), v1.getZ()),\n        FastMath.asin(v2.getZ()),\n        FastMath.atan2(-(v2.getY()), v2.getX())\n      };\n\n    } else if (order == RotationOrder.XZY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      // -sin (psi), cos (psi) cos (phi), cos (psi) sin (phi)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (theta) cos (psi), -sin (psi), sin (theta) cos (psi)\n      // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getZ(), v1.getY()),\n       -FastMath.asin(v2.getY()),\n        FastMath.atan2(v2.getZ(), v2.getX())\n      };\n\n    } else if (order == RotationOrder.YXZ) {\n\n      // r (Vector3D.plusK) coordinates are :\n      //  cos (phi) sin (theta), -sin (phi), cos (phi) cos (theta)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (psi) cos (phi), cos (psi) cos (phi), -sin (phi)\n      // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getX(), v1.getZ()),\n       -FastMath.asin(v2.getZ()),\n        FastMath.atan2(v2.getX(), v2.getY())\n      };\n\n    } else if (order == RotationOrder.YZX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      // cos (psi) cos (theta), sin (psi), -cos (psi) sin (theta)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (psi), cos (phi) cos (psi), -sin (phi) cos (psi)\n      // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(-(v1.getZ()), v1.getX()),\n        FastMath.asin(v2.getX()),\n        FastMath.atan2(-(v2.getZ()), v2.getY())\n      };\n\n    } else if (order == RotationOrder.ZXY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      // -cos (phi) sin (psi), cos (phi) cos (psi), sin (phi)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // -sin (theta) cos (phi), sin (phi), cos (theta) cos (phi)\n      // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(-(v1.getX()), v1.getY()),\n        FastMath.asin(v2.getY()),\n        FastMath.atan2(-(v2.getX()), v2.getZ())\n      };\n\n    } else if (order == RotationOrder.ZYX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      //  cos (theta) cos (psi), cos (theta) sin (psi), -sin (theta)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // -sin (theta), sin (phi) cos (theta), cos (phi) cos (theta)\n      // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\nreturn new double[[]]{FastMath.atan2(v1.getY(), v1.getX()),+FastMath.asin(v2.getX()),RotationOrder.atan2(v2.getY(), v2.getZ())};      };\n\n    } else if (order == RotationOrder.XYX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      //  cos (theta), sin (phi1) sin (theta), -cos (phi1) sin (theta)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (theta), sin (theta) sin (phi2), sin (theta) cos (phi2)\n      // and we can choose to have theta in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getY(), -v1.getZ()),\n        FastMath.acos(v2.getX()),\n        FastMath.atan2(v2.getY(), v2.getZ())\n      };\n\n    } else if (order == RotationOrder.XZX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      //  cos (psi), cos (phi1) sin (psi), sin (phi1) sin (psi)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (psi), -sin (psi) cos (phi2), sin (psi) sin (phi2)\n      // and we can choose to have psi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getZ(), v1.getY()),\n        FastMath.acos(v2.getX()),\n        FastMath.atan2(v2.getZ(), -v2.getY())\n      };\n\n    } else if (order == RotationOrder.YXY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      //  sin (theta1) sin (phi), cos (phi), cos (theta1) sin (phi)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (phi) sin (theta2), cos (phi), -sin (phi) cos (theta2)\n      // and we can choose to have phi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getX(), v1.getZ()),\n        FastMath.acos(v2.getY()),\n        FastMath.atan2(v2.getX(), -v2.getZ())\n      };\n\n    } else if (order == RotationOrder.YZY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      //  -cos (theta1) sin (psi), cos (psi), sin (theta1) sin (psi)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (psi) cos (theta2), cos (psi), sin (psi) sin (theta2)\n      // and we can choose to have psi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getZ(), -v1.getX()),\n        FastMath.acos(v2.getY()),\n        FastMath.atan2(v2.getZ(), v2.getX())\n      };\n\n    } else if (order == RotationOrder.ZXZ) {\n\n      // r (Vector3D.plusK) coordinates are :\n      //  sin (psi1) sin (phi), -cos (psi1) sin (phi), cos (phi)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // sin (phi) sin (psi2), sin (phi) cos (psi2), cos (phi)\n      // and we can choose to have phi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getX(), -v1.getY()),\n        FastMath.acos(v2.getZ()),\n        FastMath.atan2(v2.getX(), v2.getY())\n      };\n\n    } else { // last possibility is ZYZ\n\n      // r (Vector3D.plusK) coordinates are :\n      //  cos (psi1) sin (theta), sin (psi1) sin (theta), cos (theta)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // -sin (theta) cos (psi2), sin (theta) sin (psi2), cos (theta)\n      // and we can choose to have theta in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getY(), v1.getX()),\n        FastMath.acos(v2.getZ()),\n        FastMath.atan2(v2.getY(), -v2.getX())\n      };\n\n    }\n\n  }",
          "33": "  public double[] getAngles(RotationOrder order)\n    throws CardanEulerSingularityException {\n\n    if (order == RotationOrder.XYZ) {\n\n      // r (Vector3D.plusK) coordinates are :\n      //  sin (theta), -cos (theta) sin (phi), cos (theta) cos (phi)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (psi) cos (theta), -sin (psi) cos (theta), sin (theta)\n      // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if  ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(-(v1.getY()), v1.getZ()),\n        FastMath.asin(v2.getZ()),\n        FastMath.atan2(-(v2.getY()), v2.getX())\n      };\n\n    } else if (order == RotationOrder.XZY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      // -sin (psi), cos (psi) cos (phi), cos (psi) sin (phi)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (theta) cos (psi), -sin (psi), sin (theta) cos (psi)\n      // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getZ(), v1.getY()),\n       -FastMath.asin(v2.getY()),\n        FastMath.atan2(v2.getZ(), v2.getX())\n      };\n\n    } else if (order == RotationOrder.YXZ) {\n\n      // r (Vector3D.plusK) coordinates are :\n      //  cos (phi) sin (theta), -sin (phi), cos (phi) cos (theta)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (psi) cos (phi), cos (psi) cos (phi), -sin (phi)\n      // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getX(), v1.getZ()),\n       -FastMath.asin(v2.getZ()),\n        FastMath.atan2(v2.getX(), v2.getY())\n      };\n\n    } else if (order == RotationOrder.YZX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      // cos (psi) cos (theta), sin (psi), -cos (psi) sin (theta)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (psi), cos (phi) cos (psi), -sin (phi) cos (psi)\n      // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(-(v1.getZ()), v1.getX()),\n        FastMath.asin(v2.getX()),\n        FastMath.atan2(-(v2.getZ()), v2.getY())\n      };\n\n    } else if (order == RotationOrder.ZXY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      // -cos (phi) sin (psi), cos (phi) cos (psi), sin (phi)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // -sin (theta) cos (phi), sin (phi), cos (theta) cos (phi)\n      // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(-(v1.getX()), v1.getY()),\n        FastMath.asin(v2.getY()),\n        FastMath.atan2(-(v2.getX()), v2.getZ())\n      };\n\n    } else if (order == RotationOrder.ZYX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      //  cos (theta) cos (psi), cos (theta) sin (psi), -sin (theta)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // -sin (theta), sin (phi) cos (theta), cos (phi) cos (theta)\n      // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\nbreak;\n      return new double[] {\n        FastMath.atan2(v1.getY(), v1.getX()),\n       +FastMath.asin(v2.getX()),\n        FastMath.atan2(v2.getY(), v2.getZ())      };\n\n    } else if (order == RotationOrder.XYX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      //  cos (theta), sin (phi1) sin (theta), -cos (phi1) sin (theta)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (theta), sin (theta) sin (phi2), sin (theta) cos (phi2)\n      // and we can choose to have theta in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getY(), -v1.getZ()),\n        FastMath.acos(v2.getX()),\n        FastMath.atan2(v2.getY(), v2.getZ())\n      };\n\n    } else if (order == RotationOrder.XZX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      //  cos (psi), cos (phi1) sin (psi), sin (phi1) sin (psi)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (psi), -sin (psi) cos (phi2), sin (psi) sin (phi2)\n      // and we can choose to have psi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getZ(), v1.getY()),\n        FastMath.acos(v2.getX()),\n        FastMath.atan2(v2.getZ(), -v2.getY())\n      };\n\n    } else if (order == RotationOrder.YXY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      //  sin (theta1) sin (phi), cos (phi), cos (theta1) sin (phi)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (phi) sin (theta2), cos (phi), -sin (phi) cos (theta2)\n      // and we can choose to have phi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getX(), v1.getZ()),\n        FastMath.acos(v2.getY()),\n        FastMath.atan2(v2.getX(), -v2.getZ())\n      };\n\n    } else if (order == RotationOrder.YZY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      //  -cos (theta1) sin (psi), cos (psi), sin (theta1) sin (psi)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (psi) cos (theta2), cos (psi), sin (psi) sin (theta2)\n      // and we can choose to have psi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getZ(), -v1.getX()),\n        FastMath.acos(v2.getY()),\n        FastMath.atan2(v2.getZ(), v2.getX())\n      };\n\n    } else if (order == RotationOrder.ZXZ) {\n\n      // r (Vector3D.plusK) coordinates are :\n      //  sin (psi1) sin (phi), -cos (psi1) sin (phi), cos (phi)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // sin (phi) sin (psi2), sin (phi) cos (psi2), cos (phi)\n      // and we can choose to have phi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getX(), -v1.getY()),\n        FastMath.acos(v2.getZ()),\n        FastMath.atan2(v2.getX(), v2.getY())\n      };\n\n    } else { // last possibility is ZYZ\n\n      // r (Vector3D.plusK) coordinates are :\n      //  cos (psi1) sin (theta), sin (psi1) sin (theta), cos (theta)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // -sin (theta) cos (psi2), sin (theta) sin (psi2), cos (theta)\n      // and we can choose to have theta in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getY(), v1.getX()),\n        FastMath.acos(v2.getZ()),\n        FastMath.atan2(v2.getY(), -v2.getX())\n      };\n\n    }\n\n  }",
          "34": "  public double[] getAngles(RotationOrder order)\n    throws CardanEulerSingularityException {\n\n    if (order == RotationOrder.XYZ) {\n\n      // r (Vector3D.plusK) coordinates are :\n      //  sin (theta), -cos (theta) sin (phi), cos (theta) cos (phi)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (psi) cos (theta), -sin (psi) cos (theta), sin (theta)\n      // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if  ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(-(v1.getY()), v1.getZ()),\n        FastMath.asin(v2.getZ()),\n        FastMath.atan2(-(v2.getY()), v2.getX())\n      };\n\n    } else if (order == RotationOrder.XZY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      // -sin (psi), cos (psi) cos (phi), cos (psi) sin (phi)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (theta) cos (psi), -sin (psi), sin (theta) cos (psi)\n      // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getZ(), v1.getY()),\n       -FastMath.asin(v2.getY()),\n        FastMath.atan2(v2.getZ(), v2.getX())\n      };\n\n    } else if (order == RotationOrder.YXZ) {\n\n      // r (Vector3D.plusK) coordinates are :\n      //  cos (phi) sin (theta), -sin (phi), cos (phi) cos (theta)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (psi) cos (phi), cos (psi) cos (phi), -sin (phi)\n      // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getX(), v1.getZ()),\n       -FastMath.asin(v2.getZ()),\n        FastMath.atan2(v2.getX(), v2.getY())\n      };\n\n    } else if (order == RotationOrder.YZX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      // cos (psi) cos (theta), sin (psi), -cos (psi) sin (theta)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (psi), cos (phi) cos (psi), -sin (phi) cos (psi)\n      // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(-(v1.getZ()), v1.getX()),\n        FastMath.asin(v2.getX()),\n        FastMath.atan2(-(v2.getZ()), v2.getY())\n      };\n\n    } else if (order == RotationOrder.ZXY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      // -cos (phi) sin (psi), cos (phi) cos (psi), sin (phi)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // -sin (theta) cos (phi), sin (phi), cos (theta) cos (phi)\n      // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(-(v1.getX()), v1.getY()),\n        FastMath.asin(v2.getY()),\n        FastMath.atan2(-(v2.getX()), v2.getZ())\n      };\n\n    } else if (order == RotationOrder.ZYX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      //  cos (theta) cos (psi), cos (theta) sin (psi), -sin (theta)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // -sin (theta), sin (phi) cos (theta), cos (phi) cos (theta)\n      // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\nreturn new double[[]]{FastMath.atan2(v1.getY(), v1.getX()),+FastMath.asin(v2.getX()),FastMath.atan2(v2.get(), v2.getZ())};      };\n\n    } else if (order == RotationOrder.XYX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      //  cos (theta), sin (phi1) sin (theta), -cos (phi1) sin (theta)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (theta), sin (theta) sin (phi2), sin (theta) cos (phi2)\n      // and we can choose to have theta in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getY(), -v1.getZ()),\n        FastMath.acos(v2.getX()),\n        FastMath.atan2(v2.getY(), v2.getZ())\n      };\n\n    } else if (order == RotationOrder.XZX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      //  cos (psi), cos (phi1) sin (psi), sin (phi1) sin (psi)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (psi), -sin (psi) cos (phi2), sin (psi) sin (phi2)\n      // and we can choose to have psi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getZ(), v1.getY()),\n        FastMath.acos(v2.getX()),\n        FastMath.atan2(v2.getZ(), -v2.getY())\n      };\n\n    } else if (order == RotationOrder.YXY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      //  sin (theta1) sin (phi), cos (phi), cos (theta1) sin (phi)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (phi) sin (theta2), cos (phi), -sin (phi) cos (theta2)\n      // and we can choose to have phi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getX(), v1.getZ()),\n        FastMath.acos(v2.getY()),\n        FastMath.atan2(v2.getX(), -v2.getZ())\n      };\n\n    } else if (order == RotationOrder.YZY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      //  -cos (theta1) sin (psi), cos (psi), sin (theta1) sin (psi)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (psi) cos (theta2), cos (psi), sin (psi) sin (theta2)\n      // and we can choose to have psi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getZ(), -v1.getX()),\n        FastMath.acos(v2.getY()),\n        FastMath.atan2(v2.getZ(), v2.getX())\n      };\n\n    } else if (order == RotationOrder.ZXZ) {\n\n      // r (Vector3D.plusK) coordinates are :\n      //  sin (psi1) sin (phi), -cos (psi1) sin (phi), cos (phi)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // sin (phi) sin (psi2), sin (phi) cos (psi2), cos (phi)\n      // and we can choose to have phi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getX(), -v1.getY()),\n        FastMath.acos(v2.getZ()),\n        FastMath.atan2(v2.getX(), v2.getY())\n      };\n\n    } else { // last possibility is ZYZ\n\n      // r (Vector3D.plusK) coordinates are :\n      //  cos (psi1) sin (theta), sin (psi1) sin (theta), cos (theta)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // -sin (theta) cos (psi2), sin (theta) sin (psi2), cos (theta)\n      // and we can choose to have theta in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getY(), v1.getX()),\n        FastMath.acos(v2.getZ()),\n        FastMath.atan2(v2.getY(), -v2.getX())\n      };\n\n    }\n\n  }",
          "35": "  public double[] getAngles(RotationOrder order)\n    throws CardanEulerSingularityException {\n\n    if (order == RotationOrder.XYZ) {\n\n      // r (Vector3D.plusK) coordinates are :\n      //  sin (theta), -cos (theta) sin (phi), cos (theta) cos (phi)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (psi) cos (theta), -sin (psi) cos (theta), sin (theta)\n      // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if  ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(-(v1.getY()), v1.getZ()),\n        FastMath.asin(v2.getZ()),\n        FastMath.atan2(-(v2.getY()), v2.getX())\n      };\n\n    } else if (order == RotationOrder.XZY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      // -sin (psi), cos (psi) cos (phi), cos (psi) sin (phi)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (theta) cos (psi), -sin (psi), sin (theta) cos (psi)\n      // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getZ(), v1.getY()),\n       -FastMath.asin(v2.getY()),\n        FastMath.atan2(v2.getZ(), v2.getX())\n      };\n\n    } else if (order == RotationOrder.YXZ) {\n\n      // r (Vector3D.plusK) coordinates are :\n      //  cos (phi) sin (theta), -sin (phi), cos (phi) cos (theta)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (psi) cos (phi), cos (psi) cos (phi), -sin (phi)\n      // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getX(), v1.getZ()),\n       -FastMath.asin(v2.getZ()),\n        FastMath.atan2(v2.getX(), v2.getY())\n      };\n\n    } else if (order == RotationOrder.YZX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      // cos (psi) cos (theta), sin (psi), -cos (psi) sin (theta)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (psi), cos (phi) cos (psi), -sin (phi) cos (psi)\n      // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(-(v1.getZ()), v1.getX()),\n        FastMath.asin(v2.getX()),\n        FastMath.atan2(-(v2.getZ()), v2.getY())\n      };\n\n    } else if (order == RotationOrder.ZXY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      // -cos (phi) sin (psi), cos (phi) cos (psi), sin (phi)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // -sin (theta) cos (phi), sin (phi), cos (theta) cos (phi)\n      // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(-(v1.getX()), v1.getY()),\n        FastMath.asin(v2.getY()),\n        FastMath.atan2(-(v2.getX()), v2.getZ())\n      };\n\n    } else if (order == RotationOrder.ZYX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      //  cos (theta) cos (psi), cos (theta) sin (psi), -sin (theta)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // -sin (theta), sin (phi) cos (theta), cos (phi) cos (theta)\n      // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\nreturn new Vector3D[[]];      };\n\n    } else if (order == RotationOrder.XYX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      //  cos (theta), sin (phi1) sin (theta), -cos (phi1) sin (theta)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (theta), sin (theta) sin (phi2), sin (theta) cos (phi2)\n      // and we can choose to have theta in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getY(), -v1.getZ()),\n        FastMath.acos(v2.getX()),\n        FastMath.atan2(v2.getY(), v2.getZ())\n      };\n\n    } else if (order == RotationOrder.XZX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      //  cos (psi), cos (phi1) sin (psi), sin (phi1) sin (psi)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (psi), -sin (psi) cos (phi2), sin (psi) sin (phi2)\n      // and we can choose to have psi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getZ(), v1.getY()),\n        FastMath.acos(v2.getX()),\n        FastMath.atan2(v2.getZ(), -v2.getY())\n      };\n\n    } else if (order == RotationOrder.YXY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      //  sin (theta1) sin (phi), cos (phi), cos (theta1) sin (phi)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (phi) sin (theta2), cos (phi), -sin (phi) cos (theta2)\n      // and we can choose to have phi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getX(), v1.getZ()),\n        FastMath.acos(v2.getY()),\n        FastMath.atan2(v2.getX(), -v2.getZ())\n      };\n\n    } else if (order == RotationOrder.YZY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      //  -cos (theta1) sin (psi), cos (psi), sin (theta1) sin (psi)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (psi) cos (theta2), cos (psi), sin (psi) sin (theta2)\n      // and we can choose to have psi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getZ(), -v1.getX()),\n        FastMath.acos(v2.getY()),\n        FastMath.atan2(v2.getZ(), v2.getX())\n      };\n\n    } else if (order == RotationOrder.ZXZ) {\n\n      // r (Vector3D.plusK) coordinates are :\n      //  sin (psi1) sin (phi), -cos (psi1) sin (phi), cos (phi)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // sin (phi) sin (psi2), sin (phi) cos (psi2), cos (phi)\n      // and we can choose to have phi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getX(), -v1.getY()),\n        FastMath.acos(v2.getZ()),\n        FastMath.atan2(v2.getX(), v2.getY())\n      };\n\n    } else { // last possibility is ZYZ\n\n      // r (Vector3D.plusK) coordinates are :\n      //  cos (psi1) sin (theta), sin (psi1) sin (theta), cos (theta)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // -sin (theta) cos (psi2), sin (theta) sin (psi2), cos (theta)\n      // and we can choose to have theta in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getY(), v1.getX()),\n        FastMath.acos(v2.getZ()),\n        FastMath.atan2(v2.getY(), -v2.getX())\n      };\n\n    }\n\n  }",
          "36": "  public double[] getAngles(RotationOrder order)\n    throws CardanEulerSingularityException {\n\n    if (order == RotationOrder.XYZ) {\n\n      // r (Vector3D.plusK) coordinates are :\n      //  sin (theta), -cos (theta) sin (phi), cos (theta) cos (phi)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (psi) cos (theta), -sin (psi) cos (theta), sin (theta)\n      // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if  ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(-(v1.getY()), v1.getZ()),\n        FastMath.asin(v2.getZ()),\n        FastMath.atan2(-(v2.getY()), v2.getX())\n      };\n\n    } else if (order == RotationOrder.XZY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      // -sin (psi), cos (psi) cos (phi), cos (psi) sin (phi)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (theta) cos (psi), -sin (psi), sin (theta) cos (psi)\n      // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getZ(), v1.getY()),\n       -FastMath.asin(v2.getY()),\n        FastMath.atan2(v2.getZ(), v2.getX())\n      };\n\n    } else if (order == RotationOrder.YXZ) {\n\n      // r (Vector3D.plusK) coordinates are :\n      //  cos (phi) sin (theta), -sin (phi), cos (phi) cos (theta)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (psi) cos (phi), cos (psi) cos (phi), -sin (phi)\n      // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getX(), v1.getZ()),\n       -FastMath.asin(v2.getZ()),\n        FastMath.atan2(v2.getX(), v2.getY())\n      };\n\n    } else if (order == RotationOrder.YZX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      // cos (psi) cos (theta), sin (psi), -cos (psi) sin (theta)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (psi), cos (phi) cos (psi), -sin (phi) cos (psi)\n      // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(-(v1.getZ()), v1.getX()),\n        FastMath.asin(v2.getX()),\n        FastMath.atan2(-(v2.getZ()), v2.getY())\n      };\n\n    } else if (order == RotationOrder.ZXY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      // -cos (phi) sin (psi), cos (phi) cos (psi), sin (phi)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // -sin (theta) cos (phi), sin (phi), cos (theta) cos (phi)\n      // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(-(v1.getX()), v1.getY()),\n        FastMath.asin(v2.getY()),\n        FastMath.atan2(-(v2.getX()), v2.getZ())\n      };\n\n    } else if (order == RotationOrder.ZYX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      //  cos (theta) cos (psi), cos (theta) sin (psi), -sin (theta)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // -sin (theta), sin (phi) cos (theta), cos (phi) cos (theta)\n      // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\nreturn new double[[]]{FastMath.atan2(v1.getY(), v1.getX()),+FastMath.asin(v2.getX()),FastMath.atan2(v2.getY(), v2.get())};      };\n\n    } else if (order == RotationOrder.XYX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      //  cos (theta), sin (phi1) sin (theta), -cos (phi1) sin (theta)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (theta), sin (theta) sin (phi2), sin (theta) cos (phi2)\n      // and we can choose to have theta in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getY(), -v1.getZ()),\n        FastMath.acos(v2.getX()),\n        FastMath.atan2(v2.getY(), v2.getZ())\n      };\n\n    } else if (order == RotationOrder.XZX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      //  cos (psi), cos (phi1) sin (psi), sin (phi1) sin (psi)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (psi), -sin (psi) cos (phi2), sin (psi) sin (phi2)\n      // and we can choose to have psi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getZ(), v1.getY()),\n        FastMath.acos(v2.getX()),\n        FastMath.atan2(v2.getZ(), -v2.getY())\n      };\n\n    } else if (order == RotationOrder.YXY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      //  sin (theta1) sin (phi), cos (phi), cos (theta1) sin (phi)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (phi) sin (theta2), cos (phi), -sin (phi) cos (theta2)\n      // and we can choose to have phi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getX(), v1.getZ()),\n        FastMath.acos(v2.getY()),\n        FastMath.atan2(v2.getX(), -v2.getZ())\n      };\n\n    } else if (order == RotationOrder.YZY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      //  -cos (theta1) sin (psi), cos (psi), sin (theta1) sin (psi)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (psi) cos (theta2), cos (psi), sin (psi) sin (theta2)\n      // and we can choose to have psi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getZ(), -v1.getX()),\n        FastMath.acos(v2.getY()),\n        FastMath.atan2(v2.getZ(), v2.getX())\n      };\n\n    } else if (order == RotationOrder.ZXZ) {\n\n      // r (Vector3D.plusK) coordinates are :\n      //  sin (psi1) sin (phi), -cos (psi1) sin (phi), cos (phi)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // sin (phi) sin (psi2), sin (phi) cos (psi2), cos (phi)\n      // and we can choose to have phi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getX(), -v1.getY()),\n        FastMath.acos(v2.getZ()),\n        FastMath.atan2(v2.getX(), v2.getY())\n      };\n\n    } else { // last possibility is ZYZ\n\n      // r (Vector3D.plusK) coordinates are :\n      //  cos (psi1) sin (theta), sin (psi1) sin (theta), cos (theta)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // -sin (theta) cos (psi2), sin (theta) sin (psi2), cos (theta)\n      // and we can choose to have theta in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getY(), v1.getX()),\n        FastMath.acos(v2.getZ()),\n        FastMath.atan2(v2.getY(), -v2.getX())\n      };\n\n    }\n\n  }",
          "37": "  public double[] getAngles(RotationOrder order)\n    throws CardanEulerSingularityException {\n\n    if (order == RotationOrder.XYZ) {\n\n      // r (Vector3D.plusK) coordinates are :\n      //  sin (theta), -cos (theta) sin (phi), cos (theta) cos (phi)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (psi) cos (theta), -sin (psi) cos (theta), sin (theta)\n      // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if  ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(-(v1.getY()), v1.getZ()),\n        FastMath.asin(v2.getZ()),\n        FastMath.atan2(-(v2.getY()), v2.getX())\n      };\n\n    } else if (order == RotationOrder.XZY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      // -sin (psi), cos (psi) cos (phi), cos (psi) sin (phi)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (theta) cos (psi), -sin (psi), sin (theta) cos (psi)\n      // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getZ(), v1.getY()),\n       -FastMath.asin(v2.getY()),\n        FastMath.atan2(v2.getZ(), v2.getX())\n      };\n\n    } else if (order == RotationOrder.YXZ) {\n\n      // r (Vector3D.plusK) coordinates are :\n      //  cos (phi) sin (theta), -sin (phi), cos (phi) cos (theta)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (psi) cos (phi), cos (psi) cos (phi), -sin (phi)\n      // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getX(), v1.getZ()),\n       -FastMath.asin(v2.getZ()),\n        FastMath.atan2(v2.getX(), v2.getY())\n      };\n\n    } else if (order == RotationOrder.YZX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      // cos (psi) cos (theta), sin (psi), -cos (psi) sin (theta)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (psi), cos (phi) cos (psi), -sin (phi) cos (psi)\n      // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(-(v1.getZ()), v1.getX()),\n        FastMath.asin(v2.getX()),\n        FastMath.atan2(-(v2.getZ()), v2.getY())\n      };\n\n    } else if (order == RotationOrder.ZXY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      // -cos (phi) sin (psi), cos (phi) cos (psi), sin (phi)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // -sin (theta) cos (phi), sin (phi), cos (theta) cos (phi)\n      // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(-(v1.getX()), v1.getY()),\n        FastMath.asin(v2.getY()),\n        FastMath.atan2(-(v2.getX()), v2.getZ())\n      };\n\n    } else if (order == RotationOrder.ZYX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      //  cos (theta) cos (psi), cos (theta) sin (psi), -sin (theta)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // -sin (theta), sin (phi) cos (theta), cos (phi) cos (theta)\n      // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\nreturn new double[[]]{FastMath.atan2(v1.getY(), v1.getX()),+FastMath.asin(v2.getX()),FastMath.atan2(v2.getY(), v2.getY())};      };\n\n    } else if (order == RotationOrder.XYX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      //  cos (theta), sin (phi1) sin (theta), -cos (phi1) sin (theta)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (theta), sin (theta) sin (phi2), sin (theta) cos (phi2)\n      // and we can choose to have theta in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getY(), -v1.getZ()),\n        FastMath.acos(v2.getX()),\n        FastMath.atan2(v2.getY(), v2.getZ())\n      };\n\n    } else if (order == RotationOrder.XZX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      //  cos (psi), cos (phi1) sin (psi), sin (phi1) sin (psi)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (psi), -sin (psi) cos (phi2), sin (psi) sin (phi2)\n      // and we can choose to have psi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getZ(), v1.getY()),\n        FastMath.acos(v2.getX()),\n        FastMath.atan2(v2.getZ(), -v2.getY())\n      };\n\n    } else if (order == RotationOrder.YXY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      //  sin (theta1) sin (phi), cos (phi), cos (theta1) sin (phi)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (phi) sin (theta2), cos (phi), -sin (phi) cos (theta2)\n      // and we can choose to have phi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getX(), v1.getZ()),\n        FastMath.acos(v2.getY()),\n        FastMath.atan2(v2.getX(), -v2.getZ())\n      };\n\n    } else if (order == RotationOrder.YZY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      //  -cos (theta1) sin (psi), cos (psi), sin (theta1) sin (psi)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (psi) cos (theta2), cos (psi), sin (psi) sin (theta2)\n      // and we can choose to have psi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getZ(), -v1.getX()),\n        FastMath.acos(v2.getY()),\n        FastMath.atan2(v2.getZ(), v2.getX())\n      };\n\n    } else if (order == RotationOrder.ZXZ) {\n\n      // r (Vector3D.plusK) coordinates are :\n      //  sin (psi1) sin (phi), -cos (psi1) sin (phi), cos (phi)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // sin (phi) sin (psi2), sin (phi) cos (psi2), cos (phi)\n      // and we can choose to have phi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getX(), -v1.getY()),\n        FastMath.acos(v2.getZ()),\n        FastMath.atan2(v2.getX(), v2.getY())\n      };\n\n    } else { // last possibility is ZYZ\n\n      // r (Vector3D.plusK) coordinates are :\n      //  cos (psi1) sin (theta), sin (psi1) sin (theta), cos (theta)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // -sin (theta) cos (psi2), sin (theta) sin (psi2), cos (theta)\n      // and we can choose to have theta in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getY(), v1.getX()),\n        FastMath.acos(v2.getZ()),\n        FastMath.atan2(v2.getY(), -v2.getX())\n      };\n\n    }\n\n  }",
          "38": "  public double[] getAngles(RotationOrder order)\n    throws CardanEulerSingularityException {\n\n    if (order == RotationOrder.XYZ) {\n\n      // r (Vector3D.plusK) coordinates are :\n      //  sin (theta), -cos (theta) sin (phi), cos (theta) cos (phi)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (psi) cos (theta), -sin (psi) cos (theta), sin (theta)\n      // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if  ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(-(v1.getY()), v1.getZ()),\n        FastMath.asin(v2.getZ()),\n        FastMath.atan2(-(v2.getY()), v2.getX())\n      };\n\n    } else if (order == RotationOrder.XZY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      // -sin (psi), cos (psi) cos (phi), cos (psi) sin (phi)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (theta) cos (psi), -sin (psi), sin (theta) cos (psi)\n      // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getZ(), v1.getY()),\n       -FastMath.asin(v2.getY()),\n        FastMath.atan2(v2.getZ(), v2.getX())\n      };\n\n    } else if (order == RotationOrder.YXZ) {\n\n      // r (Vector3D.plusK) coordinates are :\n      //  cos (phi) sin (theta), -sin (phi), cos (phi) cos (theta)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (psi) cos (phi), cos (psi) cos (phi), -sin (phi)\n      // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getX(), v1.getZ()),\n       -FastMath.asin(v2.getZ()),\n        FastMath.atan2(v2.getX(), v2.getY())\n      };\n\n    } else if (order == RotationOrder.YZX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      // cos (psi) cos (theta), sin (psi), -cos (psi) sin (theta)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (psi), cos (phi) cos (psi), -sin (phi) cos (psi)\n      // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(-(v1.getZ()), v1.getX()),\n        FastMath.asin(v2.getX()),\n        FastMath.atan2(-(v2.getZ()), v2.getY())\n      };\n\n    } else if (order == RotationOrder.ZXY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      // -cos (phi) sin (psi), cos (phi) cos (psi), sin (phi)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // -sin (theta) cos (phi), sin (phi), cos (theta) cos (phi)\n      // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(-(v1.getX()), v1.getY()),\n        FastMath.asin(v2.getY()),\n        FastMath.atan2(-(v2.getX()), v2.getZ())\n      };\n\n    } else if (order == RotationOrder.ZYX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      //  cos (theta) cos (psi), cos (theta) sin (psi), -sin (theta)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // -sin (theta), sin (phi) cos (theta), cos (phi) cos (theta)\n      // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\nreturn FastMath.atan2(v2.getY(), v2.getZ());      };\n\n    } else if (order == RotationOrder.XYX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      //  cos (theta), sin (phi1) sin (theta), -cos (phi1) sin (theta)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (theta), sin (theta) sin (phi2), sin (theta) cos (phi2)\n      // and we can choose to have theta in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getY(), -v1.getZ()),\n        FastMath.acos(v2.getX()),\n        FastMath.atan2(v2.getY(), v2.getZ())\n      };\n\n    } else if (order == RotationOrder.XZX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      //  cos (psi), cos (phi1) sin (psi), sin (phi1) sin (psi)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (psi), -sin (psi) cos (phi2), sin (psi) sin (phi2)\n      // and we can choose to have psi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getZ(), v1.getY()),\n        FastMath.acos(v2.getX()),\n        FastMath.atan2(v2.getZ(), -v2.getY())\n      };\n\n    } else if (order == RotationOrder.YXY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      //  sin (theta1) sin (phi), cos (phi), cos (theta1) sin (phi)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (phi) sin (theta2), cos (phi), -sin (phi) cos (theta2)\n      // and we can choose to have phi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getX(), v1.getZ()),\n        FastMath.acos(v2.getY()),\n        FastMath.atan2(v2.getX(), -v2.getZ())\n      };\n\n    } else if (order == RotationOrder.YZY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      //  -cos (theta1) sin (psi), cos (psi), sin (theta1) sin (psi)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (psi) cos (theta2), cos (psi), sin (psi) sin (theta2)\n      // and we can choose to have psi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getZ(), -v1.getX()),\n        FastMath.acos(v2.getY()),\n        FastMath.atan2(v2.getZ(), v2.getX())\n      };\n\n    } else if (order == RotationOrder.ZXZ) {\n\n      // r (Vector3D.plusK) coordinates are :\n      //  sin (psi1) sin (phi), -cos (psi1) sin (phi), cos (phi)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // sin (phi) sin (psi2), sin (phi) cos (psi2), cos (phi)\n      // and we can choose to have phi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getX(), -v1.getY()),\n        FastMath.acos(v2.getZ()),\n        FastMath.atan2(v2.getX(), v2.getY())\n      };\n\n    } else { // last possibility is ZYZ\n\n      // r (Vector3D.plusK) coordinates are :\n      //  cos (psi1) sin (theta), sin (psi1) sin (theta), cos (theta)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // -sin (theta) cos (psi2), sin (theta) sin (psi2), cos (theta)\n      // and we can choose to have theta in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getY(), v1.getX()),\n        FastMath.acos(v2.getZ()),\n        FastMath.atan2(v2.getY(), -v2.getX())\n      };\n\n    }\n\n  }",
          "39": "  public double[] getAngles(RotationOrder order)\n    throws CardanEulerSingularityException {\n\n    if (order == RotationOrder.XYZ) {\n\n      // r (Vector3D.plusK) coordinates are :\n      //  sin (theta), -cos (theta) sin (phi), cos (theta) cos (phi)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (psi) cos (theta), -sin (psi) cos (theta), sin (theta)\n      // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if  ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(-(v1.getY()), v1.getZ()),\n        FastMath.asin(v2.getZ()),\n        FastMath.atan2(-(v2.getY()), v2.getX())\n      };\n\n    } else if (order == RotationOrder.XZY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      // -sin (psi), cos (psi) cos (phi), cos (psi) sin (phi)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (theta) cos (psi), -sin (psi), sin (theta) cos (psi)\n      // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getZ(), v1.getY()),\n       -FastMath.asin(v2.getY()),\n        FastMath.atan2(v2.getZ(), v2.getX())\n      };\n\n    } else if (order == RotationOrder.YXZ) {\n\n      // r (Vector3D.plusK) coordinates are :\n      //  cos (phi) sin (theta), -sin (phi), cos (phi) cos (theta)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (psi) cos (phi), cos (psi) cos (phi), -sin (phi)\n      // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getX(), v1.getZ()),\n       -FastMath.asin(v2.getZ()),\n        FastMath.atan2(v2.getX(), v2.getY())\n      };\n\n    } else if (order == RotationOrder.YZX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      // cos (psi) cos (theta), sin (psi), -cos (psi) sin (theta)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (psi), cos (phi) cos (psi), -sin (phi) cos (psi)\n      // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(-(v1.getZ()), v1.getX()),\n        FastMath.asin(v2.getX()),\n        FastMath.atan2(-(v2.getZ()), v2.getY())\n      };\n\n    } else if (order == RotationOrder.ZXY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      // -cos (phi) sin (psi), cos (phi) cos (psi), sin (phi)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // -sin (theta) cos (phi), sin (phi), cos (theta) cos (phi)\n      // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(-(v1.getX()), v1.getY()),\n        FastMath.asin(v2.getY()),\n        FastMath.atan2(-(v2.getX()), v2.getZ())\n      };\n\n    } else if (order == RotationOrder.ZYX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      //  cos (theta) cos (psi), cos (theta) sin (psi), -sin (theta)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // -sin (theta), sin (phi) cos (theta), cos (phi) cos (theta)\n      // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\nreturn new double[[]]{FastMath.atan2(v1.getY(), v1.getX()),+FastMath.asin(v2.get()),FastMath.atan2(v2.getY(), v2.getZ())};      };\n\n    } else if (order == RotationOrder.XYX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      //  cos (theta), sin (phi1) sin (theta), -cos (phi1) sin (theta)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (theta), sin (theta) sin (phi2), sin (theta) cos (phi2)\n      // and we can choose to have theta in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getY(), -v1.getZ()),\n        FastMath.acos(v2.getX()),\n        FastMath.atan2(v2.getY(), v2.getZ())\n      };\n\n    } else if (order == RotationOrder.XZX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      //  cos (psi), cos (phi1) sin (psi), sin (phi1) sin (psi)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (psi), -sin (psi) cos (phi2), sin (psi) sin (phi2)\n      // and we can choose to have psi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getZ(), v1.getY()),\n        FastMath.acos(v2.getX()),\n        FastMath.atan2(v2.getZ(), -v2.getY())\n      };\n\n    } else if (order == RotationOrder.YXY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      //  sin (theta1) sin (phi), cos (phi), cos (theta1) sin (phi)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (phi) sin (theta2), cos (phi), -sin (phi) cos (theta2)\n      // and we can choose to have phi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getX(), v1.getZ()),\n        FastMath.acos(v2.getY()),\n        FastMath.atan2(v2.getX(), -v2.getZ())\n      };\n\n    } else if (order == RotationOrder.YZY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      //  -cos (theta1) sin (psi), cos (psi), sin (theta1) sin (psi)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (psi) cos (theta2), cos (psi), sin (psi) sin (theta2)\n      // and we can choose to have psi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getZ(), -v1.getX()),\n        FastMath.acos(v2.getY()),\n        FastMath.atan2(v2.getZ(), v2.getX())\n      };\n\n    } else if (order == RotationOrder.ZXZ) {\n\n      // r (Vector3D.plusK) coordinates are :\n      //  sin (psi1) sin (phi), -cos (psi1) sin (phi), cos (phi)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // sin (phi) sin (psi2), sin (phi) cos (psi2), cos (phi)\n      // and we can choose to have phi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getX(), -v1.getY()),\n        FastMath.acos(v2.getZ()),\n        FastMath.atan2(v2.getX(), v2.getY())\n      };\n\n    } else { // last possibility is ZYZ\n\n      // r (Vector3D.plusK) coordinates are :\n      //  cos (psi1) sin (theta), sin (psi1) sin (theta), cos (theta)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // -sin (theta) cos (psi2), sin (theta) sin (psi2), cos (theta)\n      // and we can choose to have theta in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getY(), v1.getX()),\n        FastMath.acos(v2.getZ()),\n        FastMath.atan2(v2.getY(), -v2.getX())\n      };\n\n    }\n\n  }",
          "40": "  public double[] getAngles(RotationOrder order)\n    throws CardanEulerSingularityException {\n\n    if (order == RotationOrder.XYZ) {\n\n      // r (Vector3D.plusK) coordinates are :\n      //  sin (theta), -cos (theta) sin (phi), cos (theta) cos (phi)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (psi) cos (theta), -sin (psi) cos (theta), sin (theta)\n      // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if  ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(-(v1.getY()), v1.getZ()),\n        FastMath.asin(v2.getZ()),\n        FastMath.atan2(-(v2.getY()), v2.getX())\n      };\n\n    } else if (order == RotationOrder.XZY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      // -sin (psi), cos (psi) cos (phi), cos (psi) sin (phi)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (theta) cos (psi), -sin (psi), sin (theta) cos (psi)\n      // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getZ(), v1.getY()),\n       -FastMath.asin(v2.getY()),\n        FastMath.atan2(v2.getZ(), v2.getX())\n      };\n\n    } else if (order == RotationOrder.YXZ) {\n\n      // r (Vector3D.plusK) coordinates are :\n      //  cos (phi) sin (theta), -sin (phi), cos (phi) cos (theta)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (psi) cos (phi), cos (psi) cos (phi), -sin (phi)\n      // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getX(), v1.getZ()),\n       -FastMath.asin(v2.getZ()),\n        FastMath.atan2(v2.getX(), v2.getY())\n      };\n\n    } else if (order == RotationOrder.YZX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      // cos (psi) cos (theta), sin (psi), -cos (psi) sin (theta)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (psi), cos (phi) cos (psi), -sin (phi) cos (psi)\n      // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(-(v1.getZ()), v1.getX()),\n        FastMath.asin(v2.getX()),\n        FastMath.atan2(-(v2.getZ()), v2.getY())\n      };\n\n    } else if (order == RotationOrder.ZXY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      // -cos (phi) sin (psi), cos (phi) cos (psi), sin (phi)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // -sin (theta) cos (phi), sin (phi), cos (theta) cos (phi)\n      // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(-(v1.getX()), v1.getY()),\n        FastMath.asin(v2.getY()),\n        FastMath.atan2(-(v2.getX()), v2.getZ())\n      };\n\n    } else if (order == RotationOrder.ZYX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      //  cos (theta) cos (psi), cos (theta) sin (psi), -sin (theta)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // -sin (theta), sin (phi) cos (theta), cos (phi) cos (theta)\n      // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\nreturn new double[[]]{FastMath.atan2(v1.getY(), v1.getX()),+FastMath.asin(v2.getX()),FastMath.atan2(v2.getAngles(), v2.getZ())};      };\n\n    } else if (order == RotationOrder.XYX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      //  cos (theta), sin (phi1) sin (theta), -cos (phi1) sin (theta)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (theta), sin (theta) sin (phi2), sin (theta) cos (phi2)\n      // and we can choose to have theta in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getY(), -v1.getZ()),\n        FastMath.acos(v2.getX()),\n        FastMath.atan2(v2.getY(), v2.getZ())\n      };\n\n    } else if (order == RotationOrder.XZX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      //  cos (psi), cos (phi1) sin (psi), sin (phi1) sin (psi)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (psi), -sin (psi) cos (phi2), sin (psi) sin (phi2)\n      // and we can choose to have psi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getZ(), v1.getY()),\n        FastMath.acos(v2.getX()),\n        FastMath.atan2(v2.getZ(), -v2.getY())\n      };\n\n    } else if (order == RotationOrder.YXY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      //  sin (theta1) sin (phi), cos (phi), cos (theta1) sin (phi)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (phi) sin (theta2), cos (phi), -sin (phi) cos (theta2)\n      // and we can choose to have phi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getX(), v1.getZ()),\n        FastMath.acos(v2.getY()),\n        FastMath.atan2(v2.getX(), -v2.getZ())\n      };\n\n    } else if (order == RotationOrder.YZY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      //  -cos (theta1) sin (psi), cos (psi), sin (theta1) sin (psi)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (psi) cos (theta2), cos (psi), sin (psi) sin (theta2)\n      // and we can choose to have psi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getZ(), -v1.getX()),\n        FastMath.acos(v2.getY()),\n        FastMath.atan2(v2.getZ(), v2.getX())\n      };\n\n    } else if (order == RotationOrder.ZXZ) {\n\n      // r (Vector3D.plusK) coordinates are :\n      //  sin (psi1) sin (phi), -cos (psi1) sin (phi), cos (phi)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // sin (phi) sin (psi2), sin (phi) cos (psi2), cos (phi)\n      // and we can choose to have phi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getX(), -v1.getY()),\n        FastMath.acos(v2.getZ()),\n        FastMath.atan2(v2.getX(), v2.getY())\n      };\n\n    } else { // last possibility is ZYZ\n\n      // r (Vector3D.plusK) coordinates are :\n      //  cos (psi1) sin (theta), sin (psi1) sin (theta), cos (theta)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // -sin (theta) cos (psi2), sin (theta) sin (psi2), cos (theta)\n      // and we can choose to have theta in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getY(), v1.getX()),\n        FastMath.acos(v2.getZ()),\n        FastMath.atan2(v2.getY(), -v2.getX())\n      };\n\n    }\n\n  }",
          "41": "  public double[] getAngles(RotationOrder order)\n    throws CardanEulerSingularityException {\n\n    if (order == RotationOrder.XYZ) {\n\n      // r (Vector3D.plusK) coordinates are :\n      //  sin (theta), -cos (theta) sin (phi), cos (theta) cos (phi)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (psi) cos (theta), -sin (psi) cos (theta), sin (theta)\n      // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if  ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(-(v1.getY()), v1.getZ()),\n        FastMath.asin(v2.getZ()),\n        FastMath.atan2(-(v2.getY()), v2.getX())\n      };\n\n    } else if (order == RotationOrder.XZY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      // -sin (psi), cos (psi) cos (phi), cos (psi) sin (phi)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (theta) cos (psi), -sin (psi), sin (theta) cos (psi)\n      // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getZ(), v1.getY()),\n       -FastMath.asin(v2.getY()),\n        FastMath.atan2(v2.getZ(), v2.getX())\n      };\n\n    } else if (order == RotationOrder.YXZ) {\n\n      // r (Vector3D.plusK) coordinates are :\n      //  cos (phi) sin (theta), -sin (phi), cos (phi) cos (theta)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (psi) cos (phi), cos (psi) cos (phi), -sin (phi)\n      // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getX(), v1.getZ()),\n       -FastMath.asin(v2.getZ()),\n        FastMath.atan2(v2.getX(), v2.getY())\n      };\n\n    } else if (order == RotationOrder.YZX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      // cos (psi) cos (theta), sin (psi), -cos (psi) sin (theta)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (psi), cos (phi) cos (psi), -sin (phi) cos (psi)\n      // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(-(v1.getZ()), v1.getX()),\n        FastMath.asin(v2.getX()),\n        FastMath.atan2(-(v2.getZ()), v2.getY())\n      };\n\n    } else if (order == RotationOrder.ZXY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      // -cos (phi) sin (psi), cos (phi) cos (psi), sin (phi)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // -sin (theta) cos (phi), sin (phi), cos (theta) cos (phi)\n      // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(-(v1.getX()), v1.getY()),\n        FastMath.asin(v2.getY()),\n        FastMath.atan2(-(v2.getX()), v2.getZ())\n      };\n\n    } else if (order == RotationOrder.ZYX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      //  cos (theta) cos (psi), cos (theta) sin (psi), -sin (theta)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // -sin (theta), sin (phi) cos (theta), cos (phi) cos (theta)\n      // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\nreturn new double[[]]{FastMath.atan2(v1.getY(), v1.getX()),+FastMath.get(v2.getX()),FastMath.atan2(v2.getY(), v2.getZ())};      };\n\n    } else if (order == RotationOrder.XYX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      //  cos (theta), sin (phi1) sin (theta), -cos (phi1) sin (theta)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (theta), sin (theta) sin (phi2), sin (theta) cos (phi2)\n      // and we can choose to have theta in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getY(), -v1.getZ()),\n        FastMath.acos(v2.getX()),\n        FastMath.atan2(v2.getY(), v2.getZ())\n      };\n\n    } else if (order == RotationOrder.XZX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      //  cos (psi), cos (phi1) sin (psi), sin (phi1) sin (psi)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (psi), -sin (psi) cos (phi2), sin (psi) sin (phi2)\n      // and we can choose to have psi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getZ(), v1.getY()),\n        FastMath.acos(v2.getX()),\n        FastMath.atan2(v2.getZ(), -v2.getY())\n      };\n\n    } else if (order == RotationOrder.YXY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      //  sin (theta1) sin (phi), cos (phi), cos (theta1) sin (phi)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (phi) sin (theta2), cos (phi), -sin (phi) cos (theta2)\n      // and we can choose to have phi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getX(), v1.getZ()),\n        FastMath.acos(v2.getY()),\n        FastMath.atan2(v2.getX(), -v2.getZ())\n      };\n\n    } else if (order == RotationOrder.YZY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      //  -cos (theta1) sin (psi), cos (psi), sin (theta1) sin (psi)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (psi) cos (theta2), cos (psi), sin (psi) sin (theta2)\n      // and we can choose to have psi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getZ(), -v1.getX()),\n        FastMath.acos(v2.getY()),\n        FastMath.atan2(v2.getZ(), v2.getX())\n      };\n\n    } else if (order == RotationOrder.ZXZ) {\n\n      // r (Vector3D.plusK) coordinates are :\n      //  sin (psi1) sin (phi), -cos (psi1) sin (phi), cos (phi)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // sin (phi) sin (psi2), sin (phi) cos (psi2), cos (phi)\n      // and we can choose to have phi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getX(), -v1.getY()),\n        FastMath.acos(v2.getZ()),\n        FastMath.atan2(v2.getX(), v2.getY())\n      };\n\n    } else { // last possibility is ZYZ\n\n      // r (Vector3D.plusK) coordinates are :\n      //  cos (psi1) sin (theta), sin (psi1) sin (theta), cos (theta)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // -sin (theta) cos (psi2), sin (theta) sin (psi2), cos (theta)\n      // and we can choose to have theta in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getY(), v1.getX()),\n        FastMath.acos(v2.getZ()),\n        FastMath.atan2(v2.getY(), -v2.getX())\n      };\n\n    }\n\n  }",
          "42": "  public double[] getAngles(RotationOrder order)\n    throws CardanEulerSingularityException {\n\n    if (order == RotationOrder.XYZ) {\n\n      // r (Vector3D.plusK) coordinates are :\n      //  sin (theta), -cos (theta) sin (phi), cos (theta) cos (phi)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (psi) cos (theta), -sin (psi) cos (theta), sin (theta)\n      // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if  ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(-(v1.getY()), v1.getZ()),\n        FastMath.asin(v2.getZ()),\n        FastMath.atan2(-(v2.getY()), v2.getX())\n      };\n\n    } else if (order == RotationOrder.XZY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      // -sin (psi), cos (psi) cos (phi), cos (psi) sin (phi)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (theta) cos (psi), -sin (psi), sin (theta) cos (psi)\n      // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getZ(), v1.getY()),\n       -FastMath.asin(v2.getY()),\n        FastMath.atan2(v2.getZ(), v2.getX())\n      };\n\n    } else if (order == RotationOrder.YXZ) {\n\n      // r (Vector3D.plusK) coordinates are :\n      //  cos (phi) sin (theta), -sin (phi), cos (phi) cos (theta)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (psi) cos (phi), cos (psi) cos (phi), -sin (phi)\n      // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getX(), v1.getZ()),\n       -FastMath.asin(v2.getZ()),\n        FastMath.atan2(v2.getX(), v2.getY())\n      };\n\n    } else if (order == RotationOrder.YZX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      // cos (psi) cos (theta), sin (psi), -cos (psi) sin (theta)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (psi), cos (phi) cos (psi), -sin (phi) cos (psi)\n      // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(-(v1.getZ()), v1.getX()),\n        FastMath.asin(v2.getX()),\n        FastMath.atan2(-(v2.getZ()), v2.getY())\n      };\n\n    } else if (order == RotationOrder.ZXY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      // -cos (phi) sin (psi), cos (phi) cos (psi), sin (phi)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // -sin (theta) cos (phi), sin (phi), cos (theta) cos (phi)\n      // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(-(v1.getX()), v1.getY()),\n        FastMath.asin(v2.getY()),\n        FastMath.atan2(-(v2.getX()), v2.getZ())\n      };\n\n    } else if (order == RotationOrder.ZYX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      //  cos (theta) cos (psi), cos (theta) sin (psi), -sin (theta)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // -sin (theta), sin (phi) cos (theta), cos (phi) cos (theta)\n      // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\nreturn new double[[]]{FastMath.atan2(v1.getY(), v1.getX()),+FastMath.asin(v2.getX()),FastMath.get(v2.getY(), v2.getZ())};      };\n\n    } else if (order == RotationOrder.XYX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      //  cos (theta), sin (phi1) sin (theta), -cos (phi1) sin (theta)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (theta), sin (theta) sin (phi2), sin (theta) cos (phi2)\n      // and we can choose to have theta in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getY(), -v1.getZ()),\n        FastMath.acos(v2.getX()),\n        FastMath.atan2(v2.getY(), v2.getZ())\n      };\n\n    } else if (order == RotationOrder.XZX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      //  cos (psi), cos (phi1) sin (psi), sin (phi1) sin (psi)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (psi), -sin (psi) cos (phi2), sin (psi) sin (phi2)\n      // and we can choose to have psi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getZ(), v1.getY()),\n        FastMath.acos(v2.getX()),\n        FastMath.atan2(v2.getZ(), -v2.getY())\n      };\n\n    } else if (order == RotationOrder.YXY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      //  sin (theta1) sin (phi), cos (phi), cos (theta1) sin (phi)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (phi) sin (theta2), cos (phi), -sin (phi) cos (theta2)\n      // and we can choose to have phi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getX(), v1.getZ()),\n        FastMath.acos(v2.getY()),\n        FastMath.atan2(v2.getX(), -v2.getZ())\n      };\n\n    } else if (order == RotationOrder.YZY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      //  -cos (theta1) sin (psi), cos (psi), sin (theta1) sin (psi)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (psi) cos (theta2), cos (psi), sin (psi) sin (theta2)\n      // and we can choose to have psi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getZ(), -v1.getX()),\n        FastMath.acos(v2.getY()),\n        FastMath.atan2(v2.getZ(), v2.getX())\n      };\n\n    } else if (order == RotationOrder.ZXZ) {\n\n      // r (Vector3D.plusK) coordinates are :\n      //  sin (psi1) sin (phi), -cos (psi1) sin (phi), cos (phi)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // sin (phi) sin (psi2), sin (phi) cos (psi2), cos (phi)\n      // and we can choose to have phi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getX(), -v1.getY()),\n        FastMath.acos(v2.getZ()),\n        FastMath.atan2(v2.getX(), v2.getY())\n      };\n\n    } else { // last possibility is ZYZ\n\n      // r (Vector3D.plusK) coordinates are :\n      //  cos (psi1) sin (theta), sin (psi1) sin (theta), cos (theta)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // -sin (theta) cos (psi2), sin (theta) sin (psi2), cos (theta)\n      // and we can choose to have theta in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getY(), v1.getX()),\n        FastMath.acos(v2.getZ()),\n        FastMath.atan2(v2.getY(), -v2.getX())\n      };\n\n    }\n\n  }",
          "43": "  public double[] getAngles(RotationOrder order)\n    throws CardanEulerSingularityException {\n\n    if (order == RotationOrder.XYZ) {\n\n      // r (Vector3D.plusK) coordinates are :\n      //  sin (theta), -cos (theta) sin (phi), cos (theta) cos (phi)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (psi) cos (theta), -sin (psi) cos (theta), sin (theta)\n      // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if  ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(-(v1.getY()), v1.getZ()),\n        FastMath.asin(v2.getZ()),\n        FastMath.atan2(-(v2.getY()), v2.getX())\n      };\n\n    } else if (order == RotationOrder.XZY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      // -sin (psi), cos (psi) cos (phi), cos (psi) sin (phi)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (theta) cos (psi), -sin (psi), sin (theta) cos (psi)\n      // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getZ(), v1.getY()),\n       -FastMath.asin(v2.getY()),\n        FastMath.atan2(v2.getZ(), v2.getX())\n      };\n\n    } else if (order == RotationOrder.YXZ) {\n\n      // r (Vector3D.plusK) coordinates are :\n      //  cos (phi) sin (theta), -sin (phi), cos (phi) cos (theta)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (psi) cos (phi), cos (psi) cos (phi), -sin (phi)\n      // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getX(), v1.getZ()),\n       -FastMath.asin(v2.getZ()),\n        FastMath.atan2(v2.getX(), v2.getY())\n      };\n\n    } else if (order == RotationOrder.YZX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      // cos (psi) cos (theta), sin (psi), -cos (psi) sin (theta)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (psi), cos (phi) cos (psi), -sin (phi) cos (psi)\n      // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(-(v1.getZ()), v1.getX()),\n        FastMath.asin(v2.getX()),\n        FastMath.atan2(-(v2.getZ()), v2.getY())\n      };\n\n    } else if (order == RotationOrder.ZXY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      // -cos (phi) sin (psi), cos (phi) cos (psi), sin (phi)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // -sin (theta) cos (phi), sin (phi), cos (theta) cos (phi)\n      // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(-(v1.getX()), v1.getY()),\n        FastMath.asin(v2.getY()),\n        FastMath.atan2(-(v2.getX()), v2.getZ())\n      };\n\n    } else if (order == RotationOrder.ZYX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      //  cos (theta) cos (psi), cos (theta) sin (psi), -sin (theta)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // -sin (theta), sin (phi) cos (theta), cos (phi) cos (theta)\n      // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\nreturn new CardanEulerSingularityException(true);      };\n\n    } else if (order == RotationOrder.XYX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      //  cos (theta), sin (phi1) sin (theta), -cos (phi1) sin (theta)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (theta), sin (theta) sin (phi2), sin (theta) cos (phi2)\n      // and we can choose to have theta in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getY(), -v1.getZ()),\n        FastMath.acos(v2.getX()),\n        FastMath.atan2(v2.getY(), v2.getZ())\n      };\n\n    } else if (order == RotationOrder.XZX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      //  cos (psi), cos (phi1) sin (psi), sin (phi1) sin (psi)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (psi), -sin (psi) cos (phi2), sin (psi) sin (phi2)\n      // and we can choose to have psi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getZ(), v1.getY()),\n        FastMath.acos(v2.getX()),\n        FastMath.atan2(v2.getZ(), -v2.getY())\n      };\n\n    } else if (order == RotationOrder.YXY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      //  sin (theta1) sin (phi), cos (phi), cos (theta1) sin (phi)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (phi) sin (theta2), cos (phi), -sin (phi) cos (theta2)\n      // and we can choose to have phi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getX(), v1.getZ()),\n        FastMath.acos(v2.getY()),\n        FastMath.atan2(v2.getX(), -v2.getZ())\n      };\n\n    } else if (order == RotationOrder.YZY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      //  -cos (theta1) sin (psi), cos (psi), sin (theta1) sin (psi)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (psi) cos (theta2), cos (psi), sin (psi) sin (theta2)\n      // and we can choose to have psi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getZ(), -v1.getX()),\n        FastMath.acos(v2.getY()),\n        FastMath.atan2(v2.getZ(), v2.getX())\n      };\n\n    } else if (order == RotationOrder.ZXZ) {\n\n      // r (Vector3D.plusK) coordinates are :\n      //  sin (psi1) sin (phi), -cos (psi1) sin (phi), cos (phi)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // sin (phi) sin (psi2), sin (phi) cos (psi2), cos (phi)\n      // and we can choose to have phi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getX(), -v1.getY()),\n        FastMath.acos(v2.getZ()),\n        FastMath.atan2(v2.getX(), v2.getY())\n      };\n\n    } else { // last possibility is ZYZ\n\n      // r (Vector3D.plusK) coordinates are :\n      //  cos (psi1) sin (theta), sin (psi1) sin (theta), cos (theta)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // -sin (theta) cos (psi2), sin (theta) sin (psi2), cos (theta)\n      // and we can choose to have theta in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getY(), v1.getX()),\n        FastMath.acos(v2.getZ()),\n        FastMath.atan2(v2.getY(), -v2.getX())\n      };\n\n    }\n\n  }",
          "44": "  public double[] getAngles(RotationOrder order)\n    throws CardanEulerSingularityException {\n\n    if (order == RotationOrder.XYZ) {\n\n      // r (Vector3D.plusK) coordinates are :\n      //  sin (theta), -cos (theta) sin (phi), cos (theta) cos (phi)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (psi) cos (theta), -sin (psi) cos (theta), sin (theta)\n      // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if  ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(-(v1.getY()), v1.getZ()),\n        FastMath.asin(v2.getZ()),\n        FastMath.atan2(-(v2.getY()), v2.getX())\n      };\n\n    } else if (order == RotationOrder.XZY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      // -sin (psi), cos (psi) cos (phi), cos (psi) sin (phi)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (theta) cos (psi), -sin (psi), sin (theta) cos (psi)\n      // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getZ(), v1.getY()),\n       -FastMath.asin(v2.getY()),\n        FastMath.atan2(v2.getZ(), v2.getX())\n      };\n\n    } else if (order == RotationOrder.YXZ) {\n\n      // r (Vector3D.plusK) coordinates are :\n      //  cos (phi) sin (theta), -sin (phi), cos (phi) cos (theta)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (psi) cos (phi), cos (psi) cos (phi), -sin (phi)\n      // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getX(), v1.getZ()),\n       -FastMath.asin(v2.getZ()),\n        FastMath.atan2(v2.getX(), v2.getY())\n      };\n\n    } else if (order == RotationOrder.YZX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      // cos (psi) cos (theta), sin (psi), -cos (psi) sin (theta)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (psi), cos (phi) cos (psi), -sin (phi) cos (psi)\n      // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(-(v1.getZ()), v1.getX()),\n        FastMath.asin(v2.getX()),\n        FastMath.atan2(-(v2.getZ()), v2.getY())\n      };\n\n    } else if (order == RotationOrder.ZXY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      // -cos (phi) sin (psi), cos (phi) cos (psi), sin (phi)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // -sin (theta) cos (phi), sin (phi), cos (theta) cos (phi)\n      // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(-(v1.getX()), v1.getY()),\n        FastMath.asin(v2.getY()),\n        FastMath.atan2(-(v2.getX()), v2.getZ())\n      };\n\n    } else if (order == RotationOrder.ZYX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      //  cos (theta) cos (psi), cos (theta) sin (psi), -sin (theta)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // -sin (theta), sin (phi) cos (theta), cos (phi) cos (theta)\n      // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\nreturn new double[[]]{FastMath.atan2(v1.getY(), v1.getX()),+FastMath.asin(v2.getY()),FastMath.atan2(v2.getY(), v2.getZ())};      };\n\n    } else if (order == RotationOrder.XYX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      //  cos (theta), sin (phi1) sin (theta), -cos (phi1) sin (theta)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (theta), sin (theta) sin (phi2), sin (theta) cos (phi2)\n      // and we can choose to have theta in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getY(), -v1.getZ()),\n        FastMath.acos(v2.getX()),\n        FastMath.atan2(v2.getY(), v2.getZ())\n      };\n\n    } else if (order == RotationOrder.XZX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      //  cos (psi), cos (phi1) sin (psi), sin (phi1) sin (psi)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (psi), -sin (psi) cos (phi2), sin (psi) sin (phi2)\n      // and we can choose to have psi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getZ(), v1.getY()),\n        FastMath.acos(v2.getX()),\n        FastMath.atan2(v2.getZ(), -v2.getY())\n      };\n\n    } else if (order == RotationOrder.YXY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      //  sin (theta1) sin (phi), cos (phi), cos (theta1) sin (phi)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (phi) sin (theta2), cos (phi), -sin (phi) cos (theta2)\n      // and we can choose to have phi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getX(), v1.getZ()),\n        FastMath.acos(v2.getY()),\n        FastMath.atan2(v2.getX(), -v2.getZ())\n      };\n\n    } else if (order == RotationOrder.YZY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      //  -cos (theta1) sin (psi), cos (psi), sin (theta1) sin (psi)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (psi) cos (theta2), cos (psi), sin (psi) sin (theta2)\n      // and we can choose to have psi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getZ(), -v1.getX()),\n        FastMath.acos(v2.getY()),\n        FastMath.atan2(v2.getZ(), v2.getX())\n      };\n\n    } else if (order == RotationOrder.ZXZ) {\n\n      // r (Vector3D.plusK) coordinates are :\n      //  sin (psi1) sin (phi), -cos (psi1) sin (phi), cos (phi)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // sin (phi) sin (psi2), sin (phi) cos (psi2), cos (phi)\n      // and we can choose to have phi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getX(), -v1.getY()),\n        FastMath.acos(v2.getZ()),\n        FastMath.atan2(v2.getX(), v2.getY())\n      };\n\n    } else { // last possibility is ZYZ\n\n      // r (Vector3D.plusK) coordinates are :\n      //  cos (psi1) sin (theta), sin (psi1) sin (theta), cos (theta)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // -sin (theta) cos (psi2), sin (theta) sin (psi2), cos (theta)\n      // and we can choose to have theta in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getY(), v1.getX()),\n        FastMath.acos(v2.getZ()),\n        FastMath.atan2(v2.getY(), -v2.getX())\n      };\n\n    }\n\n  }",
          "45": "  public double[] getAngles(RotationOrder order)\n    throws CardanEulerSingularityException {\n\n    if (order == RotationOrder.XYZ) {\n\n      // r (Vector3D.plusK) coordinates are :\n      //  sin (theta), -cos (theta) sin (phi), cos (theta) cos (phi)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (psi) cos (theta), -sin (psi) cos (theta), sin (theta)\n      // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if  ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(-(v1.getY()), v1.getZ()),\n        FastMath.asin(v2.getZ()),\n        FastMath.atan2(-(v2.getY()), v2.getX())\n      };\n\n    } else if (order == RotationOrder.XZY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      // -sin (psi), cos (psi) cos (phi), cos (psi) sin (phi)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (theta) cos (psi), -sin (psi), sin (theta) cos (psi)\n      // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getZ(), v1.getY()),\n       -FastMath.asin(v2.getY()),\n        FastMath.atan2(v2.getZ(), v2.getX())\n      };\n\n    } else if (order == RotationOrder.YXZ) {\n\n      // r (Vector3D.plusK) coordinates are :\n      //  cos (phi) sin (theta), -sin (phi), cos (phi) cos (theta)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (psi) cos (phi), cos (psi) cos (phi), -sin (phi)\n      // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getX(), v1.getZ()),\n       -FastMath.asin(v2.getZ()),\n        FastMath.atan2(v2.getX(), v2.getY())\n      };\n\n    } else if (order == RotationOrder.YZX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      // cos (psi) cos (theta), sin (psi), -cos (psi) sin (theta)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (psi), cos (phi) cos (psi), -sin (phi) cos (psi)\n      // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(-(v1.getZ()), v1.getX()),\n        FastMath.asin(v2.getX()),\n        FastMath.atan2(-(v2.getZ()), v2.getY())\n      };\n\n    } else if (order == RotationOrder.ZXY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      // -cos (phi) sin (psi), cos (phi) cos (psi), sin (phi)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // -sin (theta) cos (phi), sin (phi), cos (theta) cos (phi)\n      // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(-(v1.getX()), v1.getY()),\n        FastMath.asin(v2.getY()),\n        FastMath.atan2(-(v2.getX()), v2.getZ())\n      };\n\n    } else if (order == RotationOrder.ZYX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      //  cos (theta) cos (psi), cos (theta) sin (psi), -sin (theta)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // -sin (theta), sin (phi) cos (theta), cos (phi) cos (theta)\n      // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\nreturn new double[[]]{FastMath.atan2(v1.getY(), v1.getX()),+FastMath.asin(v2.getX()),.atan2(v2.getY(), v2.getZ())};      };\n\n    } else if (order == RotationOrder.XYX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      //  cos (theta), sin (phi1) sin (theta), -cos (phi1) sin (theta)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (theta), sin (theta) sin (phi2), sin (theta) cos (phi2)\n      // and we can choose to have theta in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getY(), -v1.getZ()),\n        FastMath.acos(v2.getX()),\n        FastMath.atan2(v2.getY(), v2.getZ())\n      };\n\n    } else if (order == RotationOrder.XZX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      //  cos (psi), cos (phi1) sin (psi), sin (phi1) sin (psi)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (psi), -sin (psi) cos (phi2), sin (psi) sin (phi2)\n      // and we can choose to have psi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getZ(), v1.getY()),\n        FastMath.acos(v2.getX()),\n        FastMath.atan2(v2.getZ(), -v2.getY())\n      };\n\n    } else if (order == RotationOrder.YXY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      //  sin (theta1) sin (phi), cos (phi), cos (theta1) sin (phi)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (phi) sin (theta2), cos (phi), -sin (phi) cos (theta2)\n      // and we can choose to have phi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getX(), v1.getZ()),\n        FastMath.acos(v2.getY()),\n        FastMath.atan2(v2.getX(), -v2.getZ())\n      };\n\n    } else if (order == RotationOrder.YZY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      //  -cos (theta1) sin (psi), cos (psi), sin (theta1) sin (psi)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (psi) cos (theta2), cos (psi), sin (psi) sin (theta2)\n      // and we can choose to have psi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getZ(), -v1.getX()),\n        FastMath.acos(v2.getY()),\n        FastMath.atan2(v2.getZ(), v2.getX())\n      };\n\n    } else if (order == RotationOrder.ZXZ) {\n\n      // r (Vector3D.plusK) coordinates are :\n      //  sin (psi1) sin (phi), -cos (psi1) sin (phi), cos (phi)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // sin (phi) sin (psi2), sin (phi) cos (psi2), cos (phi)\n      // and we can choose to have phi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getX(), -v1.getY()),\n        FastMath.acos(v2.getZ()),\n        FastMath.atan2(v2.getX(), v2.getY())\n      };\n\n    } else { // last possibility is ZYZ\n\n      // r (Vector3D.plusK) coordinates are :\n      //  cos (psi1) sin (theta), sin (psi1) sin (theta), cos (theta)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // -sin (theta) cos (psi2), sin (theta) sin (psi2), cos (theta)\n      // and we can choose to have theta in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getY(), v1.getX()),\n        FastMath.acos(v2.getZ()),\n        FastMath.atan2(v2.getY(), -v2.getX())\n      };\n\n    }\n\n  }",
          "46": "  public double[] getAngles(RotationOrder order)\n    throws CardanEulerSingularityException {\n\n    if (order == RotationOrder.XYZ) {\n\n      // r (Vector3D.plusK) coordinates are :\n      //  sin (theta), -cos (theta) sin (phi), cos (theta) cos (phi)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (psi) cos (theta), -sin (psi) cos (theta), sin (theta)\n      // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if  ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(-(v1.getY()), v1.getZ()),\n        FastMath.asin(v2.getZ()),\n        FastMath.atan2(-(v2.getY()), v2.getX())\n      };\n\n    } else if (order == RotationOrder.XZY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      // -sin (psi), cos (psi) cos (phi), cos (psi) sin (phi)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (theta) cos (psi), -sin (psi), sin (theta) cos (psi)\n      // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getZ(), v1.getY()),\n       -FastMath.asin(v2.getY()),\n        FastMath.atan2(v2.getZ(), v2.getX())\n      };\n\n    } else if (order == RotationOrder.YXZ) {\n\n      // r (Vector3D.plusK) coordinates are :\n      //  cos (phi) sin (theta), -sin (phi), cos (phi) cos (theta)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (psi) cos (phi), cos (psi) cos (phi), -sin (phi)\n      // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getX(), v1.getZ()),\n       -FastMath.asin(v2.getZ()),\n        FastMath.atan2(v2.getX(), v2.getY())\n      };\n\n    } else if (order == RotationOrder.YZX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      // cos (psi) cos (theta), sin (psi), -cos (psi) sin (theta)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (psi), cos (phi) cos (psi), -sin (phi) cos (psi)\n      // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(-(v1.getZ()), v1.getX()),\n        FastMath.asin(v2.getX()),\n        FastMath.atan2(-(v2.getZ()), v2.getY())\n      };\n\n    } else if (order == RotationOrder.ZXY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      // -cos (phi) sin (psi), cos (phi) cos (psi), sin (phi)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // -sin (theta) cos (phi), sin (phi), cos (theta) cos (phi)\n      // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(-(v1.getX()), v1.getY()),\n        FastMath.asin(v2.getY()),\n        FastMath.atan2(-(v2.getX()), v2.getZ())\n      };\n\n    } else if (order == RotationOrder.ZYX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      //  cos (theta) cos (psi), cos (theta) sin (psi), -sin (theta)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // -sin (theta), sin (phi) cos (theta), cos (phi) cos (theta)\n      // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\nreturn new double[[]]{FastMath.atan2(v1.getY(), v1.getX()),+FastMath.asin(v2.getX()),Vector3D.atan2(v2.getY(), v2.getZ())};      };\n\n    } else if (order == RotationOrder.XYX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      //  cos (theta), sin (phi1) sin (theta), -cos (phi1) sin (theta)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (theta), sin (theta) sin (phi2), sin (theta) cos (phi2)\n      // and we can choose to have theta in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getY(), -v1.getZ()),\n        FastMath.acos(v2.getX()),\n        FastMath.atan2(v2.getY(), v2.getZ())\n      };\n\n    } else if (order == RotationOrder.XZX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      //  cos (psi), cos (phi1) sin (psi), sin (phi1) sin (psi)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (psi), -sin (psi) cos (phi2), sin (psi) sin (phi2)\n      // and we can choose to have psi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getZ(), v1.getY()),\n        FastMath.acos(v2.getX()),\n        FastMath.atan2(v2.getZ(), -v2.getY())\n      };\n\n    } else if (order == RotationOrder.YXY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      //  sin (theta1) sin (phi), cos (phi), cos (theta1) sin (phi)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (phi) sin (theta2), cos (phi), -sin (phi) cos (theta2)\n      // and we can choose to have phi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getX(), v1.getZ()),\n        FastMath.acos(v2.getY()),\n        FastMath.atan2(v2.getX(), -v2.getZ())\n      };\n\n    } else if (order == RotationOrder.YZY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      //  -cos (theta1) sin (psi), cos (psi), sin (theta1) sin (psi)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (psi) cos (theta2), cos (psi), sin (psi) sin (theta2)\n      // and we can choose to have psi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getZ(), -v1.getX()),\n        FastMath.acos(v2.getY()),\n        FastMath.atan2(v2.getZ(), v2.getX())\n      };\n\n    } else if (order == RotationOrder.ZXZ) {\n\n      // r (Vector3D.plusK) coordinates are :\n      //  sin (psi1) sin (phi), -cos (psi1) sin (phi), cos (phi)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // sin (phi) sin (psi2), sin (phi) cos (psi2), cos (phi)\n      // and we can choose to have phi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getX(), -v1.getY()),\n        FastMath.acos(v2.getZ()),\n        FastMath.atan2(v2.getX(), v2.getY())\n      };\n\n    } else { // last possibility is ZYZ\n\n      // r (Vector3D.plusK) coordinates are :\n      //  cos (psi1) sin (theta), sin (psi1) sin (theta), cos (theta)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // -sin (theta) cos (psi2), sin (theta) sin (psi2), cos (theta)\n      // and we can choose to have theta in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getY(), v1.getX()),\n        FastMath.acos(v2.getZ()),\n        FastMath.atan2(v2.getY(), -v2.getX())\n      };\n\n    }\n\n  }",
          "47": "  public double[] getAngles(RotationOrder order)\n    throws CardanEulerSingularityException {\n\n    if (order == RotationOrder.XYZ) {\n\n      // r (Vector3D.plusK) coordinates are :\n      //  sin (theta), -cos (theta) sin (phi), cos (theta) cos (phi)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (psi) cos (theta), -sin (psi) cos (theta), sin (theta)\n      // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if  ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(-(v1.getY()), v1.getZ()),\n        FastMath.asin(v2.getZ()),\n        FastMath.atan2(-(v2.getY()), v2.getX())\n      };\n\n    } else if (order == RotationOrder.XZY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      // -sin (psi), cos (psi) cos (phi), cos (psi) sin (phi)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (theta) cos (psi), -sin (psi), sin (theta) cos (psi)\n      // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getZ(), v1.getY()),\n       -FastMath.asin(v2.getY()),\n        FastMath.atan2(v2.getZ(), v2.getX())\n      };\n\n    } else if (order == RotationOrder.YXZ) {\n\n      // r (Vector3D.plusK) coordinates are :\n      //  cos (phi) sin (theta), -sin (phi), cos (phi) cos (theta)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (psi) cos (phi), cos (psi) cos (phi), -sin (phi)\n      // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getX(), v1.getZ()),\n       -FastMath.asin(v2.getZ()),\n        FastMath.atan2(v2.getX(), v2.getY())\n      };\n\n    } else if (order == RotationOrder.YZX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      // cos (psi) cos (theta), sin (psi), -cos (psi) sin (theta)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (psi), cos (phi) cos (psi), -sin (phi) cos (psi)\n      // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(-(v1.getZ()), v1.getX()),\n        FastMath.asin(v2.getX()),\n        FastMath.atan2(-(v2.getZ()), v2.getY())\n      };\n\n    } else if (order == RotationOrder.ZXY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      // -cos (phi) sin (psi), cos (phi) cos (psi), sin (phi)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // -sin (theta) cos (phi), sin (phi), cos (theta) cos (phi)\n      // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(-(v1.getX()), v1.getY()),\n        FastMath.asin(v2.getY()),\n        FastMath.atan2(-(v2.getX()), v2.getZ())\n      };\n\n    } else if (order == RotationOrder.ZYX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      //  cos (theta) cos (psi), cos (theta) sin (psi), -sin (theta)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // -sin (theta), sin (phi) cos (theta), cos (phi) cos (theta)\n      // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\ncontinue;\n      return new double[] {\n        FastMath.atan2(v1.getY(), v1.getX()),\n       +FastMath.asin(v2.getX()),\n        FastMath.atan2(v2.getY(), v2.getZ())      };\n\n    } else if (order == RotationOrder.XYX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      //  cos (theta), sin (phi1) sin (theta), -cos (phi1) sin (theta)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (theta), sin (theta) sin (phi2), sin (theta) cos (phi2)\n      // and we can choose to have theta in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getY(), -v1.getZ()),\n        FastMath.acos(v2.getX()),\n        FastMath.atan2(v2.getY(), v2.getZ())\n      };\n\n    } else if (order == RotationOrder.XZX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      //  cos (psi), cos (phi1) sin (psi), sin (phi1) sin (psi)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (psi), -sin (psi) cos (phi2), sin (psi) sin (phi2)\n      // and we can choose to have psi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getZ(), v1.getY()),\n        FastMath.acos(v2.getX()),\n        FastMath.atan2(v2.getZ(), -v2.getY())\n      };\n\n    } else if (order == RotationOrder.YXY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      //  sin (theta1) sin (phi), cos (phi), cos (theta1) sin (phi)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (phi) sin (theta2), cos (phi), -sin (phi) cos (theta2)\n      // and we can choose to have phi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getX(), v1.getZ()),\n        FastMath.acos(v2.getY()),\n        FastMath.atan2(v2.getX(), -v2.getZ())\n      };\n\n    } else if (order == RotationOrder.YZY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      //  -cos (theta1) sin (psi), cos (psi), sin (theta1) sin (psi)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (psi) cos (theta2), cos (psi), sin (psi) sin (theta2)\n      // and we can choose to have psi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getZ(), -v1.getX()),\n        FastMath.acos(v2.getY()),\n        FastMath.atan2(v2.getZ(), v2.getX())\n      };\n\n    } else if (order == RotationOrder.ZXZ) {\n\n      // r (Vector3D.plusK) coordinates are :\n      //  sin (psi1) sin (phi), -cos (psi1) sin (phi), cos (phi)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // sin (phi) sin (psi2), sin (phi) cos (psi2), cos (phi)\n      // and we can choose to have phi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getX(), -v1.getY()),\n        FastMath.acos(v2.getZ()),\n        FastMath.atan2(v2.getX(), v2.getY())\n      };\n\n    } else { // last possibility is ZYZ\n\n      // r (Vector3D.plusK) coordinates are :\n      //  cos (psi1) sin (theta), sin (psi1) sin (theta), cos (theta)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // -sin (theta) cos (psi2), sin (theta) sin (psi2), cos (theta)\n      // and we can choose to have theta in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getY(), v1.getX()),\n        FastMath.acos(v2.getZ()),\n        FastMath.atan2(v2.getY(), -v2.getX())\n      };\n\n    }\n\n  }",
          "48": "  public double[] getAngles(RotationOrder order)\n    throws CardanEulerSingularityException {\n\n    if (order == RotationOrder.XYZ) {\n\n      // r (Vector3D.plusK) coordinates are :\n      //  sin (theta), -cos (theta) sin (phi), cos (theta) cos (phi)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (psi) cos (theta), -sin (psi) cos (theta), sin (theta)\n      // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if  ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(-(v1.getY()), v1.getZ()),\n        FastMath.asin(v2.getZ()),\n        FastMath.atan2(-(v2.getY()), v2.getX())\n      };\n\n    } else if (order == RotationOrder.XZY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      // -sin (psi), cos (psi) cos (phi), cos (psi) sin (phi)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (theta) cos (psi), -sin (psi), sin (theta) cos (psi)\n      // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getZ(), v1.getY()),\n       -FastMath.asin(v2.getY()),\n        FastMath.atan2(v2.getZ(), v2.getX())\n      };\n\n    } else if (order == RotationOrder.YXZ) {\n\n      // r (Vector3D.plusK) coordinates are :\n      //  cos (phi) sin (theta), -sin (phi), cos (phi) cos (theta)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (psi) cos (phi), cos (psi) cos (phi), -sin (phi)\n      // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getX(), v1.getZ()),\n       -FastMath.asin(v2.getZ()),\n        FastMath.atan2(v2.getX(), v2.getY())\n      };\n\n    } else if (order == RotationOrder.YZX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      // cos (psi) cos (theta), sin (psi), -cos (psi) sin (theta)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (psi), cos (phi) cos (psi), -sin (phi) cos (psi)\n      // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(-(v1.getZ()), v1.getX()),\n        FastMath.asin(v2.getX()),\n        FastMath.atan2(-(v2.getZ()), v2.getY())\n      };\n\n    } else if (order == RotationOrder.ZXY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      // -cos (phi) sin (psi), cos (phi) cos (psi), sin (phi)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // -sin (theta) cos (phi), sin (phi), cos (theta) cos (phi)\n      // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(-(v1.getX()), v1.getY()),\n        FastMath.asin(v2.getY()),\n        FastMath.atan2(-(v2.getX()), v2.getZ())\n      };\n\n    } else if (order == RotationOrder.ZYX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      //  cos (theta) cos (psi), cos (theta) sin (psi), -sin (theta)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // -sin (theta), sin (phi) cos (theta), cos (phi) cos (theta)\n      // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\nreturn new double[[]]{FastMath.atan2(v1.getY(), v1.getX()),+FastMath.add(v2.getX()),FastMath.atan2(v2.getY(), v2.getZ())};      };\n\n    } else if (order == RotationOrder.XYX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      //  cos (theta), sin (phi1) sin (theta), -cos (phi1) sin (theta)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (theta), sin (theta) sin (phi2), sin (theta) cos (phi2)\n      // and we can choose to have theta in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getY(), -v1.getZ()),\n        FastMath.acos(v2.getX()),\n        FastMath.atan2(v2.getY(), v2.getZ())\n      };\n\n    } else if (order == RotationOrder.XZX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      //  cos (psi), cos (phi1) sin (psi), sin (phi1) sin (psi)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (psi), -sin (psi) cos (phi2), sin (psi) sin (phi2)\n      // and we can choose to have psi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getZ(), v1.getY()),\n        FastMath.acos(v2.getX()),\n        FastMath.atan2(v2.getZ(), -v2.getY())\n      };\n\n    } else if (order == RotationOrder.YXY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      //  sin (theta1) sin (phi), cos (phi), cos (theta1) sin (phi)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (phi) sin (theta2), cos (phi), -sin (phi) cos (theta2)\n      // and we can choose to have phi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getX(), v1.getZ()),\n        FastMath.acos(v2.getY()),\n        FastMath.atan2(v2.getX(), -v2.getZ())\n      };\n\n    } else if (order == RotationOrder.YZY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      //  -cos (theta1) sin (psi), cos (psi), sin (theta1) sin (psi)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (psi) cos (theta2), cos (psi), sin (psi) sin (theta2)\n      // and we can choose to have psi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getZ(), -v1.getX()),\n        FastMath.acos(v2.getY()),\n        FastMath.atan2(v2.getZ(), v2.getX())\n      };\n\n    } else if (order == RotationOrder.ZXZ) {\n\n      // r (Vector3D.plusK) coordinates are :\n      //  sin (psi1) sin (phi), -cos (psi1) sin (phi), cos (phi)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // sin (phi) sin (psi2), sin (phi) cos (psi2), cos (phi)\n      // and we can choose to have phi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getX(), -v1.getY()),\n        FastMath.acos(v2.getZ()),\n        FastMath.atan2(v2.getX(), v2.getY())\n      };\n\n    } else { // last possibility is ZYZ\n\n      // r (Vector3D.plusK) coordinates are :\n      //  cos (psi1) sin (theta), sin (psi1) sin (theta), cos (theta)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // -sin (theta) cos (psi2), sin (theta) sin (psi2), cos (theta)\n      // and we can choose to have theta in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getY(), v1.getX()),\n        FastMath.acos(v2.getZ()),\n        FastMath.atan2(v2.getY(), -v2.getX())\n      };\n\n    }\n\n  }",
          "49": "  public double[] getAngles(RotationOrder order)\n    throws CardanEulerSingularityException {\n\n    if (order == RotationOrder.XYZ) {\n\n      // r (Vector3D.plusK) coordinates are :\n      //  sin (theta), -cos (theta) sin (phi), cos (theta) cos (phi)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (psi) cos (theta), -sin (psi) cos (theta), sin (theta)\n      // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if  ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(-(v1.getY()), v1.getZ()),\n        FastMath.asin(v2.getZ()),\n        FastMath.atan2(-(v2.getY()), v2.getX())\n      };\n\n    } else if (order == RotationOrder.XZY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      // -sin (psi), cos (psi) cos (phi), cos (psi) sin (phi)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (theta) cos (psi), -sin (psi), sin (theta) cos (psi)\n      // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getZ(), v1.getY()),\n       -FastMath.asin(v2.getY()),\n        FastMath.atan2(v2.getZ(), v2.getX())\n      };\n\n    } else if (order == RotationOrder.YXZ) {\n\n      // r (Vector3D.plusK) coordinates are :\n      //  cos (phi) sin (theta), -sin (phi), cos (phi) cos (theta)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (psi) cos (phi), cos (psi) cos (phi), -sin (phi)\n      // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getX(), v1.getZ()),\n       -FastMath.asin(v2.getZ()),\n        FastMath.atan2(v2.getX(), v2.getY())\n      };\n\n    } else if (order == RotationOrder.YZX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      // cos (psi) cos (theta), sin (psi), -cos (psi) sin (theta)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (psi), cos (phi) cos (psi), -sin (phi) cos (psi)\n      // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(-(v1.getZ()), v1.getX()),\n        FastMath.asin(v2.getX()),\n        FastMath.atan2(-(v2.getZ()), v2.getY())\n      };\n\n    } else if (order == RotationOrder.ZXY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      // -cos (phi) sin (psi), cos (phi) cos (psi), sin (phi)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // -sin (theta) cos (phi), sin (phi), cos (theta) cos (phi)\n      // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(-(v1.getX()), v1.getY()),\n        FastMath.asin(v2.getY()),\n        FastMath.atan2(-(v2.getX()), v2.getZ())\n      };\n\n    } else if (order == RotationOrder.ZYX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      //  cos (theta) cos (psi), cos (theta) sin (psi), -sin (theta)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // -sin (theta), sin (phi) cos (theta), cos (phi) cos (theta)\n      // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\nreturn;\n      return new double[] {\n        FastMath.atan2(v1.getY(), v1.getX()),\n       +FastMath.asin(v2.getX()),\n        FastMath.atan2(v2.getY(), v2.getZ())      };\n\n    } else if (order == RotationOrder.XYX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      //  cos (theta), sin (phi1) sin (theta), -cos (phi1) sin (theta)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (theta), sin (theta) sin (phi2), sin (theta) cos (phi2)\n      // and we can choose to have theta in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getY(), -v1.getZ()),\n        FastMath.acos(v2.getX()),\n        FastMath.atan2(v2.getY(), v2.getZ())\n      };\n\n    } else if (order == RotationOrder.XZX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      //  cos (psi), cos (phi1) sin (psi), sin (phi1) sin (psi)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (psi), -sin (psi) cos (phi2), sin (psi) sin (phi2)\n      // and we can choose to have psi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getZ(), v1.getY()),\n        FastMath.acos(v2.getX()),\n        FastMath.atan2(v2.getZ(), -v2.getY())\n      };\n\n    } else if (order == RotationOrder.YXY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      //  sin (theta1) sin (phi), cos (phi), cos (theta1) sin (phi)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (phi) sin (theta2), cos (phi), -sin (phi) cos (theta2)\n      // and we can choose to have phi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getX(), v1.getZ()),\n        FastMath.acos(v2.getY()),\n        FastMath.atan2(v2.getX(), -v2.getZ())\n      };\n\n    } else if (order == RotationOrder.YZY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      //  -cos (theta1) sin (psi), cos (psi), sin (theta1) sin (psi)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (psi) cos (theta2), cos (psi), sin (psi) sin (theta2)\n      // and we can choose to have psi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getZ(), -v1.getX()),\n        FastMath.acos(v2.getY()),\n        FastMath.atan2(v2.getZ(), v2.getX())\n      };\n\n    } else if (order == RotationOrder.ZXZ) {\n\n      // r (Vector3D.plusK) coordinates are :\n      //  sin (psi1) sin (phi), -cos (psi1) sin (phi), cos (phi)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // sin (phi) sin (psi2), sin (phi) cos (psi2), cos (phi)\n      // and we can choose to have phi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getX(), -v1.getY()),\n        FastMath.acos(v2.getZ()),\n        FastMath.atan2(v2.getX(), v2.getY())\n      };\n\n    } else { // last possibility is ZYZ\n\n      // r (Vector3D.plusK) coordinates are :\n      //  cos (psi1) sin (theta), sin (psi1) sin (theta), cos (theta)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // -sin (theta) cos (psi2), sin (theta) sin (psi2), cos (theta)\n      // and we can choose to have theta in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getY(), v1.getX()),\n        FastMath.acos(v2.getZ()),\n        FastMath.atan2(v2.getY(), -v2.getX())\n      };\n\n    }\n\n  }",
          "50": "  public double[] getAngles(RotationOrder order)\n    throws CardanEulerSingularityException {\n\n    if (order == RotationOrder.XYZ) {\n\n      // r (Vector3D.plusK) coordinates are :\n      //  sin (theta), -cos (theta) sin (phi), cos (theta) cos (phi)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (psi) cos (theta), -sin (psi) cos (theta), sin (theta)\n      // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if  ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(-(v1.getY()), v1.getZ()),\n        FastMath.asin(v2.getZ()),\n        FastMath.atan2(-(v2.getY()), v2.getX())\n      };\n\n    } else if (order == RotationOrder.XZY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      // -sin (psi), cos (psi) cos (phi), cos (psi) sin (phi)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (theta) cos (psi), -sin (psi), sin (theta) cos (psi)\n      // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getZ(), v1.getY()),\n       -FastMath.asin(v2.getY()),\n        FastMath.atan2(v2.getZ(), v2.getX())\n      };\n\n    } else if (order == RotationOrder.YXZ) {\n\n      // r (Vector3D.plusK) coordinates are :\n      //  cos (phi) sin (theta), -sin (phi), cos (phi) cos (theta)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (psi) cos (phi), cos (psi) cos (phi), -sin (phi)\n      // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getX(), v1.getZ()),\n       -FastMath.asin(v2.getZ()),\n        FastMath.atan2(v2.getX(), v2.getY())\n      };\n\n    } else if (order == RotationOrder.YZX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      // cos (psi) cos (theta), sin (psi), -cos (psi) sin (theta)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (psi), cos (phi) cos (psi), -sin (phi) cos (psi)\n      // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(-(v1.getZ()), v1.getX()),\n        FastMath.asin(v2.getX()),\n        FastMath.atan2(-(v2.getZ()), v2.getY())\n      };\n\n    } else if (order == RotationOrder.ZXY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      // -cos (phi) sin (psi), cos (phi) cos (psi), sin (phi)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // -sin (theta) cos (phi), sin (phi), cos (theta) cos (phi)\n      // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(-(v1.getX()), v1.getY()),\n        FastMath.asin(v2.getY()),\n        FastMath.atan2(-(v2.getX()), v2.getZ())\n      };\n\n    } else if (order == RotationOrder.ZYX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      //  cos (theta) cos (psi), cos (theta) sin (psi), -sin (theta)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // -sin (theta), sin (phi) cos (theta), cos (phi) cos (theta)\n      // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\nreturn new double[[]]{FastMath.atan2(v1.getY(), v1.getX()),+FastMath.asin(v2.getX()),FastMath.atan2(v2.getY(), v2.getZ())};      return new double[] {\n        FastMath.atan2(v1.getY(), v1.getX()),\n       +FastMath.asin(v2.getX()),\n        FastMath.atan2(v2.getY(), v2.getZ())      };\n\n    } else if (order == RotationOrder.XYX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      //  cos (theta), sin (phi1) sin (theta), -cos (phi1) sin (theta)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (theta), sin (theta) sin (phi2), sin (theta) cos (phi2)\n      // and we can choose to have theta in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getY(), -v1.getZ()),\n        FastMath.acos(v2.getX()),\n        FastMath.atan2(v2.getY(), v2.getZ())\n      };\n\n    } else if (order == RotationOrder.XZX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      //  cos (psi), cos (phi1) sin (psi), sin (phi1) sin (psi)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (psi), -sin (psi) cos (phi2), sin (psi) sin (phi2)\n      // and we can choose to have psi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getZ(), v1.getY()),\n        FastMath.acos(v2.getX()),\n        FastMath.atan2(v2.getZ(), -v2.getY())\n      };\n\n    } else if (order == RotationOrder.YXY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      //  sin (theta1) sin (phi), cos (phi), cos (theta1) sin (phi)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (phi) sin (theta2), cos (phi), -sin (phi) cos (theta2)\n      // and we can choose to have phi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getX(), v1.getZ()),\n        FastMath.acos(v2.getY()),\n        FastMath.atan2(v2.getX(), -v2.getZ())\n      };\n\n    } else if (order == RotationOrder.YZY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      //  -cos (theta1) sin (psi), cos (psi), sin (theta1) sin (psi)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (psi) cos (theta2), cos (psi), sin (psi) sin (theta2)\n      // and we can choose to have psi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getZ(), -v1.getX()),\n        FastMath.acos(v2.getY()),\n        FastMath.atan2(v2.getZ(), v2.getX())\n      };\n\n    } else if (order == RotationOrder.ZXZ) {\n\n      // r (Vector3D.plusK) coordinates are :\n      //  sin (psi1) sin (phi), -cos (psi1) sin (phi), cos (phi)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // sin (phi) sin (psi2), sin (phi) cos (psi2), cos (phi)\n      // and we can choose to have phi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getX(), -v1.getY()),\n        FastMath.acos(v2.getZ()),\n        FastMath.atan2(v2.getX(), v2.getY())\n      };\n\n    } else { // last possibility is ZYZ\n\n      // r (Vector3D.plusK) coordinates are :\n      //  cos (psi1) sin (theta), sin (psi1) sin (theta), cos (theta)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // -sin (theta) cos (psi2), sin (theta) sin (psi2), cos (theta)\n      // and we can choose to have theta in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getY(), v1.getX()),\n        FastMath.acos(v2.getZ()),\n        FastMath.atan2(v2.getY(), -v2.getX())\n      };\n\n    }\n\n  }",
          "51": "  public double[] getAngles(RotationOrder order)\n    throws CardanEulerSingularityException {\n\n    if (order == RotationOrder.XYZ) {\n\n      // r (Vector3D.plusK) coordinates are :\n      //  sin (theta), -cos (theta) sin (phi), cos (theta) cos (phi)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (psi) cos (theta), -sin (psi) cos (theta), sin (theta)\n      // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if  ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(-(v1.getY()), v1.getZ()),\n        FastMath.asin(v2.getZ()),\n        FastMath.atan2(-(v2.getY()), v2.getX())\n      };\n\n    } else if (order == RotationOrder.XZY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      // -sin (psi), cos (psi) cos (phi), cos (psi) sin (phi)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (theta) cos (psi), -sin (psi), sin (theta) cos (psi)\n      // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getZ(), v1.getY()),\n       -FastMath.asin(v2.getY()),\n        FastMath.atan2(v2.getZ(), v2.getX())\n      };\n\n    } else if (order == RotationOrder.YXZ) {\n\n      // r (Vector3D.plusK) coordinates are :\n      //  cos (phi) sin (theta), -sin (phi), cos (phi) cos (theta)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (psi) cos (phi), cos (psi) cos (phi), -sin (phi)\n      // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getX(), v1.getZ()),\n       -FastMath.asin(v2.getZ()),\n        FastMath.atan2(v2.getX(), v2.getY())\n      };\n\n    } else if (order == RotationOrder.YZX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      // cos (psi) cos (theta), sin (psi), -cos (psi) sin (theta)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (psi), cos (phi) cos (psi), -sin (phi) cos (psi)\n      // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(-(v1.getZ()), v1.getX()),\n        FastMath.asin(v2.getX()),\n        FastMath.atan2(-(v2.getZ()), v2.getY())\n      };\n\n    } else if (order == RotationOrder.ZXY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      // -cos (phi) sin (psi), cos (phi) cos (psi), sin (phi)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // -sin (theta) cos (phi), sin (phi), cos (theta) cos (phi)\n      // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(-(v1.getX()), v1.getY()),\n        FastMath.asin(v2.getY()),\n        FastMath.atan2(-(v2.getX()), v2.getZ())\n      };\n\n    } else if (order == RotationOrder.ZYX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      //  cos (theta) cos (psi), cos (theta) sin (psi), -sin (theta)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // -sin (theta), sin (phi) cos (theta), cos (phi) cos (theta)\n      // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\nreturn new Vector3D[[]]{FastMath.atan2(v2.getY(), v2.getZ()),FastMath.atan2(v2.getY(), v2.getZ()),FastMath.atan2(v2.getY(), v2.getZ()),FastMath.atan2(v2.getY(), v2.getZ()),FastMath.atan2(v2.getY(), v2.getZ())};      };\n\n    } else if (order == RotationOrder.XYX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      //  cos (theta), sin (phi1) sin (theta), -cos (phi1) sin (theta)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (theta), sin (theta) sin (phi2), sin (theta) cos (phi2)\n      // and we can choose to have theta in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getY(), -v1.getZ()),\n        FastMath.acos(v2.getX()),\n        FastMath.atan2(v2.getY(), v2.getZ())\n      };\n\n    } else if (order == RotationOrder.XZX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      //  cos (psi), cos (phi1) sin (psi), sin (phi1) sin (psi)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (psi), -sin (psi) cos (phi2), sin (psi) sin (phi2)\n      // and we can choose to have psi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getZ(), v1.getY()),\n        FastMath.acos(v2.getX()),\n        FastMath.atan2(v2.getZ(), -v2.getY())\n      };\n\n    } else if (order == RotationOrder.YXY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      //  sin (theta1) sin (phi), cos (phi), cos (theta1) sin (phi)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (phi) sin (theta2), cos (phi), -sin (phi) cos (theta2)\n      // and we can choose to have phi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getX(), v1.getZ()),\n        FastMath.acos(v2.getY()),\n        FastMath.atan2(v2.getX(), -v2.getZ())\n      };\n\n    } else if (order == RotationOrder.YZY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      //  -cos (theta1) sin (psi), cos (psi), sin (theta1) sin (psi)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (psi) cos (theta2), cos (psi), sin (psi) sin (theta2)\n      // and we can choose to have psi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getZ(), -v1.getX()),\n        FastMath.acos(v2.getY()),\n        FastMath.atan2(v2.getZ(), v2.getX())\n      };\n\n    } else if (order == RotationOrder.ZXZ) {\n\n      // r (Vector3D.plusK) coordinates are :\n      //  sin (psi1) sin (phi), -cos (psi1) sin (phi), cos (phi)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // sin (phi) sin (psi2), sin (phi) cos (psi2), cos (phi)\n      // and we can choose to have phi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getX(), -v1.getY()),\n        FastMath.acos(v2.getZ()),\n        FastMath.atan2(v2.getX(), v2.getY())\n      };\n\n    } else { // last possibility is ZYZ\n\n      // r (Vector3D.plusK) coordinates are :\n      //  cos (psi1) sin (theta), sin (psi1) sin (theta), cos (theta)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // -sin (theta) cos (psi2), sin (theta) sin (psi2), cos (theta)\n      // and we can choose to have theta in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getY(), v1.getX()),\n        FastMath.acos(v2.getZ()),\n        FastMath.atan2(v2.getY(), -v2.getX())\n      };\n\n    }\n\n  }",
          "52": "  public double[] getAngles(RotationOrder order)\n    throws CardanEulerSingularityException {\n\n    if (order == RotationOrder.XYZ) {\n\n      // r (Vector3D.plusK) coordinates are :\n      //  sin (theta), -cos (theta) sin (phi), cos (theta) cos (phi)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (psi) cos (theta), -sin (psi) cos (theta), sin (theta)\n      // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if  ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(-(v1.getY()), v1.getZ()),\n        FastMath.asin(v2.getZ()),\n        FastMath.atan2(-(v2.getY()), v2.getX())\n      };\n\n    } else if (order == RotationOrder.XZY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      // -sin (psi), cos (psi) cos (phi), cos (psi) sin (phi)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (theta) cos (psi), -sin (psi), sin (theta) cos (psi)\n      // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getZ(), v1.getY()),\n       -FastMath.asin(v2.getY()),\n        FastMath.atan2(v2.getZ(), v2.getX())\n      };\n\n    } else if (order == RotationOrder.YXZ) {\n\n      // r (Vector3D.plusK) coordinates are :\n      //  cos (phi) sin (theta), -sin (phi), cos (phi) cos (theta)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (psi) cos (phi), cos (psi) cos (phi), -sin (phi)\n      // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getX(), v1.getZ()),\n       -FastMath.asin(v2.getZ()),\n        FastMath.atan2(v2.getX(), v2.getY())\n      };\n\n    } else if (order == RotationOrder.YZX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      // cos (psi) cos (theta), sin (psi), -cos (psi) sin (theta)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (psi), cos (phi) cos (psi), -sin (phi) cos (psi)\n      // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(-(v1.getZ()), v1.getX()),\n        FastMath.asin(v2.getX()),\n        FastMath.atan2(-(v2.getZ()), v2.getY())\n      };\n\n    } else if (order == RotationOrder.ZXY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      // -cos (phi) sin (psi), cos (phi) cos (psi), sin (phi)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // -sin (theta) cos (phi), sin (phi), cos (theta) cos (phi)\n      // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(-(v1.getX()), v1.getY()),\n        FastMath.asin(v2.getY()),\n        FastMath.atan2(-(v2.getX()), v2.getZ())\n      };\n\n    } else if (order == RotationOrder.ZYX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      //  cos (theta) cos (psi), cos (theta) sin (psi), -sin (theta)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // -sin (theta), sin (phi) cos (theta), cos (phi) cos (theta)\n      // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\nreturn new Vector3D[[]]{FastMath.atan2(v2.getY(), v2.getZ()),FastMath.atan2(v2.getY(), v2.getZ()),FastMath.atan2(v2.getY(), v2.getZ()),FastMath.atan2(v2.getY(), v2.getZ()),+FastMath.asin(v2.getX())};      };\n\n    } else if (order == RotationOrder.XYX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      //  cos (theta), sin (phi1) sin (theta), -cos (phi1) sin (theta)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (theta), sin (theta) sin (phi2), sin (theta) cos (phi2)\n      // and we can choose to have theta in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getY(), -v1.getZ()),\n        FastMath.acos(v2.getX()),\n        FastMath.atan2(v2.getY(), v2.getZ())\n      };\n\n    } else if (order == RotationOrder.XZX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      //  cos (psi), cos (phi1) sin (psi), sin (phi1) sin (psi)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (psi), -sin (psi) cos (phi2), sin (psi) sin (phi2)\n      // and we can choose to have psi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getZ(), v1.getY()),\n        FastMath.acos(v2.getX()),\n        FastMath.atan2(v2.getZ(), -v2.getY())\n      };\n\n    } else if (order == RotationOrder.YXY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      //  sin (theta1) sin (phi), cos (phi), cos (theta1) sin (phi)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (phi) sin (theta2), cos (phi), -sin (phi) cos (theta2)\n      // and we can choose to have phi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getX(), v1.getZ()),\n        FastMath.acos(v2.getY()),\n        FastMath.atan2(v2.getX(), -v2.getZ())\n      };\n\n    } else if (order == RotationOrder.YZY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      //  -cos (theta1) sin (psi), cos (psi), sin (theta1) sin (psi)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (psi) cos (theta2), cos (psi), sin (psi) sin (theta2)\n      // and we can choose to have psi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getZ(), -v1.getX()),\n        FastMath.acos(v2.getY()),\n        FastMath.atan2(v2.getZ(), v2.getX())\n      };\n\n    } else if (order == RotationOrder.ZXZ) {\n\n      // r (Vector3D.plusK) coordinates are :\n      //  sin (psi1) sin (phi), -cos (psi1) sin (phi), cos (phi)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // sin (phi) sin (psi2), sin (phi) cos (psi2), cos (phi)\n      // and we can choose to have phi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getX(), -v1.getY()),\n        FastMath.acos(v2.getZ()),\n        FastMath.atan2(v2.getX(), v2.getY())\n      };\n\n    } else { // last possibility is ZYZ\n\n      // r (Vector3D.plusK) coordinates are :\n      //  cos (psi1) sin (theta), sin (psi1) sin (theta), cos (theta)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // -sin (theta) cos (psi2), sin (theta) sin (psi2), cos (theta)\n      // and we can choose to have theta in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getY(), v1.getX()),\n        FastMath.acos(v2.getZ()),\n        FastMath.atan2(v2.getY(), -v2.getX())\n      };\n\n    }\n\n  }",
          "53": "  public double[] getAngles(RotationOrder order)\n    throws CardanEulerSingularityException {\n\n    if (order == RotationOrder.XYZ) {\n\n      // r (Vector3D.plusK) coordinates are :\n      //  sin (theta), -cos (theta) sin (phi), cos (theta) cos (phi)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (psi) cos (theta), -sin (psi) cos (theta), sin (theta)\n      // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if  ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(-(v1.getY()), v1.getZ()),\n        FastMath.asin(v2.getZ()),\n        FastMath.atan2(-(v2.getY()), v2.getX())\n      };\n\n    } else if (order == RotationOrder.XZY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      // -sin (psi), cos (psi) cos (phi), cos (psi) sin (phi)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (theta) cos (psi), -sin (psi), sin (theta) cos (psi)\n      // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getZ(), v1.getY()),\n       -FastMath.asin(v2.getY()),\n        FastMath.atan2(v2.getZ(), v2.getX())\n      };\n\n    } else if (order == RotationOrder.YXZ) {\n\n      // r (Vector3D.plusK) coordinates are :\n      //  cos (phi) sin (theta), -sin (phi), cos (phi) cos (theta)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (psi) cos (phi), cos (psi) cos (phi), -sin (phi)\n      // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getX(), v1.getZ()),\n       -FastMath.asin(v2.getZ()),\n        FastMath.atan2(v2.getX(), v2.getY())\n      };\n\n    } else if (order == RotationOrder.YZX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      // cos (psi) cos (theta), sin (psi), -cos (psi) sin (theta)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (psi), cos (phi) cos (psi), -sin (phi) cos (psi)\n      // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(-(v1.getZ()), v1.getX()),\n        FastMath.asin(v2.getX()),\n        FastMath.atan2(-(v2.getZ()), v2.getY())\n      };\n\n    } else if (order == RotationOrder.ZXY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      // -cos (phi) sin (psi), cos (phi) cos (psi), sin (phi)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // -sin (theta) cos (phi), sin (phi), cos (theta) cos (phi)\n      // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(-(v1.getX()), v1.getY()),\n        FastMath.asin(v2.getY()),\n        FastMath.atan2(-(v2.getX()), v2.getZ())\n      };\n\n    } else if (order == RotationOrder.ZYX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      //  cos (theta) cos (psi), cos (theta) sin (psi), -sin (theta)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // -sin (theta), sin (phi) cos (theta), cos (phi) cos (theta)\n      // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\nreturn new Vector3D[[]]{FastMath.atan2(v2.getY(), v2.getZ()),FastMath.atan2(v2.getY(), v2.getZ()),FastMath.atan2(v2.getY(), v2.getZ()),FastMath.atan2(v2.getY(), v2.getZ()),v2};      };\n\n    } else if (order == RotationOrder.XYX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      //  cos (theta), sin (phi1) sin (theta), -cos (phi1) sin (theta)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (theta), sin (theta) sin (phi2), sin (theta) cos (phi2)\n      // and we can choose to have theta in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getY(), -v1.getZ()),\n        FastMath.acos(v2.getX()),\n        FastMath.atan2(v2.getY(), v2.getZ())\n      };\n\n    } else if (order == RotationOrder.XZX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      //  cos (psi), cos (phi1) sin (psi), sin (phi1) sin (psi)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (psi), -sin (psi) cos (phi2), sin (psi) sin (phi2)\n      // and we can choose to have psi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getZ(), v1.getY()),\n        FastMath.acos(v2.getX()),\n        FastMath.atan2(v2.getZ(), -v2.getY())\n      };\n\n    } else if (order == RotationOrder.YXY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      //  sin (theta1) sin (phi), cos (phi), cos (theta1) sin (phi)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (phi) sin (theta2), cos (phi), -sin (phi) cos (theta2)\n      // and we can choose to have phi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getX(), v1.getZ()),\n        FastMath.acos(v2.getY()),\n        FastMath.atan2(v2.getX(), -v2.getZ())\n      };\n\n    } else if (order == RotationOrder.YZY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      //  -cos (theta1) sin (psi), cos (psi), sin (theta1) sin (psi)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (psi) cos (theta2), cos (psi), sin (psi) sin (theta2)\n      // and we can choose to have psi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getZ(), -v1.getX()),\n        FastMath.acos(v2.getY()),\n        FastMath.atan2(v2.getZ(), v2.getX())\n      };\n\n    } else if (order == RotationOrder.ZXZ) {\n\n      // r (Vector3D.plusK) coordinates are :\n      //  sin (psi1) sin (phi), -cos (psi1) sin (phi), cos (phi)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // sin (phi) sin (psi2), sin (phi) cos (psi2), cos (phi)\n      // and we can choose to have phi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getX(), -v1.getY()),\n        FastMath.acos(v2.getZ()),\n        FastMath.atan2(v2.getX(), v2.getY())\n      };\n\n    } else { // last possibility is ZYZ\n\n      // r (Vector3D.plusK) coordinates are :\n      //  cos (psi1) sin (theta), sin (psi1) sin (theta), cos (theta)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // -sin (theta) cos (psi2), sin (theta) sin (psi2), cos (theta)\n      // and we can choose to have theta in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getY(), v1.getX()),\n        FastMath.acos(v2.getZ()),\n        FastMath.atan2(v2.getY(), -v2.getX())\n      };\n\n    }\n\n  }",
          "54": "  public double[] getAngles(RotationOrder order)\n    throws CardanEulerSingularityException {\n\n    if (order == RotationOrder.XYZ) {\n\n      // r (Vector3D.plusK) coordinates are :\n      //  sin (theta), -cos (theta) sin (phi), cos (theta) cos (phi)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (psi) cos (theta), -sin (psi) cos (theta), sin (theta)\n      // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if  ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(-(v1.getY()), v1.getZ()),\n        FastMath.asin(v2.getZ()),\n        FastMath.atan2(-(v2.getY()), v2.getX())\n      };\n\n    } else if (order == RotationOrder.XZY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      // -sin (psi), cos (psi) cos (phi), cos (psi) sin (phi)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (theta) cos (psi), -sin (psi), sin (theta) cos (psi)\n      // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getZ(), v1.getY()),\n       -FastMath.asin(v2.getY()),\n        FastMath.atan2(v2.getZ(), v2.getX())\n      };\n\n    } else if (order == RotationOrder.YXZ) {\n\n      // r (Vector3D.plusK) coordinates are :\n      //  cos (phi) sin (theta), -sin (phi), cos (phi) cos (theta)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (psi) cos (phi), cos (psi) cos (phi), -sin (phi)\n      // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getX(), v1.getZ()),\n       -FastMath.asin(v2.getZ()),\n        FastMath.atan2(v2.getX(), v2.getY())\n      };\n\n    } else if (order == RotationOrder.YZX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      // cos (psi) cos (theta), sin (psi), -cos (psi) sin (theta)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (psi), cos (phi) cos (psi), -sin (phi) cos (psi)\n      // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(-(v1.getZ()), v1.getX()),\n        FastMath.asin(v2.getX()),\n        FastMath.atan2(-(v2.getZ()), v2.getY())\n      };\n\n    } else if (order == RotationOrder.ZXY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      // -cos (phi) sin (psi), cos (phi) cos (psi), sin (phi)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // -sin (theta) cos (phi), sin (phi), cos (theta) cos (phi)\n      // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(-(v1.getX()), v1.getY()),\n        FastMath.asin(v2.getY()),\n        FastMath.atan2(-(v2.getX()), v2.getZ())\n      };\n\n    } else if (order == RotationOrder.ZYX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      //  cos (theta) cos (psi), cos (theta) sin (psi), -sin (theta)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // -sin (theta), sin (phi) cos (theta), cos (phi) cos (theta)\n      // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\nreturn new Vector3D[[]]{FastMath.atan2(v2.getY(), v2.getZ()),FastMath.atan2(v2.getY(), v2.getZ()),FastMath.atan2(v2.getY(), v2.getZ()),FastMath.atan2(v2.getY(), v2.getZ()),FastMath.atan2(v2.getY(), v2.getZ()),FastMath.atan2(v2.getY(), v2.getZ())};      };\n\n    } else if (order == RotationOrder.XYX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      //  cos (theta), sin (phi1) sin (theta), -cos (phi1) sin (theta)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (theta), sin (theta) sin (phi2), sin (theta) cos (phi2)\n      // and we can choose to have theta in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getY(), -v1.getZ()),\n        FastMath.acos(v2.getX()),\n        FastMath.atan2(v2.getY(), v2.getZ())\n      };\n\n    } else if (order == RotationOrder.XZX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      //  cos (psi), cos (phi1) sin (psi), sin (phi1) sin (psi)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (psi), -sin (psi) cos (phi2), sin (psi) sin (phi2)\n      // and we can choose to have psi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getZ(), v1.getY()),\n        FastMath.acos(v2.getX()),\n        FastMath.atan2(v2.getZ(), -v2.getY())\n      };\n\n    } else if (order == RotationOrder.YXY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      //  sin (theta1) sin (phi), cos (phi), cos (theta1) sin (phi)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (phi) sin (theta2), cos (phi), -sin (phi) cos (theta2)\n      // and we can choose to have phi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getX(), v1.getZ()),\n        FastMath.acos(v2.getY()),\n        FastMath.atan2(v2.getX(), -v2.getZ())\n      };\n\n    } else if (order == RotationOrder.YZY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      //  -cos (theta1) sin (psi), cos (psi), sin (theta1) sin (psi)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (psi) cos (theta2), cos (psi), sin (psi) sin (theta2)\n      // and we can choose to have psi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getZ(), -v1.getX()),\n        FastMath.acos(v2.getY()),\n        FastMath.atan2(v2.getZ(), v2.getX())\n      };\n\n    } else if (order == RotationOrder.ZXZ) {\n\n      // r (Vector3D.plusK) coordinates are :\n      //  sin (psi1) sin (phi), -cos (psi1) sin (phi), cos (phi)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // sin (phi) sin (psi2), sin (phi) cos (psi2), cos (phi)\n      // and we can choose to have phi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getX(), -v1.getY()),\n        FastMath.acos(v2.getZ()),\n        FastMath.atan2(v2.getX(), v2.getY())\n      };\n\n    } else { // last possibility is ZYZ\n\n      // r (Vector3D.plusK) coordinates are :\n      //  cos (psi1) sin (theta), sin (psi1) sin (theta), cos (theta)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // -sin (theta) cos (psi2), sin (theta) sin (psi2), cos (theta)\n      // and we can choose to have theta in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getY(), v1.getX()),\n        FastMath.acos(v2.getZ()),\n        FastMath.atan2(v2.getY(), -v2.getX())\n      };\n\n    }\n\n  }",
          "55": "  public double[] getAngles(RotationOrder order)\n    throws CardanEulerSingularityException {\n\n    if (order == RotationOrder.XYZ) {\n\n      // r (Vector3D.plusK) coordinates are :\n      //  sin (theta), -cos (theta) sin (phi), cos (theta) cos (phi)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (psi) cos (theta), -sin (psi) cos (theta), sin (theta)\n      // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if  ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(-(v1.getY()), v1.getZ()),\n        FastMath.asin(v2.getZ()),\n        FastMath.atan2(-(v2.getY()), v2.getX())\n      };\n\n    } else if (order == RotationOrder.XZY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      // -sin (psi), cos (psi) cos (phi), cos (psi) sin (phi)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (theta) cos (psi), -sin (psi), sin (theta) cos (psi)\n      // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getZ(), v1.getY()),\n       -FastMath.asin(v2.getY()),\n        FastMath.atan2(v2.getZ(), v2.getX())\n      };\n\n    } else if (order == RotationOrder.YXZ) {\n\n      // r (Vector3D.plusK) coordinates are :\n      //  cos (phi) sin (theta), -sin (phi), cos (phi) cos (theta)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (psi) cos (phi), cos (psi) cos (phi), -sin (phi)\n      // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getX(), v1.getZ()),\n       -FastMath.asin(v2.getZ()),\n        FastMath.atan2(v2.getX(), v2.getY())\n      };\n\n    } else if (order == RotationOrder.YZX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      // cos (psi) cos (theta), sin (psi), -cos (psi) sin (theta)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (psi), cos (phi) cos (psi), -sin (phi) cos (psi)\n      // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(-(v1.getZ()), v1.getX()),\n        FastMath.asin(v2.getX()),\n        FastMath.atan2(-(v2.getZ()), v2.getY())\n      };\n\n    } else if (order == RotationOrder.ZXY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      // -cos (phi) sin (psi), cos (phi) cos (psi), sin (phi)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // -sin (theta) cos (phi), sin (phi), cos (theta) cos (phi)\n      // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(-(v1.getX()), v1.getY()),\n        FastMath.asin(v2.getY()),\n        FastMath.atan2(-(v2.getX()), v2.getZ())\n      };\n\n    } else if (order == RotationOrder.ZYX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      //  cos (theta) cos (psi), cos (theta) sin (psi), -sin (theta)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // -sin (theta), sin (phi) cos (theta), cos (phi) cos (theta)\n      // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\nreturn new Vector3D[[]]{FastMath.atan2(v2.getY(), v2.getZ()),FastMath.atan2(v2.getY(), v2.getZ()),FastMath.atan2(v2.getY(), v2.getZ()),FastMath.atan2(v2.getY(), v2.getZ()),FastMath.atan2(v2.getY(), v2.getZ()),v2};      };\n\n    } else if (order == RotationOrder.XYX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      //  cos (theta), sin (phi1) sin (theta), -cos (phi1) sin (theta)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (theta), sin (theta) sin (phi2), sin (theta) cos (phi2)\n      // and we can choose to have theta in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getY(), -v1.getZ()),\n        FastMath.acos(v2.getX()),\n        FastMath.atan2(v2.getY(), v2.getZ())\n      };\n\n    } else if (order == RotationOrder.XZX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      //  cos (psi), cos (phi1) sin (psi), sin (phi1) sin (psi)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (psi), -sin (psi) cos (phi2), sin (psi) sin (phi2)\n      // and we can choose to have psi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getZ(), v1.getY()),\n        FastMath.acos(v2.getX()),\n        FastMath.atan2(v2.getZ(), -v2.getY())\n      };\n\n    } else if (order == RotationOrder.YXY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      //  sin (theta1) sin (phi), cos (phi), cos (theta1) sin (phi)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (phi) sin (theta2), cos (phi), -sin (phi) cos (theta2)\n      // and we can choose to have phi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getX(), v1.getZ()),\n        FastMath.acos(v2.getY()),\n        FastMath.atan2(v2.getX(), -v2.getZ())\n      };\n\n    } else if (order == RotationOrder.YZY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      //  -cos (theta1) sin (psi), cos (psi), sin (theta1) sin (psi)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (psi) cos (theta2), cos (psi), sin (psi) sin (theta2)\n      // and we can choose to have psi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getZ(), -v1.getX()),\n        FastMath.acos(v2.getY()),\n        FastMath.atan2(v2.getZ(), v2.getX())\n      };\n\n    } else if (order == RotationOrder.ZXZ) {\n\n      // r (Vector3D.plusK) coordinates are :\n      //  sin (psi1) sin (phi), -cos (psi1) sin (phi), cos (phi)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // sin (phi) sin (psi2), sin (phi) cos (psi2), cos (phi)\n      // and we can choose to have phi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getX(), -v1.getY()),\n        FastMath.acos(v2.getZ()),\n        FastMath.atan2(v2.getX(), v2.getY())\n      };\n\n    } else { // last possibility is ZYZ\n\n      // r (Vector3D.plusK) coordinates are :\n      //  cos (psi1) sin (theta), sin (psi1) sin (theta), cos (theta)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // -sin (theta) cos (psi2), sin (theta) sin (psi2), cos (theta)\n      // and we can choose to have theta in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getY(), v1.getX()),\n        FastMath.acos(v2.getZ()),\n        FastMath.atan2(v2.getY(), -v2.getX())\n      };\n\n    }\n\n  }",
          "56": "  public double[] getAngles(RotationOrder order)\n    throws CardanEulerSingularityException {\n\n    if (order == RotationOrder.XYZ) {\n\n      // r (Vector3D.plusK) coordinates are :\n      //  sin (theta), -cos (theta) sin (phi), cos (theta) cos (phi)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (psi) cos (theta), -sin (psi) cos (theta), sin (theta)\n      // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if  ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(-(v1.getY()), v1.getZ()),\n        FastMath.asin(v2.getZ()),\n        FastMath.atan2(-(v2.getY()), v2.getX())\n      };\n\n    } else if (order == RotationOrder.XZY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      // -sin (psi), cos (psi) cos (phi), cos (psi) sin (phi)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (theta) cos (psi), -sin (psi), sin (theta) cos (psi)\n      // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getZ(), v1.getY()),\n       -FastMath.asin(v2.getY()),\n        FastMath.atan2(v2.getZ(), v2.getX())\n      };\n\n    } else if (order == RotationOrder.YXZ) {\n\n      // r (Vector3D.plusK) coordinates are :\n      //  cos (phi) sin (theta), -sin (phi), cos (phi) cos (theta)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (psi) cos (phi), cos (psi) cos (phi), -sin (phi)\n      // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getX(), v1.getZ()),\n       -FastMath.asin(v2.getZ()),\n        FastMath.atan2(v2.getX(), v2.getY())\n      };\n\n    } else if (order == RotationOrder.YZX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      // cos (psi) cos (theta), sin (psi), -cos (psi) sin (theta)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (psi), cos (phi) cos (psi), -sin (phi) cos (psi)\n      // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(-(v1.getZ()), v1.getX()),\n        FastMath.asin(v2.getX()),\n        FastMath.atan2(-(v2.getZ()), v2.getY())\n      };\n\n    } else if (order == RotationOrder.ZXY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      // -cos (phi) sin (psi), cos (phi) cos (psi), sin (phi)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // -sin (theta) cos (phi), sin (phi), cos (theta) cos (phi)\n      // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(-(v1.getX()), v1.getY()),\n        FastMath.asin(v2.getY()),\n        FastMath.atan2(-(v2.getX()), v2.getZ())\n      };\n\n    } else if (order == RotationOrder.ZYX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      //  cos (theta) cos (psi), cos (theta) sin (psi), -sin (theta)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // -sin (theta), sin (phi) cos (theta), cos (phi) cos (theta)\n      // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\nreturn new Vector3D[[]]{FastMath.atan2(v2.getY(), v2.getZ()),FastMath.atan2(v2.getY(), v2.getZ()),FastMath.atan2(v2.getY(), v2.getZ()),FastMath.atan2(v2.getY(), v2.getZ()),FastMath.atan2(v2.getY(), v2.getZ()),+FastMath.asin(v2.getX())};      };\n\n    } else if (order == RotationOrder.XYX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      //  cos (theta), sin (phi1) sin (theta), -cos (phi1) sin (theta)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (theta), sin (theta) sin (phi2), sin (theta) cos (phi2)\n      // and we can choose to have theta in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getY(), -v1.getZ()),\n        FastMath.acos(v2.getX()),\n        FastMath.atan2(v2.getY(), v2.getZ())\n      };\n\n    } else if (order == RotationOrder.XZX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      //  cos (psi), cos (phi1) sin (psi), sin (phi1) sin (psi)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (psi), -sin (psi) cos (phi2), sin (psi) sin (phi2)\n      // and we can choose to have psi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getZ(), v1.getY()),\n        FastMath.acos(v2.getX()),\n        FastMath.atan2(v2.getZ(), -v2.getY())\n      };\n\n    } else if (order == RotationOrder.YXY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      //  sin (theta1) sin (phi), cos (phi), cos (theta1) sin (phi)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (phi) sin (theta2), cos (phi), -sin (phi) cos (theta2)\n      // and we can choose to have phi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getX(), v1.getZ()),\n        FastMath.acos(v2.getY()),\n        FastMath.atan2(v2.getX(), -v2.getZ())\n      };\n\n    } else if (order == RotationOrder.YZY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      //  -cos (theta1) sin (psi), cos (psi), sin (theta1) sin (psi)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (psi) cos (theta2), cos (psi), sin (psi) sin (theta2)\n      // and we can choose to have psi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getZ(), -v1.getX()),\n        FastMath.acos(v2.getY()),\n        FastMath.atan2(v2.getZ(), v2.getX())\n      };\n\n    } else if (order == RotationOrder.ZXZ) {\n\n      // r (Vector3D.plusK) coordinates are :\n      //  sin (psi1) sin (phi), -cos (psi1) sin (phi), cos (phi)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // sin (phi) sin (psi2), sin (phi) cos (psi2), cos (phi)\n      // and we can choose to have phi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getX(), -v1.getY()),\n        FastMath.acos(v2.getZ()),\n        FastMath.atan2(v2.getX(), v2.getY())\n      };\n\n    } else { // last possibility is ZYZ\n\n      // r (Vector3D.plusK) coordinates are :\n      //  cos (psi1) sin (theta), sin (psi1) sin (theta), cos (theta)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // -sin (theta) cos (psi2), sin (theta) sin (psi2), cos (theta)\n      // and we can choose to have theta in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getY(), v1.getX()),\n        FastMath.acos(v2.getZ()),\n        FastMath.atan2(v2.getY(), -v2.getX())\n      };\n\n    }\n\n  }",
          "57": "  public double[] getAngles(RotationOrder order)\n    throws CardanEulerSingularityException {\n\n    if (order == RotationOrder.XYZ) {\n\n      // r (Vector3D.plusK) coordinates are :\n      //  sin (theta), -cos (theta) sin (phi), cos (theta) cos (phi)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (psi) cos (theta), -sin (psi) cos (theta), sin (theta)\n      // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if  ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(-(v1.getY()), v1.getZ()),\n        FastMath.asin(v2.getZ()),\n        FastMath.atan2(-(v2.getY()), v2.getX())\n      };\n\n    } else if (order == RotationOrder.XZY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      // -sin (psi), cos (psi) cos (phi), cos (psi) sin (phi)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (theta) cos (psi), -sin (psi), sin (theta) cos (psi)\n      // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getZ(), v1.getY()),\n       -FastMath.asin(v2.getY()),\n        FastMath.atan2(v2.getZ(), v2.getX())\n      };\n\n    } else if (order == RotationOrder.YXZ) {\n\n      // r (Vector3D.plusK) coordinates are :\n      //  cos (phi) sin (theta), -sin (phi), cos (phi) cos (theta)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (psi) cos (phi), cos (psi) cos (phi), -sin (phi)\n      // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getX(), v1.getZ()),\n       -FastMath.asin(v2.getZ()),\n        FastMath.atan2(v2.getX(), v2.getY())\n      };\n\n    } else if (order == RotationOrder.YZX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      // cos (psi) cos (theta), sin (psi), -cos (psi) sin (theta)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (psi), cos (phi) cos (psi), -sin (phi) cos (psi)\n      // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(-(v1.getZ()), v1.getX()),\n        FastMath.asin(v2.getX()),\n        FastMath.atan2(-(v2.getZ()), v2.getY())\n      };\n\n    } else if (order == RotationOrder.ZXY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      // -cos (phi) sin (psi), cos (phi) cos (psi), sin (phi)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // -sin (theta) cos (phi), sin (phi), cos (theta) cos (phi)\n      // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(-(v1.getX()), v1.getY()),\n        FastMath.asin(v2.getY()),\n        FastMath.atan2(-(v2.getX()), v2.getZ())\n      };\n\n    } else if (order == RotationOrder.ZYX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      //  cos (theta) cos (psi), cos (theta) sin (psi), -sin (theta)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // -sin (theta), sin (phi) cos (theta), cos (phi) cos (theta)\n      // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\nreturn new Vector3D[[]]{FastMath.atan2(v2.getY(), v2.getZ()),FastMath.atan2(v2.getY(), v2.getZ()),FastMath.atan2(v2.getY(), v2.getZ()),FastMath.atan2(v2.getY(), v2.getZ()),FastMath.atan2(v2.getY(), v2.getZ()),v1};      };\n\n    } else if (order == RotationOrder.XYX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      //  cos (theta), sin (phi1) sin (theta), -cos (phi1) sin (theta)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (theta), sin (theta) sin (phi2), sin (theta) cos (phi2)\n      // and we can choose to have theta in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getY(), -v1.getZ()),\n        FastMath.acos(v2.getX()),\n        FastMath.atan2(v2.getY(), v2.getZ())\n      };\n\n    } else if (order == RotationOrder.XZX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      //  cos (psi), cos (phi1) sin (psi), sin (phi1) sin (psi)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (psi), -sin (psi) cos (phi2), sin (psi) sin (phi2)\n      // and we can choose to have psi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getZ(), v1.getY()),\n        FastMath.acos(v2.getX()),\n        FastMath.atan2(v2.getZ(), -v2.getY())\n      };\n\n    } else if (order == RotationOrder.YXY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      //  sin (theta1) sin (phi), cos (phi), cos (theta1) sin (phi)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (phi) sin (theta2), cos (phi), -sin (phi) cos (theta2)\n      // and we can choose to have phi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getX(), v1.getZ()),\n        FastMath.acos(v2.getY()),\n        FastMath.atan2(v2.getX(), -v2.getZ())\n      };\n\n    } else if (order == RotationOrder.YZY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      //  -cos (theta1) sin (psi), cos (psi), sin (theta1) sin (psi)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (psi) cos (theta2), cos (psi), sin (psi) sin (theta2)\n      // and we can choose to have psi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getZ(), -v1.getX()),\n        FastMath.acos(v2.getY()),\n        FastMath.atan2(v2.getZ(), v2.getX())\n      };\n\n    } else if (order == RotationOrder.ZXZ) {\n\n      // r (Vector3D.plusK) coordinates are :\n      //  sin (psi1) sin (phi), -cos (psi1) sin (phi), cos (phi)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // sin (phi) sin (psi2), sin (phi) cos (psi2), cos (phi)\n      // and we can choose to have phi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getX(), -v1.getY()),\n        FastMath.acos(v2.getZ()),\n        FastMath.atan2(v2.getX(), v2.getY())\n      };\n\n    } else { // last possibility is ZYZ\n\n      // r (Vector3D.plusK) coordinates are :\n      //  cos (psi1) sin (theta), sin (psi1) sin (theta), cos (theta)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // -sin (theta) cos (psi2), sin (theta) sin (psi2), cos (theta)\n      // and we can choose to have theta in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getY(), v1.getX()),\n        FastMath.acos(v2.getZ()),\n        FastMath.atan2(v2.getY(), -v2.getX())\n      };\n\n    }\n\n  }",
          "58": "  public double[] getAngles(RotationOrder order)\n    throws CardanEulerSingularityException {\n\n    if (order == RotationOrder.XYZ) {\n\n      // r (Vector3D.plusK) coordinates are :\n      //  sin (theta), -cos (theta) sin (phi), cos (theta) cos (phi)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (psi) cos (theta), -sin (psi) cos (theta), sin (theta)\n      // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if  ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(-(v1.getY()), v1.getZ()),\n        FastMath.asin(v2.getZ()),\n        FastMath.atan2(-(v2.getY()), v2.getX())\n      };\n\n    } else if (order == RotationOrder.XZY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      // -sin (psi), cos (psi) cos (phi), cos (psi) sin (phi)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (theta) cos (psi), -sin (psi), sin (theta) cos (psi)\n      // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getZ(), v1.getY()),\n       -FastMath.asin(v2.getY()),\n        FastMath.atan2(v2.getZ(), v2.getX())\n      };\n\n    } else if (order == RotationOrder.YXZ) {\n\n      // r (Vector3D.plusK) coordinates are :\n      //  cos (phi) sin (theta), -sin (phi), cos (phi) cos (theta)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (psi) cos (phi), cos (psi) cos (phi), -sin (phi)\n      // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getX(), v1.getZ()),\n       -FastMath.asin(v2.getZ()),\n        FastMath.atan2(v2.getX(), v2.getY())\n      };\n\n    } else if (order == RotationOrder.YZX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      // cos (psi) cos (theta), sin (psi), -cos (psi) sin (theta)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (psi), cos (phi) cos (psi), -sin (phi) cos (psi)\n      // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(-(v1.getZ()), v1.getX()),\n        FastMath.asin(v2.getX()),\n        FastMath.atan2(-(v2.getZ()), v2.getY())\n      };\n\n    } else if (order == RotationOrder.ZXY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      // -cos (phi) sin (psi), cos (phi) cos (psi), sin (phi)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // -sin (theta) cos (phi), sin (phi), cos (theta) cos (phi)\n      // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(-(v1.getX()), v1.getY()),\n        FastMath.asin(v2.getY()),\n        FastMath.atan2(-(v2.getX()), v2.getZ())\n      };\n\n    } else if (order == RotationOrder.ZYX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      //  cos (theta) cos (psi), cos (theta) sin (psi), -sin (theta)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // -sin (theta), sin (phi) cos (theta), cos (phi) cos (theta)\n      // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\nreturn new Vector3D[[]]{FastMath.asin(v2),FastMath.asin(v2)};      };\n\n    } else if (order == RotationOrder.XYX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      //  cos (theta), sin (phi1) sin (theta), -cos (phi1) sin (theta)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (theta), sin (theta) sin (phi2), sin (theta) cos (phi2)\n      // and we can choose to have theta in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getY(), -v1.getZ()),\n        FastMath.acos(v2.getX()),\n        FastMath.atan2(v2.getY(), v2.getZ())\n      };\n\n    } else if (order == RotationOrder.XZX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      //  cos (psi), cos (phi1) sin (psi), sin (phi1) sin (psi)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (psi), -sin (psi) cos (phi2), sin (psi) sin (phi2)\n      // and we can choose to have psi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getZ(), v1.getY()),\n        FastMath.acos(v2.getX()),\n        FastMath.atan2(v2.getZ(), -v2.getY())\n      };\n\n    } else if (order == RotationOrder.YXY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      //  sin (theta1) sin (phi), cos (phi), cos (theta1) sin (phi)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (phi) sin (theta2), cos (phi), -sin (phi) cos (theta2)\n      // and we can choose to have phi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getX(), v1.getZ()),\n        FastMath.acos(v2.getY()),\n        FastMath.atan2(v2.getX(), -v2.getZ())\n      };\n\n    } else if (order == RotationOrder.YZY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      //  -cos (theta1) sin (psi), cos (psi), sin (theta1) sin (psi)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (psi) cos (theta2), cos (psi), sin (psi) sin (theta2)\n      // and we can choose to have psi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getZ(), -v1.getX()),\n        FastMath.acos(v2.getY()),\n        FastMath.atan2(v2.getZ(), v2.getX())\n      };\n\n    } else if (order == RotationOrder.ZXZ) {\n\n      // r (Vector3D.plusK) coordinates are :\n      //  sin (psi1) sin (phi), -cos (psi1) sin (phi), cos (phi)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // sin (phi) sin (psi2), sin (phi) cos (psi2), cos (phi)\n      // and we can choose to have phi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getX(), -v1.getY()),\n        FastMath.acos(v2.getZ()),\n        FastMath.atan2(v2.getX(), v2.getY())\n      };\n\n    } else { // last possibility is ZYZ\n\n      // r (Vector3D.plusK) coordinates are :\n      //  cos (psi1) sin (theta), sin (psi1) sin (theta), cos (theta)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // -sin (theta) cos (psi2), sin (theta) sin (psi2), cos (theta)\n      // and we can choose to have theta in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getY(), v1.getX()),\n        FastMath.acos(v2.getZ()),\n        FastMath.atan2(v2.getY(), -v2.getX())\n      };\n\n    }\n\n  }"
}