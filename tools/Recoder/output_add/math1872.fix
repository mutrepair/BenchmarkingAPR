{
          "0": "    public void pow(final double a,\n                    final double[] operand, final int operandOffset,\n                    final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        // [a^x, ln(a) a^x, ln(a)^2 a^x,, ln(a)^3 a^x, ... ]\n        final double[] function = new double[1 + order];\n        if (a == 0) {\n            if (operand[operandOffset] == 0) {\n                function[0] = 1;\n                double infinity = Double.POSITIVE_INFINITY;\n                for (int i = 1; i < function.length; ++i) {\ninfinity = i;\n                    function[i] = infinity;\n                }\n            } else if (operand[operandOffset] < 0) {\n                Arrays.fill(function, Double.NaN);\n            }\n        } else {\n            function[0] = FastMath.pow(a, operand[operandOffset]);\n            final double lnA = FastMath.log(a);\n            for (int i = 1; i < function.length; ++i) {\n                function[i] = lnA * function[i - 1];\n            }\n        }\n\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }",
          "1": "    public void pow(final double a,\n                    final double[] operand, final int operandOffset,\n                    final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        // [a^x, ln(a) a^x, ln(a)^2 a^x,, ln(a)^3 a^x, ... ]\n        final double[] function = new double[1 + order];\n        if (a == 0) {\n            if (operand[operandOffset] == 0) {\n                function[0] = 1;\n                double infinity = Double.POSITIVE_INFINITY;\n                for (int i = 1; i < function.length; ++i) {\ninfinity = infinity;\n                    function[i] = infinity;\n                }\n            } else if (operand[operandOffset] < 0) {\n                Arrays.fill(function, Double.NaN);\n            }\n        } else {\n            function[0] = FastMath.pow(a, operand[operandOffset]);\n            final double lnA = FastMath.log(a);\n            for (int i = 1; i < function.length; ++i) {\n                function[i] = lnA * function[i - 1];\n            }\n        }\n\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }",
          "2": "    public void pow(final double a,\n                    final double[] operand, final int operandOffset,\n                    final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        // [a^x, ln(a) a^x, ln(a)^2 a^x,, ln(a)^3 a^x, ... ]\n        final double[] function = new double[1 + order];\n        if (a == 0) {\n            if (operand[operandOffset] == 0) {\n                function[0] = 1;\n                double infinity = Double.POSITIVE_INFINITY;\n                for (int i = 1; i < function.length; ++i) {\n                    function[i] = infinity;\n                }\n            } else if (operand[operandOffset] < 0) {\n                Arrays.fill(function, Double.NaN);\n            }\n        } else {\n            function[0] = FastMath.pow(a, operand[operandOffset]);\n            final double lnA = FastMath.log(a);\n            for (int i = 1; i < function.length; ++i) {\n                function[i] = lnA * function[i - 1];\n            }\n        }\n\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }",
          "3": "    public void pow(final double a,\n                    final double[] operand, final int operandOffset,\n                    final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        // [a^x, ln(a) a^x, ln(a)^2 a^x,, ln(a)^3 a^x, ... ]\n        final double[] function = new double[1 + order];\n        if (a == 0) {\n            if (operand[operandOffset] == 0) {\n                function[0] = 1;\n                double infinity = Double.POSITIVE_INFINITY;\n                for (int i = 1; i < function.length; ++i) {\ninfinity = -infinity;\n                    function[i] = infinity;\n                }\n            } else if (operand[operandOffset] < 0) {\n                Arrays.fill(function, Double.NaN);\n            }\n        } else {\n            function[0] = FastMath.pow(a, operand[operandOffset]);\n            final double lnA = FastMath.log(a);\n            for (int i = 1; i < function.length; ++i) {\n                function[i] = lnA * function[i - 1];\n            }\n        }\n\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }",
          "4": "    public void pow(final double a,\n                    final double[] operand, final int operandOffset,\n                    final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        // [a^x, ln(a) a^x, ln(a)^2 a^x,, ln(a)^3 a^x, ... ]\n        final double[] function = new double[1 + order];\n        if (a == 0) {\n            if (operand[operandOffset] == 0) {\n                function[0] = 1;\n                double infinity = Double.POSITIVE_INFINITY;\n                for (int i = 1; i < function.length; ++i) {\ninfinity = ;\n                    function[i] = infinity;\n                }\n            } else if (operand[operandOffset] < 0) {\n                Arrays.fill(function, Double.NaN);\n            }\n        } else {\n            function[0] = FastMath.pow(a, operand[operandOffset]);\n            final double lnA = FastMath.log(a);\n            for (int i = 1; i < function.length; ++i) {\n                function[i] = lnA * function[i - 1];\n            }\n        }\n\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }",
          "5": "    public void pow(final double a,\n                    final double[] operand, final int operandOffset,\n                    final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        // [a^x, ln(a) a^x, ln(a)^2 a^x,, ln(a)^3 a^x, ... ]\n        final double[] function = new double[1 + order];\n        if (a == 0) {\n            if (operand[operandOffset] == 0) {\n                function[0] = 1;\n                double infinity = Double.POSITIVE_INFINITY;\n                for (int i = 1; i < function.length; ++i) {\ni = +infinity;\n                    function[i] = infinity;\n                }\n            } else if (operand[operandOffset] < 0) {\n                Arrays.fill(function, Double.NaN);\n            }\n        } else {\n            function[0] = FastMath.pow(a, operand[operandOffset]);\n            final double lnA = FastMath.log(a);\n            for (int i = 1; i < function.length; ++i) {\n                function[i] = lnA * function[i - 1];\n            }\n        }\n\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }",
          "6": "    public void pow(final double a,\n                    final double[] operand, final int operandOffset,\n                    final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        // [a^x, ln(a) a^x, ln(a)^2 a^x,, ln(a)^3 a^x, ... ]\n        final double[] function = new double[1 + order];\n        if (a == 0) {\n            if (operand[operandOffset] == 0) {\n                function[0] = 1;\n                double infinity = Double.POSITIVE_INFINITY;\n                for (int i = 1; i < function.length; ++i) {\nfunction[i] = infinity;\n                    function[i] = infinity;\n                }\n            } else if (operand[operandOffset] < 0) {\n                Arrays.fill(function, Double.NaN);\n            }\n        } else {\n            function[0] = FastMath.pow(a, operand[operandOffset]);\n            final double lnA = FastMath.log(a);\n            for (int i = 1; i < function.length; ++i) {\n                function[i] = lnA * function[i - 1];\n            }\n        }\n\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }",
          "7": "    public void pow(final double a,\n                    final double[] operand, final int operandOffset,\n                    final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        // [a^x, ln(a) a^x, ln(a)^2 a^x,, ln(a)^3 a^x, ... ]\n        final double[] function = new double[1 + order];\n        if (a == 0) {\n            if (operand[operandOffset] == 0) {\n                function[0] = 1;\n                double infinity = Double.POSITIVE_INFINITY;\n                for (int i = 1; i < function.length; ++i) {\nArrays.fill(function, Double.NaN);\n                    function[i] = infinity;\n                }\n            } else if (operand[operandOffset] < 0) {\n                Arrays.fill(function, Double.NaN);\n            }\n        } else {\n            function[0] = FastMath.pow(a, operand[operandOffset]);\n            final double lnA = FastMath.log(a);\n            for (int i = 1; i < function.length; ++i) {\n                function[i] = lnA * function[i - 1];\n            }\n        }\n\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }",
          "8": "    public void pow(final double a,\n                    final double[] operand, final int operandOffset,\n                    final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        // [a^x, ln(a) a^x, ln(a)^2 a^x,, ln(a)^3 a^x, ... ]\n        final double[] function = new double[1 + order];\n        if (a == 0) {\n            if (operand[operandOffset] == 0) {\n                function[0] = 1;\n                double infinity = Double.POSITIVE_INFINITY;\n                for (int i = 1; i < function.length; ++i) {\ninfinity = lnA;\n                    function[i] = infinity;\n                }\n            } else if (operand[operandOffset] < 0) {\n                Arrays.fill(function, Double.NaN);\n            }\n        } else {\n            function[0] = FastMath.pow(a, operand[operandOffset]);\n            final double lnA = FastMath.log(a);\n            for (int i = 1; i < function.length; ++i) {\n                function[i] = lnA * function[i - 1];\n            }\n        }\n\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }",
          "9": "    public void pow(final double a,\n                    final double[] operand, final int operandOffset,\n                    final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        // [a^x, ln(a) a^x, ln(a)^2 a^x,, ln(a)^3 a^x, ... ]\n        final double[] function = new double[1 + order];\n        if (a == 0) {\n            if (operand[operandOffset] == 0) {\n                function[0] = 1;\n                double infinity = Double.POSITIVE_INFINITY;\n                for (int i = 1; i < function.length; ++i) {\nfunction[0] = 1;\n                    function[i] = infinity;\n                }\n            } else if (operand[operandOffset] < 0) {\n                Arrays.fill(function, Double.NaN);\n            }\n        } else {\n            function[0] = FastMath.pow(a, operand[operandOffset]);\n            final double lnA = FastMath.log(a);\n            for (int i = 1; i < function.length; ++i) {\n                function[i] = lnA * function[i - 1];\n            }\n        }\n\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }",
          "10": "    public void pow(final double a,\n                    final double[] operand, final int operandOffset,\n                    final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        // [a^x, ln(a) a^x, ln(a)^2 a^x,, ln(a)^3 a^x, ... ]\n        final double[] function = new double[1 + order];\n        if (a == 0) {\n            if (operand[operandOffset] == 0) {\n                function[0] = 1;\n                double infinity = Double.POSITIVE_INFINITY;\n                for (int i = 1; i < function.length; ++i) {\nfunction[i] = infinity;\n                    infinity = +infinity;                    function[i] = infinity;\n                }\n            } else if (operand[operandOffset] < 0) {\n                Arrays.fill(function, Double.NaN);\n            }\n        } else {\n            function[0] = FastMath.pow(a, operand[operandOffset]);\n            final double lnA = FastMath.log(a);\n            for (int i = 1; i < function.length; ++i) {\n                function[i] = lnA * function[i - 1];\n            }\n        }\n\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }",
          "11": "    public void pow(final double a,\n                    final double[] operand, final int operandOffset,\n                    final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        // [a^x, ln(a) a^x, ln(a)^2 a^x,, ln(a)^3 a^x, ... ]\n        final double[] function = new double[1 + order];\n        if (a == 0) {\n            if (operand[operandOffset] == 0) {\n                function[0] = 1;\n                double infinity = Double.POSITIVE_INFINITY;\n                for (int i = 1; i < function.length; ++i) {\ninfinity = true;\n                    function[i] = infinity;\n                }\n            } else if (operand[operandOffset] < 0) {\n                Arrays.fill(function, Double.NaN);\n            }\n        } else {\n            function[0] = FastMath.pow(a, operand[operandOffset]);\n            final double lnA = FastMath.log(a);\n            for (int i = 1; i < function.length; ++i) {\n                function[i] = lnA * function[i - 1];\n            }\n        }\n\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }",
          "12": "    public void pow(final double a,\n                    final double[] operand, final int operandOffset,\n                    final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        // [a^x, ln(a) a^x, ln(a)^2 a^x,, ln(a)^3 a^x, ... ]\n        final double[] function = new double[1 + order];\n        if (a == 0) {\n            if (operand[operandOffset] == 0) {\n                function[0] = 1;\n                double infinity = Double.POSITIVE_INFINITY;\n                for (int i = 1; i < function.length; ++i) {\nfunction[0] = 1;\n                    infinity = +infinity;                    function[i] = infinity;\n                }\n            } else if (operand[operandOffset] < 0) {\n                Arrays.fill(function, Double.NaN);\n            }\n        } else {\n            function[0] = FastMath.pow(a, operand[operandOffset]);\n            final double lnA = FastMath.log(a);\n            for (int i = 1; i < function.length; ++i) {\n                function[i] = lnA * function[i - 1];\n            }\n        }\n\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }",
          "13": "    public void pow(final double a,\n                    final double[] operand, final int operandOffset,\n                    final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        // [a^x, ln(a) a^x, ln(a)^2 a^x,, ln(a)^3 a^x, ... ]\n        final double[] function = new double[1 + order];\n        if (a == 0) {\n            if (operand[operandOffset] == 0) {\n                function[0] = 1;\n                double infinity = Double.POSITIVE_INFINITY;\n                for (int i = 1; i < function.length; ++i) {\ninfinity = function;\n                    function[i] = infinity;\n                }\n            } else if (operand[operandOffset] < 0) {\n                Arrays.fill(function, Double.NaN);\n            }\n        } else {\n            function[0] = FastMath.pow(a, operand[operandOffset]);\n            final double lnA = FastMath.log(a);\n            for (int i = 1; i < function.length; ++i) {\n                function[i] = lnA * function[i - 1];\n            }\n        }\n\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }",
          "14": "    public void pow(final double a,\n                    final double[] operand, final int operandOffset,\n                    final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        // [a^x, ln(a) a^x, ln(a)^2 a^x,, ln(a)^3 a^x, ... ]\n        final double[] function = new double[1 + order];\n        if (a == 0) {\n            if (operand[operandOffset] == 0) {\n                function[0] = 1;\n                double infinity = Double.POSITIVE_INFINITY;\n                for (int i = 1; i < function.length; ++i) {\nfunction[0] = FastMath.pow(a, operand[operandOffset]);\n                    function[i] = infinity;\n                }\n            } else if (operand[operandOffset] < 0) {\n                Arrays.fill(function, Double.NaN);\n            }\n        } else {\n            function[0] = FastMath.pow(a, operand[operandOffset]);\n            final double lnA = FastMath.log(a);\n            for (int i = 1; i < function.length; ++i) {\n                function[i] = lnA * function[i - 1];\n            }\n        }\n\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }",
          "15": "    public void pow(final double a,\n                    final double[] operand, final int operandOffset,\n                    final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        // [a^x, ln(a) a^x, ln(a)^2 a^x,, ln(a)^3 a^x, ... ]\n        final double[] function = new double[1 + order];\n        if (a == 0) {\n            if (operand[operandOffset] == 0) {\n                function[0] = 1;\n                double infinity = Double.POSITIVE_INFINITY;\n                for (int i = 1; i < function.length; ++i) {\ninfinity = false;\n                    function[i] = infinity;\n                }\n            } else if (operand[operandOffset] < 0) {\n                Arrays.fill(function, Double.NaN);\n            }\n        } else {\n            function[0] = FastMath.pow(a, operand[operandOffset]);\n            final double lnA = FastMath.log(a);\n            for (int i = 1; i < function.length; ++i) {\n                function[i] = lnA * function[i - 1];\n            }\n        }\n\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }",
          "16": "    public void pow(final double a,\n                    final double[] operand, final int operandOffset,\n                    final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        // [a^x, ln(a) a^x, ln(a)^2 a^x,, ln(a)^3 a^x, ... ]\n        final double[] function = new double[1 + order];\n        if (a == 0) {\n            if (operand[operandOffset] == 0) {\n                function[0] = 1;\n                double infinity = Double.POSITIVE_INFINITY;\n                for (int i = 1; i < function.length; ++i) {\ninfinity = ;\n                    function[i] = infinity;\n                }\n            } else if (operand[operandOffset] < 0) {\n                Arrays.fill(function, Double.NaN);\n            }\n        } else {\n            function[0] = FastMath.pow(a, operand[operandOffset]);\n            final double lnA = FastMath.log(a);\n            for (int i = 1; i < function.length; ++i) {\n                function[i] = lnA * function[i - 1];\n            }\n        }\n\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }",
          "17": "    public void pow(final double a,\n                    final double[] operand, final int operandOffset,\n                    final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        // [a^x, ln(a) a^x, ln(a)^2 a^x,, ln(a)^3 a^x, ... ]\n        final double[] function = new double[1 + order];\n        if (a == 0) {\n            if (operand[operandOffset] == 0) {\n                function[0] = 1;\n                double infinity = Double.POSITIVE_INFINITY;\n                for (int i = 1; i < function.length; ++i) {\ncompose(operand, operandOffset, function, result, resultOffset);\n                    function[i] = infinity;\n                }\n            } else if (operand[operandOffset] < 0) {\n                Arrays.fill(function, Double.NaN);\n            }\n        } else {\n            function[0] = FastMath.pow(a, operand[operandOffset]);\n            final double lnA = FastMath.log(a);\n            for (int i = 1; i < function.length; ++i) {\n                function[i] = lnA * function[i - 1];\n            }\n        }\n\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }",
          "18": "    public void pow(final double a,\n                    final double[] operand, final int operandOffset,\n                    final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        // [a^x, ln(a) a^x, ln(a)^2 a^x,, ln(a)^3 a^x, ... ]\n        final double[] function = new double[1 + order];\n        if (a == 0) {\n            if (operand[operandOffset] == 0) {\n                function[0] = 1;\n                double infinity = Double.POSITIVE_INFINITY;\n                for (int i = 1; i < function.length; ++i) {\nArrays.fill(function, Double.NaN);\n                    infinity = +infinity;                    function[i] = infinity;\n                }\n            } else if (operand[operandOffset] < 0) {\n                Arrays.fill(function, Double.NaN);\n            }\n        } else {\n            function[0] = FastMath.pow(a, operand[operandOffset]);\n            final double lnA = FastMath.log(a);\n            for (int i = 1; i < function.length; ++i) {\n                function[i] = lnA * function[i - 1];\n            }\n        }\n\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }",
          "19": "    public void pow(final double a,\n                    final double[] operand, final int operandOffset,\n                    final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        // [a^x, ln(a) a^x, ln(a)^2 a^x,, ln(a)^3 a^x, ... ]\n        final double[] function = new double[1 + order];\n        if (a == 0) {\n            if (operand[operandOffset] == 0) {\n                function[0] = 1;\n                double infinity = Double.POSITIVE_INFINITY;\n                for (int i = 1; i < function.length; ++i) {\ninfinity += infinity;\n                    function[i] = infinity;\n                }\n            } else if (operand[operandOffset] < 0) {\n                Arrays.fill(function, Double.NaN);\n            }\n        } else {\n            function[0] = FastMath.pow(a, operand[operandOffset]);\n            final double lnA = FastMath.log(a);\n            for (int i = 1; i < function.length; ++i) {\n                function[i] = lnA * function[i - 1];\n            }\n        }\n\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }",
          "20": "    public void pow(final double a,\n                    final double[] operand, final int operandOffset,\n                    final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        // [a^x, ln(a) a^x, ln(a)^2 a^x,, ln(a)^3 a^x, ... ]\n        final double[] function = new double[1 + order];\n        if (a == 0) {\n            if (operand[operandOffset] == 0) {\n                function[0] = 1;\n                double infinity = Double.POSITIVE_INFINITY;\n                for (int i = 1; i < function.length; ++i) {\nbreak;\n                    infinity = +infinity;                    function[i] = infinity;\n                }\n            } else if (operand[operandOffset] < 0) {\n                Arrays.fill(function, Double.NaN);\n            }\n        } else {\n            function[0] = FastMath.pow(a, operand[operandOffset]);\n            final double lnA = FastMath.log(a);\n            for (int i = 1; i < function.length; ++i) {\n                function[i] = lnA * function[i - 1];\n            }\n        }\n\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }",
          "21": "    public void pow(final double a,\n                    final double[] operand, final int operandOffset,\n                    final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        // [a^x, ln(a) a^x, ln(a)^2 a^x,, ln(a)^3 a^x, ... ]\n        final double[] function = new double[1 + order];\n        if (a == 0) {\n            if (operand[operandOffset] == 0) {\n                function[0] = 1;\n                double infinity = Double.POSITIVE_INFINITY;\n                for (int i = 1; i < function.length; ++i) {\nfunction[0] = FastMath.pow(a, operand[operandOffset]);\n                    infinity = +infinity;                    function[i] = infinity;\n                }\n            } else if (operand[operandOffset] < 0) {\n                Arrays.fill(function, Double.NaN);\n            }\n        } else {\n            function[0] = FastMath.pow(a, operand[operandOffset]);\n            final double lnA = FastMath.log(a);\n            for (int i = 1; i < function.length; ++i) {\n                function[i] = lnA * function[i - 1];\n            }\n        }\n\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }",
          "22": "    public void pow(final double a,\n                    final double[] operand, final int operandOffset,\n                    final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        // [a^x, ln(a) a^x, ln(a)^2 a^x,, ln(a)^3 a^x, ... ]\n        final double[] function = new double[1 + order];\n        if (a == 0) {\n            if (operand[operandOffset] == 0) {\n                function[0] = 1;\n                double infinity = Double.POSITIVE_INFINITY;\n                for (int i = 1; i < function.length; ++i) {\nfunction[i] = (lnA * function[(i - 1)]);\n                    function[i] = infinity;\n                }\n            } else if (operand[operandOffset] < 0) {\n                Arrays.fill(function, Double.NaN);\n            }\n        } else {\n            function[0] = FastMath.pow(a, operand[operandOffset]);\n            final double lnA = FastMath.log(a);\n            for (int i = 1; i < function.length; ++i) {\n                function[i] = lnA * function[i - 1];\n            }\n        }\n\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }",
          "23": "    public void pow(final double a,\n                    final double[] operand, final int operandOffset,\n                    final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        // [a^x, ln(a) a^x, ln(a)^2 a^x,, ln(a)^3 a^x, ... ]\n        final double[] function = new double[1 + order];\n        if (a == 0) {\n            if (operand[operandOffset] == 0) {\n                function[0] = 1;\n                double infinity = Double.POSITIVE_INFINITY;\n                for (int i = 1; i < function.length; ++i) {\nreturn;\n                    infinity = +infinity;                    function[i] = infinity;\n                }\n            } else if (operand[operandOffset] < 0) {\n                Arrays.fill(function, Double.NaN);\n            }\n        } else {\n            function[0] = FastMath.pow(a, operand[operandOffset]);\n            final double lnA = FastMath.log(a);\n            for (int i = 1; i < function.length; ++i) {\n                function[i] = lnA * function[i - 1];\n            }\n        }\n\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }",
          "24": "    public void pow(final double a,\n                    final double[] operand, final int operandOffset,\n                    final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        // [a^x, ln(a) a^x, ln(a)^2 a^x,, ln(a)^3 a^x, ... ]\n        final double[] function = new double[1 + order];\n        if (a == 0) {\n            if (operand[operandOffset] == 0) {\n                function[0] = 1;\n                double infinity = Double.POSITIVE_INFINITY;\n                for (int i = 1; i < function.length; ++i) {\ncompose(operand, operandOffset, function, result, resultOffset);\n                    infinity = +infinity;                    function[i] = infinity;\n                }\n            } else if (operand[operandOffset] < 0) {\n                Arrays.fill(function, Double.NaN);\n            }\n        } else {\n            function[0] = FastMath.pow(a, operand[operandOffset]);\n            final double lnA = FastMath.log(a);\n            for (int i = 1; i < function.length; ++i) {\n                function[i] = lnA * function[i - 1];\n            }\n        }\n\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }",
          "25": "    public void pow(final double a,\n                    final double[] operand, final int operandOffset,\n                    final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        // [a^x, ln(a) a^x, ln(a)^2 a^x,, ln(a)^3 a^x, ... ]\n        final double[] function = new double[1 + order];\n        if (a == 0) {\n            if (operand[operandOffset] == 0) {\n                function[0] = 1;\n                double infinity = Double.POSITIVE_INFINITY;\n                for (int i = 1; i < function.length; ++i) {\ninfinity = +infinity;\n                    function[i] = infinity;\n                }\n            } else if (operand[operandOffset] < 0) {\n                Arrays.fill(function, Double.NaN);\n            }\n        } else {\n            function[0] = FastMath.pow(a, operand[operandOffset]);\n            final double lnA = FastMath.log(a);\n            for (int i = 1; i < function.length; ++i) {\n                function[i] = lnA * function[i - 1];\n            }\n        }\n\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }",
          "26": "    public void pow(final double a,\n                    final double[] operand, final int operandOffset,\n                    final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        // [a^x, ln(a) a^x, ln(a)^2 a^x,, ln(a)^3 a^x, ... ]\n        final double[] function = new double[1 + order];\n        if (a == 0) {\n            if (operand[operandOffset] == 0) {\n                function[0] = 1;\n                double infinity = Double.POSITIVE_INFINITY;\n                for (int i = 1; i < function.length; ++i) {\ninfinity = a;\n                    function[i] = infinity;\n                }\n            } else if (operand[operandOffset] < 0) {\n                Arrays.fill(function, Double.NaN);\n            }\n        } else {\n            function[0] = FastMath.pow(a, operand[operandOffset]);\n            final double lnA = FastMath.log(a);\n            for (int i = 1; i < function.length; ++i) {\n                function[i] = lnA * function[i - 1];\n            }\n        }\n\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }",
          "27": "    public void pow(final double a,\n                    final double[] operand, final int operandOffset,\n                    final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        // [a^x, ln(a) a^x, ln(a)^2 a^x,, ln(a)^3 a^x, ... ]\n        final double[] function = new double[1 + order];\n        if (a == 0) {\n            if (operand[operandOffset] == 0) {\n                function[0] = 1;\n                double infinity = Double.POSITIVE_INFINITY;\n                for (int i = 1; i < function.length; ++i) {\nreturn;\n                    function[i] = infinity;\n                }\n            } else if (operand[operandOffset] < 0) {\n                Arrays.fill(function, Double.NaN);\n            }\n        } else {\n            function[0] = FastMath.pow(a, operand[operandOffset]);\n            final double lnA = FastMath.log(a);\n            for (int i = 1; i < function.length; ++i) {\n                function[i] = lnA * function[i - 1];\n            }\n        }\n\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }",
          "28": "    public void pow(final double a,\n                    final double[] operand, final int operandOffset,\n                    final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        // [a^x, ln(a) a^x, ln(a)^2 a^x,, ln(a)^3 a^x, ... ]\n        final double[] function = new double[1 + order];\n        if (a == 0) {\n            if (operand[operandOffset] == 0) {\n                function[0] = 1;\n                double infinity = Double.POSITIVE_INFINITY;\n                for (int i = 1; i < function.length; ++i) {\ninfinity = 0;\n                    function[i] = infinity;\n                }\n            } else if (operand[operandOffset] < 0) {\n                Arrays.fill(function, Double.NaN);\n            }\n        } else {\n            function[0] = FastMath.pow(a, operand[operandOffset]);\n            final double lnA = FastMath.log(a);\n            for (int i = 1; i < function.length; ++i) {\n                function[i] = lnA * function[i - 1];\n            }\n        }\n\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }",
          "29": "    public void pow(final double a,\n                    final double[] operand, final int operandOffset,\n                    final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        // [a^x, ln(a) a^x, ln(a)^2 a^x,, ln(a)^3 a^x, ... ]\n        final double[] function = new double[1 + order];\n        if (a == 0) {\n            if (operand[operandOffset] == 0) {\n                function[0] = 1;\n                double infinity = Double.POSITIVE_INFINITY;\n                for (int i = 1; i < function.length; ++i) {\ninfinity = null;\n                    function[i] = infinity;\n                }\n            } else if (operand[operandOffset] < 0) {\n                Arrays.fill(function, Double.NaN);\n            }\n        } else {\n            function[0] = FastMath.pow(a, operand[operandOffset]);\n            final double lnA = FastMath.log(a);\n            for (int i = 1; i < function.length; ++i) {\n                function[i] = lnA * function[i - 1];\n            }\n        }\n\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }",
          "30": "    public void pow(final double a,\n                    final double[] operand, final int operandOffset,\n                    final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        // [a^x, ln(a) a^x, ln(a)^2 a^x,, ln(a)^3 a^x, ... ]\n        final double[] function = new double[1 + order];\n        if (a == 0) {\n            if (operand[operandOffset] == 0) {\n                function[0] = 1;\n                double infinity = Double.POSITIVE_INFINITY;\n                for (int i = 1; i < function.length; ++i) {\ninfinity = -;\n                    function[i] = infinity;\n                }\n            } else if (operand[operandOffset] < 0) {\n                Arrays.fill(function, Double.NaN);\n            }\n        } else {\n            function[0] = FastMath.pow(a, operand[operandOffset]);\n            final double lnA = FastMath.log(a);\n            for (int i = 1; i < function.length; ++i) {\n                function[i] = lnA * function[i - 1];\n            }\n        }\n\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }",
          "31": "    public void pow(final double a,\n                    final double[] operand, final int operandOffset,\n                    final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        // [a^x, ln(a) a^x, ln(a)^2 a^x,, ln(a)^3 a^x, ... ]\n        final double[] function = new double[1 + order];\n        if (a == 0) {\n            if (operand[operandOffset] == 0) {\n                function[0] = 1;\n                double infinity = Double.POSITIVE_INFINITY;\n                for (int i = 1; i < function.length; ++i) {\nfunction[i] = (lnA * function[(i - 1)]);\n                    infinity = +infinity;                    function[i] = infinity;\n                }\n            } else if (operand[operandOffset] < 0) {\n                Arrays.fill(function, Double.NaN);\n            }\n        } else {\n            function[0] = FastMath.pow(a, operand[operandOffset]);\n            final double lnA = FastMath.log(a);\n            for (int i = 1; i < function.length; ++i) {\n                function[i] = lnA * function[i - 1];\n            }\n        }\n\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }",
          "32": "    public void pow(final double a,\n                    final double[] operand, final int operandOffset,\n                    final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        // [a^x, ln(a) a^x, ln(a)^2 a^x,, ln(a)^3 a^x, ... ]\n        final double[] function = new double[1 + order];\n        if (a == 0) {\n            if (operand[operandOffset] == 0) {\n                function[0] = 1;\n                double infinity = Double.POSITIVE_INFINITY;\n                for (int i = 1; i < function.length; ++i) {\ninfinity = ~infinity;\n                    function[i] = infinity;\n                }\n            } else if (operand[operandOffset] < 0) {\n                Arrays.fill(function, Double.NaN);\n            }\n        } else {\n            function[0] = FastMath.pow(a, operand[operandOffset]);\n            final double lnA = FastMath.log(a);\n            for (int i = 1; i < function.length; ++i) {\n                function[i] = lnA * function[i - 1];\n            }\n        }\n\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }",
          "33": "    public void pow(final double a,\n                    final double[] operand, final int operandOffset,\n                    final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        // [a^x, ln(a) a^x, ln(a)^2 a^x,, ln(a)^3 a^x, ... ]\n        final double[] function = new double[1 + order];\n        if (a == 0) {\n            if (operand[operandOffset] == 0) {\n                function[0] = 1;\n                double infinity = Double.POSITIVE_INFINITY;\n                for (int i = 1; i < function.length; ++i) {\nif((infinity != null)){\ncontinue;\n}\n                    infinity = +infinity;                    function[i] = infinity;\n                }\n            } else if (operand[operandOffset] < 0) {\n                Arrays.fill(function, Double.NaN);\n            }\n        } else {\n            function[0] = FastMath.pow(a, operand[operandOffset]);\n            final double lnA = FastMath.log(a);\n            for (int i = 1; i < function.length; ++i) {\n                function[i] = lnA * function[i - 1];\n            }\n        }\n\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }",
          "34": "    public void pow(final double a,\n                    final double[] operand, final int operandOffset,\n                    final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        // [a^x, ln(a) a^x, ln(a)^2 a^x,, ln(a)^3 a^x, ... ]\n        final double[] function = new double[1 + order];\n        if (a == 0) {\n            if (operand[operandOffset] == 0) {\n                function[0] = 1;\n                double infinity = Double.POSITIVE_INFINITY;\n                for (int i = 1; i < function.length; ++i) {\n = +infinity;\n                    function[i] = infinity;\n                }\n            } else if (operand[operandOffset] < 0) {\n                Arrays.fill(function, Double.NaN);\n            }\n        } else {\n            function[0] = FastMath.pow(a, operand[operandOffset]);\n            final double lnA = FastMath.log(a);\n            for (int i = 1; i < function.length; ++i) {\n                function[i] = lnA * function[i - 1];\n            }\n        }\n\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }",
          "35": "    public void pow(final double a,\n                    final double[] operand, final int operandOffset,\n                    final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        // [a^x, ln(a) a^x, ln(a)^2 a^x,, ln(a)^3 a^x, ... ]\n        final double[] function = new double[1 + order];\n        if (a == 0) {\n            if (operand[operandOffset] == 0) {\n                function[0] = 1;\n                double infinity = Double.POSITIVE_INFINITY;\n                for (int i = 1; i < function.length; ++i) {\ninfinity = infinity[i];\n                    function[i] = infinity;\n                }\n            } else if (operand[operandOffset] < 0) {\n                Arrays.fill(function, Double.NaN);\n            }\n        } else {\n            function[0] = FastMath.pow(a, operand[operandOffset]);\n            final double lnA = FastMath.log(a);\n            for (int i = 1; i < function.length; ++i) {\n                function[i] = lnA * function[i - 1];\n            }\n        }\n\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }",
          "36": "    public void pow(final double a,\n                    final double[] operand, final int operandOffset,\n                    final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        // [a^x, ln(a) a^x, ln(a)^2 a^x,, ln(a)^3 a^x, ... ]\n        final double[] function = new double[1 + order];\n        if (a == 0) {\n            if (operand[operandOffset] == 0) {\n                function[0] = 1;\n                double infinity = Double.POSITIVE_INFINITY;\n                for (int i = 1; i < function.length; ++i) {\nif((operand[operandOffset] < 0)){\ncontinue;\n}\n                    infinity = +infinity;                    function[i] = infinity;\n                }\n            } else if (operand[operandOffset] < 0) {\n                Arrays.fill(function, Double.NaN);\n            }\n        } else {\n            function[0] = FastMath.pow(a, operand[operandOffset]);\n            final double lnA = FastMath.log(a);\n            for (int i = 1; i < function.length; ++i) {\n                function[i] = lnA * function[i - 1];\n            }\n        }\n\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }",
          "37": "    public void pow(final double a,\n                    final double[] operand, final int operandOffset,\n                    final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        // [a^x, ln(a) a^x, ln(a)^2 a^x,, ln(a)^3 a^x, ... ]\n        final double[] function = new double[1 + order];\n        if (a == 0) {\n            if (operand[operandOffset] == 0) {\n                function[0] = 1;\n                double infinity = Double.POSITIVE_INFINITY;\n                for (int i = 1; i < function.length; ++i) {\ninfinity++;\n                    function[i] = infinity;\n                }\n            } else if (operand[operandOffset] < 0) {\n                Arrays.fill(function, Double.NaN);\n            }\n        } else {\n            function[0] = FastMath.pow(a, operand[operandOffset]);\n            final double lnA = FastMath.log(a);\n            for (int i = 1; i < function.length; ++i) {\n                function[i] = lnA * function[i - 1];\n            }\n        }\n\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }",
          "38": "    public void pow(final double a,\n                    final double[] operand, final int operandOffset,\n                    final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        // [a^x, ln(a) a^x, ln(a)^2 a^x,, ln(a)^3 a^x, ... ]\n        final double[] function = new double[1 + order];\n        if (a == 0) {\n            if (operand[operandOffset] == 0) {\n                function[0] = 1;\n                double infinity = Double.POSITIVE_INFINITY;\n                for (int i = 1; i < function.length; ++i) {\ninfinity = operand;\n                    function[i] = infinity;\n                }\n            } else if (operand[operandOffset] < 0) {\n                Arrays.fill(function, Double.NaN);\n            }\n        } else {\n            function[0] = FastMath.pow(a, operand[operandOffset]);\n            final double lnA = FastMath.log(a);\n            for (int i = 1; i < function.length; ++i) {\n                function[i] = lnA * function[i - 1];\n            }\n        }\n\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }",
          "39": "    public void pow(final double a,\n                    final double[] operand, final int operandOffset,\n                    final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        // [a^x, ln(a) a^x, ln(a)^2 a^x,, ln(a)^3 a^x, ... ]\n        final double[] function = new double[1 + order];\n        if (a == 0) {\n            if (operand[operandOffset] == 0) {\n                function[0] = 1;\n                double infinity = Double.POSITIVE_INFINITY;\n                for (int i = 1; i < function.length; ++i) {\ninfinity = infinity--;\n                    function[i] = infinity;\n                }\n            } else if (operand[operandOffset] < 0) {\n                Arrays.fill(function, Double.NaN);\n            }\n        } else {\n            function[0] = FastMath.pow(a, operand[operandOffset]);\n            final double lnA = FastMath.log(a);\n            for (int i = 1; i < function.length; ++i) {\n                function[i] = lnA * function[i - 1];\n            }\n        }\n\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }",
          "40": "    public void pow(final double a,\n                    final double[] operand, final int operandOffset,\n                    final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        // [a^x, ln(a) a^x, ln(a)^2 a^x,, ln(a)^3 a^x, ... ]\n        final double[] function = new double[1 + order];\n        if (a == 0) {\n            if (operand[operandOffset] == 0) {\n                function[0] = 1;\n                double infinity = Double.POSITIVE_INFINITY;\n                for (int i = 1; i < function.length; ++i) {\nlnA = +infinity;\n                    function[i] = infinity;\n                }\n            } else if (operand[operandOffset] < 0) {\n                Arrays.fill(function, Double.NaN);\n            }\n        } else {\n            function[0] = FastMath.pow(a, operand[operandOffset]);\n            final double lnA = FastMath.log(a);\n            for (int i = 1; i < function.length; ++i) {\n                function[i] = lnA * function[i - 1];\n            }\n        }\n\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }",
          "41": "    public void pow(final double a,\n                    final double[] operand, final int operandOffset,\n                    final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        // [a^x, ln(a) a^x, ln(a)^2 a^x,, ln(a)^3 a^x, ... ]\n        final double[] function = new double[1 + order];\n        if (a == 0) {\n            if (operand[operandOffset] == 0) {\n                function[0] = 1;\n                double infinity = Double.POSITIVE_INFINITY;\n                for (int i = 1; i < function.length; ++i) {\ninfinity = infinity++;\n                    function[i] = infinity;\n                }\n            } else if (operand[operandOffset] < 0) {\n                Arrays.fill(function, Double.NaN);\n            }\n        } else {\n            function[0] = FastMath.pow(a, operand[operandOffset]);\n            final double lnA = FastMath.log(a);\n            for (int i = 1; i < function.length; ++i) {\n                function[i] = lnA * function[i - 1];\n            }\n        }\n\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }",
          "42": "    public void pow(final double a,\n                    final double[] operand, final int operandOffset,\n                    final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        // [a^x, ln(a) a^x, ln(a)^2 a^x,, ln(a)^3 a^x, ... ]\n        final double[] function = new double[1 + order];\n        if (a == 0) {\n            if (operand[operandOffset] == 0) {\n                function[0] = 1;\n                double infinity = Double.POSITIVE_INFINITY;\n                for (int i = 1; i < function.length; ++i) {\ninfinity = --infinity;\n                    function[i] = infinity;\n                }\n            } else if (operand[operandOffset] < 0) {\n                Arrays.fill(function, Double.NaN);\n            }\n        } else {\n            function[0] = FastMath.pow(a, operand[operandOffset]);\n            final double lnA = FastMath.log(a);\n            for (int i = 1; i < function.length; ++i) {\n                function[i] = lnA * function[i - 1];\n            }\n        }\n\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }",
          "43": "    public void pow(final double a,\n                    final double[] operand, final int operandOffset,\n                    final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        // [a^x, ln(a) a^x, ln(a)^2 a^x,, ln(a)^3 a^x, ... ]\n        final double[] function = new double[1 + order];\n        if (a == 0) {\n            if (operand[operandOffset] == 0) {\n                function[0] = 1;\n                double infinity = Double.POSITIVE_INFINITY;\n                for (int i = 1; i < function.length; ++i) {\ninfinity = order;\n                    function[i] = infinity;\n                }\n            } else if (operand[operandOffset] < 0) {\n                Arrays.fill(function, Double.NaN);\n            }\n        } else {\n            function[0] = FastMath.pow(a, operand[operandOffset]);\n            final double lnA = FastMath.log(a);\n            for (int i = 1; i < function.length; ++i) {\n                function[i] = lnA * function[i - 1];\n            }\n        }\n\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }",
          "44": "    public void pow(final double a,\n                    final double[] operand, final int operandOffset,\n                    final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        // [a^x, ln(a) a^x, ln(a)^2 a^x,, ln(a)^3 a^x, ... ]\n        final double[] function = new double[1 + order];\n        if (a == 0) {\n            if (operand[operandOffset] == 0) {\n                function[0] = 1;\n                double infinity = Double.POSITIVE_INFINITY;\n                for (int i = 1; i < function.length; ++i) {\ninfinity = ~;\n                    function[i] = infinity;\n                }\n            } else if (operand[operandOffset] < 0) {\n                Arrays.fill(function, Double.NaN);\n            }\n        } else {\n            function[0] = FastMath.pow(a, operand[operandOffset]);\n            final double lnA = FastMath.log(a);\n            for (int i = 1; i < function.length; ++i) {\n                function[i] = lnA * function[i - 1];\n            }\n        }\n\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }",
          "45": "    public void pow(final double a,\n                    final double[] operand, final int operandOffset,\n                    final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        // [a^x, ln(a) a^x, ln(a)^2 a^x,, ln(a)^3 a^x, ... ]\n        final double[] function = new double[1 + order];\n        if (a == 0) {\n            if (operand[operandOffset] == 0) {\n                function[0] = 1;\n                double infinity = Double.POSITIVE_INFINITY;\n                for (int i = 1; i < function.length; ++i) {\ninfinity -= infinity;\n                    function[i] = infinity;\n                }\n            } else if (operand[operandOffset] < 0) {\n                Arrays.fill(function, Double.NaN);\n            }\n        } else {\n            function[0] = FastMath.pow(a, operand[operandOffset]);\n            final double lnA = FastMath.log(a);\n            for (int i = 1; i < function.length; ++i) {\n                function[i] = lnA * function[i - 1];\n            }\n        }\n\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }",
          "46": "    public void pow(final double a,\n                    final double[] operand, final int operandOffset,\n                    final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        // [a^x, ln(a) a^x, ln(a)^2 a^x,, ln(a)^3 a^x, ... ]\n        final double[] function = new double[1 + order];\n        if (a == 0) {\n            if (operand[operandOffset] == 0) {\n                function[0] = 1;\n                double infinity = Double.POSITIVE_INFINITY;\n                for (int i = 1; i < function.length; ++i) {\nfor(int i = 1;(i < function.length);++i) {                    infinity = +infinity;                    function[i] = infinity;\n                }\n            } else if (operand[operandOffset] < 0) {\n                Arrays.fill(function, Double.NaN);\n            }\n        } else {\n            function[0] = FastMath.pow(a, operand[operandOffset]);\n            final double lnA = FastMath.log(a);\n            for (int i = 1; i < function.length; ++i) {\n                function[i] = lnA * function[i - 1];\n            }\n        }\n\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }",
          "47": "    public void pow(final double a,\n                    final double[] operand, final int operandOffset,\n                    final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        // [a^x, ln(a) a^x, ln(a)^2 a^x,, ln(a)^3 a^x, ... ]\n        final double[] function = new double[1 + order];\n        if (a == 0) {\n            if (operand[operandOffset] == 0) {\n                function[0] = 1;\n                double infinity = Double.POSITIVE_INFINITY;\n                for (int i = 1; i < function.length; ++i) {\ninfinity = -i;\n                    function[i] = infinity;\n                }\n            } else if (operand[operandOffset] < 0) {\n                Arrays.fill(function, Double.NaN);\n            }\n        } else {\n            function[0] = FastMath.pow(a, operand[operandOffset]);\n            final double lnA = FastMath.log(a);\n            for (int i = 1; i < function.length; ++i) {\n                function[i] = lnA * function[i - 1];\n            }\n        }\n\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }",
          "48": "    public void pow(final double a,\n                    final double[] operand, final int operandOffset,\n                    final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        // [a^x, ln(a) a^x, ln(a)^2 a^x,, ln(a)^3 a^x, ... ]\n        final double[] function = new double[1 + order];\n        if (a == 0) {\n            if (operand[operandOffset] == 0) {\n                function[0] = 1;\n                double infinity = Double.POSITIVE_INFINITY;\n                for (int i = 1; i < function.length; ++i) {\ninfinity--;\n                    function[i] = infinity;\n                }\n            } else if (operand[operandOffset] < 0) {\n                Arrays.fill(function, Double.NaN);\n            }\n        } else {\n            function[0] = FastMath.pow(a, operand[operandOffset]);\n            final double lnA = FastMath.log(a);\n            for (int i = 1; i < function.length; ++i) {\n                function[i] = lnA * function[i - 1];\n            }\n        }\n\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }",
          "49": "    public void pow(final double a,\n                    final double[] operand, final int operandOffset,\n                    final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        // [a^x, ln(a) a^x, ln(a)^2 a^x,, ln(a)^3 a^x, ... ]\n        final double[] function = new double[1 + order];\n        if (a == 0) {\n            if (operand[operandOffset] == 0) {\n                function[0] = 1;\n                double infinity = Double.POSITIVE_INFINITY;\n                for (int i = 1; i < function.length; ++i) {\nFastMath.pow(a, operand[operandOffset]);\n                    function[i] = infinity;\n                }\n            } else if (operand[operandOffset] < 0) {\n                Arrays.fill(function, Double.NaN);\n            }\n        } else {\n            function[0] = FastMath.pow(a, operand[operandOffset]);\n            final double lnA = FastMath.log(a);\n            for (int i = 1; i < function.length; ++i) {\n                function[i] = lnA * function[i - 1];\n            }\n        }\n\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }",
          "50": "    public void pow(final double a,\n                    final double[] operand, final int operandOffset,\n                    final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        // [a^x, ln(a) a^x, ln(a)^2 a^x,, ln(a)^3 a^x, ... ]\n        final double[] function = new double[1 + order];\n        if (a == 0) {\n            if (operand[operandOffset] == 0) {\n                function[0] = 1;\n                double infinity = Double.POSITIVE_INFINITY;\n                for (int i = 1; i < function.length; ++i) {\nif((operand[operandOffset] == 0)){\ncontinue;\n}\n                    infinity = +infinity;                    function[i] = infinity;\n                }\n            } else if (operand[operandOffset] < 0) {\n                Arrays.fill(function, Double.NaN);\n            }\n        } else {\n            function[0] = FastMath.pow(a, operand[operandOffset]);\n            final double lnA = FastMath.log(a);\n            for (int i = 1; i < function.length; ++i) {\n                function[i] = lnA * function[i - 1];\n            }\n        }\n\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }",
          "51": "    public void pow(final double a,\n                    final double[] operand, final int operandOffset,\n                    final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        // [a^x, ln(a) a^x, ln(a)^2 a^x,, ln(a)^3 a^x, ... ]\n        final double[] function = new double[1 + order];\n        if (a == 0) {\n            if (operand[operandOffset] == 0) {\n                function[0] = 1;\n                double infinity = Double.POSITIVE_INFINITY;\n                for (int i = 1; i < function.length; ++i) {\ninfinity = infinity[0];\n                    function[i] = infinity;\n                }\n            } else if (operand[operandOffset] < 0) {\n                Arrays.fill(function, Double.NaN);\n            }\n        } else {\n            function[0] = FastMath.pow(a, operand[operandOffset]);\n            final double lnA = FastMath.log(a);\n            for (int i = 1; i < function.length; ++i) {\n                function[i] = lnA * function[i - 1];\n            }\n        }\n\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }",
          "52": "    public void pow(final double a,\n                    final double[] operand, final int operandOffset,\n                    final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        // [a^x, ln(a) a^x, ln(a)^2 a^x,, ln(a)^3 a^x, ... ]\n        final double[] function = new double[1 + order];\n        if (a == 0) {\n            if (operand[operandOffset] == 0) {\n                function[0] = 1;\n                double infinity = Double.POSITIVE_INFINITY;\n                for (int i = 1; i < function.length; ++i) {\nfunction = +infinity;\n                    function[i] = infinity;\n                }\n            } else if (operand[operandOffset] < 0) {\n                Arrays.fill(function, Double.NaN);\n            }\n        } else {\n            function[0] = FastMath.pow(a, operand[operandOffset]);\n            final double lnA = FastMath.log(a);\n            for (int i = 1; i < function.length; ++i) {\n                function[i] = lnA * function[i - 1];\n            }\n        }\n\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }",
          "53": "    public void pow(final double a,\n                    final double[] operand, final int operandOffset,\n                    final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        // [a^x, ln(a) a^x, ln(a)^2 a^x,, ln(a)^3 a^x, ... ]\n        final double[] function = new double[1 + order];\n        if (a == 0) {\n            if (operand[operandOffset] == 0) {\n                function[0] = 1;\n                double infinity = Double.POSITIVE_INFINITY;\n                for (int i = 1; i < function.length; ++i) {\ninfinity[i];\n                    function[i] = infinity;\n                }\n            } else if (operand[operandOffset] < 0) {\n                Arrays.fill(function, Double.NaN);\n            }\n        } else {\n            function[0] = FastMath.pow(a, operand[operandOffset]);\n            final double lnA = FastMath.log(a);\n            for (int i = 1; i < function.length; ++i) {\n                function[i] = lnA * function[i - 1];\n            }\n        }\n\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }",
          "54": "    public void pow(final double a,\n                    final double[] operand, final int operandOffset,\n                    final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        // [a^x, ln(a) a^x, ln(a)^2 a^x,, ln(a)^3 a^x, ... ]\n        final double[] function = new double[1 + order];\n        if (a == 0) {\n            if (operand[operandOffset] == 0) {\n                function[0] = 1;\n                double infinity = Double.POSITIVE_INFINITY;\n                for (int i = 1; i < function.length; ++i) {\n-infinity = +infinity;\n                    function[i] = infinity;\n                }\n            } else if (operand[operandOffset] < 0) {\n                Arrays.fill(function, Double.NaN);\n            }\n        } else {\n            function[0] = FastMath.pow(a, operand[operandOffset]);\n            final double lnA = FastMath.log(a);\n            for (int i = 1; i < function.length; ++i) {\n                function[i] = lnA * function[i - 1];\n            }\n        }\n\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }",
          "55": "    public void pow(final double a,\n                    final double[] operand, final int operandOffset,\n                    final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        // [a^x, ln(a) a^x, ln(a)^2 a^x,, ln(a)^3 a^x, ... ]\n        final double[] function = new double[1 + order];\n        if (a == 0) {\n            if (operand[operandOffset] == 0) {\n                function[0] = 1;\n                double infinity = Double.POSITIVE_INFINITY;\n                for (int i = 1; i < function.length; ++i) {\ninfinity = infinity.infinity();\n                    function[i] = infinity;\n                }\n            } else if (operand[operandOffset] < 0) {\n                Arrays.fill(function, Double.NaN);\n            }\n        } else {\n            function[0] = FastMath.pow(a, operand[operandOffset]);\n            final double lnA = FastMath.log(a);\n            for (int i = 1; i < function.length; ++i) {\n                function[i] = lnA * function[i - 1];\n            }\n        }\n\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }",
          "56": "    public void pow(final double a,\n                    final double[] operand, final int operandOffset,\n                    final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        // [a^x, ln(a) a^x, ln(a)^2 a^x,, ln(a)^3 a^x, ... ]\n        final double[] function = new double[1 + order];\n        if (a == 0) {\n            if (operand[operandOffset] == 0) {\n                function[0] = 1;\n                double infinity = Double.POSITIVE_INFINITY;\n                for (int i = 1; i < function.length; ++i) {\n = +infinity;\n                    function[i] = infinity;\n                }\n            } else if (operand[operandOffset] < 0) {\n                Arrays.fill(function, Double.NaN);\n            }\n        } else {\n            function[0] = FastMath.pow(a, operand[operandOffset]);\n            final double lnA = FastMath.log(a);\n            for (int i = 1; i < function.length; ++i) {\n                function[i] = lnA * function[i - 1];\n            }\n        }\n\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }",
          "57": "    public void pow(final double a,\n                    final double[] operand, final int operandOffset,\n                    final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        // [a^x, ln(a) a^x, ln(a)^2 a^x,, ln(a)^3 a^x, ... ]\n        final double[] function = new double[1 + order];\n        if (a == 0) {\n            if (operand[operandOffset] == 0) {\n                function[0] = 1;\n                double infinity = Double.POSITIVE_INFINITY;\n                for (int i = 1; i < function.length; ++i) {\nif((a == 0)){\ncontinue;\n}\n                    infinity = +infinity;                    function[i] = infinity;\n                }\n            } else if (operand[operandOffset] < 0) {\n                Arrays.fill(function, Double.NaN);\n            }\n        } else {\n            function[0] = FastMath.pow(a, operand[operandOffset]);\n            final double lnA = FastMath.log(a);\n            for (int i = 1; i < function.length; ++i) {\n                function[i] = lnA * function[i - 1];\n            }\n        }\n\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }",
          "58": "    public void pow(final double a,\n                    final double[] operand, final int operandOffset,\n                    final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        // [a^x, ln(a) a^x, ln(a)^2 a^x,, ln(a)^3 a^x, ... ]\n        final double[] function = new double[1 + order];\n        if (a == 0) {\n            if (operand[operandOffset] == 0) {\n                function[0] = 1;\n                double infinity = Double.POSITIVE_INFINITY;\n                for (int i = 1; i < function.length; ++i) {\nif((i < function.length)){\ncontinue;\n}\n                    infinity = +infinity;                    function[i] = infinity;\n                }\n            } else if (operand[operandOffset] < 0) {\n                Arrays.fill(function, Double.NaN);\n            }\n        } else {\n            function[0] = FastMath.pow(a, operand[operandOffset]);\n            final double lnA = FastMath.log(a);\n            for (int i = 1; i < function.length; ++i) {\n                function[i] = lnA * function[i - 1];\n            }\n        }\n\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }",
          "59": "    public void pow(final double a,\n                    final double[] operand, final int operandOffset,\n                    final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        // [a^x, ln(a) a^x, ln(a)^2 a^x,, ln(a)^3 a^x, ... ]\n        final double[] function = new double[1 + order];\n        if (a == 0) {\n            if (operand[operandOffset] == 0) {\n                function[0] = 1;\n                double infinity = Double.POSITIVE_INFINITY;\n                for (int i = 1; i < function.length; ++i) {\nif(( != null)){\ncontinue;\n}\n                    infinity = +infinity;                    function[i] = infinity;\n                }\n            } else if (operand[operandOffset] < 0) {\n                Arrays.fill(function, Double.NaN);\n            }\n        } else {\n            function[0] = FastMath.pow(a, operand[operandOffset]);\n            final double lnA = FastMath.log(a);\n            for (int i = 1; i < function.length; ++i) {\n                function[i] = lnA * function[i - 1];\n            }\n        }\n\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }",
          "60": "    public void pow(final double a,\n                    final double[] operand, final int operandOffset,\n                    final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        // [a^x, ln(a) a^x, ln(a)^2 a^x,, ln(a)^3 a^x, ... ]\n        final double[] function = new double[1 + order];\n        if (a == 0) {\n            if (operand[operandOffset] == 0) {\n                function[0] = 1;\n                double infinity = Double.POSITIVE_INFINITY;\n                for (int i = 1; i < function.length; ++i) {\ninfinity += -infinity;\n                    function[i] = infinity;\n                }\n            } else if (operand[operandOffset] < 0) {\n                Arrays.fill(function, Double.NaN);\n            }\n        } else {\n            function[0] = FastMath.pow(a, operand[operandOffset]);\n            final double lnA = FastMath.log(a);\n            for (int i = 1; i < function.length; ++i) {\n                function[i] = lnA * function[i - 1];\n            }\n        }\n\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }",
          "61": "    public void pow(final double a,\n                    final double[] operand, final int operandOffset,\n                    final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        // [a^x, ln(a) a^x, ln(a)^2 a^x,, ln(a)^3 a^x, ... ]\n        final double[] function = new double[1 + order];\n        if (a == 0) {\n            if (operand[operandOffset] == 0) {\n                function[0] = 1;\n                double infinity = Double.POSITIVE_INFINITY;\n                for (int i = 1; i < function.length; ++i) {\ninfinity = (infinity + 1);\n                    function[i] = infinity;\n                }\n            } else if (operand[operandOffset] < 0) {\n                Arrays.fill(function, Double.NaN);\n            }\n        } else {\n            function[0] = FastMath.pow(a, operand[operandOffset]);\n            final double lnA = FastMath.log(a);\n            for (int i = 1; i < function.length; ++i) {\n                function[i] = lnA * function[i - 1];\n            }\n        }\n\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }",
          "62": "    public void pow(final double a,\n                    final double[] operand, final int operandOffset,\n                    final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        // [a^x, ln(a) a^x, ln(a)^2 a^x,, ln(a)^3 a^x, ... ]\n        final double[] function = new double[1 + order];\n        if (a == 0) {\n            if (operand[operandOffset] == 0) {\n                function[0] = 1;\n                double infinity = Double.POSITIVE_INFINITY;\n                for (int i = 1; i < function.length; ++i) {\nif((i != null)){\ncontinue;\n}\n                    infinity = +infinity;                    function[i] = infinity;\n                }\n            } else if (operand[operandOffset] < 0) {\n                Arrays.fill(function, Double.NaN);\n            }\n        } else {\n            function[0] = FastMath.pow(a, operand[operandOffset]);\n            final double lnA = FastMath.log(a);\n            for (int i = 1; i < function.length; ++i) {\n                function[i] = lnA * function[i - 1];\n            }\n        }\n\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }",
          "63": "    public void pow(final double a,\n                    final double[] operand, final int operandOffset,\n                    final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        // [a^x, ln(a) a^x, ln(a)^2 a^x,, ln(a)^3 a^x, ... ]\n        final double[] function = new double[1 + order];\n        if (a == 0) {\n            if (operand[operandOffset] == 0) {\n                function[0] = 1;\n                double infinity = Double.POSITIVE_INFINITY;\n                for (int i = 1; i < function.length; ++i) {\ninfinity = (infinity + 0);\n                    function[i] = infinity;\n                }\n            } else if (operand[operandOffset] < 0) {\n                Arrays.fill(function, Double.NaN);\n            }\n        } else {\n            function[0] = FastMath.pow(a, operand[operandOffset]);\n            final double lnA = FastMath.log(a);\n            for (int i = 1; i < function.length; ++i) {\n                function[i] = lnA * function[i - 1];\n            }\n        }\n\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }"
}