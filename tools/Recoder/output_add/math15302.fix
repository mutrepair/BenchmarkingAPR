{
          "0": "    private double brent(double lo, double hi,\n                         double fLo, double fHi) {\n        double a = lo;\n        double fa = fLo;\n        double b = hi;\n        double fb = fHi;\n        double c = a;\n        double fc = fa;\n        double d = b - a;\n        double e = d;\n\n        final double t = getAbsoluteAccuracy();\n        final double eps = getRelativeAccuracy();\n\n        while (true) {\n            if (FastMath.abs(fc) < FastMath.abs(fb)) {\n                a = b;\n                b = c;\n                c = a;\n                fa = fb;\n                fb = fc;\n                fc = fa;\n            }\n\n            final double tol = 2 * eps * FastMath.abs(b) + t;\n            final double m = 0.5 * (c - b);\n\n            if (FastMath.abs(m) <= tol ||\n                Precision.equals(fb, 0))  {\n                return b;\n            }\n            if (FastMath.abs(e) < tol ||\n                FastMath.abs(fa) <= FastMath.abs(fb)) {\n                // Force bisection.\n                d = m;\n                e = d;\n            } else {\n                double s = fb / fa;\n                double p;\n                double q;\n                // The equality test (a == c) is intentional,\n                // it is part of the original Brent's method and\n                // it should NOT be replaced by proximity test.\n                if (a == c) {\n                    // Linear interpolation.\n                    p = 2 * m * s;\n                    q = 1 - s;\n                } else {\n                    // Inverse quadratic interpolation.\n                    q = fa / fc;\n                    final double r = fb / fc;\n                    p = s * (2 * m * q * (q - r) - (b - a) * (r - 1));\n                    q = (q - 1) * (r - 1) * (s - 1);\n                }\n                if (p > 0) {\n                } else {\n                    p = -p;\n                }\n                s = e;\n                e = d;\n                if (p >= 1.5 * m * q - FastMath.abs(tol * q) ||\n                    p >= FastMath.abs(0.5 * s * q)) {\n                    // Inverse quadratic interpolation gives a value\n                    // in the wrong direction, or progress is slow.\n                    // Fall back to bisection.\n                    d = m;\n                    e = d;\n                } else {\n                    d = p / q;\n                }\n            }\n            a = b;\n            fa = fb;\n\n            if (FastMath.abs(d) > tol) {\n                b += d;\n            } else if (m > 0) {\n                b += tol;\n            } else {\n                b -= tol;\n            }\n            fb = computeObjectiveValue(b);\n            if ((fb > 0 && fc > 0) ||\n                (fb <= 0 && fc <= 0)) {\n                c = a;\n                fc = fa;\n                d = b - a;\n                e = d;\n            }\n        }\n    }",
          "1": "    private double brent(double lo, double hi,\n                         double fLo, double fHi) {\n        double a = lo;\n        double fa = fLo;\n        double b = hi;\n        double fb = fHi;\n        double c = a;\n        double fc = fa;\n        double d = b - a;\n        double e = d;\n\n        final double t = getAbsoluteAccuracy();\n        final double eps = getRelativeAccuracy();\n\n        while (true) {\n            if (FastMath.abs(fc) < FastMath.abs(fb)) {\n                a = b;\n                b = c;\n                c = a;\n                fa = fb;\n                fb = fc;\n                fc = fa;\n            }\n\n            final double tol = 2 * eps * FastMath.abs(b) + t;\n            final double m = 0.5 * (c - b);\n\n            if (FastMath.abs(m) <= tol ||\n                Precision.equals(fb, 0))  {\n                return b;\n            }\n            if (FastMath.abs(e) < tol ||\n                FastMath.abs(fa) <= FastMath.abs(fb)) {\n                // Force bisection.\n                d = m;\n                e = d;\n            } else {\n                double s = fb / fa;\n                double p;\n                double q;\n                // The equality test (a == c) is intentional,\n                // it is part of the original Brent's method and\n                // it should NOT be replaced by proximity test.\n                if (a == c) {\n                    // Linear interpolation.\n                    p = 2 * m * s;\n                    q = 1 - s;\n                } else {\n                    // Inverse quadratic interpolation.\n                    q = fa / fc;\n                    final double r = fb / fc;\n                    p = s * (2 * m * q * (q - r) - (b - a) * (r - 1));\n                    q = (q - 1) * (r - 1) * (s - 1);\n                }\n                if (p > 0) {\nq = (1 - s);\n                } else {\n                    p = -p;\n                }\n                s = e;\n                e = d;\n                if (p >= 1.5 * m * q - FastMath.abs(tol * q) ||\n                    p >= FastMath.abs(0.5 * s * q)) {\n                    // Inverse quadratic interpolation gives a value\n                    // in the wrong direction, or progress is slow.\n                    // Fall back to bisection.\n                    d = m;\n                    e = d;\n                } else {\n                    d = p / q;\n                }\n            }\n            a = b;\n            fa = fb;\n\n            if (FastMath.abs(d) > tol) {\n                b += d;\n            } else if (m > 0) {\n                b += tol;\n            } else {\n                b -= tol;\n            }\n            fb = computeObjectiveValue(b);\n            if ((fb > 0 && fc > 0) ||\n                (fb <= 0 && fc <= 0)) {\n                c = a;\n                fc = fa;\n                d = b - a;\n                e = d;\n            }\n        }\n    }",
          "2": "    private double brent(double lo, double hi,\n                         double fLo, double fHi) {\n        double a = lo;\n        double fa = fLo;\n        double b = hi;\n        double fb = fHi;\n        double c = a;\n        double fc = fa;\n        double d = b - a;\n        double e = d;\n\n        final double t = getAbsoluteAccuracy();\n        final double eps = getRelativeAccuracy();\n\n        while (true) {\n            if (FastMath.abs(fc) < FastMath.abs(fb)) {\n                a = b;\n                b = c;\n                c = a;\n                fa = fb;\n                fb = fc;\n                fc = fa;\n            }\n\n            final double tol = 2 * eps * FastMath.abs(b) + t;\n            final double m = 0.5 * (c - b);\n\n            if (FastMath.abs(m) <= tol ||\n                Precision.equals(fb, 0))  {\n                return b;\n            }\n            if (FastMath.abs(e) < tol ||\n                FastMath.abs(fa) <= FastMath.abs(fb)) {\n                // Force bisection.\n                d = m;\n                e = d;\n            } else {\n                double s = fb / fa;\n                double p;\n                double q;\n                // The equality test (a == c) is intentional,\n                // it is part of the original Brent's method and\n                // it should NOT be replaced by proximity test.\n                if (a == c) {\n                    // Linear interpolation.\n                    p = 2 * m * s;\n                    q = 1 - s;\n                } else {\n                    // Inverse quadratic interpolation.\n                    q = fa / fc;\n                    final double r = fb / fc;\n                    p = s * (2 * m * q * (q - r) - (b - a) * (r - 1));\n                    q = (q - 1) * (r - 1) * (s - 1);\n                }\n                if (p > 0) {\np = ((2 * m) * s);\n                } else {\n                    p = -p;\n                }\n                s = e;\n                e = d;\n                if (p >= 1.5 * m * q - FastMath.abs(tol * q) ||\n                    p >= FastMath.abs(0.5 * s * q)) {\n                    // Inverse quadratic interpolation gives a value\n                    // in the wrong direction, or progress is slow.\n                    // Fall back to bisection.\n                    d = m;\n                    e = d;\n                } else {\n                    d = p / q;\n                }\n            }\n            a = b;\n            fa = fb;\n\n            if (FastMath.abs(d) > tol) {\n                b += d;\n            } else if (m > 0) {\n                b += tol;\n            } else {\n                b -= tol;\n            }\n            fb = computeObjectiveValue(b);\n            if ((fb > 0 && fc > 0) ||\n                (fb <= 0 && fc <= 0)) {\n                c = a;\n                fc = fa;\n                d = b - a;\n                e = d;\n            }\n        }\n    }",
          "3": "    private double brent(double lo, double hi,\n                         double fLo, double fHi) {\n        double a = lo;\n        double fa = fLo;\n        double b = hi;\n        double fb = fHi;\n        double c = a;\n        double fc = fa;\n        double d = b - a;\n        double e = d;\n\n        final double t = getAbsoluteAccuracy();\n        final double eps = getRelativeAccuracy();\n\n        while (true) {\n            if (FastMath.abs(fc) < FastMath.abs(fb)) {\n                a = b;\n                b = c;\n                c = a;\n                fa = fb;\n                fb = fc;\n                fc = fa;\n            }\n\n            final double tol = 2 * eps * FastMath.abs(b) + t;\n            final double m = 0.5 * (c - b);\n\n            if (FastMath.abs(m) <= tol ||\n                Precision.equals(fb, 0))  {\n                return b;\n            }\n            if (FastMath.abs(e) < tol ||\n                FastMath.abs(fa) <= FastMath.abs(fb)) {\n                // Force bisection.\n                d = m;\n                e = d;\n            } else {\n                double s = fb / fa;\n                double p;\n                double q;\n                // The equality test (a == c) is intentional,\n                // it is part of the original Brent's method and\n                // it should NOT be replaced by proximity test.\n                if (a == c) {\n                    // Linear interpolation.\n                    p = 2 * m * s;\n                    q = 1 - s;\n                } else {\n                    // Inverse quadratic interpolation.\n                    q = fa / fc;\n                    final double r = fb / fc;\n                    p = s * (2 * m * q * (q - r) - (b - a) * (r - 1));\n                    q = (q - 1) * (r - 1) * (s - 1);\n                }\n                if (p > 0) {\np = -p;\n                } else {\n                    p = -p;\n                }\n                s = e;\n                e = d;\n                if (p >= 1.5 * m * q - FastMath.abs(tol * q) ||\n                    p >= FastMath.abs(0.5 * s * q)) {\n                    // Inverse quadratic interpolation gives a value\n                    // in the wrong direction, or progress is slow.\n                    // Fall back to bisection.\n                    d = m;\n                    e = d;\n                } else {\n                    d = p / q;\n                }\n            }\n            a = b;\n            fa = fb;\n\n            if (FastMath.abs(d) > tol) {\n                b += d;\n            } else if (m > 0) {\n                b += tol;\n            } else {\n                b -= tol;\n            }\n            fb = computeObjectiveValue(b);\n            if ((fb > 0 && fc > 0) ||\n                (fb <= 0 && fc <= 0)) {\n                c = a;\n                fc = fa;\n                d = b - a;\n                e = d;\n            }\n        }\n    }",
          "4": "    private double brent(double lo, double hi,\n                         double fLo, double fHi) {\n        double a = lo;\n        double fa = fLo;\n        double b = hi;\n        double fb = fHi;\n        double c = a;\n        double fc = fa;\n        double d = b - a;\n        double e = d;\n\n        final double t = getAbsoluteAccuracy();\n        final double eps = getRelativeAccuracy();\n\n        while (true) {\n            if (FastMath.abs(fc) < FastMath.abs(fb)) {\n                a = b;\n                b = c;\n                c = a;\n                fa = fb;\n                fb = fc;\n                fc = fa;\n            }\n\n            final double tol = 2 * eps * FastMath.abs(b) + t;\n            final double m = 0.5 * (c - b);\n\n            if (FastMath.abs(m) <= tol ||\n                Precision.equals(fb, 0))  {\n                return b;\n            }\n            if (FastMath.abs(e) < tol ||\n                FastMath.abs(fa) <= FastMath.abs(fb)) {\n                // Force bisection.\n                d = m;\n                e = d;\n            } else {\n                double s = fb / fa;\n                double p;\n                double q;\n                // The equality test (a == c) is intentional,\n                // it is part of the original Brent's method and\n                // it should NOT be replaced by proximity test.\n                if (a == c) {\n                    // Linear interpolation.\n                    p = 2 * m * s;\n                    q = 1 - s;\n                } else {\n                    // Inverse quadratic interpolation.\n                    q = fa / fc;\n                    final double r = fb / fc;\n                    p = s * (2 * m * q * (q - r) - (b - a) * (r - 1));\n                    q = (q - 1) * (r - 1) * (s - 1);\n                }\n                if (p > 0) {\nq = (fa / fc);\n                } else {\n                    p = -p;\n                }\n                s = e;\n                e = d;\n                if (p >= 1.5 * m * q - FastMath.abs(tol * q) ||\n                    p >= FastMath.abs(0.5 * s * q)) {\n                    // Inverse quadratic interpolation gives a value\n                    // in the wrong direction, or progress is slow.\n                    // Fall back to bisection.\n                    d = m;\n                    e = d;\n                } else {\n                    d = p / q;\n                }\n            }\n            a = b;\n            fa = fb;\n\n            if (FastMath.abs(d) > tol) {\n                b += d;\n            } else if (m > 0) {\n                b += tol;\n            } else {\n                b -= tol;\n            }\n            fb = computeObjectiveValue(b);\n            if ((fb > 0 && fc > 0) ||\n                (fb <= 0 && fc <= 0)) {\n                c = a;\n                fc = fa;\n                d = b - a;\n                e = d;\n            }\n        }\n    }",
          "5": "    private double brent(double lo, double hi,\n                         double fLo, double fHi) {\n        double a = lo;\n        double fa = fLo;\n        double b = hi;\n        double fb = fHi;\n        double c = a;\n        double fc = fa;\n        double d = b - a;\n        double e = d;\n\n        final double t = getAbsoluteAccuracy();\n        final double eps = getRelativeAccuracy();\n\n        while (true) {\n            if (FastMath.abs(fc) < FastMath.abs(fb)) {\n                a = b;\n                b = c;\n                c = a;\n                fa = fb;\n                fb = fc;\n                fc = fa;\n            }\n\n            final double tol = 2 * eps * FastMath.abs(b) + t;\n            final double m = 0.5 * (c - b);\n\n            if (FastMath.abs(m) <= tol ||\n                Precision.equals(fb, 0))  {\n                return b;\n            }\n            if (FastMath.abs(e) < tol ||\n                FastMath.abs(fa) <= FastMath.abs(fb)) {\n                // Force bisection.\n                d = m;\n                e = d;\n            } else {\n                double s = fb / fa;\n                double p;\n                double q;\n                // The equality test (a == c) is intentional,\n                // it is part of the original Brent's method and\n                // it should NOT be replaced by proximity test.\n                if (a == c) {\n                    // Linear interpolation.\n                    p = 2 * m * s;\n                    q = 1 - s;\n                } else {\n                    // Inverse quadratic interpolation.\n                    q = fa / fc;\n                    final double r = fb / fc;\n                    p = s * (2 * m * q * (q - r) - (b - a) * (r - 1));\n                    q = (q - 1) * (r - 1) * (s - 1);\n                }\n                if (p > 0) {\nq = (((q - 1) * (r - 1)) * (s - 1));\n                } else {\n                    p = -p;\n                }\n                s = e;\n                e = d;\n                if (p >= 1.5 * m * q - FastMath.abs(tol * q) ||\n                    p >= FastMath.abs(0.5 * s * q)) {\n                    // Inverse quadratic interpolation gives a value\n                    // in the wrong direction, or progress is slow.\n                    // Fall back to bisection.\n                    d = m;\n                    e = d;\n                } else {\n                    d = p / q;\n                }\n            }\n            a = b;\n            fa = fb;\n\n            if (FastMath.abs(d) > tol) {\n                b += d;\n            } else if (m > 0) {\n                b += tol;\n            } else {\n                b -= tol;\n            }\n            fb = computeObjectiveValue(b);\n            if ((fb > 0 && fc > 0) ||\n                (fb <= 0 && fc <= 0)) {\n                c = a;\n                fc = fa;\n                d = b - a;\n                e = d;\n            }\n        }\n    }",
          "6": "    private double brent(double lo, double hi,\n                         double fLo, double fHi) {\n        double a = lo;\n        double fa = fLo;\n        double b = hi;\n        double fb = fHi;\n        double c = a;\n        double fc = fa;\n        double d = b - a;\n        double e = d;\n\n        final double t = getAbsoluteAccuracy();\n        final double eps = getRelativeAccuracy();\n\n        while (true) {\n            if (FastMath.abs(fc) < FastMath.abs(fb)) {\n                a = b;\n                b = c;\n                c = a;\n                fa = fb;\n                fb = fc;\n                fc = fa;\n            }\n\n            final double tol = 2 * eps * FastMath.abs(b) + t;\n            final double m = 0.5 * (c - b);\n\n            if (FastMath.abs(m) <= tol ||\n                Precision.equals(fb, 0))  {\n                return b;\n            }\n            if (FastMath.abs(e) < tol ||\n                FastMath.abs(fa) <= FastMath.abs(fb)) {\n                // Force bisection.\n                d = m;\n                e = d;\n            } else {\n                double s = fb / fa;\n                double p;\n                double q;\n                // The equality test (a == c) is intentional,\n                // it is part of the original Brent's method and\n                // it should NOT be replaced by proximity test.\n                if (a == c) {\n                    // Linear interpolation.\n                    p = 2 * m * s;\n                    q = 1 - s;\n                } else {\n                    // Inverse quadratic interpolation.\n                    q = fa / fc;\n                    final double r = fb / fc;\n                    p = s * (2 * m * q * (q - r) - (b - a) * (r - 1));\n                    q = (q - 1) * (r - 1) * (s - 1);\n                }\n                if (p > 0) {\np = (s * ((((2 * m) * q) * (q - r)) - ((b - a) * (r - 1))));\n                } else {\n                    p = -p;\n                }\n                s = e;\n                e = d;\n                if (p >= 1.5 * m * q - FastMath.abs(tol * q) ||\n                    p >= FastMath.abs(0.5 * s * q)) {\n                    // Inverse quadratic interpolation gives a value\n                    // in the wrong direction, or progress is slow.\n                    // Fall back to bisection.\n                    d = m;\n                    e = d;\n                } else {\n                    d = p / q;\n                }\n            }\n            a = b;\n            fa = fb;\n\n            if (FastMath.abs(d) > tol) {\n                b += d;\n            } else if (m > 0) {\n                b += tol;\n            } else {\n                b -= tol;\n            }\n            fb = computeObjectiveValue(b);\n            if ((fb > 0 && fc > 0) ||\n                (fb <= 0 && fc <= 0)) {\n                c = a;\n                fc = fa;\n                d = b - a;\n                e = d;\n            }\n        }\n    }",
          "7": "    private double brent(double lo, double hi,\n                         double fLo, double fHi) {\n        double a = lo;\n        double fa = fLo;\n        double b = hi;\n        double fb = fHi;\n        double c = a;\n        double fc = fa;\n        double d = b - a;\n        double e = d;\n\n        final double t = getAbsoluteAccuracy();\n        final double eps = getRelativeAccuracy();\n\n        while (true) {\n            if (FastMath.abs(fc) < FastMath.abs(fb)) {\n                a = b;\n                b = c;\n                c = a;\n                fa = fb;\n                fb = fc;\n                fc = fa;\n            }\n\n            final double tol = 2 * eps * FastMath.abs(b) + t;\n            final double m = 0.5 * (c - b);\n\n            if (FastMath.abs(m) <= tol ||\n                Precision.equals(fb, 0))  {\n                return b;\n            }\n            if (FastMath.abs(e) < tol ||\n                FastMath.abs(fa) <= FastMath.abs(fb)) {\n                // Force bisection.\n                d = m;\n                e = d;\n            } else {\n                double s = fb / fa;\n                double p;\n                double q;\n                // The equality test (a == c) is intentional,\n                // it is part of the original Brent's method and\n                // it should NOT be replaced by proximity test.\n                if (a == c) {\n                    // Linear interpolation.\n                    p = 2 * m * s;\n                    q = 1 - s;\n                } else {\n                    // Inverse quadratic interpolation.\n                    q = fa / fc;\n                    final double r = fb / fc;\n                    p = s * (2 * m * q * (q - r) - (b - a) * (r - 1));\n                    q = (q - 1) * (r - 1) * (s - 1);\n                }\n                if (p > 0) {\ns = e;\n                } else {\n                    p = -p;\n                }\n                s = e;\n                e = d;\n                if (p >= 1.5 * m * q - FastMath.abs(tol * q) ||\n                    p >= FastMath.abs(0.5 * s * q)) {\n                    // Inverse quadratic interpolation gives a value\n                    // in the wrong direction, or progress is slow.\n                    // Fall back to bisection.\n                    d = m;\n                    e = d;\n                } else {\n                    d = p / q;\n                }\n            }\n            a = b;\n            fa = fb;\n\n            if (FastMath.abs(d) > tol) {\n                b += d;\n            } else if (m > 0) {\n                b += tol;\n            } else {\n                b -= tol;\n            }\n            fb = computeObjectiveValue(b);\n            if ((fb > 0 && fc > 0) ||\n                (fb <= 0 && fc <= 0)) {\n                c = a;\n                fc = fa;\n                d = b - a;\n                e = d;\n            }\n        }\n    }",
          "8": "    private double brent(double lo, double hi,\n                         double fLo, double fHi) {\n        double a = lo;\n        double fa = fLo;\n        double b = hi;\n        double fb = fHi;\n        double c = a;\n        double fc = fa;\n        double d = b - a;\n        double e = d;\n\n        final double t = getAbsoluteAccuracy();\n        final double eps = getRelativeAccuracy();\n\n        while (true) {\n            if (FastMath.abs(fc) < FastMath.abs(fb)) {\n                a = b;\n                b = c;\n                c = a;\n                fa = fb;\n                fb = fc;\n                fc = fa;\n            }\n\n            final double tol = 2 * eps * FastMath.abs(b) + t;\n            final double m = 0.5 * (c - b);\n\n            if (FastMath.abs(m) <= tol ||\n                Precision.equals(fb, 0))  {\n                return b;\n            }\n            if (FastMath.abs(e) < tol ||\n                FastMath.abs(fa) <= FastMath.abs(fb)) {\n                // Force bisection.\n                d = m;\n                e = d;\n            } else {\n                double s = fb / fa;\n                double p;\n                double q;\n                // The equality test (a == c) is intentional,\n                // it is part of the original Brent's method and\n                // it should NOT be replaced by proximity test.\n                if (a == c) {\n                    // Linear interpolation.\n                    p = 2 * m * s;\n                    q = 1 - s;\n                } else {\n                    // Inverse quadratic interpolation.\n                    q = fa / fc;\n                    final double r = fb / fc;\n                    p = s * (2 * m * q * (q - r) - (b - a) * (r - 1));\n                    q = (q - 1) * (r - 1) * (s - 1);\n                }\n                if (p > 0) {\nq = p;\n                } else {\n                    p = -p;\n                }\n                s = e;\n                e = d;\n                if (p >= 1.5 * m * q - FastMath.abs(tol * q) ||\n                    p >= FastMath.abs(0.5 * s * q)) {\n                    // Inverse quadratic interpolation gives a value\n                    // in the wrong direction, or progress is slow.\n                    // Fall back to bisection.\n                    d = m;\n                    e = d;\n                } else {\n                    d = p / q;\n                }\n            }\n            a = b;\n            fa = fb;\n\n            if (FastMath.abs(d) > tol) {\n                b += d;\n            } else if (m > 0) {\n                b += tol;\n            } else {\n                b -= tol;\n            }\n            fb = computeObjectiveValue(b);\n            if ((fb > 0 && fc > 0) ||\n                (fb <= 0 && fc <= 0)) {\n                c = a;\n                fc = fa;\n                d = b - a;\n                e = d;\n            }\n        }\n    }",
          "9": "    private double brent(double lo, double hi,\n                         double fLo, double fHi) {\n        double a = lo;\n        double fa = fLo;\n        double b = hi;\n        double fb = fHi;\n        double c = a;\n        double fc = fa;\n        double d = b - a;\n        double e = d;\n\n        final double t = getAbsoluteAccuracy();\n        final double eps = getRelativeAccuracy();\n\n        while (true) {\n            if (FastMath.abs(fc) < FastMath.abs(fb)) {\n                a = b;\n                b = c;\n                c = a;\n                fa = fb;\n                fb = fc;\n                fc = fa;\n            }\n\n            final double tol = 2 * eps * FastMath.abs(b) + t;\n            final double m = 0.5 * (c - b);\n\n            if (FastMath.abs(m) <= tol ||\n                Precision.equals(fb, 0))  {\n                return b;\n            }\n            if (FastMath.abs(e) < tol ||\n                FastMath.abs(fa) <= FastMath.abs(fb)) {\n                // Force bisection.\n                d = m;\n                e = d;\n            } else {\n                double s = fb / fa;\n                double p;\n                double q;\n                // The equality test (a == c) is intentional,\n                // it is part of the original Brent's method and\n                // it should NOT be replaced by proximity test.\n                if (a == c) {\n                    // Linear interpolation.\n                    p = 2 * m * s;\n                    q = 1 - s;\n                } else {\n                    // Inverse quadratic interpolation.\n                    q = fa / fc;\n                    final double r = fb / fc;\n                    p = s * (2 * m * q * (q - r) - (b - a) * (r - 1));\n                    q = (q - 1) * (r - 1) * (s - 1);\n                }\n                if (p > 0) {\nq = q;\n                } else {\n                    p = -p;\n                }\n                s = e;\n                e = d;\n                if (p >= 1.5 * m * q - FastMath.abs(tol * q) ||\n                    p >= FastMath.abs(0.5 * s * q)) {\n                    // Inverse quadratic interpolation gives a value\n                    // in the wrong direction, or progress is slow.\n                    // Fall back to bisection.\n                    d = m;\n                    e = d;\n                } else {\n                    d = p / q;\n                }\n            }\n            a = b;\n            fa = fb;\n\n            if (FastMath.abs(d) > tol) {\n                b += d;\n            } else if (m > 0) {\n                b += tol;\n            } else {\n                b -= tol;\n            }\n            fb = computeObjectiveValue(b);\n            if ((fb > 0 && fc > 0) ||\n                (fb <= 0 && fc <= 0)) {\n                c = a;\n                fc = fa;\n                d = b - a;\n                e = d;\n            }\n        }\n    }",
          "10": "    private double brent(double lo, double hi,\n                         double fLo, double fHi) {\n        double a = lo;\n        double fa = fLo;\n        double b = hi;\n        double fb = fHi;\n        double c = a;\n        double fc = fa;\n        double d = b - a;\n        double e = d;\n\n        final double t = getAbsoluteAccuracy();\n        final double eps = getRelativeAccuracy();\n\n        while (true) {\n            if (FastMath.abs(fc) < FastMath.abs(fb)) {\n                a = b;\n                b = c;\n                c = a;\n                fa = fb;\n                fb = fc;\n                fc = fa;\n            }\n\n            final double tol = 2 * eps * FastMath.abs(b) + t;\n            final double m = 0.5 * (c - b);\n\n            if (FastMath.abs(m) <= tol ||\n                Precision.equals(fb, 0))  {\n                return b;\n            }\n            if (FastMath.abs(e) < tol ||\n                FastMath.abs(fa) <= FastMath.abs(fb)) {\n                // Force bisection.\n                d = m;\n                e = d;\n            } else {\n                double s = fb / fa;\n                double p;\n                double q;\n                // The equality test (a == c) is intentional,\n                // it is part of the original Brent's method and\n                // it should NOT be replaced by proximity test.\n                if (a == c) {\n                    // Linear interpolation.\n                    p = 2 * m * s;\n                    q = 1 - s;\n                } else {\n                    // Inverse quadratic interpolation.\n                    q = fa / fc;\n                    final double r = fb / fc;\n                    p = s * (2 * m * q * (q - r) - (b - a) * (r - 1));\n                    q = (q - 1) * (r - 1) * (s - 1);\n                }\n                if (p > 0) {\nq = (1 - s);\n                    q = +q;                } else {\n                    p = -p;\n                }\n                s = e;\n                e = d;\n                if (p >= 1.5 * m * q - FastMath.abs(tol * q) ||\n                    p >= FastMath.abs(0.5 * s * q)) {\n                    // Inverse quadratic interpolation gives a value\n                    // in the wrong direction, or progress is slow.\n                    // Fall back to bisection.\n                    d = m;\n                    e = d;\n                } else {\n                    d = p / q;\n                }\n            }\n            a = b;\n            fa = fb;\n\n            if (FastMath.abs(d) > tol) {\n                b += d;\n            } else if (m > 0) {\n                b += tol;\n            } else {\n                b -= tol;\n            }\n            fb = computeObjectiveValue(b);\n            if ((fb > 0 && fc > 0) ||\n                (fb <= 0 && fc <= 0)) {\n                c = a;\n                fc = fa;\n                d = b - a;\n                e = d;\n            }\n        }\n    }",
          "11": "    private double brent(double lo, double hi,\n                         double fLo, double fHi) {\n        double a = lo;\n        double fa = fLo;\n        double b = hi;\n        double fb = fHi;\n        double c = a;\n        double fc = fa;\n        double d = b - a;\n        double e = d;\n\n        final double t = getAbsoluteAccuracy();\n        final double eps = getRelativeAccuracy();\n\n        while (true) {\n            if (FastMath.abs(fc) < FastMath.abs(fb)) {\n                a = b;\n                b = c;\n                c = a;\n                fa = fb;\n                fb = fc;\n                fc = fa;\n            }\n\n            final double tol = 2 * eps * FastMath.abs(b) + t;\n            final double m = 0.5 * (c - b);\n\n            if (FastMath.abs(m) <= tol ||\n                Precision.equals(fb, 0))  {\n                return b;\n            }\n            if (FastMath.abs(e) < tol ||\n                FastMath.abs(fa) <= FastMath.abs(fb)) {\n                // Force bisection.\n                d = m;\n                e = d;\n            } else {\n                double s = fb / fa;\n                double p;\n                double q;\n                // The equality test (a == c) is intentional,\n                // it is part of the original Brent's method and\n                // it should NOT be replaced by proximity test.\n                if (a == c) {\n                    // Linear interpolation.\n                    p = 2 * m * s;\n                    q = 1 - s;\n                } else {\n                    // Inverse quadratic interpolation.\n                    q = fa / fc;\n                    final double r = fb / fc;\n                    p = s * (2 * m * q * (q - r) - (b - a) * (r - 1));\n                    q = (q - 1) * (r - 1) * (s - 1);\n                }\n                if (p > 0) {\np = ((2 * m) * s);\n                    q = +q;                } else {\n                    p = -p;\n                }\n                s = e;\n                e = d;\n                if (p >= 1.5 * m * q - FastMath.abs(tol * q) ||\n                    p >= FastMath.abs(0.5 * s * q)) {\n                    // Inverse quadratic interpolation gives a value\n                    // in the wrong direction, or progress is slow.\n                    // Fall back to bisection.\n                    d = m;\n                    e = d;\n                } else {\n                    d = p / q;\n                }\n            }\n            a = b;\n            fa = fb;\n\n            if (FastMath.abs(d) > tol) {\n                b += d;\n            } else if (m > 0) {\n                b += tol;\n            } else {\n                b -= tol;\n            }\n            fb = computeObjectiveValue(b);\n            if ((fb > 0 && fc > 0) ||\n                (fb <= 0 && fc <= 0)) {\n                c = a;\n                fc = fa;\n                d = b - a;\n                e = d;\n            }\n        }\n    }",
          "12": "    private double brent(double lo, double hi,\n                         double fLo, double fHi) {\n        double a = lo;\n        double fa = fLo;\n        double b = hi;\n        double fb = fHi;\n        double c = a;\n        double fc = fa;\n        double d = b - a;\n        double e = d;\n\n        final double t = getAbsoluteAccuracy();\n        final double eps = getRelativeAccuracy();\n\n        while (true) {\n            if (FastMath.abs(fc) < FastMath.abs(fb)) {\n                a = b;\n                b = c;\n                c = a;\n                fa = fb;\n                fb = fc;\n                fc = fa;\n            }\n\n            final double tol = 2 * eps * FastMath.abs(b) + t;\n            final double m = 0.5 * (c - b);\n\n            if (FastMath.abs(m) <= tol ||\n                Precision.equals(fb, 0))  {\n                return b;\n            }\n            if (FastMath.abs(e) < tol ||\n                FastMath.abs(fa) <= FastMath.abs(fb)) {\n                // Force bisection.\n                d = m;\n                e = d;\n            } else {\n                double s = fb / fa;\n                double p;\n                double q;\n                // The equality test (a == c) is intentional,\n                // it is part of the original Brent's method and\n                // it should NOT be replaced by proximity test.\n                if (a == c) {\n                    // Linear interpolation.\n                    p = 2 * m * s;\n                    q = 1 - s;\n                } else {\n                    // Inverse quadratic interpolation.\n                    q = fa / fc;\n                    final double r = fb / fc;\n                    p = s * (2 * m * q * (q - r) - (b - a) * (r - 1));\n                    q = (q - 1) * (r - 1) * (s - 1);\n                }\n                if (p > 0) {\nq = (fa / fc);\n                    q = +q;                } else {\n                    p = -p;\n                }\n                s = e;\n                e = d;\n                if (p >= 1.5 * m * q - FastMath.abs(tol * q) ||\n                    p >= FastMath.abs(0.5 * s * q)) {\n                    // Inverse quadratic interpolation gives a value\n                    // in the wrong direction, or progress is slow.\n                    // Fall back to bisection.\n                    d = m;\n                    e = d;\n                } else {\n                    d = p / q;\n                }\n            }\n            a = b;\n            fa = fb;\n\n            if (FastMath.abs(d) > tol) {\n                b += d;\n            } else if (m > 0) {\n                b += tol;\n            } else {\n                b -= tol;\n            }\n            fb = computeObjectiveValue(b);\n            if ((fb > 0 && fc > 0) ||\n                (fb <= 0 && fc <= 0)) {\n                c = a;\n                fc = fa;\n                d = b - a;\n                e = d;\n            }\n        }\n    }",
          "13": "    private double brent(double lo, double hi,\n                         double fLo, double fHi) {\n        double a = lo;\n        double fa = fLo;\n        double b = hi;\n        double fb = fHi;\n        double c = a;\n        double fc = fa;\n        double d = b - a;\n        double e = d;\n\n        final double t = getAbsoluteAccuracy();\n        final double eps = getRelativeAccuracy();\n\n        while (true) {\n            if (FastMath.abs(fc) < FastMath.abs(fb)) {\n                a = b;\n                b = c;\n                c = a;\n                fa = fb;\n                fb = fc;\n                fc = fa;\n            }\n\n            final double tol = 2 * eps * FastMath.abs(b) + t;\n            final double m = 0.5 * (c - b);\n\n            if (FastMath.abs(m) <= tol ||\n                Precision.equals(fb, 0))  {\n                return b;\n            }\n            if (FastMath.abs(e) < tol ||\n                FastMath.abs(fa) <= FastMath.abs(fb)) {\n                // Force bisection.\n                d = m;\n                e = d;\n            } else {\n                double s = fb / fa;\n                double p;\n                double q;\n                // The equality test (a == c) is intentional,\n                // it is part of the original Brent's method and\n                // it should NOT be replaced by proximity test.\n                if (a == c) {\n                    // Linear interpolation.\n                    p = 2 * m * s;\n                    q = 1 - s;\n                } else {\n                    // Inverse quadratic interpolation.\n                    q = fa / fc;\n                    final double r = fb / fc;\n                    p = s * (2 * m * q * (q - r) - (b - a) * (r - 1));\n                    q = (q - 1) * (r - 1) * (s - 1);\n                }\n                if (p > 0) {\np = -p;\n                    q = +q;                } else {\n                    p = -p;\n                }\n                s = e;\n                e = d;\n                if (p >= 1.5 * m * q - FastMath.abs(tol * q) ||\n                    p >= FastMath.abs(0.5 * s * q)) {\n                    // Inverse quadratic interpolation gives a value\n                    // in the wrong direction, or progress is slow.\n                    // Fall back to bisection.\n                    d = m;\n                    e = d;\n                } else {\n                    d = p / q;\n                }\n            }\n            a = b;\n            fa = fb;\n\n            if (FastMath.abs(d) > tol) {\n                b += d;\n            } else if (m > 0) {\n                b += tol;\n            } else {\n                b -= tol;\n            }\n            fb = computeObjectiveValue(b);\n            if ((fb > 0 && fc > 0) ||\n                (fb <= 0 && fc <= 0)) {\n                c = a;\n                fc = fa;\n                d = b - a;\n                e = d;\n            }\n        }\n    }",
          "14": "    private double brent(double lo, double hi,\n                         double fLo, double fHi) {\n        double a = lo;\n        double fa = fLo;\n        double b = hi;\n        double fb = fHi;\n        double c = a;\n        double fc = fa;\n        double d = b - a;\n        double e = d;\n\n        final double t = getAbsoluteAccuracy();\n        final double eps = getRelativeAccuracy();\n\n        while (true) {\n            if (FastMath.abs(fc) < FastMath.abs(fb)) {\n                a = b;\n                b = c;\n                c = a;\n                fa = fb;\n                fb = fc;\n                fc = fa;\n            }\n\n            final double tol = 2 * eps * FastMath.abs(b) + t;\n            final double m = 0.5 * (c - b);\n\n            if (FastMath.abs(m) <= tol ||\n                Precision.equals(fb, 0))  {\n                return b;\n            }\n            if (FastMath.abs(e) < tol ||\n                FastMath.abs(fa) <= FastMath.abs(fb)) {\n                // Force bisection.\n                d = m;\n                e = d;\n            } else {\n                double s = fb / fa;\n                double p;\n                double q;\n                // The equality test (a == c) is intentional,\n                // it is part of the original Brent's method and\n                // it should NOT be replaced by proximity test.\n                if (a == c) {\n                    // Linear interpolation.\n                    p = 2 * m * s;\n                    q = 1 - s;\n                } else {\n                    // Inverse quadratic interpolation.\n                    q = fa / fc;\n                    final double r = fb / fc;\n                    p = s * (2 * m * q * (q - r) - (b - a) * (r - 1));\n                    q = (q - 1) * (r - 1) * (s - 1);\n                }\n                if (p > 0) {\nq = (((q - 1) * (r - 1)) * (s - 1));\n                    q = +q;                } else {\n                    p = -p;\n                }\n                s = e;\n                e = d;\n                if (p >= 1.5 * m * q - FastMath.abs(tol * q) ||\n                    p >= FastMath.abs(0.5 * s * q)) {\n                    // Inverse quadratic interpolation gives a value\n                    // in the wrong direction, or progress is slow.\n                    // Fall back to bisection.\n                    d = m;\n                    e = d;\n                } else {\n                    d = p / q;\n                }\n            }\n            a = b;\n            fa = fb;\n\n            if (FastMath.abs(d) > tol) {\n                b += d;\n            } else if (m > 0) {\n                b += tol;\n            } else {\n                b -= tol;\n            }\n            fb = computeObjectiveValue(b);\n            if ((fb > 0 && fc > 0) ||\n                (fb <= 0 && fc <= 0)) {\n                c = a;\n                fc = fa;\n                d = b - a;\n                e = d;\n            }\n        }\n    }",
          "15": "    private double brent(double lo, double hi,\n                         double fLo, double fHi) {\n        double a = lo;\n        double fa = fLo;\n        double b = hi;\n        double fb = fHi;\n        double c = a;\n        double fc = fa;\n        double d = b - a;\n        double e = d;\n\n        final double t = getAbsoluteAccuracy();\n        final double eps = getRelativeAccuracy();\n\n        while (true) {\n            if (FastMath.abs(fc) < FastMath.abs(fb)) {\n                a = b;\n                b = c;\n                c = a;\n                fa = fb;\n                fb = fc;\n                fc = fa;\n            }\n\n            final double tol = 2 * eps * FastMath.abs(b) + t;\n            final double m = 0.5 * (c - b);\n\n            if (FastMath.abs(m) <= tol ||\n                Precision.equals(fb, 0))  {\n                return b;\n            }\n            if (FastMath.abs(e) < tol ||\n                FastMath.abs(fa) <= FastMath.abs(fb)) {\n                // Force bisection.\n                d = m;\n                e = d;\n            } else {\n                double s = fb / fa;\n                double p;\n                double q;\n                // The equality test (a == c) is intentional,\n                // it is part of the original Brent's method and\n                // it should NOT be replaced by proximity test.\n                if (a == c) {\n                    // Linear interpolation.\n                    p = 2 * m * s;\n                    q = 1 - s;\n                } else {\n                    // Inverse quadratic interpolation.\n                    q = fa / fc;\n                    final double r = fb / fc;\n                    p = s * (2 * m * q * (q - r) - (b - a) * (r - 1));\n                    q = (q - 1) * (r - 1) * (s - 1);\n                }\n                if (p > 0) {\np = (s * ((((2 * m) * q) * (q - r)) - ((b - a) * (r - 1))));\n                    q = +q;                } else {\n                    p = -p;\n                }\n                s = e;\n                e = d;\n                if (p >= 1.5 * m * q - FastMath.abs(tol * q) ||\n                    p >= FastMath.abs(0.5 * s * q)) {\n                    // Inverse quadratic interpolation gives a value\n                    // in the wrong direction, or progress is slow.\n                    // Fall back to bisection.\n                    d = m;\n                    e = d;\n                } else {\n                    d = p / q;\n                }\n            }\n            a = b;\n            fa = fb;\n\n            if (FastMath.abs(d) > tol) {\n                b += d;\n            } else if (m > 0) {\n                b += tol;\n            } else {\n                b -= tol;\n            }\n            fb = computeObjectiveValue(b);\n            if ((fb > 0 && fc > 0) ||\n                (fb <= 0 && fc <= 0)) {\n                c = a;\n                fc = fa;\n                d = b - a;\n                e = d;\n            }\n        }\n    }",
          "16": "    private double brent(double lo, double hi,\n                         double fLo, double fHi) {\n        double a = lo;\n        double fa = fLo;\n        double b = hi;\n        double fb = fHi;\n        double c = a;\n        double fc = fa;\n        double d = b - a;\n        double e = d;\n\n        final double t = getAbsoluteAccuracy();\n        final double eps = getRelativeAccuracy();\n\n        while (true) {\n            if (FastMath.abs(fc) < FastMath.abs(fb)) {\n                a = b;\n                b = c;\n                c = a;\n                fa = fb;\n                fb = fc;\n                fc = fa;\n            }\n\n            final double tol = 2 * eps * FastMath.abs(b) + t;\n            final double m = 0.5 * (c - b);\n\n            if (FastMath.abs(m) <= tol ||\n                Precision.equals(fb, 0))  {\n                return b;\n            }\n            if (FastMath.abs(e) < tol ||\n                FastMath.abs(fa) <= FastMath.abs(fb)) {\n                // Force bisection.\n                d = m;\n                e = d;\n            } else {\n                double s = fb / fa;\n                double p;\n                double q;\n                // The equality test (a == c) is intentional,\n                // it is part of the original Brent's method and\n                // it should NOT be replaced by proximity test.\n                if (a == c) {\n                    // Linear interpolation.\n                    p = 2 * m * s;\n                    q = 1 - s;\n                } else {\n                    // Inverse quadratic interpolation.\n                    q = fa / fc;\n                    final double r = fb / fc;\n                    p = s * (2 * m * q * (q - r) - (b - a) * (r - 1));\n                    q = (q - 1) * (r - 1) * (s - 1);\n                }\n                if (p > 0) {\nq = d;\n                } else {\n                    p = -p;\n                }\n                s = e;\n                e = d;\n                if (p >= 1.5 * m * q - FastMath.abs(tol * q) ||\n                    p >= FastMath.abs(0.5 * s * q)) {\n                    // Inverse quadratic interpolation gives a value\n                    // in the wrong direction, or progress is slow.\n                    // Fall back to bisection.\n                    d = m;\n                    e = d;\n                } else {\n                    d = p / q;\n                }\n            }\n            a = b;\n            fa = fb;\n\n            if (FastMath.abs(d) > tol) {\n                b += d;\n            } else if (m > 0) {\n                b += tol;\n            } else {\n                b -= tol;\n            }\n            fb = computeObjectiveValue(b);\n            if ((fb > 0 && fc > 0) ||\n                (fb <= 0 && fc <= 0)) {\n                c = a;\n                fc = fa;\n                d = b - a;\n                e = d;\n            }\n        }\n    }",
          "17": "    private double brent(double lo, double hi,\n                         double fLo, double fHi) {\n        double a = lo;\n        double fa = fLo;\n        double b = hi;\n        double fb = fHi;\n        double c = a;\n        double fc = fa;\n        double d = b - a;\n        double e = d;\n\n        final double t = getAbsoluteAccuracy();\n        final double eps = getRelativeAccuracy();\n\n        while (true) {\n            if (FastMath.abs(fc) < FastMath.abs(fb)) {\n                a = b;\n                b = c;\n                c = a;\n                fa = fb;\n                fb = fc;\n                fc = fa;\n            }\n\n            final double tol = 2 * eps * FastMath.abs(b) + t;\n            final double m = 0.5 * (c - b);\n\n            if (FastMath.abs(m) <= tol ||\n                Precision.equals(fb, 0))  {\n                return b;\n            }\n            if (FastMath.abs(e) < tol ||\n                FastMath.abs(fa) <= FastMath.abs(fb)) {\n                // Force bisection.\n                d = m;\n                e = d;\n            } else {\n                double s = fb / fa;\n                double p;\n                double q;\n                // The equality test (a == c) is intentional,\n                // it is part of the original Brent's method and\n                // it should NOT be replaced by proximity test.\n                if (a == c) {\n                    // Linear interpolation.\n                    p = 2 * m * s;\n                    q = 1 - s;\n                } else {\n                    // Inverse quadratic interpolation.\n                    q = fa / fc;\n                    final double r = fb / fc;\n                    p = s * (2 * m * q * (q - r) - (b - a) * (r - 1));\n                    q = (q - 1) * (r - 1) * (s - 1);\n                }\n                if (p > 0) {\ns = e;\n                    q = +q;                } else {\n                    p = -p;\n                }\n                s = e;\n                e = d;\n                if (p >= 1.5 * m * q - FastMath.abs(tol * q) ||\n                    p >= FastMath.abs(0.5 * s * q)) {\n                    // Inverse quadratic interpolation gives a value\n                    // in the wrong direction, or progress is slow.\n                    // Fall back to bisection.\n                    d = m;\n                    e = d;\n                } else {\n                    d = p / q;\n                }\n            }\n            a = b;\n            fa = fb;\n\n            if (FastMath.abs(d) > tol) {\n                b += d;\n            } else if (m > 0) {\n                b += tol;\n            } else {\n                b -= tol;\n            }\n            fb = computeObjectiveValue(b);\n            if ((fb > 0 && fc > 0) ||\n                (fb <= 0 && fc <= 0)) {\n                c = a;\n                fc = fa;\n                d = b - a;\n                e = d;\n            }\n        }\n    }",
          "18": "    private double brent(double lo, double hi,\n                         double fLo, double fHi) {\n        double a = lo;\n        double fa = fLo;\n        double b = hi;\n        double fb = fHi;\n        double c = a;\n        double fc = fa;\n        double d = b - a;\n        double e = d;\n\n        final double t = getAbsoluteAccuracy();\n        final double eps = getRelativeAccuracy();\n\n        while (true) {\n            if (FastMath.abs(fc) < FastMath.abs(fb)) {\n                a = b;\n                b = c;\n                c = a;\n                fa = fb;\n                fb = fc;\n                fc = fa;\n            }\n\n            final double tol = 2 * eps * FastMath.abs(b) + t;\n            final double m = 0.5 * (c - b);\n\n            if (FastMath.abs(m) <= tol ||\n                Precision.equals(fb, 0))  {\n                return b;\n            }\n            if (FastMath.abs(e) < tol ||\n                FastMath.abs(fa) <= FastMath.abs(fb)) {\n                // Force bisection.\n                d = m;\n                e = d;\n            } else {\n                double s = fb / fa;\n                double p;\n                double q;\n                // The equality test (a == c) is intentional,\n                // it is part of the original Brent's method and\n                // it should NOT be replaced by proximity test.\n                if (a == c) {\n                    // Linear interpolation.\n                    p = 2 * m * s;\n                    q = 1 - s;\n                } else {\n                    // Inverse quadratic interpolation.\n                    q = fa / fc;\n                    final double r = fb / fc;\n                    p = s * (2 * m * q * (q - r) - (b - a) * (r - 1));\n                    q = (q - 1) * (r - 1) * (s - 1);\n                }\n                if (p > 0) {\nq = s;\n                } else {\n                    p = -p;\n                }\n                s = e;\n                e = d;\n                if (p >= 1.5 * m * q - FastMath.abs(tol * q) ||\n                    p >= FastMath.abs(0.5 * s * q)) {\n                    // Inverse quadratic interpolation gives a value\n                    // in the wrong direction, or progress is slow.\n                    // Fall back to bisection.\n                    d = m;\n                    e = d;\n                } else {\n                    d = p / q;\n                }\n            }\n            a = b;\n            fa = fb;\n\n            if (FastMath.abs(d) > tol) {\n                b += d;\n            } else if (m > 0) {\n                b += tol;\n            } else {\n                b -= tol;\n            }\n            fb = computeObjectiveValue(b);\n            if ((fb > 0 && fc > 0) ||\n                (fb <= 0 && fc <= 0)) {\n                c = a;\n                fc = fa;\n                d = b - a;\n                e = d;\n            }\n        }\n    }",
          "19": "    private double brent(double lo, double hi,\n                         double fLo, double fHi) {\n        double a = lo;\n        double fa = fLo;\n        double b = hi;\n        double fb = fHi;\n        double c = a;\n        double fc = fa;\n        double d = b - a;\n        double e = d;\n\n        final double t = getAbsoluteAccuracy();\n        final double eps = getRelativeAccuracy();\n\n        while (true) {\n            if (FastMath.abs(fc) < FastMath.abs(fb)) {\n                a = b;\n                b = c;\n                c = a;\n                fa = fb;\n                fb = fc;\n                fc = fa;\n            }\n\n            final double tol = 2 * eps * FastMath.abs(b) + t;\n            final double m = 0.5 * (c - b);\n\n            if (FastMath.abs(m) <= tol ||\n                Precision.equals(fb, 0))  {\n                return b;\n            }\n            if (FastMath.abs(e) < tol ||\n                FastMath.abs(fa) <= FastMath.abs(fb)) {\n                // Force bisection.\n                d = m;\n                e = d;\n            } else {\n                double s = fb / fa;\n                double p;\n                double q;\n                // The equality test (a == c) is intentional,\n                // it is part of the original Brent's method and\n                // it should NOT be replaced by proximity test.\n                if (a == c) {\n                    // Linear interpolation.\n                    p = 2 * m * s;\n                    q = 1 - s;\n                } else {\n                    // Inverse quadratic interpolation.\n                    q = fa / fc;\n                    final double r = fb / fc;\n                    p = s * (2 * m * q * (q - r) - (b - a) * (r - 1));\n                    q = (q - 1) * (r - 1) * (s - 1);\n                }\n                if (p > 0) {\nif((p > 0)){\n                    q = +q;                } else {\n                    p = -p;\n}\n                }\n                s = e;\n                e = d;\n                if (p >= 1.5 * m * q - FastMath.abs(tol * q) ||\n                    p >= FastMath.abs(0.5 * s * q)) {\n                    // Inverse quadratic interpolation gives a value\n                    // in the wrong direction, or progress is slow.\n                    // Fall back to bisection.\n                    d = m;\n                    e = d;\n                } else {\n                    d = p / q;\n                }\n            }\n            a = b;\n            fa = fb;\n\n            if (FastMath.abs(d) > tol) {\n                b += d;\n            } else if (m > 0) {\n                b += tol;\n            } else {\n                b -= tol;\n            }\n            fb = computeObjectiveValue(b);\n            if ((fb > 0 && fc > 0) ||\n                (fb <= 0 && fc <= 0)) {\n                c = a;\n                fc = fa;\n                d = b - a;\n                e = d;\n            }\n        }\n    }",
          "20": "    private double brent(double lo, double hi,\n                         double fLo, double fHi) {\n        double a = lo;\n        double fa = fLo;\n        double b = hi;\n        double fb = fHi;\n        double c = a;\n        double fc = fa;\n        double d = b - a;\n        double e = d;\n\n        final double t = getAbsoluteAccuracy();\n        final double eps = getRelativeAccuracy();\n\n        while (true) {\n            if (FastMath.abs(fc) < FastMath.abs(fb)) {\n                a = b;\n                b = c;\n                c = a;\n                fa = fb;\n                fb = fc;\n                fc = fa;\n            }\n\n            final double tol = 2 * eps * FastMath.abs(b) + t;\n            final double m = 0.5 * (c - b);\n\n            if (FastMath.abs(m) <= tol ||\n                Precision.equals(fb, 0))  {\n                return b;\n            }\n            if (FastMath.abs(e) < tol ||\n                FastMath.abs(fa) <= FastMath.abs(fb)) {\n                // Force bisection.\n                d = m;\n                e = d;\n            } else {\n                double s = fb / fa;\n                double p;\n                double q;\n                // The equality test (a == c) is intentional,\n                // it is part of the original Brent's method and\n                // it should NOT be replaced by proximity test.\n                if (a == c) {\n                    // Linear interpolation.\n                    p = 2 * m * s;\n                    q = 1 - s;\n                } else {\n                    // Inverse quadratic interpolation.\n                    q = fa / fc;\n                    final double r = fb / fc;\n                    p = s * (2 * m * q * (q - r) - (b - a) * (r - 1));\n                    q = (q - 1) * (r - 1) * (s - 1);\n                }\n                if (p > 0) {\ne = d;\n                    q = +q;                } else {\n                    p = -p;\n                }\n                s = e;\n                e = d;\n                if (p >= 1.5 * m * q - FastMath.abs(tol * q) ||\n                    p >= FastMath.abs(0.5 * s * q)) {\n                    // Inverse quadratic interpolation gives a value\n                    // in the wrong direction, or progress is slow.\n                    // Fall back to bisection.\n                    d = m;\n                    e = d;\n                } else {\n                    d = p / q;\n                }\n            }\n            a = b;\n            fa = fb;\n\n            if (FastMath.abs(d) > tol) {\n                b += d;\n            } else if (m > 0) {\n                b += tol;\n            } else {\n                b -= tol;\n            }\n            fb = computeObjectiveValue(b);\n            if ((fb > 0 && fc > 0) ||\n                (fb <= 0 && fc <= 0)) {\n                c = a;\n                fc = fa;\n                d = b - a;\n                e = d;\n            }\n        }\n    }",
          "21": "    private double brent(double lo, double hi,\n                         double fLo, double fHi) {\n        double a = lo;\n        double fa = fLo;\n        double b = hi;\n        double fb = fHi;\n        double c = a;\n        double fc = fa;\n        double d = b - a;\n        double e = d;\n\n        final double t = getAbsoluteAccuracy();\n        final double eps = getRelativeAccuracy();\n\n        while (true) {\n            if (FastMath.abs(fc) < FastMath.abs(fb)) {\n                a = b;\n                b = c;\n                c = a;\n                fa = fb;\n                fb = fc;\n                fc = fa;\n            }\n\n            final double tol = 2 * eps * FastMath.abs(b) + t;\n            final double m = 0.5 * (c - b);\n\n            if (FastMath.abs(m) <= tol ||\n                Precision.equals(fb, 0))  {\n                return b;\n            }\n            if (FastMath.abs(e) < tol ||\n                FastMath.abs(fa) <= FastMath.abs(fb)) {\n                // Force bisection.\n                d = m;\n                e = d;\n            } else {\n                double s = fb / fa;\n                double p;\n                double q;\n                // The equality test (a == c) is intentional,\n                // it is part of the original Brent's method and\n                // it should NOT be replaced by proximity test.\n                if (a == c) {\n                    // Linear interpolation.\n                    p = 2 * m * s;\n                    q = 1 - s;\n                } else {\n                    // Inverse quadratic interpolation.\n                    q = fa / fc;\n                    final double r = fb / fc;\n                    p = s * (2 * m * q * (q - r) - (b - a) * (r - 1));\n                    q = (q - 1) * (r - 1) * (s - 1);\n                }\n                if (p > 0) {\nq = a;\n                } else {\n                    p = -p;\n                }\n                s = e;\n                e = d;\n                if (p >= 1.5 * m * q - FastMath.abs(tol * q) ||\n                    p >= FastMath.abs(0.5 * s * q)) {\n                    // Inverse quadratic interpolation gives a value\n                    // in the wrong direction, or progress is slow.\n                    // Fall back to bisection.\n                    d = m;\n                    e = d;\n                } else {\n                    d = p / q;\n                }\n            }\n            a = b;\n            fa = fb;\n\n            if (FastMath.abs(d) > tol) {\n                b += d;\n            } else if (m > 0) {\n                b += tol;\n            } else {\n                b -= tol;\n            }\n            fb = computeObjectiveValue(b);\n            if ((fb > 0 && fc > 0) ||\n                (fb <= 0 && fc <= 0)) {\n                c = a;\n                fc = fa;\n                d = b - a;\n                e = d;\n            }\n        }\n    }",
          "22": "    private double brent(double lo, double hi,\n                         double fLo, double fHi) {\n        double a = lo;\n        double fa = fLo;\n        double b = hi;\n        double fb = fHi;\n        double c = a;\n        double fc = fa;\n        double d = b - a;\n        double e = d;\n\n        final double t = getAbsoluteAccuracy();\n        final double eps = getRelativeAccuracy();\n\n        while (true) {\n            if (FastMath.abs(fc) < FastMath.abs(fb)) {\n                a = b;\n                b = c;\n                c = a;\n                fa = fb;\n                fb = fc;\n                fc = fa;\n            }\n\n            final double tol = 2 * eps * FastMath.abs(b) + t;\n            final double m = 0.5 * (c - b);\n\n            if (FastMath.abs(m) <= tol ||\n                Precision.equals(fb, 0))  {\n                return b;\n            }\n            if (FastMath.abs(e) < tol ||\n                FastMath.abs(fa) <= FastMath.abs(fb)) {\n                // Force bisection.\n                d = m;\n                e = d;\n            } else {\n                double s = fb / fa;\n                double p;\n                double q;\n                // The equality test (a == c) is intentional,\n                // it is part of the original Brent's method and\n                // it should NOT be replaced by proximity test.\n                if (a == c) {\n                    // Linear interpolation.\n                    p = 2 * m * s;\n                    q = 1 - s;\n                } else {\n                    // Inverse quadratic interpolation.\n                    q = fa / fc;\n                    final double r = fb / fc;\n                    p = s * (2 * m * q * (q - r) - (b - a) * (r - 1));\n                    q = (q - 1) * (r - 1) * (s - 1);\n                }\n                if (p > 0) {\nq = e;\n                } else {\n                    p = -p;\n                }\n                s = e;\n                e = d;\n                if (p >= 1.5 * m * q - FastMath.abs(tol * q) ||\n                    p >= FastMath.abs(0.5 * s * q)) {\n                    // Inverse quadratic interpolation gives a value\n                    // in the wrong direction, or progress is slow.\n                    // Fall back to bisection.\n                    d = m;\n                    e = d;\n                } else {\n                    d = p / q;\n                }\n            }\n            a = b;\n            fa = fb;\n\n            if (FastMath.abs(d) > tol) {\n                b += d;\n            } else if (m > 0) {\n                b += tol;\n            } else {\n                b -= tol;\n            }\n            fb = computeObjectiveValue(b);\n            if ((fb > 0 && fc > 0) ||\n                (fb <= 0 && fc <= 0)) {\n                c = a;\n                fc = fa;\n                d = b - a;\n                e = d;\n            }\n        }\n    }",
          "23": "    private double brent(double lo, double hi,\n                         double fLo, double fHi) {\n        double a = lo;\n        double fa = fLo;\n        double b = hi;\n        double fb = fHi;\n        double c = a;\n        double fc = fa;\n        double d = b - a;\n        double e = d;\n\n        final double t = getAbsoluteAccuracy();\n        final double eps = getRelativeAccuracy();\n\n        while (true) {\n            if (FastMath.abs(fc) < FastMath.abs(fb)) {\n                a = b;\n                b = c;\n                c = a;\n                fa = fb;\n                fb = fc;\n                fc = fa;\n            }\n\n            final double tol = 2 * eps * FastMath.abs(b) + t;\n            final double m = 0.5 * (c - b);\n\n            if (FastMath.abs(m) <= tol ||\n                Precision.equals(fb, 0))  {\n                return b;\n            }\n            if (FastMath.abs(e) < tol ||\n                FastMath.abs(fa) <= FastMath.abs(fb)) {\n                // Force bisection.\n                d = m;\n                e = d;\n            } else {\n                double s = fb / fa;\n                double p;\n                double q;\n                // The equality test (a == c) is intentional,\n                // it is part of the original Brent's method and\n                // it should NOT be replaced by proximity test.\n                if (a == c) {\n                    // Linear interpolation.\n                    p = 2 * m * s;\n                    q = 1 - s;\n                } else {\n                    // Inverse quadratic interpolation.\n                    q = fa / fc;\n                    final double r = fb / fc;\n                    p = s * (2 * m * q * (q - r) - (b - a) * (r - 1));\n                    q = (q - 1) * (r - 1) * (s - 1);\n                }\n                if (p > 0) {\nreturn;\n                    q = +q;                } else {\n                    p = -p;\n                }\n                s = e;\n                e = d;\n                if (p >= 1.5 * m * q - FastMath.abs(tol * q) ||\n                    p >= FastMath.abs(0.5 * s * q)) {\n                    // Inverse quadratic interpolation gives a value\n                    // in the wrong direction, or progress is slow.\n                    // Fall back to bisection.\n                    d = m;\n                    e = d;\n                } else {\n                    d = p / q;\n                }\n            }\n            a = b;\n            fa = fb;\n\n            if (FastMath.abs(d) > tol) {\n                b += d;\n            } else if (m > 0) {\n                b += tol;\n            } else {\n                b -= tol;\n            }\n            fb = computeObjectiveValue(b);\n            if ((fb > 0 && fc > 0) ||\n                (fb <= 0 && fc <= 0)) {\n                c = a;\n                fc = fa;\n                d = b - a;\n                e = d;\n            }\n        }\n    }",
          "24": "    private double brent(double lo, double hi,\n                         double fLo, double fHi) {\n        double a = lo;\n        double fa = fLo;\n        double b = hi;\n        double fb = fHi;\n        double c = a;\n        double fc = fa;\n        double d = b - a;\n        double e = d;\n\n        final double t = getAbsoluteAccuracy();\n        final double eps = getRelativeAccuracy();\n\n        while (true) {\n            if (FastMath.abs(fc) < FastMath.abs(fb)) {\n                a = b;\n                b = c;\n                c = a;\n                fa = fb;\n                fb = fc;\n                fc = fa;\n            }\n\n            final double tol = 2 * eps * FastMath.abs(b) + t;\n            final double m = 0.5 * (c - b);\n\n            if (FastMath.abs(m) <= tol ||\n                Precision.equals(fb, 0))  {\n                return b;\n            }\n            if (FastMath.abs(e) < tol ||\n                FastMath.abs(fa) <= FastMath.abs(fb)) {\n                // Force bisection.\n                d = m;\n                e = d;\n            } else {\n                double s = fb / fa;\n                double p;\n                double q;\n                // The equality test (a == c) is intentional,\n                // it is part of the original Brent's method and\n                // it should NOT be replaced by proximity test.\n                if (a == c) {\n                    // Linear interpolation.\n                    p = 2 * m * s;\n                    q = 1 - s;\n                } else {\n                    // Inverse quadratic interpolation.\n                    q = fa / fc;\n                    final double r = fb / fc;\n                    p = s * (2 * m * q * (q - r) - (b - a) * (r - 1));\n                    q = (q - 1) * (r - 1) * (s - 1);\n                }\n                if (p > 0) {\nq = -q;\n                } else {\n                    p = -p;\n                }\n                s = e;\n                e = d;\n                if (p >= 1.5 * m * q - FastMath.abs(tol * q) ||\n                    p >= FastMath.abs(0.5 * s * q)) {\n                    // Inverse quadratic interpolation gives a value\n                    // in the wrong direction, or progress is slow.\n                    // Fall back to bisection.\n                    d = m;\n                    e = d;\n                } else {\n                    d = p / q;\n                }\n            }\n            a = b;\n            fa = fb;\n\n            if (FastMath.abs(d) > tol) {\n                b += d;\n            } else if (m > 0) {\n                b += tol;\n            } else {\n                b -= tol;\n            }\n            fb = computeObjectiveValue(b);\n            if ((fb > 0 && fc > 0) ||\n                (fb <= 0 && fc <= 0)) {\n                c = a;\n                fc = fa;\n                d = b - a;\n                e = d;\n            }\n        }\n    }",
          "25": "    private double brent(double lo, double hi,\n                         double fLo, double fHi) {\n        double a = lo;\n        double fa = fLo;\n        double b = hi;\n        double fb = fHi;\n        double c = a;\n        double fc = fa;\n        double d = b - a;\n        double e = d;\n\n        final double t = getAbsoluteAccuracy();\n        final double eps = getRelativeAccuracy();\n\n        while (true) {\n            if (FastMath.abs(fc) < FastMath.abs(fb)) {\n                a = b;\n                b = c;\n                c = a;\n                fa = fb;\n                fb = fc;\n                fc = fa;\n            }\n\n            final double tol = 2 * eps * FastMath.abs(b) + t;\n            final double m = 0.5 * (c - b);\n\n            if (FastMath.abs(m) <= tol ||\n                Precision.equals(fb, 0))  {\n                return b;\n            }\n            if (FastMath.abs(e) < tol ||\n                FastMath.abs(fa) <= FastMath.abs(fb)) {\n                // Force bisection.\n                d = m;\n                e = d;\n            } else {\n                double s = fb / fa;\n                double p;\n                double q;\n                // The equality test (a == c) is intentional,\n                // it is part of the original Brent's method and\n                // it should NOT be replaced by proximity test.\n                if (a == c) {\n                    // Linear interpolation.\n                    p = 2 * m * s;\n                    q = 1 - s;\n                } else {\n                    // Inverse quadratic interpolation.\n                    q = fa / fc;\n                    final double r = fb / fc;\n                    p = s * (2 * m * q * (q - r) - (b - a) * (r - 1));\n                    q = (q - 1) * (r - 1) * (s - 1);\n                }\n                if (p > 0) {\np = q;\n                } else {\n                    p = -p;\n                }\n                s = e;\n                e = d;\n                if (p >= 1.5 * m * q - FastMath.abs(tol * q) ||\n                    p >= FastMath.abs(0.5 * s * q)) {\n                    // Inverse quadratic interpolation gives a value\n                    // in the wrong direction, or progress is slow.\n                    // Fall back to bisection.\n                    d = m;\n                    e = d;\n                } else {\n                    d = p / q;\n                }\n            }\n            a = b;\n            fa = fb;\n\n            if (FastMath.abs(d) > tol) {\n                b += d;\n            } else if (m > 0) {\n                b += tol;\n            } else {\n                b -= tol;\n            }\n            fb = computeObjectiveValue(b);\n            if ((fb > 0 && fc > 0) ||\n                (fb <= 0 && fc <= 0)) {\n                c = a;\n                fc = fa;\n                d = b - a;\n                e = d;\n            }\n        }\n    }",
          "26": "    private double brent(double lo, double hi,\n                         double fLo, double fHi) {\n        double a = lo;\n        double fa = fLo;\n        double b = hi;\n        double fb = fHi;\n        double c = a;\n        double fc = fa;\n        double d = b - a;\n        double e = d;\n\n        final double t = getAbsoluteAccuracy();\n        final double eps = getRelativeAccuracy();\n\n        while (true) {\n            if (FastMath.abs(fc) < FastMath.abs(fb)) {\n                a = b;\n                b = c;\n                c = a;\n                fa = fb;\n                fb = fc;\n                fc = fa;\n            }\n\n            final double tol = 2 * eps * FastMath.abs(b) + t;\n            final double m = 0.5 * (c - b);\n\n            if (FastMath.abs(m) <= tol ||\n                Precision.equals(fb, 0))  {\n                return b;\n            }\n            if (FastMath.abs(e) < tol ||\n                FastMath.abs(fa) <= FastMath.abs(fb)) {\n                // Force bisection.\n                d = m;\n                e = d;\n            } else {\n                double s = fb / fa;\n                double p;\n                double q;\n                // The equality test (a == c) is intentional,\n                // it is part of the original Brent's method and\n                // it should NOT be replaced by proximity test.\n                if (a == c) {\n                    // Linear interpolation.\n                    p = 2 * m * s;\n                    q = 1 - s;\n                } else {\n                    // Inverse quadratic interpolation.\n                    q = fa / fc;\n                    final double r = fb / fc;\n                    p = s * (2 * m * q * (q - r) - (b - a) * (r - 1));\n                    q = (q - 1) * (r - 1) * (s - 1);\n                }\n                if (p > 0) {\np = +q;\n                } else {\n                    p = -p;\n                }\n                s = e;\n                e = d;\n                if (p >= 1.5 * m * q - FastMath.abs(tol * q) ||\n                    p >= FastMath.abs(0.5 * s * q)) {\n                    // Inverse quadratic interpolation gives a value\n                    // in the wrong direction, or progress is slow.\n                    // Fall back to bisection.\n                    d = m;\n                    e = d;\n                } else {\n                    d = p / q;\n                }\n            }\n            a = b;\n            fa = fb;\n\n            if (FastMath.abs(d) > tol) {\n                b += d;\n            } else if (m > 0) {\n                b += tol;\n            } else {\n                b -= tol;\n            }\n            fb = computeObjectiveValue(b);\n            if ((fb > 0 && fc > 0) ||\n                (fb <= 0 && fc <= 0)) {\n                c = a;\n                fc = fa;\n                d = b - a;\n                e = d;\n            }\n        }\n    }",
          "27": "    private double brent(double lo, double hi,\n                         double fLo, double fHi) {\n        double a = lo;\n        double fa = fLo;\n        double b = hi;\n        double fb = fHi;\n        double c = a;\n        double fc = fa;\n        double d = b - a;\n        double e = d;\n\n        final double t = getAbsoluteAccuracy();\n        final double eps = getRelativeAccuracy();\n\n        while (true) {\n            if (FastMath.abs(fc) < FastMath.abs(fb)) {\n                a = b;\n                b = c;\n                c = a;\n                fa = fb;\n                fb = fc;\n                fc = fa;\n            }\n\n            final double tol = 2 * eps * FastMath.abs(b) + t;\n            final double m = 0.5 * (c - b);\n\n            if (FastMath.abs(m) <= tol ||\n                Precision.equals(fb, 0))  {\n                return b;\n            }\n            if (FastMath.abs(e) < tol ||\n                FastMath.abs(fa) <= FastMath.abs(fb)) {\n                // Force bisection.\n                d = m;\n                e = d;\n            } else {\n                double s = fb / fa;\n                double p;\n                double q;\n                // The equality test (a == c) is intentional,\n                // it is part of the original Brent's method and\n                // it should NOT be replaced by proximity test.\n                if (a == c) {\n                    // Linear interpolation.\n                    p = 2 * m * s;\n                    q = 1 - s;\n                } else {\n                    // Inverse quadratic interpolation.\n                    q = fa / fc;\n                    final double r = fb / fc;\n                    p = s * (2 * m * q * (q - r) - (b - a) * (r - 1));\n                    q = (q - 1) * (r - 1) * (s - 1);\n                }\n                if (p > 0) {\nreturn;\n                } else {\n                    p = -p;\n                }\n                s = e;\n                e = d;\n                if (p >= 1.5 * m * q - FastMath.abs(tol * q) ||\n                    p >= FastMath.abs(0.5 * s * q)) {\n                    // Inverse quadratic interpolation gives a value\n                    // in the wrong direction, or progress is slow.\n                    // Fall back to bisection.\n                    d = m;\n                    e = d;\n                } else {\n                    d = p / q;\n                }\n            }\n            a = b;\n            fa = fb;\n\n            if (FastMath.abs(d) > tol) {\n                b += d;\n            } else if (m > 0) {\n                b += tol;\n            } else {\n                b -= tol;\n            }\n            fb = computeObjectiveValue(b);\n            if ((fb > 0 && fc > 0) ||\n                (fb <= 0 && fc <= 0)) {\n                c = a;\n                fc = fa;\n                d = b - a;\n                e = d;\n            }\n        }\n    }",
          "28": "    private double brent(double lo, double hi,\n                         double fLo, double fHi) {\n        double a = lo;\n        double fa = fLo;\n        double b = hi;\n        double fb = fHi;\n        double c = a;\n        double fc = fa;\n        double d = b - a;\n        double e = d;\n\n        final double t = getAbsoluteAccuracy();\n        final double eps = getRelativeAccuracy();\n\n        while (true) {\n            if (FastMath.abs(fc) < FastMath.abs(fb)) {\n                a = b;\n                b = c;\n                c = a;\n                fa = fb;\n                fb = fc;\n                fc = fa;\n            }\n\n            final double tol = 2 * eps * FastMath.abs(b) + t;\n            final double m = 0.5 * (c - b);\n\n            if (FastMath.abs(m) <= tol ||\n                Precision.equals(fb, 0))  {\n                return b;\n            }\n            if (FastMath.abs(e) < tol ||\n                FastMath.abs(fa) <= FastMath.abs(fb)) {\n                // Force bisection.\n                d = m;\n                e = d;\n            } else {\n                double s = fb / fa;\n                double p;\n                double q;\n                // The equality test (a == c) is intentional,\n                // it is part of the original Brent's method and\n                // it should NOT be replaced by proximity test.\n                if (a == c) {\n                    // Linear interpolation.\n                    p = 2 * m * s;\n                    q = 1 - s;\n                } else {\n                    // Inverse quadratic interpolation.\n                    q = fa / fc;\n                    final double r = fb / fc;\n                    p = s * (2 * m * q * (q - r) - (b - a) * (r - 1));\n                    q = (q - 1) * (r - 1) * (s - 1);\n                }\n                if (p > 0) {\nbreak;\n                    q = +q;                } else {\n                    p = -p;\n                }\n                s = e;\n                e = d;\n                if (p >= 1.5 * m * q - FastMath.abs(tol * q) ||\n                    p >= FastMath.abs(0.5 * s * q)) {\n                    // Inverse quadratic interpolation gives a value\n                    // in the wrong direction, or progress is slow.\n                    // Fall back to bisection.\n                    d = m;\n                    e = d;\n                } else {\n                    d = p / q;\n                }\n            }\n            a = b;\n            fa = fb;\n\n            if (FastMath.abs(d) > tol) {\n                b += d;\n            } else if (m > 0) {\n                b += tol;\n            } else {\n                b -= tol;\n            }\n            fb = computeObjectiveValue(b);\n            if ((fb > 0 && fc > 0) ||\n                (fb <= 0 && fc <= 0)) {\n                c = a;\n                fc = fa;\n                d = b - a;\n                e = d;\n            }\n        }\n    }",
          "29": "    private double brent(double lo, double hi,\n                         double fLo, double fHi) {\n        double a = lo;\n        double fa = fLo;\n        double b = hi;\n        double fb = fHi;\n        double c = a;\n        double fc = fa;\n        double d = b - a;\n        double e = d;\n\n        final double t = getAbsoluteAccuracy();\n        final double eps = getRelativeAccuracy();\n\n        while (true) {\n            if (FastMath.abs(fc) < FastMath.abs(fb)) {\n                a = b;\n                b = c;\n                c = a;\n                fa = fb;\n                fb = fc;\n                fc = fa;\n            }\n\n            final double tol = 2 * eps * FastMath.abs(b) + t;\n            final double m = 0.5 * (c - b);\n\n            if (FastMath.abs(m) <= tol ||\n                Precision.equals(fb, 0))  {\n                return b;\n            }\n            if (FastMath.abs(e) < tol ||\n                FastMath.abs(fa) <= FastMath.abs(fb)) {\n                // Force bisection.\n                d = m;\n                e = d;\n            } else {\n                double s = fb / fa;\n                double p;\n                double q;\n                // The equality test (a == c) is intentional,\n                // it is part of the original Brent's method and\n                // it should NOT be replaced by proximity test.\n                if (a == c) {\n                    // Linear interpolation.\n                    p = 2 * m * s;\n                    q = 1 - s;\n                } else {\n                    // Inverse quadratic interpolation.\n                    q = fa / fc;\n                    final double r = fb / fc;\n                    p = s * (2 * m * q * (q - r) - (b - a) * (r - 1));\n                    q = (q - 1) * (r - 1) * (s - 1);\n                }\n                if (p > 0) {\nd = +q;\n                } else {\n                    p = -p;\n                }\n                s = e;\n                e = d;\n                if (p >= 1.5 * m * q - FastMath.abs(tol * q) ||\n                    p >= FastMath.abs(0.5 * s * q)) {\n                    // Inverse quadratic interpolation gives a value\n                    // in the wrong direction, or progress is slow.\n                    // Fall back to bisection.\n                    d = m;\n                    e = d;\n                } else {\n                    d = p / q;\n                }\n            }\n            a = b;\n            fa = fb;\n\n            if (FastMath.abs(d) > tol) {\n                b += d;\n            } else if (m > 0) {\n                b += tol;\n            } else {\n                b -= tol;\n            }\n            fb = computeObjectiveValue(b);\n            if ((fb > 0 && fc > 0) ||\n                (fb <= 0 && fc <= 0)) {\n                c = a;\n                fc = fa;\n                d = b - a;\n                e = d;\n            }\n        }\n    }",
          "30": "    private double brent(double lo, double hi,\n                         double fLo, double fHi) {\n        double a = lo;\n        double fa = fLo;\n        double b = hi;\n        double fb = fHi;\n        double c = a;\n        double fc = fa;\n        double d = b - a;\n        double e = d;\n\n        final double t = getAbsoluteAccuracy();\n        final double eps = getRelativeAccuracy();\n\n        while (true) {\n            if (FastMath.abs(fc) < FastMath.abs(fb)) {\n                a = b;\n                b = c;\n                c = a;\n                fa = fb;\n                fb = fc;\n                fc = fa;\n            }\n\n            final double tol = 2 * eps * FastMath.abs(b) + t;\n            final double m = 0.5 * (c - b);\n\n            if (FastMath.abs(m) <= tol ||\n                Precision.equals(fb, 0))  {\n                return b;\n            }\n            if (FastMath.abs(e) < tol ||\n                FastMath.abs(fa) <= FastMath.abs(fb)) {\n                // Force bisection.\n                d = m;\n                e = d;\n            } else {\n                double s = fb / fa;\n                double p;\n                double q;\n                // The equality test (a == c) is intentional,\n                // it is part of the original Brent's method and\n                // it should NOT be replaced by proximity test.\n                if (a == c) {\n                    // Linear interpolation.\n                    p = 2 * m * s;\n                    q = 1 - s;\n                } else {\n                    // Inverse quadratic interpolation.\n                    q = fa / fc;\n                    final double r = fb / fc;\n                    p = s * (2 * m * q * (q - r) - (b - a) * (r - 1));\n                    q = (q - 1) * (r - 1) * (s - 1);\n                }\n                if (p > 0) {\nq = true;\n                } else {\n                    p = -p;\n                }\n                s = e;\n                e = d;\n                if (p >= 1.5 * m * q - FastMath.abs(tol * q) ||\n                    p >= FastMath.abs(0.5 * s * q)) {\n                    // Inverse quadratic interpolation gives a value\n                    // in the wrong direction, or progress is slow.\n                    // Fall back to bisection.\n                    d = m;\n                    e = d;\n                } else {\n                    d = p / q;\n                }\n            }\n            a = b;\n            fa = fb;\n\n            if (FastMath.abs(d) > tol) {\n                b += d;\n            } else if (m > 0) {\n                b += tol;\n            } else {\n                b -= tol;\n            }\n            fb = computeObjectiveValue(b);\n            if ((fb > 0 && fc > 0) ||\n                (fb <= 0 && fc <= 0)) {\n                c = a;\n                fc = fa;\n                d = b - a;\n                e = d;\n            }\n        }\n    }",
          "31": "    private double brent(double lo, double hi,\n                         double fLo, double fHi) {\n        double a = lo;\n        double fa = fLo;\n        double b = hi;\n        double fb = fHi;\n        double c = a;\n        double fc = fa;\n        double d = b - a;\n        double e = d;\n\n        final double t = getAbsoluteAccuracy();\n        final double eps = getRelativeAccuracy();\n\n        while (true) {\n            if (FastMath.abs(fc) < FastMath.abs(fb)) {\n                a = b;\n                b = c;\n                c = a;\n                fa = fb;\n                fb = fc;\n                fc = fa;\n            }\n\n            final double tol = 2 * eps * FastMath.abs(b) + t;\n            final double m = 0.5 * (c - b);\n\n            if (FastMath.abs(m) <= tol ||\n                Precision.equals(fb, 0))  {\n                return b;\n            }\n            if (FastMath.abs(e) < tol ||\n                FastMath.abs(fa) <= FastMath.abs(fb)) {\n                // Force bisection.\n                d = m;\n                e = d;\n            } else {\n                double s = fb / fa;\n                double p;\n                double q;\n                // The equality test (a == c) is intentional,\n                // it is part of the original Brent's method and\n                // it should NOT be replaced by proximity test.\n                if (a == c) {\n                    // Linear interpolation.\n                    p = 2 * m * s;\n                    q = 1 - s;\n                } else {\n                    // Inverse quadratic interpolation.\n                    q = fa / fc;\n                    final double r = fb / fc;\n                    p = s * (2 * m * q * (q - r) - (b - a) * (r - 1));\n                    q = (q - 1) * (r - 1) * (s - 1);\n                }\n                if (p > 0) {\nq = +q;\n                } else {\n                    p = -p;\n                }\n                s = e;\n                e = d;\n                if (p >= 1.5 * m * q - FastMath.abs(tol * q) ||\n                    p >= FastMath.abs(0.5 * s * q)) {\n                    // Inverse quadratic interpolation gives a value\n                    // in the wrong direction, or progress is slow.\n                    // Fall back to bisection.\n                    d = m;\n                    e = d;\n                } else {\n                    d = p / q;\n                }\n            }\n            a = b;\n            fa = fb;\n\n            if (FastMath.abs(d) > tol) {\n                b += d;\n            } else if (m > 0) {\n                b += tol;\n            } else {\n                b -= tol;\n            }\n            fb = computeObjectiveValue(b);\n            if ((fb > 0 && fc > 0) ||\n                (fb <= 0 && fc <= 0)) {\n                c = a;\n                fc = fa;\n                d = b - a;\n                e = d;\n            }\n        }\n    }",
          "32": "    private double brent(double lo, double hi,\n                         double fLo, double fHi) {\n        double a = lo;\n        double fa = fLo;\n        double b = hi;\n        double fb = fHi;\n        double c = a;\n        double fc = fa;\n        double d = b - a;\n        double e = d;\n\n        final double t = getAbsoluteAccuracy();\n        final double eps = getRelativeAccuracy();\n\n        while (true) {\n            if (FastMath.abs(fc) < FastMath.abs(fb)) {\n                a = b;\n                b = c;\n                c = a;\n                fa = fb;\n                fb = fc;\n                fc = fa;\n            }\n\n            final double tol = 2 * eps * FastMath.abs(b) + t;\n            final double m = 0.5 * (c - b);\n\n            if (FastMath.abs(m) <= tol ||\n                Precision.equals(fb, 0))  {\n                return b;\n            }\n            if (FastMath.abs(e) < tol ||\n                FastMath.abs(fa) <= FastMath.abs(fb)) {\n                // Force bisection.\n                d = m;\n                e = d;\n            } else {\n                double s = fb / fa;\n                double p;\n                double q;\n                // The equality test (a == c) is intentional,\n                // it is part of the original Brent's method and\n                // it should NOT be replaced by proximity test.\n                if (a == c) {\n                    // Linear interpolation.\n                    p = 2 * m * s;\n                    q = 1 - s;\n                } else {\n                    // Inverse quadratic interpolation.\n                    q = fa / fc;\n                    final double r = fb / fc;\n                    p = s * (2 * m * q * (q - r) - (b - a) * (r - 1));\n                    q = (q - 1) * (r - 1) * (s - 1);\n                }\n                if (p > 0) {\ne = q;\n                } else {\n                    p = -p;\n                }\n                s = e;\n                e = d;\n                if (p >= 1.5 * m * q - FastMath.abs(tol * q) ||\n                    p >= FastMath.abs(0.5 * s * q)) {\n                    // Inverse quadratic interpolation gives a value\n                    // in the wrong direction, or progress is slow.\n                    // Fall back to bisection.\n                    d = m;\n                    e = d;\n                } else {\n                    d = p / q;\n                }\n            }\n            a = b;\n            fa = fb;\n\n            if (FastMath.abs(d) > tol) {\n                b += d;\n            } else if (m > 0) {\n                b += tol;\n            } else {\n                b -= tol;\n            }\n            fb = computeObjectiveValue(b);\n            if ((fb > 0 && fc > 0) ||\n                (fb <= 0 && fc <= 0)) {\n                c = a;\n                fc = fa;\n                d = b - a;\n                e = d;\n            }\n        }\n    }",
          "33": "    private double brent(double lo, double hi,\n                         double fLo, double fHi) {\n        double a = lo;\n        double fa = fLo;\n        double b = hi;\n        double fb = fHi;\n        double c = a;\n        double fc = fa;\n        double d = b - a;\n        double e = d;\n\n        final double t = getAbsoluteAccuracy();\n        final double eps = getRelativeAccuracy();\n\n        while (true) {\n            if (FastMath.abs(fc) < FastMath.abs(fb)) {\n                a = b;\n                b = c;\n                c = a;\n                fa = fb;\n                fb = fc;\n                fc = fa;\n            }\n\n            final double tol = 2 * eps * FastMath.abs(b) + t;\n            final double m = 0.5 * (c - b);\n\n            if (FastMath.abs(m) <= tol ||\n                Precision.equals(fb, 0))  {\n                return b;\n            }\n            if (FastMath.abs(e) < tol ||\n                FastMath.abs(fa) <= FastMath.abs(fb)) {\n                // Force bisection.\n                d = m;\n                e = d;\n            } else {\n                double s = fb / fa;\n                double p;\n                double q;\n                // The equality test (a == c) is intentional,\n                // it is part of the original Brent's method and\n                // it should NOT be replaced by proximity test.\n                if (a == c) {\n                    // Linear interpolation.\n                    p = 2 * m * s;\n                    q = 1 - s;\n                } else {\n                    // Inverse quadratic interpolation.\n                    q = fa / fc;\n                    final double r = fb / fc;\n                    p = s * (2 * m * q * (q - r) - (b - a) * (r - 1));\n                    q = (q - 1) * (r - 1) * (s - 1);\n                }\n                if (p > 0) {\ns = +q;\n                } else {\n                    p = -p;\n                }\n                s = e;\n                e = d;\n                if (p >= 1.5 * m * q - FastMath.abs(tol * q) ||\n                    p >= FastMath.abs(0.5 * s * q)) {\n                    // Inverse quadratic interpolation gives a value\n                    // in the wrong direction, or progress is slow.\n                    // Fall back to bisection.\n                    d = m;\n                    e = d;\n                } else {\n                    d = p / q;\n                }\n            }\n            a = b;\n            fa = fb;\n\n            if (FastMath.abs(d) > tol) {\n                b += d;\n            } else if (m > 0) {\n                b += tol;\n            } else {\n                b -= tol;\n            }\n            fb = computeObjectiveValue(b);\n            if ((fb > 0 && fc > 0) ||\n                (fb <= 0 && fc <= 0)) {\n                c = a;\n                fc = fa;\n                d = b - a;\n                e = d;\n            }\n        }\n    }",
          "34": "    private double brent(double lo, double hi,\n                         double fLo, double fHi) {\n        double a = lo;\n        double fa = fLo;\n        double b = hi;\n        double fb = fHi;\n        double c = a;\n        double fc = fa;\n        double d = b - a;\n        double e = d;\n\n        final double t = getAbsoluteAccuracy();\n        final double eps = getRelativeAccuracy();\n\n        while (true) {\n            if (FastMath.abs(fc) < FastMath.abs(fb)) {\n                a = b;\n                b = c;\n                c = a;\n                fa = fb;\n                fb = fc;\n                fc = fa;\n            }\n\n            final double tol = 2 * eps * FastMath.abs(b) + t;\n            final double m = 0.5 * (c - b);\n\n            if (FastMath.abs(m) <= tol ||\n                Precision.equals(fb, 0))  {\n                return b;\n            }\n            if (FastMath.abs(e) < tol ||\n                FastMath.abs(fa) <= FastMath.abs(fb)) {\n                // Force bisection.\n                d = m;\n                e = d;\n            } else {\n                double s = fb / fa;\n                double p;\n                double q;\n                // The equality test (a == c) is intentional,\n                // it is part of the original Brent's method and\n                // it should NOT be replaced by proximity test.\n                if (a == c) {\n                    // Linear interpolation.\n                    p = 2 * m * s;\n                    q = 1 - s;\n                } else {\n                    // Inverse quadratic interpolation.\n                    q = fa / fc;\n                    final double r = fb / fc;\n                    p = s * (2 * m * q * (q - r) - (b - a) * (r - 1));\n                    q = (q - 1) * (r - 1) * (s - 1);\n                }\n                if (p > 0) {\nq = false;\n                } else {\n                    p = -p;\n                }\n                s = e;\n                e = d;\n                if (p >= 1.5 * m * q - FastMath.abs(tol * q) ||\n                    p >= FastMath.abs(0.5 * s * q)) {\n                    // Inverse quadratic interpolation gives a value\n                    // in the wrong direction, or progress is slow.\n                    // Fall back to bisection.\n                    d = m;\n                    e = d;\n                } else {\n                    d = p / q;\n                }\n            }\n            a = b;\n            fa = fb;\n\n            if (FastMath.abs(d) > tol) {\n                b += d;\n            } else if (m > 0) {\n                b += tol;\n            } else {\n                b -= tol;\n            }\n            fb = computeObjectiveValue(b);\n            if ((fb > 0 && fc > 0) ||\n                (fb <= 0 && fc <= 0)) {\n                c = a;\n                fc = fa;\n                d = b - a;\n                e = d;\n            }\n        }\n    }",
          "35": "    private double brent(double lo, double hi,\n                         double fLo, double fHi) {\n        double a = lo;\n        double fa = fLo;\n        double b = hi;\n        double fb = fHi;\n        double c = a;\n        double fc = fa;\n        double d = b - a;\n        double e = d;\n\n        final double t = getAbsoluteAccuracy();\n        final double eps = getRelativeAccuracy();\n\n        while (true) {\n            if (FastMath.abs(fc) < FastMath.abs(fb)) {\n                a = b;\n                b = c;\n                c = a;\n                fa = fb;\n                fb = fc;\n                fc = fa;\n            }\n\n            final double tol = 2 * eps * FastMath.abs(b) + t;\n            final double m = 0.5 * (c - b);\n\n            if (FastMath.abs(m) <= tol ||\n                Precision.equals(fb, 0))  {\n                return b;\n            }\n            if (FastMath.abs(e) < tol ||\n                FastMath.abs(fa) <= FastMath.abs(fb)) {\n                // Force bisection.\n                d = m;\n                e = d;\n            } else {\n                double s = fb / fa;\n                double p;\n                double q;\n                // The equality test (a == c) is intentional,\n                // it is part of the original Brent's method and\n                // it should NOT be replaced by proximity test.\n                if (a == c) {\n                    // Linear interpolation.\n                    p = 2 * m * s;\n                    q = 1 - s;\n                } else {\n                    // Inverse quadratic interpolation.\n                    q = fa / fc;\n                    final double r = fb / fc;\n                    p = s * (2 * m * q * (q - r) - (b - a) * (r - 1));\n                    q = (q - 1) * (r - 1) * (s - 1);\n                }\n                if (p > 0) {\na = +q;\n                } else {\n                    p = -p;\n                }\n                s = e;\n                e = d;\n                if (p >= 1.5 * m * q - FastMath.abs(tol * q) ||\n                    p >= FastMath.abs(0.5 * s * q)) {\n                    // Inverse quadratic interpolation gives a value\n                    // in the wrong direction, or progress is slow.\n                    // Fall back to bisection.\n                    d = m;\n                    e = d;\n                } else {\n                    d = p / q;\n                }\n            }\n            a = b;\n            fa = fb;\n\n            if (FastMath.abs(d) > tol) {\n                b += d;\n            } else if (m > 0) {\n                b += tol;\n            } else {\n                b -= tol;\n            }\n            fb = computeObjectiveValue(b);\n            if ((fb > 0 && fc > 0) ||\n                (fb <= 0 && fc <= 0)) {\n                c = a;\n                fc = fa;\n                d = b - a;\n                e = d;\n            }\n        }\n    }",
          "36": "    private double brent(double lo, double hi,\n                         double fLo, double fHi) {\n        double a = lo;\n        double fa = fLo;\n        double b = hi;\n        double fb = fHi;\n        double c = a;\n        double fc = fa;\n        double d = b - a;\n        double e = d;\n\n        final double t = getAbsoluteAccuracy();\n        final double eps = getRelativeAccuracy();\n\n        while (true) {\n            if (FastMath.abs(fc) < FastMath.abs(fb)) {\n                a = b;\n                b = c;\n                c = a;\n                fa = fb;\n                fb = fc;\n                fc = fa;\n            }\n\n            final double tol = 2 * eps * FastMath.abs(b) + t;\n            final double m = 0.5 * (c - b);\n\n            if (FastMath.abs(m) <= tol ||\n                Precision.equals(fb, 0))  {\n                return b;\n            }\n            if (FastMath.abs(e) < tol ||\n                FastMath.abs(fa) <= FastMath.abs(fb)) {\n                // Force bisection.\n                d = m;\n                e = d;\n            } else {\n                double s = fb / fa;\n                double p;\n                double q;\n                // The equality test (a == c) is intentional,\n                // it is part of the original Brent's method and\n                // it should NOT be replaced by proximity test.\n                if (a == c) {\n                    // Linear interpolation.\n                    p = 2 * m * s;\n                    q = 1 - s;\n                } else {\n                    // Inverse quadratic interpolation.\n                    q = fa / fc;\n                    final double r = fb / fc;\n                    p = s * (2 * m * q * (q - r) - (b - a) * (r - 1));\n                    q = (q - 1) * (r - 1) * (s - 1);\n                }\n                if (p > 0) {\nq = -p;\n                } else {\n                    p = -p;\n                }\n                s = e;\n                e = d;\n                if (p >= 1.5 * m * q - FastMath.abs(tol * q) ||\n                    p >= FastMath.abs(0.5 * s * q)) {\n                    // Inverse quadratic interpolation gives a value\n                    // in the wrong direction, or progress is slow.\n                    // Fall back to bisection.\n                    d = m;\n                    e = d;\n                } else {\n                    d = p / q;\n                }\n            }\n            a = b;\n            fa = fb;\n\n            if (FastMath.abs(d) > tol) {\n                b += d;\n            } else if (m > 0) {\n                b += tol;\n            } else {\n                b -= tol;\n            }\n            fb = computeObjectiveValue(b);\n            if ((fb > 0 && fc > 0) ||\n                (fb <= 0 && fc <= 0)) {\n                c = a;\n                fc = fa;\n                d = b - a;\n                e = d;\n            }\n        }\n    }",
          "37": "    private double brent(double lo, double hi,\n                         double fLo, double fHi) {\n        double a = lo;\n        double fa = fLo;\n        double b = hi;\n        double fb = fHi;\n        double c = a;\n        double fc = fa;\n        double d = b - a;\n        double e = d;\n\n        final double t = getAbsoluteAccuracy();\n        final double eps = getRelativeAccuracy();\n\n        while (true) {\n            if (FastMath.abs(fc) < FastMath.abs(fb)) {\n                a = b;\n                b = c;\n                c = a;\n                fa = fb;\n                fb = fc;\n                fc = fa;\n            }\n\n            final double tol = 2 * eps * FastMath.abs(b) + t;\n            final double m = 0.5 * (c - b);\n\n            if (FastMath.abs(m) <= tol ||\n                Precision.equals(fb, 0))  {\n                return b;\n            }\n            if (FastMath.abs(e) < tol ||\n                FastMath.abs(fa) <= FastMath.abs(fb)) {\n                // Force bisection.\n                d = m;\n                e = d;\n            } else {\n                double s = fb / fa;\n                double p;\n                double q;\n                // The equality test (a == c) is intentional,\n                // it is part of the original Brent's method and\n                // it should NOT be replaced by proximity test.\n                if (a == c) {\n                    // Linear interpolation.\n                    p = 2 * m * s;\n                    q = 1 - s;\n                } else {\n                    // Inverse quadratic interpolation.\n                    q = fa / fc;\n                    final double r = fb / fc;\n                    p = s * (2 * m * q * (q - r) - (b - a) * (r - 1));\n                    q = (q - 1) * (r - 1) * (s - 1);\n                }\n                if (p > 0) {\nif((a == c)){\n                    q = +q;                } else {\n                    p = -p;\n}\n                }\n                s = e;\n                e = d;\n                if (p >= 1.5 * m * q - FastMath.abs(tol * q) ||\n                    p >= FastMath.abs(0.5 * s * q)) {\n                    // Inverse quadratic interpolation gives a value\n                    // in the wrong direction, or progress is slow.\n                    // Fall back to bisection.\n                    d = m;\n                    e = d;\n                } else {\n                    d = p / q;\n                }\n            }\n            a = b;\n            fa = fb;\n\n            if (FastMath.abs(d) > tol) {\n                b += d;\n            } else if (m > 0) {\n                b += tol;\n            } else {\n                b -= tol;\n            }\n            fb = computeObjectiveValue(b);\n            if ((fb > 0 && fc > 0) ||\n                (fb <= 0 && fc <= 0)) {\n                c = a;\n                fc = fa;\n                d = b - a;\n                e = d;\n            }\n        }\n    }",
          "38": "    private double brent(double lo, double hi,\n                         double fLo, double fHi) {\n        double a = lo;\n        double fa = fLo;\n        double b = hi;\n        double fb = fHi;\n        double c = a;\n        double fc = fa;\n        double d = b - a;\n        double e = d;\n\n        final double t = getAbsoluteAccuracy();\n        final double eps = getRelativeAccuracy();\n\n        while (true) {\n            if (FastMath.abs(fc) < FastMath.abs(fb)) {\n                a = b;\n                b = c;\n                c = a;\n                fa = fb;\n                fb = fc;\n                fc = fa;\n            }\n\n            final double tol = 2 * eps * FastMath.abs(b) + t;\n            final double m = 0.5 * (c - b);\n\n            if (FastMath.abs(m) <= tol ||\n                Precision.equals(fb, 0))  {\n                return b;\n            }\n            if (FastMath.abs(e) < tol ||\n                FastMath.abs(fa) <= FastMath.abs(fb)) {\n                // Force bisection.\n                d = m;\n                e = d;\n            } else {\n                double s = fb / fa;\n                double p;\n                double q;\n                // The equality test (a == c) is intentional,\n                // it is part of the original Brent's method and\n                // it should NOT be replaced by proximity test.\n                if (a == c) {\n                    // Linear interpolation.\n                    p = 2 * m * s;\n                    q = 1 - s;\n                } else {\n                    // Inverse quadratic interpolation.\n                    q = fa / fc;\n                    final double r = fb / fc;\n                    p = s * (2 * m * q * (q - r) - (b - a) * (r - 1));\n                    q = (q - 1) * (r - 1) * (s - 1);\n                }\n                if (p > 0) {\np = p;\n                } else {\n                    p = -p;\n                }\n                s = e;\n                e = d;\n                if (p >= 1.5 * m * q - FastMath.abs(tol * q) ||\n                    p >= FastMath.abs(0.5 * s * q)) {\n                    // Inverse quadratic interpolation gives a value\n                    // in the wrong direction, or progress is slow.\n                    // Fall back to bisection.\n                    d = m;\n                    e = d;\n                } else {\n                    d = p / q;\n                }\n            }\n            a = b;\n            fa = fb;\n\n            if (FastMath.abs(d) > tol) {\n                b += d;\n            } else if (m > 0) {\n                b += tol;\n            } else {\n                b -= tol;\n            }\n            fb = computeObjectiveValue(b);\n            if ((fb > 0 && fc > 0) ||\n                (fb <= 0 && fc <= 0)) {\n                c = a;\n                fc = fa;\n                d = b - a;\n                e = d;\n            }\n        }\n    }",
          "39": "    private double brent(double lo, double hi,\n                         double fLo, double fHi) {\n        double a = lo;\n        double fa = fLo;\n        double b = hi;\n        double fb = fHi;\n        double c = a;\n        double fc = fa;\n        double d = b - a;\n        double e = d;\n\n        final double t = getAbsoluteAccuracy();\n        final double eps = getRelativeAccuracy();\n\n        while (true) {\n            if (FastMath.abs(fc) < FastMath.abs(fb)) {\n                a = b;\n                b = c;\n                c = a;\n                fa = fb;\n                fb = fc;\n                fc = fa;\n            }\n\n            final double tol = 2 * eps * FastMath.abs(b) + t;\n            final double m = 0.5 * (c - b);\n\n            if (FastMath.abs(m) <= tol ||\n                Precision.equals(fb, 0))  {\n                return b;\n            }\n            if (FastMath.abs(e) < tol ||\n                FastMath.abs(fa) <= FastMath.abs(fb)) {\n                // Force bisection.\n                d = m;\n                e = d;\n            } else {\n                double s = fb / fa;\n                double p;\n                double q;\n                // The equality test (a == c) is intentional,\n                // it is part of the original Brent's method and\n                // it should NOT be replaced by proximity test.\n                if (a == c) {\n                    // Linear interpolation.\n                    p = 2 * m * s;\n                    q = 1 - s;\n                } else {\n                    // Inverse quadratic interpolation.\n                    q = fa / fc;\n                    final double r = fb / fc;\n                    p = s * (2 * m * q * (q - r) - (b - a) * (r - 1));\n                    q = (q - 1) * (r - 1) * (s - 1);\n                }\n                if (p > 0) {\ns = q;\n                } else {\n                    p = -p;\n                }\n                s = e;\n                e = d;\n                if (p >= 1.5 * m * q - FastMath.abs(tol * q) ||\n                    p >= FastMath.abs(0.5 * s * q)) {\n                    // Inverse quadratic interpolation gives a value\n                    // in the wrong direction, or progress is slow.\n                    // Fall back to bisection.\n                    d = m;\n                    e = d;\n                } else {\n                    d = p / q;\n                }\n            }\n            a = b;\n            fa = fb;\n\n            if (FastMath.abs(d) > tol) {\n                b += d;\n            } else if (m > 0) {\n                b += tol;\n            } else {\n                b -= tol;\n            }\n            fb = computeObjectiveValue(b);\n            if ((fb > 0 && fc > 0) ||\n                (fb <= 0 && fc <= 0)) {\n                c = a;\n                fc = fa;\n                d = b - a;\n                e = d;\n            }\n        }\n    }",
          "40": "    private double brent(double lo, double hi,\n                         double fLo, double fHi) {\n        double a = lo;\n        double fa = fLo;\n        double b = hi;\n        double fb = fHi;\n        double c = a;\n        double fc = fa;\n        double d = b - a;\n        double e = d;\n\n        final double t = getAbsoluteAccuracy();\n        final double eps = getRelativeAccuracy();\n\n        while (true) {\n            if (FastMath.abs(fc) < FastMath.abs(fb)) {\n                a = b;\n                b = c;\n                c = a;\n                fa = fb;\n                fb = fc;\n                fc = fa;\n            }\n\n            final double tol = 2 * eps * FastMath.abs(b) + t;\n            final double m = 0.5 * (c - b);\n\n            if (FastMath.abs(m) <= tol ||\n                Precision.equals(fb, 0))  {\n                return b;\n            }\n            if (FastMath.abs(e) < tol ||\n                FastMath.abs(fa) <= FastMath.abs(fb)) {\n                // Force bisection.\n                d = m;\n                e = d;\n            } else {\n                double s = fb / fa;\n                double p;\n                double q;\n                // The equality test (a == c) is intentional,\n                // it is part of the original Brent's method and\n                // it should NOT be replaced by proximity test.\n                if (a == c) {\n                    // Linear interpolation.\n                    p = 2 * m * s;\n                    q = 1 - s;\n                } else {\n                    // Inverse quadratic interpolation.\n                    q = fa / fc;\n                    final double r = fb / fc;\n                    p = s * (2 * m * q * (q - r) - (b - a) * (r - 1));\n                    q = (q - 1) * (r - 1) * (s - 1);\n                }\n                if (p > 0) {\nq = null;\n                } else {\n                    p = -p;\n                }\n                s = e;\n                e = d;\n                if (p >= 1.5 * m * q - FastMath.abs(tol * q) ||\n                    p >= FastMath.abs(0.5 * s * q)) {\n                    // Inverse quadratic interpolation gives a value\n                    // in the wrong direction, or progress is slow.\n                    // Fall back to bisection.\n                    d = m;\n                    e = d;\n                } else {\n                    d = p / q;\n                }\n            }\n            a = b;\n            fa = fb;\n\n            if (FastMath.abs(d) > tol) {\n                b += d;\n            } else if (m > 0) {\n                b += tol;\n            } else {\n                b -= tol;\n            }\n            fb = computeObjectiveValue(b);\n            if ((fb > 0 && fc > 0) ||\n                (fb <= 0 && fc <= 0)) {\n                c = a;\n                fc = fa;\n                d = b - a;\n                e = d;\n            }\n        }\n    }",
          "41": "    private double brent(double lo, double hi,\n                         double fLo, double fHi) {\n        double a = lo;\n        double fa = fLo;\n        double b = hi;\n        double fb = fHi;\n        double c = a;\n        double fc = fa;\n        double d = b - a;\n        double e = d;\n\n        final double t = getAbsoluteAccuracy();\n        final double eps = getRelativeAccuracy();\n\n        while (true) {\n            if (FastMath.abs(fc) < FastMath.abs(fb)) {\n                a = b;\n                b = c;\n                c = a;\n                fa = fb;\n                fb = fc;\n                fc = fa;\n            }\n\n            final double tol = 2 * eps * FastMath.abs(b) + t;\n            final double m = 0.5 * (c - b);\n\n            if (FastMath.abs(m) <= tol ||\n                Precision.equals(fb, 0))  {\n                return b;\n            }\n            if (FastMath.abs(e) < tol ||\n                FastMath.abs(fa) <= FastMath.abs(fb)) {\n                // Force bisection.\n                d = m;\n                e = d;\n            } else {\n                double s = fb / fa;\n                double p;\n                double q;\n                // The equality test (a == c) is intentional,\n                // it is part of the original Brent's method and\n                // it should NOT be replaced by proximity test.\n                if (a == c) {\n                    // Linear interpolation.\n                    p = 2 * m * s;\n                    q = 1 - s;\n                } else {\n                    // Inverse quadratic interpolation.\n                    q = fa / fc;\n                    final double r = fb / fc;\n                    p = s * (2 * m * q * (q - r) - (b - a) * (r - 1));\n                    q = (q - 1) * (r - 1) * (s - 1);\n                }\n                if (p > 0) {\np = -q;\n                } else {\n                    p = -p;\n                }\n                s = e;\n                e = d;\n                if (p >= 1.5 * m * q - FastMath.abs(tol * q) ||\n                    p >= FastMath.abs(0.5 * s * q)) {\n                    // Inverse quadratic interpolation gives a value\n                    // in the wrong direction, or progress is slow.\n                    // Fall back to bisection.\n                    d = m;\n                    e = d;\n                } else {\n                    d = p / q;\n                }\n            }\n            a = b;\n            fa = fb;\n\n            if (FastMath.abs(d) > tol) {\n                b += d;\n            } else if (m > 0) {\n                b += tol;\n            } else {\n                b -= tol;\n            }\n            fb = computeObjectiveValue(b);\n            if ((fb > 0 && fc > 0) ||\n                (fb <= 0 && fc <= 0)) {\n                c = a;\n                fc = fa;\n                d = b - a;\n                e = d;\n            }\n        }\n    }",
          "42": "    private double brent(double lo, double hi,\n                         double fLo, double fHi) {\n        double a = lo;\n        double fa = fLo;\n        double b = hi;\n        double fb = fHi;\n        double c = a;\n        double fc = fa;\n        double d = b - a;\n        double e = d;\n\n        final double t = getAbsoluteAccuracy();\n        final double eps = getRelativeAccuracy();\n\n        while (true) {\n            if (FastMath.abs(fc) < FastMath.abs(fb)) {\n                a = b;\n                b = c;\n                c = a;\n                fa = fb;\n                fb = fc;\n                fc = fa;\n            }\n\n            final double tol = 2 * eps * FastMath.abs(b) + t;\n            final double m = 0.5 * (c - b);\n\n            if (FastMath.abs(m) <= tol ||\n                Precision.equals(fb, 0))  {\n                return b;\n            }\n            if (FastMath.abs(e) < tol ||\n                FastMath.abs(fa) <= FastMath.abs(fb)) {\n                // Force bisection.\n                d = m;\n                e = d;\n            } else {\n                double s = fb / fa;\n                double p;\n                double q;\n                // The equality test (a == c) is intentional,\n                // it is part of the original Brent's method and\n                // it should NOT be replaced by proximity test.\n                if (a == c) {\n                    // Linear interpolation.\n                    p = 2 * m * s;\n                    q = 1 - s;\n                } else {\n                    // Inverse quadratic interpolation.\n                    q = fa / fc;\n                    final double r = fb / fc;\n                    p = s * (2 * m * q * (q - r) - (b - a) * (r - 1));\n                    q = (q - 1) * (r - 1) * (s - 1);\n                }\n                if (p > 0) {\ncontinue;\n                    q = +q;                } else {\n                    p = -p;\n                }\n                s = e;\n                e = d;\n                if (p >= 1.5 * m * q - FastMath.abs(tol * q) ||\n                    p >= FastMath.abs(0.5 * s * q)) {\n                    // Inverse quadratic interpolation gives a value\n                    // in the wrong direction, or progress is slow.\n                    // Fall back to bisection.\n                    d = m;\n                    e = d;\n                } else {\n                    d = p / q;\n                }\n            }\n            a = b;\n            fa = fb;\n\n            if (FastMath.abs(d) > tol) {\n                b += d;\n            } else if (m > 0) {\n                b += tol;\n            } else {\n                b -= tol;\n            }\n            fb = computeObjectiveValue(b);\n            if ((fb > 0 && fc > 0) ||\n                (fb <= 0 && fc <= 0)) {\n                c = a;\n                fc = fa;\n                d = b - a;\n                e = d;\n            }\n        }\n    }",
          "43": "    private double brent(double lo, double hi,\n                         double fLo, double fHi) {\n        double a = lo;\n        double fa = fLo;\n        double b = hi;\n        double fb = fHi;\n        double c = a;\n        double fc = fa;\n        double d = b - a;\n        double e = d;\n\n        final double t = getAbsoluteAccuracy();\n        final double eps = getRelativeAccuracy();\n\n        while (true) {\n            if (FastMath.abs(fc) < FastMath.abs(fb)) {\n                a = b;\n                b = c;\n                c = a;\n                fa = fb;\n                fb = fc;\n                fc = fa;\n            }\n\n            final double tol = 2 * eps * FastMath.abs(b) + t;\n            final double m = 0.5 * (c - b);\n\n            if (FastMath.abs(m) <= tol ||\n                Precision.equals(fb, 0))  {\n                return b;\n            }\n            if (FastMath.abs(e) < tol ||\n                FastMath.abs(fa) <= FastMath.abs(fb)) {\n                // Force bisection.\n                d = m;\n                e = d;\n            } else {\n                double s = fb / fa;\n                double p;\n                double q;\n                // The equality test (a == c) is intentional,\n                // it is part of the original Brent's method and\n                // it should NOT be replaced by proximity test.\n                if (a == c) {\n                    // Linear interpolation.\n                    p = 2 * m * s;\n                    q = 1 - s;\n                } else {\n                    // Inverse quadratic interpolation.\n                    q = fa / fc;\n                    final double r = fb / fc;\n                    p = s * (2 * m * q * (q - r) - (b - a) * (r - 1));\n                    q = (q - 1) * (r - 1) * (s - 1);\n                }\n                if (p > 0) {\n                    q = +q;                } else {\n                    p = -p;\n                }\n                s = e;\n                e = d;\n                if (p >= 1.5 * m * q - FastMath.abs(tol * q) ||\n                    p >= FastMath.abs(0.5 * s * q)) {\n                    // Inverse quadratic interpolation gives a value\n                    // in the wrong direction, or progress is slow.\n                    // Fall back to bisection.\n                    d = m;\n                    e = d;\n                } else {\n                    d = p / q;\n                }\n            }\n            a = b;\n            fa = fb;\n\n            if (FastMath.abs(d) > tol) {\n                b += d;\n            } else if (m > 0) {\n                b += tol;\n            } else {\n                b -= tol;\n            }\n            fb = computeObjectiveValue(b);\n            if ((fb > 0 && fc > 0) ||\n                (fb <= 0 && fc <= 0)) {\n                c = a;\n                fc = fa;\n                d = b - a;\n                e = d;\n            }\n        }\n    }",
          "44": "    private double brent(double lo, double hi,\n                         double fLo, double fHi) {\n        double a = lo;\n        double fa = fLo;\n        double b = hi;\n        double fb = fHi;\n        double c = a;\n        double fc = fa;\n        double d = b - a;\n        double e = d;\n\n        final double t = getAbsoluteAccuracy();\n        final double eps = getRelativeAccuracy();\n\n        while (true) {\n            if (FastMath.abs(fc) < FastMath.abs(fb)) {\n                a = b;\n                b = c;\n                c = a;\n                fa = fb;\n                fb = fc;\n                fc = fa;\n            }\n\n            final double tol = 2 * eps * FastMath.abs(b) + t;\n            final double m = 0.5 * (c - b);\n\n            if (FastMath.abs(m) <= tol ||\n                Precision.equals(fb, 0))  {\n                return b;\n            }\n            if (FastMath.abs(e) < tol ||\n                FastMath.abs(fa) <= FastMath.abs(fb)) {\n                // Force bisection.\n                d = m;\n                e = d;\n            } else {\n                double s = fb / fa;\n                double p;\n                double q;\n                // The equality test (a == c) is intentional,\n                // it is part of the original Brent's method and\n                // it should NOT be replaced by proximity test.\n                if (a == c) {\n                    // Linear interpolation.\n                    p = 2 * m * s;\n                    q = 1 - s;\n                } else {\n                    // Inverse quadratic interpolation.\n                    q = fa / fc;\n                    final double r = fb / fc;\n                    p = s * (2 * m * q * (q - r) - (b - a) * (r - 1));\n                    q = (q - 1) * (r - 1) * (s - 1);\n                }\n                if (p > 0) {\nq = (q + q);\n                } else {\n                    p = -p;\n                }\n                s = e;\n                e = d;\n                if (p >= 1.5 * m * q - FastMath.abs(tol * q) ||\n                    p >= FastMath.abs(0.5 * s * q)) {\n                    // Inverse quadratic interpolation gives a value\n                    // in the wrong direction, or progress is slow.\n                    // Fall back to bisection.\n                    d = m;\n                    e = d;\n                } else {\n                    d = p / q;\n                }\n            }\n            a = b;\n            fa = fb;\n\n            if (FastMath.abs(d) > tol) {\n                b += d;\n            } else if (m > 0) {\n                b += tol;\n            } else {\n                b -= tol;\n            }\n            fb = computeObjectiveValue(b);\n            if ((fb > 0 && fc > 0) ||\n                (fb <= 0 && fc <= 0)) {\n                c = a;\n                fc = fa;\n                d = b - a;\n                e = d;\n            }\n        }\n    }",
          "45": "    private double brent(double lo, double hi,\n                         double fLo, double fHi) {\n        double a = lo;\n        double fa = fLo;\n        double b = hi;\n        double fb = fHi;\n        double c = a;\n        double fc = fa;\n        double d = b - a;\n        double e = d;\n\n        final double t = getAbsoluteAccuracy();\n        final double eps = getRelativeAccuracy();\n\n        while (true) {\n            if (FastMath.abs(fc) < FastMath.abs(fb)) {\n                a = b;\n                b = c;\n                c = a;\n                fa = fb;\n                fb = fc;\n                fc = fa;\n            }\n\n            final double tol = 2 * eps * FastMath.abs(b) + t;\n            final double m = 0.5 * (c - b);\n\n            if (FastMath.abs(m) <= tol ||\n                Precision.equals(fb, 0))  {\n                return b;\n            }\n            if (FastMath.abs(e) < tol ||\n                FastMath.abs(fa) <= FastMath.abs(fb)) {\n                // Force bisection.\n                d = m;\n                e = d;\n            } else {\n                double s = fb / fa;\n                double p;\n                double q;\n                // The equality test (a == c) is intentional,\n                // it is part of the original Brent's method and\n                // it should NOT be replaced by proximity test.\n                if (a == c) {\n                    // Linear interpolation.\n                    p = 2 * m * s;\n                    q = 1 - s;\n                } else {\n                    // Inverse quadratic interpolation.\n                    q = fa / fc;\n                    final double r = fb / fc;\n                    p = s * (2 * m * q * (q - r) - (b - a) * (r - 1));\n                    q = (q - 1) * (r - 1) * (s - 1);\n                }\n                if (p > 0) {\nq = (q + 1);\n                } else {\n                    p = -p;\n                }\n                s = e;\n                e = d;\n                if (p >= 1.5 * m * q - FastMath.abs(tol * q) ||\n                    p >= FastMath.abs(0.5 * s * q)) {\n                    // Inverse quadratic interpolation gives a value\n                    // in the wrong direction, or progress is slow.\n                    // Fall back to bisection.\n                    d = m;\n                    e = d;\n                } else {\n                    d = p / q;\n                }\n            }\n            a = b;\n            fa = fb;\n\n            if (FastMath.abs(d) > tol) {\n                b += d;\n            } else if (m > 0) {\n                b += tol;\n            } else {\n                b -= tol;\n            }\n            fb = computeObjectiveValue(b);\n            if ((fb > 0 && fc > 0) ||\n                (fb <= 0 && fc <= 0)) {\n                c = a;\n                fc = fa;\n                d = b - a;\n                e = d;\n            }\n        }\n    }",
          "46": "    private double brent(double lo, double hi,\n                         double fLo, double fHi) {\n        double a = lo;\n        double fa = fLo;\n        double b = hi;\n        double fb = fHi;\n        double c = a;\n        double fc = fa;\n        double d = b - a;\n        double e = d;\n\n        final double t = getAbsoluteAccuracy();\n        final double eps = getRelativeAccuracy();\n\n        while (true) {\n            if (FastMath.abs(fc) < FastMath.abs(fb)) {\n                a = b;\n                b = c;\n                c = a;\n                fa = fb;\n                fb = fc;\n                fc = fa;\n            }\n\n            final double tol = 2 * eps * FastMath.abs(b) + t;\n            final double m = 0.5 * (c - b);\n\n            if (FastMath.abs(m) <= tol ||\n                Precision.equals(fb, 0))  {\n                return b;\n            }\n            if (FastMath.abs(e) < tol ||\n                FastMath.abs(fa) <= FastMath.abs(fb)) {\n                // Force bisection.\n                d = m;\n                e = d;\n            } else {\n                double s = fb / fa;\n                double p;\n                double q;\n                // The equality test (a == c) is intentional,\n                // it is part of the original Brent's method and\n                // it should NOT be replaced by proximity test.\n                if (a == c) {\n                    // Linear interpolation.\n                    p = 2 * m * s;\n                    q = 1 - s;\n                } else {\n                    // Inverse quadratic interpolation.\n                    q = fa / fc;\n                    final double r = fb / fc;\n                    p = s * (2 * m * q * (q - r) - (b - a) * (r - 1));\n                    q = (q - 1) * (r - 1) * (s - 1);\n                }\n                if (p > 0) {\nq = (q + 0);\n                } else {\n                    p = -p;\n                }\n                s = e;\n                e = d;\n                if (p >= 1.5 * m * q - FastMath.abs(tol * q) ||\n                    p >= FastMath.abs(0.5 * s * q)) {\n                    // Inverse quadratic interpolation gives a value\n                    // in the wrong direction, or progress is slow.\n                    // Fall back to bisection.\n                    d = m;\n                    e = d;\n                } else {\n                    d = p / q;\n                }\n            }\n            a = b;\n            fa = fb;\n\n            if (FastMath.abs(d) > tol) {\n                b += d;\n            } else if (m > 0) {\n                b += tol;\n            } else {\n                b -= tol;\n            }\n            fb = computeObjectiveValue(b);\n            if ((fb > 0 && fc > 0) ||\n                (fb <= 0 && fc <= 0)) {\n                c = a;\n                fc = fa;\n                d = b - a;\n                e = d;\n            }\n        }\n    }",
          "47": "    private double brent(double lo, double hi,\n                         double fLo, double fHi) {\n        double a = lo;\n        double fa = fLo;\n        double b = hi;\n        double fb = fHi;\n        double c = a;\n        double fc = fa;\n        double d = b - a;\n        double e = d;\n\n        final double t = getAbsoluteAccuracy();\n        final double eps = getRelativeAccuracy();\n\n        while (true) {\n            if (FastMath.abs(fc) < FastMath.abs(fb)) {\n                a = b;\n                b = c;\n                c = a;\n                fa = fb;\n                fb = fc;\n                fc = fa;\n            }\n\n            final double tol = 2 * eps * FastMath.abs(b) + t;\n            final double m = 0.5 * (c - b);\n\n            if (FastMath.abs(m) <= tol ||\n                Precision.equals(fb, 0))  {\n                return b;\n            }\n            if (FastMath.abs(e) < tol ||\n                FastMath.abs(fa) <= FastMath.abs(fb)) {\n                // Force bisection.\n                d = m;\n                e = d;\n            } else {\n                double s = fb / fa;\n                double p;\n                double q;\n                // The equality test (a == c) is intentional,\n                // it is part of the original Brent's method and\n                // it should NOT be replaced by proximity test.\n                if (a == c) {\n                    // Linear interpolation.\n                    p = 2 * m * s;\n                    q = 1 - s;\n                } else {\n                    // Inverse quadratic interpolation.\n                    q = fa / fc;\n                    final double r = fb / fc;\n                    p = s * (2 * m * q * (q - r) - (b - a) * (r - 1));\n                    q = (q - 1) * (r - 1) * (s - 1);\n                }\n                if (p > 0) {\nq = (q + p);\n                } else {\n                    p = -p;\n                }\n                s = e;\n                e = d;\n                if (p >= 1.5 * m * q - FastMath.abs(tol * q) ||\n                    p >= FastMath.abs(0.5 * s * q)) {\n                    // Inverse quadratic interpolation gives a value\n                    // in the wrong direction, or progress is slow.\n                    // Fall back to bisection.\n                    d = m;\n                    e = d;\n                } else {\n                    d = p / q;\n                }\n            }\n            a = b;\n            fa = fb;\n\n            if (FastMath.abs(d) > tol) {\n                b += d;\n            } else if (m > 0) {\n                b += tol;\n            } else {\n                b -= tol;\n            }\n            fb = computeObjectiveValue(b);\n            if ((fb > 0 && fc > 0) ||\n                (fb <= 0 && fc <= 0)) {\n                c = a;\n                fc = fa;\n                d = b - a;\n                e = d;\n            }\n        }\n    }",
          "48": "    private double brent(double lo, double hi,\n                         double fLo, double fHi) {\n        double a = lo;\n        double fa = fLo;\n        double b = hi;\n        double fb = fHi;\n        double c = a;\n        double fc = fa;\n        double d = b - a;\n        double e = d;\n\n        final double t = getAbsoluteAccuracy();\n        final double eps = getRelativeAccuracy();\n\n        while (true) {\n            if (FastMath.abs(fc) < FastMath.abs(fb)) {\n                a = b;\n                b = c;\n                c = a;\n                fa = fb;\n                fb = fc;\n                fc = fa;\n            }\n\n            final double tol = 2 * eps * FastMath.abs(b) + t;\n            final double m = 0.5 * (c - b);\n\n            if (FastMath.abs(m) <= tol ||\n                Precision.equals(fb, 0))  {\n                return b;\n            }\n            if (FastMath.abs(e) < tol ||\n                FastMath.abs(fa) <= FastMath.abs(fb)) {\n                // Force bisection.\n                d = m;\n                e = d;\n            } else {\n                double s = fb / fa;\n                double p;\n                double q;\n                // The equality test (a == c) is intentional,\n                // it is part of the original Brent's method and\n                // it should NOT be replaced by proximity test.\n                if (a == c) {\n                    // Linear interpolation.\n                    p = 2 * m * s;\n                    q = 1 - s;\n                } else {\n                    // Inverse quadratic interpolation.\n                    q = fa / fc;\n                    final double r = fb / fc;\n                    p = s * (2 * m * q * (q - r) - (b - a) * (r - 1));\n                    q = (q - 1) * (r - 1) * (s - 1);\n                }\n                if (p > 0) {\nq = (q + -q);\n                } else {\n                    p = -p;\n                }\n                s = e;\n                e = d;\n                if (p >= 1.5 * m * q - FastMath.abs(tol * q) ||\n                    p >= FastMath.abs(0.5 * s * q)) {\n                    // Inverse quadratic interpolation gives a value\n                    // in the wrong direction, or progress is slow.\n                    // Fall back to bisection.\n                    d = m;\n                    e = d;\n                } else {\n                    d = p / q;\n                }\n            }\n            a = b;\n            fa = fb;\n\n            if (FastMath.abs(d) > tol) {\n                b += d;\n            } else if (m > 0) {\n                b += tol;\n            } else {\n                b -= tol;\n            }\n            fb = computeObjectiveValue(b);\n            if ((fb > 0 && fc > 0) ||\n                (fb <= 0 && fc <= 0)) {\n                c = a;\n                fc = fa;\n                d = b - a;\n                e = d;\n            }\n        }\n    }",
          "49": "    private double brent(double lo, double hi,\n                         double fLo, double fHi) {\n        double a = lo;\n        double fa = fLo;\n        double b = hi;\n        double fb = fHi;\n        double c = a;\n        double fc = fa;\n        double d = b - a;\n        double e = d;\n\n        final double t = getAbsoluteAccuracy();\n        final double eps = getRelativeAccuracy();\n\n        while (true) {\n            if (FastMath.abs(fc) < FastMath.abs(fb)) {\n                a = b;\n                b = c;\n                c = a;\n                fa = fb;\n                fb = fc;\n                fc = fa;\n            }\n\n            final double tol = 2 * eps * FastMath.abs(b) + t;\n            final double m = 0.5 * (c - b);\n\n            if (FastMath.abs(m) <= tol ||\n                Precision.equals(fb, 0))  {\n                return b;\n            }\n            if (FastMath.abs(e) < tol ||\n                FastMath.abs(fa) <= FastMath.abs(fb)) {\n                // Force bisection.\n                d = m;\n                e = d;\n            } else {\n                double s = fb / fa;\n                double p;\n                double q;\n                // The equality test (a == c) is intentional,\n                // it is part of the original Brent's method and\n                // it should NOT be replaced by proximity test.\n                if (a == c) {\n                    // Linear interpolation.\n                    p = 2 * m * s;\n                    q = 1 - s;\n                } else {\n                    // Inverse quadratic interpolation.\n                    q = fa / fc;\n                    final double r = fb / fc;\n                    p = s * (2 * m * q * (q - r) - (b - a) * (r - 1));\n                    q = (q - 1) * (r - 1) * (s - 1);\n                }\n                if (p > 0) {\nq = ((q + q) + q);\n                } else {\n                    p = -p;\n                }\n                s = e;\n                e = d;\n                if (p >= 1.5 * m * q - FastMath.abs(tol * q) ||\n                    p >= FastMath.abs(0.5 * s * q)) {\n                    // Inverse quadratic interpolation gives a value\n                    // in the wrong direction, or progress is slow.\n                    // Fall back to bisection.\n                    d = m;\n                    e = d;\n                } else {\n                    d = p / q;\n                }\n            }\n            a = b;\n            fa = fb;\n\n            if (FastMath.abs(d) > tol) {\n                b += d;\n            } else if (m > 0) {\n                b += tol;\n            } else {\n                b -= tol;\n            }\n            fb = computeObjectiveValue(b);\n            if ((fb > 0 && fc > 0) ||\n                (fb <= 0 && fc <= 0)) {\n                c = a;\n                fc = fa;\n                d = b - a;\n                e = d;\n            }\n        }\n    }"
}