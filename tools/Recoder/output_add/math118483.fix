{
          "0": "    public static float scalb(final float f, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -127) && (n < 128)) {\n            return f * Float.intBitsToFloat((n + 127) << 23);\n        }\n\n        // handle special cases\n        if (Float.isNaN(f) || Float.isInfinite(f) || (f == 0f)) {\n            return f;\n        }\n        if (n < -277) {\n            return (f > 0) ? 0.0f : -0.0f;\n        }\n        if (n > 276) {\n            return (f > 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n        }\n\n        // decompose f\n        final int bits = Float.floatToIntBits(f);\n        final int sign = bits & 0x80000000;\n        int  exponent  = (bits >>> 23) & 0xff;\n        int mantissa   = bits & 0x007fffff;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -127\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n            } else if (scaledExponent > -24) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\n                mantissa = mantissa | (1 << 23);\n\n                // scales down complete mantissa, hence losing least significant bits\n                final int mostSignificantLostBit = mantissa & (1 << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Float.intBitsToFloat(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0) ? 0.0f : -0.0f;\n            }\n        } else {\n            // we are really in the case n >= 128\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 23) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x007fffff;\n\n                if (scaledExponent < 255) {\nreturn Float.intBitsToFloat(((sign | (scaledExponent >> 2)) | mantissa));                } else {\n                    return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 255) {\n                return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n            } else {\n                return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "1": "    public static float scalb(final float f, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -127) && (n < 128)) {\n            return f * Float.intBitsToFloat((n + 127) << 23);\n        }\n\n        // handle special cases\n        if (Float.isNaN(f) || Float.isInfinite(f) || (f == 0f)) {\n            return f;\n        }\n        if (n < -277) {\n            return (f > 0) ? 0.0f : -0.0f;\n        }\n        if (n > 276) {\n            return (f > 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n        }\n\n        // decompose f\n        final int bits = Float.floatToIntBits(f);\n        final int sign = bits & 0x80000000;\n        int  exponent  = (bits >>> 23) & 0xff;\n        int mantissa   = bits & 0x007fffff;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -127\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n            } else if (scaledExponent > -24) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\n                mantissa = mantissa | (1 << 23);\n\n                // scales down complete mantissa, hence losing least significant bits\n                final int mostSignificantLostBit = mantissa & (1 << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Float.intBitsToFloat(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0) ? 0.0f : -0.0f;\n            }\n        } else {\n            // we are really in the case n >= 128\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 23) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x007fffff;\n\n                if (scaledExponent < 255) {\nreturn Float.intBitsToFloat(((sign | (scaledExponent >> 1)) | mantissa));                } else {\n                    return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 255) {\n                return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n            } else {\n                return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "2": "    public static float scalb(final float f, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -127) && (n < 128)) {\n            return f * Float.intBitsToFloat((n + 127) << 23);\n        }\n\n        // handle special cases\n        if (Float.isNaN(f) || Float.isInfinite(f) || (f == 0f)) {\n            return f;\n        }\n        if (n < -277) {\n            return (f > 0) ? 0.0f : -0.0f;\n        }\n        if (n > 276) {\n            return (f > 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n        }\n\n        // decompose f\n        final int bits = Float.floatToIntBits(f);\n        final int sign = bits & 0x80000000;\n        int  exponent  = (bits >>> 23) & 0xff;\n        int mantissa   = bits & 0x007fffff;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -127\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n            } else if (scaledExponent > -24) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\n                mantissa = mantissa | (1 << 23);\n\n                // scales down complete mantissa, hence losing least significant bits\n                final int mostSignificantLostBit = mantissa & (1 << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Float.intBitsToFloat(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0) ? 0.0f : -0.0f;\n            }\n        } else {\n            // we are really in the case n >= 128\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 23) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x007fffff;\n\n                if (scaledExponent < 255) {\nreturn Float.intBitsToFloat(((sign | (scaledExponent > 23)) | mantissa));                } else {\n                    return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 255) {\n                return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n            } else {\n                return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "3": "    public static float scalb(final float f, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -127) && (n < 128)) {\n            return f * Float.intBitsToFloat((n + 127) << 23);\n        }\n\n        // handle special cases\n        if (Float.isNaN(f) || Float.isInfinite(f) || (f == 0f)) {\n            return f;\n        }\n        if (n < -277) {\n            return (f > 0) ? 0.0f : -0.0f;\n        }\n        if (n > 276) {\n            return (f > 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n        }\n\n        // decompose f\n        final int bits = Float.floatToIntBits(f);\n        final int sign = bits & 0x80000000;\n        int  exponent  = (bits >>> 23) & 0xff;\n        int mantissa   = bits & 0x007fffff;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -127\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n            } else if (scaledExponent > -24) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\n                mantissa = mantissa | (1 << 23);\n\n                // scales down complete mantissa, hence losing least significant bits\n                final int mostSignificantLostBit = mantissa & (1 << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Float.intBitsToFloat(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0) ? 0.0f : -0.0f;\n            }\n        } else {\n            // we are really in the case n >= 128\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 23) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x007fffff;\n\n                if (scaledExponent < 255) {\nreturn Float.intBitsToFloat(((sign | (scaledExponent <= 23)) | mantissa));                } else {\n                    return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 255) {\n                return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n            } else {\n                return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "4": "    public static float scalb(final float f, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -127) && (n < 128)) {\n            return f * Float.intBitsToFloat((n + 127) << 23);\n        }\n\n        // handle special cases\n        if (Float.isNaN(f) || Float.isInfinite(f) || (f == 0f)) {\n            return f;\n        }\n        if (n < -277) {\n            return (f > 0) ? 0.0f : -0.0f;\n        }\n        if (n > 276) {\n            return (f > 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n        }\n\n        // decompose f\n        final int bits = Float.floatToIntBits(f);\n        final int sign = bits & 0x80000000;\n        int  exponent  = (bits >>> 23) & 0xff;\n        int mantissa   = bits & 0x007fffff;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -127\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n            } else if (scaledExponent > -24) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\n                mantissa = mantissa | (1 << 23);\n\n                // scales down complete mantissa, hence losing least significant bits\n                final int mostSignificantLostBit = mantissa & (1 << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Float.intBitsToFloat(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0) ? 0.0f : -0.0f;\n            }\n        } else {\n            // we are really in the case n >= 128\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 23) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x007fffff;\n\n                if (scaledExponent < 255) {\nreturn Float.intBitsToFloat(((sign | (scaledExponent < 23)) | mantissa));                } else {\n                    return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 255) {\n                return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n            } else {\n                return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "5": "    public static float scalb(final float f, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -127) && (n < 128)) {\n            return f * Float.intBitsToFloat((n + 127) << 23);\n        }\n\n        // handle special cases\n        if (Float.isNaN(f) || Float.isInfinite(f) || (f == 0f)) {\n            return f;\n        }\n        if (n < -277) {\n            return (f > 0) ? 0.0f : -0.0f;\n        }\n        if (n > 276) {\n            return (f > 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n        }\n\n        // decompose f\n        final int bits = Float.floatToIntBits(f);\n        final int sign = bits & 0x80000000;\n        int  exponent  = (bits >>> 23) & 0xff;\n        int mantissa   = bits & 0x007fffff;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -127\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n            } else if (scaledExponent > -24) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\n                mantissa = mantissa | (1 << 23);\n\n                // scales down complete mantissa, hence losing least significant bits\n                final int mostSignificantLostBit = mantissa & (1 << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Float.intBitsToFloat(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0) ? 0.0f : -0.0f;\n            }\n        } else {\n            // we are really in the case n >= 128\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 23) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x007fffff;\n\n                if (scaledExponent < 255) {\nreturn Float.intBitsToFloat(((sign | (scaledExponent >> 23)) < mantissa));                } else {\n                    return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 255) {\n                return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n            } else {\n                return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "6": "    public static float scalb(final float f, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -127) && (n < 128)) {\n            return f * Float.intBitsToFloat((n + 127) << 23);\n        }\n\n        // handle special cases\n        if (Float.isNaN(f) || Float.isInfinite(f) || (f == 0f)) {\n            return f;\n        }\n        if (n < -277) {\n            return (f > 0) ? 0.0f : -0.0f;\n        }\n        if (n > 276) {\n            return (f > 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n        }\n\n        // decompose f\n        final int bits = Float.floatToIntBits(f);\n        final int sign = bits & 0x80000000;\n        int  exponent  = (bits >>> 23) & 0xff;\n        int mantissa   = bits & 0x007fffff;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -127\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n            } else if (scaledExponent > -24) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\n                mantissa = mantissa | (1 << 23);\n\n                // scales down complete mantissa, hence losing least significant bits\n                final int mostSignificantLostBit = mantissa & (1 << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Float.intBitsToFloat(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0) ? 0.0f : -0.0f;\n            }\n        } else {\n            // we are really in the case n >= 128\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 23) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x007fffff;\n\n                if (scaledExponent < 255) {\nreturn Float.intBitsToFloat(((sign | (scaledExponent >= 23)) | mantissa));                } else {\n                    return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 255) {\n                return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n            } else {\n                return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "7": "    public static float scalb(final float f, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -127) && (n < 128)) {\n            return f * Float.intBitsToFloat((n + 127) << 23);\n        }\n\n        // handle special cases\n        if (Float.isNaN(f) || Float.isInfinite(f) || (f == 0f)) {\n            return f;\n        }\n        if (n < -277) {\n            return (f > 0) ? 0.0f : -0.0f;\n        }\n        if (n > 276) {\n            return (f > 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n        }\n\n        // decompose f\n        final int bits = Float.floatToIntBits(f);\n        final int sign = bits & 0x80000000;\n        int  exponent  = (bits >>> 23) & 0xff;\n        int mantissa   = bits & 0x007fffff;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -127\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n            } else if (scaledExponent > -24) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\n                mantissa = mantissa | (1 << 23);\n\n                // scales down complete mantissa, hence losing least significant bits\n                final int mostSignificantLostBit = mantissa & (1 << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Float.intBitsToFloat(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0) ? 0.0f : -0.0f;\n            }\n        } else {\n            // we are really in the case n >= 128\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 23) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x007fffff;\n\n                if (scaledExponent < 255) {\nreturn Float.intBitsToFloat(((sign | (scaledExponent >> 23)) <= mantissa));                } else {\n                    return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 255) {\n                return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n            } else {\n                return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "8": "    public static float scalb(final float f, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -127) && (n < 128)) {\n            return f * Float.intBitsToFloat((n + 127) << 23);\n        }\n\n        // handle special cases\n        if (Float.isNaN(f) || Float.isInfinite(f) || (f == 0f)) {\n            return f;\n        }\n        if (n < -277) {\n            return (f > 0) ? 0.0f : -0.0f;\n        }\n        if (n > 276) {\n            return (f > 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n        }\n\n        // decompose f\n        final int bits = Float.floatToIntBits(f);\n        final int sign = bits & 0x80000000;\n        int  exponent  = (bits >>> 23) & 0xff;\n        int mantissa   = bits & 0x007fffff;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -127\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n            } else if (scaledExponent > -24) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\n                mantissa = mantissa | (1 << 23);\n\n                // scales down complete mantissa, hence losing least significant bits\n                final int mostSignificantLostBit = mantissa & (1 << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Float.intBitsToFloat(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0) ? 0.0f : -0.0f;\n            }\n        } else {\n            // we are really in the case n >= 128\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 23) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x007fffff;\n\n                if (scaledExponent < 255) {\nreturn Float.intBitsToFloat(((sign | (scaledExponent >> 23)) > mantissa));                } else {\n                    return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 255) {\n                return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n            } else {\n                return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "9": "    public static float scalb(final float f, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -127) && (n < 128)) {\n            return f * Float.intBitsToFloat((n + 127) << 23);\n        }\n\n        // handle special cases\n        if (Float.isNaN(f) || Float.isInfinite(f) || (f == 0f)) {\n            return f;\n        }\n        if (n < -277) {\n            return (f > 0) ? 0.0f : -0.0f;\n        }\n        if (n > 276) {\n            return (f > 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n        }\n\n        // decompose f\n        final int bits = Float.floatToIntBits(f);\n        final int sign = bits & 0x80000000;\n        int  exponent  = (bits >>> 23) & 0xff;\n        int mantissa   = bits & 0x007fffff;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -127\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n            } else if (scaledExponent > -24) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\n                mantissa = mantissa | (1 << 23);\n\n                // scales down complete mantissa, hence losing least significant bits\n                final int mostSignificantLostBit = mantissa & (1 << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Float.intBitsToFloat(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0) ? 0.0f : -0.0f;\n            }\n        } else {\n            // we are really in the case n >= 128\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 23) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x007fffff;\n\n                if (scaledExponent < 255) {\nreturn Float.intBitsToFloat(((sign | (scaledExponent & 23)) | mantissa));                } else {\n                    return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 255) {\n                return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n            } else {\n                return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "10": "    public static float scalb(final float f, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -127) && (n < 128)) {\n            return f * Float.intBitsToFloat((n + 127) << 23);\n        }\n\n        // handle special cases\n        if (Float.isNaN(f) || Float.isInfinite(f) || (f == 0f)) {\n            return f;\n        }\n        if (n < -277) {\n            return (f > 0) ? 0.0f : -0.0f;\n        }\n        if (n > 276) {\n            return (f > 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n        }\n\n        // decompose f\n        final int bits = Float.floatToIntBits(f);\n        final int sign = bits & 0x80000000;\n        int  exponent  = (bits >>> 23) & 0xff;\n        int mantissa   = bits & 0x007fffff;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -127\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n            } else if (scaledExponent > -24) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\n                mantissa = mantissa | (1 << 23);\n\n                // scales down complete mantissa, hence losing least significant bits\n                final int mostSignificantLostBit = mantissa & (1 << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Float.intBitsToFloat(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0) ? 0.0f : -0.0f;\n            }\n        } else {\n            // we are really in the case n >= 128\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 23) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x007fffff;\n\n                if (scaledExponent < 255) {\nreturn Float.intBitsToFloat(((sign | (scaledExponent >> 23)) & mantissa));                } else {\n                    return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 255) {\n                return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n            } else {\n                return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "11": "    public static float scalb(final float f, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -127) && (n < 128)) {\n            return f * Float.intBitsToFloat((n + 127) << 23);\n        }\n\n        // handle special cases\n        if (Float.isNaN(f) || Float.isInfinite(f) || (f == 0f)) {\n            return f;\n        }\n        if (n < -277) {\n            return (f > 0) ? 0.0f : -0.0f;\n        }\n        if (n > 276) {\n            return (f > 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n        }\n\n        // decompose f\n        final int bits = Float.floatToIntBits(f);\n        final int sign = bits & 0x80000000;\n        int  exponent  = (bits >>> 23) & 0xff;\n        int mantissa   = bits & 0x007fffff;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -127\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n            } else if (scaledExponent > -24) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\n                mantissa = mantissa | (1 << 23);\n\n                // scales down complete mantissa, hence losing least significant bits\n                final int mostSignificantLostBit = mantissa & (1 << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Float.intBitsToFloat(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0) ? 0.0f : -0.0f;\n            }\n        } else {\n            // we are really in the case n >= 128\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 23) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x007fffff;\n\n                if (scaledExponent < 255) {\n                } else {\n                    return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 255) {\n                return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n            } else {\n                return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "12": "    public static float scalb(final float f, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -127) && (n < 128)) {\n            return f * Float.intBitsToFloat((n + 127) << 23);\n        }\n\n        // handle special cases\n        if (Float.isNaN(f) || Float.isInfinite(f) || (f == 0f)) {\n            return f;\n        }\n        if (n < -277) {\n            return (f > 0) ? 0.0f : -0.0f;\n        }\n        if (n > 276) {\n            return (f > 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n        }\n\n        // decompose f\n        final int bits = Float.floatToIntBits(f);\n        final int sign = bits & 0x80000000;\n        int  exponent  = (bits >>> 23) & 0xff;\n        int mantissa   = bits & 0x007fffff;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -127\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n            } else if (scaledExponent > -24) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\n                mantissa = mantissa | (1 << 23);\n\n                // scales down complete mantissa, hence losing least significant bits\n                final int mostSignificantLostBit = mantissa & (1 << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Float.intBitsToFloat(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0) ? 0.0f : -0.0f;\n            }\n        } else {\n            // we are really in the case n >= 128\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 23) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x007fffff;\n\n                if (scaledExponent < 255) {\nreturn ((sign == 0))?0.0f:-0.0f;                } else {\n                    return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 255) {\n                return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n            } else {\n                return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "13": "    public static float scalb(final float f, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -127) && (n < 128)) {\n            return f * Float.intBitsToFloat((n + 127) << 23);\n        }\n\n        // handle special cases\n        if (Float.isNaN(f) || Float.isInfinite(f) || (f == 0f)) {\n            return f;\n        }\n        if (n < -277) {\n            return (f > 0) ? 0.0f : -0.0f;\n        }\n        if (n > 276) {\n            return (f > 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n        }\n\n        // decompose f\n        final int bits = Float.floatToIntBits(f);\n        final int sign = bits & 0x80000000;\n        int  exponent  = (bits >>> 23) & 0xff;\n        int mantissa   = bits & 0x007fffff;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -127\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n            } else if (scaledExponent > -24) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\n                mantissa = mantissa | (1 << 23);\n\n                // scales down complete mantissa, hence losing least significant bits\n                final int mostSignificantLostBit = mantissa & (1 << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Float.intBitsToFloat(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0) ? 0.0f : -0.0f;\n            }\n        } else {\n            // we are really in the case n >= 128\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 23) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x007fffff;\n\n                if (scaledExponent < 255) {\nreturn Float.intBitsToFloat(((sign | (scaledExponent >> 23)) >= mantissa));                } else {\n                    return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 255) {\n                return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n            } else {\n                return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "14": "    public static float scalb(final float f, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -127) && (n < 128)) {\n            return f * Float.intBitsToFloat((n + 127) << 23);\n        }\n\n        // handle special cases\n        if (Float.isNaN(f) || Float.isInfinite(f) || (f == 0f)) {\n            return f;\n        }\n        if (n < -277) {\n            return (f > 0) ? 0.0f : -0.0f;\n        }\n        if (n > 276) {\n            return (f > 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n        }\n\n        // decompose f\n        final int bits = Float.floatToIntBits(f);\n        final int sign = bits & 0x80000000;\n        int  exponent  = (bits >>> 23) & 0xff;\n        int mantissa   = bits & 0x007fffff;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -127\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n            } else if (scaledExponent > -24) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\n                mantissa = mantissa | (1 << 23);\n\n                // scales down complete mantissa, hence losing least significant bits\n                final int mostSignificantLostBit = mantissa & (1 << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Float.intBitsToFloat(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0) ? 0.0f : -0.0f;\n            }\n        } else {\n            // we are really in the case n >= 128\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 23) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x007fffff;\n\n                if (scaledExponent < 255) {\nreturn ((sign | (scaledExponent >> 23)) | mantissa);                } else {\n                    return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 255) {\n                return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n            } else {\n                return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "15": "    public static float scalb(final float f, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -127) && (n < 128)) {\n            return f * Float.intBitsToFloat((n + 127) << 23);\n        }\n\n        // handle special cases\n        if (Float.isNaN(f) || Float.isInfinite(f) || (f == 0f)) {\n            return f;\n        }\n        if (n < -277) {\n            return (f > 0) ? 0.0f : -0.0f;\n        }\n        if (n > 276) {\n            return (f > 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n        }\n\n        // decompose f\n        final int bits = Float.floatToIntBits(f);\n        final int sign = bits & 0x80000000;\n        int  exponent  = (bits >>> 23) & 0xff;\n        int mantissa   = bits & 0x007fffff;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -127\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n            } else if (scaledExponent > -24) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\n                mantissa = mantissa | (1 << 23);\n\n                // scales down complete mantissa, hence losing least significant bits\n                final int mostSignificantLostBit = mantissa & (1 << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Float.intBitsToFloat(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0) ? 0.0f : -0.0f;\n            }\n        } else {\n            // we are really in the case n >= 128\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 23) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x007fffff;\n\n                if (scaledExponent < 255) {\nreturn Float.intBitsToFloat(((sign | (scaledExponent | 23)) | mantissa));                } else {\n                    return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 255) {\n                return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n            } else {\n                return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "16": "    public static float scalb(final float f, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -127) && (n < 128)) {\n            return f * Float.intBitsToFloat((n + 127) << 23);\n        }\n\n        // handle special cases\n        if (Float.isNaN(f) || Float.isInfinite(f) || (f == 0f)) {\n            return f;\n        }\n        if (n < -277) {\n            return (f > 0) ? 0.0f : -0.0f;\n        }\n        if (n > 276) {\n            return (f > 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n        }\n\n        // decompose f\n        final int bits = Float.floatToIntBits(f);\n        final int sign = bits & 0x80000000;\n        int  exponent  = (bits >>> 23) & 0xff;\n        int mantissa   = bits & 0x007fffff;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -127\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n            } else if (scaledExponent > -24) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\n                mantissa = mantissa | (1 << 23);\n\n                // scales down complete mantissa, hence losing least significant bits\n                final int mostSignificantLostBit = mantissa & (1 << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Float.intBitsToFloat(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0) ? 0.0f : -0.0f;\n            }\n        } else {\n            // we are really in the case n >= 128\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 23) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x007fffff;\n\n                if (scaledExponent < 255) {\nreturn Float.intBitsToFloat(((sign | (scaledExponent - 23)) | mantissa));                } else {\n                    return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 255) {\n                return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n            } else {\n                return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "17": "    public static float scalb(final float f, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -127) && (n < 128)) {\n            return f * Float.intBitsToFloat((n + 127) << 23);\n        }\n\n        // handle special cases\n        if (Float.isNaN(f) || Float.isInfinite(f) || (f == 0f)) {\n            return f;\n        }\n        if (n < -277) {\n            return (f > 0) ? 0.0f : -0.0f;\n        }\n        if (n > 276) {\n            return (f > 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n        }\n\n        // decompose f\n        final int bits = Float.floatToIntBits(f);\n        final int sign = bits & 0x80000000;\n        int  exponent  = (bits >>> 23) & 0xff;\n        int mantissa   = bits & 0x007fffff;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -127\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n            } else if (scaledExponent > -24) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\n                mantissa = mantissa | (1 << 23);\n\n                // scales down complete mantissa, hence losing least significant bits\n                final int mostSignificantLostBit = mantissa & (1 << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Float.intBitsToFloat(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0) ? 0.0f : -0.0f;\n            }\n        } else {\n            // we are really in the case n >= 128\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 23) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x007fffff;\n\n                if (scaledExponent < 255) {\nreturn Float.intBitsToFloat(((sign | (scaledExponent >>> 23)) | mantissa));                } else {\n                    return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 255) {\n                return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n            } else {\n                return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "18": "    public static float scalb(final float f, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -127) && (n < 128)) {\n            return f * Float.intBitsToFloat((n + 127) << 23);\n        }\n\n        // handle special cases\n        if (Float.isNaN(f) || Float.isInfinite(f) || (f == 0f)) {\n            return f;\n        }\n        if (n < -277) {\n            return (f > 0) ? 0.0f : -0.0f;\n        }\n        if (n > 276) {\n            return (f > 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n        }\n\n        // decompose f\n        final int bits = Float.floatToIntBits(f);\n        final int sign = bits & 0x80000000;\n        int  exponent  = (bits >>> 23) & 0xff;\n        int mantissa   = bits & 0x007fffff;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -127\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n            } else if (scaledExponent > -24) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\n                mantissa = mantissa | (1 << 23);\n\n                // scales down complete mantissa, hence losing least significant bits\n                final int mostSignificantLostBit = mantissa & (1 << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Float.intBitsToFloat(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0) ? 0.0f : -0.0f;\n            }\n        } else {\n            // we are really in the case n >= 128\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 23) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x007fffff;\n\n                if (scaledExponent < 255) {\nreturn Float.intBitsToFloat(((sign | (scaledExponent == 23)) | mantissa));                } else {\n                    return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 255) {\n                return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n            } else {\n                return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "19": "    public static float scalb(final float f, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -127) && (n < 128)) {\n            return f * Float.intBitsToFloat((n + 127) << 23);\n        }\n\n        // handle special cases\n        if (Float.isNaN(f) || Float.isInfinite(f) || (f == 0f)) {\n            return f;\n        }\n        if (n < -277) {\n            return (f > 0) ? 0.0f : -0.0f;\n        }\n        if (n > 276) {\n            return (f > 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n        }\n\n        // decompose f\n        final int bits = Float.floatToIntBits(f);\n        final int sign = bits & 0x80000000;\n        int  exponent  = (bits >>> 23) & 0xff;\n        int mantissa   = bits & 0x007fffff;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -127\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n            } else if (scaledExponent > -24) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\n                mantissa = mantissa | (1 << 23);\n\n                // scales down complete mantissa, hence losing least significant bits\n                final int mostSignificantLostBit = mantissa & (1 << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Float.intBitsToFloat(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0) ? 0.0f : -0.0f;\n            }\n        } else {\n            // we are really in the case n >= 128\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 23) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x007fffff;\n\n                if (scaledExponent < 255) {\nreturn Float.intBitsToFloat(((sign | (scaledExponent >> 23)) | mantissa));                } else {\n                    return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 255) {\n                return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n            } else {\n                return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "20": "    public static float scalb(final float f, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -127) && (n < 128)) {\n            return f * Float.intBitsToFloat((n + 127) << 23);\n        }\n\n        // handle special cases\n        if (Float.isNaN(f) || Float.isInfinite(f) || (f == 0f)) {\n            return f;\n        }\n        if (n < -277) {\n            return (f > 0) ? 0.0f : -0.0f;\n        }\n        if (n > 276) {\n            return (f > 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n        }\n\n        // decompose f\n        final int bits = Float.floatToIntBits(f);\n        final int sign = bits & 0x80000000;\n        int  exponent  = (bits >>> 23) & 0xff;\n        int mantissa   = bits & 0x007fffff;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -127\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n            } else if (scaledExponent > -24) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\n                mantissa = mantissa | (1 << 23);\n\n                // scales down complete mantissa, hence losing least significant bits\n                final int mostSignificantLostBit = mantissa & (1 << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Float.intBitsToFloat(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0) ? 0.0f : -0.0f;\n            }\n        } else {\n            // we are really in the case n >= 128\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 23) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x007fffff;\n\n                if (scaledExponent < 255) {\nreturn Float.intBitsToFloat(((sign | (scaledExponent >> -1)) | mantissa));                } else {\n                    return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 255) {\n                return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n            } else {\n                return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "21": "    public static float scalb(final float f, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -127) && (n < 128)) {\n            return f * Float.intBitsToFloat((n + 127) << 23);\n        }\n\n        // handle special cases\n        if (Float.isNaN(f) || Float.isInfinite(f) || (f == 0f)) {\n            return f;\n        }\n        if (n < -277) {\n            return (f > 0) ? 0.0f : -0.0f;\n        }\n        if (n > 276) {\n            return (f > 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n        }\n\n        // decompose f\n        final int bits = Float.floatToIntBits(f);\n        final int sign = bits & 0x80000000;\n        int  exponent  = (bits >>> 23) & 0xff;\n        int mantissa   = bits & 0x007fffff;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -127\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n            } else if (scaledExponent > -24) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\n                mantissa = mantissa | (1 << 23);\n\n                // scales down complete mantissa, hence losing least significant bits\n                final int mostSignificantLostBit = mantissa & (1 << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Float.intBitsToFloat(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0) ? 0.0f : -0.0f;\n            }\n        } else {\n            // we are really in the case n >= 128\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 23) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x007fffff;\n\n                if (scaledExponent < 255) {\nmantissa = (mantissa & 0x007fffff);\n                    return Float.intBitsToFloat(sign | (scaledExponent >> 23) | mantissa);                } else {\n                    return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 255) {\n                return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n            } else {\n                return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "22": "    public static float scalb(final float f, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -127) && (n < 128)) {\n            return f * Float.intBitsToFloat((n + 127) << 23);\n        }\n\n        // handle special cases\n        if (Float.isNaN(f) || Float.isInfinite(f) || (f == 0f)) {\n            return f;\n        }\n        if (n < -277) {\n            return (f > 0) ? 0.0f : -0.0f;\n        }\n        if (n > 276) {\n            return (f > 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n        }\n\n        // decompose f\n        final int bits = Float.floatToIntBits(f);\n        final int sign = bits & 0x80000000;\n        int  exponent  = (bits >>> 23) & 0xff;\n        int mantissa   = bits & 0x007fffff;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -127\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n            } else if (scaledExponent > -24) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\n                mantissa = mantissa | (1 << 23);\n\n                // scales down complete mantissa, hence losing least significant bits\n                final int mostSignificantLostBit = mantissa & (1 << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Float.intBitsToFloat(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0) ? 0.0f : -0.0f;\n            }\n        } else {\n            // we are really in the case n >= 128\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 23) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x007fffff;\n\n                if (scaledExponent < 255) {\n++scaledExponent;\n                    return Float.intBitsToFloat(sign | (scaledExponent >> 23) | mantissa);                } else {\n                    return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 255) {\n                return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n            } else {\n                return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "23": "    public static float scalb(final float f, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -127) && (n < 128)) {\n            return f * Float.intBitsToFloat((n + 127) << 23);\n        }\n\n        // handle special cases\n        if (Float.isNaN(f) || Float.isInfinite(f) || (f == 0f)) {\n            return f;\n        }\n        if (n < -277) {\n            return (f > 0) ? 0.0f : -0.0f;\n        }\n        if (n > 276) {\n            return (f > 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n        }\n\n        // decompose f\n        final int bits = Float.floatToIntBits(f);\n        final int sign = bits & 0x80000000;\n        int  exponent  = (bits >>> 23) & 0xff;\n        int mantissa   = bits & 0x007fffff;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -127\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n            } else if (scaledExponent > -24) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\n                mantissa = mantissa | (1 << 23);\n\n                // scales down complete mantissa, hence losing least significant bits\n                final int mostSignificantLostBit = mantissa & (1 << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Float.intBitsToFloat(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0) ? 0.0f : -0.0f;\n            }\n        } else {\n            // we are really in the case n >= 128\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 23) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x007fffff;\n\n                if (scaledExponent < 255) {\nmantissa = (mantissa << 1);\n                    return Float.intBitsToFloat(sign | (scaledExponent >> 23) | mantissa);                } else {\n                    return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 255) {\n                return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n            } else {\n                return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "24": "    public static float scalb(final float f, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -127) && (n < 128)) {\n            return f * Float.intBitsToFloat((n + 127) << 23);\n        }\n\n        // handle special cases\n        if (Float.isNaN(f) || Float.isInfinite(f) || (f == 0f)) {\n            return f;\n        }\n        if (n < -277) {\n            return (f > 0) ? 0.0f : -0.0f;\n        }\n        if (n > 276) {\n            return (f > 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n        }\n\n        // decompose f\n        final int bits = Float.floatToIntBits(f);\n        final int sign = bits & 0x80000000;\n        int  exponent  = (bits >>> 23) & 0xff;\n        int mantissa   = bits & 0x007fffff;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -127\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n            } else if (scaledExponent > -24) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\n                mantissa = mantissa | (1 << 23);\n\n                // scales down complete mantissa, hence losing least significant bits\n                final int mostSignificantLostBit = mantissa & (1 << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Float.intBitsToFloat(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0) ? 0.0f : -0.0f;\n            }\n        } else {\n            // we are really in the case n >= 128\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 23) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x007fffff;\n\n                if (scaledExponent < 255) {\nreturn Float.intBitsToFloat(((sign | (scaledExponent >> 23)) - mantissa));                } else {\n                    return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 255) {\n                return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n            } else {\n                return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "25": "    public static float scalb(final float f, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -127) && (n < 128)) {\n            return f * Float.intBitsToFloat((n + 127) << 23);\n        }\n\n        // handle special cases\n        if (Float.isNaN(f) || Float.isInfinite(f) || (f == 0f)) {\n            return f;\n        }\n        if (n < -277) {\n            return (f > 0) ? 0.0f : -0.0f;\n        }\n        if (n > 276) {\n            return (f > 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n        }\n\n        // decompose f\n        final int bits = Float.floatToIntBits(f);\n        final int sign = bits & 0x80000000;\n        int  exponent  = (bits >>> 23) & 0xff;\n        int mantissa   = bits & 0x007fffff;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -127\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n            } else if (scaledExponent > -24) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\n                mantissa = mantissa | (1 << 23);\n\n                // scales down complete mantissa, hence losing least significant bits\n                final int mostSignificantLostBit = mantissa & (1 << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Float.intBitsToFloat(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0) ? 0.0f : -0.0f;\n            }\n        } else {\n            // we are really in the case n >= 128\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 23) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x007fffff;\n\n                if (scaledExponent < 255) {\n--scaledExponent;\n                    return Float.intBitsToFloat(sign | (scaledExponent >> 23) | mantissa);                } else {\n                    return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 255) {\n                return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n            } else {\n                return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "26": "    public static float scalb(final float f, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -127) && (n < 128)) {\n            return f * Float.intBitsToFloat((n + 127) << 23);\n        }\n\n        // handle special cases\n        if (Float.isNaN(f) || Float.isInfinite(f) || (f == 0f)) {\n            return f;\n        }\n        if (n < -277) {\n            return (f > 0) ? 0.0f : -0.0f;\n        }\n        if (n > 276) {\n            return (f > 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n        }\n\n        // decompose f\n        final int bits = Float.floatToIntBits(f);\n        final int sign = bits & 0x80000000;\n        int  exponent  = (bits >>> 23) & 0xff;\n        int mantissa   = bits & 0x007fffff;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -127\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n            } else if (scaledExponent > -24) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\n                mantissa = mantissa | (1 << 23);\n\n                // scales down complete mantissa, hence losing least significant bits\n                final int mostSignificantLostBit = mantissa & (1 << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Float.intBitsToFloat(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0) ? 0.0f : -0.0f;\n            }\n        } else {\n            // we are really in the case n >= 128\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 23) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x007fffff;\n\n                if (scaledExponent < 255) {\nreturn Float.intBitsToFloat(((sign | (scaledExponent >> 23)) >>> mantissa));                } else {\n                    return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 255) {\n                return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n            } else {\n                return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "27": "    public static float scalb(final float f, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -127) && (n < 128)) {\n            return f * Float.intBitsToFloat((n + 127) << 23);\n        }\n\n        // handle special cases\n        if (Float.isNaN(f) || Float.isInfinite(f) || (f == 0f)) {\n            return f;\n        }\n        if (n < -277) {\n            return (f > 0) ? 0.0f : -0.0f;\n        }\n        if (n > 276) {\n            return (f > 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n        }\n\n        // decompose f\n        final int bits = Float.floatToIntBits(f);\n        final int sign = bits & 0x80000000;\n        int  exponent  = (bits >>> 23) & 0xff;\n        int mantissa   = bits & 0x007fffff;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -127\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n            } else if (scaledExponent > -24) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\n                mantissa = mantissa | (1 << 23);\n\n                // scales down complete mantissa, hence losing least significant bits\n                final int mostSignificantLostBit = mantissa & (1 << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Float.intBitsToFloat(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0) ? 0.0f : -0.0f;\n            }\n        } else {\n            // we are really in the case n >= 128\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 23) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x007fffff;\n\n                if (scaledExponent < 255) {\nreturn Float.intBitsToFloat(((sign | (scaledExponent >> 23)) == mantissa));                } else {\n                    return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 255) {\n                return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n            } else {\n                return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "28": "    public static float scalb(final float f, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -127) && (n < 128)) {\n            return f * Float.intBitsToFloat((n + 127) << 23);\n        }\n\n        // handle special cases\n        if (Float.isNaN(f) || Float.isInfinite(f) || (f == 0f)) {\n            return f;\n        }\n        if (n < -277) {\n            return (f > 0) ? 0.0f : -0.0f;\n        }\n        if (n > 276) {\n            return (f > 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n        }\n\n        // decompose f\n        final int bits = Float.floatToIntBits(f);\n        final int sign = bits & 0x80000000;\n        int  exponent  = (bits >>> 23) & 0xff;\n        int mantissa   = bits & 0x007fffff;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -127\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n            } else if (scaledExponent > -24) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\n                mantissa = mantissa | (1 << 23);\n\n                // scales down complete mantissa, hence losing least significant bits\n                final int mostSignificantLostBit = mantissa & (1 << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Float.intBitsToFloat(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0) ? 0.0f : -0.0f;\n            }\n        } else {\n            // we are really in the case n >= 128\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 23) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x007fffff;\n\n                if (scaledExponent < 255) {\nreturn Float.intBitsToFloat((sign | mantissa));                } else {\n                    return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 255) {\n                return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n            } else {\n                return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "29": "    public static float scalb(final float f, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -127) && (n < 128)) {\n            return f * Float.intBitsToFloat((n + 127) << 23);\n        }\n\n        // handle special cases\n        if (Float.isNaN(f) || Float.isInfinite(f) || (f == 0f)) {\n            return f;\n        }\n        if (n < -277) {\n            return (f > 0) ? 0.0f : -0.0f;\n        }\n        if (n > 276) {\n            return (f > 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n        }\n\n        // decompose f\n        final int bits = Float.floatToIntBits(f);\n        final int sign = bits & 0x80000000;\n        int  exponent  = (bits >>> 23) & 0xff;\n        int mantissa   = bits & 0x007fffff;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -127\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n            } else if (scaledExponent > -24) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\n                mantissa = mantissa | (1 << 23);\n\n                // scales down complete mantissa, hence losing least significant bits\n                final int mostSignificantLostBit = mantissa & (1 << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Float.intBitsToFloat(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0) ? 0.0f : -0.0f;\n            }\n        } else {\n            // we are really in the case n >= 128\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 23) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x007fffff;\n\n                if (scaledExponent < 255) {\nreturn Float.intBitsToFloat(((sign | (scaledExponent >> -0.0f)) | mantissa));                } else {\n                    return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 255) {\n                return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n            } else {\n                return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "30": "    public static float scalb(final float f, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -127) && (n < 128)) {\n            return f * Float.intBitsToFloat((n + 127) << 23);\n        }\n\n        // handle special cases\n        if (Float.isNaN(f) || Float.isInfinite(f) || (f == 0f)) {\n            return f;\n        }\n        if (n < -277) {\n            return (f > 0) ? 0.0f : -0.0f;\n        }\n        if (n > 276) {\n            return (f > 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n        }\n\n        // decompose f\n        final int bits = Float.floatToIntBits(f);\n        final int sign = bits & 0x80000000;\n        int  exponent  = (bits >>> 23) & 0xff;\n        int mantissa   = bits & 0x007fffff;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -127\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n            } else if (scaledExponent > -24) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\n                mantissa = mantissa | (1 << 23);\n\n                // scales down complete mantissa, hence losing least significant bits\n                final int mostSignificantLostBit = mantissa & (1 << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Float.intBitsToFloat(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0) ? 0.0f : -0.0f;\n            }\n        } else {\n            // we are really in the case n >= 128\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 23) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x007fffff;\n\n                if (scaledExponent < 255) {\nreturn ((sign == 0))?0.0f:-0.0f;                    return Float.intBitsToFloat(sign | (scaledExponent >> 23) | mantissa);                } else {\n                    return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 255) {\n                return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n            } else {\n                return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "31": "    public static float scalb(final float f, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -127) && (n < 128)) {\n            return f * Float.intBitsToFloat((n + 127) << 23);\n        }\n\n        // handle special cases\n        if (Float.isNaN(f) || Float.isInfinite(f) || (f == 0f)) {\n            return f;\n        }\n        if (n < -277) {\n            return (f > 0) ? 0.0f : -0.0f;\n        }\n        if (n > 276) {\n            return (f > 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n        }\n\n        // decompose f\n        final int bits = Float.floatToIntBits(f);\n        final int sign = bits & 0x80000000;\n        int  exponent  = (bits >>> 23) & 0xff;\n        int mantissa   = bits & 0x007fffff;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -127\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n            } else if (scaledExponent > -24) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\n                mantissa = mantissa | (1 << 23);\n\n                // scales down complete mantissa, hence losing least significant bits\n                final int mostSignificantLostBit = mantissa & (1 << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Float.intBitsToFloat(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0) ? 0.0f : -0.0f;\n            }\n        } else {\n            // we are really in the case n >= 128\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 23) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x007fffff;\n\n                if (scaledExponent < 255) {\nreturn Float.intBitsToFloat(((sign | (scaledExponent >> 23)) >> mantissa));                } else {\n                    return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 255) {\n                return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n            } else {\n                return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "32": "    public static float scalb(final float f, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -127) && (n < 128)) {\n            return f * Float.intBitsToFloat((n + 127) << 23);\n        }\n\n        // handle special cases\n        if (Float.isNaN(f) || Float.isInfinite(f) || (f == 0f)) {\n            return f;\n        }\n        if (n < -277) {\n            return (f > 0) ? 0.0f : -0.0f;\n        }\n        if (n > 276) {\n            return (f > 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n        }\n\n        // decompose f\n        final int bits = Float.floatToIntBits(f);\n        final int sign = bits & 0x80000000;\n        int  exponent  = (bits >>> 23) & 0xff;\n        int mantissa   = bits & 0x007fffff;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -127\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n            } else if (scaledExponent > -24) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\n                mantissa = mantissa | (1 << 23);\n\n                // scales down complete mantissa, hence losing least significant bits\n                final int mostSignificantLostBit = mantissa & (1 << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Float.intBitsToFloat(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0) ? 0.0f : -0.0f;\n            }\n        } else {\n            // we are really in the case n >= 128\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 23) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x007fffff;\n\n                if (scaledExponent < 255) {\nmantissa = (mantissa | (1 << 23));\n                    return Float.intBitsToFloat(sign | (scaledExponent >> 23) | mantissa);                } else {\n                    return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 255) {\n                return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n            } else {\n                return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "33": "    public static float scalb(final float f, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -127) && (n < 128)) {\n            return f * Float.intBitsToFloat((n + 127) << 23);\n        }\n\n        // handle special cases\n        if (Float.isNaN(f) || Float.isInfinite(f) || (f == 0f)) {\n            return f;\n        }\n        if (n < -277) {\n            return (f > 0) ? 0.0f : -0.0f;\n        }\n        if (n > 276) {\n            return (f > 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n        }\n\n        // decompose f\n        final int bits = Float.floatToIntBits(f);\n        final int sign = bits & 0x80000000;\n        int  exponent  = (bits >>> 23) & 0xff;\n        int mantissa   = bits & 0x007fffff;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -127\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n            } else if (scaledExponent > -24) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\n                mantissa = mantissa | (1 << 23);\n\n                // scales down complete mantissa, hence losing least significant bits\n                final int mostSignificantLostBit = mantissa & (1 << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Float.intBitsToFloat(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0) ? 0.0f : -0.0f;\n            }\n        } else {\n            // we are really in the case n >= 128\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 23) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x007fffff;\n\n                if (scaledExponent < 255) {\nreturn Float.intBitsToFloat(((sign | (scaledExponent >> 23)) | mostSignificantLostBit));                } else {\n                    return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 255) {\n                return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n            } else {\n                return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "34": "    public static float scalb(final float f, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -127) && (n < 128)) {\n            return f * Float.intBitsToFloat((n + 127) << 23);\n        }\n\n        // handle special cases\n        if (Float.isNaN(f) || Float.isInfinite(f) || (f == 0f)) {\n            return f;\n        }\n        if (n < -277) {\n            return (f > 0) ? 0.0f : -0.0f;\n        }\n        if (n > 276) {\n            return (f > 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n        }\n\n        // decompose f\n        final int bits = Float.floatToIntBits(f);\n        final int sign = bits & 0x80000000;\n        int  exponent  = (bits >>> 23) & 0xff;\n        int mantissa   = bits & 0x007fffff;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -127\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n            } else if (scaledExponent > -24) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\n                mantissa = mantissa | (1 << 23);\n\n                // scales down complete mantissa, hence losing least significant bits\n                final int mostSignificantLostBit = mantissa & (1 << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Float.intBitsToFloat(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0) ? 0.0f : -0.0f;\n            }\n        } else {\n            // we are really in the case n >= 128\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 23) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x007fffff;\n\n                if (scaledExponent < 255) {\nreturn Float.intBitsToFloat(((sign | (scaledExponent >> 0.0f)) | mantissa));                } else {\n                    return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 255) {\n                return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n            } else {\n                return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "35": "    public static float scalb(final float f, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -127) && (n < 128)) {\n            return f * Float.intBitsToFloat((n + 127) << 23);\n        }\n\n        // handle special cases\n        if (Float.isNaN(f) || Float.isInfinite(f) || (f == 0f)) {\n            return f;\n        }\n        if (n < -277) {\n            return (f > 0) ? 0.0f : -0.0f;\n        }\n        if (n > 276) {\n            return (f > 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n        }\n\n        // decompose f\n        final int bits = Float.floatToIntBits(f);\n        final int sign = bits & 0x80000000;\n        int  exponent  = (bits >>> 23) & 0xff;\n        int mantissa   = bits & 0x007fffff;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -127\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n            } else if (scaledExponent > -24) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\n                mantissa = mantissa | (1 << 23);\n\n                // scales down complete mantissa, hence losing least significant bits\n                final int mostSignificantLostBit = mantissa & (1 << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Float.intBitsToFloat(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0) ? 0.0f : -0.0f;\n            }\n        } else {\n            // we are really in the case n >= 128\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 23) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x007fffff;\n\n                if (scaledExponent < 255) {\nmantissa++;\n                    return Float.intBitsToFloat(sign | (scaledExponent >> 23) | mantissa);                } else {\n                    return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 255) {\n                return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n            } else {\n                return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "36": "    public static float scalb(final float f, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -127) && (n < 128)) {\n            return f * Float.intBitsToFloat((n + 127) << 23);\n        }\n\n        // handle special cases\n        if (Float.isNaN(f) || Float.isInfinite(f) || (f == 0f)) {\n            return f;\n        }\n        if (n < -277) {\n            return (f > 0) ? 0.0f : -0.0f;\n        }\n        if (n > 276) {\n            return (f > 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n        }\n\n        // decompose f\n        final int bits = Float.floatToIntBits(f);\n        final int sign = bits & 0x80000000;\n        int  exponent  = (bits >>> 23) & 0xff;\n        int mantissa   = bits & 0x007fffff;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -127\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n            } else if (scaledExponent > -24) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\n                mantissa = mantissa | (1 << 23);\n\n                // scales down complete mantissa, hence losing least significant bits\n                final int mostSignificantLostBit = mantissa & (1 << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Float.intBitsToFloat(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0) ? 0.0f : -0.0f;\n            }\n        } else {\n            // we are really in the case n >= 128\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 23) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x007fffff;\n\n                if (scaledExponent < 255) {\nreturn (sign | (scaledExponent >> 23));                } else {\n                    return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 255) {\n                return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n            } else {\n                return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "37": "    public static float scalb(final float f, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -127) && (n < 128)) {\n            return f * Float.intBitsToFloat((n + 127) << 23);\n        }\n\n        // handle special cases\n        if (Float.isNaN(f) || Float.isInfinite(f) || (f == 0f)) {\n            return f;\n        }\n        if (n < -277) {\n            return (f > 0) ? 0.0f : -0.0f;\n        }\n        if (n > 276) {\n            return (f > 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n        }\n\n        // decompose f\n        final int bits = Float.floatToIntBits(f);\n        final int sign = bits & 0x80000000;\n        int  exponent  = (bits >>> 23) & 0xff;\n        int mantissa   = bits & 0x007fffff;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -127\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n            } else if (scaledExponent > -24) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\n                mantissa = mantissa | (1 << 23);\n\n                // scales down complete mantissa, hence losing least significant bits\n                final int mostSignificantLostBit = mantissa & (1 << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Float.intBitsToFloat(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0) ? 0.0f : -0.0f;\n            }\n        } else {\n            // we are really in the case n >= 128\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 23) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x007fffff;\n\n                if (scaledExponent < 255) {\nmantissa = (mantissa >>> (1 - scaledExponent));\n                    return Float.intBitsToFloat(sign | (scaledExponent >> 23) | mantissa);                } else {\n                    return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 255) {\n                return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n            } else {\n                return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "38": "    public static float scalb(final float f, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -127) && (n < 128)) {\n            return f * Float.intBitsToFloat((n + 127) << 23);\n        }\n\n        // handle special cases\n        if (Float.isNaN(f) || Float.isInfinite(f) || (f == 0f)) {\n            return f;\n        }\n        if (n < -277) {\n            return (f > 0) ? 0.0f : -0.0f;\n        }\n        if (n > 276) {\n            return (f > 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n        }\n\n        // decompose f\n        final int bits = Float.floatToIntBits(f);\n        final int sign = bits & 0x80000000;\n        int  exponent  = (bits >>> 23) & 0xff;\n        int mantissa   = bits & 0x007fffff;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -127\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n            } else if (scaledExponent > -24) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\n                mantissa = mantissa | (1 << 23);\n\n                // scales down complete mantissa, hence losing least significant bits\n                final int mostSignificantLostBit = mantissa & (1 << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Float.intBitsToFloat(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0) ? 0.0f : -0.0f;\n            }\n        } else {\n            // we are really in the case n >= 128\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 23) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x007fffff;\n\n                if (scaledExponent < 255) {\nreturn Float.intBitsToFloat(((sign | (scaledExponent >> 23)) | scaledExponent));                } else {\n                    return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 255) {\n                return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n            } else {\n                return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "39": "    public static float scalb(final float f, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -127) && (n < 128)) {\n            return f * Float.intBitsToFloat((n + 127) << 23);\n        }\n\n        // handle special cases\n        if (Float.isNaN(f) || Float.isInfinite(f) || (f == 0f)) {\n            return f;\n        }\n        if (n < -277) {\n            return (f > 0) ? 0.0f : -0.0f;\n        }\n        if (n > 276) {\n            return (f > 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n        }\n\n        // decompose f\n        final int bits = Float.floatToIntBits(f);\n        final int sign = bits & 0x80000000;\n        int  exponent  = (bits >>> 23) & 0xff;\n        int mantissa   = bits & 0x007fffff;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -127\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n            } else if (scaledExponent > -24) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\n                mantissa = mantissa | (1 << 23);\n\n                // scales down complete mantissa, hence losing least significant bits\n                final int mostSignificantLostBit = mantissa & (1 << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Float.intBitsToFloat(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0) ? 0.0f : -0.0f;\n            }\n        } else {\n            // we are really in the case n >= 128\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 23) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x007fffff;\n\n                if (scaledExponent < 255) {\nreturn Float.intBitsToFloat(((sign | (scaledExponent >> 23)) | sign));                } else {\n                    return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 255) {\n                return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n            } else {\n                return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "40": "    public static float scalb(final float f, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -127) && (n < 128)) {\n            return f * Float.intBitsToFloat((n + 127) << 23);\n        }\n\n        // handle special cases\n        if (Float.isNaN(f) || Float.isInfinite(f) || (f == 0f)) {\n            return f;\n        }\n        if (n < -277) {\n            return (f > 0) ? 0.0f : -0.0f;\n        }\n        if (n > 276) {\n            return (f > 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n        }\n\n        // decompose f\n        final int bits = Float.floatToIntBits(f);\n        final int sign = bits & 0x80000000;\n        int  exponent  = (bits >>> 23) & 0xff;\n        int mantissa   = bits & 0x007fffff;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -127\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n            } else if (scaledExponent > -24) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\n                mantissa = mantissa | (1 << 23);\n\n                // scales down complete mantissa, hence losing least significant bits\n                final int mostSignificantLostBit = mantissa & (1 << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Float.intBitsToFloat(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0) ? 0.0f : -0.0f;\n            }\n        } else {\n            // we are really in the case n >= 128\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 23) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x007fffff;\n\n                if (scaledExponent < 255) {\nreturn ((sign == 0))?Float.POSITIVE_INFINITY:Float.NEGATIVE_INFINITY;                } else {\n                    return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 255) {\n                return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n            } else {\n                return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "41": "    public static float scalb(final float f, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -127) && (n < 128)) {\n            return f * Float.intBitsToFloat((n + 127) << 23);\n        }\n\n        // handle special cases\n        if (Float.isNaN(f) || Float.isInfinite(f) || (f == 0f)) {\n            return f;\n        }\n        if (n < -277) {\n            return (f > 0) ? 0.0f : -0.0f;\n        }\n        if (n > 276) {\n            return (f > 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n        }\n\n        // decompose f\n        final int bits = Float.floatToIntBits(f);\n        final int sign = bits & 0x80000000;\n        int  exponent  = (bits >>> 23) & 0xff;\n        int mantissa   = bits & 0x007fffff;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -127\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n            } else if (scaledExponent > -24) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\n                mantissa = mantissa | (1 << 23);\n\n                // scales down complete mantissa, hence losing least significant bits\n                final int mostSignificantLostBit = mantissa & (1 << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Float.intBitsToFloat(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0) ? 0.0f : -0.0f;\n            }\n        } else {\n            // we are really in the case n >= 128\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 23) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x007fffff;\n\n                if (scaledExponent < 255) {\nreturn (scaledExponent >> 23);                } else {\n                    return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 255) {\n                return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n            } else {\n                return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "42": "    public static float scalb(final float f, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -127) && (n < 128)) {\n            return f * Float.intBitsToFloat((n + 127) << 23);\n        }\n\n        // handle special cases\n        if (Float.isNaN(f) || Float.isInfinite(f) || (f == 0f)) {\n            return f;\n        }\n        if (n < -277) {\n            return (f > 0) ? 0.0f : -0.0f;\n        }\n        if (n > 276) {\n            return (f > 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n        }\n\n        // decompose f\n        final int bits = Float.floatToIntBits(f);\n        final int sign = bits & 0x80000000;\n        int  exponent  = (bits >>> 23) & 0xff;\n        int mantissa   = bits & 0x007fffff;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -127\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n            } else if (scaledExponent > -24) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\n                mantissa = mantissa | (1 << 23);\n\n                // scales down complete mantissa, hence losing least significant bits\n                final int mostSignificantLostBit = mantissa & (1 << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Float.intBitsToFloat(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0) ? 0.0f : -0.0f;\n            }\n        } else {\n            // we are really in the case n >= 128\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 23) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x007fffff;\n\n                if (scaledExponent < 255) {\nreturn Float.intBitsToFloat((sign == 0));                } else {\n                    return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 255) {\n                return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n            } else {\n                return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "43": "    public static float scalb(final float f, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -127) && (n < 128)) {\n            return f * Float.intBitsToFloat((n + 127) << 23);\n        }\n\n        // handle special cases\n        if (Float.isNaN(f) || Float.isInfinite(f) || (f == 0f)) {\n            return f;\n        }\n        if (n < -277) {\n            return (f > 0) ? 0.0f : -0.0f;\n        }\n        if (n > 276) {\n            return (f > 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n        }\n\n        // decompose f\n        final int bits = Float.floatToIntBits(f);\n        final int sign = bits & 0x80000000;\n        int  exponent  = (bits >>> 23) & 0xff;\n        int mantissa   = bits & 0x007fffff;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -127\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n            } else if (scaledExponent > -24) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\n                mantissa = mantissa | (1 << 23);\n\n                // scales down complete mantissa, hence losing least significant bits\n                final int mostSignificantLostBit = mantissa & (1 << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Float.intBitsToFloat(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0) ? 0.0f : -0.0f;\n            }\n        } else {\n            // we are really in the case n >= 128\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 23) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x007fffff;\n\n                if (scaledExponent < 255) {\nreturn Float.intBitsToFloat(((sign | (scaledExponent >> -24)) | mantissa));                } else {\n                    return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 255) {\n                return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n            } else {\n                return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "44": "    public static float scalb(final float f, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -127) && (n < 128)) {\n            return f * Float.intBitsToFloat((n + 127) << 23);\n        }\n\n        // handle special cases\n        if (Float.isNaN(f) || Float.isInfinite(f) || (f == 0f)) {\n            return f;\n        }\n        if (n < -277) {\n            return (f > 0) ? 0.0f : -0.0f;\n        }\n        if (n > 276) {\n            return (f > 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n        }\n\n        // decompose f\n        final int bits = Float.floatToIntBits(f);\n        final int sign = bits & 0x80000000;\n        int  exponent  = (bits >>> 23) & 0xff;\n        int mantissa   = bits & 0x007fffff;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -127\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n            } else if (scaledExponent > -24) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\n                mantissa = mantissa | (1 << 23);\n\n                // scales down complete mantissa, hence losing least significant bits\n                final int mostSignificantLostBit = mantissa & (1 << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Float.intBitsToFloat(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0) ? 0.0f : -0.0f;\n            }\n        } else {\n            // we are really in the case n >= 128\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 23) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x007fffff;\n\n                if (scaledExponent < 255) {\nreturn Float.intBitsToFloat((mostSignificantLostBit != 0));                } else {\n                    return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 255) {\n                return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n            } else {\n                return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "45": "    public static float scalb(final float f, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -127) && (n < 128)) {\n            return f * Float.intBitsToFloat((n + 127) << 23);\n        }\n\n        // handle special cases\n        if (Float.isNaN(f) || Float.isInfinite(f) || (f == 0f)) {\n            return f;\n        }\n        if (n < -277) {\n            return (f > 0) ? 0.0f : -0.0f;\n        }\n        if (n > 276) {\n            return (f > 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n        }\n\n        // decompose f\n        final int bits = Float.floatToIntBits(f);\n        final int sign = bits & 0x80000000;\n        int  exponent  = (bits >>> 23) & 0xff;\n        int mantissa   = bits & 0x007fffff;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -127\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n            } else if (scaledExponent > -24) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\n                mantissa = mantissa | (1 << 23);\n\n                // scales down complete mantissa, hence losing least significant bits\n                final int mostSignificantLostBit = mantissa & (1 << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Float.intBitsToFloat(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0) ? 0.0f : -0.0f;\n            }\n        } else {\n            // we are really in the case n >= 128\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 23) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x007fffff;\n\n                if (scaledExponent < 255) {\nreturn Float.intBitsToFloat((sign | mantissa));                    return Float.intBitsToFloat(sign | (scaledExponent >> 23) | mantissa);                } else {\n                    return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 255) {\n                return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n            } else {\n                return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "46": "    public static float scalb(final float f, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -127) && (n < 128)) {\n            return f * Float.intBitsToFloat((n + 127) << 23);\n        }\n\n        // handle special cases\n        if (Float.isNaN(f) || Float.isInfinite(f) || (f == 0f)) {\n            return f;\n        }\n        if (n < -277) {\n            return (f > 0) ? 0.0f : -0.0f;\n        }\n        if (n > 276) {\n            return (f > 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n        }\n\n        // decompose f\n        final int bits = Float.floatToIntBits(f);\n        final int sign = bits & 0x80000000;\n        int  exponent  = (bits >>> 23) & 0xff;\n        int mantissa   = bits & 0x007fffff;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -127\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n            } else if (scaledExponent > -24) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\n                mantissa = mantissa | (1 << 23);\n\n                // scales down complete mantissa, hence losing least significant bits\n                final int mostSignificantLostBit = mantissa & (1 << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Float.intBitsToFloat(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0) ? 0.0f : -0.0f;\n            }\n        } else {\n            // we are really in the case n >= 128\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 23) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x007fffff;\n\n                if (scaledExponent < 255) {\nreturn Float.intBitsToFloat(((sign | (scaledExponent << 23)) | mantissa));                } else {\n                    return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 255) {\n                return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n            } else {\n                return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "47": "    public static float scalb(final float f, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -127) && (n < 128)) {\n            return f * Float.intBitsToFloat((n + 127) << 23);\n        }\n\n        // handle special cases\n        if (Float.isNaN(f) || Float.isInfinite(f) || (f == 0f)) {\n            return f;\n        }\n        if (n < -277) {\n            return (f > 0) ? 0.0f : -0.0f;\n        }\n        if (n > 276) {\n            return (f > 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n        }\n\n        // decompose f\n        final int bits = Float.floatToIntBits(f);\n        final int sign = bits & 0x80000000;\n        int  exponent  = (bits >>> 23) & 0xff;\n        int mantissa   = bits & 0x007fffff;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -127\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n            } else if (scaledExponent > -24) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\n                mantissa = mantissa | (1 << 23);\n\n                // scales down complete mantissa, hence losing least significant bits\n                final int mostSignificantLostBit = mantissa & (1 << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Float.intBitsToFloat(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0) ? 0.0f : -0.0f;\n            }\n        } else {\n            // we are really in the case n >= 128\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 23) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x007fffff;\n\n                if (scaledExponent < 255) {\nreturn Float.intBitsToFloat(((sign | (scaledExponent >> false)) | mantissa));                } else {\n                    return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 255) {\n                return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n            } else {\n                return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "48": "    public static float scalb(final float f, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -127) && (n < 128)) {\n            return f * Float.intBitsToFloat((n + 127) << 23);\n        }\n\n        // handle special cases\n        if (Float.isNaN(f) || Float.isInfinite(f) || (f == 0f)) {\n            return f;\n        }\n        if (n < -277) {\n            return (f > 0) ? 0.0f : -0.0f;\n        }\n        if (n > 276) {\n            return (f > 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n        }\n\n        // decompose f\n        final int bits = Float.floatToIntBits(f);\n        final int sign = bits & 0x80000000;\n        int  exponent  = (bits >>> 23) & 0xff;\n        int mantissa   = bits & 0x007fffff;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -127\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n            } else if (scaledExponent > -24) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\n                mantissa = mantissa | (1 << 23);\n\n                // scales down complete mantissa, hence losing least significant bits\n                final int mostSignificantLostBit = mantissa & (1 << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Float.intBitsToFloat(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0) ? 0.0f : -0.0f;\n            }\n        } else {\n            // we are really in the case n >= 128\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 23) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x007fffff;\n\n                if (scaledExponent < 255) {\nreturn Float.intBitsToFloat(((mostSignificantLostBit | (scaledExponent >> 23)) | mantissa));                } else {\n                    return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 255) {\n                return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n            } else {\n                return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "49": "    public static float scalb(final float f, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -127) && (n < 128)) {\n            return f * Float.intBitsToFloat((n + 127) << 23);\n        }\n\n        // handle special cases\n        if (Float.isNaN(f) || Float.isInfinite(f) || (f == 0f)) {\n            return f;\n        }\n        if (n < -277) {\n            return (f > 0) ? 0.0f : -0.0f;\n        }\n        if (n > 276) {\n            return (f > 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n        }\n\n        // decompose f\n        final int bits = Float.floatToIntBits(f);\n        final int sign = bits & 0x80000000;\n        int  exponent  = (bits >>> 23) & 0xff;\n        int mantissa   = bits & 0x007fffff;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -127\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n            } else if (scaledExponent > -24) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\n                mantissa = mantissa | (1 << 23);\n\n                // scales down complete mantissa, hence losing least significant bits\n                final int mostSignificantLostBit = mantissa & (1 << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Float.intBitsToFloat(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0) ? 0.0f : -0.0f;\n            }\n        } else {\n            // we are really in the case n >= 128\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 23) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x007fffff;\n\n                if (scaledExponent < 255) {\nreturn Float.intBitsToFloat((mantissa >>> (1 - scaledExponent)));                } else {\n                    return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 255) {\n                return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n            } else {\n                return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "50": "    public static float scalb(final float f, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -127) && (n < 128)) {\n            return f * Float.intBitsToFloat((n + 127) << 23);\n        }\n\n        // handle special cases\n        if (Float.isNaN(f) || Float.isInfinite(f) || (f == 0f)) {\n            return f;\n        }\n        if (n < -277) {\n            return (f > 0) ? 0.0f : -0.0f;\n        }\n        if (n > 276) {\n            return (f > 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n        }\n\n        // decompose f\n        final int bits = Float.floatToIntBits(f);\n        final int sign = bits & 0x80000000;\n        int  exponent  = (bits >>> 23) & 0xff;\n        int mantissa   = bits & 0x007fffff;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -127\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n            } else if (scaledExponent > -24) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\n                mantissa = mantissa | (1 << 23);\n\n                // scales down complete mantissa, hence losing least significant bits\n                final int mostSignificantLostBit = mantissa & (1 << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Float.intBitsToFloat(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0) ? 0.0f : -0.0f;\n            }\n        } else {\n            // we are really in the case n >= 128\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 23) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x007fffff;\n\n                if (scaledExponent < 255) {\nreturn Float.intBitsToFloat((mantissa & (1 << scaledExponent)));                } else {\n                    return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 255) {\n                return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n            } else {\n                return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "51": "    public static float scalb(final float f, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -127) && (n < 128)) {\n            return f * Float.intBitsToFloat((n + 127) << 23);\n        }\n\n        // handle special cases\n        if (Float.isNaN(f) || Float.isInfinite(f) || (f == 0f)) {\n            return f;\n        }\n        if (n < -277) {\n            return (f > 0) ? 0.0f : -0.0f;\n        }\n        if (n > 276) {\n            return (f > 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n        }\n\n        // decompose f\n        final int bits = Float.floatToIntBits(f);\n        final int sign = bits & 0x80000000;\n        int  exponent  = (bits >>> 23) & 0xff;\n        int mantissa   = bits & 0x007fffff;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -127\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n            } else if (scaledExponent > -24) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\n                mantissa = mantissa | (1 << 23);\n\n                // scales down complete mantissa, hence losing least significant bits\n                final int mostSignificantLostBit = mantissa & (1 << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Float.intBitsToFloat(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0) ? 0.0f : -0.0f;\n            }\n        } else {\n            // we are really in the case n >= 128\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 23) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x007fffff;\n\n                if (scaledExponent < 255) {\nreturn Float.intBitsToFloat(((sign | (scaledExponent >> true)) | mantissa));                } else {\n                    return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 255) {\n                return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n            } else {\n                return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "52": "    public static float scalb(final float f, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -127) && (n < 128)) {\n            return f * Float.intBitsToFloat((n + 127) << 23);\n        }\n\n        // handle special cases\n        if (Float.isNaN(f) || Float.isInfinite(f) || (f == 0f)) {\n            return f;\n        }\n        if (n < -277) {\n            return (f > 0) ? 0.0f : -0.0f;\n        }\n        if (n > 276) {\n            return (f > 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n        }\n\n        // decompose f\n        final int bits = Float.floatToIntBits(f);\n        final int sign = bits & 0x80000000;\n        int  exponent  = (bits >>> 23) & 0xff;\n        int mantissa   = bits & 0x007fffff;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -127\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n            } else if (scaledExponent > -24) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\n                mantissa = mantissa | (1 << 23);\n\n                // scales down complete mantissa, hence losing least significant bits\n                final int mostSignificantLostBit = mantissa & (1 << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Float.intBitsToFloat(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0) ? 0.0f : -0.0f;\n            }\n        } else {\n            // we are really in the case n >= 128\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 23) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x007fffff;\n\n                if (scaledExponent < 255) {\nreturn Float.intBitsToFloat(((sign + (scaledExponent >> 23)) | mantissa));                } else {\n                    return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 255) {\n                return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n            } else {\n                return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "53": "    public static float scalb(final float f, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -127) && (n < 128)) {\n            return f * Float.intBitsToFloat((n + 127) << 23);\n        }\n\n        // handle special cases\n        if (Float.isNaN(f) || Float.isInfinite(f) || (f == 0f)) {\n            return f;\n        }\n        if (n < -277) {\n            return (f > 0) ? 0.0f : -0.0f;\n        }\n        if (n > 276) {\n            return (f > 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n        }\n\n        // decompose f\n        final int bits = Float.floatToIntBits(f);\n        final int sign = bits & 0x80000000;\n        int  exponent  = (bits >>> 23) & 0xff;\n        int mantissa   = bits & 0x007fffff;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -127\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n            } else if (scaledExponent > -24) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\n                mantissa = mantissa | (1 << 23);\n\n                // scales down complete mantissa, hence losing least significant bits\n                final int mostSignificantLostBit = mantissa & (1 << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Float.intBitsToFloat(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0) ? 0.0f : -0.0f;\n            }\n        } else {\n            // we are really in the case n >= 128\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 23) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x007fffff;\n\n                if (scaledExponent < 255) {\nreturn Float.intBitsToFloat(((sign | (scaledExponent >> 0)) | mantissa));                } else {\n                    return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 255) {\n                return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n            } else {\n                return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "54": "    public static float scalb(final float f, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -127) && (n < 128)) {\n            return f * Float.intBitsToFloat((n + 127) << 23);\n        }\n\n        // handle special cases\n        if (Float.isNaN(f) || Float.isInfinite(f) || (f == 0f)) {\n            return f;\n        }\n        if (n < -277) {\n            return (f > 0) ? 0.0f : -0.0f;\n        }\n        if (n > 276) {\n            return (f > 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n        }\n\n        // decompose f\n        final int bits = Float.floatToIntBits(f);\n        final int sign = bits & 0x80000000;\n        int  exponent  = (bits >>> 23) & 0xff;\n        int mantissa   = bits & 0x007fffff;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -127\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n            } else if (scaledExponent > -24) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\n                mantissa = mantissa | (1 << 23);\n\n                // scales down complete mantissa, hence losing least significant bits\n                final int mostSignificantLostBit = mantissa & (1 << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Float.intBitsToFloat(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0) ? 0.0f : -0.0f;\n            }\n        } else {\n            // we are really in the case n >= 128\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 23) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x007fffff;\n\n                if (scaledExponent < 255) {\nreturn Float.intBitsToFloat(mantissa);                } else {\n                    return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 255) {\n                return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n            } else {\n                return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "55": "    public static float scalb(final float f, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -127) && (n < 128)) {\n            return f * Float.intBitsToFloat((n + 127) << 23);\n        }\n\n        // handle special cases\n        if (Float.isNaN(f) || Float.isInfinite(f) || (f == 0f)) {\n            return f;\n        }\n        if (n < -277) {\n            return (f > 0) ? 0.0f : -0.0f;\n        }\n        if (n > 276) {\n            return (f > 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n        }\n\n        // decompose f\n        final int bits = Float.floatToIntBits(f);\n        final int sign = bits & 0x80000000;\n        int  exponent  = (bits >>> 23) & 0xff;\n        int mantissa   = bits & 0x007fffff;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -127\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n            } else if (scaledExponent > -24) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\n                mantissa = mantissa | (1 << 23);\n\n                // scales down complete mantissa, hence losing least significant bits\n                final int mostSignificantLostBit = mantissa & (1 << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Float.intBitsToFloat(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0) ? 0.0f : -0.0f;\n            }\n        } else {\n            // we are really in the case n >= 128\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 23) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x007fffff;\n\n                if (scaledExponent < 255) {\nbreak;\n                    return Float.intBitsToFloat(sign | (scaledExponent >> 23) | mantissa);                } else {\n                    return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 255) {\n                return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n            } else {\n                return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "56": "    public static float scalb(final float f, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -127) && (n < 128)) {\n            return f * Float.intBitsToFloat((n + 127) << 23);\n        }\n\n        // handle special cases\n        if (Float.isNaN(f) || Float.isInfinite(f) || (f == 0f)) {\n            return f;\n        }\n        if (n < -277) {\n            return (f > 0) ? 0.0f : -0.0f;\n        }\n        if (n > 276) {\n            return (f > 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n        }\n\n        // decompose f\n        final int bits = Float.floatToIntBits(f);\n        final int sign = bits & 0x80000000;\n        int  exponent  = (bits >>> 23) & 0xff;\n        int mantissa   = bits & 0x007fffff;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -127\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n            } else if (scaledExponent > -24) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\n                mantissa = mantissa | (1 << 23);\n\n                // scales down complete mantissa, hence losing least significant bits\n                final int mostSignificantLostBit = mantissa & (1 << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Float.intBitsToFloat(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0) ? 0.0f : -0.0f;\n            }\n        } else {\n            // we are really in the case n >= 128\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 23) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x007fffff;\n\n                if (scaledExponent < 255) {\nreturn;\n                    return Float.intBitsToFloat(sign | (scaledExponent >> 23) | mantissa);                } else {\n                    return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 255) {\n                return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n            } else {\n                return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n            }\n        }\n\n    }"
}