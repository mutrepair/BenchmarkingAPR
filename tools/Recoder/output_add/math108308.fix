{
          "0": "    private static int gcdPositive(int a,\n                                   int b) {\n        if (a == 0) {\n            return b;\n        }\n        else if (b == 0) {\n            return a;\n        }\n\n        // Make \"a\" and \"b\" odd, keeping track of common power of 2.\n        final int aTwos = Integer.numberOfTrailingZeros(a);\n        a >>= aTwos;\n        final int bTwos = Integer.numberOfTrailingZeros(b);\n        b >>= bTwos;\n        final int shift = Math.min(aTwos, bTwos);\n\n        // \"a\" and \"b\" are positive.\n        // If a > b then \"gdc(a, b)\" is equal to \"gcd(a - b, b)\".\n        // If a < b then \"gcd(a, b)\" is equal to \"gcd(b - a, a)\".\n        // Hence, in the successive iterations:\n        //  \"a\" becomes the absolute difference of the current values,\n        //  \"b\" becomes the minimum of the current values.\n        while (a != b) {\n            final int delta = a - b;\n            b = Math.min(a, b);\n            a = Math.abs(delta);\n\n            // Remove any power of 2 in \"a\" (\"b\" is guaranteed to be odd).\n            a >>= Integer.numberOfTrailingZeros(a);\n        }\n\n        // Recover the common power of 2.\nb = Math.min(a, b);\n        return a >>> shift;    }",
          "1": "    private static int gcdPositive(int a,\n                                   int b) {\n        if (a == 0) {\n            return b;\n        }\n        else if (b == 0) {\n            return a;\n        }\n\n        // Make \"a\" and \"b\" odd, keeping track of common power of 2.\n        final int aTwos = Integer.numberOfTrailingZeros(a);\n        a >>= aTwos;\n        final int bTwos = Integer.numberOfTrailingZeros(b);\n        b >>= bTwos;\n        final int shift = Math.min(aTwos, bTwos);\n\n        // \"a\" and \"b\" are positive.\n        // If a > b then \"gdc(a, b)\" is equal to \"gcd(a - b, b)\".\n        // If a < b then \"gcd(a, b)\" is equal to \"gcd(b - a, a)\".\n        // Hence, in the successive iterations:\n        //  \"a\" becomes the absolute difference of the current values,\n        //  \"b\" becomes the minimum of the current values.\n        while (a != b) {\n            final int delta = a - b;\n            b = Math.min(a, b);\n            a = Math.abs(delta);\n\n            // Remove any power of 2 in \"a\" (\"b\" is guaranteed to be odd).\n            a >>= Integer.numberOfTrailingZeros(a);\n        }\n\n        // Recover the common power of 2.\nb >>= bTwos;\n        return a >>> shift;    }",
          "2": "    private static int gcdPositive(int a,\n                                   int b) {\n        if (a == 0) {\n            return b;\n        }\n        else if (b == 0) {\n            return a;\n        }\n\n        // Make \"a\" and \"b\" odd, keeping track of common power of 2.\n        final int aTwos = Integer.numberOfTrailingZeros(a);\n        a >>= aTwos;\n        final int bTwos = Integer.numberOfTrailingZeros(b);\n        b >>= bTwos;\n        final int shift = Math.min(aTwos, bTwos);\n\n        // \"a\" and \"b\" are positive.\n        // If a > b then \"gdc(a, b)\" is equal to \"gcd(a - b, b)\".\n        // If a < b then \"gcd(a, b)\" is equal to \"gcd(b - a, a)\".\n        // Hence, in the successive iterations:\n        //  \"a\" becomes the absolute difference of the current values,\n        //  \"b\" becomes the minimum of the current values.\n        while (a != b) {\n            final int delta = a - b;\n            b = Math.min(a, b);\n            a = Math.abs(delta);\n\n            // Remove any power of 2 in \"a\" (\"b\" is guaranteed to be odd).\n            a >>= Integer.numberOfTrailingZeros(a);\n        }\n\n        // Recover the common power of 2.\na >>= aTwos;\n        return a >>> shift;    }",
          "3": "    private static int gcdPositive(int a,\n                                   int b) {\n        if (a == 0) {\n            return b;\n        }\n        else if (b == 0) {\n            return a;\n        }\n\n        // Make \"a\" and \"b\" odd, keeping track of common power of 2.\n        final int aTwos = Integer.numberOfTrailingZeros(a);\n        a >>= aTwos;\n        final int bTwos = Integer.numberOfTrailingZeros(b);\n        b >>= bTwos;\n        final int shift = Math.min(aTwos, bTwos);\n\n        // \"a\" and \"b\" are positive.\n        // If a > b then \"gdc(a, b)\" is equal to \"gcd(a - b, b)\".\n        // If a < b then \"gcd(a, b)\" is equal to \"gcd(b - a, a)\".\n        // Hence, in the successive iterations:\n        //  \"a\" becomes the absolute difference of the current values,\n        //  \"b\" becomes the minimum of the current values.\n        while (a != b) {\n            final int delta = a - b;\n            b = Math.min(a, b);\n            a = Math.abs(delta);\n\n            // Remove any power of 2 in \"a\" (\"b\" is guaranteed to be odd).\n            a >>= Integer.numberOfTrailingZeros(a);\n        }\n\n        // Recover the common power of 2.\na = Math.abs(delta);\n        return a >>> shift;    }",
          "4": "    private static int gcdPositive(int a,\n                                   int b) {\n        if (a == 0) {\n            return b;\n        }\n        else if (b == 0) {\n            return a;\n        }\n\n        // Make \"a\" and \"b\" odd, keeping track of common power of 2.\n        final int aTwos = Integer.numberOfTrailingZeros(a);\n        a >>= aTwos;\n        final int bTwos = Integer.numberOfTrailingZeros(b);\n        b >>= bTwos;\n        final int shift = Math.min(aTwos, bTwos);\n\n        // \"a\" and \"b\" are positive.\n        // If a > b then \"gdc(a, b)\" is equal to \"gcd(a - b, b)\".\n        // If a < b then \"gcd(a, b)\" is equal to \"gcd(b - a, a)\".\n        // Hence, in the successive iterations:\n        //  \"a\" becomes the absolute difference of the current values,\n        //  \"b\" becomes the minimum of the current values.\n        while (a != b) {\n            final int delta = a - b;\n            b = Math.min(a, b);\n            a = Math.abs(delta);\n\n            // Remove any power of 2 in \"a\" (\"b\" is guaranteed to be odd).\n            a >>= Integer.numberOfTrailingZeros(a);\n        }\n\n        // Recover the common power of 2.\nreturn (a >>> shift);    }",
          "5": "    private static int gcdPositive(int a,\n                                   int b) {\n        if (a == 0) {\n            return b;\n        }\n        else if (b == 0) {\n            return a;\n        }\n\n        // Make \"a\" and \"b\" odd, keeping track of common power of 2.\n        final int aTwos = Integer.numberOfTrailingZeros(a);\n        a >>= aTwos;\n        final int bTwos = Integer.numberOfTrailingZeros(b);\n        b >>= bTwos;\n        final int shift = Math.min(aTwos, bTwos);\n\n        // \"a\" and \"b\" are positive.\n        // If a > b then \"gdc(a, b)\" is equal to \"gcd(a - b, b)\".\n        // If a < b then \"gcd(a, b)\" is equal to \"gcd(b - a, a)\".\n        // Hence, in the successive iterations:\n        //  \"a\" becomes the absolute difference of the current values,\n        //  \"b\" becomes the minimum of the current values.\n        while (a != b) {\n            final int delta = a - b;\n            b = Math.min(a, b);\n            a = Math.abs(delta);\n\n            // Remove any power of 2 in \"a\" (\"b\" is guaranteed to be odd).\n            a >>= Integer.numberOfTrailingZeros(a);\n        }\n\n        // Recover the common power of 2.\na >>= Integer.numberOfTrailingZeros(a);\n        return a >>> shift;    }",
          "6": "    private static int gcdPositive(int a,\n                                   int b) {\n        if (a == 0) {\n            return b;\n        }\n        else if (b == 0) {\n            return a;\n        }\n\n        // Make \"a\" and \"b\" odd, keeping track of common power of 2.\n        final int aTwos = Integer.numberOfTrailingZeros(a);\n        a >>= aTwos;\n        final int bTwos = Integer.numberOfTrailingZeros(b);\n        b >>= bTwos;\n        final int shift = Math.min(aTwos, bTwos);\n\n        // \"a\" and \"b\" are positive.\n        // If a > b then \"gdc(a, b)\" is equal to \"gcd(a - b, b)\".\n        // If a < b then \"gcd(a, b)\" is equal to \"gcd(b - a, a)\".\n        // Hence, in the successive iterations:\n        //  \"a\" becomes the absolute difference of the current values,\n        //  \"b\" becomes the minimum of the current values.\n        while (a != b) {\n            final int delta = a - b;\n            b = Math.min(a, b);\n            a = Math.abs(delta);\n\n            // Remove any power of 2 in \"a\" (\"b\" is guaranteed to be odd).\n            a >>= Integer.numberOfTrailingZeros(a);\n        }\n\n        // Recover the common power of 2.\nreturn (shift >>> shift);    }",
          "7": "    private static int gcdPositive(int a,\n                                   int b) {\n        if (a == 0) {\n            return b;\n        }\n        else if (b == 0) {\n            return a;\n        }\n\n        // Make \"a\" and \"b\" odd, keeping track of common power of 2.\n        final int aTwos = Integer.numberOfTrailingZeros(a);\n        a >>= aTwos;\n        final int bTwos = Integer.numberOfTrailingZeros(b);\n        b >>= bTwos;\n        final int shift = Math.min(aTwos, bTwos);\n\n        // \"a\" and \"b\" are positive.\n        // If a > b then \"gdc(a, b)\" is equal to \"gcd(a - b, b)\".\n        // If a < b then \"gcd(a, b)\" is equal to \"gcd(b - a, a)\".\n        // Hence, in the successive iterations:\n        //  \"a\" becomes the absolute difference of the current values,\n        //  \"b\" becomes the minimum of the current values.\n        while (a != b) {\n            final int delta = a - b;\n            b = Math.min(a, b);\n            a = Math.abs(delta);\n\n            // Remove any power of 2 in \"a\" (\"b\" is guaranteed to be odd).\n            a >>= Integer.numberOfTrailingZeros(a);\n        }\n\n        // Recover the common power of 2.\nreturn (bTwos >>> shift);    }",
          "8": "    private static int gcdPositive(int a,\n                                   int b) {\n        if (a == 0) {\n            return b;\n        }\n        else if (b == 0) {\n            return a;\n        }\n\n        // Make \"a\" and \"b\" odd, keeping track of common power of 2.\n        final int aTwos = Integer.numberOfTrailingZeros(a);\n        a >>= aTwos;\n        final int bTwos = Integer.numberOfTrailingZeros(b);\n        b >>= bTwos;\n        final int shift = Math.min(aTwos, bTwos);\n\n        // \"a\" and \"b\" are positive.\n        // If a > b then \"gdc(a, b)\" is equal to \"gcd(a - b, b)\".\n        // If a < b then \"gcd(a, b)\" is equal to \"gcd(b - a, a)\".\n        // Hence, in the successive iterations:\n        //  \"a\" becomes the absolute difference of the current values,\n        //  \"b\" becomes the minimum of the current values.\n        while (a != b) {\n            final int delta = a - b;\n            b = Math.min(a, b);\n            a = Math.abs(delta);\n\n            // Remove any power of 2 in \"a\" (\"b\" is guaranteed to be odd).\n            a >>= Integer.numberOfTrailingZeros(a);\n        }\n\n        // Recover the common power of 2.\nreturn (a <= shift);    }",
          "9": "    private static int gcdPositive(int a,\n                                   int b) {\n        if (a == 0) {\n            return b;\n        }\n        else if (b == 0) {\n            return a;\n        }\n\n        // Make \"a\" and \"b\" odd, keeping track of common power of 2.\n        final int aTwos = Integer.numberOfTrailingZeros(a);\n        a >>= aTwos;\n        final int bTwos = Integer.numberOfTrailingZeros(b);\n        b >>= bTwos;\n        final int shift = Math.min(aTwos, bTwos);\n\n        // \"a\" and \"b\" are positive.\n        // If a > b then \"gdc(a, b)\" is equal to \"gcd(a - b, b)\".\n        // If a < b then \"gcd(a, b)\" is equal to \"gcd(b - a, a)\".\n        // Hence, in the successive iterations:\n        //  \"a\" becomes the absolute difference of the current values,\n        //  \"b\" becomes the minimum of the current values.\n        while (a != b) {\n            final int delta = a - b;\n            b = Math.min(a, b);\n            a = Math.abs(delta);\n\n            // Remove any power of 2 in \"a\" (\"b\" is guaranteed to be odd).\n            a >>= Integer.numberOfTrailingZeros(a);\n        }\n\n        // Recover the common power of 2.\nreturn (delta >>> shift);    }",
          "10": "    private static int gcdPositive(int a,\n                                   int b) {\n        if (a == 0) {\n            return b;\n        }\n        else if (b == 0) {\n            return a;\n        }\n\n        // Make \"a\" and \"b\" odd, keeping track of common power of 2.\n        final int aTwos = Integer.numberOfTrailingZeros(a);\n        a >>= aTwos;\n        final int bTwos = Integer.numberOfTrailingZeros(b);\n        b >>= bTwos;\n        final int shift = Math.min(aTwos, bTwos);\n\n        // \"a\" and \"b\" are positive.\n        // If a > b then \"gdc(a, b)\" is equal to \"gcd(a - b, b)\".\n        // If a < b then \"gcd(a, b)\" is equal to \"gcd(b - a, a)\".\n        // Hence, in the successive iterations:\n        //  \"a\" becomes the absolute difference of the current values,\n        //  \"b\" becomes the minimum of the current values.\n        while (a != b) {\n            final int delta = a - b;\n            b = Math.min(a, b);\n            a = Math.abs(delta);\n\n            // Remove any power of 2 in \"a\" (\"b\" is guaranteed to be odd).\n            a >>= Integer.numberOfTrailingZeros(a);\n        }\n\n        // Recover the common power of 2.\nreturn (a - shift);    }",
          "11": "    private static int gcdPositive(int a,\n                                   int b) {\n        if (a == 0) {\n            return b;\n        }\n        else if (b == 0) {\n            return a;\n        }\n\n        // Make \"a\" and \"b\" odd, keeping track of common power of 2.\n        final int aTwos = Integer.numberOfTrailingZeros(a);\n        a >>= aTwos;\n        final int bTwos = Integer.numberOfTrailingZeros(b);\n        b >>= bTwos;\n        final int shift = Math.min(aTwos, bTwos);\n\n        // \"a\" and \"b\" are positive.\n        // If a > b then \"gdc(a, b)\" is equal to \"gcd(a - b, b)\".\n        // If a < b then \"gcd(a, b)\" is equal to \"gcd(b - a, a)\".\n        // Hence, in the successive iterations:\n        //  \"a\" becomes the absolute difference of the current values,\n        //  \"b\" becomes the minimum of the current values.\n        while (a != b) {\n            final int delta = a - b;\n            b = Math.min(a, b);\n            a = Math.abs(delta);\n\n            // Remove any power of 2 in \"a\" (\"b\" is guaranteed to be odd).\n            a >>= Integer.numberOfTrailingZeros(a);\n        }\n\n        // Recover the common power of 2.\n    }",
          "12": "    private static int gcdPositive(int a,\n                                   int b) {\n        if (a == 0) {\n            return b;\n        }\n        else if (b == 0) {\n            return a;\n        }\n\n        // Make \"a\" and \"b\" odd, keeping track of common power of 2.\n        final int aTwos = Integer.numberOfTrailingZeros(a);\n        a >>= aTwos;\n        final int bTwos = Integer.numberOfTrailingZeros(b);\n        b >>= bTwos;\n        final int shift = Math.min(aTwos, bTwos);\n\n        // \"a\" and \"b\" are positive.\n        // If a > b then \"gdc(a, b)\" is equal to \"gcd(a - b, b)\".\n        // If a < b then \"gcd(a, b)\" is equal to \"gcd(b - a, a)\".\n        // Hence, in the successive iterations:\n        //  \"a\" becomes the absolute difference of the current values,\n        //  \"b\" becomes the minimum of the current values.\n        while (a != b) {\n            final int delta = a - b;\n            b = Math.min(a, b);\n            a = Math.abs(delta);\n\n            // Remove any power of 2 in \"a\" (\"b\" is guaranteed to be odd).\n            a >>= Integer.numberOfTrailingZeros(a);\n        }\n\n        // Recover the common power of 2.\nreturn (a >= shift);    }",
          "13": "    private static int gcdPositive(int a,\n                                   int b) {\n        if (a == 0) {\n            return b;\n        }\n        else if (b == 0) {\n            return a;\n        }\n\n        // Make \"a\" and \"b\" odd, keeping track of common power of 2.\n        final int aTwos = Integer.numberOfTrailingZeros(a);\n        a >>= aTwos;\n        final int bTwos = Integer.numberOfTrailingZeros(b);\n        b >>= bTwos;\n        final int shift = Math.min(aTwos, bTwos);\n\n        // \"a\" and \"b\" are positive.\n        // If a > b then \"gdc(a, b)\" is equal to \"gcd(a - b, b)\".\n        // If a < b then \"gcd(a, b)\" is equal to \"gcd(b - a, a)\".\n        // Hence, in the successive iterations:\n        //  \"a\" becomes the absolute difference of the current values,\n        //  \"b\" becomes the minimum of the current values.\n        while (a != b) {\n            final int delta = a - b;\n            b = Math.min(a, b);\n            a = Math.abs(delta);\n\n            // Remove any power of 2 in \"a\" (\"b\" is guaranteed to be odd).\n            a >>= Integer.numberOfTrailingZeros(a);\n        }\n\n        // Recover the common power of 2.\nreturn (a >>> bTwos);    }",
          "14": "    private static int gcdPositive(int a,\n                                   int b) {\n        if (a == 0) {\n            return b;\n        }\n        else if (b == 0) {\n            return a;\n        }\n\n        // Make \"a\" and \"b\" odd, keeping track of common power of 2.\n        final int aTwos = Integer.numberOfTrailingZeros(a);\n        a >>= aTwos;\n        final int bTwos = Integer.numberOfTrailingZeros(b);\n        b >>= bTwos;\n        final int shift = Math.min(aTwos, bTwos);\n\n        // \"a\" and \"b\" are positive.\n        // If a > b then \"gdc(a, b)\" is equal to \"gcd(a - b, b)\".\n        // If a < b then \"gcd(a, b)\" is equal to \"gcd(b - a, a)\".\n        // Hence, in the successive iterations:\n        //  \"a\" becomes the absolute difference of the current values,\n        //  \"b\" becomes the minimum of the current values.\n        while (a != b) {\n            final int delta = a - b;\n            b = Math.min(a, b);\n            a = Math.abs(delta);\n\n            // Remove any power of 2 in \"a\" (\"b\" is guaranteed to be odd).\n            a >>= Integer.numberOfTrailingZeros(a);\n        }\n\n        // Recover the common power of 2.\nreturn (aTwos >>> shift);    }",
          "15": "    private static int gcdPositive(int a,\n                                   int b) {\n        if (a == 0) {\n            return b;\n        }\n        else if (b == 0) {\n            return a;\n        }\n\n        // Make \"a\" and \"b\" odd, keeping track of common power of 2.\n        final int aTwos = Integer.numberOfTrailingZeros(a);\n        a >>= aTwos;\n        final int bTwos = Integer.numberOfTrailingZeros(b);\n        b >>= bTwos;\n        final int shift = Math.min(aTwos, bTwos);\n\n        // \"a\" and \"b\" are positive.\n        // If a > b then \"gdc(a, b)\" is equal to \"gcd(a - b, b)\".\n        // If a < b then \"gcd(a, b)\" is equal to \"gcd(b - a, a)\".\n        // Hence, in the successive iterations:\n        //  \"a\" becomes the absolute difference of the current values,\n        //  \"b\" becomes the minimum of the current values.\n        while (a != b) {\n            final int delta = a - b;\n            b = Math.min(a, b);\n            a = Math.abs(delta);\n\n            // Remove any power of 2 in \"a\" (\"b\" is guaranteed to be odd).\n            a >>= Integer.numberOfTrailingZeros(a);\n        }\n\n        // Recover the common power of 2.\nreturn (a >> shift);    }",
          "16": "    private static int gcdPositive(int a,\n                                   int b) {\n        if (a == 0) {\n            return b;\n        }\n        else if (b == 0) {\n            return a;\n        }\n\n        // Make \"a\" and \"b\" odd, keeping track of common power of 2.\n        final int aTwos = Integer.numberOfTrailingZeros(a);\n        a >>= aTwos;\n        final int bTwos = Integer.numberOfTrailingZeros(b);\n        b >>= bTwos;\n        final int shift = Math.min(aTwos, bTwos);\n\n        // \"a\" and \"b\" are positive.\n        // If a > b then \"gdc(a, b)\" is equal to \"gcd(a - b, b)\".\n        // If a < b then \"gcd(a, b)\" is equal to \"gcd(b - a, a)\".\n        // Hence, in the successive iterations:\n        //  \"a\" becomes the absolute difference of the current values,\n        //  \"b\" becomes the minimum of the current values.\n        while (a != b) {\n            final int delta = a - b;\n            b = Math.min(a, b);\n            a = Math.abs(delta);\n\n            // Remove any power of 2 in \"a\" (\"b\" is guaranteed to be odd).\n            a >>= Integer.numberOfTrailingZeros(a);\n        }\n\n        // Recover the common power of 2.\nreturn (a >>> delta);    }",
          "17": "    private static int gcdPositive(int a,\n                                   int b) {\n        if (a == 0) {\n            return b;\n        }\n        else if (b == 0) {\n            return a;\n        }\n\n        // Make \"a\" and \"b\" odd, keeping track of common power of 2.\n        final int aTwos = Integer.numberOfTrailingZeros(a);\n        a >>= aTwos;\n        final int bTwos = Integer.numberOfTrailingZeros(b);\n        b >>= bTwos;\n        final int shift = Math.min(aTwos, bTwos);\n\n        // \"a\" and \"b\" are positive.\n        // If a > b then \"gdc(a, b)\" is equal to \"gcd(a - b, b)\".\n        // If a < b then \"gcd(a, b)\" is equal to \"gcd(b - a, a)\".\n        // Hence, in the successive iterations:\n        //  \"a\" becomes the absolute difference of the current values,\n        //  \"b\" becomes the minimum of the current values.\n        while (a != b) {\n            final int delta = a - b;\n            b = Math.min(a, b);\n            a = Math.abs(delta);\n\n            // Remove any power of 2 in \"a\" (\"b\" is guaranteed to be odd).\n            a >>= Integer.numberOfTrailingZeros(a);\n        }\n\n        // Recover the common power of 2.\nreturn (a > shift);    }",
          "18": "    private static int gcdPositive(int a,\n                                   int b) {\n        if (a == 0) {\n            return b;\n        }\n        else if (b == 0) {\n            return a;\n        }\n\n        // Make \"a\" and \"b\" odd, keeping track of common power of 2.\n        final int aTwos = Integer.numberOfTrailingZeros(a);\n        a >>= aTwos;\n        final int bTwos = Integer.numberOfTrailingZeros(b);\n        b >>= bTwos;\n        final int shift = Math.min(aTwos, bTwos);\n\n        // \"a\" and \"b\" are positive.\n        // If a > b then \"gdc(a, b)\" is equal to \"gcd(a - b, b)\".\n        // If a < b then \"gcd(a, b)\" is equal to \"gcd(b - a, a)\".\n        // Hence, in the successive iterations:\n        //  \"a\" becomes the absolute difference of the current values,\n        //  \"b\" becomes the minimum of the current values.\n        while (a != b) {\n            final int delta = a - b;\n            b = Math.min(a, b);\n            a = Math.abs(delta);\n\n            // Remove any power of 2 in \"a\" (\"b\" is guaranteed to be odd).\n            a >>= Integer.numberOfTrailingZeros(a);\n        }\n\n        // Recover the common power of 2.\nreturn a;    }",
          "19": "    private static int gcdPositive(int a,\n                                   int b) {\n        if (a == 0) {\n            return b;\n        }\n        else if (b == 0) {\n            return a;\n        }\n\n        // Make \"a\" and \"b\" odd, keeping track of common power of 2.\n        final int aTwos = Integer.numberOfTrailingZeros(a);\n        a >>= aTwos;\n        final int bTwos = Integer.numberOfTrailingZeros(b);\n        b >>= bTwos;\n        final int shift = Math.min(aTwos, bTwos);\n\n        // \"a\" and \"b\" are positive.\n        // If a > b then \"gdc(a, b)\" is equal to \"gcd(a - b, b)\".\n        // If a < b then \"gcd(a, b)\" is equal to \"gcd(b - a, a)\".\n        // Hence, in the successive iterations:\n        //  \"a\" becomes the absolute difference of the current values,\n        //  \"b\" becomes the minimum of the current values.\n        while (a != b) {\n            final int delta = a - b;\n            b = Math.min(a, b);\n            a = Math.abs(delta);\n\n            // Remove any power of 2 in \"a\" (\"b\" is guaranteed to be odd).\n            a >>= Integer.numberOfTrailingZeros(a);\n        }\n\n        // Recover the common power of 2.\nreturn a;        return a >>> shift;    }",
          "20": "    private static int gcdPositive(int a,\n                                   int b) {\n        if (a == 0) {\n            return b;\n        }\n        else if (b == 0) {\n            return a;\n        }\n\n        // Make \"a\" and \"b\" odd, keeping track of common power of 2.\n        final int aTwos = Integer.numberOfTrailingZeros(a);\n        a >>= aTwos;\n        final int bTwos = Integer.numberOfTrailingZeros(b);\n        b >>= bTwos;\n        final int shift = Math.min(aTwos, bTwos);\n\n        // \"a\" and \"b\" are positive.\n        // If a > b then \"gdc(a, b)\" is equal to \"gcd(a - b, b)\".\n        // If a < b then \"gcd(a, b)\" is equal to \"gcd(b - a, a)\".\n        // Hence, in the successive iterations:\n        //  \"a\" becomes the absolute difference of the current values,\n        //  \"b\" becomes the minimum of the current values.\n        while (a != b) {\n            final int delta = a - b;\n            b = Math.min(a, b);\n            a = Math.abs(delta);\n\n            // Remove any power of 2 in \"a\" (\"b\" is guaranteed to be odd).\n            a >>= Integer.numberOfTrailingZeros(a);\n        }\n\n        // Recover the common power of 2.\nreturn (a < shift);    }",
          "21": "    private static int gcdPositive(int a,\n                                   int b) {\n        if (a == 0) {\n            return b;\n        }\n        else if (b == 0) {\n            return a;\n        }\n\n        // Make \"a\" and \"b\" odd, keeping track of common power of 2.\n        final int aTwos = Integer.numberOfTrailingZeros(a);\n        a >>= aTwos;\n        final int bTwos = Integer.numberOfTrailingZeros(b);\n        b >>= bTwos;\n        final int shift = Math.min(aTwos, bTwos);\n\n        // \"a\" and \"b\" are positive.\n        // If a > b then \"gdc(a, b)\" is equal to \"gcd(a - b, b)\".\n        // If a < b then \"gcd(a, b)\" is equal to \"gcd(b - a, a)\".\n        // Hence, in the successive iterations:\n        //  \"a\" becomes the absolute difference of the current values,\n        //  \"b\" becomes the minimum of the current values.\n        while (a != b) {\n            final int delta = a - b;\n            b = Math.min(a, b);\n            a = Math.abs(delta);\n\n            // Remove any power of 2 in \"a\" (\"b\" is guaranteed to be odd).\n            a >>= Integer.numberOfTrailingZeros(a);\n        }\n\n        // Recover the common power of 2.\nreturn (b >>> shift);    }",
          "22": "    private static int gcdPositive(int a,\n                                   int b) {\n        if (a == 0) {\n            return b;\n        }\n        else if (b == 0) {\n            return a;\n        }\n\n        // Make \"a\" and \"b\" odd, keeping track of common power of 2.\n        final int aTwos = Integer.numberOfTrailingZeros(a);\n        a >>= aTwos;\n        final int bTwos = Integer.numberOfTrailingZeros(b);\n        b >>= bTwos;\n        final int shift = Math.min(aTwos, bTwos);\n\n        // \"a\" and \"b\" are positive.\n        // If a > b then \"gdc(a, b)\" is equal to \"gcd(a - b, b)\".\n        // If a < b then \"gcd(a, b)\" is equal to \"gcd(b - a, a)\".\n        // Hence, in the successive iterations:\n        //  \"a\" becomes the absolute difference of the current values,\n        //  \"b\" becomes the minimum of the current values.\n        while (a != b) {\n            final int delta = a - b;\n            b = Math.min(a, b);\n            a = Math.abs(delta);\n\n            // Remove any power of 2 in \"a\" (\"b\" is guaranteed to be odd).\n            a >>= Integer.numberOfTrailingZeros(a);\n        }\n\n        // Recover the common power of 2.\nreturn b;    }",
          "23": "    private static int gcdPositive(int a,\n                                   int b) {\n        if (a == 0) {\n            return b;\n        }\n        else if (b == 0) {\n            return a;\n        }\n\n        // Make \"a\" and \"b\" odd, keeping track of common power of 2.\n        final int aTwos = Integer.numberOfTrailingZeros(a);\n        a >>= aTwos;\n        final int bTwos = Integer.numberOfTrailingZeros(b);\n        b >>= bTwos;\n        final int shift = Math.min(aTwos, bTwos);\n\n        // \"a\" and \"b\" are positive.\n        // If a > b then \"gdc(a, b)\" is equal to \"gcd(a - b, b)\".\n        // If a < b then \"gcd(a, b)\" is equal to \"gcd(b - a, a)\".\n        // Hence, in the successive iterations:\n        //  \"a\" becomes the absolute difference of the current values,\n        //  \"b\" becomes the minimum of the current values.\n        while (a != b) {\n            final int delta = a - b;\n            b = Math.min(a, b);\n            a = Math.abs(delta);\n\n            // Remove any power of 2 in \"a\" (\"b\" is guaranteed to be odd).\n            a >>= Integer.numberOfTrailingZeros(a);\n        }\n\n        // Recover the common power of 2.\ncontinue;\n    }",
          "24": "    private static int gcdPositive(int a,\n                                   int b) {\n        if (a == 0) {\n            return b;\n        }\n        else if (b == 0) {\n            return a;\n        }\n\n        // Make \"a\" and \"b\" odd, keeping track of common power of 2.\n        final int aTwos = Integer.numberOfTrailingZeros(a);\n        a >>= aTwos;\n        final int bTwos = Integer.numberOfTrailingZeros(b);\n        b >>= bTwos;\n        final int shift = Math.min(aTwos, bTwos);\n\n        // \"a\" and \"b\" are positive.\n        // If a > b then \"gdc(a, b)\" is equal to \"gcd(a - b, b)\".\n        // If a < b then \"gcd(a, b)\" is equal to \"gcd(b - a, a)\".\n        // Hence, in the successive iterations:\n        //  \"a\" becomes the absolute difference of the current values,\n        //  \"b\" becomes the minimum of the current values.\n        while (a != b) {\n            final int delta = a - b;\n            b = Math.min(a, b);\n            a = Math.abs(delta);\n\n            // Remove any power of 2 in \"a\" (\"b\" is guaranteed to be odd).\n            a >>= Integer.numberOfTrailingZeros(a);\n        }\n\n        // Recover the common power of 2.\nreturn (a % shift);    }",
          "25": "    private static int gcdPositive(int a,\n                                   int b) {\n        if (a == 0) {\n            return b;\n        }\n        else if (b == 0) {\n            return a;\n        }\n\n        // Make \"a\" and \"b\" odd, keeping track of common power of 2.\n        final int aTwos = Integer.numberOfTrailingZeros(a);\n        a >>= aTwos;\n        final int bTwos = Integer.numberOfTrailingZeros(b);\n        b >>= bTwos;\n        final int shift = Math.min(aTwos, bTwos);\n\n        // \"a\" and \"b\" are positive.\n        // If a > b then \"gdc(a, b)\" is equal to \"gcd(a - b, b)\".\n        // If a < b then \"gcd(a, b)\" is equal to \"gcd(b - a, a)\".\n        // Hence, in the successive iterations:\n        //  \"a\" becomes the absolute difference of the current values,\n        //  \"b\" becomes the minimum of the current values.\n        while (a != b) {\n            final int delta = a - b;\n            b = Math.min(a, b);\n            a = Math.abs(delta);\n\n            // Remove any power of 2 in \"a\" (\"b\" is guaranteed to be odd).\n            a >>= Integer.numberOfTrailingZeros(a);\n        }\n\n        // Recover the common power of 2.\nreturn ( >>> shift);    }",
          "26": "    private static int gcdPositive(int a,\n                                   int b) {\n        if (a == 0) {\n            return b;\n        }\n        else if (b == 0) {\n            return a;\n        }\n\n        // Make \"a\" and \"b\" odd, keeping track of common power of 2.\n        final int aTwos = Integer.numberOfTrailingZeros(a);\n        a >>= aTwos;\n        final int bTwos = Integer.numberOfTrailingZeros(b);\n        b >>= bTwos;\n        final int shift = Math.min(aTwos, bTwos);\n\n        // \"a\" and \"b\" are positive.\n        // If a > b then \"gdc(a, b)\" is equal to \"gcd(a - b, b)\".\n        // If a < b then \"gcd(a, b)\" is equal to \"gcd(b - a, a)\".\n        // Hence, in the successive iterations:\n        //  \"a\" becomes the absolute difference of the current values,\n        //  \"b\" becomes the minimum of the current values.\n        while (a != b) {\n            final int delta = a - b;\n            b = Math.min(a, b);\n            a = Math.abs(delta);\n\n            // Remove any power of 2 in \"a\" (\"b\" is guaranteed to be odd).\n            a >>= Integer.numberOfTrailingZeros(a);\n        }\n\n        // Recover the common power of 2.\nreturn (a & shift);    }",
          "27": "    private static int gcdPositive(int a,\n                                   int b) {\n        if (a == 0) {\n            return b;\n        }\n        else if (b == 0) {\n            return a;\n        }\n\n        // Make \"a\" and \"b\" odd, keeping track of common power of 2.\n        final int aTwos = Integer.numberOfTrailingZeros(a);\n        a >>= aTwos;\n        final int bTwos = Integer.numberOfTrailingZeros(b);\n        b >>= bTwos;\n        final int shift = Math.min(aTwos, bTwos);\n\n        // \"a\" and \"b\" are positive.\n        // If a > b then \"gdc(a, b)\" is equal to \"gcd(a - b, b)\".\n        // If a < b then \"gcd(a, b)\" is equal to \"gcd(b - a, a)\".\n        // Hence, in the successive iterations:\n        //  \"a\" becomes the absolute difference of the current values,\n        //  \"b\" becomes the minimum of the current values.\n        while (a != b) {\n            final int delta = a - b;\n            b = Math.min(a, b);\n            a = Math.abs(delta);\n\n            // Remove any power of 2 in \"a\" (\"b\" is guaranteed to be odd).\n            a >>= Integer.numberOfTrailingZeros(a);\n        }\n\n        // Recover the common power of 2.\nreturn (a >>> aTwos);    }",
          "28": "    private static int gcdPositive(int a,\n                                   int b) {\n        if (a == 0) {\n            return b;\n        }\n        else if (b == 0) {\n            return a;\n        }\n\n        // Make \"a\" and \"b\" odd, keeping track of common power of 2.\n        final int aTwos = Integer.numberOfTrailingZeros(a);\n        a >>= aTwos;\n        final int bTwos = Integer.numberOfTrailingZeros(b);\n        b >>= bTwos;\n        final int shift = Math.min(aTwos, bTwos);\n\n        // \"a\" and \"b\" are positive.\n        // If a > b then \"gdc(a, b)\" is equal to \"gcd(a - b, b)\".\n        // If a < b then \"gcd(a, b)\" is equal to \"gcd(b - a, a)\".\n        // Hence, in the successive iterations:\n        //  \"a\" becomes the absolute difference of the current values,\n        //  \"b\" becomes the minimum of the current values.\n        while (a != b) {\n            final int delta = a - b;\n            b = Math.min(a, b);\n            a = Math.abs(delta);\n\n            // Remove any power of 2 in \"a\" (\"b\" is guaranteed to be odd).\n            a >>= Integer.numberOfTrailingZeros(a);\n        }\n\n        // Recover the common power of 2.\nbreak;\n        return a >>> shift;    }",
          "29": "    private static int gcdPositive(int a,\n                                   int b) {\n        if (a == 0) {\n            return b;\n        }\n        else if (b == 0) {\n            return a;\n        }\n\n        // Make \"a\" and \"b\" odd, keeping track of common power of 2.\n        final int aTwos = Integer.numberOfTrailingZeros(a);\n        a >>= aTwos;\n        final int bTwos = Integer.numberOfTrailingZeros(b);\n        b >>= bTwos;\n        final int shift = Math.min(aTwos, bTwos);\n\n        // \"a\" and \"b\" are positive.\n        // If a > b then \"gdc(a, b)\" is equal to \"gcd(a - b, b)\".\n        // If a < b then \"gcd(a, b)\" is equal to \"gcd(b - a, a)\".\n        // Hence, in the successive iterations:\n        //  \"a\" becomes the absolute difference of the current values,\n        //  \"b\" becomes the minimum of the current values.\n        while (a != b) {\n            final int delta = a - b;\n            b = Math.min(a, b);\n            a = Math.abs(delta);\n\n            // Remove any power of 2 in \"a\" (\"b\" is guaranteed to be odd).\n            a >>= Integer.numberOfTrailingZeros(a);\n        }\n\n        // Recover the common power of 2.\nreturn b;        return a >>> shift;    }",
          "30": "    private static int gcdPositive(int a,\n                                   int b) {\n        if (a == 0) {\n            return b;\n        }\n        else if (b == 0) {\n            return a;\n        }\n\n        // Make \"a\" and \"b\" odd, keeping track of common power of 2.\n        final int aTwos = Integer.numberOfTrailingZeros(a);\n        a >>= aTwos;\n        final int bTwos = Integer.numberOfTrailingZeros(b);\n        b >>= bTwos;\n        final int shift = Math.min(aTwos, bTwos);\n\n        // \"a\" and \"b\" are positive.\n        // If a > b then \"gdc(a, b)\" is equal to \"gcd(a - b, b)\".\n        // If a < b then \"gcd(a, b)\" is equal to \"gcd(b - a, a)\".\n        // Hence, in the successive iterations:\n        //  \"a\" becomes the absolute difference of the current values,\n        //  \"b\" becomes the minimum of the current values.\n        while (a != b) {\n            final int delta = a - b;\n            b = Math.min(a, b);\n            a = Math.abs(delta);\n\n            // Remove any power of 2 in \"a\" (\"b\" is guaranteed to be odd).\n            a >>= Integer.numberOfTrailingZeros(a);\n        }\n\n        // Recover the common power of 2.\nreturn (a / shift);    }",
          "31": "    private static int gcdPositive(int a,\n                                   int b) {\n        if (a == 0) {\n            return b;\n        }\n        else if (b == 0) {\n            return a;\n        }\n\n        // Make \"a\" and \"b\" odd, keeping track of common power of 2.\n        final int aTwos = Integer.numberOfTrailingZeros(a);\n        a >>= aTwos;\n        final int bTwos = Integer.numberOfTrailingZeros(b);\n        b >>= bTwos;\n        final int shift = Math.min(aTwos, bTwos);\n\n        // \"a\" and \"b\" are positive.\n        // If a > b then \"gdc(a, b)\" is equal to \"gcd(a - b, b)\".\n        // If a < b then \"gcd(a, b)\" is equal to \"gcd(b - a, a)\".\n        // Hence, in the successive iterations:\n        //  \"a\" becomes the absolute difference of the current values,\n        //  \"b\" becomes the minimum of the current values.\n        while (a != b) {\n            final int delta = a - b;\n            b = Math.min(a, b);\n            a = Math.abs(delta);\n\n            // Remove any power of 2 in \"a\" (\"b\" is guaranteed to be odd).\n            a >>= Integer.numberOfTrailingZeros(a);\n        }\n\n        // Recover the common power of 2.\nreturn (a >>> b);    }",
          "32": "    private static int gcdPositive(int a,\n                                   int b) {\n        if (a == 0) {\n            return b;\n        }\n        else if (b == 0) {\n            return a;\n        }\n\n        // Make \"a\" and \"b\" odd, keeping track of common power of 2.\n        final int aTwos = Integer.numberOfTrailingZeros(a);\n        a >>= aTwos;\n        final int bTwos = Integer.numberOfTrailingZeros(b);\n        b >>= bTwos;\n        final int shift = Math.min(aTwos, bTwos);\n\n        // \"a\" and \"b\" are positive.\n        // If a > b then \"gdc(a, b)\" is equal to \"gcd(a - b, b)\".\n        // If a < b then \"gcd(a, b)\" is equal to \"gcd(b - a, a)\".\n        // Hence, in the successive iterations:\n        //  \"a\" becomes the absolute difference of the current values,\n        //  \"b\" becomes the minimum of the current values.\n        while (a != b) {\n            final int delta = a - b;\n            b = Math.min(a, b);\n            a = Math.abs(delta);\n\n            // Remove any power of 2 in \"a\" (\"b\" is guaranteed to be odd).\n            a >>= Integer.numberOfTrailingZeros(a);\n        }\n\n        // Recover the common power of 2.\nreturn (a >>> );    }",
          "33": "    private static int gcdPositive(int a,\n                                   int b) {\n        if (a == 0) {\n            return b;\n        }\n        else if (b == 0) {\n            return a;\n        }\n\n        // Make \"a\" and \"b\" odd, keeping track of common power of 2.\n        final int aTwos = Integer.numberOfTrailingZeros(a);\n        a >>= aTwos;\n        final int bTwos = Integer.numberOfTrailingZeros(b);\n        b >>= bTwos;\n        final int shift = Math.min(aTwos, bTwos);\n\n        // \"a\" and \"b\" are positive.\n        // If a > b then \"gdc(a, b)\" is equal to \"gcd(a - b, b)\".\n        // If a < b then \"gcd(a, b)\" is equal to \"gcd(b - a, a)\".\n        // Hence, in the successive iterations:\n        //  \"a\" becomes the absolute difference of the current values,\n        //  \"b\" becomes the minimum of the current values.\n        while (a != b) {\n            final int delta = a - b;\n            b = Math.min(a, b);\n            a = Math.abs(delta);\n\n            // Remove any power of 2 in \"a\" (\"b\" is guaranteed to be odd).\n            a >>= Integer.numberOfTrailingZeros(a);\n        }\n\n        // Recover the common power of 2.\nreturn 0;        return a >>> shift;    }",
          "34": "    private static int gcdPositive(int a,\n                                   int b) {\n        if (a == 0) {\n            return b;\n        }\n        else if (b == 0) {\n            return a;\n        }\n\n        // Make \"a\" and \"b\" odd, keeping track of common power of 2.\n        final int aTwos = Integer.numberOfTrailingZeros(a);\n        a >>= aTwos;\n        final int bTwos = Integer.numberOfTrailingZeros(b);\n        b >>= bTwos;\n        final int shift = Math.min(aTwos, bTwos);\n\n        // \"a\" and \"b\" are positive.\n        // If a > b then \"gdc(a, b)\" is equal to \"gcd(a - b, b)\".\n        // If a < b then \"gcd(a, b)\" is equal to \"gcd(b - a, a)\".\n        // Hence, in the successive iterations:\n        //  \"a\" becomes the absolute difference of the current values,\n        //  \"b\" becomes the minimum of the current values.\n        while (a != b) {\n            final int delta = a - b;\n            b = Math.min(a, b);\n            a = Math.abs(delta);\n\n            // Remove any power of 2 in \"a\" (\"b\" is guaranteed to be odd).\n            a >>= Integer.numberOfTrailingZeros(a);\n        }\n\n        // Recover the common power of 2.\na = bTwos;\n        return a >>> shift;    }",
          "35": "    private static int gcdPositive(int a,\n                                   int b) {\n        if (a == 0) {\n            return b;\n        }\n        else if (b == 0) {\n            return a;\n        }\n\n        // Make \"a\" and \"b\" odd, keeping track of common power of 2.\n        final int aTwos = Integer.numberOfTrailingZeros(a);\n        a >>= aTwos;\n        final int bTwos = Integer.numberOfTrailingZeros(b);\n        b >>= bTwos;\n        final int shift = Math.min(aTwos, bTwos);\n\n        // \"a\" and \"b\" are positive.\n        // If a > b then \"gdc(a, b)\" is equal to \"gcd(a - b, b)\".\n        // If a < b then \"gcd(a, b)\" is equal to \"gcd(b - a, a)\".\n        // Hence, in the successive iterations:\n        //  \"a\" becomes the absolute difference of the current values,\n        //  \"b\" becomes the minimum of the current values.\n        while (a != b) {\n            final int delta = a - b;\n            b = Math.min(a, b);\n            a = Math.abs(delta);\n\n            // Remove any power of 2 in \"a\" (\"b\" is guaranteed to be odd).\n            a >>= Integer.numberOfTrailingZeros(a);\n        }\n\n        // Recover the common power of 2.\nreturn (a - b);    }",
          "36": "    private static int gcdPositive(int a,\n                                   int b) {\n        if (a == 0) {\n            return b;\n        }\n        else if (b == 0) {\n            return a;\n        }\n\n        // Make \"a\" and \"b\" odd, keeping track of common power of 2.\n        final int aTwos = Integer.numberOfTrailingZeros(a);\n        a >>= aTwos;\n        final int bTwos = Integer.numberOfTrailingZeros(b);\n        b >>= bTwos;\n        final int shift = Math.min(aTwos, bTwos);\n\n        // \"a\" and \"b\" are positive.\n        // If a > b then \"gdc(a, b)\" is equal to \"gcd(a - b, b)\".\n        // If a < b then \"gcd(a, b)\" is equal to \"gcd(b - a, a)\".\n        // Hence, in the successive iterations:\n        //  \"a\" becomes the absolute difference of the current values,\n        //  \"b\" becomes the minimum of the current values.\n        while (a != b) {\n            final int delta = a - b;\n            b = Math.min(a, b);\n            a = Math.abs(delta);\n\n            // Remove any power of 2 in \"a\" (\"b\" is guaranteed to be odd).\n            a >>= Integer.numberOfTrailingZeros(a);\n        }\n\n        // Recover the common power of 2.\nreturn;\n        return a >>> shift;    }",
          "37": "    private static int gcdPositive(int a,\n                                   int b) {\n        if (a == 0) {\n            return b;\n        }\n        else if (b == 0) {\n            return a;\n        }\n\n        // Make \"a\" and \"b\" odd, keeping track of common power of 2.\n        final int aTwos = Integer.numberOfTrailingZeros(a);\n        a >>= aTwos;\n        final int bTwos = Integer.numberOfTrailingZeros(b);\n        b >>= bTwos;\n        final int shift = Math.min(aTwos, bTwos);\n\n        // \"a\" and \"b\" are positive.\n        // If a > b then \"gdc(a, b)\" is equal to \"gcd(a - b, b)\".\n        // If a < b then \"gcd(a, b)\" is equal to \"gcd(b - a, a)\".\n        // Hence, in the successive iterations:\n        //  \"a\" becomes the absolute difference of the current values,\n        //  \"b\" becomes the minimum of the current values.\n        while (a != b) {\n            final int delta = a - b;\n            b = Math.min(a, b);\n            a = Math.abs(delta);\n\n            // Remove any power of 2 in \"a\" (\"b\" is guaranteed to be odd).\n            a >>= Integer.numberOfTrailingZeros(a);\n        }\n\n        // Recover the common power of 2.\nreturn shift;    }",
          "38": "    private static int gcdPositive(int a,\n                                   int b) {\n        if (a == 0) {\n            return b;\n        }\n        else if (b == 0) {\n            return a;\n        }\n\n        // Make \"a\" and \"b\" odd, keeping track of common power of 2.\n        final int aTwos = Integer.numberOfTrailingZeros(a);\n        a >>= aTwos;\n        final int bTwos = Integer.numberOfTrailingZeros(b);\n        b >>= bTwos;\n        final int shift = Math.min(aTwos, bTwos);\n\n        // \"a\" and \"b\" are positive.\n        // If a > b then \"gdc(a, b)\" is equal to \"gcd(a - b, b)\".\n        // If a < b then \"gcd(a, b)\" is equal to \"gcd(b - a, a)\".\n        // Hence, in the successive iterations:\n        //  \"a\" becomes the absolute difference of the current values,\n        //  \"b\" becomes the minimum of the current values.\n        while (a != b) {\n            final int delta = a - b;\n            b = Math.min(a, b);\n            a = Math.abs(delta);\n\n            // Remove any power of 2 in \"a\" (\"b\" is guaranteed to be odd).\n            a >>= Integer.numberOfTrailingZeros(a);\n        }\n\n        // Recover the common power of 2.\nif((b == 0)){\n}\n        return a >>> shift;    }",
          "39": "    private static int gcdPositive(int a,\n                                   int b) {\n        if (a == 0) {\n            return b;\n        }\n        else if (b == 0) {\n            return a;\n        }\n\n        // Make \"a\" and \"b\" odd, keeping track of common power of 2.\n        final int aTwos = Integer.numberOfTrailingZeros(a);\n        a >>= aTwos;\n        final int bTwos = Integer.numberOfTrailingZeros(b);\n        b >>= bTwos;\n        final int shift = Math.min(aTwos, bTwos);\n\n        // \"a\" and \"b\" are positive.\n        // If a > b then \"gdc(a, b)\" is equal to \"gcd(a - b, b)\".\n        // If a < b then \"gcd(a, b)\" is equal to \"gcd(b - a, a)\".\n        // Hence, in the successive iterations:\n        //  \"a\" becomes the absolute difference of the current values,\n        //  \"b\" becomes the minimum of the current values.\n        while (a != b) {\n            final int delta = a - b;\n            b = Math.min(a, b);\n            a = Math.abs(delta);\n\n            // Remove any power of 2 in \"a\" (\"b\" is guaranteed to be odd).\n            a >>= Integer.numberOfTrailingZeros(a);\n        }\n\n        // Recover the common power of 2.\nreturn (a >>> a);    }",
          "40": "    private static int gcdPositive(int a,\n                                   int b) {\n        if (a == 0) {\n            return b;\n        }\n        else if (b == 0) {\n            return a;\n        }\n\n        // Make \"a\" and \"b\" odd, keeping track of common power of 2.\n        final int aTwos = Integer.numberOfTrailingZeros(a);\n        a >>= aTwos;\n        final int bTwos = Integer.numberOfTrailingZeros(b);\n        b >>= bTwos;\n        final int shift = Math.min(aTwos, bTwos);\n\n        // \"a\" and \"b\" are positive.\n        // If a > b then \"gdc(a, b)\" is equal to \"gcd(a - b, b)\".\n        // If a < b then \"gcd(a, b)\" is equal to \"gcd(b - a, a)\".\n        // Hence, in the successive iterations:\n        //  \"a\" becomes the absolute difference of the current values,\n        //  \"b\" becomes the minimum of the current values.\n        while (a != b) {\n            final int delta = a - b;\n            b = Math.min(a, b);\n            a = Math.abs(delta);\n\n            // Remove any power of 2 in \"a\" (\"b\" is guaranteed to be odd).\n            a >>= Integer.numberOfTrailingZeros(a);\n        }\n\n        // Recover the common power of 2.\na = b;\n        return a >>> shift;    }",
          "41": "    private static int gcdPositive(int a,\n                                   int b) {\n        if (a == 0) {\n            return b;\n        }\n        else if (b == 0) {\n            return a;\n        }\n\n        // Make \"a\" and \"b\" odd, keeping track of common power of 2.\n        final int aTwos = Integer.numberOfTrailingZeros(a);\n        a >>= aTwos;\n        final int bTwos = Integer.numberOfTrailingZeros(b);\n        b >>= bTwos;\n        final int shift = Math.min(aTwos, bTwos);\n\n        // \"a\" and \"b\" are positive.\n        // If a > b then \"gdc(a, b)\" is equal to \"gcd(a - b, b)\".\n        // If a < b then \"gcd(a, b)\" is equal to \"gcd(b - a, a)\".\n        // Hence, in the successive iterations:\n        //  \"a\" becomes the absolute difference of the current values,\n        //  \"b\" becomes the minimum of the current values.\n        while (a != b) {\n            final int delta = a - b;\n            b = Math.min(a, b);\n            a = Math.abs(delta);\n\n            // Remove any power of 2 in \"a\" (\"b\" is guaranteed to be odd).\n            a >>= Integer.numberOfTrailingZeros(a);\n        }\n\n        // Recover the common power of 2.\nreturn ( >>> shift);    }",
          "42": "    private static int gcdPositive(int a,\n                                   int b) {\n        if (a == 0) {\n            return b;\n        }\n        else if (b == 0) {\n            return a;\n        }\n\n        // Make \"a\" and \"b\" odd, keeping track of common power of 2.\n        final int aTwos = Integer.numberOfTrailingZeros(a);\n        a >>= aTwos;\n        final int bTwos = Integer.numberOfTrailingZeros(b);\n        b >>= bTwos;\n        final int shift = Math.min(aTwos, bTwos);\n\n        // \"a\" and \"b\" are positive.\n        // If a > b then \"gdc(a, b)\" is equal to \"gcd(a - b, b)\".\n        // If a < b then \"gcd(a, b)\" is equal to \"gcd(b - a, a)\".\n        // Hence, in the successive iterations:\n        //  \"a\" becomes the absolute difference of the current values,\n        //  \"b\" becomes the minimum of the current values.\n        while (a != b) {\n            final int delta = a - b;\n            b = Math.min(a, b);\n            a = Math.abs(delta);\n\n            // Remove any power of 2 in \"a\" (\"b\" is guaranteed to be odd).\n            a >>= Integer.numberOfTrailingZeros(a);\n        }\n\n        // Recover the common power of 2.\na = aTwos;\n        return a >>> shift;    }",
          "43": "    private static int gcdPositive(int a,\n                                   int b) {\n        if (a == 0) {\n            return b;\n        }\n        else if (b == 0) {\n            return a;\n        }\n\n        // Make \"a\" and \"b\" odd, keeping track of common power of 2.\n        final int aTwos = Integer.numberOfTrailingZeros(a);\n        a >>= aTwos;\n        final int bTwos = Integer.numberOfTrailingZeros(b);\n        b >>= bTwos;\n        final int shift = Math.min(aTwos, bTwos);\n\n        // \"a\" and \"b\" are positive.\n        // If a > b then \"gdc(a, b)\" is equal to \"gcd(a - b, b)\".\n        // If a < b then \"gcd(a, b)\" is equal to \"gcd(b - a, a)\".\n        // Hence, in the successive iterations:\n        //  \"a\" becomes the absolute difference of the current values,\n        //  \"b\" becomes the minimum of the current values.\n        while (a != b) {\n            final int delta = a - b;\n            b = Math.min(a, b);\n            a = Math.abs(delta);\n\n            // Remove any power of 2 in \"a\" (\"b\" is guaranteed to be odd).\n            a >>= Integer.numberOfTrailingZeros(a);\n        }\n\n        // Recover the common power of 2.\nb = Math.min(a, b);\na >>= Integer.numberOfTrailingZeros(a);\n        return a >>> shift;    }",
          "44": "    private static int gcdPositive(int a,\n                                   int b) {\n        if (a == 0) {\n            return b;\n        }\n        else if (b == 0) {\n            return a;\n        }\n\n        // Make \"a\" and \"b\" odd, keeping track of common power of 2.\n        final int aTwos = Integer.numberOfTrailingZeros(a);\n        a >>= aTwos;\n        final int bTwos = Integer.numberOfTrailingZeros(b);\n        b >>= bTwos;\n        final int shift = Math.min(aTwos, bTwos);\n\n        // \"a\" and \"b\" are positive.\n        // If a > b then \"gdc(a, b)\" is equal to \"gcd(a - b, b)\".\n        // If a < b then \"gcd(a, b)\" is equal to \"gcd(b - a, a)\".\n        // Hence, in the successive iterations:\n        //  \"a\" becomes the absolute difference of the current values,\n        //  \"b\" becomes the minimum of the current values.\n        while (a != b) {\n            final int delta = a - b;\n            b = Math.min(a, b);\n            a = Math.abs(delta);\n\n            // Remove any power of 2 in \"a\" (\"b\" is guaranteed to be odd).\n            a >>= Integer.numberOfTrailingZeros(a);\n        }\n\n        // Recover the common power of 2.\nif((a != b)){\n}\n        return a >>> shift;    }",
          "45": "    private static int gcdPositive(int a,\n                                   int b) {\n        if (a == 0) {\n            return b;\n        }\n        else if (b == 0) {\n            return a;\n        }\n\n        // Make \"a\" and \"b\" odd, keeping track of common power of 2.\n        final int aTwos = Integer.numberOfTrailingZeros(a);\n        a >>= aTwos;\n        final int bTwos = Integer.numberOfTrailingZeros(b);\n        b >>= bTwos;\n        final int shift = Math.min(aTwos, bTwos);\n\n        // \"a\" and \"b\" are positive.\n        // If a > b then \"gdc(a, b)\" is equal to \"gcd(a - b, b)\".\n        // If a < b then \"gcd(a, b)\" is equal to \"gcd(b - a, a)\".\n        // Hence, in the successive iterations:\n        //  \"a\" becomes the absolute difference of the current values,\n        //  \"b\" becomes the minimum of the current values.\n        while (a != b) {\n            final int delta = a - b;\n            b = Math.min(a, b);\n            a = Math.abs(delta);\n\n            // Remove any power of 2 in \"a\" (\"b\" is guaranteed to be odd).\n            a >>= Integer.numberOfTrailingZeros(a);\n        }\n\n        // Recover the common power of 2.\na = 0;\n        return a >>> shift;    }",
          "46": "    private static int gcdPositive(int a,\n                                   int b) {\n        if (a == 0) {\n            return b;\n        }\n        else if (b == 0) {\n            return a;\n        }\n\n        // Make \"a\" and \"b\" odd, keeping track of common power of 2.\n        final int aTwos = Integer.numberOfTrailingZeros(a);\n        a >>= aTwos;\n        final int bTwos = Integer.numberOfTrailingZeros(b);\n        b >>= bTwos;\n        final int shift = Math.min(aTwos, bTwos);\n\n        // \"a\" and \"b\" are positive.\n        // If a > b then \"gdc(a, b)\" is equal to \"gcd(a - b, b)\".\n        // If a < b then \"gcd(a, b)\" is equal to \"gcd(b - a, a)\".\n        // Hence, in the successive iterations:\n        //  \"a\" becomes the absolute difference of the current values,\n        //  \"b\" becomes the minimum of the current values.\n        while (a != b) {\n            final int delta = a - b;\n            b = Math.min(a, b);\n            a = Math.abs(delta);\n\n            // Remove any power of 2 in \"a\" (\"b\" is guaranteed to be odd).\n            a >>= Integer.numberOfTrailingZeros(a);\n        }\n\n        // Recover the common power of 2.\na = Math.abs(delta);\na >>= Integer.numberOfTrailingZeros(a);\n        return a >>> shift;    }",
          "47": "    private static int gcdPositive(int a,\n                                   int b) {\n        if (a == 0) {\n            return b;\n        }\n        else if (b == 0) {\n            return a;\n        }\n\n        // Make \"a\" and \"b\" odd, keeping track of common power of 2.\n        final int aTwos = Integer.numberOfTrailingZeros(a);\n        a >>= aTwos;\n        final int bTwos = Integer.numberOfTrailingZeros(b);\n        b >>= bTwos;\n        final int shift = Math.min(aTwos, bTwos);\n\n        // \"a\" and \"b\" are positive.\n        // If a > b then \"gdc(a, b)\" is equal to \"gcd(a - b, b)\".\n        // If a < b then \"gcd(a, b)\" is equal to \"gcd(b - a, a)\".\n        // Hence, in the successive iterations:\n        //  \"a\" becomes the absolute difference of the current values,\n        //  \"b\" becomes the minimum of the current values.\n        while (a != b) {\n            final int delta = a - b;\n            b = Math.min(a, b);\n            a = Math.abs(delta);\n\n            // Remove any power of 2 in \"a\" (\"b\" is guaranteed to be odd).\n            a >>= Integer.numberOfTrailingZeros(a);\n        }\n\n        // Recover the common power of 2.\na = shift;\n}\n        return a >>> shift;    }",
          "48": "    private static int gcdPositive(int a,\n                                   int b) {\n        if (a == 0) {\n            return b;\n        }\n        else if (b == 0) {\n            return a;\n        }\n\n        // Make \"a\" and \"b\" odd, keeping track of common power of 2.\n        final int aTwos = Integer.numberOfTrailingZeros(a);\n        a >>= aTwos;\n        final int bTwos = Integer.numberOfTrailingZeros(b);\n        b >>= bTwos;\n        final int shift = Math.min(aTwos, bTwos);\n\n        // \"a\" and \"b\" are positive.\n        // If a > b then \"gdc(a, b)\" is equal to \"gcd(a - b, b)\".\n        // If a < b then \"gcd(a, b)\" is equal to \"gcd(b - a, a)\".\n        // Hence, in the successive iterations:\n        //  \"a\" becomes the absolute difference of the current values,\n        //  \"b\" becomes the minimum of the current values.\n        while (a != b) {\n            final int delta = a - b;\n            b = Math.min(a, b);\n            a = Math.abs(delta);\n\n            // Remove any power of 2 in \"a\" (\"b\" is guaranteed to be odd).\n            a >>= Integer.numberOfTrailingZeros(a);\n        }\n\n        // Recover the common power of 2.\nreturn bTwos;    }",
          "49": "    private static int gcdPositive(int a,\n                                   int b) {\n        if (a == 0) {\n            return b;\n        }\n        else if (b == 0) {\n            return a;\n        }\n\n        // Make \"a\" and \"b\" odd, keeping track of common power of 2.\n        final int aTwos = Integer.numberOfTrailingZeros(a);\n        a >>= aTwos;\n        final int bTwos = Integer.numberOfTrailingZeros(b);\n        b >>= bTwos;\n        final int shift = Math.min(aTwos, bTwos);\n\n        // \"a\" and \"b\" are positive.\n        // If a > b then \"gdc(a, b)\" is equal to \"gcd(a - b, b)\".\n        // If a < b then \"gcd(a, b)\" is equal to \"gcd(b - a, a)\".\n        // Hence, in the successive iterations:\n        //  \"a\" becomes the absolute difference of the current values,\n        //  \"b\" becomes the minimum of the current values.\n        while (a != b) {\n            final int delta = a - b;\n            b = Math.min(a, b);\n            a = Math.abs(delta);\n\n            // Remove any power of 2 in \"a\" (\"b\" is guaranteed to be odd).\n            a >>= Integer.numberOfTrailingZeros(a);\n        }\n\n        // Recover the common power of 2.\nif((a == 0)){\n}\n        return a >>> shift;    }",
          "50": "    private static int gcdPositive(int a,\n                                   int b) {\n        if (a == 0) {\n            return b;\n        }\n        else if (b == 0) {\n            return a;\n        }\n\n        // Make \"a\" and \"b\" odd, keeping track of common power of 2.\n        final int aTwos = Integer.numberOfTrailingZeros(a);\n        a >>= aTwos;\n        final int bTwos = Integer.numberOfTrailingZeros(b);\n        b >>= bTwos;\n        final int shift = Math.min(aTwos, bTwos);\n\n        // \"a\" and \"b\" are positive.\n        // If a > b then \"gdc(a, b)\" is equal to \"gcd(a - b, b)\".\n        // If a < b then \"gcd(a, b)\" is equal to \"gcd(b - a, a)\".\n        // Hence, in the successive iterations:\n        //  \"a\" becomes the absolute difference of the current values,\n        //  \"b\" becomes the minimum of the current values.\n        while (a != b) {\n            final int delta = a - b;\n            b = Math.min(a, b);\n            a = Math.abs(delta);\n\n            // Remove any power of 2 in \"a\" (\"b\" is guaranteed to be odd).\n            a >>= Integer.numberOfTrailingZeros(a);\n        }\n\n        // Recover the common power of 2.\na = a;\n        return a >>> shift;    }",
          "51": "    private static int gcdPositive(int a,\n                                   int b) {\n        if (a == 0) {\n            return b;\n        }\n        else if (b == 0) {\n            return a;\n        }\n\n        // Make \"a\" and \"b\" odd, keeping track of common power of 2.\n        final int aTwos = Integer.numberOfTrailingZeros(a);\n        a >>= aTwos;\n        final int bTwos = Integer.numberOfTrailingZeros(b);\n        b >>= bTwos;\n        final int shift = Math.min(aTwos, bTwos);\n\n        // \"a\" and \"b\" are positive.\n        // If a > b then \"gdc(a, b)\" is equal to \"gcd(a - b, b)\".\n        // If a < b then \"gcd(a, b)\" is equal to \"gcd(b - a, a)\".\n        // Hence, in the successive iterations:\n        //  \"a\" becomes the absolute difference of the current values,\n        //  \"b\" becomes the minimum of the current values.\n        while (a != b) {\n            final int delta = a - b;\n            b = Math.min(a, b);\n            a = Math.abs(delta);\n\n            // Remove any power of 2 in \"a\" (\"b\" is guaranteed to be odd).\n            a >>= Integer.numberOfTrailingZeros(a);\n        }\n\n        // Recover the common power of 2.\nbreak;\n    }",
          "52": "    private static int gcdPositive(int a,\n                                   int b) {\n        if (a == 0) {\n            return b;\n        }\n        else if (b == 0) {\n            return a;\n        }\n\n        // Make \"a\" and \"b\" odd, keeping track of common power of 2.\n        final int aTwos = Integer.numberOfTrailingZeros(a);\n        a >>= aTwos;\n        final int bTwos = Integer.numberOfTrailingZeros(b);\n        b >>= bTwos;\n        final int shift = Math.min(aTwos, bTwos);\n\n        // \"a\" and \"b\" are positive.\n        // If a > b then \"gdc(a, b)\" is equal to \"gcd(a - b, b)\".\n        // If a < b then \"gcd(a, b)\" is equal to \"gcd(b - a, a)\".\n        // Hence, in the successive iterations:\n        //  \"a\" becomes the absolute difference of the current values,\n        //  \"b\" becomes the minimum of the current values.\n        while (a != b) {\n            final int delta = a - b;\n            b = Math.min(a, b);\n            a = Math.abs(delta);\n\n            // Remove any power of 2 in \"a\" (\"b\" is guaranteed to be odd).\n            a >>= Integer.numberOfTrailingZeros(a);\n        }\n\n        // Recover the common power of 2.\nreturn 0;    }",
          "53": "    private static int gcdPositive(int a,\n                                   int b) {\n        if (a == 0) {\n            return b;\n        }\n        else if (b == 0) {\n            return a;\n        }\n\n        // Make \"a\" and \"b\" odd, keeping track of common power of 2.\n        final int aTwos = Integer.numberOfTrailingZeros(a);\n        a >>= aTwos;\n        final int bTwos = Integer.numberOfTrailingZeros(b);\n        b >>= bTwos;\n        final int shift = Math.min(aTwos, bTwos);\n\n        // \"a\" and \"b\" are positive.\n        // If a > b then \"gdc(a, b)\" is equal to \"gcd(a - b, b)\".\n        // If a < b then \"gcd(a, b)\" is equal to \"gcd(b - a, a)\".\n        // Hence, in the successive iterations:\n        //  \"a\" becomes the absolute difference of the current values,\n        //  \"b\" becomes the minimum of the current values.\n        while (a != b) {\n            final int delta = a - b;\n            b = Math.min(a, b);\n            a = Math.abs(delta);\n\n            // Remove any power of 2 in \"a\" (\"b\" is guaranteed to be odd).\n            a >>= Integer.numberOfTrailingZeros(a);\n        }\n\n        // Recover the common power of 2.\nreturn (a != b);    }",
          "54": "    private static int gcdPositive(int a,\n                                   int b) {\n        if (a == 0) {\n            return b;\n        }\n        else if (b == 0) {\n            return a;\n        }\n\n        // Make \"a\" and \"b\" odd, keeping track of common power of 2.\n        final int aTwos = Integer.numberOfTrailingZeros(a);\n        a >>= aTwos;\n        final int bTwos = Integer.numberOfTrailingZeros(b);\n        b >>= bTwos;\n        final int shift = Math.min(aTwos, bTwos);\n\n        // \"a\" and \"b\" are positive.\n        // If a > b then \"gdc(a, b)\" is equal to \"gcd(a - b, b)\".\n        // If a < b then \"gcd(a, b)\" is equal to \"gcd(b - a, a)\".\n        // Hence, in the successive iterations:\n        //  \"a\" becomes the absolute difference of the current values,\n        //  \"b\" becomes the minimum of the current values.\n        while (a != b) {\n            final int delta = a - b;\n            b = Math.min(a, b);\n            a = Math.abs(delta);\n\n            // Remove any power of 2 in \"a\" (\"b\" is guaranteed to be odd).\n            a >>= Integer.numberOfTrailingZeros(a);\n        }\n\n        // Recover the common power of 2.\na >>= aTwos;\na >>= Integer.numberOfTrailingZeros(a);\n        return a >>> shift;    }",
          "55": "    private static int gcdPositive(int a,\n                                   int b) {\n        if (a == 0) {\n            return b;\n        }\n        else if (b == 0) {\n            return a;\n        }\n\n        // Make \"a\" and \"b\" odd, keeping track of common power of 2.\n        final int aTwos = Integer.numberOfTrailingZeros(a);\n        a >>= aTwos;\n        final int bTwos = Integer.numberOfTrailingZeros(b);\n        b >>= bTwos;\n        final int shift = Math.min(aTwos, bTwos);\n\n        // \"a\" and \"b\" are positive.\n        // If a > b then \"gdc(a, b)\" is equal to \"gcd(a - b, b)\".\n        // If a < b then \"gcd(a, b)\" is equal to \"gcd(b - a, a)\".\n        // Hence, in the successive iterations:\n        //  \"a\" becomes the absolute difference of the current values,\n        //  \"b\" becomes the minimum of the current values.\n        while (a != b) {\n            final int delta = a - b;\n            b = Math.min(a, b);\n            a = Math.abs(delta);\n\n            // Remove any power of 2 in \"a\" (\"b\" is guaranteed to be odd).\n            a >>= Integer.numberOfTrailingZeros(a);\n        }\n\n        // Recover the common power of 2.\ncontinue;\n        return a >>> shift;    }",
          "56": "    private static int gcdPositive(int a,\n                                   int b) {\n        if (a == 0) {\n            return b;\n        }\n        else if (b == 0) {\n            return a;\n        }\n\n        // Make \"a\" and \"b\" odd, keeping track of common power of 2.\n        final int aTwos = Integer.numberOfTrailingZeros(a);\n        a >>= aTwos;\n        final int bTwos = Integer.numberOfTrailingZeros(b);\n        b >>= bTwos;\n        final int shift = Math.min(aTwos, bTwos);\n\n        // \"a\" and \"b\" are positive.\n        // If a > b then \"gdc(a, b)\" is equal to \"gcd(a - b, b)\".\n        // If a < b then \"gcd(a, b)\" is equal to \"gcd(b - a, a)\".\n        // Hence, in the successive iterations:\n        //  \"a\" becomes the absolute difference of the current values,\n        //  \"b\" becomes the minimum of the current values.\n        while (a != b) {\n            final int delta = a - b;\n            b = Math.min(a, b);\n            a = Math.abs(delta);\n\n            // Remove any power of 2 in \"a\" (\"b\" is guaranteed to be odd).\n            a >>= Integer.numberOfTrailingZeros(a);\n        }\n\n        // Recover the common power of 2.\nreturn;\n    }",
          "57": "    private static int gcdPositive(int a,\n                                   int b) {\n        if (a == 0) {\n            return b;\n        }\n        else if (b == 0) {\n            return a;\n        }\n\n        // Make \"a\" and \"b\" odd, keeping track of common power of 2.\n        final int aTwos = Integer.numberOfTrailingZeros(a);\n        a >>= aTwos;\n        final int bTwos = Integer.numberOfTrailingZeros(b);\n        b >>= bTwos;\n        final int shift = Math.min(aTwos, bTwos);\n\n        // \"a\" and \"b\" are positive.\n        // If a > b then \"gdc(a, b)\" is equal to \"gcd(a - b, b)\".\n        // If a < b then \"gcd(a, b)\" is equal to \"gcd(b - a, a)\".\n        // Hence, in the successive iterations:\n        //  \"a\" becomes the absolute difference of the current values,\n        //  \"b\" becomes the minimum of the current values.\n        while (a != b) {\n            final int delta = a - b;\n            b = Math.min(a, b);\n            a = Math.abs(delta);\n\n            // Remove any power of 2 in \"a\" (\"b\" is guaranteed to be odd).\n            a >>= Integer.numberOfTrailingZeros(a);\n        }\n\n        // Recover the common power of 2.\nreturn (a >>> );    }",
          "58": "    private static int gcdPositive(int a,\n                                   int b) {\n        if (a == 0) {\n            return b;\n        }\n        else if (b == 0) {\n            return a;\n        }\n\n        // Make \"a\" and \"b\" odd, keeping track of common power of 2.\n        final int aTwos = Integer.numberOfTrailingZeros(a);\n        a >>= aTwos;\n        final int bTwos = Integer.numberOfTrailingZeros(b);\n        b >>= bTwos;\n        final int shift = Math.min(aTwos, bTwos);\n\n        // \"a\" and \"b\" are positive.\n        // If a > b then \"gdc(a, b)\" is equal to \"gcd(a - b, b)\".\n        // If a < b then \"gcd(a, b)\" is equal to \"gcd(b - a, a)\".\n        // Hence, in the successive iterations:\n        //  \"a\" becomes the absolute difference of the current values,\n        //  \"b\" becomes the minimum of the current values.\n        while (a != b) {\n            final int delta = a - b;\n            b = Math.min(a, b);\n            a = Math.abs(delta);\n\n            // Remove any power of 2 in \"a\" (\"b\" is guaranteed to be odd).\n            a >>= Integer.numberOfTrailingZeros(a);\n        }\n\n        // Recover the common power of 2.\na = Integer.numberOfTrailingZeros(a);\n        return a >>> shift;    }",
          "59": "    private static int gcdPositive(int a,\n                                   int b) {\n        if (a == 0) {\n            return b;\n        }\n        else if (b == 0) {\n            return a;\n        }\n\n        // Make \"a\" and \"b\" odd, keeping track of common power of 2.\n        final int aTwos = Integer.numberOfTrailingZeros(a);\n        a >>= aTwos;\n        final int bTwos = Integer.numberOfTrailingZeros(b);\n        b >>= bTwos;\n        final int shift = Math.min(aTwos, bTwos);\n\n        // \"a\" and \"b\" are positive.\n        // If a > b then \"gdc(a, b)\" is equal to \"gcd(a - b, b)\".\n        // If a < b then \"gcd(a, b)\" is equal to \"gcd(b - a, a)\".\n        // Hence, in the successive iterations:\n        //  \"a\" becomes the absolute difference of the current values,\n        //  \"b\" becomes the minimum of the current values.\n        while (a != b) {\n            final int delta = a - b;\n            b = Math.min(a, b);\n            a = Math.abs(delta);\n\n            // Remove any power of 2 in \"a\" (\"b\" is guaranteed to be odd).\n            a >>= Integer.numberOfTrailingZeros(a);\n        }\n\n        // Recover the common power of 2.\n        return a >>> shift;    }",
          "60": "    private static int gcdPositive(int a,\n                                   int b) {\n        if (a == 0) {\n            return b;\n        }\n        else if (b == 0) {\n            return a;\n        }\n\n        // Make \"a\" and \"b\" odd, keeping track of common power of 2.\n        final int aTwos = Integer.numberOfTrailingZeros(a);\n        a >>= aTwos;\n        final int bTwos = Integer.numberOfTrailingZeros(b);\n        b >>= bTwos;\n        final int shift = Math.min(aTwos, bTwos);\n\n        // \"a\" and \"b\" are positive.\n        // If a > b then \"gdc(a, b)\" is equal to \"gcd(a - b, b)\".\n        // If a < b then \"gcd(a, b)\" is equal to \"gcd(b - a, a)\".\n        // Hence, in the successive iterations:\n        //  \"a\" becomes the absolute difference of the current values,\n        //  \"b\" becomes the minimum of the current values.\n        while (a != b) {\n            final int delta = a - b;\n            b = Math.min(a, b);\n            a = Math.abs(delta);\n\n            // Remove any power of 2 in \"a\" (\"b\" is guaranteed to be odd).\n            a >>= Integer.numberOfTrailingZeros(a);\n        }\n\n        // Recover the common power of 2.\nif((b != null)){\n}\n        return a >>> shift;    }",
          "61": "    private static int gcdPositive(int a,\n                                   int b) {\n        if (a == 0) {\n            return b;\n        }\n        else if (b == 0) {\n            return a;\n        }\n\n        // Make \"a\" and \"b\" odd, keeping track of common power of 2.\n        final int aTwos = Integer.numberOfTrailingZeros(a);\n        a >>= aTwos;\n        final int bTwos = Integer.numberOfTrailingZeros(b);\n        b >>= bTwos;\n        final int shift = Math.min(aTwos, bTwos);\n\n        // \"a\" and \"b\" are positive.\n        // If a > b then \"gdc(a, b)\" is equal to \"gcd(a - b, b)\".\n        // If a < b then \"gcd(a, b)\" is equal to \"gcd(b - a, a)\".\n        // Hence, in the successive iterations:\n        //  \"a\" becomes the absolute difference of the current values,\n        //  \"b\" becomes the minimum of the current values.\n        while (a != b) {\n            final int delta = a - b;\n            b = Math.min(a, b);\n            a = Math.abs(delta);\n\n            // Remove any power of 2 in \"a\" (\"b\" is guaranteed to be odd).\n            a >>= Integer.numberOfTrailingZeros(a);\n        }\n\n        // Recover the common power of 2.\na = Integer.numberOfTrailingZeros(a, b);\n        return a >>> shift;    }",
          "62": "    private static int gcdPositive(int a,\n                                   int b) {\n        if (a == 0) {\n            return b;\n        }\n        else if (b == 0) {\n            return a;\n        }\n\n        // Make \"a\" and \"b\" odd, keeping track of common power of 2.\n        final int aTwos = Integer.numberOfTrailingZeros(a);\n        a >>= aTwos;\n        final int bTwos = Integer.numberOfTrailingZeros(b);\n        b >>= bTwos;\n        final int shift = Math.min(aTwos, bTwos);\n\n        // \"a\" and \"b\" are positive.\n        // If a > b then \"gdc(a, b)\" is equal to \"gcd(a - b, b)\".\n        // If a < b then \"gcd(a, b)\" is equal to \"gcd(b - a, a)\".\n        // Hence, in the successive iterations:\n        //  \"a\" becomes the absolute difference of the current values,\n        //  \"b\" becomes the minimum of the current values.\n        while (a != b) {\n            final int delta = a - b;\n            b = Math.min(a, b);\n            a = Math.abs(delta);\n\n            // Remove any power of 2 in \"a\" (\"b\" is guaranteed to be odd).\n            a >>= Integer.numberOfTrailingZeros(a);\n        }\n\n        // Recover the common power of 2.\na = Integer.numberOfTrailingZeros(b, b);\n        return a >>> shift;    }",
          "63": "    private static int gcdPositive(int a,\n                                   int b) {\n        if (a == 0) {\n            return b;\n        }\n        else if (b == 0) {\n            return a;\n        }\n\n        // Make \"a\" and \"b\" odd, keeping track of common power of 2.\n        final int aTwos = Integer.numberOfTrailingZeros(a);\n        a >>= aTwos;\n        final int bTwos = Integer.numberOfTrailingZeros(b);\n        b >>= bTwos;\n        final int shift = Math.min(aTwos, bTwos);\n\n        // \"a\" and \"b\" are positive.\n        // If a > b then \"gdc(a, b)\" is equal to \"gcd(a - b, b)\".\n        // If a < b then \"gcd(a, b)\" is equal to \"gcd(b - a, a)\".\n        // Hence, in the successive iterations:\n        //  \"a\" becomes the absolute difference of the current values,\n        //  \"b\" becomes the minimum of the current values.\n        while (a != b) {\n            final int delta = a - b;\n            b = Math.min(a, b);\n            a = Math.abs(delta);\n\n            // Remove any power of 2 in \"a\" (\"b\" is guaranteed to be odd).\n            a >>= Integer.numberOfTrailingZeros(a);\n        }\n\n        // Recover the common power of 2.\nif((b != null)){\na = shift;\n}        return a >>> shift;    }",
          "64": "    private static int gcdPositive(int a,\n                                   int b) {\n        if (a == 0) {\n            return b;\n        }\n        else if (b == 0) {\n            return a;\n        }\n\n        // Make \"a\" and \"b\" odd, keeping track of common power of 2.\n        final int aTwos = Integer.numberOfTrailingZeros(a);\n        a >>= aTwos;\n        final int bTwos = Integer.numberOfTrailingZeros(b);\n        b >>= bTwos;\n        final int shift = Math.min(aTwos, bTwos);\n\n        // \"a\" and \"b\" are positive.\n        // If a > b then \"gdc(a, b)\" is equal to \"gcd(a - b, b)\".\n        // If a < b then \"gcd(a, b)\" is equal to \"gcd(b - a, a)\".\n        // Hence, in the successive iterations:\n        //  \"a\" becomes the absolute difference of the current values,\n        //  \"b\" becomes the minimum of the current values.\n        while (a != b) {\n            final int delta = a - b;\n            b = Math.min(a, b);\n            a = Math.abs(delta);\n\n            // Remove any power of 2 in \"a\" (\"b\" is guaranteed to be odd).\n            a >>= Integer.numberOfTrailingZeros(a);\n        }\n\n        // Recover the common power of 2.\nif((bTwos != null)){\na = shift;\n}        return a >>> shift;    }",
          "65": "    private static int gcdPositive(int a,\n                                   int b) {\n        if (a == 0) {\n            return b;\n        }\n        else if (b == 0) {\n            return a;\n        }\n\n        // Make \"a\" and \"b\" odd, keeping track of common power of 2.\n        final int aTwos = Integer.numberOfTrailingZeros(a);\n        a >>= aTwos;\n        final int bTwos = Integer.numberOfTrailingZeros(b);\n        b >>= bTwos;\n        final int shift = Math.min(aTwos, bTwos);\n\n        // \"a\" and \"b\" are positive.\n        // If a > b then \"gdc(a, b)\" is equal to \"gcd(a - b, b)\".\n        // If a < b then \"gcd(a, b)\" is equal to \"gcd(b - a, a)\".\n        // Hence, in the successive iterations:\n        //  \"a\" becomes the absolute difference of the current values,\n        //  \"b\" becomes the minimum of the current values.\n        while (a != b) {\n            final int delta = a - b;\n            b = Math.min(a, b);\n            a = Math.abs(delta);\n\n            // Remove any power of 2 in \"a\" (\"b\" is guaranteed to be odd).\n            a >>= Integer.numberOfTrailingZeros(a);\n        }\n\n        // Recover the common power of 2.\nif((b != null)){\na = bTwos;\n}        return a >>> shift;    }"
}