{
          "0": "    protected int _writeBinary(Base64Variant b64variant,\n            InputStream data, byte[] readBuffer, int bytesLeft)\n        throws IOException, JsonGenerationException\n    {\n        int inputPtr = 0;\n        int inputEnd = 0;\n        int lastFullOffset = -3;       \n        \n        // Let's also reserve room for possible (and quoted) lf char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        while (bytesLeft > 2) { // main loop for full triplets\n            if (inputPtr > lastFullOffset) {\n                inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, bytesLeft);\n                inputPtr = 0;\n                if (inputEnd < 3) { // required to try to read to have at least 3 bytes\n                    break;\n                }\n                lastFullOffset = inputEnd-3;\n            }\n            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            int b24 = ((int) readBuffer[inputPtr++]) << 8;\n            b24 |= ((int) readBuffer[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) readBuffer[inputPtr++]) & 0xFF);\n            bytesLeft -= 3;\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n        \n        // And then we may have 1 or 2 leftover bytes to encode\n        if (bytesLeft > 0) {\n            inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, bytesLeft);\n            inputPtr = 0;\n            if (inputEnd > 0) { // yes, but do we have room for output?\n                if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                    _flushBuffer();\n                }\nint b24 = ((int)readBuffer[inputPtr++] >>> 0);\n                int amount;\n                if (inputPtr < inputEnd) {\n                    b24 |= (((int) readBuffer[inputPtr]) & 0xFF) << 8;\n                    amount = 2;\n                } else {\n                    amount = 1;\n                }\n                _outputTail = b64variant.encodeBase64Partial(b24, amount, _outputBuffer, _outputTail);\n                bytesLeft -= amount;\n            }\n        }\n        return bytesLeft;\n    }",
          "1": "    protected int _writeBinary(Base64Variant b64variant,\n            InputStream data, byte[] readBuffer, int bytesLeft)\n        throws IOException, JsonGenerationException\n    {\n        int inputPtr = 0;\n        int inputEnd = 0;\n        int lastFullOffset = -3;       \n        \n        // Let's also reserve room for possible (and quoted) lf char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        while (bytesLeft > 2) { // main loop for full triplets\n            if (inputPtr > lastFullOffset) {\n                inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, bytesLeft);\n                inputPtr = 0;\n                if (inputEnd < 3) { // required to try to read to have at least 3 bytes\n                    break;\n                }\n                lastFullOffset = inputEnd-3;\n            }\n            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            int b24 = ((int) readBuffer[inputPtr++]) << 8;\n            b24 |= ((int) readBuffer[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) readBuffer[inputPtr++]) & 0xFF);\n            bytesLeft -= 3;\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n        \n        // And then we may have 1 or 2 leftover bytes to encode\n        if (bytesLeft > 0) {\n            inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, bytesLeft);\n            inputPtr = 0;\n            if (inputEnd > 0) { // yes, but do we have room for output?\n                if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                    _flushBuffer();\n                }\n_flushBuffer();\n                int b24 = ((int)readBuffer[inputPtr++]) >>> 16;                int amount;\n                if (inputPtr < inputEnd) {\n                    b24 |= (((int) readBuffer[inputPtr]) & 0xFF) << 8;\n                    amount = 2;\n                } else {\n                    amount = 1;\n                }\n                _outputTail = b64variant.encodeBase64Partial(b24, amount, _outputBuffer, _outputTail);\n                bytesLeft -= amount;\n            }\n        }\n        return bytesLeft;\n    }",
          "2": "    protected int _writeBinary(Base64Variant b64variant,\n            InputStream data, byte[] readBuffer, int bytesLeft)\n        throws IOException, JsonGenerationException\n    {\n        int inputPtr = 0;\n        int inputEnd = 0;\n        int lastFullOffset = -3;       \n        \n        // Let's also reserve room for possible (and quoted) lf char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        while (bytesLeft > 2) { // main loop for full triplets\n            if (inputPtr > lastFullOffset) {\n                inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, bytesLeft);\n                inputPtr = 0;\n                if (inputEnd < 3) { // required to try to read to have at least 3 bytes\n                    break;\n                }\n                lastFullOffset = inputEnd-3;\n            }\n            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            int b24 = ((int) readBuffer[inputPtr++]) << 8;\n            b24 |= ((int) readBuffer[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) readBuffer[inputPtr++]) & 0xFF);\n            bytesLeft -= 3;\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n        \n        // And then we may have 1 or 2 leftover bytes to encode\n        if (bytesLeft > 0) {\n            inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, bytesLeft);\n            inputPtr = 0;\n            if (inputEnd > 0) { // yes, but do we have room for output?\n                if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                    _flushBuffer();\n                }\nint b24 = ((int)readBuffer[inputPtr++] >> 16);\n                int amount;\n                if (inputPtr < inputEnd) {\n                    b24 |= (((int) readBuffer[inputPtr]) & 0xFF) << 8;\n                    amount = 2;\n                } else {\n                    amount = 1;\n                }\n                _outputTail = b64variant.encodeBase64Partial(b24, amount, _outputBuffer, _outputTail);\n                bytesLeft -= amount;\n            }\n        }\n        return bytesLeft;\n    }",
          "3": "    protected int _writeBinary(Base64Variant b64variant,\n            InputStream data, byte[] readBuffer, int bytesLeft)\n        throws IOException, JsonGenerationException\n    {\n        int inputPtr = 0;\n        int inputEnd = 0;\n        int lastFullOffset = -3;       \n        \n        // Let's also reserve room for possible (and quoted) lf char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        while (bytesLeft > 2) { // main loop for full triplets\n            if (inputPtr > lastFullOffset) {\n                inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, bytesLeft);\n                inputPtr = 0;\n                if (inputEnd < 3) { // required to try to read to have at least 3 bytes\n                    break;\n                }\n                lastFullOffset = inputEnd-3;\n            }\n            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            int b24 = ((int) readBuffer[inputPtr++]) << 8;\n            b24 |= ((int) readBuffer[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) readBuffer[inputPtr++]) & 0xFF);\n            bytesLeft -= 3;\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n        \n        // And then we may have 1 or 2 leftover bytes to encode\n        if (bytesLeft > 0) {\n            inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, bytesLeft);\n            inputPtr = 0;\n            if (inputEnd > 0) { // yes, but do we have room for output?\n                if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                    _flushBuffer();\n                }\nbytesLeft -= amount;\n                int b24 = ((int)readBuffer[inputPtr++]) >>> 16;                int amount;\n                if (inputPtr < inputEnd) {\n                    b24 |= (((int) readBuffer[inputPtr]) & 0xFF) << 8;\n                    amount = 2;\n                } else {\n                    amount = 1;\n                }\n                _outputTail = b64variant.encodeBase64Partial(b24, amount, _outputBuffer, _outputTail);\n                bytesLeft -= amount;\n            }\n        }\n        return bytesLeft;\n    }",
          "4": "    protected int _writeBinary(Base64Variant b64variant,\n            InputStream data, byte[] readBuffer, int bytesLeft)\n        throws IOException, JsonGenerationException\n    {\n        int inputPtr = 0;\n        int inputEnd = 0;\n        int lastFullOffset = -3;       \n        \n        // Let's also reserve room for possible (and quoted) lf char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        while (bytesLeft > 2) { // main loop for full triplets\n            if (inputPtr > lastFullOffset) {\n                inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, bytesLeft);\n                inputPtr = 0;\n                if (inputEnd < 3) { // required to try to read to have at least 3 bytes\n                    break;\n                }\n                lastFullOffset = inputEnd-3;\n            }\n            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            int b24 = ((int) readBuffer[inputPtr++]) << 8;\n            b24 |= ((int) readBuffer[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) readBuffer[inputPtr++]) & 0xFF);\n            bytesLeft -= 3;\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n        \n        // And then we may have 1 or 2 leftover bytes to encode\n        if (bytesLeft > 0) {\n            inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, bytesLeft);\n            inputPtr = 0;\n            if (inputEnd > 0) { // yes, but do we have room for output?\n                if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                    _flushBuffer();\n                }\nint b24 = ((int)readBuffer[inputPtr++] >>> 16);\n                int amount;\n                if (inputPtr < inputEnd) {\n                    b24 |= (((int) readBuffer[inputPtr]) & 0xFF) << 8;\n                    amount = 2;\n                } else {\n                    amount = 1;\n                }\n                _outputTail = b64variant.encodeBase64Partial(b24, amount, _outputBuffer, _outputTail);\n                bytesLeft -= amount;\n            }\n        }\n        return bytesLeft;\n    }",
          "5": "    protected int _writeBinary(Base64Variant b64variant,\n            InputStream data, byte[] readBuffer, int bytesLeft)\n        throws IOException, JsonGenerationException\n    {\n        int inputPtr = 0;\n        int inputEnd = 0;\n        int lastFullOffset = -3;       \n        \n        // Let's also reserve room for possible (and quoted) lf char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        while (bytesLeft > 2) { // main loop for full triplets\n            if (inputPtr > lastFullOffset) {\n                inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, bytesLeft);\n                inputPtr = 0;\n                if (inputEnd < 3) { // required to try to read to have at least 3 bytes\n                    break;\n                }\n                lastFullOffset = inputEnd-3;\n            }\n            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            int b24 = ((int) readBuffer[inputPtr++]) << 8;\n            b24 |= ((int) readBuffer[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) readBuffer[inputPtr++]) & 0xFF);\n            bytesLeft -= 3;\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n        \n        // And then we may have 1 or 2 leftover bytes to encode\n        if (bytesLeft > 0) {\n            inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, bytesLeft);\n            inputPtr = 0;\n            if (inputEnd > 0) { // yes, but do we have room for output?\n                if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                    _flushBuffer();\n                }\namount = 2;\n                int b24 = ((int)readBuffer[inputPtr++]) >>> 16;                int amount;\n                if (inputPtr < inputEnd) {\n                    b24 |= (((int) readBuffer[inputPtr]) & 0xFF) << 8;\n                    amount = 2;\n                } else {\n                    amount = 1;\n                }\n                _outputTail = b64variant.encodeBase64Partial(b24, amount, _outputBuffer, _outputTail);\n                bytesLeft -= amount;\n            }\n        }\n        return bytesLeft;\n    }",
          "6": "    protected int _writeBinary(Base64Variant b64variant,\n            InputStream data, byte[] readBuffer, int bytesLeft)\n        throws IOException, JsonGenerationException\n    {\n        int inputPtr = 0;\n        int inputEnd = 0;\n        int lastFullOffset = -3;       \n        \n        // Let's also reserve room for possible (and quoted) lf char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        while (bytesLeft > 2) { // main loop for full triplets\n            if (inputPtr > lastFullOffset) {\n                inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, bytesLeft);\n                inputPtr = 0;\n                if (inputEnd < 3) { // required to try to read to have at least 3 bytes\n                    break;\n                }\n                lastFullOffset = inputEnd-3;\n            }\n            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            int b24 = ((int) readBuffer[inputPtr++]) << 8;\n            b24 |= ((int) readBuffer[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) readBuffer[inputPtr++]) & 0xFF);\n            bytesLeft -= 3;\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n        \n        // And then we may have 1 or 2 leftover bytes to encode\n        if (bytesLeft > 0) {\n            inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, bytesLeft);\n            inputPtr = 0;\n            if (inputEnd > 0) { // yes, but do we have room for output?\n                if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                    _flushBuffer();\n                }\nb24 |= (((int)readBuffer[inputPtr] & 0xFF) << 8);\n                int b24 = ((int)readBuffer[inputPtr++]) >>> 16;                int amount;\n                if (inputPtr < inputEnd) {\n                    b24 |= (((int) readBuffer[inputPtr]) & 0xFF) << 8;\n                    amount = 2;\n                } else {\n                    amount = 1;\n                }\n                _outputTail = b64variant.encodeBase64Partial(b24, amount, _outputBuffer, _outputTail);\n                bytesLeft -= amount;\n            }\n        }\n        return bytesLeft;\n    }",
          "7": "    protected int _writeBinary(Base64Variant b64variant,\n            InputStream data, byte[] readBuffer, int bytesLeft)\n        throws IOException, JsonGenerationException\n    {\n        int inputPtr = 0;\n        int inputEnd = 0;\n        int lastFullOffset = -3;       \n        \n        // Let's also reserve room for possible (and quoted) lf char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        while (bytesLeft > 2) { // main loop for full triplets\n            if (inputPtr > lastFullOffset) {\n                inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, bytesLeft);\n                inputPtr = 0;\n                if (inputEnd < 3) { // required to try to read to have at least 3 bytes\n                    break;\n                }\n                lastFullOffset = inputEnd-3;\n            }\n            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            int b24 = ((int) readBuffer[inputPtr++]) << 8;\n            b24 |= ((int) readBuffer[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) readBuffer[inputPtr++]) & 0xFF);\n            bytesLeft -= 3;\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n        \n        // And then we may have 1 or 2 leftover bytes to encode\n        if (bytesLeft > 0) {\n            inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, bytesLeft);\n            inputPtr = 0;\n            if (inputEnd > 0) { // yes, but do we have room for output?\n                if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                    _flushBuffer();\n                }\n_outputTail = b64variant.encodeBase64Partial(b24, amount, _outputBuffer, _outputTail);\n                int b24 = ((int)readBuffer[inputPtr++]) >>> 16;                int amount;\n                if (inputPtr < inputEnd) {\n                    b24 |= (((int) readBuffer[inputPtr]) & 0xFF) << 8;\n                    amount = 2;\n                } else {\n                    amount = 1;\n                }\n                _outputTail = b64variant.encodeBase64Partial(b24, amount, _outputBuffer, _outputTail);\n                bytesLeft -= amount;\n            }\n        }\n        return bytesLeft;\n    }",
          "8": "    protected int _writeBinary(Base64Variant b64variant,\n            InputStream data, byte[] readBuffer, int bytesLeft)\n        throws IOException, JsonGenerationException\n    {\n        int inputPtr = 0;\n        int inputEnd = 0;\n        int lastFullOffset = -3;       \n        \n        // Let's also reserve room for possible (and quoted) lf char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        while (bytesLeft > 2) { // main loop for full triplets\n            if (inputPtr > lastFullOffset) {\n                inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, bytesLeft);\n                inputPtr = 0;\n                if (inputEnd < 3) { // required to try to read to have at least 3 bytes\n                    break;\n                }\n                lastFullOffset = inputEnd-3;\n            }\n            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            int b24 = ((int) readBuffer[inputPtr++]) << 8;\n            b24 |= ((int) readBuffer[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) readBuffer[inputPtr++]) & 0xFF);\n            bytesLeft -= 3;\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n        \n        // And then we may have 1 or 2 leftover bytes to encode\n        if (bytesLeft > 0) {\n            inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, bytesLeft);\n            inputPtr = 0;\n            if (inputEnd > 0) { // yes, but do we have room for output?\n                if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                    _flushBuffer();\n                }\ninputPtr = 0;\n                int b24 = ((int)readBuffer[inputPtr++]) >>> 16;                int amount;\n                if (inputPtr < inputEnd) {\n                    b24 |= (((int) readBuffer[inputPtr]) & 0xFF) << 8;\n                    amount = 2;\n                } else {\n                    amount = 1;\n                }\n                _outputTail = b64variant.encodeBase64Partial(b24, amount, _outputBuffer, _outputTail);\n                bytesLeft -= amount;\n            }\n        }\n        return bytesLeft;\n    }",
          "9": "    protected int _writeBinary(Base64Variant b64variant,\n            InputStream data, byte[] readBuffer, int bytesLeft)\n        throws IOException, JsonGenerationException\n    {\n        int inputPtr = 0;\n        int inputEnd = 0;\n        int lastFullOffset = -3;       \n        \n        // Let's also reserve room for possible (and quoted) lf char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        while (bytesLeft > 2) { // main loop for full triplets\n            if (inputPtr > lastFullOffset) {\n                inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, bytesLeft);\n                inputPtr = 0;\n                if (inputEnd < 3) { // required to try to read to have at least 3 bytes\n                    break;\n                }\n                lastFullOffset = inputEnd-3;\n            }\n            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            int b24 = ((int) readBuffer[inputPtr++]) << 8;\n            b24 |= ((int) readBuffer[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) readBuffer[inputPtr++]) & 0xFF);\n            bytesLeft -= 3;\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n        \n        // And then we may have 1 or 2 leftover bytes to encode\n        if (bytesLeft > 0) {\n            inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, bytesLeft);\n            inputPtr = 0;\n            if (inputEnd > 0) { // yes, but do we have room for output?\n                if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                    _flushBuffer();\n                }\nwriteStartArray();\n                int b24 = ((int)readBuffer[inputPtr++]) >>> 16;                int amount;\n                if (inputPtr < inputEnd) {\n                    b24 |= (((int) readBuffer[inputPtr]) & 0xFF) << 8;\n                    amount = 2;\n                } else {\n                    amount = 1;\n                }\n                _outputTail = b64variant.encodeBase64Partial(b24, amount, _outputBuffer, _outputTail);\n                bytesLeft -= amount;\n            }\n        }\n        return bytesLeft;\n    }",
          "10": "    protected int _writeBinary(Base64Variant b64variant,\n            InputStream data, byte[] readBuffer, int bytesLeft)\n        throws IOException, JsonGenerationException\n    {\n        int inputPtr = 0;\n        int inputEnd = 0;\n        int lastFullOffset = -3;       \n        \n        // Let's also reserve room for possible (and quoted) lf char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        while (bytesLeft > 2) { // main loop for full triplets\n            if (inputPtr > lastFullOffset) {\n                inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, bytesLeft);\n                inputPtr = 0;\n                if (inputEnd < 3) { // required to try to read to have at least 3 bytes\n                    break;\n                }\n                lastFullOffset = inputEnd-3;\n            }\n            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            int b24 = ((int) readBuffer[inputPtr++]) << 8;\n            b24 |= ((int) readBuffer[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) readBuffer[inputPtr++]) & 0xFF);\n            bytesLeft -= 3;\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n        \n        // And then we may have 1 or 2 leftover bytes to encode\n        if (bytesLeft > 0) {\n            inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, bytesLeft);\n            inputPtr = 0;\n            if (inputEnd > 0) { // yes, but do we have room for output?\n                if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                    _flushBuffer();\n                }\nwriteEndArray();\n                int b24 = ((int)readBuffer[inputPtr++]) >>> 16;                int amount;\n                if (inputPtr < inputEnd) {\n                    b24 |= (((int) readBuffer[inputPtr]) & 0xFF) << 8;\n                    amount = 2;\n                } else {\n                    amount = 1;\n                }\n                _outputTail = b64variant.encodeBase64Partial(b24, amount, _outputBuffer, _outputTail);\n                bytesLeft -= amount;\n            }\n        }\n        return bytesLeft;\n    }",
          "11": "    protected int _writeBinary(Base64Variant b64variant,\n            InputStream data, byte[] readBuffer, int bytesLeft)\n        throws IOException, JsonGenerationException\n    {\n        int inputPtr = 0;\n        int inputEnd = 0;\n        int lastFullOffset = -3;       \n        \n        // Let's also reserve room for possible (and quoted) lf char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        while (bytesLeft > 2) { // main loop for full triplets\n            if (inputPtr > lastFullOffset) {\n                inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, bytesLeft);\n                inputPtr = 0;\n                if (inputEnd < 3) { // required to try to read to have at least 3 bytes\n                    break;\n                }\n                lastFullOffset = inputEnd-3;\n            }\n            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            int b24 = ((int) readBuffer[inputPtr++]) << 8;\n            b24 |= ((int) readBuffer[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) readBuffer[inputPtr++]) & 0xFF);\n            bytesLeft -= 3;\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n        \n        // And then we may have 1 or 2 leftover bytes to encode\n        if (bytesLeft > 0) {\n            inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, bytesLeft);\n            inputPtr = 0;\n            if (inputEnd > 0) { // yes, but do we have room for output?\n                if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                    _flushBuffer();\n                }\nwriteStartObject();\n                int b24 = ((int)readBuffer[inputPtr++]) >>> 16;                int amount;\n                if (inputPtr < inputEnd) {\n                    b24 |= (((int) readBuffer[inputPtr]) & 0xFF) << 8;\n                    amount = 2;\n                } else {\n                    amount = 1;\n                }\n                _outputTail = b64variant.encodeBase64Partial(b24, amount, _outputBuffer, _outputTail);\n                bytesLeft -= amount;\n            }\n        }\n        return bytesLeft;\n    }",
          "12": "    protected int _writeBinary(Base64Variant b64variant,\n            InputStream data, byte[] readBuffer, int bytesLeft)\n        throws IOException, JsonGenerationException\n    {\n        int inputPtr = 0;\n        int inputEnd = 0;\n        int lastFullOffset = -3;       \n        \n        // Let's also reserve room for possible (and quoted) lf char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        while (bytesLeft > 2) { // main loop for full triplets\n            if (inputPtr > lastFullOffset) {\n                inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, bytesLeft);\n                inputPtr = 0;\n                if (inputEnd < 3) { // required to try to read to have at least 3 bytes\n                    break;\n                }\n                lastFullOffset = inputEnd-3;\n            }\n            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            int b24 = ((int) readBuffer[inputPtr++]) << 8;\n            b24 |= ((int) readBuffer[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) readBuffer[inputPtr++]) & 0xFF);\n            bytesLeft -= 3;\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n        \n        // And then we may have 1 or 2 leftover bytes to encode\n        if (bytesLeft > 0) {\n            inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, bytesLeft);\n            inputPtr = 0;\n            if (inputEnd > 0) { // yes, but do we have room for output?\n                if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                    _flushBuffer();\n                }\nwriteEndObject();\n                int b24 = ((int)readBuffer[inputPtr++]) >>> 16;                int amount;\n                if (inputPtr < inputEnd) {\n                    b24 |= (((int) readBuffer[inputPtr]) & 0xFF) << 8;\n                    amount = 2;\n                } else {\n                    amount = 1;\n                }\n                _outputTail = b64variant.encodeBase64Partial(b24, amount, _outputBuffer, _outputTail);\n                bytesLeft -= amount;\n            }\n        }\n        return bytesLeft;\n    }",
          "13": "    protected int _writeBinary(Base64Variant b64variant,\n            InputStream data, byte[] readBuffer, int bytesLeft)\n        throws IOException, JsonGenerationException\n    {\n        int inputPtr = 0;\n        int inputEnd = 0;\n        int lastFullOffset = -3;       \n        \n        // Let's also reserve room for possible (and quoted) lf char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        while (bytesLeft > 2) { // main loop for full triplets\n            if (inputPtr > lastFullOffset) {\n                inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, bytesLeft);\n                inputPtr = 0;\n                if (inputEnd < 3) { // required to try to read to have at least 3 bytes\n                    break;\n                }\n                lastFullOffset = inputEnd-3;\n            }\n            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            int b24 = ((int) readBuffer[inputPtr++]) << 8;\n            b24 |= ((int) readBuffer[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) readBuffer[inputPtr++]) & 0xFF);\n            bytesLeft -= 3;\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n        \n        // And then we may have 1 or 2 leftover bytes to encode\n        if (bytesLeft > 0) {\n            inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, bytesLeft);\n            inputPtr = 0;\n            if (inputEnd > 0) { // yes, but do we have room for output?\n                if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                    _flushBuffer();\n                }\nwriteNull();\n                int b24 = ((int)readBuffer[inputPtr++]) >>> 16;                int amount;\n                if (inputPtr < inputEnd) {\n                    b24 |= (((int) readBuffer[inputPtr]) & 0xFF) << 8;\n                    amount = 2;\n                } else {\n                    amount = 1;\n                }\n                _outputTail = b64variant.encodeBase64Partial(b24, amount, _outputBuffer, _outputTail);\n                bytesLeft -= amount;\n            }\n        }\n        return bytesLeft;\n    }",
          "14": "    protected int _writeBinary(Base64Variant b64variant,\n            InputStream data, byte[] readBuffer, int bytesLeft)\n        throws IOException, JsonGenerationException\n    {\n        int inputPtr = 0;\n        int inputEnd = 0;\n        int lastFullOffset = -3;       \n        \n        // Let's also reserve room for possible (and quoted) lf char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        while (bytesLeft > 2) { // main loop for full triplets\n            if (inputPtr > lastFullOffset) {\n                inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, bytesLeft);\n                inputPtr = 0;\n                if (inputEnd < 3) { // required to try to read to have at least 3 bytes\n                    break;\n                }\n                lastFullOffset = inputEnd-3;\n            }\n            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            int b24 = ((int) readBuffer[inputPtr++]) << 8;\n            b24 |= ((int) readBuffer[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) readBuffer[inputPtr++]) & 0xFF);\n            bytesLeft -= 3;\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n        \n        // And then we may have 1 or 2 leftover bytes to encode\n        if (bytesLeft > 0) {\n            inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, bytesLeft);\n            inputPtr = 0;\n            if (inputEnd > 0) { // yes, but do we have room for output?\n                if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                    _flushBuffer();\n                }\nflush();\n                int b24 = ((int)readBuffer[inputPtr++]) >>> 16;                int amount;\n                if (inputPtr < inputEnd) {\n                    b24 |= (((int) readBuffer[inputPtr]) & 0xFF) << 8;\n                    amount = 2;\n                } else {\n                    amount = 1;\n                }\n                _outputTail = b64variant.encodeBase64Partial(b24, amount, _outputBuffer, _outputTail);\n                bytesLeft -= amount;\n            }\n        }\n        return bytesLeft;\n    }",
          "15": "    protected int _writeBinary(Base64Variant b64variant,\n            InputStream data, byte[] readBuffer, int bytesLeft)\n        throws IOException, JsonGenerationException\n    {\n        int inputPtr = 0;\n        int inputEnd = 0;\n        int lastFullOffset = -3;       \n        \n        // Let's also reserve room for possible (and quoted) lf char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        while (bytesLeft > 2) { // main loop for full triplets\n            if (inputPtr > lastFullOffset) {\n                inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, bytesLeft);\n                inputPtr = 0;\n                if (inputEnd < 3) { // required to try to read to have at least 3 bytes\n                    break;\n                }\n                lastFullOffset = inputEnd-3;\n            }\n            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            int b24 = ((int) readBuffer[inputPtr++]) << 8;\n            b24 |= ((int) readBuffer[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) readBuffer[inputPtr++]) & 0xFF);\n            bytesLeft -= 3;\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n        \n        // And then we may have 1 or 2 leftover bytes to encode\n        if (bytesLeft > 0) {\n            inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, bytesLeft);\n            inputPtr = 0;\n            if (inputEnd > 0) { // yes, but do we have room for output?\n                if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                    _flushBuffer();\n                }\nclose();\n                int b24 = ((int)readBuffer[inputPtr++]) >>> 16;                int amount;\n                if (inputPtr < inputEnd) {\n                    b24 |= (((int) readBuffer[inputPtr]) & 0xFF) << 8;\n                    amount = 2;\n                } else {\n                    amount = 1;\n                }\n                _outputTail = b64variant.encodeBase64Partial(b24, amount, _outputBuffer, _outputTail);\n                bytesLeft -= amount;\n            }\n        }\n        return bytesLeft;\n    }",
          "16": "    protected int _writeBinary(Base64Variant b64variant,\n            InputStream data, byte[] readBuffer, int bytesLeft)\n        throws IOException, JsonGenerationException\n    {\n        int inputPtr = 0;\n        int inputEnd = 0;\n        int lastFullOffset = -3;       \n        \n        // Let's also reserve room for possible (and quoted) lf char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        while (bytesLeft > 2) { // main loop for full triplets\n            if (inputPtr > lastFullOffset) {\n                inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, bytesLeft);\n                inputPtr = 0;\n                if (inputEnd < 3) { // required to try to read to have at least 3 bytes\n                    break;\n                }\n                lastFullOffset = inputEnd-3;\n            }\n            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            int b24 = ((int) readBuffer[inputPtr++]) << 8;\n            b24 |= ((int) readBuffer[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) readBuffer[inputPtr++]) & 0xFF);\n            bytesLeft -= 3;\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n        \n        // And then we may have 1 or 2 leftover bytes to encode\n        if (bytesLeft > 0) {\n            inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, bytesLeft);\n            inputPtr = 0;\n            if (inputEnd > 0) { // yes, but do we have room for output?\n                if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                    _flushBuffer();\n                }\n_releaseBuffers();\n                int b24 = ((int)readBuffer[inputPtr++]) >>> 16;                int amount;\n                if (inputPtr < inputEnd) {\n                    b24 |= (((int) readBuffer[inputPtr]) & 0xFF) << 8;\n                    amount = 2;\n                } else {\n                    amount = 1;\n                }\n                _outputTail = b64variant.encodeBase64Partial(b24, amount, _outputBuffer, _outputTail);\n                bytesLeft -= amount;\n            }\n        }\n        return bytesLeft;\n    }",
          "17": "    protected int _writeBinary(Base64Variant b64variant,\n            InputStream data, byte[] readBuffer, int bytesLeft)\n        throws IOException, JsonGenerationException\n    {\n        int inputPtr = 0;\n        int inputEnd = 0;\n        int lastFullOffset = -3;       \n        \n        // Let's also reserve room for possible (and quoted) lf char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        while (bytesLeft > 2) { // main loop for full triplets\n            if (inputPtr > lastFullOffset) {\n                inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, bytesLeft);\n                inputPtr = 0;\n                if (inputEnd < 3) { // required to try to read to have at least 3 bytes\n                    break;\n                }\n                lastFullOffset = inputEnd-3;\n            }\n            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            int b24 = ((int) readBuffer[inputPtr++]) << 8;\n            b24 |= ((int) readBuffer[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) readBuffer[inputPtr++]) & 0xFF);\n            bytesLeft -= 3;\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n        \n        // And then we may have 1 or 2 leftover bytes to encode\n        if (bytesLeft > 0) {\n            inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, bytesLeft);\n            inputPtr = 0;\n            if (inputEnd > 0) { // yes, but do we have room for output?\n                if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                    _flushBuffer();\n                }\n_writeNull();\n                int b24 = ((int)readBuffer[inputPtr++]) >>> 16;                int amount;\n                if (inputPtr < inputEnd) {\n                    b24 |= (((int) readBuffer[inputPtr]) & 0xFF) << 8;\n                    amount = 2;\n                } else {\n                    amount = 1;\n                }\n                _outputTail = b64variant.encodeBase64Partial(b24, amount, _outputBuffer, _outputTail);\n                bytesLeft -= amount;\n            }\n        }\n        return bytesLeft;\n    }",
          "18": "    protected int _writeBinary(Base64Variant b64variant,\n            InputStream data, byte[] readBuffer, int bytesLeft)\n        throws IOException, JsonGenerationException\n    {\n        int inputPtr = 0;\n        int inputEnd = 0;\n        int lastFullOffset = -3;       \n        \n        // Let's also reserve room for possible (and quoted) lf char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        while (bytesLeft > 2) { // main loop for full triplets\n            if (inputPtr > lastFullOffset) {\n                inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, bytesLeft);\n                inputPtr = 0;\n                if (inputEnd < 3) { // required to try to read to have at least 3 bytes\n                    break;\n                }\n                lastFullOffset = inputEnd-3;\n            }\n            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            int b24 = ((int) readBuffer[inputPtr++]) << 8;\n            b24 |= ((int) readBuffer[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) readBuffer[inputPtr++]) & 0xFF);\n            bytesLeft -= 3;\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n        \n        // And then we may have 1 or 2 leftover bytes to encode\n        if (bytesLeft > 0) {\n            inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, bytesLeft);\n            inputPtr = 0;\n            if (inputEnd > 0) { // yes, but do we have room for output?\n                if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                    _flushBuffer();\n                }\namount = 1;\n                int b24 = ((int)readBuffer[inputPtr++]) >>> 16;                int amount;\n                if (inputPtr < inputEnd) {\n                    b24 |= (((int) readBuffer[inputPtr]) & 0xFF) << 8;\n                    amount = 2;\n                } else {\n                    amount = 1;\n                }\n                _outputTail = b64variant.encodeBase64Partial(b24, amount, _outputBuffer, _outputTail);\n                bytesLeft -= amount;\n            }\n        }\n        return bytesLeft;\n    }",
          "19": "    protected int _writeBinary(Base64Variant b64variant,\n            InputStream data, byte[] readBuffer, int bytesLeft)\n        throws IOException, JsonGenerationException\n    {\n        int inputPtr = 0;\n        int inputEnd = 0;\n        int lastFullOffset = -3;       \n        \n        // Let's also reserve room for possible (and quoted) lf char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        while (bytesLeft > 2) { // main loop for full triplets\n            if (inputPtr > lastFullOffset) {\n                inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, bytesLeft);\n                inputPtr = 0;\n                if (inputEnd < 3) { // required to try to read to have at least 3 bytes\n                    break;\n                }\n                lastFullOffset = inputEnd-3;\n            }\n            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            int b24 = ((int) readBuffer[inputPtr++]) << 8;\n            b24 |= ((int) readBuffer[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) readBuffer[inputPtr++]) & 0xFF);\n            bytesLeft -= 3;\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n        \n        // And then we may have 1 or 2 leftover bytes to encode\n        if (bytesLeft > 0) {\n            inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, bytesLeft);\n            inputPtr = 0;\n            if (inputEnd > 0) { // yes, but do we have room for output?\n                if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                    _flushBuffer();\n                }\nreturn bytesLeft;                int b24 = ((int)readBuffer[inputPtr++]) >>> 16;                int amount;\n                if (inputPtr < inputEnd) {\n                    b24 |= (((int) readBuffer[inputPtr]) & 0xFF) << 8;\n                    amount = 2;\n                } else {\n                    amount = 1;\n                }\n                _outputTail = b64variant.encodeBase64Partial(b24, amount, _outputBuffer, _outputTail);\n                bytesLeft -= amount;\n            }\n        }\n        return bytesLeft;\n    }",
          "20": "    protected int _writeBinary(Base64Variant b64variant,\n            InputStream data, byte[] readBuffer, int bytesLeft)\n        throws IOException, JsonGenerationException\n    {\n        int inputPtr = 0;\n        int inputEnd = 0;\n        int lastFullOffset = -3;       \n        \n        // Let's also reserve room for possible (and quoted) lf char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        while (bytesLeft > 2) { // main loop for full triplets\n            if (inputPtr > lastFullOffset) {\n                inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, bytesLeft);\n                inputPtr = 0;\n                if (inputEnd < 3) { // required to try to read to have at least 3 bytes\n                    break;\n                }\n                lastFullOffset = inputEnd-3;\n            }\n            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            int b24 = ((int) readBuffer[inputPtr++]) << 8;\n            b24 |= ((int) readBuffer[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) readBuffer[inputPtr++]) & 0xFF);\n            bytesLeft -= 3;\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n        \n        // And then we may have 1 or 2 leftover bytes to encode\n        if (bytesLeft > 0) {\n            inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, bytesLeft);\n            inputPtr = 0;\n            if (inputEnd > 0) { // yes, but do we have room for output?\n                if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                    _flushBuffer();\n                }\nreturn;\n                int b24 = ((int)readBuffer[inputPtr++]) >>> 16;                int amount;\n                if (inputPtr < inputEnd) {\n                    b24 |= (((int) readBuffer[inputPtr]) & 0xFF) << 8;\n                    amount = 2;\n                } else {\n                    amount = 1;\n                }\n                _outputTail = b64variant.encodeBase64Partial(b24, amount, _outputBuffer, _outputTail);\n                bytesLeft -= amount;\n            }\n        }\n        return bytesLeft;\n    }",
          "21": "    protected int _writeBinary(Base64Variant b64variant,\n            InputStream data, byte[] readBuffer, int bytesLeft)\n        throws IOException, JsonGenerationException\n    {\n        int inputPtr = 0;\n        int inputEnd = 0;\n        int lastFullOffset = -3;       \n        \n        // Let's also reserve room for possible (and quoted) lf char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        while (bytesLeft > 2) { // main loop for full triplets\n            if (inputPtr > lastFullOffset) {\n                inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, bytesLeft);\n                inputPtr = 0;\n                if (inputEnd < 3) { // required to try to read to have at least 3 bytes\n                    break;\n                }\n                lastFullOffset = inputEnd-3;\n            }\n            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            int b24 = ((int) readBuffer[inputPtr++]) << 8;\n            b24 |= ((int) readBuffer[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) readBuffer[inputPtr++]) & 0xFF);\n            bytesLeft -= 3;\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n        \n        // And then we may have 1 or 2 leftover bytes to encode\n        if (bytesLeft > 0) {\n            inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, bytesLeft);\n            inputPtr = 0;\n            if (inputEnd > 0) { // yes, but do we have room for output?\n                if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                    _flushBuffer();\n                }\ninputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, bytesLeft);\n                int b24 = ((int)readBuffer[inputPtr++]) >>> 16;                int amount;\n                if (inputPtr < inputEnd) {\n                    b24 |= (((int) readBuffer[inputPtr]) & 0xFF) << 8;\n                    amount = 2;\n                } else {\n                    amount = 1;\n                }\n                _outputTail = b64variant.encodeBase64Partial(b24, amount, _outputBuffer, _outputTail);\n                bytesLeft -= amount;\n            }\n        }\n        return bytesLeft;\n    }",
          "22": "    protected int _writeBinary(Base64Variant b64variant,\n            InputStream data, byte[] readBuffer, int bytesLeft)\n        throws IOException, JsonGenerationException\n    {\n        int inputPtr = 0;\n        int inputEnd = 0;\n        int lastFullOffset = -3;       \n        \n        // Let's also reserve room for possible (and quoted) lf char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        while (bytesLeft > 2) { // main loop for full triplets\n            if (inputPtr > lastFullOffset) {\n                inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, bytesLeft);\n                inputPtr = 0;\n                if (inputEnd < 3) { // required to try to read to have at least 3 bytes\n                    break;\n                }\n                lastFullOffset = inputEnd-3;\n            }\n            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            int b24 = ((int) readBuffer[inputPtr++]) << 8;\n            b24 |= ((int) readBuffer[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) readBuffer[inputPtr++]) & 0xFF);\n            bytesLeft -= 3;\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n        \n        // And then we may have 1 or 2 leftover bytes to encode\n        if (bytesLeft > 0) {\n            inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, bytesLeft);\n            inputPtr = 0;\n            if (inputEnd > 0) { // yes, but do we have room for output?\n                if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                    _flushBuffer();\n                }\nbreak;\n                int b24 = ((int)readBuffer[inputPtr++]) >>> 16;                int amount;\n                if (inputPtr < inputEnd) {\n                    b24 |= (((int) readBuffer[inputPtr]) & 0xFF) << 8;\n                    amount = 2;\n                } else {\n                    amount = 1;\n                }\n                _outputTail = b64variant.encodeBase64Partial(b24, amount, _outputBuffer, _outputTail);\n                bytesLeft -= amount;\n            }\n        }\n        return bytesLeft;\n    }",
          "23": "    protected int _writeBinary(Base64Variant b64variant,\n            InputStream data, byte[] readBuffer, int bytesLeft)\n        throws IOException, JsonGenerationException\n    {\n        int inputPtr = 0;\n        int inputEnd = 0;\n        int lastFullOffset = -3;       \n        \n        // Let's also reserve room for possible (and quoted) lf char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        while (bytesLeft > 2) { // main loop for full triplets\n            if (inputPtr > lastFullOffset) {\n                inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, bytesLeft);\n                inputPtr = 0;\n                if (inputEnd < 3) { // required to try to read to have at least 3 bytes\n                    break;\n                }\n                lastFullOffset = inputEnd-3;\n            }\n            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            int b24 = ((int) readBuffer[inputPtr++]) << 8;\n            b24 |= ((int) readBuffer[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) readBuffer[inputPtr++]) & 0xFF);\n            bytesLeft -= 3;\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n        \n        // And then we may have 1 or 2 leftover bytes to encode\n        if (bytesLeft > 0) {\n            inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, bytesLeft);\n            inputPtr = 0;\n            if (inputEnd > 0) { // yes, but do we have room for output?\n                if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                    _flushBuffer();\n                }\nif(((int)readBuffer[inputPtr] & 0xFF)){\n                int b24 = ((int)readBuffer[inputPtr++]) >>> 16;                int amount;\n                if (inputPtr < inputEnd) {\n                    b24 |= (((int) readBuffer[inputPtr]) & 0xFF) << 8;\n                    amount = 2;\n                } else {\n                    amount = 1;\n                }\n                _outputTail = b64variant.encodeBase64Partial(b24, amount, _outputBuffer, _outputTail);\n                bytesLeft -= amount;\n}\n            }\n        }\n        return bytesLeft;\n    }",
          "24": "    protected int _writeBinary(Base64Variant b64variant,\n            InputStream data, byte[] readBuffer, int bytesLeft)\n        throws IOException, JsonGenerationException\n    {\n        int inputPtr = 0;\n        int inputEnd = 0;\n        int lastFullOffset = -3;       \n        \n        // Let's also reserve room for possible (and quoted) lf char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        while (bytesLeft > 2) { // main loop for full triplets\n            if (inputPtr > lastFullOffset) {\n                inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, bytesLeft);\n                inputPtr = 0;\n                if (inputEnd < 3) { // required to try to read to have at least 3 bytes\n                    break;\n                }\n                lastFullOffset = inputEnd-3;\n            }\n            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            int b24 = ((int) readBuffer[inputPtr++]) << 8;\n            b24 |= ((int) readBuffer[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) readBuffer[inputPtr++]) & 0xFF);\n            bytesLeft -= 3;\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n        \n        // And then we may have 1 or 2 leftover bytes to encode\n        if (bytesLeft > 0) {\n            inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, bytesLeft);\n            inputPtr = 0;\n            if (inputEnd > 0) { // yes, but do we have room for output?\n                if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                    _flushBuffer();\n                }\nint b24 = ((int)readBuffer[inputPtr++] % 16);\n                int amount;\n                if (inputPtr < inputEnd) {\n                    b24 |= (((int) readBuffer[inputPtr]) & 0xFF) << 8;\n                    amount = 2;\n                } else {\n                    amount = 1;\n                }\n                _outputTail = b64variant.encodeBase64Partial(b24, amount, _outputBuffer, _outputTail);\n                bytesLeft -= amount;\n            }\n        }\n        return bytesLeft;\n    }",
          "25": "    protected int _writeBinary(Base64Variant b64variant,\n            InputStream data, byte[] readBuffer, int bytesLeft)\n        throws IOException, JsonGenerationException\n    {\n        int inputPtr = 0;\n        int inputEnd = 0;\n        int lastFullOffset = -3;       \n        \n        // Let's also reserve room for possible (and quoted) lf char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        while (bytesLeft > 2) { // main loop for full triplets\n            if (inputPtr > lastFullOffset) {\n                inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, bytesLeft);\n                inputPtr = 0;\n                if (inputEnd < 3) { // required to try to read to have at least 3 bytes\n                    break;\n                }\n                lastFullOffset = inputEnd-3;\n            }\n            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            int b24 = ((int) readBuffer[inputPtr++]) << 8;\n            b24 |= ((int) readBuffer[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) readBuffer[inputPtr++]) & 0xFF);\n            bytesLeft -= 3;\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n        \n        // And then we may have 1 or 2 leftover bytes to encode\n        if (bytesLeft > 0) {\n            inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, bytesLeft);\n            inputPtr = 0;\n            if (inputEnd > 0) { // yes, but do we have room for output?\n                if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                    _flushBuffer();\n                }\nint b24 = ((int)readBuffer[inputPtr++] >>> 0xFF);\n                int amount;\n                if (inputPtr < inputEnd) {\n                    b24 |= (((int) readBuffer[inputPtr]) & 0xFF) << 8;\n                    amount = 2;\n                } else {\n                    amount = 1;\n                }\n                _outputTail = b64variant.encodeBase64Partial(b24, amount, _outputBuffer, _outputTail);\n                bytesLeft -= amount;\n            }\n        }\n        return bytesLeft;\n    }",
          "26": "    protected int _writeBinary(Base64Variant b64variant,\n            InputStream data, byte[] readBuffer, int bytesLeft)\n        throws IOException, JsonGenerationException\n    {\n        int inputPtr = 0;\n        int inputEnd = 0;\n        int lastFullOffset = -3;       \n        \n        // Let's also reserve room for possible (and quoted) lf char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        while (bytesLeft > 2) { // main loop for full triplets\n            if (inputPtr > lastFullOffset) {\n                inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, bytesLeft);\n                inputPtr = 0;\n                if (inputEnd < 3) { // required to try to read to have at least 3 bytes\n                    break;\n                }\n                lastFullOffset = inputEnd-3;\n            }\n            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            int b24 = ((int) readBuffer[inputPtr++]) << 8;\n            b24 |= ((int) readBuffer[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) readBuffer[inputPtr++]) & 0xFF);\n            bytesLeft -= 3;\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n        \n        // And then we may have 1 or 2 leftover bytes to encode\n        if (bytesLeft > 0) {\n            inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, bytesLeft);\n            inputPtr = 0;\n            if (inputEnd > 0) { // yes, but do we have room for output?\n                if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                    _flushBuffer();\n                }\nif((bytesLeft > 0)){\n                int b24 = ((int)readBuffer[inputPtr++]) >>> 16;                int amount;\n                if (inputPtr < inputEnd) {\n                    b24 |= (((int) readBuffer[inputPtr]) & 0xFF) << 8;\n                    amount = 2;\n                } else {\n                    amount = 1;\n                }\n                _outputTail = b64variant.encodeBase64Partial(b24, amount, _outputBuffer, _outputTail);\n                bytesLeft -= amount;\n}\n            }\n        }\n        return bytesLeft;\n    }",
          "27": "    protected int _writeBinary(Base64Variant b64variant,\n            InputStream data, byte[] readBuffer, int bytesLeft)\n        throws IOException, JsonGenerationException\n    {\n        int inputPtr = 0;\n        int inputEnd = 0;\n        int lastFullOffset = -3;       \n        \n        // Let's also reserve room for possible (and quoted) lf char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        while (bytesLeft > 2) { // main loop for full triplets\n            if (inputPtr > lastFullOffset) {\n                inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, bytesLeft);\n                inputPtr = 0;\n                if (inputEnd < 3) { // required to try to read to have at least 3 bytes\n                    break;\n                }\n                lastFullOffset = inputEnd-3;\n            }\n            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            int b24 = ((int) readBuffer[inputPtr++]) << 8;\n            b24 |= ((int) readBuffer[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) readBuffer[inputPtr++]) & 0xFF);\n            bytesLeft -= 3;\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n        \n        // And then we may have 1 or 2 leftover bytes to encode\n        if (bytesLeft > 0) {\n            inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, bytesLeft);\n            inputPtr = 0;\n            if (inputEnd > 0) { // yes, but do we have room for output?\n                if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                    _flushBuffer();\n                }\n                int amount;\n                if (inputPtr < inputEnd) {\n                    b24 |= (((int) readBuffer[inputPtr]) & 0xFF) << 8;\n                    amount = 2;\n                } else {\n                    amount = 1;\n                }\n                _outputTail = b64variant.encodeBase64Partial(b24, amount, _outputBuffer, _outputTail);\n                bytesLeft -= amount;\n            }\n        }\n        return bytesLeft;\n    }",
          "28": "    protected int _writeBinary(Base64Variant b64variant,\n            InputStream data, byte[] readBuffer, int bytesLeft)\n        throws IOException, JsonGenerationException\n    {\n        int inputPtr = 0;\n        int inputEnd = 0;\n        int lastFullOffset = -3;       \n        \n        // Let's also reserve room for possible (and quoted) lf char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        while (bytesLeft > 2) { // main loop for full triplets\n            if (inputPtr > lastFullOffset) {\n                inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, bytesLeft);\n                inputPtr = 0;\n                if (inputEnd < 3) { // required to try to read to have at least 3 bytes\n                    break;\n                }\n                lastFullOffset = inputEnd-3;\n            }\n            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            int b24 = ((int) readBuffer[inputPtr++]) << 8;\n            b24 |= ((int) readBuffer[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) readBuffer[inputPtr++]) & 0xFF);\n            bytesLeft -= 3;\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n        \n        // And then we may have 1 or 2 leftover bytes to encode\n        if (bytesLeft > 0) {\n            inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, bytesLeft);\n            inputPtr = 0;\n            if (inputEnd > 0) { // yes, but do we have room for output?\n                if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                    _flushBuffer();\n                }\nif((_outputTail > safeOutputEnd)){\n                int b24 = ((int)readBuffer[inputPtr++]) >>> 16;                int amount;\n                if (inputPtr < inputEnd) {\n                    b24 |= (((int) readBuffer[inputPtr]) & 0xFF) << 8;\n                    amount = 2;\n                } else {\n                    amount = 1;\n                }\n                _outputTail = b64variant.encodeBase64Partial(b24, amount, _outputBuffer, _outputTail);\n                bytesLeft -= amount;\n}\n            }\n        }\n        return bytesLeft;\n    }",
          "29": "    protected int _writeBinary(Base64Variant b64variant,\n            InputStream data, byte[] readBuffer, int bytesLeft)\n        throws IOException, JsonGenerationException\n    {\n        int inputPtr = 0;\n        int inputEnd = 0;\n        int lastFullOffset = -3;       \n        \n        // Let's also reserve room for possible (and quoted) lf char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        while (bytesLeft > 2) { // main loop for full triplets\n            if (inputPtr > lastFullOffset) {\n                inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, bytesLeft);\n                inputPtr = 0;\n                if (inputEnd < 3) { // required to try to read to have at least 3 bytes\n                    break;\n                }\n                lastFullOffset = inputEnd-3;\n            }\n            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            int b24 = ((int) readBuffer[inputPtr++]) << 8;\n            b24 |= ((int) readBuffer[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) readBuffer[inputPtr++]) & 0xFF);\n            bytesLeft -= 3;\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n        \n        // And then we may have 1 or 2 leftover bytes to encode\n        if (bytesLeft > 0) {\n            inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, bytesLeft);\n            inputPtr = 0;\n            if (inputEnd > 0) { // yes, but do we have room for output?\n                if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                    _flushBuffer();\n                }\nif((inputEnd > 0)){\n                int b24 = ((int)readBuffer[inputPtr++]) >>> 16;                int amount;\n                if (inputPtr < inputEnd) {\n                    b24 |= (((int) readBuffer[inputPtr]) & 0xFF) << 8;\n                    amount = 2;\n                } else {\n                    amount = 1;\n                }\n                _outputTail = b64variant.encodeBase64Partial(b24, amount, _outputBuffer, _outputTail);\n                bytesLeft -= amount;\n}\n            }\n        }\n        return bytesLeft;\n    }",
          "30": "    protected int _writeBinary(Base64Variant b64variant,\n            InputStream data, byte[] readBuffer, int bytesLeft)\n        throws IOException, JsonGenerationException\n    {\n        int inputPtr = 0;\n        int inputEnd = 0;\n        int lastFullOffset = -3;       \n        \n        // Let's also reserve room for possible (and quoted) lf char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        while (bytesLeft > 2) { // main loop for full triplets\n            if (inputPtr > lastFullOffset) {\n                inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, bytesLeft);\n                inputPtr = 0;\n                if (inputEnd < 3) { // required to try to read to have at least 3 bytes\n                    break;\n                }\n                lastFullOffset = inputEnd-3;\n            }\n            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            int b24 = ((int) readBuffer[inputPtr++]) << 8;\n            b24 |= ((int) readBuffer[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) readBuffer[inputPtr++]) & 0xFF);\n            bytesLeft -= 3;\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n        \n        // And then we may have 1 or 2 leftover bytes to encode\n        if (bytesLeft > 0) {\n            inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, bytesLeft);\n            inputPtr = 0;\n            if (inputEnd > 0) { // yes, but do we have room for output?\n                if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                    _flushBuffer();\n                }\nif((inputPtr < inputEnd)){\n                int b24 = ((int)readBuffer[inputPtr++]) >>> 16;                int amount;\n                if (inputPtr < inputEnd) {\n                    b24 |= (((int) readBuffer[inputPtr]) & 0xFF) << 8;\n                    amount = 2;\n                } else {\n                    amount = 1;\n                }\n                _outputTail = b64variant.encodeBase64Partial(b24, amount, _outputBuffer, _outputTail);\n                bytesLeft -= amount;\n}\n            }\n        }\n        return bytesLeft;\n    }",
          "31": "    protected int _writeBinary(Base64Variant b64variant,\n            InputStream data, byte[] readBuffer, int bytesLeft)\n        throws IOException, JsonGenerationException\n    {\n        int inputPtr = 0;\n        int inputEnd = 0;\n        int lastFullOffset = -3;       \n        \n        // Let's also reserve room for possible (and quoted) lf char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        while (bytesLeft > 2) { // main loop for full triplets\n            if (inputPtr > lastFullOffset) {\n                inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, bytesLeft);\n                inputPtr = 0;\n                if (inputEnd < 3) { // required to try to read to have at least 3 bytes\n                    break;\n                }\n                lastFullOffset = inputEnd-3;\n            }\n            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            int b24 = ((int) readBuffer[inputPtr++]) << 8;\n            b24 |= ((int) readBuffer[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) readBuffer[inputPtr++]) & 0xFF);\n            bytesLeft -= 3;\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n        \n        // And then we may have 1 or 2 leftover bytes to encode\n        if (bytesLeft > 0) {\n            inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, bytesLeft);\n            inputPtr = 0;\n            if (inputEnd > 0) { // yes, but do we have room for output?\n                if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                    _flushBuffer();\n                }\nb64variant.writeStartArray();\n                int b24 = ((int)readBuffer[inputPtr++]) >>> 16;                int amount;\n                if (inputPtr < inputEnd) {\n                    b24 |= (((int) readBuffer[inputPtr]) & 0xFF) << 8;\n                    amount = 2;\n                } else {\n                    amount = 1;\n                }\n                _outputTail = b64variant.encodeBase64Partial(b24, amount, _outputBuffer, _outputTail);\n                bytesLeft -= amount;\n            }\n        }\n        return bytesLeft;\n    }",
          "32": "    protected int _writeBinary(Base64Variant b64variant,\n            InputStream data, byte[] readBuffer, int bytesLeft)\n        throws IOException, JsonGenerationException\n    {\n        int inputPtr = 0;\n        int inputEnd = 0;\n        int lastFullOffset = -3;       \n        \n        // Let's also reserve room for possible (and quoted) lf char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        while (bytesLeft > 2) { // main loop for full triplets\n            if (inputPtr > lastFullOffset) {\n                inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, bytesLeft);\n                inputPtr = 0;\n                if (inputEnd < 3) { // required to try to read to have at least 3 bytes\n                    break;\n                }\n                lastFullOffset = inputEnd-3;\n            }\n            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            int b24 = ((int) readBuffer[inputPtr++]) << 8;\n            b24 |= ((int) readBuffer[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) readBuffer[inputPtr++]) & 0xFF);\n            bytesLeft -= 3;\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n        \n        // And then we may have 1 or 2 leftover bytes to encode\n        if (bytesLeft > 0) {\n            inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, bytesLeft);\n            inputPtr = 0;\n            if (inputEnd > 0) { // yes, but do we have room for output?\n                if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                    _flushBuffer();\n                }\nb64variant.writeEndArray();\n                int b24 = ((int)readBuffer[inputPtr++]) >>> 16;                int amount;\n                if (inputPtr < inputEnd) {\n                    b24 |= (((int) readBuffer[inputPtr]) & 0xFF) << 8;\n                    amount = 2;\n                } else {\n                    amount = 1;\n                }\n                _outputTail = b64variant.encodeBase64Partial(b24, amount, _outputBuffer, _outputTail);\n                bytesLeft -= amount;\n            }\n        }\n        return bytesLeft;\n    }",
          "33": "    protected int _writeBinary(Base64Variant b64variant,\n            InputStream data, byte[] readBuffer, int bytesLeft)\n        throws IOException, JsonGenerationException\n    {\n        int inputPtr = 0;\n        int inputEnd = 0;\n        int lastFullOffset = -3;       \n        \n        // Let's also reserve room for possible (and quoted) lf char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        while (bytesLeft > 2) { // main loop for full triplets\n            if (inputPtr > lastFullOffset) {\n                inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, bytesLeft);\n                inputPtr = 0;\n                if (inputEnd < 3) { // required to try to read to have at least 3 bytes\n                    break;\n                }\n                lastFullOffset = inputEnd-3;\n            }\n            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            int b24 = ((int) readBuffer[inputPtr++]) << 8;\n            b24 |= ((int) readBuffer[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) readBuffer[inputPtr++]) & 0xFF);\n            bytesLeft -= 3;\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n        \n        // And then we may have 1 or 2 leftover bytes to encode\n        if (bytesLeft > 0) {\n            inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, bytesLeft);\n            inputPtr = 0;\n            if (inputEnd > 0) { // yes, but do we have room for output?\n                if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                    _flushBuffer();\n                }\nb64variant.writeStartObject();\n                int b24 = ((int)readBuffer[inputPtr++]) >>> 16;                int amount;\n                if (inputPtr < inputEnd) {\n                    b24 |= (((int) readBuffer[inputPtr]) & 0xFF) << 8;\n                    amount = 2;\n                } else {\n                    amount = 1;\n                }\n                _outputTail = b64variant.encodeBase64Partial(b24, amount, _outputBuffer, _outputTail);\n                bytesLeft -= amount;\n            }\n        }\n        return bytesLeft;\n    }",
          "34": "    protected int _writeBinary(Base64Variant b64variant,\n            InputStream data, byte[] readBuffer, int bytesLeft)\n        throws IOException, JsonGenerationException\n    {\n        int inputPtr = 0;\n        int inputEnd = 0;\n        int lastFullOffset = -3;       \n        \n        // Let's also reserve room for possible (and quoted) lf char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        while (bytesLeft > 2) { // main loop for full triplets\n            if (inputPtr > lastFullOffset) {\n                inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, bytesLeft);\n                inputPtr = 0;\n                if (inputEnd < 3) { // required to try to read to have at least 3 bytes\n                    break;\n                }\n                lastFullOffset = inputEnd-3;\n            }\n            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            int b24 = ((int) readBuffer[inputPtr++]) << 8;\n            b24 |= ((int) readBuffer[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) readBuffer[inputPtr++]) & 0xFF);\n            bytesLeft -= 3;\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n        \n        // And then we may have 1 or 2 leftover bytes to encode\n        if (bytesLeft > 0) {\n            inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, bytesLeft);\n            inputPtr = 0;\n            if (inputEnd > 0) { // yes, but do we have room for output?\n                if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                    _flushBuffer();\n                }\nb64variant.writeEndObject();\n                int b24 = ((int)readBuffer[inputPtr++]) >>> 16;                int amount;\n                if (inputPtr < inputEnd) {\n                    b24 |= (((int) readBuffer[inputPtr]) & 0xFF) << 8;\n                    amount = 2;\n                } else {\n                    amount = 1;\n                }\n                _outputTail = b64variant.encodeBase64Partial(b24, amount, _outputBuffer, _outputTail);\n                bytesLeft -= amount;\n            }\n        }\n        return bytesLeft;\n    }",
          "35": "    protected int _writeBinary(Base64Variant b64variant,\n            InputStream data, byte[] readBuffer, int bytesLeft)\n        throws IOException, JsonGenerationException\n    {\n        int inputPtr = 0;\n        int inputEnd = 0;\n        int lastFullOffset = -3;       \n        \n        // Let's also reserve room for possible (and quoted) lf char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        while (bytesLeft > 2) { // main loop for full triplets\n            if (inputPtr > lastFullOffset) {\n                inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, bytesLeft);\n                inputPtr = 0;\n                if (inputEnd < 3) { // required to try to read to have at least 3 bytes\n                    break;\n                }\n                lastFullOffset = inputEnd-3;\n            }\n            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            int b24 = ((int) readBuffer[inputPtr++]) << 8;\n            b24 |= ((int) readBuffer[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) readBuffer[inputPtr++]) & 0xFF);\n            bytesLeft -= 3;\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n        \n        // And then we may have 1 or 2 leftover bytes to encode\n        if (bytesLeft > 0) {\n            inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, bytesLeft);\n            inputPtr = 0;\n            if (inputEnd > 0) { // yes, but do we have room for output?\n                if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                    _flushBuffer();\n                }\nb64variant.writeNull();\n                int b24 = ((int)readBuffer[inputPtr++]) >>> 16;                int amount;\n                if (inputPtr < inputEnd) {\n                    b24 |= (((int) readBuffer[inputPtr]) & 0xFF) << 8;\n                    amount = 2;\n                } else {\n                    amount = 1;\n                }\n                _outputTail = b64variant.encodeBase64Partial(b24, amount, _outputBuffer, _outputTail);\n                bytesLeft -= amount;\n            }\n        }\n        return bytesLeft;\n    }",
          "36": "    protected int _writeBinary(Base64Variant b64variant,\n            InputStream data, byte[] readBuffer, int bytesLeft)\n        throws IOException, JsonGenerationException\n    {\n        int inputPtr = 0;\n        int inputEnd = 0;\n        int lastFullOffset = -3;       \n        \n        // Let's also reserve room for possible (and quoted) lf char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        while (bytesLeft > 2) { // main loop for full triplets\n            if (inputPtr > lastFullOffset) {\n                inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, bytesLeft);\n                inputPtr = 0;\n                if (inputEnd < 3) { // required to try to read to have at least 3 bytes\n                    break;\n                }\n                lastFullOffset = inputEnd-3;\n            }\n            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            int b24 = ((int) readBuffer[inputPtr++]) << 8;\n            b24 |= ((int) readBuffer[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) readBuffer[inputPtr++]) & 0xFF);\n            bytesLeft -= 3;\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n        \n        // And then we may have 1 or 2 leftover bytes to encode\n        if (bytesLeft > 0) {\n            inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, bytesLeft);\n            inputPtr = 0;\n            if (inputEnd > 0) { // yes, but do we have room for output?\n                if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                    _flushBuffer();\n                }\nb64variant.flush();\n                int b24 = ((int)readBuffer[inputPtr++]) >>> 16;                int amount;\n                if (inputPtr < inputEnd) {\n                    b24 |= (((int) readBuffer[inputPtr]) & 0xFF) << 8;\n                    amount = 2;\n                } else {\n                    amount = 1;\n                }\n                _outputTail = b64variant.encodeBase64Partial(b24, amount, _outputBuffer, _outputTail);\n                bytesLeft -= amount;\n            }\n        }\n        return bytesLeft;\n    }",
          "37": "    protected int _writeBinary(Base64Variant b64variant,\n            InputStream data, byte[] readBuffer, int bytesLeft)\n        throws IOException, JsonGenerationException\n    {\n        int inputPtr = 0;\n        int inputEnd = 0;\n        int lastFullOffset = -3;       \n        \n        // Let's also reserve room for possible (and quoted) lf char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        while (bytesLeft > 2) { // main loop for full triplets\n            if (inputPtr > lastFullOffset) {\n                inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, bytesLeft);\n                inputPtr = 0;\n                if (inputEnd < 3) { // required to try to read to have at least 3 bytes\n                    break;\n                }\n                lastFullOffset = inputEnd-3;\n            }\n            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            int b24 = ((int) readBuffer[inputPtr++]) << 8;\n            b24 |= ((int) readBuffer[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) readBuffer[inputPtr++]) & 0xFF);\n            bytesLeft -= 3;\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n        \n        // And then we may have 1 or 2 leftover bytes to encode\n        if (bytesLeft > 0) {\n            inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, bytesLeft);\n            inputPtr = 0;\n            if (inputEnd > 0) { // yes, but do we have room for output?\n                if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                    _flushBuffer();\n                }\nb64variant.close();\n                int b24 = ((int)readBuffer[inputPtr++]) >>> 16;                int amount;\n                if (inputPtr < inputEnd) {\n                    b24 |= (((int) readBuffer[inputPtr]) & 0xFF) << 8;\n                    amount = 2;\n                } else {\n                    amount = 1;\n                }\n                _outputTail = b64variant.encodeBase64Partial(b24, amount, _outputBuffer, _outputTail);\n                bytesLeft -= amount;\n            }\n        }\n        return bytesLeft;\n    }",
          "38": "    protected int _writeBinary(Base64Variant b64variant,\n            InputStream data, byte[] readBuffer, int bytesLeft)\n        throws IOException, JsonGenerationException\n    {\n        int inputPtr = 0;\n        int inputEnd = 0;\n        int lastFullOffset = -3;       \n        \n        // Let's also reserve room for possible (and quoted) lf char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        while (bytesLeft > 2) { // main loop for full triplets\n            if (inputPtr > lastFullOffset) {\n                inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, bytesLeft);\n                inputPtr = 0;\n                if (inputEnd < 3) { // required to try to read to have at least 3 bytes\n                    break;\n                }\n                lastFullOffset = inputEnd-3;\n            }\n            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            int b24 = ((int) readBuffer[inputPtr++]) << 8;\n            b24 |= ((int) readBuffer[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) readBuffer[inputPtr++]) & 0xFF);\n            bytesLeft -= 3;\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n        \n        // And then we may have 1 or 2 leftover bytes to encode\n        if (bytesLeft > 0) {\n            inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, bytesLeft);\n            inputPtr = 0;\n            if (inputEnd > 0) { // yes, but do we have room for output?\n                if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                    _flushBuffer();\n                }\nb64variant._releaseBuffers();\n                int b24 = ((int)readBuffer[inputPtr++]) >>> 16;                int amount;\n                if (inputPtr < inputEnd) {\n                    b24 |= (((int) readBuffer[inputPtr]) & 0xFF) << 8;\n                    amount = 2;\n                } else {\n                    amount = 1;\n                }\n                _outputTail = b64variant.encodeBase64Partial(b24, amount, _outputBuffer, _outputTail);\n                bytesLeft -= amount;\n            }\n        }\n        return bytesLeft;\n    }",
          "39": "    protected int _writeBinary(Base64Variant b64variant,\n            InputStream data, byte[] readBuffer, int bytesLeft)\n        throws IOException, JsonGenerationException\n    {\n        int inputPtr = 0;\n        int inputEnd = 0;\n        int lastFullOffset = -3;       \n        \n        // Let's also reserve room for possible (and quoted) lf char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        while (bytesLeft > 2) { // main loop for full triplets\n            if (inputPtr > lastFullOffset) {\n                inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, bytesLeft);\n                inputPtr = 0;\n                if (inputEnd < 3) { // required to try to read to have at least 3 bytes\n                    break;\n                }\n                lastFullOffset = inputEnd-3;\n            }\n            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            int b24 = ((int) readBuffer[inputPtr++]) << 8;\n            b24 |= ((int) readBuffer[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) readBuffer[inputPtr++]) & 0xFF);\n            bytesLeft -= 3;\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n        \n        // And then we may have 1 or 2 leftover bytes to encode\n        if (bytesLeft > 0) {\n            inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, bytesLeft);\n            inputPtr = 0;\n            if (inputEnd > 0) { // yes, but do we have room for output?\n                if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                    _flushBuffer();\n                }\nb64variant._writeNull();\n                int b24 = ((int)readBuffer[inputPtr++]) >>> 16;                int amount;\n                if (inputPtr < inputEnd) {\n                    b24 |= (((int) readBuffer[inputPtr]) & 0xFF) << 8;\n                    amount = 2;\n                } else {\n                    amount = 1;\n                }\n                _outputTail = b64variant.encodeBase64Partial(b24, amount, _outputBuffer, _outputTail);\n                bytesLeft -= amount;\n            }\n        }\n        return bytesLeft;\n    }",
          "40": "    protected int _writeBinary(Base64Variant b64variant,\n            InputStream data, byte[] readBuffer, int bytesLeft)\n        throws IOException, JsonGenerationException\n    {\n        int inputPtr = 0;\n        int inputEnd = 0;\n        int lastFullOffset = -3;       \n        \n        // Let's also reserve room for possible (and quoted) lf char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        while (bytesLeft > 2) { // main loop for full triplets\n            if (inputPtr > lastFullOffset) {\n                inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, bytesLeft);\n                inputPtr = 0;\n                if (inputEnd < 3) { // required to try to read to have at least 3 bytes\n                    break;\n                }\n                lastFullOffset = inputEnd-3;\n            }\n            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            int b24 = ((int) readBuffer[inputPtr++]) << 8;\n            b24 |= ((int) readBuffer[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) readBuffer[inputPtr++]) & 0xFF);\n            bytesLeft -= 3;\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n        \n        // And then we may have 1 or 2 leftover bytes to encode\n        if (bytesLeft > 0) {\n            inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, bytesLeft);\n            inputPtr = 0;\n            if (inputEnd > 0) { // yes, but do we have room for output?\n                if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                    _flushBuffer();\n                }\nb64variant._flushBuffer();\n                int b24 = ((int)readBuffer[inputPtr++]) >>> 16;                int amount;\n                if (inputPtr < inputEnd) {\n                    b24 |= (((int) readBuffer[inputPtr]) & 0xFF) << 8;\n                    amount = 2;\n                } else {\n                    amount = 1;\n                }\n                _outputTail = b64variant.encodeBase64Partial(b24, amount, _outputBuffer, _outputTail);\n                bytesLeft -= amount;\n            }\n        }\n        return bytesLeft;\n    }",
          "41": "    protected int _writeBinary(Base64Variant b64variant,\n            InputStream data, byte[] readBuffer, int bytesLeft)\n        throws IOException, JsonGenerationException\n    {\n        int inputPtr = 0;\n        int inputEnd = 0;\n        int lastFullOffset = -3;       \n        \n        // Let's also reserve room for possible (and quoted) lf char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        while (bytesLeft > 2) { // main loop for full triplets\n            if (inputPtr > lastFullOffset) {\n                inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, bytesLeft);\n                inputPtr = 0;\n                if (inputEnd < 3) { // required to try to read to have at least 3 bytes\n                    break;\n                }\n                lastFullOffset = inputEnd-3;\n            }\n            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            int b24 = ((int) readBuffer[inputPtr++]) << 8;\n            b24 |= ((int) readBuffer[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) readBuffer[inputPtr++]) & 0xFF);\n            bytesLeft -= 3;\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n        \n        // And then we may have 1 or 2 leftover bytes to encode\n        if (bytesLeft > 0) {\n            inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, bytesLeft);\n            inputPtr = 0;\n            if (inputEnd > 0) { // yes, but do we have room for output?\n                if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                    _flushBuffer();\n                }\nint b24 = ((int)readBuffer[inputPtr++] << 16);\n                int amount;\n                if (inputPtr < inputEnd) {\n                    b24 |= (((int) readBuffer[inputPtr]) & 0xFF) << 8;\n                    amount = 2;\n                } else {\n                    amount = 1;\n                }\n                _outputTail = b64variant.encodeBase64Partial(b24, amount, _outputBuffer, _outputTail);\n                bytesLeft -= amount;\n            }\n        }\n        return bytesLeft;\n    }",
          "42": "    protected int _writeBinary(Base64Variant b64variant,\n            InputStream data, byte[] readBuffer, int bytesLeft)\n        throws IOException, JsonGenerationException\n    {\n        int inputPtr = 0;\n        int inputEnd = 0;\n        int lastFullOffset = -3;       \n        \n        // Let's also reserve room for possible (and quoted) lf char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        while (bytesLeft > 2) { // main loop for full triplets\n            if (inputPtr > lastFullOffset) {\n                inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, bytesLeft);\n                inputPtr = 0;\n                if (inputEnd < 3) { // required to try to read to have at least 3 bytes\n                    break;\n                }\n                lastFullOffset = inputEnd-3;\n            }\n            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            int b24 = ((int) readBuffer[inputPtr++]) << 8;\n            b24 |= ((int) readBuffer[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) readBuffer[inputPtr++]) & 0xFF);\n            bytesLeft -= 3;\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n        \n        // And then we may have 1 or 2 leftover bytes to encode\n        if (bytesLeft > 0) {\n            inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, bytesLeft);\n            inputPtr = 0;\n            if (inputEnd > 0) { // yes, but do we have room for output?\n                if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                    _flushBuffer();\n                }\nint b24 = ((int)readBuffer[inputPtr++] >= 16);\n                int amount;\n                if (inputPtr < inputEnd) {\n                    b24 |= (((int) readBuffer[inputPtr]) & 0xFF) << 8;\n                    amount = 2;\n                } else {\n                    amount = 1;\n                }\n                _outputTail = b64variant.encodeBase64Partial(b24, amount, _outputBuffer, _outputTail);\n                bytesLeft -= amount;\n            }\n        }\n        return bytesLeft;\n    }",
          "43": "    protected int _writeBinary(Base64Variant b64variant,\n            InputStream data, byte[] readBuffer, int bytesLeft)\n        throws IOException, JsonGenerationException\n    {\n        int inputPtr = 0;\n        int inputEnd = 0;\n        int lastFullOffset = -3;       \n        \n        // Let's also reserve room for possible (and quoted) lf char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        while (bytesLeft > 2) { // main loop for full triplets\n            if (inputPtr > lastFullOffset) {\n                inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, bytesLeft);\n                inputPtr = 0;\n                if (inputEnd < 3) { // required to try to read to have at least 3 bytes\n                    break;\n                }\n                lastFullOffset = inputEnd-3;\n            }\n            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            int b24 = ((int) readBuffer[inputPtr++]) << 8;\n            b24 |= ((int) readBuffer[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) readBuffer[inputPtr++]) & 0xFF);\n            bytesLeft -= 3;\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n        \n        // And then we may have 1 or 2 leftover bytes to encode\n        if (bytesLeft > 0) {\n            inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, bytesLeft);\n            inputPtr = 0;\n            if (inputEnd > 0) { // yes, but do we have room for output?\n                if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                    _flushBuffer();\n                }\nint b24 = ((int)readBuffer[inputPtr++] <= 16);\n                int amount;\n                if (inputPtr < inputEnd) {\n                    b24 |= (((int) readBuffer[inputPtr]) & 0xFF) << 8;\n                    amount = 2;\n                } else {\n                    amount = 1;\n                }\n                _outputTail = b64variant.encodeBase64Partial(b24, amount, _outputBuffer, _outputTail);\n                bytesLeft -= amount;\n            }\n        }\n        return bytesLeft;\n    }",
          "44": "    protected int _writeBinary(Base64Variant b64variant,\n            InputStream data, byte[] readBuffer, int bytesLeft)\n        throws IOException, JsonGenerationException\n    {\n        int inputPtr = 0;\n        int inputEnd = 0;\n        int lastFullOffset = -3;       \n        \n        // Let's also reserve room for possible (and quoted) lf char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        while (bytesLeft > 2) { // main loop for full triplets\n            if (inputPtr > lastFullOffset) {\n                inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, bytesLeft);\n                inputPtr = 0;\n                if (inputEnd < 3) { // required to try to read to have at least 3 bytes\n                    break;\n                }\n                lastFullOffset = inputEnd-3;\n            }\n            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            int b24 = ((int) readBuffer[inputPtr++]) << 8;\n            b24 |= ((int) readBuffer[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) readBuffer[inputPtr++]) & 0xFF);\n            bytesLeft -= 3;\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n        \n        // And then we may have 1 or 2 leftover bytes to encode\n        if (bytesLeft > 0) {\n            inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, bytesLeft);\n            inputPtr = 0;\n            if (inputEnd > 0) { // yes, but do we have room for output?\n                if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                    _flushBuffer();\n                }\nint b24 = ((int)readBuffer[inputPtr++] - 16);\n                int amount;\n                if (inputPtr < inputEnd) {\n                    b24 |= (((int) readBuffer[inputPtr]) & 0xFF) << 8;\n                    amount = 2;\n                } else {\n                    amount = 1;\n                }\n                _outputTail = b64variant.encodeBase64Partial(b24, amount, _outputBuffer, _outputTail);\n                bytesLeft -= amount;\n            }\n        }\n        return bytesLeft;\n    }",
          "45": "    protected int _writeBinary(Base64Variant b64variant,\n            InputStream data, byte[] readBuffer, int bytesLeft)\n        throws IOException, JsonGenerationException\n    {\n        int inputPtr = 0;\n        int inputEnd = 0;\n        int lastFullOffset = -3;       \n        \n        // Let's also reserve room for possible (and quoted) lf char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        while (bytesLeft > 2) { // main loop for full triplets\n            if (inputPtr > lastFullOffset) {\n                inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, bytesLeft);\n                inputPtr = 0;\n                if (inputEnd < 3) { // required to try to read to have at least 3 bytes\n                    break;\n                }\n                lastFullOffset = inputEnd-3;\n            }\n            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            int b24 = ((int) readBuffer[inputPtr++]) << 8;\n            b24 |= ((int) readBuffer[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) readBuffer[inputPtr++]) & 0xFF);\n            bytesLeft -= 3;\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n        \n        // And then we may have 1 or 2 leftover bytes to encode\n        if (bytesLeft > 0) {\n            inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, bytesLeft);\n            inputPtr = 0;\n            if (inputEnd > 0) { // yes, but do we have room for output?\n                if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                    _flushBuffer();\n                }\nif((((int)readBuffer[inputPtr] & 0xFF) << 8)){\n                int b24 = ((int)readBuffer[inputPtr++]) >>> 16;                int amount;\n                if (inputPtr < inputEnd) {\n                    b24 |= (((int) readBuffer[inputPtr]) & 0xFF) << 8;\n                    amount = 2;\n                } else {\n                    amount = 1;\n                }\n                _outputTail = b64variant.encodeBase64Partial(b24, amount, _outputBuffer, _outputTail);\n                bytesLeft -= amount;\n}\n            }\n        }\n        return bytesLeft;\n    }",
          "46": "    protected int _writeBinary(Base64Variant b64variant,\n            InputStream data, byte[] readBuffer, int bytesLeft)\n        throws IOException, JsonGenerationException\n    {\n        int inputPtr = 0;\n        int inputEnd = 0;\n        int lastFullOffset = -3;       \n        \n        // Let's also reserve room for possible (and quoted) lf char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        while (bytesLeft > 2) { // main loop for full triplets\n            if (inputPtr > lastFullOffset) {\n                inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, bytesLeft);\n                inputPtr = 0;\n                if (inputEnd < 3) { // required to try to read to have at least 3 bytes\n                    break;\n                }\n                lastFullOffset = inputEnd-3;\n            }\n            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            int b24 = ((int) readBuffer[inputPtr++]) << 8;\n            b24 |= ((int) readBuffer[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) readBuffer[inputPtr++]) & 0xFF);\n            bytesLeft -= 3;\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n        \n        // And then we may have 1 or 2 leftover bytes to encode\n        if (bytesLeft > 0) {\n            inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, bytesLeft);\n            inputPtr = 0;\n            if (inputEnd > 0) { // yes, but do we have room for output?\n                if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                    _flushBuffer();\n                }\nint b24 = ((int)readBuffer[inputPtr++] >>> -1);\n                int amount;\n                if (inputPtr < inputEnd) {\n                    b24 |= (((int) readBuffer[inputPtr]) & 0xFF) << 8;\n                    amount = 2;\n                } else {\n                    amount = 1;\n                }\n                _outputTail = b64variant.encodeBase64Partial(b24, amount, _outputBuffer, _outputTail);\n                bytesLeft -= amount;\n            }\n        }\n        return bytesLeft;\n    }",
          "47": "    protected int _writeBinary(Base64Variant b64variant,\n            InputStream data, byte[] readBuffer, int bytesLeft)\n        throws IOException, JsonGenerationException\n    {\n        int inputPtr = 0;\n        int inputEnd = 0;\n        int lastFullOffset = -3;       \n        \n        // Let's also reserve room for possible (and quoted) lf char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        while (bytesLeft > 2) { // main loop for full triplets\n            if (inputPtr > lastFullOffset) {\n                inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, bytesLeft);\n                inputPtr = 0;\n                if (inputEnd < 3) { // required to try to read to have at least 3 bytes\n                    break;\n                }\n                lastFullOffset = inputEnd-3;\n            }\n            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            int b24 = ((int) readBuffer[inputPtr++]) << 8;\n            b24 |= ((int) readBuffer[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) readBuffer[inputPtr++]) & 0xFF);\n            bytesLeft -= 3;\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n        \n        // And then we may have 1 or 2 leftover bytes to encode\n        if (bytesLeft > 0) {\n            inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, bytesLeft);\n            inputPtr = 0;\n            if (inputEnd > 0) { // yes, but do we have room for output?\n                if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                    _flushBuffer();\n                }\nint b24 = ((int)readBuffer[inputPtr++] & 16);\n                int amount;\n                if (inputPtr < inputEnd) {\n                    b24 |= (((int) readBuffer[inputPtr]) & 0xFF) << 8;\n                    amount = 2;\n                } else {\n                    amount = 1;\n                }\n                _outputTail = b64variant.encodeBase64Partial(b24, amount, _outputBuffer, _outputTail);\n                bytesLeft -= amount;\n            }\n        }\n        return bytesLeft;\n    }",
          "48": "    protected int _writeBinary(Base64Variant b64variant,\n            InputStream data, byte[] readBuffer, int bytesLeft)\n        throws IOException, JsonGenerationException\n    {\n        int inputPtr = 0;\n        int inputEnd = 0;\n        int lastFullOffset = -3;       \n        \n        // Let's also reserve room for possible (and quoted) lf char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        while (bytesLeft > 2) { // main loop for full triplets\n            if (inputPtr > lastFullOffset) {\n                inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, bytesLeft);\n                inputPtr = 0;\n                if (inputEnd < 3) { // required to try to read to have at least 3 bytes\n                    break;\n                }\n                lastFullOffset = inputEnd-3;\n            }\n            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            int b24 = ((int) readBuffer[inputPtr++]) << 8;\n            b24 |= ((int) readBuffer[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) readBuffer[inputPtr++]) & 0xFF);\n            bytesLeft -= 3;\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n        \n        // And then we may have 1 or 2 leftover bytes to encode\n        if (bytesLeft > 0) {\n            inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, bytesLeft);\n            inputPtr = 0;\n            if (inputEnd > 0) { // yes, but do we have room for output?\n                if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                    _flushBuffer();\n                }\nint b24 = ((int)readBuffer[inputPtr++] >>> 8);\n                int amount;\n                if (inputPtr < inputEnd) {\n                    b24 |= (((int) readBuffer[inputPtr]) & 0xFF) << 8;\n                    amount = 2;\n                } else {\n                    amount = 1;\n                }\n                _outputTail = b64variant.encodeBase64Partial(b24, amount, _outputBuffer, _outputTail);\n                bytesLeft -= amount;\n            }\n        }\n        return bytesLeft;\n    }",
          "49": "    protected int _writeBinary(Base64Variant b64variant,\n            InputStream data, byte[] readBuffer, int bytesLeft)\n        throws IOException, JsonGenerationException\n    {\n        int inputPtr = 0;\n        int inputEnd = 0;\n        int lastFullOffset = -3;       \n        \n        // Let's also reserve room for possible (and quoted) lf char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        while (bytesLeft > 2) { // main loop for full triplets\n            if (inputPtr > lastFullOffset) {\n                inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, bytesLeft);\n                inputPtr = 0;\n                if (inputEnd < 3) { // required to try to read to have at least 3 bytes\n                    break;\n                }\n                lastFullOffset = inputEnd-3;\n            }\n            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            int b24 = ((int) readBuffer[inputPtr++]) << 8;\n            b24 |= ((int) readBuffer[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) readBuffer[inputPtr++]) & 0xFF);\n            bytesLeft -= 3;\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n        \n        // And then we may have 1 or 2 leftover bytes to encode\n        if (bytesLeft > 0) {\n            inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, bytesLeft);\n            inputPtr = 0;\n            if (inputEnd > 0) { // yes, but do we have room for output?\n                if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                    _flushBuffer();\n                }\nint b24 = ((int)readBuffer[inputPtr++] / 16);\n                int amount;\n                if (inputPtr < inputEnd) {\n                    b24 |= (((int) readBuffer[inputPtr]) & 0xFF) << 8;\n                    amount = 2;\n                } else {\n                    amount = 1;\n                }\n                _outputTail = b64variant.encodeBase64Partial(b24, amount, _outputBuffer, _outputTail);\n                bytesLeft -= amount;\n            }\n        }\n        return bytesLeft;\n    }",
          "50": "    protected int _writeBinary(Base64Variant b64variant,\n            InputStream data, byte[] readBuffer, int bytesLeft)\n        throws IOException, JsonGenerationException\n    {\n        int inputPtr = 0;\n        int inputEnd = 0;\n        int lastFullOffset = -3;       \n        \n        // Let's also reserve room for possible (and quoted) lf char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        while (bytesLeft > 2) { // main loop for full triplets\n            if (inputPtr > lastFullOffset) {\n                inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, bytesLeft);\n                inputPtr = 0;\n                if (inputEnd < 3) { // required to try to read to have at least 3 bytes\n                    break;\n                }\n                lastFullOffset = inputEnd-3;\n            }\n            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            int b24 = ((int) readBuffer[inputPtr++]) << 8;\n            b24 |= ((int) readBuffer[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) readBuffer[inputPtr++]) & 0xFF);\n            bytesLeft -= 3;\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n        \n        // And then we may have 1 or 2 leftover bytes to encode\n        if (bytesLeft > 0) {\n            inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, bytesLeft);\n            inputPtr = 0;\n            if (inputEnd > 0) { // yes, but do we have room for output?\n                if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                    _flushBuffer();\n                }\nint b24 = ((int)readBuffer[inputPtr++] * 16);\n                int amount;\n                if (inputPtr < inputEnd) {\n                    b24 |= (((int) readBuffer[inputPtr]) & 0xFF) << 8;\n                    amount = 2;\n                } else {\n                    amount = 1;\n                }\n                _outputTail = b64variant.encodeBase64Partial(b24, amount, _outputBuffer, _outputTail);\n                bytesLeft -= amount;\n            }\n        }\n        return bytesLeft;\n    }",
          "51": "    protected int _writeBinary(Base64Variant b64variant,\n            InputStream data, byte[] readBuffer, int bytesLeft)\n        throws IOException, JsonGenerationException\n    {\n        int inputPtr = 0;\n        int inputEnd = 0;\n        int lastFullOffset = -3;       \n        \n        // Let's also reserve room for possible (and quoted) lf char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        while (bytesLeft > 2) { // main loop for full triplets\n            if (inputPtr > lastFullOffset) {\n                inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, bytesLeft);\n                inputPtr = 0;\n                if (inputEnd < 3) { // required to try to read to have at least 3 bytes\n                    break;\n                }\n                lastFullOffset = inputEnd-3;\n            }\n            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            int b24 = ((int) readBuffer[inputPtr++]) << 8;\n            b24 |= ((int) readBuffer[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) readBuffer[inputPtr++]) & 0xFF);\n            bytesLeft -= 3;\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n        \n        // And then we may have 1 or 2 leftover bytes to encode\n        if (bytesLeft > 0) {\n            inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, bytesLeft);\n            inputPtr = 0;\n            if (inputEnd > 0) { // yes, but do we have room for output?\n                if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                    _flushBuffer();\n                }\ncontinue;\n                int b24 = ((int)readBuffer[inputPtr++]) >>> 16;                int amount;\n                if (inputPtr < inputEnd) {\n                    b24 |= (((int) readBuffer[inputPtr]) & 0xFF) << 8;\n                    amount = 2;\n                } else {\n                    amount = 1;\n                }\n                _outputTail = b64variant.encodeBase64Partial(b24, amount, _outputBuffer, _outputTail);\n                bytesLeft -= amount;\n            }\n        }\n        return bytesLeft;\n    }",
          "52": "    protected int _writeBinary(Base64Variant b64variant,\n            InputStream data, byte[] readBuffer, int bytesLeft)\n        throws IOException, JsonGenerationException\n    {\n        int inputPtr = 0;\n        int inputEnd = 0;\n        int lastFullOffset = -3;       \n        \n        // Let's also reserve room for possible (and quoted) lf char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        while (bytesLeft > 2) { // main loop for full triplets\n            if (inputPtr > lastFullOffset) {\n                inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, bytesLeft);\n                inputPtr = 0;\n                if (inputEnd < 3) { // required to try to read to have at least 3 bytes\n                    break;\n                }\n                lastFullOffset = inputEnd-3;\n            }\n            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            int b24 = ((int) readBuffer[inputPtr++]) << 8;\n            b24 |= ((int) readBuffer[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) readBuffer[inputPtr++]) & 0xFF);\n            bytesLeft -= 3;\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n        \n        // And then we may have 1 or 2 leftover bytes to encode\n        if (bytesLeft > 0) {\n            inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, bytesLeft);\n            inputPtr = 0;\n            if (inputEnd > 0) { // yes, but do we have room for output?\n                if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                    _flushBuffer();\n                }\nlong b24 = ((int)readBuffer[inputPtr++] >>> 16);\n                int amount;\n                if (inputPtr < inputEnd) {\n                    b24 |= (((int) readBuffer[inputPtr]) & 0xFF) << 8;\n                    amount = 2;\n                } else {\n                    amount = 1;\n                }\n                _outputTail = b64variant.encodeBase64Partial(b24, amount, _outputBuffer, _outputTail);\n                bytesLeft -= amount;\n            }\n        }\n        return bytesLeft;\n    }",
          "53": "    protected int _writeBinary(Base64Variant b64variant,\n            InputStream data, byte[] readBuffer, int bytesLeft)\n        throws IOException, JsonGenerationException\n    {\n        int inputPtr = 0;\n        int inputEnd = 0;\n        int lastFullOffset = -3;       \n        \n        // Let's also reserve room for possible (and quoted) lf char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        while (bytesLeft > 2) { // main loop for full triplets\n            if (inputPtr > lastFullOffset) {\n                inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, bytesLeft);\n                inputPtr = 0;\n                if (inputEnd < 3) { // required to try to read to have at least 3 bytes\n                    break;\n                }\n                lastFullOffset = inputEnd-3;\n            }\n            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            int b24 = ((int) readBuffer[inputPtr++]) << 8;\n            b24 |= ((int) readBuffer[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) readBuffer[inputPtr++]) & 0xFF);\n            bytesLeft -= 3;\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n        \n        // And then we may have 1 or 2 leftover bytes to encode\n        if (bytesLeft > 0) {\n            inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, bytesLeft);\n            inputPtr = 0;\n            if (inputEnd > 0) { // yes, but do we have room for output?\n                if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                    _flushBuffer();\n                }\nint amount = ;\n                int amount;\n                if (inputPtr < inputEnd) {\n                    b24 |= (((int) readBuffer[inputPtr]) & 0xFF) << 8;\n                    amount = 2;\n                } else {\n                    amount = 1;\n                }\n                _outputTail = b64variant.encodeBase64Partial(b24, amount, _outputBuffer, _outputTail);\n                bytesLeft -= amount;\n            }\n        }\n        return bytesLeft;\n    }",
          "54": "    protected int _writeBinary(Base64Variant b64variant,\n            InputStream data, byte[] readBuffer, int bytesLeft)\n        throws IOException, JsonGenerationException\n    {\n        int inputPtr = 0;\n        int inputEnd = 0;\n        int lastFullOffset = -3;       \n        \n        // Let's also reserve room for possible (and quoted) lf char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        while (bytesLeft > 2) { // main loop for full triplets\n            if (inputPtr > lastFullOffset) {\n                inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, bytesLeft);\n                inputPtr = 0;\n                if (inputEnd < 3) { // required to try to read to have at least 3 bytes\n                    break;\n                }\n                lastFullOffset = inputEnd-3;\n            }\n            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            int b24 = ((int) readBuffer[inputPtr++]) << 8;\n            b24 |= ((int) readBuffer[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) readBuffer[inputPtr++]) & 0xFF);\n            bytesLeft -= 3;\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n        \n        // And then we may have 1 or 2 leftover bytes to encode\n        if (bytesLeft > 0) {\n            inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, bytesLeft);\n            inputPtr = 0;\n            if (inputEnd > 0) { // yes, but do we have room for output?\n                if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                    _flushBuffer();\n                }\nfinal int b24 = ((int)readBuffer[inputPtr++] >>> 16);\n                int amount;\n                if (inputPtr < inputEnd) {\n                    b24 |= (((int) readBuffer[inputPtr]) & 0xFF) << 8;\n                    amount = 2;\n                } else {\n                    amount = 1;\n                }\n                _outputTail = b64variant.encodeBase64Partial(b24, amount, _outputBuffer, _outputTail);\n                bytesLeft -= amount;\n            }\n        }\n        return bytesLeft;\n    }",
          "55": "    protected int _writeBinary(Base64Variant b64variant,\n            InputStream data, byte[] readBuffer, int bytesLeft)\n        throws IOException, JsonGenerationException\n    {\n        int inputPtr = 0;\n        int inputEnd = 0;\n        int lastFullOffset = -3;       \n        \n        // Let's also reserve room for possible (and quoted) lf char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        while (bytesLeft > 2) { // main loop for full triplets\n            if (inputPtr > lastFullOffset) {\n                inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, bytesLeft);\n                inputPtr = 0;\n                if (inputEnd < 3) { // required to try to read to have at least 3 bytes\n                    break;\n                }\n                lastFullOffset = inputEnd-3;\n            }\n            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            int b24 = ((int) readBuffer[inputPtr++]) << 8;\n            b24 |= ((int) readBuffer[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) readBuffer[inputPtr++]) & 0xFF);\n            bytesLeft -= 3;\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n        \n        // And then we may have 1 or 2 leftover bytes to encode\n        if (bytesLeft > 0) {\n            inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, bytesLeft);\n            inputPtr = 0;\n            if (inputEnd > 0) { // yes, but do we have room for output?\n                if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                    _flushBuffer();\n                }\nint b24 = ((int)readBuffer[inputPtr++] >>> 2);\n                int amount;\n                if (inputPtr < inputEnd) {\n                    b24 |= (((int) readBuffer[inputPtr]) & 0xFF) << 8;\n                    amount = 2;\n                } else {\n                    amount = 1;\n                }\n                _outputTail = b64variant.encodeBase64Partial(b24, amount, _outputBuffer, _outputTail);\n                bytesLeft -= amount;\n            }\n        }\n        return bytesLeft;\n    }",
          "56": "    protected int _writeBinary(Base64Variant b64variant,\n            InputStream data, byte[] readBuffer, int bytesLeft)\n        throws IOException, JsonGenerationException\n    {\n        int inputPtr = 0;\n        int inputEnd = 0;\n        int lastFullOffset = -3;       \n        \n        // Let's also reserve room for possible (and quoted) lf char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        while (bytesLeft > 2) { // main loop for full triplets\n            if (inputPtr > lastFullOffset) {\n                inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, bytesLeft);\n                inputPtr = 0;\n                if (inputEnd < 3) { // required to try to read to have at least 3 bytes\n                    break;\n                }\n                lastFullOffset = inputEnd-3;\n            }\n            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            int b24 = ((int) readBuffer[inputPtr++]) << 8;\n            b24 |= ((int) readBuffer[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) readBuffer[inputPtr++]) & 0xFF);\n            bytesLeft -= 3;\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n        \n        // And then we may have 1 or 2 leftover bytes to encode\n        if (bytesLeft > 0) {\n            inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, bytesLeft);\n            inputPtr = 0;\n            if (inputEnd > 0) { // yes, but do we have room for output?\n                if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                    _flushBuffer();\n                }\nint b24 = ((int)bytesLeft >>> 16);\n                int amount;\n                if (inputPtr < inputEnd) {\n                    b24 |= (((int) readBuffer[inputPtr]) & 0xFF) << 8;\n                    amount = 2;\n                } else {\n                    amount = 1;\n                }\n                _outputTail = b64variant.encodeBase64Partial(b24, amount, _outputBuffer, _outputTail);\n                bytesLeft -= amount;\n            }\n        }\n        return bytesLeft;\n    }",
          "57": "    protected int _writeBinary(Base64Variant b64variant,\n            InputStream data, byte[] readBuffer, int bytesLeft)\n        throws IOException, JsonGenerationException\n    {\n        int inputPtr = 0;\n        int inputEnd = 0;\n        int lastFullOffset = -3;       \n        \n        // Let's also reserve room for possible (and quoted) lf char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        while (bytesLeft > 2) { // main loop for full triplets\n            if (inputPtr > lastFullOffset) {\n                inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, bytesLeft);\n                inputPtr = 0;\n                if (inputEnd < 3) { // required to try to read to have at least 3 bytes\n                    break;\n                }\n                lastFullOffset = inputEnd-3;\n            }\n            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            int b24 = ((int) readBuffer[inputPtr++]) << 8;\n            b24 |= ((int) readBuffer[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) readBuffer[inputPtr++]) & 0xFF);\n            bytesLeft -= 3;\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n        \n        // And then we may have 1 or 2 leftover bytes to encode\n        if (bytesLeft > 0) {\n            inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, bytesLeft);\n            inputPtr = 0;\n            if (inputEnd > 0) { // yes, but do we have room for output?\n                if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                    _flushBuffer();\n                }\nint b24 = ((int)amount >>> 16);\n                int amount;\n                if (inputPtr < inputEnd) {\n                    b24 |= (((int) readBuffer[inputPtr]) & 0xFF) << 8;\n                    amount = 2;\n                } else {\n                    amount = 1;\n                }\n                _outputTail = b64variant.encodeBase64Partial(b24, amount, _outputBuffer, _outputTail);\n                bytesLeft -= amount;\n            }\n        }\n        return bytesLeft;\n    }",
          "58": "    protected int _writeBinary(Base64Variant b64variant,\n            InputStream data, byte[] readBuffer, int bytesLeft)\n        throws IOException, JsonGenerationException\n    {\n        int inputPtr = 0;\n        int inputEnd = 0;\n        int lastFullOffset = -3;       \n        \n        // Let's also reserve room for possible (and quoted) lf char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        while (bytesLeft > 2) { // main loop for full triplets\n            if (inputPtr > lastFullOffset) {\n                inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, bytesLeft);\n                inputPtr = 0;\n                if (inputEnd < 3) { // required to try to read to have at least 3 bytes\n                    break;\n                }\n                lastFullOffset = inputEnd-3;\n            }\n            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            int b24 = ((int) readBuffer[inputPtr++]) << 8;\n            b24 |= ((int) readBuffer[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) readBuffer[inputPtr++]) & 0xFF);\n            bytesLeft -= 3;\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n        \n        // And then we may have 1 or 2 leftover bytes to encode\n        if (bytesLeft > 0) {\n            inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, bytesLeft);\n            inputPtr = 0;\n            if (inputEnd > 0) { // yes, but do we have room for output?\n                if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                    _flushBuffer();\n                }\nint amount = ;\n                int b24 = ((int)readBuffer[inputPtr++]) >>> 16;                int amount;\n                if (inputPtr < inputEnd) {\n                    b24 |= (((int) readBuffer[inputPtr]) & 0xFF) << 8;\n                    amount = 2;\n                } else {\n                    amount = 1;\n                }\n                _outputTail = b64variant.encodeBase64Partial(b24, amount, _outputBuffer, _outputTail);\n                bytesLeft -= amount;\n            }\n        }\n        return bytesLeft;\n    }",
          "59": "    protected int _writeBinary(Base64Variant b64variant,\n            InputStream data, byte[] readBuffer, int bytesLeft)\n        throws IOException, JsonGenerationException\n    {\n        int inputPtr = 0;\n        int inputEnd = 0;\n        int lastFullOffset = -3;       \n        \n        // Let's also reserve room for possible (and quoted) lf char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        while (bytesLeft > 2) { // main loop for full triplets\n            if (inputPtr > lastFullOffset) {\n                inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, bytesLeft);\n                inputPtr = 0;\n                if (inputEnd < 3) { // required to try to read to have at least 3 bytes\n                    break;\n                }\n                lastFullOffset = inputEnd-3;\n            }\n            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            int b24 = ((int) readBuffer[inputPtr++]) << 8;\n            b24 |= ((int) readBuffer[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) readBuffer[inputPtr++]) & 0xFF);\n            bytesLeft -= 3;\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n        \n        // And then we may have 1 or 2 leftover bytes to encode\n        if (bytesLeft > 0) {\n            inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, bytesLeft);\n            inputPtr = 0;\n            if (inputEnd > 0) { // yes, but do we have room for output?\n                if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                    _flushBuffer();\n                }\nint b24 = ((int)_outputBuffer >>> 16);\n                int amount;\n                if (inputPtr < inputEnd) {\n                    b24 |= (((int) readBuffer[inputPtr]) & 0xFF) << 8;\n                    amount = 2;\n                } else {\n                    amount = 1;\n                }\n                _outputTail = b64variant.encodeBase64Partial(b24, amount, _outputBuffer, _outputTail);\n                bytesLeft -= amount;\n            }\n        }\n        return bytesLeft;\n    }",
          "60": "    protected int _writeBinary(Base64Variant b64variant,\n            InputStream data, byte[] readBuffer, int bytesLeft)\n        throws IOException, JsonGenerationException\n    {\n        int inputPtr = 0;\n        int inputEnd = 0;\n        int lastFullOffset = -3;       \n        \n        // Let's also reserve room for possible (and quoted) lf char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        while (bytesLeft > 2) { // main loop for full triplets\n            if (inputPtr > lastFullOffset) {\n                inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, bytesLeft);\n                inputPtr = 0;\n                if (inputEnd < 3) { // required to try to read to have at least 3 bytes\n                    break;\n                }\n                lastFullOffset = inputEnd-3;\n            }\n            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            int b24 = ((int) readBuffer[inputPtr++]) << 8;\n            b24 |= ((int) readBuffer[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) readBuffer[inputPtr++]) & 0xFF);\n            bytesLeft -= 3;\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n        \n        // And then we may have 1 or 2 leftover bytes to encode\n        if (bytesLeft > 0) {\n            inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, bytesLeft);\n            inputPtr = 0;\n            if (inputEnd > 0) { // yes, but do we have room for output?\n                if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                    _flushBuffer();\n                }\nint b24 = ((int)readBuffer[inputPtr++] >>> 1);\n                int amount;\n                if (inputPtr < inputEnd) {\n                    b24 |= (((int) readBuffer[inputPtr]) & 0xFF) << 8;\n                    amount = 2;\n                } else {\n                    amount = 1;\n                }\n                _outputTail = b64variant.encodeBase64Partial(b24, amount, _outputBuffer, _outputTail);\n                bytesLeft -= amount;\n            }\n        }\n        return bytesLeft;\n    }",
          "61": "    protected int _writeBinary(Base64Variant b64variant,\n            InputStream data, byte[] readBuffer, int bytesLeft)\n        throws IOException, JsonGenerationException\n    {\n        int inputPtr = 0;\n        int inputEnd = 0;\n        int lastFullOffset = -3;       \n        \n        // Let's also reserve room for possible (and quoted) lf char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        while (bytesLeft > 2) { // main loop for full triplets\n            if (inputPtr > lastFullOffset) {\n                inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, bytesLeft);\n                inputPtr = 0;\n                if (inputEnd < 3) { // required to try to read to have at least 3 bytes\n                    break;\n                }\n                lastFullOffset = inputEnd-3;\n            }\n            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            int b24 = ((int) readBuffer[inputPtr++]) << 8;\n            b24 |= ((int) readBuffer[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) readBuffer[inputPtr++]) & 0xFF);\n            bytesLeft -= 3;\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n        \n        // And then we may have 1 or 2 leftover bytes to encode\n        if (bytesLeft > 0) {\n            inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, bytesLeft);\n            inputPtr = 0;\n            if (inputEnd > 0) { // yes, but do we have room for output?\n                if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                    _flushBuffer();\n                }\nint b24 = ((int)_outputTail >>> 16);\n                int amount;\n                if (inputPtr < inputEnd) {\n                    b24 |= (((int) readBuffer[inputPtr]) & 0xFF) << 8;\n                    amount = 2;\n                } else {\n                    amount = 1;\n                }\n                _outputTail = b64variant.encodeBase64Partial(b24, amount, _outputBuffer, _outputTail);\n                bytesLeft -= amount;\n            }\n        }\n        return bytesLeft;\n    }",
          "62": "    protected int _writeBinary(Base64Variant b64variant,\n            InputStream data, byte[] readBuffer, int bytesLeft)\n        throws IOException, JsonGenerationException\n    {\n        int inputPtr = 0;\n        int inputEnd = 0;\n        int lastFullOffset = -3;       \n        \n        // Let's also reserve room for possible (and quoted) lf char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        while (bytesLeft > 2) { // main loop for full triplets\n            if (inputPtr > lastFullOffset) {\n                inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, bytesLeft);\n                inputPtr = 0;\n                if (inputEnd < 3) { // required to try to read to have at least 3 bytes\n                    break;\n                }\n                lastFullOffset = inputEnd-3;\n            }\n            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            int b24 = ((int) readBuffer[inputPtr++]) << 8;\n            b24 |= ((int) readBuffer[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) readBuffer[inputPtr++]) & 0xFF);\n            bytesLeft -= 3;\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n        \n        // And then we may have 1 or 2 leftover bytes to encode\n        if (bytesLeft > 0) {\n            inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, bytesLeft);\n            inputPtr = 0;\n            if (inputEnd > 0) { // yes, but do we have room for output?\n                if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                    _flushBuffer();\n                }\nint b24 = ((int)readBuffer[inputPtr++] >>> false);\n                int amount;\n                if (inputPtr < inputEnd) {\n                    b24 |= (((int) readBuffer[inputPtr]) & 0xFF) << 8;\n                    amount = 2;\n                } else {\n                    amount = 1;\n                }\n                _outputTail = b64variant.encodeBase64Partial(b24, amount, _outputBuffer, _outputTail);\n                bytesLeft -= amount;\n            }\n        }\n        return bytesLeft;\n    }",
          "63": "    protected int _writeBinary(Base64Variant b64variant,\n            InputStream data, byte[] readBuffer, int bytesLeft)\n        throws IOException, JsonGenerationException\n    {\n        int inputPtr = 0;\n        int inputEnd = 0;\n        int lastFullOffset = -3;       \n        \n        // Let's also reserve room for possible (and quoted) lf char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        while (bytesLeft > 2) { // main loop for full triplets\n            if (inputPtr > lastFullOffset) {\n                inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, bytesLeft);\n                inputPtr = 0;\n                if (inputEnd < 3) { // required to try to read to have at least 3 bytes\n                    break;\n                }\n                lastFullOffset = inputEnd-3;\n            }\n            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            int b24 = ((int) readBuffer[inputPtr++]) << 8;\n            b24 |= ((int) readBuffer[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) readBuffer[inputPtr++]) & 0xFF);\n            bytesLeft -= 3;\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n        \n        // And then we may have 1 or 2 leftover bytes to encode\n        if (bytesLeft > 0) {\n            inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, bytesLeft);\n            inputPtr = 0;\n            if (inputEnd > 0) { // yes, but do we have room for output?\n                if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                    _flushBuffer();\n                }\nint b24 = _readMore(data, readBuffer, inputPtr, inputEnd, bytesLeft);\n                int amount;\n                if (inputPtr < inputEnd) {\n                    b24 |= (((int) readBuffer[inputPtr]) & 0xFF) << 8;\n                    amount = 2;\n                } else {\n                    amount = 1;\n                }\n                _outputTail = b64variant.encodeBase64Partial(b24, amount, _outputBuffer, _outputTail);\n                bytesLeft -= amount;\n            }\n        }\n        return bytesLeft;\n    }",
          "64": "    protected int _writeBinary(Base64Variant b64variant,\n            InputStream data, byte[] readBuffer, int bytesLeft)\n        throws IOException, JsonGenerationException\n    {\n        int inputPtr = 0;\n        int inputEnd = 0;\n        int lastFullOffset = -3;       \n        \n        // Let's also reserve room for possible (and quoted) lf char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        while (bytesLeft > 2) { // main loop for full triplets\n            if (inputPtr > lastFullOffset) {\n                inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, bytesLeft);\n                inputPtr = 0;\n                if (inputEnd < 3) { // required to try to read to have at least 3 bytes\n                    break;\n                }\n                lastFullOffset = inputEnd-3;\n            }\n            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            int b24 = ((int) readBuffer[inputPtr++]) << 8;\n            b24 |= ((int) readBuffer[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) readBuffer[inputPtr++]) & 0xFF);\n            bytesLeft -= 3;\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n        \n        // And then we may have 1 or 2 leftover bytes to encode\n        if (bytesLeft > 0) {\n            inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, bytesLeft);\n            inputPtr = 0;\n            if (inputEnd > 0) { // yes, but do we have room for output?\n                if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                    _flushBuffer();\n                }\nint b24 = 0;\n                int amount;\n                if (inputPtr < inputEnd) {\n                    b24 |= (((int) readBuffer[inputPtr]) & 0xFF) << 8;\n                    amount = 2;\n                } else {\n                    amount = 1;\n                }\n                _outputTail = b64variant.encodeBase64Partial(b24, amount, _outputBuffer, _outputTail);\n                bytesLeft -= amount;\n            }\n        }\n        return bytesLeft;\n    }",
          "65": "    protected int _writeBinary(Base64Variant b64variant,\n            InputStream data, byte[] readBuffer, int bytesLeft)\n        throws IOException, JsonGenerationException\n    {\n        int inputPtr = 0;\n        int inputEnd = 0;\n        int lastFullOffset = -3;       \n        \n        // Let's also reserve room for possible (and quoted) lf char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        while (bytesLeft > 2) { // main loop for full triplets\n            if (inputPtr > lastFullOffset) {\n                inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, bytesLeft);\n                inputPtr = 0;\n                if (inputEnd < 3) { // required to try to read to have at least 3 bytes\n                    break;\n                }\n                lastFullOffset = inputEnd-3;\n            }\n            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            int b24 = ((int) readBuffer[inputPtr++]) << 8;\n            b24 |= ((int) readBuffer[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) readBuffer[inputPtr++]) & 0xFF);\n            bytesLeft -= 3;\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n        \n        // And then we may have 1 or 2 leftover bytes to encode\n        if (bytesLeft > 0) {\n            inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, bytesLeft);\n            inputPtr = 0;\n            if (inputEnd > 0) { // yes, but do we have room for output?\n                if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                    _flushBuffer();\n                }\nint b24 = 1;\n                int amount;\n                if (inputPtr < inputEnd) {\n                    b24 |= (((int) readBuffer[inputPtr]) & 0xFF) << 8;\n                    amount = 2;\n                } else {\n                    amount = 1;\n                }\n                _outputTail = b64variant.encodeBase64Partial(b24, amount, _outputBuffer, _outputTail);\n                bytesLeft -= amount;\n            }\n        }\n        return bytesLeft;\n    }",
          "66": "    protected int _writeBinary(Base64Variant b64variant,\n            InputStream data, byte[] readBuffer, int bytesLeft)\n        throws IOException, JsonGenerationException\n    {\n        int inputPtr = 0;\n        int inputEnd = 0;\n        int lastFullOffset = -3;       \n        \n        // Let's also reserve room for possible (and quoted) lf char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        while (bytesLeft > 2) { // main loop for full triplets\n            if (inputPtr > lastFullOffset) {\n                inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, bytesLeft);\n                inputPtr = 0;\n                if (inputEnd < 3) { // required to try to read to have at least 3 bytes\n                    break;\n                }\n                lastFullOffset = inputEnd-3;\n            }\n            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            int b24 = ((int) readBuffer[inputPtr++]) << 8;\n            b24 |= ((int) readBuffer[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) readBuffer[inputPtr++]) & 0xFF);\n            bytesLeft -= 3;\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n        \n        // And then we may have 1 or 2 leftover bytes to encode\n        if (bytesLeft > 0) {\n            inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, bytesLeft);\n            inputPtr = 0;\n            if (inputEnd > 0) { // yes, but do we have room for output?\n                if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                    _flushBuffer();\n                }\nint b24 = (((int)readBuffer[inputPtr] & 0xFF) << 8);\n                int amount;\n                if (inputPtr < inputEnd) {\n                    b24 |= (((int) readBuffer[inputPtr]) & 0xFF) << 8;\n                    amount = 2;\n                } else {\n                    amount = 1;\n                }\n                _outputTail = b64variant.encodeBase64Partial(b24, amount, _outputBuffer, _outputTail);\n                bytesLeft -= amount;\n            }\n        }\n        return bytesLeft;\n    }",
          "67": "    protected int _writeBinary(Base64Variant b64variant,\n            InputStream data, byte[] readBuffer, int bytesLeft)\n        throws IOException, JsonGenerationException\n    {\n        int inputPtr = 0;\n        int inputEnd = 0;\n        int lastFullOffset = -3;       \n        \n        // Let's also reserve room for possible (and quoted) lf char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        while (bytesLeft > 2) { // main loop for full triplets\n            if (inputPtr > lastFullOffset) {\n                inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, bytesLeft);\n                inputPtr = 0;\n                if (inputEnd < 3) { // required to try to read to have at least 3 bytes\n                    break;\n                }\n                lastFullOffset = inputEnd-3;\n            }\n            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            int b24 = ((int) readBuffer[inputPtr++]) << 8;\n            b24 |= ((int) readBuffer[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) readBuffer[inputPtr++]) & 0xFF);\n            bytesLeft -= 3;\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n        \n        // And then we may have 1 or 2 leftover bytes to encode\n        if (bytesLeft > 0) {\n            inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, bytesLeft);\n            inputPtr = 0;\n            if (inputEnd > 0) { // yes, but do we have room for output?\n                if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                    _flushBuffer();\n                }\nint b24 = ((int)readBuffer[inputPtr] & 0xFF);\n                int amount;\n                if (inputPtr < inputEnd) {\n                    b24 |= (((int) readBuffer[inputPtr]) & 0xFF) << 8;\n                    amount = 2;\n                } else {\n                    amount = 1;\n                }\n                _outputTail = b64variant.encodeBase64Partial(b24, amount, _outputBuffer, _outputTail);\n                bytesLeft -= amount;\n            }\n        }\n        return bytesLeft;\n    }",
          "68": "    protected int _writeBinary(Base64Variant b64variant,\n            InputStream data, byte[] readBuffer, int bytesLeft)\n        throws IOException, JsonGenerationException\n    {\n        int inputPtr = 0;\n        int inputEnd = 0;\n        int lastFullOffset = -3;       \n        \n        // Let's also reserve room for possible (and quoted) lf char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        while (bytesLeft > 2) { // main loop for full triplets\n            if (inputPtr > lastFullOffset) {\n                inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, bytesLeft);\n                inputPtr = 0;\n                if (inputEnd < 3) { // required to try to read to have at least 3 bytes\n                    break;\n                }\n                lastFullOffset = inputEnd-3;\n            }\n            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            int b24 = ((int) readBuffer[inputPtr++]) << 8;\n            b24 |= ((int) readBuffer[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) readBuffer[inputPtr++]) & 0xFF);\n            bytesLeft -= 3;\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n        \n        // And then we may have 1 or 2 leftover bytes to encode\n        if (bytesLeft > 0) {\n            inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, bytesLeft);\n            inputPtr = 0;\n            if (inputEnd > 0) { // yes, but do we have room for output?\n                if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                    _flushBuffer();\n                }\nif((readBuffer != null)){\n                int b24 = ((int)readBuffer[inputPtr++]) >>> 16;                int amount;\n                if (inputPtr < inputEnd) {\n                    b24 |= (((int) readBuffer[inputPtr]) & 0xFF) << 8;\n                    amount = 2;\n                } else {\n                    amount = 1;\n                }\n                _outputTail = b64variant.encodeBase64Partial(b24, amount, _outputBuffer, _outputTail);\n                bytesLeft -= amount;\n}\n            }\n        }\n        return bytesLeft;\n    }",
          "69": "    protected int _writeBinary(Base64Variant b64variant,\n            InputStream data, byte[] readBuffer, int bytesLeft)\n        throws IOException, JsonGenerationException\n    {\n        int inputPtr = 0;\n        int inputEnd = 0;\n        int lastFullOffset = -3;       \n        \n        // Let's also reserve room for possible (and quoted) lf char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        while (bytesLeft > 2) { // main loop for full triplets\n            if (inputPtr > lastFullOffset) {\n                inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, bytesLeft);\n                inputPtr = 0;\n                if (inputEnd < 3) { // required to try to read to have at least 3 bytes\n                    break;\n                }\n                lastFullOffset = inputEnd-3;\n            }\n            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            int b24 = ((int) readBuffer[inputPtr++]) << 8;\n            b24 |= ((int) readBuffer[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) readBuffer[inputPtr++]) & 0xFF);\n            bytesLeft -= 3;\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n        \n        // And then we may have 1 or 2 leftover bytes to encode\n        if (bytesLeft > 0) {\n            inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, bytesLeft);\n            inputPtr = 0;\n            if (inputEnd > 0) { // yes, but do we have room for output?\n                if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                    _flushBuffer();\n                }\nif((inputPtr != null)){\n                int b24 = ((int)readBuffer[inputPtr++]) >>> 16;                int amount;\n                if (inputPtr < inputEnd) {\n                    b24 |= (((int) readBuffer[inputPtr]) & 0xFF) << 8;\n                    amount = 2;\n                } else {\n                    amount = 1;\n                }\n                _outputTail = b64variant.encodeBase64Partial(b24, amount, _outputBuffer, _outputTail);\n                bytesLeft -= amount;\n}\n            }\n        }\n        return bytesLeft;\n    }",
          "70": "    protected int _writeBinary(Base64Variant b64variant,\n            InputStream data, byte[] readBuffer, int bytesLeft)\n        throws IOException, JsonGenerationException\n    {\n        int inputPtr = 0;\n        int inputEnd = 0;\n        int lastFullOffset = -3;       \n        \n        // Let's also reserve room for possible (and quoted) lf char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        while (bytesLeft > 2) { // main loop for full triplets\n            if (inputPtr > lastFullOffset) {\n                inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, bytesLeft);\n                inputPtr = 0;\n                if (inputEnd < 3) { // required to try to read to have at least 3 bytes\n                    break;\n                }\n                lastFullOffset = inputEnd-3;\n            }\n            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            int b24 = ((int) readBuffer[inputPtr++]) << 8;\n            b24 |= ((int) readBuffer[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) readBuffer[inputPtr++]) & 0xFF);\n            bytesLeft -= 3;\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n        \n        // And then we may have 1 or 2 leftover bytes to encode\n        if (bytesLeft > 0) {\n            inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, bytesLeft);\n            inputPtr = 0;\n            if (inputEnd > 0) { // yes, but do we have room for output?\n                if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                    _flushBuffer();\n                }\nint b24 = (((int)readBuffer[inputPtr++] >>> 16) * 16);\n                int amount;\n                if (inputPtr < inputEnd) {\n                    b24 |= (((int) readBuffer[inputPtr]) & 0xFF) << 8;\n                    amount = 2;\n                } else {\n                    amount = 1;\n                }\n                _outputTail = b64variant.encodeBase64Partial(b24, amount, _outputBuffer, _outputTail);\n                bytesLeft -= amount;\n            }\n        }\n        return bytesLeft;\n    }"
}