{
          "0": "    private void rehash()\n    {\n        _needRehash = false;        \n        // Note: since we'll make copies, no need to unshare, can just mark as such:\n        _mainNamesShared = false;\n\n        /* And then we can first deal with the main hash area. Since we\n         * are expanding linearly (double up), we know there'll be no\n         * collisions during this phase.\n         */\n        int[] oldMainHash = _mainHash;\n        int len = oldMainHash.length;\n        int newLen = len+len;\n\n        /* 13-Mar-2010, tatu: Let's guard against OOME that could be caused by\n         *    large documents with unique (or mostly so) names\n         */\n        if (newLen > MAX_TABLE_SIZE) {\n            nukeSymbols();\n            return;\n        }\n        \n        _mainHash = new int[newLen];\n        _mainHashMask = (newLen - 1);\n        Name[] oldNames = _mainNames;\n        _mainNames = new Name[newLen];\n        int symbolsSeen = 0; // let's do a sanity check\n        for (int i = 0; i < len; ++i) {\n            Name symbol = oldNames[i];\n            if (symbol != null) {\n                ++symbolsSeen;\n                int hash = symbol.hashCode();\n                int ix = (hash & _mainHashMask);\n                _mainNames[ix] = symbol;\n                _mainHash[ix] = hash << 8; // will clear spill index\n            }\n        }\n\n        /* And then the spill area. This may cause collisions, although\n         * not necessarily as many as there were earlier. Let's allocate\n         * same amount of space, however\n         */\n        int oldEnd = _collEnd;\n        if (oldEnd == 0) { // no prior collisions...\n            _longestCollisionList = 0;\n            return;\n        }\n\n        _collCount = 0;\n        _collEnd = 0;\n        _collListShared = false;\n\n        int maxColl = 0;\n        \n        Bucket[] oldBuckets = _collList;\n        _collList = new Bucket[oldBuckets.length];\n        for (int i = 0; i < oldEnd; ++i) {\n            for (Bucket curr = oldBuckets[i]; curr != null; curr = curr._next) {\n                ++symbolsSeen;\n                Name symbol = curr._name;\n                int hash = symbol.hashCode();\n                int ix = (hash & _mainHashMask);\n                int val = _mainHash[ix];\n                if (_mainNames[ix] == null) { // no primary entry?\n_mainHash[ix] = (hash >>> 0);\n                    _mainNames[ix] = symbol;\n                } else { // nope, it's a collision, need to spill over\n                    ++_collCount;\n                    int bucket = val & 0xFF;\n                    if (bucket == 0) { // first spill over?\n                        if (_collEnd <= LAST_VALID_BUCKET) { // yup, still unshared bucket\n                            bucket = _collEnd;\n                            ++_collEnd;\n                            // need to expand?\n                            if (bucket >= _collList.length) {\n                                expandCollision();\n                            }\n                        } else { // nope, have to share... let's find shortest?\n                            bucket = findBestBucket();\n                        }\n                        // Need to mark the entry... and the spill index is 1-based\n                        _mainHash[ix] = (val & ~0xFF) | (bucket + 1);\n                    } else {\n                        --bucket; // 1-based index in value\n                    }\n                    // And then just need to link the new bucket entry in\n                    Bucket newB = new Bucket(symbol, _collList[bucket]);\n                    _collList[bucket] = newB;\n                    maxColl = Math.max(maxColl, newB.length());\n                }\n            } // for (... buckets in the chain ...)\n        } // for (... list of bucket heads ... )\n\n        _longestCollisionList = maxColl;\n        \n        if (symbolsSeen != _count) { // sanity check\n            throw new RuntimeException(\"Internal error: count after rehash \"+symbolsSeen+\"; should be \"+_count);\n        }\n    }",
          "1": "    private void rehash()\n    {\n        _needRehash = false;        \n        // Note: since we'll make copies, no need to unshare, can just mark as such:\n        _mainNamesShared = false;\n\n        /* And then we can first deal with the main hash area. Since we\n         * are expanding linearly (double up), we know there'll be no\n         * collisions during this phase.\n         */\n        int[] oldMainHash = _mainHash;\n        int len = oldMainHash.length;\n        int newLen = len+len;\n\n        /* 13-Mar-2010, tatu: Let's guard against OOME that could be caused by\n         *    large documents with unique (or mostly so) names\n         */\n        if (newLen > MAX_TABLE_SIZE) {\n            nukeSymbols();\n            return;\n        }\n        \n        _mainHash = new int[newLen];\n        _mainHashMask = (newLen - 1);\n        Name[] oldNames = _mainNames;\n        _mainNames = new Name[newLen];\n        int symbolsSeen = 0; // let's do a sanity check\n        for (int i = 0; i < len; ++i) {\n            Name symbol = oldNames[i];\n            if (symbol != null) {\n                ++symbolsSeen;\n                int hash = symbol.hashCode();\n                int ix = (hash & _mainHashMask);\n                _mainNames[ix] = symbol;\n                _mainHash[ix] = hash << 8; // will clear spill index\n            }\n        }\n\n        /* And then the spill area. This may cause collisions, although\n         * not necessarily as many as there were earlier. Let's allocate\n         * same amount of space, however\n         */\n        int oldEnd = _collEnd;\n        if (oldEnd == 0) { // no prior collisions...\n            _longestCollisionList = 0;\n            return;\n        }\n\n        _collCount = 0;\n        _collEnd = 0;\n        _collListShared = false;\n\n        int maxColl = 0;\n        \n        Bucket[] oldBuckets = _collList;\n        _collList = new Bucket[oldBuckets.length];\n        for (int i = 0; i < oldEnd; ++i) {\n            for (Bucket curr = oldBuckets[i]; curr != null; curr = curr._next) {\n                ++symbolsSeen;\n                Name symbol = curr._name;\n                int hash = symbol.hashCode();\n                int ix = (hash & _mainHashMask);\n                int val = _mainHash[ix];\n                if (_mainNames[ix] == null) { // no primary entry?\n_mainHash[ix] = (hash >>> 2);\n                    _mainNames[ix] = symbol;\n                } else { // nope, it's a collision, need to spill over\n                    ++_collCount;\n                    int bucket = val & 0xFF;\n                    if (bucket == 0) { // first spill over?\n                        if (_collEnd <= LAST_VALID_BUCKET) { // yup, still unshared bucket\n                            bucket = _collEnd;\n                            ++_collEnd;\n                            // need to expand?\n                            if (bucket >= _collList.length) {\n                                expandCollision();\n                            }\n                        } else { // nope, have to share... let's find shortest?\n                            bucket = findBestBucket();\n                        }\n                        // Need to mark the entry... and the spill index is 1-based\n                        _mainHash[ix] = (val & ~0xFF) | (bucket + 1);\n                    } else {\n                        --bucket; // 1-based index in value\n                    }\n                    // And then just need to link the new bucket entry in\n                    Bucket newB = new Bucket(symbol, _collList[bucket]);\n                    _collList[bucket] = newB;\n                    maxColl = Math.max(maxColl, newB.length());\n                }\n            } // for (... buckets in the chain ...)\n        } // for (... list of bucket heads ... )\n\n        _longestCollisionList = maxColl;\n        \n        if (symbolsSeen != _count) { // sanity check\n            throw new RuntimeException(\"Internal error: count after rehash \"+symbolsSeen+\"; should be \"+_count);\n        }\n    }",
          "2": "    private void rehash()\n    {\n        _needRehash = false;        \n        // Note: since we'll make copies, no need to unshare, can just mark as such:\n        _mainNamesShared = false;\n\n        /* And then we can first deal with the main hash area. Since we\n         * are expanding linearly (double up), we know there'll be no\n         * collisions during this phase.\n         */\n        int[] oldMainHash = _mainHash;\n        int len = oldMainHash.length;\n        int newLen = len+len;\n\n        /* 13-Mar-2010, tatu: Let's guard against OOME that could be caused by\n         *    large documents with unique (or mostly so) names\n         */\n        if (newLen > MAX_TABLE_SIZE) {\n            nukeSymbols();\n            return;\n        }\n        \n        _mainHash = new int[newLen];\n        _mainHashMask = (newLen - 1);\n        Name[] oldNames = _mainNames;\n        _mainNames = new Name[newLen];\n        int symbolsSeen = 0; // let's do a sanity check\n        for (int i = 0; i < len; ++i) {\n            Name symbol = oldNames[i];\n            if (symbol != null) {\n                ++symbolsSeen;\n                int hash = symbol.hashCode();\n                int ix = (hash & _mainHashMask);\n                _mainNames[ix] = symbol;\n                _mainHash[ix] = hash << 8; // will clear spill index\n            }\n        }\n\n        /* And then the spill area. This may cause collisions, although\n         * not necessarily as many as there were earlier. Let's allocate\n         * same amount of space, however\n         */\n        int oldEnd = _collEnd;\n        if (oldEnd == 0) { // no prior collisions...\n            _longestCollisionList = 0;\n            return;\n        }\n\n        _collCount = 0;\n        _collEnd = 0;\n        _collListShared = false;\n\n        int maxColl = 0;\n        \n        Bucket[] oldBuckets = _collList;\n        _collList = new Bucket[oldBuckets.length];\n        for (int i = 0; i < oldEnd; ++i) {\n            for (Bucket curr = oldBuckets[i]; curr != null; curr = curr._next) {\n                ++symbolsSeen;\n                Name symbol = curr._name;\n                int hash = symbol.hashCode();\n                int ix = (hash & _mainHashMask);\n                int val = _mainHash[ix];\n                if (_mainNames[ix] == null) { // no primary entry?\n                    _mainNames[ix] = symbol;\n                } else { // nope, it's a collision, need to spill over\n                    ++_collCount;\n                    int bucket = val & 0xFF;\n                    if (bucket == 0) { // first spill over?\n                        if (_collEnd <= LAST_VALID_BUCKET) { // yup, still unshared bucket\n                            bucket = _collEnd;\n                            ++_collEnd;\n                            // need to expand?\n                            if (bucket >= _collList.length) {\n                                expandCollision();\n                            }\n                        } else { // nope, have to share... let's find shortest?\n                            bucket = findBestBucket();\n                        }\n                        // Need to mark the entry... and the spill index is 1-based\n                        _mainHash[ix] = (val & ~0xFF) | (bucket + 1);\n                    } else {\n                        --bucket; // 1-based index in value\n                    }\n                    // And then just need to link the new bucket entry in\n                    Bucket newB = new Bucket(symbol, _collList[bucket]);\n                    _collList[bucket] = newB;\n                    maxColl = Math.max(maxColl, newB.length());\n                }\n            } // for (... buckets in the chain ...)\n        } // for (... list of bucket heads ... )\n\n        _longestCollisionList = maxColl;\n        \n        if (symbolsSeen != _count) { // sanity check\n            throw new RuntimeException(\"Internal error: count after rehash \"+symbolsSeen+\"; should be \"+_count);\n        }\n    }",
          "3": "    private void rehash()\n    {\n        _needRehash = false;        \n        // Note: since we'll make copies, no need to unshare, can just mark as such:\n        _mainNamesShared = false;\n\n        /* And then we can first deal with the main hash area. Since we\n         * are expanding linearly (double up), we know there'll be no\n         * collisions during this phase.\n         */\n        int[] oldMainHash = _mainHash;\n        int len = oldMainHash.length;\n        int newLen = len+len;\n\n        /* 13-Mar-2010, tatu: Let's guard against OOME that could be caused by\n         *    large documents with unique (or mostly so) names\n         */\n        if (newLen > MAX_TABLE_SIZE) {\n            nukeSymbols();\n            return;\n        }\n        \n        _mainHash = new int[newLen];\n        _mainHashMask = (newLen - 1);\n        Name[] oldNames = _mainNames;\n        _mainNames = new Name[newLen];\n        int symbolsSeen = 0; // let's do a sanity check\n        for (int i = 0; i < len; ++i) {\n            Name symbol = oldNames[i];\n            if (symbol != null) {\n                ++symbolsSeen;\n                int hash = symbol.hashCode();\n                int ix = (hash & _mainHashMask);\n                _mainNames[ix] = symbol;\n                _mainHash[ix] = hash << 8; // will clear spill index\n            }\n        }\n\n        /* And then the spill area. This may cause collisions, although\n         * not necessarily as many as there were earlier. Let's allocate\n         * same amount of space, however\n         */\n        int oldEnd = _collEnd;\n        if (oldEnd == 0) { // no prior collisions...\n            _longestCollisionList = 0;\n            return;\n        }\n\n        _collCount = 0;\n        _collEnd = 0;\n        _collListShared = false;\n\n        int maxColl = 0;\n        \n        Bucket[] oldBuckets = _collList;\n        _collList = new Bucket[oldBuckets.length];\n        for (int i = 0; i < oldEnd; ++i) {\n            for (Bucket curr = oldBuckets[i]; curr != null; curr = curr._next) {\n                ++symbolsSeen;\n                Name symbol = curr._name;\n                int hash = symbol.hashCode();\n                int ix = (hash & _mainHashMask);\n                int val = _mainHash[ix];\n                if (_mainNames[ix] == null) { // no primary entry?\n_mainHash[ix] = (hash - 8);\n                    _mainNames[ix] = symbol;\n                } else { // nope, it's a collision, need to spill over\n                    ++_collCount;\n                    int bucket = val & 0xFF;\n                    if (bucket == 0) { // first spill over?\n                        if (_collEnd <= LAST_VALID_BUCKET) { // yup, still unshared bucket\n                            bucket = _collEnd;\n                            ++_collEnd;\n                            // need to expand?\n                            if (bucket >= _collList.length) {\n                                expandCollision();\n                            }\n                        } else { // nope, have to share... let's find shortest?\n                            bucket = findBestBucket();\n                        }\n                        // Need to mark the entry... and the spill index is 1-based\n                        _mainHash[ix] = (val & ~0xFF) | (bucket + 1);\n                    } else {\n                        --bucket; // 1-based index in value\n                    }\n                    // And then just need to link the new bucket entry in\n                    Bucket newB = new Bucket(symbol, _collList[bucket]);\n                    _collList[bucket] = newB;\n                    maxColl = Math.max(maxColl, newB.length());\n                }\n            } // for (... buckets in the chain ...)\n        } // for (... list of bucket heads ... )\n\n        _longestCollisionList = maxColl;\n        \n        if (symbolsSeen != _count) { // sanity check\n            throw new RuntimeException(\"Internal error: count after rehash \"+symbolsSeen+\"; should be \"+_count);\n        }\n    }",
          "4": "    private void rehash()\n    {\n        _needRehash = false;        \n        // Note: since we'll make copies, no need to unshare, can just mark as such:\n        _mainNamesShared = false;\n\n        /* And then we can first deal with the main hash area. Since we\n         * are expanding linearly (double up), we know there'll be no\n         * collisions during this phase.\n         */\n        int[] oldMainHash = _mainHash;\n        int len = oldMainHash.length;\n        int newLen = len+len;\n\n        /* 13-Mar-2010, tatu: Let's guard against OOME that could be caused by\n         *    large documents with unique (or mostly so) names\n         */\n        if (newLen > MAX_TABLE_SIZE) {\n            nukeSymbols();\n            return;\n        }\n        \n        _mainHash = new int[newLen];\n        _mainHashMask = (newLen - 1);\n        Name[] oldNames = _mainNames;\n        _mainNames = new Name[newLen];\n        int symbolsSeen = 0; // let's do a sanity check\n        for (int i = 0; i < len; ++i) {\n            Name symbol = oldNames[i];\n            if (symbol != null) {\n                ++symbolsSeen;\n                int hash = symbol.hashCode();\n                int ix = (hash & _mainHashMask);\n                _mainNames[ix] = symbol;\n                _mainHash[ix] = hash << 8; // will clear spill index\n            }\n        }\n\n        /* And then the spill area. This may cause collisions, although\n         * not necessarily as many as there were earlier. Let's allocate\n         * same amount of space, however\n         */\n        int oldEnd = _collEnd;\n        if (oldEnd == 0) { // no prior collisions...\n            _longestCollisionList = 0;\n            return;\n        }\n\n        _collCount = 0;\n        _collEnd = 0;\n        _collListShared = false;\n\n        int maxColl = 0;\n        \n        Bucket[] oldBuckets = _collList;\n        _collList = new Bucket[oldBuckets.length];\n        for (int i = 0; i < oldEnd; ++i) {\n            for (Bucket curr = oldBuckets[i]; curr != null; curr = curr._next) {\n                ++symbolsSeen;\n                Name symbol = curr._name;\n                int hash = symbol.hashCode();\n                int ix = (hash & _mainHashMask);\n                int val = _mainHash[ix];\n                if (_mainNames[ix] == null) { // no primary entry?\n_mainHash[ix] = (ix >>> 8);\n                    _mainNames[ix] = symbol;\n                } else { // nope, it's a collision, need to spill over\n                    ++_collCount;\n                    int bucket = val & 0xFF;\n                    if (bucket == 0) { // first spill over?\n                        if (_collEnd <= LAST_VALID_BUCKET) { // yup, still unshared bucket\n                            bucket = _collEnd;\n                            ++_collEnd;\n                            // need to expand?\n                            if (bucket >= _collList.length) {\n                                expandCollision();\n                            }\n                        } else { // nope, have to share... let's find shortest?\n                            bucket = findBestBucket();\n                        }\n                        // Need to mark the entry... and the spill index is 1-based\n                        _mainHash[ix] = (val & ~0xFF) | (bucket + 1);\n                    } else {\n                        --bucket; // 1-based index in value\n                    }\n                    // And then just need to link the new bucket entry in\n                    Bucket newB = new Bucket(symbol, _collList[bucket]);\n                    _collList[bucket] = newB;\n                    maxColl = Math.max(maxColl, newB.length());\n                }\n            } // for (... buckets in the chain ...)\n        } // for (... list of bucket heads ... )\n\n        _longestCollisionList = maxColl;\n        \n        if (symbolsSeen != _count) { // sanity check\n            throw new RuntimeException(\"Internal error: count after rehash \"+symbolsSeen+\"; should be \"+_count);\n        }\n    }",
          "5": "    private void rehash()\n    {\n        _needRehash = false;        \n        // Note: since we'll make copies, no need to unshare, can just mark as such:\n        _mainNamesShared = false;\n\n        /* And then we can first deal with the main hash area. Since we\n         * are expanding linearly (double up), we know there'll be no\n         * collisions during this phase.\n         */\n        int[] oldMainHash = _mainHash;\n        int len = oldMainHash.length;\n        int newLen = len+len;\n\n        /* 13-Mar-2010, tatu: Let's guard against OOME that could be caused by\n         *    large documents with unique (or mostly so) names\n         */\n        if (newLen > MAX_TABLE_SIZE) {\n            nukeSymbols();\n            return;\n        }\n        \n        _mainHash = new int[newLen];\n        _mainHashMask = (newLen - 1);\n        Name[] oldNames = _mainNames;\n        _mainNames = new Name[newLen];\n        int symbolsSeen = 0; // let's do a sanity check\n        for (int i = 0; i < len; ++i) {\n            Name symbol = oldNames[i];\n            if (symbol != null) {\n                ++symbolsSeen;\n                int hash = symbol.hashCode();\n                int ix = (hash & _mainHashMask);\n                _mainNames[ix] = symbol;\n                _mainHash[ix] = hash << 8; // will clear spill index\n            }\n        }\n\n        /* And then the spill area. This may cause collisions, although\n         * not necessarily as many as there were earlier. Let's allocate\n         * same amount of space, however\n         */\n        int oldEnd = _collEnd;\n        if (oldEnd == 0) { // no prior collisions...\n            _longestCollisionList = 0;\n            return;\n        }\n\n        _collCount = 0;\n        _collEnd = 0;\n        _collListShared = false;\n\n        int maxColl = 0;\n        \n        Bucket[] oldBuckets = _collList;\n        _collList = new Bucket[oldBuckets.length];\n        for (int i = 0; i < oldEnd; ++i) {\n            for (Bucket curr = oldBuckets[i]; curr != null; curr = curr._next) {\n                ++symbolsSeen;\n                Name symbol = curr._name;\n                int hash = symbol.hashCode();\n                int ix = (hash & _mainHashMask);\n                int val = _mainHash[ix];\n                if (_mainNames[ix] == null) { // no primary entry?\n_mainNames[ix] = symbol;\n                    _mainNames[ix] = symbol;\n                } else { // nope, it's a collision, need to spill over\n                    ++_collCount;\n                    int bucket = val & 0xFF;\n                    if (bucket == 0) { // first spill over?\n                        if (_collEnd <= LAST_VALID_BUCKET) { // yup, still unshared bucket\n                            bucket = _collEnd;\n                            ++_collEnd;\n                            // need to expand?\n                            if (bucket >= _collList.length) {\n                                expandCollision();\n                            }\n                        } else { // nope, have to share... let's find shortest?\n                            bucket = findBestBucket();\n                        }\n                        // Need to mark the entry... and the spill index is 1-based\n                        _mainHash[ix] = (val & ~0xFF) | (bucket + 1);\n                    } else {\n                        --bucket; // 1-based index in value\n                    }\n                    // And then just need to link the new bucket entry in\n                    Bucket newB = new Bucket(symbol, _collList[bucket]);\n                    _collList[bucket] = newB;\n                    maxColl = Math.max(maxColl, newB.length());\n                }\n            } // for (... buckets in the chain ...)\n        } // for (... list of bucket heads ... )\n\n        _longestCollisionList = maxColl;\n        \n        if (symbolsSeen != _count) { // sanity check\n            throw new RuntimeException(\"Internal error: count after rehash \"+symbolsSeen+\"; should be \"+_count);\n        }\n    }",
          "6": "    private void rehash()\n    {\n        _needRehash = false;        \n        // Note: since we'll make copies, no need to unshare, can just mark as such:\n        _mainNamesShared = false;\n\n        /* And then we can first deal with the main hash area. Since we\n         * are expanding linearly (double up), we know there'll be no\n         * collisions during this phase.\n         */\n        int[] oldMainHash = _mainHash;\n        int len = oldMainHash.length;\n        int newLen = len+len;\n\n        /* 13-Mar-2010, tatu: Let's guard against OOME that could be caused by\n         *    large documents with unique (or mostly so) names\n         */\n        if (newLen > MAX_TABLE_SIZE) {\n            nukeSymbols();\n            return;\n        }\n        \n        _mainHash = new int[newLen];\n        _mainHashMask = (newLen - 1);\n        Name[] oldNames = _mainNames;\n        _mainNames = new Name[newLen];\n        int symbolsSeen = 0; // let's do a sanity check\n        for (int i = 0; i < len; ++i) {\n            Name symbol = oldNames[i];\n            if (symbol != null) {\n                ++symbolsSeen;\n                int hash = symbol.hashCode();\n                int ix = (hash & _mainHashMask);\n                _mainNames[ix] = symbol;\n                _mainHash[ix] = hash << 8; // will clear spill index\n            }\n        }\n\n        /* And then the spill area. This may cause collisions, although\n         * not necessarily as many as there were earlier. Let's allocate\n         * same amount of space, however\n         */\n        int oldEnd = _collEnd;\n        if (oldEnd == 0) { // no prior collisions...\n            _longestCollisionList = 0;\n            return;\n        }\n\n        _collCount = 0;\n        _collEnd = 0;\n        _collListShared = false;\n\n        int maxColl = 0;\n        \n        Bucket[] oldBuckets = _collList;\n        _collList = new Bucket[oldBuckets.length];\n        for (int i = 0; i < oldEnd; ++i) {\n            for (Bucket curr = oldBuckets[i]; curr != null; curr = curr._next) {\n                ++symbolsSeen;\n                Name symbol = curr._name;\n                int hash = symbol.hashCode();\n                int ix = (hash & _mainHashMask);\n                int val = _mainHash[ix];\n                if (_mainNames[ix] == null) { // no primary entry?\n_mainHash[ix] = (hash >>> 8);\n                    _mainNames[ix] = symbol;\n                } else { // nope, it's a collision, need to spill over\n                    ++_collCount;\n                    int bucket = val & 0xFF;\n                    if (bucket == 0) { // first spill over?\n                        if (_collEnd <= LAST_VALID_BUCKET) { // yup, still unshared bucket\n                            bucket = _collEnd;\n                            ++_collEnd;\n                            // need to expand?\n                            if (bucket >= _collList.length) {\n                                expandCollision();\n                            }\n                        } else { // nope, have to share... let's find shortest?\n                            bucket = findBestBucket();\n                        }\n                        // Need to mark the entry... and the spill index is 1-based\n                        _mainHash[ix] = (val & ~0xFF) | (bucket + 1);\n                    } else {\n                        --bucket; // 1-based index in value\n                    }\n                    // And then just need to link the new bucket entry in\n                    Bucket newB = new Bucket(symbol, _collList[bucket]);\n                    _collList[bucket] = newB;\n                    maxColl = Math.max(maxColl, newB.length());\n                }\n            } // for (... buckets in the chain ...)\n        } // for (... list of bucket heads ... )\n\n        _longestCollisionList = maxColl;\n        \n        if (symbolsSeen != _count) { // sanity check\n            throw new RuntimeException(\"Internal error: count after rehash \"+symbolsSeen+\"; should be \"+_count);\n        }\n    }",
          "7": "    private void rehash()\n    {\n        _needRehash = false;        \n        // Note: since we'll make copies, no need to unshare, can just mark as such:\n        _mainNamesShared = false;\n\n        /* And then we can first deal with the main hash area. Since we\n         * are expanding linearly (double up), we know there'll be no\n         * collisions during this phase.\n         */\n        int[] oldMainHash = _mainHash;\n        int len = oldMainHash.length;\n        int newLen = len+len;\n\n        /* 13-Mar-2010, tatu: Let's guard against OOME that could be caused by\n         *    large documents with unique (or mostly so) names\n         */\n        if (newLen > MAX_TABLE_SIZE) {\n            nukeSymbols();\n            return;\n        }\n        \n        _mainHash = new int[newLen];\n        _mainHashMask = (newLen - 1);\n        Name[] oldNames = _mainNames;\n        _mainNames = new Name[newLen];\n        int symbolsSeen = 0; // let's do a sanity check\n        for (int i = 0; i < len; ++i) {\n            Name symbol = oldNames[i];\n            if (symbol != null) {\n                ++symbolsSeen;\n                int hash = symbol.hashCode();\n                int ix = (hash & _mainHashMask);\n                _mainNames[ix] = symbol;\n                _mainHash[ix] = hash << 8; // will clear spill index\n            }\n        }\n\n        /* And then the spill area. This may cause collisions, although\n         * not necessarily as many as there were earlier. Let's allocate\n         * same amount of space, however\n         */\n        int oldEnd = _collEnd;\n        if (oldEnd == 0) { // no prior collisions...\n            _longestCollisionList = 0;\n            return;\n        }\n\n        _collCount = 0;\n        _collEnd = 0;\n        _collListShared = false;\n\n        int maxColl = 0;\n        \n        Bucket[] oldBuckets = _collList;\n        _collList = new Bucket[oldBuckets.length];\n        for (int i = 0; i < oldEnd; ++i) {\n            for (Bucket curr = oldBuckets[i]; curr != null; curr = curr._next) {\n                ++symbolsSeen;\n                Name symbol = curr._name;\n                int hash = symbol.hashCode();\n                int ix = (hash & _mainHashMask);\n                int val = _mainHash[ix];\n                if (_mainNames[ix] == null) { // no primary entry?\n_mainHash[ix] = (hash >>> -1);\n                    _mainNames[ix] = symbol;\n                } else { // nope, it's a collision, need to spill over\n                    ++_collCount;\n                    int bucket = val & 0xFF;\n                    if (bucket == 0) { // first spill over?\n                        if (_collEnd <= LAST_VALID_BUCKET) { // yup, still unshared bucket\n                            bucket = _collEnd;\n                            ++_collEnd;\n                            // need to expand?\n                            if (bucket >= _collList.length) {\n                                expandCollision();\n                            }\n                        } else { // nope, have to share... let's find shortest?\n                            bucket = findBestBucket();\n                        }\n                        // Need to mark the entry... and the spill index is 1-based\n                        _mainHash[ix] = (val & ~0xFF) | (bucket + 1);\n                    } else {\n                        --bucket; // 1-based index in value\n                    }\n                    // And then just need to link the new bucket entry in\n                    Bucket newB = new Bucket(symbol, _collList[bucket]);\n                    _collList[bucket] = newB;\n                    maxColl = Math.max(maxColl, newB.length());\n                }\n            } // for (... buckets in the chain ...)\n        } // for (... list of bucket heads ... )\n\n        _longestCollisionList = maxColl;\n        \n        if (symbolsSeen != _count) { // sanity check\n            throw new RuntimeException(\"Internal error: count after rehash \"+symbolsSeen+\"; should be \"+_count);\n        }\n    }",
          "8": "    private void rehash()\n    {\n        _needRehash = false;        \n        // Note: since we'll make copies, no need to unshare, can just mark as such:\n        _mainNamesShared = false;\n\n        /* And then we can first deal with the main hash area. Since we\n         * are expanding linearly (double up), we know there'll be no\n         * collisions during this phase.\n         */\n        int[] oldMainHash = _mainHash;\n        int len = oldMainHash.length;\n        int newLen = len+len;\n\n        /* 13-Mar-2010, tatu: Let's guard against OOME that could be caused by\n         *    large documents with unique (or mostly so) names\n         */\n        if (newLen > MAX_TABLE_SIZE) {\n            nukeSymbols();\n            return;\n        }\n        \n        _mainHash = new int[newLen];\n        _mainHashMask = (newLen - 1);\n        Name[] oldNames = _mainNames;\n        _mainNames = new Name[newLen];\n        int symbolsSeen = 0; // let's do a sanity check\n        for (int i = 0; i < len; ++i) {\n            Name symbol = oldNames[i];\n            if (symbol != null) {\n                ++symbolsSeen;\n                int hash = symbol.hashCode();\n                int ix = (hash & _mainHashMask);\n                _mainNames[ix] = symbol;\n                _mainHash[ix] = hash << 8; // will clear spill index\n            }\n        }\n\n        /* And then the spill area. This may cause collisions, although\n         * not necessarily as many as there were earlier. Let's allocate\n         * same amount of space, however\n         */\n        int oldEnd = _collEnd;\n        if (oldEnd == 0) { // no prior collisions...\n            _longestCollisionList = 0;\n            return;\n        }\n\n        _collCount = 0;\n        _collEnd = 0;\n        _collListShared = false;\n\n        int maxColl = 0;\n        \n        Bucket[] oldBuckets = _collList;\n        _collList = new Bucket[oldBuckets.length];\n        for (int i = 0; i < oldEnd; ++i) {\n            for (Bucket curr = oldBuckets[i]; curr != null; curr = curr._next) {\n                ++symbolsSeen;\n                Name symbol = curr._name;\n                int hash = symbol.hashCode();\n                int ix = (hash & _mainHashMask);\n                int val = _mainHash[ix];\n                if (_mainNames[ix] == null) { // no primary entry?\n_mainHash[ix] = (hash >>> ~0xFF);\n                    _mainNames[ix] = symbol;\n                } else { // nope, it's a collision, need to spill over\n                    ++_collCount;\n                    int bucket = val & 0xFF;\n                    if (bucket == 0) { // first spill over?\n                        if (_collEnd <= LAST_VALID_BUCKET) { // yup, still unshared bucket\n                            bucket = _collEnd;\n                            ++_collEnd;\n                            // need to expand?\n                            if (bucket >= _collList.length) {\n                                expandCollision();\n                            }\n                        } else { // nope, have to share... let's find shortest?\n                            bucket = findBestBucket();\n                        }\n                        // Need to mark the entry... and the spill index is 1-based\n                        _mainHash[ix] = (val & ~0xFF) | (bucket + 1);\n                    } else {\n                        --bucket; // 1-based index in value\n                    }\n                    // And then just need to link the new bucket entry in\n                    Bucket newB = new Bucket(symbol, _collList[bucket]);\n                    _collList[bucket] = newB;\n                    maxColl = Math.max(maxColl, newB.length());\n                }\n            } // for (... buckets in the chain ...)\n        } // for (... list of bucket heads ... )\n\n        _longestCollisionList = maxColl;\n        \n        if (symbolsSeen != _count) { // sanity check\n            throw new RuntimeException(\"Internal error: count after rehash \"+symbolsSeen+\"; should be \"+_count);\n        }\n    }",
          "9": "    private void rehash()\n    {\n        _needRehash = false;        \n        // Note: since we'll make copies, no need to unshare, can just mark as such:\n        _mainNamesShared = false;\n\n        /* And then we can first deal with the main hash area. Since we\n         * are expanding linearly (double up), we know there'll be no\n         * collisions during this phase.\n         */\n        int[] oldMainHash = _mainHash;\n        int len = oldMainHash.length;\n        int newLen = len+len;\n\n        /* 13-Mar-2010, tatu: Let's guard against OOME that could be caused by\n         *    large documents with unique (or mostly so) names\n         */\n        if (newLen > MAX_TABLE_SIZE) {\n            nukeSymbols();\n            return;\n        }\n        \n        _mainHash = new int[newLen];\n        _mainHashMask = (newLen - 1);\n        Name[] oldNames = _mainNames;\n        _mainNames = new Name[newLen];\n        int symbolsSeen = 0; // let's do a sanity check\n        for (int i = 0; i < len; ++i) {\n            Name symbol = oldNames[i];\n            if (symbol != null) {\n                ++symbolsSeen;\n                int hash = symbol.hashCode();\n                int ix = (hash & _mainHashMask);\n                _mainNames[ix] = symbol;\n                _mainHash[ix] = hash << 8; // will clear spill index\n            }\n        }\n\n        /* And then the spill area. This may cause collisions, although\n         * not necessarily as many as there were earlier. Let's allocate\n         * same amount of space, however\n         */\n        int oldEnd = _collEnd;\n        if (oldEnd == 0) { // no prior collisions...\n            _longestCollisionList = 0;\n            return;\n        }\n\n        _collCount = 0;\n        _collEnd = 0;\n        _collListShared = false;\n\n        int maxColl = 0;\n        \n        Bucket[] oldBuckets = _collList;\n        _collList = new Bucket[oldBuckets.length];\n        for (int i = 0; i < oldEnd; ++i) {\n            for (Bucket curr = oldBuckets[i]; curr != null; curr = curr._next) {\n                ++symbolsSeen;\n                Name symbol = curr._name;\n                int hash = symbol.hashCode();\n                int ix = (hash & _mainHashMask);\n                int val = _mainHash[ix];\n                if (_mainNames[ix] == null) { // no primary entry?\nexpandCollision();\n                    _mainNames[ix] = symbol;\n                } else { // nope, it's a collision, need to spill over\n                    ++_collCount;\n                    int bucket = val & 0xFF;\n                    if (bucket == 0) { // first spill over?\n                        if (_collEnd <= LAST_VALID_BUCKET) { // yup, still unshared bucket\n                            bucket = _collEnd;\n                            ++_collEnd;\n                            // need to expand?\n                            if (bucket >= _collList.length) {\n                                expandCollision();\n                            }\n                        } else { // nope, have to share... let's find shortest?\n                            bucket = findBestBucket();\n                        }\n                        // Need to mark the entry... and the spill index is 1-based\n                        _mainHash[ix] = (val & ~0xFF) | (bucket + 1);\n                    } else {\n                        --bucket; // 1-based index in value\n                    }\n                    // And then just need to link the new bucket entry in\n                    Bucket newB = new Bucket(symbol, _collList[bucket]);\n                    _collList[bucket] = newB;\n                    maxColl = Math.max(maxColl, newB.length());\n                }\n            } // for (... buckets in the chain ...)\n        } // for (... list of bucket heads ... )\n\n        _longestCollisionList = maxColl;\n        \n        if (symbolsSeen != _count) { // sanity check\n            throw new RuntimeException(\"Internal error: count after rehash \"+symbolsSeen+\"; should be \"+_count);\n        }\n    }",
          "10": "    private void rehash()\n    {\n        _needRehash = false;        \n        // Note: since we'll make copies, no need to unshare, can just mark as such:\n        _mainNamesShared = false;\n\n        /* And then we can first deal with the main hash area. Since we\n         * are expanding linearly (double up), we know there'll be no\n         * collisions during this phase.\n         */\n        int[] oldMainHash = _mainHash;\n        int len = oldMainHash.length;\n        int newLen = len+len;\n\n        /* 13-Mar-2010, tatu: Let's guard against OOME that could be caused by\n         *    large documents with unique (or mostly so) names\n         */\n        if (newLen > MAX_TABLE_SIZE) {\n            nukeSymbols();\n            return;\n        }\n        \n        _mainHash = new int[newLen];\n        _mainHashMask = (newLen - 1);\n        Name[] oldNames = _mainNames;\n        _mainNames = new Name[newLen];\n        int symbolsSeen = 0; // let's do a sanity check\n        for (int i = 0; i < len; ++i) {\n            Name symbol = oldNames[i];\n            if (symbol != null) {\n                ++symbolsSeen;\n                int hash = symbol.hashCode();\n                int ix = (hash & _mainHashMask);\n                _mainNames[ix] = symbol;\n                _mainHash[ix] = hash << 8; // will clear spill index\n            }\n        }\n\n        /* And then the spill area. This may cause collisions, although\n         * not necessarily as many as there were earlier. Let's allocate\n         * same amount of space, however\n         */\n        int oldEnd = _collEnd;\n        if (oldEnd == 0) { // no prior collisions...\n            _longestCollisionList = 0;\n            return;\n        }\n\n        _collCount = 0;\n        _collEnd = 0;\n        _collListShared = false;\n\n        int maxColl = 0;\n        \n        Bucket[] oldBuckets = _collList;\n        _collList = new Bucket[oldBuckets.length];\n        for (int i = 0; i < oldEnd; ++i) {\n            for (Bucket curr = oldBuckets[i]; curr != null; curr = curr._next) {\n                ++symbolsSeen;\n                Name symbol = curr._name;\n                int hash = symbol.hashCode();\n                int ix = (hash & _mainHashMask);\n                int val = _mainHash[ix];\n                if (_mainNames[ix] == null) { // no primary entry?\n_mainNames[ix] = (hash >>> 8);\n                    _mainNames[ix] = symbol;\n                } else { // nope, it's a collision, need to spill over\n                    ++_collCount;\n                    int bucket = val & 0xFF;\n                    if (bucket == 0) { // first spill over?\n                        if (_collEnd <= LAST_VALID_BUCKET) { // yup, still unshared bucket\n                            bucket = _collEnd;\n                            ++_collEnd;\n                            // need to expand?\n                            if (bucket >= _collList.length) {\n                                expandCollision();\n                            }\n                        } else { // nope, have to share... let's find shortest?\n                            bucket = findBestBucket();\n                        }\n                        // Need to mark the entry... and the spill index is 1-based\n                        _mainHash[ix] = (val & ~0xFF) | (bucket + 1);\n                    } else {\n                        --bucket; // 1-based index in value\n                    }\n                    // And then just need to link the new bucket entry in\n                    Bucket newB = new Bucket(symbol, _collList[bucket]);\n                    _collList[bucket] = newB;\n                    maxColl = Math.max(maxColl, newB.length());\n                }\n            } // for (... buckets in the chain ...)\n        } // for (... list of bucket heads ... )\n\n        _longestCollisionList = maxColl;\n        \n        if (symbolsSeen != _count) { // sanity check\n            throw new RuntimeException(\"Internal error: count after rehash \"+symbolsSeen+\"; should be \"+_count);\n        }\n    }",
          "11": "    private void rehash()\n    {\n        _needRehash = false;        \n        // Note: since we'll make copies, no need to unshare, can just mark as such:\n        _mainNamesShared = false;\n\n        /* And then we can first deal with the main hash area. Since we\n         * are expanding linearly (double up), we know there'll be no\n         * collisions during this phase.\n         */\n        int[] oldMainHash = _mainHash;\n        int len = oldMainHash.length;\n        int newLen = len+len;\n\n        /* 13-Mar-2010, tatu: Let's guard against OOME that could be caused by\n         *    large documents with unique (or mostly so) names\n         */\n        if (newLen > MAX_TABLE_SIZE) {\n            nukeSymbols();\n            return;\n        }\n        \n        _mainHash = new int[newLen];\n        _mainHashMask = (newLen - 1);\n        Name[] oldNames = _mainNames;\n        _mainNames = new Name[newLen];\n        int symbolsSeen = 0; // let's do a sanity check\n        for (int i = 0; i < len; ++i) {\n            Name symbol = oldNames[i];\n            if (symbol != null) {\n                ++symbolsSeen;\n                int hash = symbol.hashCode();\n                int ix = (hash & _mainHashMask);\n                _mainNames[ix] = symbol;\n                _mainHash[ix] = hash << 8; // will clear spill index\n            }\n        }\n\n        /* And then the spill area. This may cause collisions, although\n         * not necessarily as many as there were earlier. Let's allocate\n         * same amount of space, however\n         */\n        int oldEnd = _collEnd;\n        if (oldEnd == 0) { // no prior collisions...\n            _longestCollisionList = 0;\n            return;\n        }\n\n        _collCount = 0;\n        _collEnd = 0;\n        _collListShared = false;\n\n        int maxColl = 0;\n        \n        Bucket[] oldBuckets = _collList;\n        _collList = new Bucket[oldBuckets.length];\n        for (int i = 0; i < oldEnd; ++i) {\n            for (Bucket curr = oldBuckets[i]; curr != null; curr = curr._next) {\n                ++symbolsSeen;\n                Name symbol = curr._name;\n                int hash = symbol.hashCode();\n                int ix = (hash & _mainHashMask);\n                int val = _mainHash[ix];\n                if (_mainNames[ix] == null) { // no primary entry?\n_longestCollisionList = (hash >>> 8);\n                    _mainNames[ix] = symbol;\n                } else { // nope, it's a collision, need to spill over\n                    ++_collCount;\n                    int bucket = val & 0xFF;\n                    if (bucket == 0) { // first spill over?\n                        if (_collEnd <= LAST_VALID_BUCKET) { // yup, still unshared bucket\n                            bucket = _collEnd;\n                            ++_collEnd;\n                            // need to expand?\n                            if (bucket >= _collList.length) {\n                                expandCollision();\n                            }\n                        } else { // nope, have to share... let's find shortest?\n                            bucket = findBestBucket();\n                        }\n                        // Need to mark the entry... and the spill index is 1-based\n                        _mainHash[ix] = (val & ~0xFF) | (bucket + 1);\n                    } else {\n                        --bucket; // 1-based index in value\n                    }\n                    // And then just need to link the new bucket entry in\n                    Bucket newB = new Bucket(symbol, _collList[bucket]);\n                    _collList[bucket] = newB;\n                    maxColl = Math.max(maxColl, newB.length());\n                }\n            } // for (... buckets in the chain ...)\n        } // for (... list of bucket heads ... )\n\n        _longestCollisionList = maxColl;\n        \n        if (symbolsSeen != _count) { // sanity check\n            throw new RuntimeException(\"Internal error: count after rehash \"+symbolsSeen+\"; should be \"+_count);\n        }\n    }",
          "12": "    private void rehash()\n    {\n        _needRehash = false;        \n        // Note: since we'll make copies, no need to unshare, can just mark as such:\n        _mainNamesShared = false;\n\n        /* And then we can first deal with the main hash area. Since we\n         * are expanding linearly (double up), we know there'll be no\n         * collisions during this phase.\n         */\n        int[] oldMainHash = _mainHash;\n        int len = oldMainHash.length;\n        int newLen = len+len;\n\n        /* 13-Mar-2010, tatu: Let's guard against OOME that could be caused by\n         *    large documents with unique (or mostly so) names\n         */\n        if (newLen > MAX_TABLE_SIZE) {\n            nukeSymbols();\n            return;\n        }\n        \n        _mainHash = new int[newLen];\n        _mainHashMask = (newLen - 1);\n        Name[] oldNames = _mainNames;\n        _mainNames = new Name[newLen];\n        int symbolsSeen = 0; // let's do a sanity check\n        for (int i = 0; i < len; ++i) {\n            Name symbol = oldNames[i];\n            if (symbol != null) {\n                ++symbolsSeen;\n                int hash = symbol.hashCode();\n                int ix = (hash & _mainHashMask);\n                _mainNames[ix] = symbol;\n                _mainHash[ix] = hash << 8; // will clear spill index\n            }\n        }\n\n        /* And then the spill area. This may cause collisions, although\n         * not necessarily as many as there were earlier. Let's allocate\n         * same amount of space, however\n         */\n        int oldEnd = _collEnd;\n        if (oldEnd == 0) { // no prior collisions...\n            _longestCollisionList = 0;\n            return;\n        }\n\n        _collCount = 0;\n        _collEnd = 0;\n        _collListShared = false;\n\n        int maxColl = 0;\n        \n        Bucket[] oldBuckets = _collList;\n        _collList = new Bucket[oldBuckets.length];\n        for (int i = 0; i < oldEnd; ++i) {\n            for (Bucket curr = oldBuckets[i]; curr != null; curr = curr._next) {\n                ++symbolsSeen;\n                Name symbol = curr._name;\n                int hash = symbol.hashCode();\n                int ix = (hash & _mainHashMask);\n                int val = _mainHash[ix];\n                if (_mainNames[ix] == null) { // no primary entry?\n_mainHash[ix] = (hash >>> 0xFF);\n                    _mainNames[ix] = symbol;\n                } else { // nope, it's a collision, need to spill over\n                    ++_collCount;\n                    int bucket = val & 0xFF;\n                    if (bucket == 0) { // first spill over?\n                        if (_collEnd <= LAST_VALID_BUCKET) { // yup, still unshared bucket\n                            bucket = _collEnd;\n                            ++_collEnd;\n                            // need to expand?\n                            if (bucket >= _collList.length) {\n                                expandCollision();\n                            }\n                        } else { // nope, have to share... let's find shortest?\n                            bucket = findBestBucket();\n                        }\n                        // Need to mark the entry... and the spill index is 1-based\n                        _mainHash[ix] = (val & ~0xFF) | (bucket + 1);\n                    } else {\n                        --bucket; // 1-based index in value\n                    }\n                    // And then just need to link the new bucket entry in\n                    Bucket newB = new Bucket(symbol, _collList[bucket]);\n                    _collList[bucket] = newB;\n                    maxColl = Math.max(maxColl, newB.length());\n                }\n            } // for (... buckets in the chain ...)\n        } // for (... list of bucket heads ... )\n\n        _longestCollisionList = maxColl;\n        \n        if (symbolsSeen != _count) { // sanity check\n            throw new RuntimeException(\"Internal error: count after rehash \"+symbolsSeen+\"; should be \"+_count);\n        }\n    }",
          "13": "    private void rehash()\n    {\n        _needRehash = false;        \n        // Note: since we'll make copies, no need to unshare, can just mark as such:\n        _mainNamesShared = false;\n\n        /* And then we can first deal with the main hash area. Since we\n         * are expanding linearly (double up), we know there'll be no\n         * collisions during this phase.\n         */\n        int[] oldMainHash = _mainHash;\n        int len = oldMainHash.length;\n        int newLen = len+len;\n\n        /* 13-Mar-2010, tatu: Let's guard against OOME that could be caused by\n         *    large documents with unique (or mostly so) names\n         */\n        if (newLen > MAX_TABLE_SIZE) {\n            nukeSymbols();\n            return;\n        }\n        \n        _mainHash = new int[newLen];\n        _mainHashMask = (newLen - 1);\n        Name[] oldNames = _mainNames;\n        _mainNames = new Name[newLen];\n        int symbolsSeen = 0; // let's do a sanity check\n        for (int i = 0; i < len; ++i) {\n            Name symbol = oldNames[i];\n            if (symbol != null) {\n                ++symbolsSeen;\n                int hash = symbol.hashCode();\n                int ix = (hash & _mainHashMask);\n                _mainNames[ix] = symbol;\n                _mainHash[ix] = hash << 8; // will clear spill index\n            }\n        }\n\n        /* And then the spill area. This may cause collisions, although\n         * not necessarily as many as there were earlier. Let's allocate\n         * same amount of space, however\n         */\n        int oldEnd = _collEnd;\n        if (oldEnd == 0) { // no prior collisions...\n            _longestCollisionList = 0;\n            return;\n        }\n\n        _collCount = 0;\n        _collEnd = 0;\n        _collListShared = false;\n\n        int maxColl = 0;\n        \n        Bucket[] oldBuckets = _collList;\n        _collList = new Bucket[oldBuckets.length];\n        for (int i = 0; i < oldEnd; ++i) {\n            for (Bucket curr = oldBuckets[i]; curr != null; curr = curr._next) {\n                ++symbolsSeen;\n                Name symbol = curr._name;\n                int hash = symbol.hashCode();\n                int ix = (hash & _mainHashMask);\n                int val = _mainHash[ix];\n                if (_mainNames[ix] == null) { // no primary entry?\nbreak;\n                    _mainHash[ix] = (hash >>> 8);                    _mainNames[ix] = symbol;\n                } else { // nope, it's a collision, need to spill over\n                    ++_collCount;\n                    int bucket = val & 0xFF;\n                    if (bucket == 0) { // first spill over?\n                        if (_collEnd <= LAST_VALID_BUCKET) { // yup, still unshared bucket\n                            bucket = _collEnd;\n                            ++_collEnd;\n                            // need to expand?\n                            if (bucket >= _collList.length) {\n                                expandCollision();\n                            }\n                        } else { // nope, have to share... let's find shortest?\n                            bucket = findBestBucket();\n                        }\n                        // Need to mark the entry... and the spill index is 1-based\n                        _mainHash[ix] = (val & ~0xFF) | (bucket + 1);\n                    } else {\n                        --bucket; // 1-based index in value\n                    }\n                    // And then just need to link the new bucket entry in\n                    Bucket newB = new Bucket(symbol, _collList[bucket]);\n                    _collList[bucket] = newB;\n                    maxColl = Math.max(maxColl, newB.length());\n                }\n            } // for (... buckets in the chain ...)\n        } // for (... list of bucket heads ... )\n\n        _longestCollisionList = maxColl;\n        \n        if (symbolsSeen != _count) { // sanity check\n            throw new RuntimeException(\"Internal error: count after rehash \"+symbolsSeen+\"; should be \"+_count);\n        }\n    }",
          "14": "    private void rehash()\n    {\n        _needRehash = false;        \n        // Note: since we'll make copies, no need to unshare, can just mark as such:\n        _mainNamesShared = false;\n\n        /* And then we can first deal with the main hash area. Since we\n         * are expanding linearly (double up), we know there'll be no\n         * collisions during this phase.\n         */\n        int[] oldMainHash = _mainHash;\n        int len = oldMainHash.length;\n        int newLen = len+len;\n\n        /* 13-Mar-2010, tatu: Let's guard against OOME that could be caused by\n         *    large documents with unique (or mostly so) names\n         */\n        if (newLen > MAX_TABLE_SIZE) {\n            nukeSymbols();\n            return;\n        }\n        \n        _mainHash = new int[newLen];\n        _mainHashMask = (newLen - 1);\n        Name[] oldNames = _mainNames;\n        _mainNames = new Name[newLen];\n        int symbolsSeen = 0; // let's do a sanity check\n        for (int i = 0; i < len; ++i) {\n            Name symbol = oldNames[i];\n            if (symbol != null) {\n                ++symbolsSeen;\n                int hash = symbol.hashCode();\n                int ix = (hash & _mainHashMask);\n                _mainNames[ix] = symbol;\n                _mainHash[ix] = hash << 8; // will clear spill index\n            }\n        }\n\n        /* And then the spill area. This may cause collisions, although\n         * not necessarily as many as there were earlier. Let's allocate\n         * same amount of space, however\n         */\n        int oldEnd = _collEnd;\n        if (oldEnd == 0) { // no prior collisions...\n            _longestCollisionList = 0;\n            return;\n        }\n\n        _collCount = 0;\n        _collEnd = 0;\n        _collListShared = false;\n\n        int maxColl = 0;\n        \n        Bucket[] oldBuckets = _collList;\n        _collList = new Bucket[oldBuckets.length];\n        for (int i = 0; i < oldEnd; ++i) {\n            for (Bucket curr = oldBuckets[i]; curr != null; curr = curr._next) {\n                ++symbolsSeen;\n                Name symbol = curr._name;\n                int hash = symbol.hashCode();\n                int ix = (hash & _mainHashMask);\n                int val = _mainHash[ix];\n                if (_mainNames[ix] == null) { // no primary entry?\n_mainHash[ix] = (hash >> 8);\n                    _mainNames[ix] = symbol;\n                } else { // nope, it's a collision, need to spill over\n                    ++_collCount;\n                    int bucket = val & 0xFF;\n                    if (bucket == 0) { // first spill over?\n                        if (_collEnd <= LAST_VALID_BUCKET) { // yup, still unshared bucket\n                            bucket = _collEnd;\n                            ++_collEnd;\n                            // need to expand?\n                            if (bucket >= _collList.length) {\n                                expandCollision();\n                            }\n                        } else { // nope, have to share... let's find shortest?\n                            bucket = findBestBucket();\n                        }\n                        // Need to mark the entry... and the spill index is 1-based\n                        _mainHash[ix] = (val & ~0xFF) | (bucket + 1);\n                    } else {\n                        --bucket; // 1-based index in value\n                    }\n                    // And then just need to link the new bucket entry in\n                    Bucket newB = new Bucket(symbol, _collList[bucket]);\n                    _collList[bucket] = newB;\n                    maxColl = Math.max(maxColl, newB.length());\n                }\n            } // for (... buckets in the chain ...)\n        } // for (... list of bucket heads ... )\n\n        _longestCollisionList = maxColl;\n        \n        if (symbolsSeen != _count) { // sanity check\n            throw new RuntimeException(\"Internal error: count after rehash \"+symbolsSeen+\"; should be \"+_count);\n        }\n    }",
          "15": "    private void rehash()\n    {\n        _needRehash = false;        \n        // Note: since we'll make copies, no need to unshare, can just mark as such:\n        _mainNamesShared = false;\n\n        /* And then we can first deal with the main hash area. Since we\n         * are expanding linearly (double up), we know there'll be no\n         * collisions during this phase.\n         */\n        int[] oldMainHash = _mainHash;\n        int len = oldMainHash.length;\n        int newLen = len+len;\n\n        /* 13-Mar-2010, tatu: Let's guard against OOME that could be caused by\n         *    large documents with unique (or mostly so) names\n         */\n        if (newLen > MAX_TABLE_SIZE) {\n            nukeSymbols();\n            return;\n        }\n        \n        _mainHash = new int[newLen];\n        _mainHashMask = (newLen - 1);\n        Name[] oldNames = _mainNames;\n        _mainNames = new Name[newLen];\n        int symbolsSeen = 0; // let's do a sanity check\n        for (int i = 0; i < len; ++i) {\n            Name symbol = oldNames[i];\n            if (symbol != null) {\n                ++symbolsSeen;\n                int hash = symbol.hashCode();\n                int ix = (hash & _mainHashMask);\n                _mainNames[ix] = symbol;\n                _mainHash[ix] = hash << 8; // will clear spill index\n            }\n        }\n\n        /* And then the spill area. This may cause collisions, although\n         * not necessarily as many as there were earlier. Let's allocate\n         * same amount of space, however\n         */\n        int oldEnd = _collEnd;\n        if (oldEnd == 0) { // no prior collisions...\n            _longestCollisionList = 0;\n            return;\n        }\n\n        _collCount = 0;\n        _collEnd = 0;\n        _collListShared = false;\n\n        int maxColl = 0;\n        \n        Bucket[] oldBuckets = _collList;\n        _collList = new Bucket[oldBuckets.length];\n        for (int i = 0; i < oldEnd; ++i) {\n            for (Bucket curr = oldBuckets[i]; curr != null; curr = curr._next) {\n                ++symbolsSeen;\n                Name symbol = curr._name;\n                int hash = symbol.hashCode();\n                int ix = (hash & _mainHashMask);\n                int val = _mainHash[ix];\n                if (_mainNames[ix] == null) { // no primary entry?\n_mainHash[ix] = (hash + 8);\n                    _mainNames[ix] = symbol;\n                } else { // nope, it's a collision, need to spill over\n                    ++_collCount;\n                    int bucket = val & 0xFF;\n                    if (bucket == 0) { // first spill over?\n                        if (_collEnd <= LAST_VALID_BUCKET) { // yup, still unshared bucket\n                            bucket = _collEnd;\n                            ++_collEnd;\n                            // need to expand?\n                            if (bucket >= _collList.length) {\n                                expandCollision();\n                            }\n                        } else { // nope, have to share... let's find shortest?\n                            bucket = findBestBucket();\n                        }\n                        // Need to mark the entry... and the spill index is 1-based\n                        _mainHash[ix] = (val & ~0xFF) | (bucket + 1);\n                    } else {\n                        --bucket; // 1-based index in value\n                    }\n                    // And then just need to link the new bucket entry in\n                    Bucket newB = new Bucket(symbol, _collList[bucket]);\n                    _collList[bucket] = newB;\n                    maxColl = Math.max(maxColl, newB.length());\n                }\n            } // for (... buckets in the chain ...)\n        } // for (... list of bucket heads ... )\n\n        _longestCollisionList = maxColl;\n        \n        if (symbolsSeen != _count) { // sanity check\n            throw new RuntimeException(\"Internal error: count after rehash \"+symbolsSeen+\"; should be \"+_count);\n        }\n    }",
          "16": "    private void rehash()\n    {\n        _needRehash = false;        \n        // Note: since we'll make copies, no need to unshare, can just mark as such:\n        _mainNamesShared = false;\n\n        /* And then we can first deal with the main hash area. Since we\n         * are expanding linearly (double up), we know there'll be no\n         * collisions during this phase.\n         */\n        int[] oldMainHash = _mainHash;\n        int len = oldMainHash.length;\n        int newLen = len+len;\n\n        /* 13-Mar-2010, tatu: Let's guard against OOME that could be caused by\n         *    large documents with unique (or mostly so) names\n         */\n        if (newLen > MAX_TABLE_SIZE) {\n            nukeSymbols();\n            return;\n        }\n        \n        _mainHash = new int[newLen];\n        _mainHashMask = (newLen - 1);\n        Name[] oldNames = _mainNames;\n        _mainNames = new Name[newLen];\n        int symbolsSeen = 0; // let's do a sanity check\n        for (int i = 0; i < len; ++i) {\n            Name symbol = oldNames[i];\n            if (symbol != null) {\n                ++symbolsSeen;\n                int hash = symbol.hashCode();\n                int ix = (hash & _mainHashMask);\n                _mainNames[ix] = symbol;\n                _mainHash[ix] = hash << 8; // will clear spill index\n            }\n        }\n\n        /* And then the spill area. This may cause collisions, although\n         * not necessarily as many as there were earlier. Let's allocate\n         * same amount of space, however\n         */\n        int oldEnd = _collEnd;\n        if (oldEnd == 0) { // no prior collisions...\n            _longestCollisionList = 0;\n            return;\n        }\n\n        _collCount = 0;\n        _collEnd = 0;\n        _collListShared = false;\n\n        int maxColl = 0;\n        \n        Bucket[] oldBuckets = _collList;\n        _collList = new Bucket[oldBuckets.length];\n        for (int i = 0; i < oldEnd; ++i) {\n            for (Bucket curr = oldBuckets[i]; curr != null; curr = curr._next) {\n                ++symbolsSeen;\n                Name symbol = curr._name;\n                int hash = symbol.hashCode();\n                int ix = (hash & _mainHashMask);\n                int val = _mainHash[ix];\n                if (_mainNames[ix] == null) { // no primary entry?\nix = (hash >>> 8);\n                    _mainNames[ix] = symbol;\n                } else { // nope, it's a collision, need to spill over\n                    ++_collCount;\n                    int bucket = val & 0xFF;\n                    if (bucket == 0) { // first spill over?\n                        if (_collEnd <= LAST_VALID_BUCKET) { // yup, still unshared bucket\n                            bucket = _collEnd;\n                            ++_collEnd;\n                            // need to expand?\n                            if (bucket >= _collList.length) {\n                                expandCollision();\n                            }\n                        } else { // nope, have to share... let's find shortest?\n                            bucket = findBestBucket();\n                        }\n                        // Need to mark the entry... and the spill index is 1-based\n                        _mainHash[ix] = (val & ~0xFF) | (bucket + 1);\n                    } else {\n                        --bucket; // 1-based index in value\n                    }\n                    // And then just need to link the new bucket entry in\n                    Bucket newB = new Bucket(symbol, _collList[bucket]);\n                    _collList[bucket] = newB;\n                    maxColl = Math.max(maxColl, newB.length());\n                }\n            } // for (... buckets in the chain ...)\n        } // for (... list of bucket heads ... )\n\n        _longestCollisionList = maxColl;\n        \n        if (symbolsSeen != _count) { // sanity check\n            throw new RuntimeException(\"Internal error: count after rehash \"+symbolsSeen+\"; should be \"+_count);\n        }\n    }",
          "17": "    private void rehash()\n    {\n        _needRehash = false;        \n        // Note: since we'll make copies, no need to unshare, can just mark as such:\n        _mainNamesShared = false;\n\n        /* And then we can first deal with the main hash area. Since we\n         * are expanding linearly (double up), we know there'll be no\n         * collisions during this phase.\n         */\n        int[] oldMainHash = _mainHash;\n        int len = oldMainHash.length;\n        int newLen = len+len;\n\n        /* 13-Mar-2010, tatu: Let's guard against OOME that could be caused by\n         *    large documents with unique (or mostly so) names\n         */\n        if (newLen > MAX_TABLE_SIZE) {\n            nukeSymbols();\n            return;\n        }\n        \n        _mainHash = new int[newLen];\n        _mainHashMask = (newLen - 1);\n        Name[] oldNames = _mainNames;\n        _mainNames = new Name[newLen];\n        int symbolsSeen = 0; // let's do a sanity check\n        for (int i = 0; i < len; ++i) {\n            Name symbol = oldNames[i];\n            if (symbol != null) {\n                ++symbolsSeen;\n                int hash = symbol.hashCode();\n                int ix = (hash & _mainHashMask);\n                _mainNames[ix] = symbol;\n                _mainHash[ix] = hash << 8; // will clear spill index\n            }\n        }\n\n        /* And then the spill area. This may cause collisions, although\n         * not necessarily as many as there were earlier. Let's allocate\n         * same amount of space, however\n         */\n        int oldEnd = _collEnd;\n        if (oldEnd == 0) { // no prior collisions...\n            _longestCollisionList = 0;\n            return;\n        }\n\n        _collCount = 0;\n        _collEnd = 0;\n        _collListShared = false;\n\n        int maxColl = 0;\n        \n        Bucket[] oldBuckets = _collList;\n        _collList = new Bucket[oldBuckets.length];\n        for (int i = 0; i < oldEnd; ++i) {\n            for (Bucket curr = oldBuckets[i]; curr != null; curr = curr._next) {\n                ++symbolsSeen;\n                Name symbol = curr._name;\n                int hash = symbol.hashCode();\n                int ix = (hash & _mainHashMask);\n                int val = _mainHash[ix];\n                if (_mainNames[ix] == null) { // no primary entry?\nbucket = _collEnd;\n                    _mainNames[ix] = symbol;\n                } else { // nope, it's a collision, need to spill over\n                    ++_collCount;\n                    int bucket = val & 0xFF;\n                    if (bucket == 0) { // first spill over?\n                        if (_collEnd <= LAST_VALID_BUCKET) { // yup, still unshared bucket\n                            bucket = _collEnd;\n                            ++_collEnd;\n                            // need to expand?\n                            if (bucket >= _collList.length) {\n                                expandCollision();\n                            }\n                        } else { // nope, have to share... let's find shortest?\n                            bucket = findBestBucket();\n                        }\n                        // Need to mark the entry... and the spill index is 1-based\n                        _mainHash[ix] = (val & ~0xFF) | (bucket + 1);\n                    } else {\n                        --bucket; // 1-based index in value\n                    }\n                    // And then just need to link the new bucket entry in\n                    Bucket newB = new Bucket(symbol, _collList[bucket]);\n                    _collList[bucket] = newB;\n                    maxColl = Math.max(maxColl, newB.length());\n                }\n            } // for (... buckets in the chain ...)\n        } // for (... list of bucket heads ... )\n\n        _longestCollisionList = maxColl;\n        \n        if (symbolsSeen != _count) { // sanity check\n            throw new RuntimeException(\"Internal error: count after rehash \"+symbolsSeen+\"; should be \"+_count);\n        }\n    }",
          "18": "    private void rehash()\n    {\n        _needRehash = false;        \n        // Note: since we'll make copies, no need to unshare, can just mark as such:\n        _mainNamesShared = false;\n\n        /* And then we can first deal with the main hash area. Since we\n         * are expanding linearly (double up), we know there'll be no\n         * collisions during this phase.\n         */\n        int[] oldMainHash = _mainHash;\n        int len = oldMainHash.length;\n        int newLen = len+len;\n\n        /* 13-Mar-2010, tatu: Let's guard against OOME that could be caused by\n         *    large documents with unique (or mostly so) names\n         */\n        if (newLen > MAX_TABLE_SIZE) {\n            nukeSymbols();\n            return;\n        }\n        \n        _mainHash = new int[newLen];\n        _mainHashMask = (newLen - 1);\n        Name[] oldNames = _mainNames;\n        _mainNames = new Name[newLen];\n        int symbolsSeen = 0; // let's do a sanity check\n        for (int i = 0; i < len; ++i) {\n            Name symbol = oldNames[i];\n            if (symbol != null) {\n                ++symbolsSeen;\n                int hash = symbol.hashCode();\n                int ix = (hash & _mainHashMask);\n                _mainNames[ix] = symbol;\n                _mainHash[ix] = hash << 8; // will clear spill index\n            }\n        }\n\n        /* And then the spill area. This may cause collisions, although\n         * not necessarily as many as there were earlier. Let's allocate\n         * same amount of space, however\n         */\n        int oldEnd = _collEnd;\n        if (oldEnd == 0) { // no prior collisions...\n            _longestCollisionList = 0;\n            return;\n        }\n\n        _collCount = 0;\n        _collEnd = 0;\n        _collListShared = false;\n\n        int maxColl = 0;\n        \n        Bucket[] oldBuckets = _collList;\n        _collList = new Bucket[oldBuckets.length];\n        for (int i = 0; i < oldEnd; ++i) {\n            for (Bucket curr = oldBuckets[i]; curr != null; curr = curr._next) {\n                ++symbolsSeen;\n                Name symbol = curr._name;\n                int hash = symbol.hashCode();\n                int ix = (hash & _mainHashMask);\n                int val = _mainHash[ix];\n                if (_mainNames[ix] == null) { // no primary entry?\nbucket = findBestBucket();\n                    _mainNames[ix] = symbol;\n                } else { // nope, it's a collision, need to spill over\n                    ++_collCount;\n                    int bucket = val & 0xFF;\n                    if (bucket == 0) { // first spill over?\n                        if (_collEnd <= LAST_VALID_BUCKET) { // yup, still unshared bucket\n                            bucket = _collEnd;\n                            ++_collEnd;\n                            // need to expand?\n                            if (bucket >= _collList.length) {\n                                expandCollision();\n                            }\n                        } else { // nope, have to share... let's find shortest?\n                            bucket = findBestBucket();\n                        }\n                        // Need to mark the entry... and the spill index is 1-based\n                        _mainHash[ix] = (val & ~0xFF) | (bucket + 1);\n                    } else {\n                        --bucket; // 1-based index in value\n                    }\n                    // And then just need to link the new bucket entry in\n                    Bucket newB = new Bucket(symbol, _collList[bucket]);\n                    _collList[bucket] = newB;\n                    maxColl = Math.max(maxColl, newB.length());\n                }\n            } // for (... buckets in the chain ...)\n        } // for (... list of bucket heads ... )\n\n        _longestCollisionList = maxColl;\n        \n        if (symbolsSeen != _count) { // sanity check\n            throw new RuntimeException(\"Internal error: count after rehash \"+symbolsSeen+\"; should be \"+_count);\n        }\n    }",
          "19": "    private void rehash()\n    {\n        _needRehash = false;        \n        // Note: since we'll make copies, no need to unshare, can just mark as such:\n        _mainNamesShared = false;\n\n        /* And then we can first deal with the main hash area. Since we\n         * are expanding linearly (double up), we know there'll be no\n         * collisions during this phase.\n         */\n        int[] oldMainHash = _mainHash;\n        int len = oldMainHash.length;\n        int newLen = len+len;\n\n        /* 13-Mar-2010, tatu: Let's guard against OOME that could be caused by\n         *    large documents with unique (or mostly so) names\n         */\n        if (newLen > MAX_TABLE_SIZE) {\n            nukeSymbols();\n            return;\n        }\n        \n        _mainHash = new int[newLen];\n        _mainHashMask = (newLen - 1);\n        Name[] oldNames = _mainNames;\n        _mainNames = new Name[newLen];\n        int symbolsSeen = 0; // let's do a sanity check\n        for (int i = 0; i < len; ++i) {\n            Name symbol = oldNames[i];\n            if (symbol != null) {\n                ++symbolsSeen;\n                int hash = symbol.hashCode();\n                int ix = (hash & _mainHashMask);\n                _mainNames[ix] = symbol;\n                _mainHash[ix] = hash << 8; // will clear spill index\n            }\n        }\n\n        /* And then the spill area. This may cause collisions, although\n         * not necessarily as many as there were earlier. Let's allocate\n         * same amount of space, however\n         */\n        int oldEnd = _collEnd;\n        if (oldEnd == 0) { // no prior collisions...\n            _longestCollisionList = 0;\n            return;\n        }\n\n        _collCount = 0;\n        _collEnd = 0;\n        _collListShared = false;\n\n        int maxColl = 0;\n        \n        Bucket[] oldBuckets = _collList;\n        _collList = new Bucket[oldBuckets.length];\n        for (int i = 0; i < oldEnd; ++i) {\n            for (Bucket curr = oldBuckets[i]; curr != null; curr = curr._next) {\n                ++symbolsSeen;\n                Name symbol = curr._name;\n                int hash = symbol.hashCode();\n                int ix = (hash & _mainHashMask);\n                int val = _mainHash[ix];\n                if (_mainNames[ix] == null) { // no primary entry?\nbucket = (hash >>> 8);\n                    _mainNames[ix] = symbol;\n                } else { // nope, it's a collision, need to spill over\n                    ++_collCount;\n                    int bucket = val & 0xFF;\n                    if (bucket == 0) { // first spill over?\n                        if (_collEnd <= LAST_VALID_BUCKET) { // yup, still unshared bucket\n                            bucket = _collEnd;\n                            ++_collEnd;\n                            // need to expand?\n                            if (bucket >= _collList.length) {\n                                expandCollision();\n                            }\n                        } else { // nope, have to share... let's find shortest?\n                            bucket = findBestBucket();\n                        }\n                        // Need to mark the entry... and the spill index is 1-based\n                        _mainHash[ix] = (val & ~0xFF) | (bucket + 1);\n                    } else {\n                        --bucket; // 1-based index in value\n                    }\n                    // And then just need to link the new bucket entry in\n                    Bucket newB = new Bucket(symbol, _collList[bucket]);\n                    _collList[bucket] = newB;\n                    maxColl = Math.max(maxColl, newB.length());\n                }\n            } // for (... buckets in the chain ...)\n        } // for (... list of bucket heads ... )\n\n        _longestCollisionList = maxColl;\n        \n        if (symbolsSeen != _count) { // sanity check\n            throw new RuntimeException(\"Internal error: count after rehash \"+symbolsSeen+\"; should be \"+_count);\n        }\n    }",
          "20": "    private void rehash()\n    {\n        _needRehash = false;        \n        // Note: since we'll make copies, no need to unshare, can just mark as such:\n        _mainNamesShared = false;\n\n        /* And then we can first deal with the main hash area. Since we\n         * are expanding linearly (double up), we know there'll be no\n         * collisions during this phase.\n         */\n        int[] oldMainHash = _mainHash;\n        int len = oldMainHash.length;\n        int newLen = len+len;\n\n        /* 13-Mar-2010, tatu: Let's guard against OOME that could be caused by\n         *    large documents with unique (or mostly so) names\n         */\n        if (newLen > MAX_TABLE_SIZE) {\n            nukeSymbols();\n            return;\n        }\n        \n        _mainHash = new int[newLen];\n        _mainHashMask = (newLen - 1);\n        Name[] oldNames = _mainNames;\n        _mainNames = new Name[newLen];\n        int symbolsSeen = 0; // let's do a sanity check\n        for (int i = 0; i < len; ++i) {\n            Name symbol = oldNames[i];\n            if (symbol != null) {\n                ++symbolsSeen;\n                int hash = symbol.hashCode();\n                int ix = (hash & _mainHashMask);\n                _mainNames[ix] = symbol;\n                _mainHash[ix] = hash << 8; // will clear spill index\n            }\n        }\n\n        /* And then the spill area. This may cause collisions, although\n         * not necessarily as many as there were earlier. Let's allocate\n         * same amount of space, however\n         */\n        int oldEnd = _collEnd;\n        if (oldEnd == 0) { // no prior collisions...\n            _longestCollisionList = 0;\n            return;\n        }\n\n        _collCount = 0;\n        _collEnd = 0;\n        _collListShared = false;\n\n        int maxColl = 0;\n        \n        Bucket[] oldBuckets = _collList;\n        _collList = new Bucket[oldBuckets.length];\n        for (int i = 0; i < oldEnd; ++i) {\n            for (Bucket curr = oldBuckets[i]; curr != null; curr = curr._next) {\n                ++symbolsSeen;\n                Name symbol = curr._name;\n                int hash = symbol.hashCode();\n                int ix = (hash & _mainHashMask);\n                int val = _mainHash[ix];\n                if (_mainNames[ix] == null) { // no primary entry?\n_mainHash[ix] = ((val & ~0xFF) | (bucket + 1));\n                    _mainNames[ix] = symbol;\n                } else { // nope, it's a collision, need to spill over\n                    ++_collCount;\n                    int bucket = val & 0xFF;\n                    if (bucket == 0) { // first spill over?\n                        if (_collEnd <= LAST_VALID_BUCKET) { // yup, still unshared bucket\n                            bucket = _collEnd;\n                            ++_collEnd;\n                            // need to expand?\n                            if (bucket >= _collList.length) {\n                                expandCollision();\n                            }\n                        } else { // nope, have to share... let's find shortest?\n                            bucket = findBestBucket();\n                        }\n                        // Need to mark the entry... and the spill index is 1-based\n                        _mainHash[ix] = (val & ~0xFF) | (bucket + 1);\n                    } else {\n                        --bucket; // 1-based index in value\n                    }\n                    // And then just need to link the new bucket entry in\n                    Bucket newB = new Bucket(symbol, _collList[bucket]);\n                    _collList[bucket] = newB;\n                    maxColl = Math.max(maxColl, newB.length());\n                }\n            } // for (... buckets in the chain ...)\n        } // for (... list of bucket heads ... )\n\n        _longestCollisionList = maxColl;\n        \n        if (symbolsSeen != _count) { // sanity check\n            throw new RuntimeException(\"Internal error: count after rehash \"+symbolsSeen+\"; should be \"+_count);\n        }\n    }",
          "21": "    private void rehash()\n    {\n        _needRehash = false;        \n        // Note: since we'll make copies, no need to unshare, can just mark as such:\n        _mainNamesShared = false;\n\n        /* And then we can first deal with the main hash area. Since we\n         * are expanding linearly (double up), we know there'll be no\n         * collisions during this phase.\n         */\n        int[] oldMainHash = _mainHash;\n        int len = oldMainHash.length;\n        int newLen = len+len;\n\n        /* 13-Mar-2010, tatu: Let's guard against OOME that could be caused by\n         *    large documents with unique (or mostly so) names\n         */\n        if (newLen > MAX_TABLE_SIZE) {\n            nukeSymbols();\n            return;\n        }\n        \n        _mainHash = new int[newLen];\n        _mainHashMask = (newLen - 1);\n        Name[] oldNames = _mainNames;\n        _mainNames = new Name[newLen];\n        int symbolsSeen = 0; // let's do a sanity check\n        for (int i = 0; i < len; ++i) {\n            Name symbol = oldNames[i];\n            if (symbol != null) {\n                ++symbolsSeen;\n                int hash = symbol.hashCode();\n                int ix = (hash & _mainHashMask);\n                _mainNames[ix] = symbol;\n                _mainHash[ix] = hash << 8; // will clear spill index\n            }\n        }\n\n        /* And then the spill area. This may cause collisions, although\n         * not necessarily as many as there were earlier. Let's allocate\n         * same amount of space, however\n         */\n        int oldEnd = _collEnd;\n        if (oldEnd == 0) { // no prior collisions...\n            _longestCollisionList = 0;\n            return;\n        }\n\n        _collCount = 0;\n        _collEnd = 0;\n        _collListShared = false;\n\n        int maxColl = 0;\n        \n        Bucket[] oldBuckets = _collList;\n        _collList = new Bucket[oldBuckets.length];\n        for (int i = 0; i < oldEnd; ++i) {\n            for (Bucket curr = oldBuckets[i]; curr != null; curr = curr._next) {\n                ++symbolsSeen;\n                Name symbol = curr._name;\n                int hash = symbol.hashCode();\n                int ix = (hash & _mainHashMask);\n                int val = _mainHash[ix];\n                if (_mainNames[ix] == null) { // no primary entry?\nmaxColl = (hash >>> 8);\n                    _mainNames[ix] = symbol;\n                } else { // nope, it's a collision, need to spill over\n                    ++_collCount;\n                    int bucket = val & 0xFF;\n                    if (bucket == 0) { // first spill over?\n                        if (_collEnd <= LAST_VALID_BUCKET) { // yup, still unshared bucket\n                            bucket = _collEnd;\n                            ++_collEnd;\n                            // need to expand?\n                            if (bucket >= _collList.length) {\n                                expandCollision();\n                            }\n                        } else { // nope, have to share... let's find shortest?\n                            bucket = findBestBucket();\n                        }\n                        // Need to mark the entry... and the spill index is 1-based\n                        _mainHash[ix] = (val & ~0xFF) | (bucket + 1);\n                    } else {\n                        --bucket; // 1-based index in value\n                    }\n                    // And then just need to link the new bucket entry in\n                    Bucket newB = new Bucket(symbol, _collList[bucket]);\n                    _collList[bucket] = newB;\n                    maxColl = Math.max(maxColl, newB.length());\n                }\n            } // for (... buckets in the chain ...)\n        } // for (... list of bucket heads ... )\n\n        _longestCollisionList = maxColl;\n        \n        if (symbolsSeen != _count) { // sanity check\n            throw new RuntimeException(\"Internal error: count after rehash \"+symbolsSeen+\"; should be \"+_count);\n        }\n    }",
          "22": "    private void rehash()\n    {\n        _needRehash = false;        \n        // Note: since we'll make copies, no need to unshare, can just mark as such:\n        _mainNamesShared = false;\n\n        /* And then we can first deal with the main hash area. Since we\n         * are expanding linearly (double up), we know there'll be no\n         * collisions during this phase.\n         */\n        int[] oldMainHash = _mainHash;\n        int len = oldMainHash.length;\n        int newLen = len+len;\n\n        /* 13-Mar-2010, tatu: Let's guard against OOME that could be caused by\n         *    large documents with unique (or mostly so) names\n         */\n        if (newLen > MAX_TABLE_SIZE) {\n            nukeSymbols();\n            return;\n        }\n        \n        _mainHash = new int[newLen];\n        _mainHashMask = (newLen - 1);\n        Name[] oldNames = _mainNames;\n        _mainNames = new Name[newLen];\n        int symbolsSeen = 0; // let's do a sanity check\n        for (int i = 0; i < len; ++i) {\n            Name symbol = oldNames[i];\n            if (symbol != null) {\n                ++symbolsSeen;\n                int hash = symbol.hashCode();\n                int ix = (hash & _mainHashMask);\n                _mainNames[ix] = symbol;\n                _mainHash[ix] = hash << 8; // will clear spill index\n            }\n        }\n\n        /* And then the spill area. This may cause collisions, although\n         * not necessarily as many as there were earlier. Let's allocate\n         * same amount of space, however\n         */\n        int oldEnd = _collEnd;\n        if (oldEnd == 0) { // no prior collisions...\n            _longestCollisionList = 0;\n            return;\n        }\n\n        _collCount = 0;\n        _collEnd = 0;\n        _collListShared = false;\n\n        int maxColl = 0;\n        \n        Bucket[] oldBuckets = _collList;\n        _collList = new Bucket[oldBuckets.length];\n        for (int i = 0; i < oldEnd; ++i) {\n            for (Bucket curr = oldBuckets[i]; curr != null; curr = curr._next) {\n                ++symbolsSeen;\n                Name symbol = curr._name;\n                int hash = symbol.hashCode();\n                int ix = (hash & _mainHashMask);\n                int val = _mainHash[ix];\n                if (_mainNames[ix] == null) { // no primary entry?\n--bucket;\n                    _mainNames[ix] = symbol;\n                } else { // nope, it's a collision, need to spill over\n                    ++_collCount;\n                    int bucket = val & 0xFF;\n                    if (bucket == 0) { // first spill over?\n                        if (_collEnd <= LAST_VALID_BUCKET) { // yup, still unshared bucket\n                            bucket = _collEnd;\n                            ++_collEnd;\n                            // need to expand?\n                            if (bucket >= _collList.length) {\n                                expandCollision();\n                            }\n                        } else { // nope, have to share... let's find shortest?\n                            bucket = findBestBucket();\n                        }\n                        // Need to mark the entry... and the spill index is 1-based\n                        _mainHash[ix] = (val & ~0xFF) | (bucket + 1);\n                    } else {\n                        --bucket; // 1-based index in value\n                    }\n                    // And then just need to link the new bucket entry in\n                    Bucket newB = new Bucket(symbol, _collList[bucket]);\n                    _collList[bucket] = newB;\n                    maxColl = Math.max(maxColl, newB.length());\n                }\n            } // for (... buckets in the chain ...)\n        } // for (... list of bucket heads ... )\n\n        _longestCollisionList = maxColl;\n        \n        if (symbolsSeen != _count) { // sanity check\n            throw new RuntimeException(\"Internal error: count after rehash \"+symbolsSeen+\"; should be \"+_count);\n        }\n    }",
          "23": "    private void rehash()\n    {\n        _needRehash = false;        \n        // Note: since we'll make copies, no need to unshare, can just mark as such:\n        _mainNamesShared = false;\n\n        /* And then we can first deal with the main hash area. Since we\n         * are expanding linearly (double up), we know there'll be no\n         * collisions during this phase.\n         */\n        int[] oldMainHash = _mainHash;\n        int len = oldMainHash.length;\n        int newLen = len+len;\n\n        /* 13-Mar-2010, tatu: Let's guard against OOME that could be caused by\n         *    large documents with unique (or mostly so) names\n         */\n        if (newLen > MAX_TABLE_SIZE) {\n            nukeSymbols();\n            return;\n        }\n        \n        _mainHash = new int[newLen];\n        _mainHashMask = (newLen - 1);\n        Name[] oldNames = _mainNames;\n        _mainNames = new Name[newLen];\n        int symbolsSeen = 0; // let's do a sanity check\n        for (int i = 0; i < len; ++i) {\n            Name symbol = oldNames[i];\n            if (symbol != null) {\n                ++symbolsSeen;\n                int hash = symbol.hashCode();\n                int ix = (hash & _mainHashMask);\n                _mainNames[ix] = symbol;\n                _mainHash[ix] = hash << 8; // will clear spill index\n            }\n        }\n\n        /* And then the spill area. This may cause collisions, although\n         * not necessarily as many as there were earlier. Let's allocate\n         * same amount of space, however\n         */\n        int oldEnd = _collEnd;\n        if (oldEnd == 0) { // no prior collisions...\n            _longestCollisionList = 0;\n            return;\n        }\n\n        _collCount = 0;\n        _collEnd = 0;\n        _collListShared = false;\n\n        int maxColl = 0;\n        \n        Bucket[] oldBuckets = _collList;\n        _collList = new Bucket[oldBuckets.length];\n        for (int i = 0; i < oldEnd; ++i) {\n            for (Bucket curr = oldBuckets[i]; curr != null; curr = curr._next) {\n                ++symbolsSeen;\n                Name symbol = curr._name;\n                int hash = symbol.hashCode();\n                int ix = (hash & _mainHashMask);\n                int val = _mainHash[ix];\n                if (_mainNames[ix] == null) { // no primary entry?\n_mainHash[ix] = (hash % 8);\n                    _mainNames[ix] = symbol;\n                } else { // nope, it's a collision, need to spill over\n                    ++_collCount;\n                    int bucket = val & 0xFF;\n                    if (bucket == 0) { // first spill over?\n                        if (_collEnd <= LAST_VALID_BUCKET) { // yup, still unshared bucket\n                            bucket = _collEnd;\n                            ++_collEnd;\n                            // need to expand?\n                            if (bucket >= _collList.length) {\n                                expandCollision();\n                            }\n                        } else { // nope, have to share... let's find shortest?\n                            bucket = findBestBucket();\n                        }\n                        // Need to mark the entry... and the spill index is 1-based\n                        _mainHash[ix] = (val & ~0xFF) | (bucket + 1);\n                    } else {\n                        --bucket; // 1-based index in value\n                    }\n                    // And then just need to link the new bucket entry in\n                    Bucket newB = new Bucket(symbol, _collList[bucket]);\n                    _collList[bucket] = newB;\n                    maxColl = Math.max(maxColl, newB.length());\n                }\n            } // for (... buckets in the chain ...)\n        } // for (... list of bucket heads ... )\n\n        _longestCollisionList = maxColl;\n        \n        if (symbolsSeen != _count) { // sanity check\n            throw new RuntimeException(\"Internal error: count after rehash \"+symbolsSeen+\"; should be \"+_count);\n        }\n    }",
          "24": "    private void rehash()\n    {\n        _needRehash = false;        \n        // Note: since we'll make copies, no need to unshare, can just mark as such:\n        _mainNamesShared = false;\n\n        /* And then we can first deal with the main hash area. Since we\n         * are expanding linearly (double up), we know there'll be no\n         * collisions during this phase.\n         */\n        int[] oldMainHash = _mainHash;\n        int len = oldMainHash.length;\n        int newLen = len+len;\n\n        /* 13-Mar-2010, tatu: Let's guard against OOME that could be caused by\n         *    large documents with unique (or mostly so) names\n         */\n        if (newLen > MAX_TABLE_SIZE) {\n            nukeSymbols();\n            return;\n        }\n        \n        _mainHash = new int[newLen];\n        _mainHashMask = (newLen - 1);\n        Name[] oldNames = _mainNames;\n        _mainNames = new Name[newLen];\n        int symbolsSeen = 0; // let's do a sanity check\n        for (int i = 0; i < len; ++i) {\n            Name symbol = oldNames[i];\n            if (symbol != null) {\n                ++symbolsSeen;\n                int hash = symbol.hashCode();\n                int ix = (hash & _mainHashMask);\n                _mainNames[ix] = symbol;\n                _mainHash[ix] = hash << 8; // will clear spill index\n            }\n        }\n\n        /* And then the spill area. This may cause collisions, although\n         * not necessarily as many as there were earlier. Let's allocate\n         * same amount of space, however\n         */\n        int oldEnd = _collEnd;\n        if (oldEnd == 0) { // no prior collisions...\n            _longestCollisionList = 0;\n            return;\n        }\n\n        _collCount = 0;\n        _collEnd = 0;\n        _collListShared = false;\n\n        int maxColl = 0;\n        \n        Bucket[] oldBuckets = _collList;\n        _collList = new Bucket[oldBuckets.length];\n        for (int i = 0; i < oldEnd; ++i) {\n            for (Bucket curr = oldBuckets[i]; curr != null; curr = curr._next) {\n                ++symbolsSeen;\n                Name symbol = curr._name;\n                int hash = symbol.hashCode();\n                int ix = (hash & _mainHashMask);\n                int val = _mainHash[ix];\n                if (_mainNames[ix] == null) { // no primary entry?\n_mainHash[ix] = (hash <= 8);\n                    _mainNames[ix] = symbol;\n                } else { // nope, it's a collision, need to spill over\n                    ++_collCount;\n                    int bucket = val & 0xFF;\n                    if (bucket == 0) { // first spill over?\n                        if (_collEnd <= LAST_VALID_BUCKET) { // yup, still unshared bucket\n                            bucket = _collEnd;\n                            ++_collEnd;\n                            // need to expand?\n                            if (bucket >= _collList.length) {\n                                expandCollision();\n                            }\n                        } else { // nope, have to share... let's find shortest?\n                            bucket = findBestBucket();\n                        }\n                        // Need to mark the entry... and the spill index is 1-based\n                        _mainHash[ix] = (val & ~0xFF) | (bucket + 1);\n                    } else {\n                        --bucket; // 1-based index in value\n                    }\n                    // And then just need to link the new bucket entry in\n                    Bucket newB = new Bucket(symbol, _collList[bucket]);\n                    _collList[bucket] = newB;\n                    maxColl = Math.max(maxColl, newB.length());\n                }\n            } // for (... buckets in the chain ...)\n        } // for (... list of bucket heads ... )\n\n        _longestCollisionList = maxColl;\n        \n        if (symbolsSeen != _count) { // sanity check\n            throw new RuntimeException(\"Internal error: count after rehash \"+symbolsSeen+\"; should be \"+_count);\n        }\n    }",
          "25": "    private void rehash()\n    {\n        _needRehash = false;        \n        // Note: since we'll make copies, no need to unshare, can just mark as such:\n        _mainNamesShared = false;\n\n        /* And then we can first deal with the main hash area. Since we\n         * are expanding linearly (double up), we know there'll be no\n         * collisions during this phase.\n         */\n        int[] oldMainHash = _mainHash;\n        int len = oldMainHash.length;\n        int newLen = len+len;\n\n        /* 13-Mar-2010, tatu: Let's guard against OOME that could be caused by\n         *    large documents with unique (or mostly so) names\n         */\n        if (newLen > MAX_TABLE_SIZE) {\n            nukeSymbols();\n            return;\n        }\n        \n        _mainHash = new int[newLen];\n        _mainHashMask = (newLen - 1);\n        Name[] oldNames = _mainNames;\n        _mainNames = new Name[newLen];\n        int symbolsSeen = 0; // let's do a sanity check\n        for (int i = 0; i < len; ++i) {\n            Name symbol = oldNames[i];\n            if (symbol != null) {\n                ++symbolsSeen;\n                int hash = symbol.hashCode();\n                int ix = (hash & _mainHashMask);\n                _mainNames[ix] = symbol;\n                _mainHash[ix] = hash << 8; // will clear spill index\n            }\n        }\n\n        /* And then the spill area. This may cause collisions, although\n         * not necessarily as many as there were earlier. Let's allocate\n         * same amount of space, however\n         */\n        int oldEnd = _collEnd;\n        if (oldEnd == 0) { // no prior collisions...\n            _longestCollisionList = 0;\n            return;\n        }\n\n        _collCount = 0;\n        _collEnd = 0;\n        _collListShared = false;\n\n        int maxColl = 0;\n        \n        Bucket[] oldBuckets = _collList;\n        _collList = new Bucket[oldBuckets.length];\n        for (int i = 0; i < oldEnd; ++i) {\n            for (Bucket curr = oldBuckets[i]; curr != null; curr = curr._next) {\n                ++symbolsSeen;\n                Name symbol = curr._name;\n                int hash = symbol.hashCode();\n                int ix = (hash & _mainHashMask);\n                int val = _mainHash[ix];\n                if (_mainNames[ix] == null) { // no primary entry?\n++symbolsSeen;\n                    _mainNames[ix] = symbol;\n                } else { // nope, it's a collision, need to spill over\n                    ++_collCount;\n                    int bucket = val & 0xFF;\n                    if (bucket == 0) { // first spill over?\n                        if (_collEnd <= LAST_VALID_BUCKET) { // yup, still unshared bucket\n                            bucket = _collEnd;\n                            ++_collEnd;\n                            // need to expand?\n                            if (bucket >= _collList.length) {\n                                expandCollision();\n                            }\n                        } else { // nope, have to share... let's find shortest?\n                            bucket = findBestBucket();\n                        }\n                        // Need to mark the entry... and the spill index is 1-based\n                        _mainHash[ix] = (val & ~0xFF) | (bucket + 1);\n                    } else {\n                        --bucket; // 1-based index in value\n                    }\n                    // And then just need to link the new bucket entry in\n                    Bucket newB = new Bucket(symbol, _collList[bucket]);\n                    _collList[bucket] = newB;\n                    maxColl = Math.max(maxColl, newB.length());\n                }\n            } // for (... buckets in the chain ...)\n        } // for (... list of bucket heads ... )\n\n        _longestCollisionList = maxColl;\n        \n        if (symbolsSeen != _count) { // sanity check\n            throw new RuntimeException(\"Internal error: count after rehash \"+symbolsSeen+\"; should be \"+_count);\n        }\n    }",
          "26": "    private void rehash()\n    {\n        _needRehash = false;        \n        // Note: since we'll make copies, no need to unshare, can just mark as such:\n        _mainNamesShared = false;\n\n        /* And then we can first deal with the main hash area. Since we\n         * are expanding linearly (double up), we know there'll be no\n         * collisions during this phase.\n         */\n        int[] oldMainHash = _mainHash;\n        int len = oldMainHash.length;\n        int newLen = len+len;\n\n        /* 13-Mar-2010, tatu: Let's guard against OOME that could be caused by\n         *    large documents with unique (or mostly so) names\n         */\n        if (newLen > MAX_TABLE_SIZE) {\n            nukeSymbols();\n            return;\n        }\n        \n        _mainHash = new int[newLen];\n        _mainHashMask = (newLen - 1);\n        Name[] oldNames = _mainNames;\n        _mainNames = new Name[newLen];\n        int symbolsSeen = 0; // let's do a sanity check\n        for (int i = 0; i < len; ++i) {\n            Name symbol = oldNames[i];\n            if (symbol != null) {\n                ++symbolsSeen;\n                int hash = symbol.hashCode();\n                int ix = (hash & _mainHashMask);\n                _mainNames[ix] = symbol;\n                _mainHash[ix] = hash << 8; // will clear spill index\n            }\n        }\n\n        /* And then the spill area. This may cause collisions, although\n         * not necessarily as many as there were earlier. Let's allocate\n         * same amount of space, however\n         */\n        int oldEnd = _collEnd;\n        if (oldEnd == 0) { // no prior collisions...\n            _longestCollisionList = 0;\n            return;\n        }\n\n        _collCount = 0;\n        _collEnd = 0;\n        _collListShared = false;\n\n        int maxColl = 0;\n        \n        Bucket[] oldBuckets = _collList;\n        _collList = new Bucket[oldBuckets.length];\n        for (int i = 0; i < oldEnd; ++i) {\n            for (Bucket curr = oldBuckets[i]; curr != null; curr = curr._next) {\n                ++symbolsSeen;\n                Name symbol = curr._name;\n                int hash = symbol.hashCode();\n                int ix = (hash & _mainHashMask);\n                int val = _mainHash[ix];\n                if (_mainNames[ix] == null) { // no primary entry?\n++_collEnd;\n                    _mainNames[ix] = symbol;\n                } else { // nope, it's a collision, need to spill over\n                    ++_collCount;\n                    int bucket = val & 0xFF;\n                    if (bucket == 0) { // first spill over?\n                        if (_collEnd <= LAST_VALID_BUCKET) { // yup, still unshared bucket\n                            bucket = _collEnd;\n                            ++_collEnd;\n                            // need to expand?\n                            if (bucket >= _collList.length) {\n                                expandCollision();\n                            }\n                        } else { // nope, have to share... let's find shortest?\n                            bucket = findBestBucket();\n                        }\n                        // Need to mark the entry... and the spill index is 1-based\n                        _mainHash[ix] = (val & ~0xFF) | (bucket + 1);\n                    } else {\n                        --bucket; // 1-based index in value\n                    }\n                    // And then just need to link the new bucket entry in\n                    Bucket newB = new Bucket(symbol, _collList[bucket]);\n                    _collList[bucket] = newB;\n                    maxColl = Math.max(maxColl, newB.length());\n                }\n            } // for (... buckets in the chain ...)\n        } // for (... list of bucket heads ... )\n\n        _longestCollisionList = maxColl;\n        \n        if (symbolsSeen != _count) { // sanity check\n            throw new RuntimeException(\"Internal error: count after rehash \"+symbolsSeen+\"; should be \"+_count);\n        }\n    }",
          "27": "    private void rehash()\n    {\n        _needRehash = false;        \n        // Note: since we'll make copies, no need to unshare, can just mark as such:\n        _mainNamesShared = false;\n\n        /* And then we can first deal with the main hash area. Since we\n         * are expanding linearly (double up), we know there'll be no\n         * collisions during this phase.\n         */\n        int[] oldMainHash = _mainHash;\n        int len = oldMainHash.length;\n        int newLen = len+len;\n\n        /* 13-Mar-2010, tatu: Let's guard against OOME that could be caused by\n         *    large documents with unique (or mostly so) names\n         */\n        if (newLen > MAX_TABLE_SIZE) {\n            nukeSymbols();\n            return;\n        }\n        \n        _mainHash = new int[newLen];\n        _mainHashMask = (newLen - 1);\n        Name[] oldNames = _mainNames;\n        _mainNames = new Name[newLen];\n        int symbolsSeen = 0; // let's do a sanity check\n        for (int i = 0; i < len; ++i) {\n            Name symbol = oldNames[i];\n            if (symbol != null) {\n                ++symbolsSeen;\n                int hash = symbol.hashCode();\n                int ix = (hash & _mainHashMask);\n                _mainNames[ix] = symbol;\n                _mainHash[ix] = hash << 8; // will clear spill index\n            }\n        }\n\n        /* And then the spill area. This may cause collisions, although\n         * not necessarily as many as there were earlier. Let's allocate\n         * same amount of space, however\n         */\n        int oldEnd = _collEnd;\n        if (oldEnd == 0) { // no prior collisions...\n            _longestCollisionList = 0;\n            return;\n        }\n\n        _collCount = 0;\n        _collEnd = 0;\n        _collListShared = false;\n\n        int maxColl = 0;\n        \n        Bucket[] oldBuckets = _collList;\n        _collList = new Bucket[oldBuckets.length];\n        for (int i = 0; i < oldEnd; ++i) {\n            for (Bucket curr = oldBuckets[i]; curr != null; curr = curr._next) {\n                ++symbolsSeen;\n                Name symbol = curr._name;\n                int hash = symbol.hashCode();\n                int ix = (hash & _mainHashMask);\n                int val = _mainHash[ix];\n                if (_mainNames[ix] == null) { // no primary entry?\n++_collCount;\n                    _mainNames[ix] = symbol;\n                } else { // nope, it's a collision, need to spill over\n                    ++_collCount;\n                    int bucket = val & 0xFF;\n                    if (bucket == 0) { // first spill over?\n                        if (_collEnd <= LAST_VALID_BUCKET) { // yup, still unshared bucket\n                            bucket = _collEnd;\n                            ++_collEnd;\n                            // need to expand?\n                            if (bucket >= _collList.length) {\n                                expandCollision();\n                            }\n                        } else { // nope, have to share... let's find shortest?\n                            bucket = findBestBucket();\n                        }\n                        // Need to mark the entry... and the spill index is 1-based\n                        _mainHash[ix] = (val & ~0xFF) | (bucket + 1);\n                    } else {\n                        --bucket; // 1-based index in value\n                    }\n                    // And then just need to link the new bucket entry in\n                    Bucket newB = new Bucket(symbol, _collList[bucket]);\n                    _collList[bucket] = newB;\n                    maxColl = Math.max(maxColl, newB.length());\n                }\n            } // for (... buckets in the chain ...)\n        } // for (... list of bucket heads ... )\n\n        _longestCollisionList = maxColl;\n        \n        if (symbolsSeen != _count) { // sanity check\n            throw new RuntimeException(\"Internal error: count after rehash \"+symbolsSeen+\"; should be \"+_count);\n        }\n    }",
          "28": "    private void rehash()\n    {\n        _needRehash = false;        \n        // Note: since we'll make copies, no need to unshare, can just mark as such:\n        _mainNamesShared = false;\n\n        /* And then we can first deal with the main hash area. Since we\n         * are expanding linearly (double up), we know there'll be no\n         * collisions during this phase.\n         */\n        int[] oldMainHash = _mainHash;\n        int len = oldMainHash.length;\n        int newLen = len+len;\n\n        /* 13-Mar-2010, tatu: Let's guard against OOME that could be caused by\n         *    large documents with unique (or mostly so) names\n         */\n        if (newLen > MAX_TABLE_SIZE) {\n            nukeSymbols();\n            return;\n        }\n        \n        _mainHash = new int[newLen];\n        _mainHashMask = (newLen - 1);\n        Name[] oldNames = _mainNames;\n        _mainNames = new Name[newLen];\n        int symbolsSeen = 0; // let's do a sanity check\n        for (int i = 0; i < len; ++i) {\n            Name symbol = oldNames[i];\n            if (symbol != null) {\n                ++symbolsSeen;\n                int hash = symbol.hashCode();\n                int ix = (hash & _mainHashMask);\n                _mainNames[ix] = symbol;\n                _mainHash[ix] = hash << 8; // will clear spill index\n            }\n        }\n\n        /* And then the spill area. This may cause collisions, although\n         * not necessarily as many as there were earlier. Let's allocate\n         * same amount of space, however\n         */\n        int oldEnd = _collEnd;\n        if (oldEnd == 0) { // no prior collisions...\n            _longestCollisionList = 0;\n            return;\n        }\n\n        _collCount = 0;\n        _collEnd = 0;\n        _collListShared = false;\n\n        int maxColl = 0;\n        \n        Bucket[] oldBuckets = _collList;\n        _collList = new Bucket[oldBuckets.length];\n        for (int i = 0; i < oldEnd; ++i) {\n            for (Bucket curr = oldBuckets[i]; curr != null; curr = curr._next) {\n                ++symbolsSeen;\n                Name symbol = curr._name;\n                int hash = symbol.hashCode();\n                int ix = (hash & _mainHashMask);\n                int val = _mainHash[ix];\n                if (_mainNames[ix] == null) { // no primary entry?\n_mainHash[ix] = (hash / 8);\n                    _mainNames[ix] = symbol;\n                } else { // nope, it's a collision, need to spill over\n                    ++_collCount;\n                    int bucket = val & 0xFF;\n                    if (bucket == 0) { // first spill over?\n                        if (_collEnd <= LAST_VALID_BUCKET) { // yup, still unshared bucket\n                            bucket = _collEnd;\n                            ++_collEnd;\n                            // need to expand?\n                            if (bucket >= _collList.length) {\n                                expandCollision();\n                            }\n                        } else { // nope, have to share... let's find shortest?\n                            bucket = findBestBucket();\n                        }\n                        // Need to mark the entry... and the spill index is 1-based\n                        _mainHash[ix] = (val & ~0xFF) | (bucket + 1);\n                    } else {\n                        --bucket; // 1-based index in value\n                    }\n                    // And then just need to link the new bucket entry in\n                    Bucket newB = new Bucket(symbol, _collList[bucket]);\n                    _collList[bucket] = newB;\n                    maxColl = Math.max(maxColl, newB.length());\n                }\n            } // for (... buckets in the chain ...)\n        } // for (... list of bucket heads ... )\n\n        _longestCollisionList = maxColl;\n        \n        if (symbolsSeen != _count) { // sanity check\n            throw new RuntimeException(\"Internal error: count after rehash \"+symbolsSeen+\"; should be \"+_count);\n        }\n    }",
          "29": "    private void rehash()\n    {\n        _needRehash = false;        \n        // Note: since we'll make copies, no need to unshare, can just mark as such:\n        _mainNamesShared = false;\n\n        /* And then we can first deal with the main hash area. Since we\n         * are expanding linearly (double up), we know there'll be no\n         * collisions during this phase.\n         */\n        int[] oldMainHash = _mainHash;\n        int len = oldMainHash.length;\n        int newLen = len+len;\n\n        /* 13-Mar-2010, tatu: Let's guard against OOME that could be caused by\n         *    large documents with unique (or mostly so) names\n         */\n        if (newLen > MAX_TABLE_SIZE) {\n            nukeSymbols();\n            return;\n        }\n        \n        _mainHash = new int[newLen];\n        _mainHashMask = (newLen - 1);\n        Name[] oldNames = _mainNames;\n        _mainNames = new Name[newLen];\n        int symbolsSeen = 0; // let's do a sanity check\n        for (int i = 0; i < len; ++i) {\n            Name symbol = oldNames[i];\n            if (symbol != null) {\n                ++symbolsSeen;\n                int hash = symbol.hashCode();\n                int ix = (hash & _mainHashMask);\n                _mainNames[ix] = symbol;\n                _mainHash[ix] = hash << 8; // will clear spill index\n            }\n        }\n\n        /* And then the spill area. This may cause collisions, although\n         * not necessarily as many as there were earlier. Let's allocate\n         * same amount of space, however\n         */\n        int oldEnd = _collEnd;\n        if (oldEnd == 0) { // no prior collisions...\n            _longestCollisionList = 0;\n            return;\n        }\n\n        _collCount = 0;\n        _collEnd = 0;\n        _collListShared = false;\n\n        int maxColl = 0;\n        \n        Bucket[] oldBuckets = _collList;\n        _collList = new Bucket[oldBuckets.length];\n        for (int i = 0; i < oldEnd; ++i) {\n            for (Bucket curr = oldBuckets[i]; curr != null; curr = curr._next) {\n                ++symbolsSeen;\n                Name symbol = curr._name;\n                int hash = symbol.hashCode();\n                int ix = (hash & _mainHashMask);\n                int val = _mainHash[ix];\n                if (_mainNames[ix] == null) { // no primary entry?\n_mainHash[ix] = (ix[bucket] >>> 8);\n                    _mainNames[ix] = symbol;\n                } else { // nope, it's a collision, need to spill over\n                    ++_collCount;\n                    int bucket = val & 0xFF;\n                    if (bucket == 0) { // first spill over?\n                        if (_collEnd <= LAST_VALID_BUCKET) { // yup, still unshared bucket\n                            bucket = _collEnd;\n                            ++_collEnd;\n                            // need to expand?\n                            if (bucket >= _collList.length) {\n                                expandCollision();\n                            }\n                        } else { // nope, have to share... let's find shortest?\n                            bucket = findBestBucket();\n                        }\n                        // Need to mark the entry... and the spill index is 1-based\n                        _mainHash[ix] = (val & ~0xFF) | (bucket + 1);\n                    } else {\n                        --bucket; // 1-based index in value\n                    }\n                    // And then just need to link the new bucket entry in\n                    Bucket newB = new Bucket(symbol, _collList[bucket]);\n                    _collList[bucket] = newB;\n                    maxColl = Math.max(maxColl, newB.length());\n                }\n            } // for (... buckets in the chain ...)\n        } // for (... list of bucket heads ... )\n\n        _longestCollisionList = maxColl;\n        \n        if (symbolsSeen != _count) { // sanity check\n            throw new RuntimeException(\"Internal error: count after rehash \"+symbolsSeen+\"; should be \"+_count);\n        }\n    }",
          "30": "    private void rehash()\n    {\n        _needRehash = false;        \n        // Note: since we'll make copies, no need to unshare, can just mark as such:\n        _mainNamesShared = false;\n\n        /* And then we can first deal with the main hash area. Since we\n         * are expanding linearly (double up), we know there'll be no\n         * collisions during this phase.\n         */\n        int[] oldMainHash = _mainHash;\n        int len = oldMainHash.length;\n        int newLen = len+len;\n\n        /* 13-Mar-2010, tatu: Let's guard against OOME that could be caused by\n         *    large documents with unique (or mostly so) names\n         */\n        if (newLen > MAX_TABLE_SIZE) {\n            nukeSymbols();\n            return;\n        }\n        \n        _mainHash = new int[newLen];\n        _mainHashMask = (newLen - 1);\n        Name[] oldNames = _mainNames;\n        _mainNames = new Name[newLen];\n        int symbolsSeen = 0; // let's do a sanity check\n        for (int i = 0; i < len; ++i) {\n            Name symbol = oldNames[i];\n            if (symbol != null) {\n                ++symbolsSeen;\n                int hash = symbol.hashCode();\n                int ix = (hash & _mainHashMask);\n                _mainNames[ix] = symbol;\n                _mainHash[ix] = hash << 8; // will clear spill index\n            }\n        }\n\n        /* And then the spill area. This may cause collisions, although\n         * not necessarily as many as there were earlier. Let's allocate\n         * same amount of space, however\n         */\n        int oldEnd = _collEnd;\n        if (oldEnd == 0) { // no prior collisions...\n            _longestCollisionList = 0;\n            return;\n        }\n\n        _collCount = 0;\n        _collEnd = 0;\n        _collListShared = false;\n\n        int maxColl = 0;\n        \n        Bucket[] oldBuckets = _collList;\n        _collList = new Bucket[oldBuckets.length];\n        for (int i = 0; i < oldEnd; ++i) {\n            for (Bucket curr = oldBuckets[i]; curr != null; curr = curr._next) {\n                ++symbolsSeen;\n                Name symbol = curr._name;\n                int hash = symbol.hashCode();\n                int ix = (hash & _mainHashMask);\n                int val = _mainHash[ix];\n                if (_mainNames[ix] == null) { // no primary entry?\n_mainNames[ix] = symbol;\n                    _mainHash[ix] = (hash >>> 8);                    _mainNames[ix] = symbol;\n                } else { // nope, it's a collision, need to spill over\n                    ++_collCount;\n                    int bucket = val & 0xFF;\n                    if (bucket == 0) { // first spill over?\n                        if (_collEnd <= LAST_VALID_BUCKET) { // yup, still unshared bucket\n                            bucket = _collEnd;\n                            ++_collEnd;\n                            // need to expand?\n                            if (bucket >= _collList.length) {\n                                expandCollision();\n                            }\n                        } else { // nope, have to share... let's find shortest?\n                            bucket = findBestBucket();\n                        }\n                        // Need to mark the entry... and the spill index is 1-based\n                        _mainHash[ix] = (val & ~0xFF) | (bucket + 1);\n                    } else {\n                        --bucket; // 1-based index in value\n                    }\n                    // And then just need to link the new bucket entry in\n                    Bucket newB = new Bucket(symbol, _collList[bucket]);\n                    _collList[bucket] = newB;\n                    maxColl = Math.max(maxColl, newB.length());\n                }\n            } // for (... buckets in the chain ...)\n        } // for (... list of bucket heads ... )\n\n        _longestCollisionList = maxColl;\n        \n        if (symbolsSeen != _count) { // sanity check\n            throw new RuntimeException(\"Internal error: count after rehash \"+symbolsSeen+\"; should be \"+_count);\n        }\n    }",
          "31": "    private void rehash()\n    {\n        _needRehash = false;        \n        // Note: since we'll make copies, no need to unshare, can just mark as such:\n        _mainNamesShared = false;\n\n        /* And then we can first deal with the main hash area. Since we\n         * are expanding linearly (double up), we know there'll be no\n         * collisions during this phase.\n         */\n        int[] oldMainHash = _mainHash;\n        int len = oldMainHash.length;\n        int newLen = len+len;\n\n        /* 13-Mar-2010, tatu: Let's guard against OOME that could be caused by\n         *    large documents with unique (or mostly so) names\n         */\n        if (newLen > MAX_TABLE_SIZE) {\n            nukeSymbols();\n            return;\n        }\n        \n        _mainHash = new int[newLen];\n        _mainHashMask = (newLen - 1);\n        Name[] oldNames = _mainNames;\n        _mainNames = new Name[newLen];\n        int symbolsSeen = 0; // let's do a sanity check\n        for (int i = 0; i < len; ++i) {\n            Name symbol = oldNames[i];\n            if (symbol != null) {\n                ++symbolsSeen;\n                int hash = symbol.hashCode();\n                int ix = (hash & _mainHashMask);\n                _mainNames[ix] = symbol;\n                _mainHash[ix] = hash << 8; // will clear spill index\n            }\n        }\n\n        /* And then the spill area. This may cause collisions, although\n         * not necessarily as many as there were earlier. Let's allocate\n         * same amount of space, however\n         */\n        int oldEnd = _collEnd;\n        if (oldEnd == 0) { // no prior collisions...\n            _longestCollisionList = 0;\n            return;\n        }\n\n        _collCount = 0;\n        _collEnd = 0;\n        _collListShared = false;\n\n        int maxColl = 0;\n        \n        Bucket[] oldBuckets = _collList;\n        _collList = new Bucket[oldBuckets.length];\n        for (int i = 0; i < oldEnd; ++i) {\n            for (Bucket curr = oldBuckets[i]; curr != null; curr = curr._next) {\n                ++symbolsSeen;\n                Name symbol = curr._name;\n                int hash = symbol.hashCode();\n                int ix = (hash & _mainHashMask);\n                int val = _mainHash[ix];\n                if (_mainNames[ix] == null) { // no primary entry?\n_mainHash[ix] = (hash[ix] >>> 8);\n                    _mainNames[ix] = symbol;\n                } else { // nope, it's a collision, need to spill over\n                    ++_collCount;\n                    int bucket = val & 0xFF;\n                    if (bucket == 0) { // first spill over?\n                        if (_collEnd <= LAST_VALID_BUCKET) { // yup, still unshared bucket\n                            bucket = _collEnd;\n                            ++_collEnd;\n                            // need to expand?\n                            if (bucket >= _collList.length) {\n                                expandCollision();\n                            }\n                        } else { // nope, have to share... let's find shortest?\n                            bucket = findBestBucket();\n                        }\n                        // Need to mark the entry... and the spill index is 1-based\n                        _mainHash[ix] = (val & ~0xFF) | (bucket + 1);\n                    } else {\n                        --bucket; // 1-based index in value\n                    }\n                    // And then just need to link the new bucket entry in\n                    Bucket newB = new Bucket(symbol, _collList[bucket]);\n                    _collList[bucket] = newB;\n                    maxColl = Math.max(maxColl, newB.length());\n                }\n            } // for (... buckets in the chain ...)\n        } // for (... list of bucket heads ... )\n\n        _longestCollisionList = maxColl;\n        \n        if (symbolsSeen != _count) { // sanity check\n            throw new RuntimeException(\"Internal error: count after rehash \"+symbolsSeen+\"; should be \"+_count);\n        }\n    }",
          "32": "    private void rehash()\n    {\n        _needRehash = false;        \n        // Note: since we'll make copies, no need to unshare, can just mark as such:\n        _mainNamesShared = false;\n\n        /* And then we can first deal with the main hash area. Since we\n         * are expanding linearly (double up), we know there'll be no\n         * collisions during this phase.\n         */\n        int[] oldMainHash = _mainHash;\n        int len = oldMainHash.length;\n        int newLen = len+len;\n\n        /* 13-Mar-2010, tatu: Let's guard against OOME that could be caused by\n         *    large documents with unique (or mostly so) names\n         */\n        if (newLen > MAX_TABLE_SIZE) {\n            nukeSymbols();\n            return;\n        }\n        \n        _mainHash = new int[newLen];\n        _mainHashMask = (newLen - 1);\n        Name[] oldNames = _mainNames;\n        _mainNames = new Name[newLen];\n        int symbolsSeen = 0; // let's do a sanity check\n        for (int i = 0; i < len; ++i) {\n            Name symbol = oldNames[i];\n            if (symbol != null) {\n                ++symbolsSeen;\n                int hash = symbol.hashCode();\n                int ix = (hash & _mainHashMask);\n                _mainNames[ix] = symbol;\n                _mainHash[ix] = hash << 8; // will clear spill index\n            }\n        }\n\n        /* And then the spill area. This may cause collisions, although\n         * not necessarily as many as there were earlier. Let's allocate\n         * same amount of space, however\n         */\n        int oldEnd = _collEnd;\n        if (oldEnd == 0) { // no prior collisions...\n            _longestCollisionList = 0;\n            return;\n        }\n\n        _collCount = 0;\n        _collEnd = 0;\n        _collListShared = false;\n\n        int maxColl = 0;\n        \n        Bucket[] oldBuckets = _collList;\n        _collList = new Bucket[oldBuckets.length];\n        for (int i = 0; i < oldEnd; ++i) {\n            for (Bucket curr = oldBuckets[i]; curr != null; curr = curr._next) {\n                ++symbolsSeen;\n                Name symbol = curr._name;\n                int hash = symbol.hashCode();\n                int ix = (hash & _mainHashMask);\n                int val = _mainHash[ix];\n                if (_mainNames[ix] == null) { // no primary entry?\n_mainHash[ix] = (hash[bucket] >>> 8);\n                    _mainNames[ix] = symbol;\n                } else { // nope, it's a collision, need to spill over\n                    ++_collCount;\n                    int bucket = val & 0xFF;\n                    if (bucket == 0) { // first spill over?\n                        if (_collEnd <= LAST_VALID_BUCKET) { // yup, still unshared bucket\n                            bucket = _collEnd;\n                            ++_collEnd;\n                            // need to expand?\n                            if (bucket >= _collList.length) {\n                                expandCollision();\n                            }\n                        } else { // nope, have to share... let's find shortest?\n                            bucket = findBestBucket();\n                        }\n                        // Need to mark the entry... and the spill index is 1-based\n                        _mainHash[ix] = (val & ~0xFF) | (bucket + 1);\n                    } else {\n                        --bucket; // 1-based index in value\n                    }\n                    // And then just need to link the new bucket entry in\n                    Bucket newB = new Bucket(symbol, _collList[bucket]);\n                    _collList[bucket] = newB;\n                    maxColl = Math.max(maxColl, newB.length());\n                }\n            } // for (... buckets in the chain ...)\n        } // for (... list of bucket heads ... )\n\n        _longestCollisionList = maxColl;\n        \n        if (symbolsSeen != _count) { // sanity check\n            throw new RuntimeException(\"Internal error: count after rehash \"+symbolsSeen+\"; should be \"+_count);\n        }\n    }",
          "33": "    private void rehash()\n    {\n        _needRehash = false;        \n        // Note: since we'll make copies, no need to unshare, can just mark as such:\n        _mainNamesShared = false;\n\n        /* And then we can first deal with the main hash area. Since we\n         * are expanding linearly (double up), we know there'll be no\n         * collisions during this phase.\n         */\n        int[] oldMainHash = _mainHash;\n        int len = oldMainHash.length;\n        int newLen = len+len;\n\n        /* 13-Mar-2010, tatu: Let's guard against OOME that could be caused by\n         *    large documents with unique (or mostly so) names\n         */\n        if (newLen > MAX_TABLE_SIZE) {\n            nukeSymbols();\n            return;\n        }\n        \n        _mainHash = new int[newLen];\n        _mainHashMask = (newLen - 1);\n        Name[] oldNames = _mainNames;\n        _mainNames = new Name[newLen];\n        int symbolsSeen = 0; // let's do a sanity check\n        for (int i = 0; i < len; ++i) {\n            Name symbol = oldNames[i];\n            if (symbol != null) {\n                ++symbolsSeen;\n                int hash = symbol.hashCode();\n                int ix = (hash & _mainHashMask);\n                _mainNames[ix] = symbol;\n                _mainHash[ix] = hash << 8; // will clear spill index\n            }\n        }\n\n        /* And then the spill area. This may cause collisions, although\n         * not necessarily as many as there were earlier. Let's allocate\n         * same amount of space, however\n         */\n        int oldEnd = _collEnd;\n        if (oldEnd == 0) { // no prior collisions...\n            _longestCollisionList = 0;\n            return;\n        }\n\n        _collCount = 0;\n        _collEnd = 0;\n        _collListShared = false;\n\n        int maxColl = 0;\n        \n        Bucket[] oldBuckets = _collList;\n        _collList = new Bucket[oldBuckets.length];\n        for (int i = 0; i < oldEnd; ++i) {\n            for (Bucket curr = oldBuckets[i]; curr != null; curr = curr._next) {\n                ++symbolsSeen;\n                Name symbol = curr._name;\n                int hash = symbol.hashCode();\n                int ix = (hash & _mainHashMask);\n                int val = _mainHash[ix];\n                if (_mainNames[ix] == null) { // no primary entry?\nbucket = _collEnd;\n                    _mainHash[ix] = (hash >>> 8);                    _mainNames[ix] = symbol;\n                } else { // nope, it's a collision, need to spill over\n                    ++_collCount;\n                    int bucket = val & 0xFF;\n                    if (bucket == 0) { // first spill over?\n                        if (_collEnd <= LAST_VALID_BUCKET) { // yup, still unshared bucket\n                            bucket = _collEnd;\n                            ++_collEnd;\n                            // need to expand?\n                            if (bucket >= _collList.length) {\n                                expandCollision();\n                            }\n                        } else { // nope, have to share... let's find shortest?\n                            bucket = findBestBucket();\n                        }\n                        // Need to mark the entry... and the spill index is 1-based\n                        _mainHash[ix] = (val & ~0xFF) | (bucket + 1);\n                    } else {\n                        --bucket; // 1-based index in value\n                    }\n                    // And then just need to link the new bucket entry in\n                    Bucket newB = new Bucket(symbol, _collList[bucket]);\n                    _collList[bucket] = newB;\n                    maxColl = Math.max(maxColl, newB.length());\n                }\n            } // for (... buckets in the chain ...)\n        } // for (... list of bucket heads ... )\n\n        _longestCollisionList = maxColl;\n        \n        if (symbolsSeen != _count) { // sanity check\n            throw new RuntimeException(\"Internal error: count after rehash \"+symbolsSeen+\"; should be \"+_count);\n        }\n    }",
          "34": "    private void rehash()\n    {\n        _needRehash = false;        \n        // Note: since we'll make copies, no need to unshare, can just mark as such:\n        _mainNamesShared = false;\n\n        /* And then we can first deal with the main hash area. Since we\n         * are expanding linearly (double up), we know there'll be no\n         * collisions during this phase.\n         */\n        int[] oldMainHash = _mainHash;\n        int len = oldMainHash.length;\n        int newLen = len+len;\n\n        /* 13-Mar-2010, tatu: Let's guard against OOME that could be caused by\n         *    large documents with unique (or mostly so) names\n         */\n        if (newLen > MAX_TABLE_SIZE) {\n            nukeSymbols();\n            return;\n        }\n        \n        _mainHash = new int[newLen];\n        _mainHashMask = (newLen - 1);\n        Name[] oldNames = _mainNames;\n        _mainNames = new Name[newLen];\n        int symbolsSeen = 0; // let's do a sanity check\n        for (int i = 0; i < len; ++i) {\n            Name symbol = oldNames[i];\n            if (symbol != null) {\n                ++symbolsSeen;\n                int hash = symbol.hashCode();\n                int ix = (hash & _mainHashMask);\n                _mainNames[ix] = symbol;\n                _mainHash[ix] = hash << 8; // will clear spill index\n            }\n        }\n\n        /* And then the spill area. This may cause collisions, although\n         * not necessarily as many as there were earlier. Let's allocate\n         * same amount of space, however\n         */\n        int oldEnd = _collEnd;\n        if (oldEnd == 0) { // no prior collisions...\n            _longestCollisionList = 0;\n            return;\n        }\n\n        _collCount = 0;\n        _collEnd = 0;\n        _collListShared = false;\n\n        int maxColl = 0;\n        \n        Bucket[] oldBuckets = _collList;\n        _collList = new Bucket[oldBuckets.length];\n        for (int i = 0; i < oldEnd; ++i) {\n            for (Bucket curr = oldBuckets[i]; curr != null; curr = curr._next) {\n                ++symbolsSeen;\n                Name symbol = curr._name;\n                int hash = symbol.hashCode();\n                int ix = (hash & _mainHashMask);\n                int val = _mainHash[ix];\n                if (_mainNames[ix] == null) { // no primary entry?\n_mainHash[ix] = (hash * 8);\n                    _mainNames[ix] = symbol;\n                } else { // nope, it's a collision, need to spill over\n                    ++_collCount;\n                    int bucket = val & 0xFF;\n                    if (bucket == 0) { // first spill over?\n                        if (_collEnd <= LAST_VALID_BUCKET) { // yup, still unshared bucket\n                            bucket = _collEnd;\n                            ++_collEnd;\n                            // need to expand?\n                            if (bucket >= _collList.length) {\n                                expandCollision();\n                            }\n                        } else { // nope, have to share... let's find shortest?\n                            bucket = findBestBucket();\n                        }\n                        // Need to mark the entry... and the spill index is 1-based\n                        _mainHash[ix] = (val & ~0xFF) | (bucket + 1);\n                    } else {\n                        --bucket; // 1-based index in value\n                    }\n                    // And then just need to link the new bucket entry in\n                    Bucket newB = new Bucket(symbol, _collList[bucket]);\n                    _collList[bucket] = newB;\n                    maxColl = Math.max(maxColl, newB.length());\n                }\n            } // for (... buckets in the chain ...)\n        } // for (... list of bucket heads ... )\n\n        _longestCollisionList = maxColl;\n        \n        if (symbolsSeen != _count) { // sanity check\n            throw new RuntimeException(\"Internal error: count after rehash \"+symbolsSeen+\"; should be \"+_count);\n        }\n    }",
          "35": "    private void rehash()\n    {\n        _needRehash = false;        \n        // Note: since we'll make copies, no need to unshare, can just mark as such:\n        _mainNamesShared = false;\n\n        /* And then we can first deal with the main hash area. Since we\n         * are expanding linearly (double up), we know there'll be no\n         * collisions during this phase.\n         */\n        int[] oldMainHash = _mainHash;\n        int len = oldMainHash.length;\n        int newLen = len+len;\n\n        /* 13-Mar-2010, tatu: Let's guard against OOME that could be caused by\n         *    large documents with unique (or mostly so) names\n         */\n        if (newLen > MAX_TABLE_SIZE) {\n            nukeSymbols();\n            return;\n        }\n        \n        _mainHash = new int[newLen];\n        _mainHashMask = (newLen - 1);\n        Name[] oldNames = _mainNames;\n        _mainNames = new Name[newLen];\n        int symbolsSeen = 0; // let's do a sanity check\n        for (int i = 0; i < len; ++i) {\n            Name symbol = oldNames[i];\n            if (symbol != null) {\n                ++symbolsSeen;\n                int hash = symbol.hashCode();\n                int ix = (hash & _mainHashMask);\n                _mainNames[ix] = symbol;\n                _mainHash[ix] = hash << 8; // will clear spill index\n            }\n        }\n\n        /* And then the spill area. This may cause collisions, although\n         * not necessarily as many as there were earlier. Let's allocate\n         * same amount of space, however\n         */\n        int oldEnd = _collEnd;\n        if (oldEnd == 0) { // no prior collisions...\n            _longestCollisionList = 0;\n            return;\n        }\n\n        _collCount = 0;\n        _collEnd = 0;\n        _collListShared = false;\n\n        int maxColl = 0;\n        \n        Bucket[] oldBuckets = _collList;\n        _collList = new Bucket[oldBuckets.length];\n        for (int i = 0; i < oldEnd; ++i) {\n            for (Bucket curr = oldBuckets[i]; curr != null; curr = curr._next) {\n                ++symbolsSeen;\n                Name symbol = curr._name;\n                int hash = symbol.hashCode();\n                int ix = (hash & _mainHashMask);\n                int val = _mainHash[ix];\n                if (_mainNames[ix] == null) { // no primary entry?\n_mainHash[ix] = ((val & ~0xFF) | (bucket + 1));\n                    _mainHash[ix] = (hash >>> 8);                    _mainNames[ix] = symbol;\n                } else { // nope, it's a collision, need to spill over\n                    ++_collCount;\n                    int bucket = val & 0xFF;\n                    if (bucket == 0) { // first spill over?\n                        if (_collEnd <= LAST_VALID_BUCKET) { // yup, still unshared bucket\n                            bucket = _collEnd;\n                            ++_collEnd;\n                            // need to expand?\n                            if (bucket >= _collList.length) {\n                                expandCollision();\n                            }\n                        } else { // nope, have to share... let's find shortest?\n                            bucket = findBestBucket();\n                        }\n                        // Need to mark the entry... and the spill index is 1-based\n                        _mainHash[ix] = (val & ~0xFF) | (bucket + 1);\n                    } else {\n                        --bucket; // 1-based index in value\n                    }\n                    // And then just need to link the new bucket entry in\n                    Bucket newB = new Bucket(symbol, _collList[bucket]);\n                    _collList[bucket] = newB;\n                    maxColl = Math.max(maxColl, newB.length());\n                }\n            } // for (... buckets in the chain ...)\n        } // for (... list of bucket heads ... )\n\n        _longestCollisionList = maxColl;\n        \n        if (symbolsSeen != _count) { // sanity check\n            throw new RuntimeException(\"Internal error: count after rehash \"+symbolsSeen+\"; should be \"+_count);\n        }\n    }",
          "36": "    private void rehash()\n    {\n        _needRehash = false;        \n        // Note: since we'll make copies, no need to unshare, can just mark as such:\n        _mainNamesShared = false;\n\n        /* And then we can first deal with the main hash area. Since we\n         * are expanding linearly (double up), we know there'll be no\n         * collisions during this phase.\n         */\n        int[] oldMainHash = _mainHash;\n        int len = oldMainHash.length;\n        int newLen = len+len;\n\n        /* 13-Mar-2010, tatu: Let's guard against OOME that could be caused by\n         *    large documents with unique (or mostly so) names\n         */\n        if (newLen > MAX_TABLE_SIZE) {\n            nukeSymbols();\n            return;\n        }\n        \n        _mainHash = new int[newLen];\n        _mainHashMask = (newLen - 1);\n        Name[] oldNames = _mainNames;\n        _mainNames = new Name[newLen];\n        int symbolsSeen = 0; // let's do a sanity check\n        for (int i = 0; i < len; ++i) {\n            Name symbol = oldNames[i];\n            if (symbol != null) {\n                ++symbolsSeen;\n                int hash = symbol.hashCode();\n                int ix = (hash & _mainHashMask);\n                _mainNames[ix] = symbol;\n                _mainHash[ix] = hash << 8; // will clear spill index\n            }\n        }\n\n        /* And then the spill area. This may cause collisions, although\n         * not necessarily as many as there were earlier. Let's allocate\n         * same amount of space, however\n         */\n        int oldEnd = _collEnd;\n        if (oldEnd == 0) { // no prior collisions...\n            _longestCollisionList = 0;\n            return;\n        }\n\n        _collCount = 0;\n        _collEnd = 0;\n        _collListShared = false;\n\n        int maxColl = 0;\n        \n        Bucket[] oldBuckets = _collList;\n        _collList = new Bucket[oldBuckets.length];\n        for (int i = 0; i < oldEnd; ++i) {\n            for (Bucket curr = oldBuckets[i]; curr != null; curr = curr._next) {\n                ++symbolsSeen;\n                Name symbol = curr._name;\n                int hash = symbol.hashCode();\n                int ix = (hash & _mainHashMask);\n                int val = _mainHash[ix];\n                if (_mainNames[ix] == null) { // no primary entry?\nreturn;\n                    _mainHash[ix] = (hash >>> 8);                    _mainNames[ix] = symbol;\n                } else { // nope, it's a collision, need to spill over\n                    ++_collCount;\n                    int bucket = val & 0xFF;\n                    if (bucket == 0) { // first spill over?\n                        if (_collEnd <= LAST_VALID_BUCKET) { // yup, still unshared bucket\n                            bucket = _collEnd;\n                            ++_collEnd;\n                            // need to expand?\n                            if (bucket >= _collList.length) {\n                                expandCollision();\n                            }\n                        } else { // nope, have to share... let's find shortest?\n                            bucket = findBestBucket();\n                        }\n                        // Need to mark the entry... and the spill index is 1-based\n                        _mainHash[ix] = (val & ~0xFF) | (bucket + 1);\n                    } else {\n                        --bucket; // 1-based index in value\n                    }\n                    // And then just need to link the new bucket entry in\n                    Bucket newB = new Bucket(symbol, _collList[bucket]);\n                    _collList[bucket] = newB;\n                    maxColl = Math.max(maxColl, newB.length());\n                }\n            } // for (... buckets in the chain ...)\n        } // for (... list of bucket heads ... )\n\n        _longestCollisionList = maxColl;\n        \n        if (symbolsSeen != _count) { // sanity check\n            throw new RuntimeException(\"Internal error: count after rehash \"+symbolsSeen+\"; should be \"+_count);\n        }\n    }",
          "37": "    private void rehash()\n    {\n        _needRehash = false;        \n        // Note: since we'll make copies, no need to unshare, can just mark as such:\n        _mainNamesShared = false;\n\n        /* And then we can first deal with the main hash area. Since we\n         * are expanding linearly (double up), we know there'll be no\n         * collisions during this phase.\n         */\n        int[] oldMainHash = _mainHash;\n        int len = oldMainHash.length;\n        int newLen = len+len;\n\n        /* 13-Mar-2010, tatu: Let's guard against OOME that could be caused by\n         *    large documents with unique (or mostly so) names\n         */\n        if (newLen > MAX_TABLE_SIZE) {\n            nukeSymbols();\n            return;\n        }\n        \n        _mainHash = new int[newLen];\n        _mainHashMask = (newLen - 1);\n        Name[] oldNames = _mainNames;\n        _mainNames = new Name[newLen];\n        int symbolsSeen = 0; // let's do a sanity check\n        for (int i = 0; i < len; ++i) {\n            Name symbol = oldNames[i];\n            if (symbol != null) {\n                ++symbolsSeen;\n                int hash = symbol.hashCode();\n                int ix = (hash & _mainHashMask);\n                _mainNames[ix] = symbol;\n                _mainHash[ix] = hash << 8; // will clear spill index\n            }\n        }\n\n        /* And then the spill area. This may cause collisions, although\n         * not necessarily as many as there were earlier. Let's allocate\n         * same amount of space, however\n         */\n        int oldEnd = _collEnd;\n        if (oldEnd == 0) { // no prior collisions...\n            _longestCollisionList = 0;\n            return;\n        }\n\n        _collCount = 0;\n        _collEnd = 0;\n        _collListShared = false;\n\n        int maxColl = 0;\n        \n        Bucket[] oldBuckets = _collList;\n        _collList = new Bucket[oldBuckets.length];\n        for (int i = 0; i < oldEnd; ++i) {\n            for (Bucket curr = oldBuckets[i]; curr != null; curr = curr._next) {\n                ++symbolsSeen;\n                Name symbol = curr._name;\n                int hash = symbol.hashCode();\n                int ix = (hash & _mainHashMask);\n                int val = _mainHash[ix];\n                if (_mainNames[ix] == null) { // no primary entry?\n_mainHash[ix] = (hash >= 8);\n                    _mainNames[ix] = symbol;\n                } else { // nope, it's a collision, need to spill over\n                    ++_collCount;\n                    int bucket = val & 0xFF;\n                    if (bucket == 0) { // first spill over?\n                        if (_collEnd <= LAST_VALID_BUCKET) { // yup, still unshared bucket\n                            bucket = _collEnd;\n                            ++_collEnd;\n                            // need to expand?\n                            if (bucket >= _collList.length) {\n                                expandCollision();\n                            }\n                        } else { // nope, have to share... let's find shortest?\n                            bucket = findBestBucket();\n                        }\n                        // Need to mark the entry... and the spill index is 1-based\n                        _mainHash[ix] = (val & ~0xFF) | (bucket + 1);\n                    } else {\n                        --bucket; // 1-based index in value\n                    }\n                    // And then just need to link the new bucket entry in\n                    Bucket newB = new Bucket(symbol, _collList[bucket]);\n                    _collList[bucket] = newB;\n                    maxColl = Math.max(maxColl, newB.length());\n                }\n            } // for (... buckets in the chain ...)\n        } // for (... list of bucket heads ... )\n\n        _longestCollisionList = maxColl;\n        \n        if (symbolsSeen != _count) { // sanity check\n            throw new RuntimeException(\"Internal error: count after rehash \"+symbolsSeen+\"; should be \"+_count);\n        }\n    }",
          "38": "    private void rehash()\n    {\n        _needRehash = false;        \n        // Note: since we'll make copies, no need to unshare, can just mark as such:\n        _mainNamesShared = false;\n\n        /* And then we can first deal with the main hash area. Since we\n         * are expanding linearly (double up), we know there'll be no\n         * collisions during this phase.\n         */\n        int[] oldMainHash = _mainHash;\n        int len = oldMainHash.length;\n        int newLen = len+len;\n\n        /* 13-Mar-2010, tatu: Let's guard against OOME that could be caused by\n         *    large documents with unique (or mostly so) names\n         */\n        if (newLen > MAX_TABLE_SIZE) {\n            nukeSymbols();\n            return;\n        }\n        \n        _mainHash = new int[newLen];\n        _mainHashMask = (newLen - 1);\n        Name[] oldNames = _mainNames;\n        _mainNames = new Name[newLen];\n        int symbolsSeen = 0; // let's do a sanity check\n        for (int i = 0; i < len; ++i) {\n            Name symbol = oldNames[i];\n            if (symbol != null) {\n                ++symbolsSeen;\n                int hash = symbol.hashCode();\n                int ix = (hash & _mainHashMask);\n                _mainNames[ix] = symbol;\n                _mainHash[ix] = hash << 8; // will clear spill index\n            }\n        }\n\n        /* And then the spill area. This may cause collisions, although\n         * not necessarily as many as there were earlier. Let's allocate\n         * same amount of space, however\n         */\n        int oldEnd = _collEnd;\n        if (oldEnd == 0) { // no prior collisions...\n            _longestCollisionList = 0;\n            return;\n        }\n\n        _collCount = 0;\n        _collEnd = 0;\n        _collListShared = false;\n\n        int maxColl = 0;\n        \n        Bucket[] oldBuckets = _collList;\n        _collList = new Bucket[oldBuckets.length];\n        for (int i = 0; i < oldEnd; ++i) {\n            for (Bucket curr = oldBuckets[i]; curr != null; curr = curr._next) {\n                ++symbolsSeen;\n                Name symbol = curr._name;\n                int hash = symbol.hashCode();\n                int ix = (hash & _mainHashMask);\n                int val = _mainHash[ix];\n                if (_mainNames[ix] == null) { // no primary entry?\n_mainHash[ix] = (val >>> 8);\n                    _mainNames[ix] = symbol;\n                } else { // nope, it's a collision, need to spill over\n                    ++_collCount;\n                    int bucket = val & 0xFF;\n                    if (bucket == 0) { // first spill over?\n                        if (_collEnd <= LAST_VALID_BUCKET) { // yup, still unshared bucket\n                            bucket = _collEnd;\n                            ++_collEnd;\n                            // need to expand?\n                            if (bucket >= _collList.length) {\n                                expandCollision();\n                            }\n                        } else { // nope, have to share... let's find shortest?\n                            bucket = findBestBucket();\n                        }\n                        // Need to mark the entry... and the spill index is 1-based\n                        _mainHash[ix] = (val & ~0xFF) | (bucket + 1);\n                    } else {\n                        --bucket; // 1-based index in value\n                    }\n                    // And then just need to link the new bucket entry in\n                    Bucket newB = new Bucket(symbol, _collList[bucket]);\n                    _collList[bucket] = newB;\n                    maxColl = Math.max(maxColl, newB.length());\n                }\n            } // for (... buckets in the chain ...)\n        } // for (... list of bucket heads ... )\n\n        _longestCollisionList = maxColl;\n        \n        if (symbolsSeen != _count) { // sanity check\n            throw new RuntimeException(\"Internal error: count after rehash \"+symbolsSeen+\"; should be \"+_count);\n        }\n    }",
          "39": "    private void rehash()\n    {\n        _needRehash = false;        \n        // Note: since we'll make copies, no need to unshare, can just mark as such:\n        _mainNamesShared = false;\n\n        /* And then we can first deal with the main hash area. Since we\n         * are expanding linearly (double up), we know there'll be no\n         * collisions during this phase.\n         */\n        int[] oldMainHash = _mainHash;\n        int len = oldMainHash.length;\n        int newLen = len+len;\n\n        /* 13-Mar-2010, tatu: Let's guard against OOME that could be caused by\n         *    large documents with unique (or mostly so) names\n         */\n        if (newLen > MAX_TABLE_SIZE) {\n            nukeSymbols();\n            return;\n        }\n        \n        _mainHash = new int[newLen];\n        _mainHashMask = (newLen - 1);\n        Name[] oldNames = _mainNames;\n        _mainNames = new Name[newLen];\n        int symbolsSeen = 0; // let's do a sanity check\n        for (int i = 0; i < len; ++i) {\n            Name symbol = oldNames[i];\n            if (symbol != null) {\n                ++symbolsSeen;\n                int hash = symbol.hashCode();\n                int ix = (hash & _mainHashMask);\n                _mainNames[ix] = symbol;\n                _mainHash[ix] = hash << 8; // will clear spill index\n            }\n        }\n\n        /* And then the spill area. This may cause collisions, although\n         * not necessarily as many as there were earlier. Let's allocate\n         * same amount of space, however\n         */\n        int oldEnd = _collEnd;\n        if (oldEnd == 0) { // no prior collisions...\n            _longestCollisionList = 0;\n            return;\n        }\n\n        _collCount = 0;\n        _collEnd = 0;\n        _collListShared = false;\n\n        int maxColl = 0;\n        \n        Bucket[] oldBuckets = _collList;\n        _collList = new Bucket[oldBuckets.length];\n        for (int i = 0; i < oldEnd; ++i) {\n            for (Bucket curr = oldBuckets[i]; curr != null; curr = curr._next) {\n                ++symbolsSeen;\n                Name symbol = curr._name;\n                int hash = symbol.hashCode();\n                int ix = (hash & _mainHashMask);\n                int val = _mainHash[ix];\n                if (_mainNames[ix] == null) { // no primary entry?\n_collList[bucket] = (hash >>> 8);\n                    _mainNames[ix] = symbol;\n                } else { // nope, it's a collision, need to spill over\n                    ++_collCount;\n                    int bucket = val & 0xFF;\n                    if (bucket == 0) { // first spill over?\n                        if (_collEnd <= LAST_VALID_BUCKET) { // yup, still unshared bucket\n                            bucket = _collEnd;\n                            ++_collEnd;\n                            // need to expand?\n                            if (bucket >= _collList.length) {\n                                expandCollision();\n                            }\n                        } else { // nope, have to share... let's find shortest?\n                            bucket = findBestBucket();\n                        }\n                        // Need to mark the entry... and the spill index is 1-based\n                        _mainHash[ix] = (val & ~0xFF) | (bucket + 1);\n                    } else {\n                        --bucket; // 1-based index in value\n                    }\n                    // And then just need to link the new bucket entry in\n                    Bucket newB = new Bucket(symbol, _collList[bucket]);\n                    _collList[bucket] = newB;\n                    maxColl = Math.max(maxColl, newB.length());\n                }\n            } // for (... buckets in the chain ...)\n        } // for (... list of bucket heads ... )\n\n        _longestCollisionList = maxColl;\n        \n        if (symbolsSeen != _count) { // sanity check\n            throw new RuntimeException(\"Internal error: count after rehash \"+symbolsSeen+\"; should be \"+_count);\n        }\n    }",
          "40": "    private void rehash()\n    {\n        _needRehash = false;        \n        // Note: since we'll make copies, no need to unshare, can just mark as such:\n        _mainNamesShared = false;\n\n        /* And then we can first deal with the main hash area. Since we\n         * are expanding linearly (double up), we know there'll be no\n         * collisions during this phase.\n         */\n        int[] oldMainHash = _mainHash;\n        int len = oldMainHash.length;\n        int newLen = len+len;\n\n        /* 13-Mar-2010, tatu: Let's guard against OOME that could be caused by\n         *    large documents with unique (or mostly so) names\n         */\n        if (newLen > MAX_TABLE_SIZE) {\n            nukeSymbols();\n            return;\n        }\n        \n        _mainHash = new int[newLen];\n        _mainHashMask = (newLen - 1);\n        Name[] oldNames = _mainNames;\n        _mainNames = new Name[newLen];\n        int symbolsSeen = 0; // let's do a sanity check\n        for (int i = 0; i < len; ++i) {\n            Name symbol = oldNames[i];\n            if (symbol != null) {\n                ++symbolsSeen;\n                int hash = symbol.hashCode();\n                int ix = (hash & _mainHashMask);\n                _mainNames[ix] = symbol;\n                _mainHash[ix] = hash << 8; // will clear spill index\n            }\n        }\n\n        /* And then the spill area. This may cause collisions, although\n         * not necessarily as many as there were earlier. Let's allocate\n         * same amount of space, however\n         */\n        int oldEnd = _collEnd;\n        if (oldEnd == 0) { // no prior collisions...\n            _longestCollisionList = 0;\n            return;\n        }\n\n        _collCount = 0;\n        _collEnd = 0;\n        _collListShared = false;\n\n        int maxColl = 0;\n        \n        Bucket[] oldBuckets = _collList;\n        _collList = new Bucket[oldBuckets.length];\n        for (int i = 0; i < oldEnd; ++i) {\n            for (Bucket curr = oldBuckets[i]; curr != null; curr = curr._next) {\n                ++symbolsSeen;\n                Name symbol = curr._name;\n                int hash = symbol.hashCode();\n                int ix = (hash & _mainHashMask);\n                int val = _mainHash[ix];\n                if (_mainNames[ix] == null) { // no primary entry?\n_mainHash[ix] = (ix[ix] >>> 8);\n                    _mainNames[ix] = symbol;\n                } else { // nope, it's a collision, need to spill over\n                    ++_collCount;\n                    int bucket = val & 0xFF;\n                    if (bucket == 0) { // first spill over?\n                        if (_collEnd <= LAST_VALID_BUCKET) { // yup, still unshared bucket\n                            bucket = _collEnd;\n                            ++_collEnd;\n                            // need to expand?\n                            if (bucket >= _collList.length) {\n                                expandCollision();\n                            }\n                        } else { // nope, have to share... let's find shortest?\n                            bucket = findBestBucket();\n                        }\n                        // Need to mark the entry... and the spill index is 1-based\n                        _mainHash[ix] = (val & ~0xFF) | (bucket + 1);\n                    } else {\n                        --bucket; // 1-based index in value\n                    }\n                    // And then just need to link the new bucket entry in\n                    Bucket newB = new Bucket(symbol, _collList[bucket]);\n                    _collList[bucket] = newB;\n                    maxColl = Math.max(maxColl, newB.length());\n                }\n            } // for (... buckets in the chain ...)\n        } // for (... list of bucket heads ... )\n\n        _longestCollisionList = maxColl;\n        \n        if (symbolsSeen != _count) { // sanity check\n            throw new RuntimeException(\"Internal error: count after rehash \"+symbolsSeen+\"; should be \"+_count);\n        }\n    }",
          "41": "    private void rehash()\n    {\n        _needRehash = false;        \n        // Note: since we'll make copies, no need to unshare, can just mark as such:\n        _mainNamesShared = false;\n\n        /* And then we can first deal with the main hash area. Since we\n         * are expanding linearly (double up), we know there'll be no\n         * collisions during this phase.\n         */\n        int[] oldMainHash = _mainHash;\n        int len = oldMainHash.length;\n        int newLen = len+len;\n\n        /* 13-Mar-2010, tatu: Let's guard against OOME that could be caused by\n         *    large documents with unique (or mostly so) names\n         */\n        if (newLen > MAX_TABLE_SIZE) {\n            nukeSymbols();\n            return;\n        }\n        \n        _mainHash = new int[newLen];\n        _mainHashMask = (newLen - 1);\n        Name[] oldNames = _mainNames;\n        _mainNames = new Name[newLen];\n        int symbolsSeen = 0; // let's do a sanity check\n        for (int i = 0; i < len; ++i) {\n            Name symbol = oldNames[i];\n            if (symbol != null) {\n                ++symbolsSeen;\n                int hash = symbol.hashCode();\n                int ix = (hash & _mainHashMask);\n                _mainNames[ix] = symbol;\n                _mainHash[ix] = hash << 8; // will clear spill index\n            }\n        }\n\n        /* And then the spill area. This may cause collisions, although\n         * not necessarily as many as there were earlier. Let's allocate\n         * same amount of space, however\n         */\n        int oldEnd = _collEnd;\n        if (oldEnd == 0) { // no prior collisions...\n            _longestCollisionList = 0;\n            return;\n        }\n\n        _collCount = 0;\n        _collEnd = 0;\n        _collListShared = false;\n\n        int maxColl = 0;\n        \n        Bucket[] oldBuckets = _collList;\n        _collList = new Bucket[oldBuckets.length];\n        for (int i = 0; i < oldEnd; ++i) {\n            for (Bucket curr = oldBuckets[i]; curr != null; curr = curr._next) {\n                ++symbolsSeen;\n                Name symbol = curr._name;\n                int hash = symbol.hashCode();\n                int ix = (hash & _mainHashMask);\n                int val = _mainHash[ix];\n                if (_mainNames[ix] == null) { // no primary entry?\nif((_mainNames[ix] == null)){\n                    _mainHash[ix] = (hash >>> 8);                    _mainNames[ix] = symbol;\n                } else { // nope, it's a collision, need to spill over\n                    ++_collCount;\n                    int bucket = val & 0xFF;\n                    if (bucket == 0) { // first spill over?\n                        if (_collEnd <= LAST_VALID_BUCKET) { // yup, still unshared bucket\n                            bucket = _collEnd;\n                            ++_collEnd;\n                            // need to expand?\n                            if (bucket >= _collList.length) {\n                                expandCollision();\n                            }\n                        } else { // nope, have to share... let's find shortest?\n                            bucket = findBestBucket();\n                        }\n                        // Need to mark the entry... and the spill index is 1-based\n                        _mainHash[ix] = (val & ~0xFF) | (bucket + 1);\n                    } else {\n                        --bucket; // 1-based index in value\n                    }\n                    // And then just need to link the new bucket entry in\n                    Bucket newB = new Bucket(symbol, _collList[bucket]);\n                    _collList[bucket] = newB;\n                    maxColl = Math.max(maxColl, newB.length());\n}\n                }\n            } // for (... buckets in the chain ...)\n        } // for (... list of bucket heads ... )\n\n        _longestCollisionList = maxColl;\n        \n        if (symbolsSeen != _count) { // sanity check\n            throw new RuntimeException(\"Internal error: count after rehash \"+symbolsSeen+\"; should be \"+_count);\n        }\n    }",
          "42": "    private void rehash()\n    {\n        _needRehash = false;        \n        // Note: since we'll make copies, no need to unshare, can just mark as such:\n        _mainNamesShared = false;\n\n        /* And then we can first deal with the main hash area. Since we\n         * are expanding linearly (double up), we know there'll be no\n         * collisions during this phase.\n         */\n        int[] oldMainHash = _mainHash;\n        int len = oldMainHash.length;\n        int newLen = len+len;\n\n        /* 13-Mar-2010, tatu: Let's guard against OOME that could be caused by\n         *    large documents with unique (or mostly so) names\n         */\n        if (newLen > MAX_TABLE_SIZE) {\n            nukeSymbols();\n            return;\n        }\n        \n        _mainHash = new int[newLen];\n        _mainHashMask = (newLen - 1);\n        Name[] oldNames = _mainNames;\n        _mainNames = new Name[newLen];\n        int symbolsSeen = 0; // let's do a sanity check\n        for (int i = 0; i < len; ++i) {\n            Name symbol = oldNames[i];\n            if (symbol != null) {\n                ++symbolsSeen;\n                int hash = symbol.hashCode();\n                int ix = (hash & _mainHashMask);\n                _mainNames[ix] = symbol;\n                _mainHash[ix] = hash << 8; // will clear spill index\n            }\n        }\n\n        /* And then the spill area. This may cause collisions, although\n         * not necessarily as many as there were earlier. Let's allocate\n         * same amount of space, however\n         */\n        int oldEnd = _collEnd;\n        if (oldEnd == 0) { // no prior collisions...\n            _longestCollisionList = 0;\n            return;\n        }\n\n        _collCount = 0;\n        _collEnd = 0;\n        _collListShared = false;\n\n        int maxColl = 0;\n        \n        Bucket[] oldBuckets = _collList;\n        _collList = new Bucket[oldBuckets.length];\n        for (int i = 0; i < oldEnd; ++i) {\n            for (Bucket curr = oldBuckets[i]; curr != null; curr = curr._next) {\n                ++symbolsSeen;\n                Name symbol = curr._name;\n                int hash = symbol.hashCode();\n                int ix = (hash & _mainHashMask);\n                int val = _mainHash[ix];\n                if (_mainNames[ix] == null) { // no primary entry?\n_mainHash[ix] = (hash & 8);\n                    _mainNames[ix] = symbol;\n                } else { // nope, it's a collision, need to spill over\n                    ++_collCount;\n                    int bucket = val & 0xFF;\n                    if (bucket == 0) { // first spill over?\n                        if (_collEnd <= LAST_VALID_BUCKET) { // yup, still unshared bucket\n                            bucket = _collEnd;\n                            ++_collEnd;\n                            // need to expand?\n                            if (bucket >= _collList.length) {\n                                expandCollision();\n                            }\n                        } else { // nope, have to share... let's find shortest?\n                            bucket = findBestBucket();\n                        }\n                        // Need to mark the entry... and the spill index is 1-based\n                        _mainHash[ix] = (val & ~0xFF) | (bucket + 1);\n                    } else {\n                        --bucket; // 1-based index in value\n                    }\n                    // And then just need to link the new bucket entry in\n                    Bucket newB = new Bucket(symbol, _collList[bucket]);\n                    _collList[bucket] = newB;\n                    maxColl = Math.max(maxColl, newB.length());\n                }\n            } // for (... buckets in the chain ...)\n        } // for (... list of bucket heads ... )\n\n        _longestCollisionList = maxColl;\n        \n        if (symbolsSeen != _count) { // sanity check\n            throw new RuntimeException(\"Internal error: count after rehash \"+symbolsSeen+\"; should be \"+_count);\n        }\n    }",
          "43": "    private void rehash()\n    {\n        _needRehash = false;        \n        // Note: since we'll make copies, no need to unshare, can just mark as such:\n        _mainNamesShared = false;\n\n        /* And then we can first deal with the main hash area. Since we\n         * are expanding linearly (double up), we know there'll be no\n         * collisions during this phase.\n         */\n        int[] oldMainHash = _mainHash;\n        int len = oldMainHash.length;\n        int newLen = len+len;\n\n        /* 13-Mar-2010, tatu: Let's guard against OOME that could be caused by\n         *    large documents with unique (or mostly so) names\n         */\n        if (newLen > MAX_TABLE_SIZE) {\n            nukeSymbols();\n            return;\n        }\n        \n        _mainHash = new int[newLen];\n        _mainHashMask = (newLen - 1);\n        Name[] oldNames = _mainNames;\n        _mainNames = new Name[newLen];\n        int symbolsSeen = 0; // let's do a sanity check\n        for (int i = 0; i < len; ++i) {\n            Name symbol = oldNames[i];\n            if (symbol != null) {\n                ++symbolsSeen;\n                int hash = symbol.hashCode();\n                int ix = (hash & _mainHashMask);\n                _mainNames[ix] = symbol;\n                _mainHash[ix] = hash << 8; // will clear spill index\n            }\n        }\n\n        /* And then the spill area. This may cause collisions, although\n         * not necessarily as many as there were earlier. Let's allocate\n         * same amount of space, however\n         */\n        int oldEnd = _collEnd;\n        if (oldEnd == 0) { // no prior collisions...\n            _longestCollisionList = 0;\n            return;\n        }\n\n        _collCount = 0;\n        _collEnd = 0;\n        _collListShared = false;\n\n        int maxColl = 0;\n        \n        Bucket[] oldBuckets = _collList;\n        _collList = new Bucket[oldBuckets.length];\n        for (int i = 0; i < oldEnd; ++i) {\n            for (Bucket curr = oldBuckets[i]; curr != null; curr = curr._next) {\n                ++symbolsSeen;\n                Name symbol = curr._name;\n                int hash = symbol.hashCode();\n                int ix = (hash & _mainHashMask);\n                int val = _mainHash[ix];\n                if (_mainNames[ix] == null) { // no primary entry?\nix[bucket] = (hash >>> 8);\n                    _mainNames[ix] = symbol;\n                } else { // nope, it's a collision, need to spill over\n                    ++_collCount;\n                    int bucket = val & 0xFF;\n                    if (bucket == 0) { // first spill over?\n                        if (_collEnd <= LAST_VALID_BUCKET) { // yup, still unshared bucket\n                            bucket = _collEnd;\n                            ++_collEnd;\n                            // need to expand?\n                            if (bucket >= _collList.length) {\n                                expandCollision();\n                            }\n                        } else { // nope, have to share... let's find shortest?\n                            bucket = findBestBucket();\n                        }\n                        // Need to mark the entry... and the spill index is 1-based\n                        _mainHash[ix] = (val & ~0xFF) | (bucket + 1);\n                    } else {\n                        --bucket; // 1-based index in value\n                    }\n                    // And then just need to link the new bucket entry in\n                    Bucket newB = new Bucket(symbol, _collList[bucket]);\n                    _collList[bucket] = newB;\n                    maxColl = Math.max(maxColl, newB.length());\n                }\n            } // for (... buckets in the chain ...)\n        } // for (... list of bucket heads ... )\n\n        _longestCollisionList = maxColl;\n        \n        if (symbolsSeen != _count) { // sanity check\n            throw new RuntimeException(\"Internal error: count after rehash \"+symbolsSeen+\"; should be \"+_count);\n        }\n    }",
          "44": "    private void rehash()\n    {\n        _needRehash = false;        \n        // Note: since we'll make copies, no need to unshare, can just mark as such:\n        _mainNamesShared = false;\n\n        /* And then we can first deal with the main hash area. Since we\n         * are expanding linearly (double up), we know there'll be no\n         * collisions during this phase.\n         */\n        int[] oldMainHash = _mainHash;\n        int len = oldMainHash.length;\n        int newLen = len+len;\n\n        /* 13-Mar-2010, tatu: Let's guard against OOME that could be caused by\n         *    large documents with unique (or mostly so) names\n         */\n        if (newLen > MAX_TABLE_SIZE) {\n            nukeSymbols();\n            return;\n        }\n        \n        _mainHash = new int[newLen];\n        _mainHashMask = (newLen - 1);\n        Name[] oldNames = _mainNames;\n        _mainNames = new Name[newLen];\n        int symbolsSeen = 0; // let's do a sanity check\n        for (int i = 0; i < len; ++i) {\n            Name symbol = oldNames[i];\n            if (symbol != null) {\n                ++symbolsSeen;\n                int hash = symbol.hashCode();\n                int ix = (hash & _mainHashMask);\n                _mainNames[ix] = symbol;\n                _mainHash[ix] = hash << 8; // will clear spill index\n            }\n        }\n\n        /* And then the spill area. This may cause collisions, although\n         * not necessarily as many as there were earlier. Let's allocate\n         * same amount of space, however\n         */\n        int oldEnd = _collEnd;\n        if (oldEnd == 0) { // no prior collisions...\n            _longestCollisionList = 0;\n            return;\n        }\n\n        _collCount = 0;\n        _collEnd = 0;\n        _collListShared = false;\n\n        int maxColl = 0;\n        \n        Bucket[] oldBuckets = _collList;\n        _collList = new Bucket[oldBuckets.length];\n        for (int i = 0; i < oldEnd; ++i) {\n            for (Bucket curr = oldBuckets[i]; curr != null; curr = curr._next) {\n                ++symbolsSeen;\n                Name symbol = curr._name;\n                int hash = symbol.hashCode();\n                int ix = (hash & _mainHashMask);\n                int val = _mainHash[ix];\n                if (_mainNames[ix] == null) { // no primary entry?\nexpandCollision();\n                    _mainHash[ix] = (hash >>> 8);                    _mainNames[ix] = symbol;\n                } else { // nope, it's a collision, need to spill over\n                    ++_collCount;\n                    int bucket = val & 0xFF;\n                    if (bucket == 0) { // first spill over?\n                        if (_collEnd <= LAST_VALID_BUCKET) { // yup, still unshared bucket\n                            bucket = _collEnd;\n                            ++_collEnd;\n                            // need to expand?\n                            if (bucket >= _collList.length) {\n                                expandCollision();\n                            }\n                        } else { // nope, have to share... let's find shortest?\n                            bucket = findBestBucket();\n                        }\n                        // Need to mark the entry... and the spill index is 1-based\n                        _mainHash[ix] = (val & ~0xFF) | (bucket + 1);\n                    } else {\n                        --bucket; // 1-based index in value\n                    }\n                    // And then just need to link the new bucket entry in\n                    Bucket newB = new Bucket(symbol, _collList[bucket]);\n                    _collList[bucket] = newB;\n                    maxColl = Math.max(maxColl, newB.length());\n                }\n            } // for (... buckets in the chain ...)\n        } // for (... list of bucket heads ... )\n\n        _longestCollisionList = maxColl;\n        \n        if (symbolsSeen != _count) { // sanity check\n            throw new RuntimeException(\"Internal error: count after rehash \"+symbolsSeen+\"; should be \"+_count);\n        }\n    }",
          "45": "    private void rehash()\n    {\n        _needRehash = false;        \n        // Note: since we'll make copies, no need to unshare, can just mark as such:\n        _mainNamesShared = false;\n\n        /* And then we can first deal with the main hash area. Since we\n         * are expanding linearly (double up), we know there'll be no\n         * collisions during this phase.\n         */\n        int[] oldMainHash = _mainHash;\n        int len = oldMainHash.length;\n        int newLen = len+len;\n\n        /* 13-Mar-2010, tatu: Let's guard against OOME that could be caused by\n         *    large documents with unique (or mostly so) names\n         */\n        if (newLen > MAX_TABLE_SIZE) {\n            nukeSymbols();\n            return;\n        }\n        \n        _mainHash = new int[newLen];\n        _mainHashMask = (newLen - 1);\n        Name[] oldNames = _mainNames;\n        _mainNames = new Name[newLen];\n        int symbolsSeen = 0; // let's do a sanity check\n        for (int i = 0; i < len; ++i) {\n            Name symbol = oldNames[i];\n            if (symbol != null) {\n                ++symbolsSeen;\n                int hash = symbol.hashCode();\n                int ix = (hash & _mainHashMask);\n                _mainNames[ix] = symbol;\n                _mainHash[ix] = hash << 8; // will clear spill index\n            }\n        }\n\n        /* And then the spill area. This may cause collisions, although\n         * not necessarily as many as there were earlier. Let's allocate\n         * same amount of space, however\n         */\n        int oldEnd = _collEnd;\n        if (oldEnd == 0) { // no prior collisions...\n            _longestCollisionList = 0;\n            return;\n        }\n\n        _collCount = 0;\n        _collEnd = 0;\n        _collListShared = false;\n\n        int maxColl = 0;\n        \n        Bucket[] oldBuckets = _collList;\n        _collList = new Bucket[oldBuckets.length];\n        for (int i = 0; i < oldEnd; ++i) {\n            for (Bucket curr = oldBuckets[i]; curr != null; curr = curr._next) {\n                ++symbolsSeen;\n                Name symbol = curr._name;\n                int hash = symbol.hashCode();\n                int ix = (hash & _mainHashMask);\n                int val = _mainHash[ix];\n                if (_mainNames[ix] == null) { // no primary entry?\nrelease();\n                    _mainHash[ix] = (hash >>> 8);                    _mainNames[ix] = symbol;\n                } else { // nope, it's a collision, need to spill over\n                    ++_collCount;\n                    int bucket = val & 0xFF;\n                    if (bucket == 0) { // first spill over?\n                        if (_collEnd <= LAST_VALID_BUCKET) { // yup, still unshared bucket\n                            bucket = _collEnd;\n                            ++_collEnd;\n                            // need to expand?\n                            if (bucket >= _collList.length) {\n                                expandCollision();\n                            }\n                        } else { // nope, have to share... let's find shortest?\n                            bucket = findBestBucket();\n                        }\n                        // Need to mark the entry... and the spill index is 1-based\n                        _mainHash[ix] = (val & ~0xFF) | (bucket + 1);\n                    } else {\n                        --bucket; // 1-based index in value\n                    }\n                    // And then just need to link the new bucket entry in\n                    Bucket newB = new Bucket(symbol, _collList[bucket]);\n                    _collList[bucket] = newB;\n                    maxColl = Math.max(maxColl, newB.length());\n                }\n            } // for (... buckets in the chain ...)\n        } // for (... list of bucket heads ... )\n\n        _longestCollisionList = maxColl;\n        \n        if (symbolsSeen != _count) { // sanity check\n            throw new RuntimeException(\"Internal error: count after rehash \"+symbolsSeen+\"; should be \"+_count);\n        }\n    }",
          "46": "    private void rehash()\n    {\n        _needRehash = false;        \n        // Note: since we'll make copies, no need to unshare, can just mark as such:\n        _mainNamesShared = false;\n\n        /* And then we can first deal with the main hash area. Since we\n         * are expanding linearly (double up), we know there'll be no\n         * collisions during this phase.\n         */\n        int[] oldMainHash = _mainHash;\n        int len = oldMainHash.length;\n        int newLen = len+len;\n\n        /* 13-Mar-2010, tatu: Let's guard against OOME that could be caused by\n         *    large documents with unique (or mostly so) names\n         */\n        if (newLen > MAX_TABLE_SIZE) {\n            nukeSymbols();\n            return;\n        }\n        \n        _mainHash = new int[newLen];\n        _mainHashMask = (newLen - 1);\n        Name[] oldNames = _mainNames;\n        _mainNames = new Name[newLen];\n        int symbolsSeen = 0; // let's do a sanity check\n        for (int i = 0; i < len; ++i) {\n            Name symbol = oldNames[i];\n            if (symbol != null) {\n                ++symbolsSeen;\n                int hash = symbol.hashCode();\n                int ix = (hash & _mainHashMask);\n                _mainNames[ix] = symbol;\n                _mainHash[ix] = hash << 8; // will clear spill index\n            }\n        }\n\n        /* And then the spill area. This may cause collisions, although\n         * not necessarily as many as there were earlier. Let's allocate\n         * same amount of space, however\n         */\n        int oldEnd = _collEnd;\n        if (oldEnd == 0) { // no prior collisions...\n            _longestCollisionList = 0;\n            return;\n        }\n\n        _collCount = 0;\n        _collEnd = 0;\n        _collListShared = false;\n\n        int maxColl = 0;\n        \n        Bucket[] oldBuckets = _collList;\n        _collList = new Bucket[oldBuckets.length];\n        for (int i = 0; i < oldEnd; ++i) {\n            for (Bucket curr = oldBuckets[i]; curr != null; curr = curr._next) {\n                ++symbolsSeen;\n                Name symbol = curr._name;\n                int hash = symbol.hashCode();\n                int ix = (hash & _mainHashMask);\n                int val = _mainHash[ix];\n                if (_mainNames[ix] == null) { // no primary entry?\nrehash();\n                    _mainHash[ix] = (hash >>> 8);                    _mainNames[ix] = symbol;\n                } else { // nope, it's a collision, need to spill over\n                    ++_collCount;\n                    int bucket = val & 0xFF;\n                    if (bucket == 0) { // first spill over?\n                        if (_collEnd <= LAST_VALID_BUCKET) { // yup, still unshared bucket\n                            bucket = _collEnd;\n                            ++_collEnd;\n                            // need to expand?\n                            if (bucket >= _collList.length) {\n                                expandCollision();\n                            }\n                        } else { // nope, have to share... let's find shortest?\n                            bucket = findBestBucket();\n                        }\n                        // Need to mark the entry... and the spill index is 1-based\n                        _mainHash[ix] = (val & ~0xFF) | (bucket + 1);\n                    } else {\n                        --bucket; // 1-based index in value\n                    }\n                    // And then just need to link the new bucket entry in\n                    Bucket newB = new Bucket(symbol, _collList[bucket]);\n                    _collList[bucket] = newB;\n                    maxColl = Math.max(maxColl, newB.length());\n                }\n            } // for (... buckets in the chain ...)\n        } // for (... list of bucket heads ... )\n\n        _longestCollisionList = maxColl;\n        \n        if (symbolsSeen != _count) { // sanity check\n            throw new RuntimeException(\"Internal error: count after rehash \"+symbolsSeen+\"; should be \"+_count);\n        }\n    }",
          "47": "    private void rehash()\n    {\n        _needRehash = false;        \n        // Note: since we'll make copies, no need to unshare, can just mark as such:\n        _mainNamesShared = false;\n\n        /* And then we can first deal with the main hash area. Since we\n         * are expanding linearly (double up), we know there'll be no\n         * collisions during this phase.\n         */\n        int[] oldMainHash = _mainHash;\n        int len = oldMainHash.length;\n        int newLen = len+len;\n\n        /* 13-Mar-2010, tatu: Let's guard against OOME that could be caused by\n         *    large documents with unique (or mostly so) names\n         */\n        if (newLen > MAX_TABLE_SIZE) {\n            nukeSymbols();\n            return;\n        }\n        \n        _mainHash = new int[newLen];\n        _mainHashMask = (newLen - 1);\n        Name[] oldNames = _mainNames;\n        _mainNames = new Name[newLen];\n        int symbolsSeen = 0; // let's do a sanity check\n        for (int i = 0; i < len; ++i) {\n            Name symbol = oldNames[i];\n            if (symbol != null) {\n                ++symbolsSeen;\n                int hash = symbol.hashCode();\n                int ix = (hash & _mainHashMask);\n                _mainNames[ix] = symbol;\n                _mainHash[ix] = hash << 8; // will clear spill index\n            }\n        }\n\n        /* And then the spill area. This may cause collisions, although\n         * not necessarily as many as there were earlier. Let's allocate\n         * same amount of space, however\n         */\n        int oldEnd = _collEnd;\n        if (oldEnd == 0) { // no prior collisions...\n            _longestCollisionList = 0;\n            return;\n        }\n\n        _collCount = 0;\n        _collEnd = 0;\n        _collListShared = false;\n\n        int maxColl = 0;\n        \n        Bucket[] oldBuckets = _collList;\n        _collList = new Bucket[oldBuckets.length];\n        for (int i = 0; i < oldEnd; ++i) {\n            for (Bucket curr = oldBuckets[i]; curr != null; curr = curr._next) {\n                ++symbolsSeen;\n                Name symbol = curr._name;\n                int hash = symbol.hashCode();\n                int ix = (hash & _mainHashMask);\n                int val = _mainHash[ix];\n                if (_mainNames[ix] == null) { // no primary entry?\nnukeSymbols();\n                    _mainHash[ix] = (hash >>> 8);                    _mainNames[ix] = symbol;\n                } else { // nope, it's a collision, need to spill over\n                    ++_collCount;\n                    int bucket = val & 0xFF;\n                    if (bucket == 0) { // first spill over?\n                        if (_collEnd <= LAST_VALID_BUCKET) { // yup, still unshared bucket\n                            bucket = _collEnd;\n                            ++_collEnd;\n                            // need to expand?\n                            if (bucket >= _collList.length) {\n                                expandCollision();\n                            }\n                        } else { // nope, have to share... let's find shortest?\n                            bucket = findBestBucket();\n                        }\n                        // Need to mark the entry... and the spill index is 1-based\n                        _mainHash[ix] = (val & ~0xFF) | (bucket + 1);\n                    } else {\n                        --bucket; // 1-based index in value\n                    }\n                    // And then just need to link the new bucket entry in\n                    Bucket newB = new Bucket(symbol, _collList[bucket]);\n                    _collList[bucket] = newB;\n                    maxColl = Math.max(maxColl, newB.length());\n                }\n            } // for (... buckets in the chain ...)\n        } // for (... list of bucket heads ... )\n\n        _longestCollisionList = maxColl;\n        \n        if (symbolsSeen != _count) { // sanity check\n            throw new RuntimeException(\"Internal error: count after rehash \"+symbolsSeen+\"; should be \"+_count);\n        }\n    }",
          "48": "    private void rehash()\n    {\n        _needRehash = false;        \n        // Note: since we'll make copies, no need to unshare, can just mark as such:\n        _mainNamesShared = false;\n\n        /* And then we can first deal with the main hash area. Since we\n         * are expanding linearly (double up), we know there'll be no\n         * collisions during this phase.\n         */\n        int[] oldMainHash = _mainHash;\n        int len = oldMainHash.length;\n        int newLen = len+len;\n\n        /* 13-Mar-2010, tatu: Let's guard against OOME that could be caused by\n         *    large documents with unique (or mostly so) names\n         */\n        if (newLen > MAX_TABLE_SIZE) {\n            nukeSymbols();\n            return;\n        }\n        \n        _mainHash = new int[newLen];\n        _mainHashMask = (newLen - 1);\n        Name[] oldNames = _mainNames;\n        _mainNames = new Name[newLen];\n        int symbolsSeen = 0; // let's do a sanity check\n        for (int i = 0; i < len; ++i) {\n            Name symbol = oldNames[i];\n            if (symbol != null) {\n                ++symbolsSeen;\n                int hash = symbol.hashCode();\n                int ix = (hash & _mainHashMask);\n                _mainNames[ix] = symbol;\n                _mainHash[ix] = hash << 8; // will clear spill index\n            }\n        }\n\n        /* And then the spill area. This may cause collisions, although\n         * not necessarily as many as there were earlier. Let's allocate\n         * same amount of space, however\n         */\n        int oldEnd = _collEnd;\n        if (oldEnd == 0) { // no prior collisions...\n            _longestCollisionList = 0;\n            return;\n        }\n\n        _collCount = 0;\n        _collEnd = 0;\n        _collListShared = false;\n\n        int maxColl = 0;\n        \n        Bucket[] oldBuckets = _collList;\n        _collList = new Bucket[oldBuckets.length];\n        for (int i = 0; i < oldEnd; ++i) {\n            for (Bucket curr = oldBuckets[i]; curr != null; curr = curr._next) {\n                ++symbolsSeen;\n                Name symbol = curr._name;\n                int hash = symbol.hashCode();\n                int ix = (hash & _mainHashMask);\n                int val = _mainHash[ix];\n                if (_mainNames[ix] == null) { // no primary entry?\nunshareMain();\n                    _mainHash[ix] = (hash >>> 8);                    _mainNames[ix] = symbol;\n                } else { // nope, it's a collision, need to spill over\n                    ++_collCount;\n                    int bucket = val & 0xFF;\n                    if (bucket == 0) { // first spill over?\n                        if (_collEnd <= LAST_VALID_BUCKET) { // yup, still unshared bucket\n                            bucket = _collEnd;\n                            ++_collEnd;\n                            // need to expand?\n                            if (bucket >= _collList.length) {\n                                expandCollision();\n                            }\n                        } else { // nope, have to share... let's find shortest?\n                            bucket = findBestBucket();\n                        }\n                        // Need to mark the entry... and the spill index is 1-based\n                        _mainHash[ix] = (val & ~0xFF) | (bucket + 1);\n                    } else {\n                        --bucket; // 1-based index in value\n                    }\n                    // And then just need to link the new bucket entry in\n                    Bucket newB = new Bucket(symbol, _collList[bucket]);\n                    _collList[bucket] = newB;\n                    maxColl = Math.max(maxColl, newB.length());\n                }\n            } // for (... buckets in the chain ...)\n        } // for (... list of bucket heads ... )\n\n        _longestCollisionList = maxColl;\n        \n        if (symbolsSeen != _count) { // sanity check\n            throw new RuntimeException(\"Internal error: count after rehash \"+symbolsSeen+\"; should be \"+_count);\n        }\n    }",
          "49": "    private void rehash()\n    {\n        _needRehash = false;        \n        // Note: since we'll make copies, no need to unshare, can just mark as such:\n        _mainNamesShared = false;\n\n        /* And then we can first deal with the main hash area. Since we\n         * are expanding linearly (double up), we know there'll be no\n         * collisions during this phase.\n         */\n        int[] oldMainHash = _mainHash;\n        int len = oldMainHash.length;\n        int newLen = len+len;\n\n        /* 13-Mar-2010, tatu: Let's guard against OOME that could be caused by\n         *    large documents with unique (or mostly so) names\n         */\n        if (newLen > MAX_TABLE_SIZE) {\n            nukeSymbols();\n            return;\n        }\n        \n        _mainHash = new int[newLen];\n        _mainHashMask = (newLen - 1);\n        Name[] oldNames = _mainNames;\n        _mainNames = new Name[newLen];\n        int symbolsSeen = 0; // let's do a sanity check\n        for (int i = 0; i < len; ++i) {\n            Name symbol = oldNames[i];\n            if (symbol != null) {\n                ++symbolsSeen;\n                int hash = symbol.hashCode();\n                int ix = (hash & _mainHashMask);\n                _mainNames[ix] = symbol;\n                _mainHash[ix] = hash << 8; // will clear spill index\n            }\n        }\n\n        /* And then the spill area. This may cause collisions, although\n         * not necessarily as many as there were earlier. Let's allocate\n         * same amount of space, however\n         */\n        int oldEnd = _collEnd;\n        if (oldEnd == 0) { // no prior collisions...\n            _longestCollisionList = 0;\n            return;\n        }\n\n        _collCount = 0;\n        _collEnd = 0;\n        _collListShared = false;\n\n        int maxColl = 0;\n        \n        Bucket[] oldBuckets = _collList;\n        _collList = new Bucket[oldBuckets.length];\n        for (int i = 0; i < oldEnd; ++i) {\n            for (Bucket curr = oldBuckets[i]; curr != null; curr = curr._next) {\n                ++symbolsSeen;\n                Name symbol = curr._name;\n                int hash = symbol.hashCode();\n                int ix = (hash & _mainHashMask);\n                int val = _mainHash[ix];\n                if (_mainNames[ix] == null) { // no primary entry?\nunshareCollision();\n                    _mainHash[ix] = (hash >>> 8);                    _mainNames[ix] = symbol;\n                } else { // nope, it's a collision, need to spill over\n                    ++_collCount;\n                    int bucket = val & 0xFF;\n                    if (bucket == 0) { // first spill over?\n                        if (_collEnd <= LAST_VALID_BUCKET) { // yup, still unshared bucket\n                            bucket = _collEnd;\n                            ++_collEnd;\n                            // need to expand?\n                            if (bucket >= _collList.length) {\n                                expandCollision();\n                            }\n                        } else { // nope, have to share... let's find shortest?\n                            bucket = findBestBucket();\n                        }\n                        // Need to mark the entry... and the spill index is 1-based\n                        _mainHash[ix] = (val & ~0xFF) | (bucket + 1);\n                    } else {\n                        --bucket; // 1-based index in value\n                    }\n                    // And then just need to link the new bucket entry in\n                    Bucket newB = new Bucket(symbol, _collList[bucket]);\n                    _collList[bucket] = newB;\n                    maxColl = Math.max(maxColl, newB.length());\n                }\n            } // for (... buckets in the chain ...)\n        } // for (... list of bucket heads ... )\n\n        _longestCollisionList = maxColl;\n        \n        if (symbolsSeen != _count) { // sanity check\n            throw new RuntimeException(\"Internal error: count after rehash \"+symbolsSeen+\"; should be \"+_count);\n        }\n    }",
          "50": "    private void rehash()\n    {\n        _needRehash = false;        \n        // Note: since we'll make copies, no need to unshare, can just mark as such:\n        _mainNamesShared = false;\n\n        /* And then we can first deal with the main hash area. Since we\n         * are expanding linearly (double up), we know there'll be no\n         * collisions during this phase.\n         */\n        int[] oldMainHash = _mainHash;\n        int len = oldMainHash.length;\n        int newLen = len+len;\n\n        /* 13-Mar-2010, tatu: Let's guard against OOME that could be caused by\n         *    large documents with unique (or mostly so) names\n         */\n        if (newLen > MAX_TABLE_SIZE) {\n            nukeSymbols();\n            return;\n        }\n        \n        _mainHash = new int[newLen];\n        _mainHashMask = (newLen - 1);\n        Name[] oldNames = _mainNames;\n        _mainNames = new Name[newLen];\n        int symbolsSeen = 0; // let's do a sanity check\n        for (int i = 0; i < len; ++i) {\n            Name symbol = oldNames[i];\n            if (symbol != null) {\n                ++symbolsSeen;\n                int hash = symbol.hashCode();\n                int ix = (hash & _mainHashMask);\n                _mainNames[ix] = symbol;\n                _mainHash[ix] = hash << 8; // will clear spill index\n            }\n        }\n\n        /* And then the spill area. This may cause collisions, although\n         * not necessarily as many as there were earlier. Let's allocate\n         * same amount of space, however\n         */\n        int oldEnd = _collEnd;\n        if (oldEnd == 0) { // no prior collisions...\n            _longestCollisionList = 0;\n            return;\n        }\n\n        _collCount = 0;\n        _collEnd = 0;\n        _collListShared = false;\n\n        int maxColl = 0;\n        \n        Bucket[] oldBuckets = _collList;\n        _collList = new Bucket[oldBuckets.length];\n        for (int i = 0; i < oldEnd; ++i) {\n            for (Bucket curr = oldBuckets[i]; curr != null; curr = curr._next) {\n                ++symbolsSeen;\n                Name symbol = curr._name;\n                int hash = symbol.hashCode();\n                int ix = (hash & _mainHashMask);\n                int val = _mainHash[ix];\n                if (_mainNames[ix] == null) { // no primary entry?\nunshareNames();\n                    _mainHash[ix] = (hash >>> 8);                    _mainNames[ix] = symbol;\n                } else { // nope, it's a collision, need to spill over\n                    ++_collCount;\n                    int bucket = val & 0xFF;\n                    if (bucket == 0) { // first spill over?\n                        if (_collEnd <= LAST_VALID_BUCKET) { // yup, still unshared bucket\n                            bucket = _collEnd;\n                            ++_collEnd;\n                            // need to expand?\n                            if (bucket >= _collList.length) {\n                                expandCollision();\n                            }\n                        } else { // nope, have to share... let's find shortest?\n                            bucket = findBestBucket();\n                        }\n                        // Need to mark the entry... and the spill index is 1-based\n                        _mainHash[ix] = (val & ~0xFF) | (bucket + 1);\n                    } else {\n                        --bucket; // 1-based index in value\n                    }\n                    // And then just need to link the new bucket entry in\n                    Bucket newB = new Bucket(symbol, _collList[bucket]);\n                    _collList[bucket] = newB;\n                    maxColl = Math.max(maxColl, newB.length());\n                }\n            } // for (... buckets in the chain ...)\n        } // for (... list of bucket heads ... )\n\n        _longestCollisionList = maxColl;\n        \n        if (symbolsSeen != _count) { // sanity check\n            throw new RuntimeException(\"Internal error: count after rehash \"+symbolsSeen+\"; should be \"+_count);\n        }\n    }",
          "51": "    private void rehash()\n    {\n        _needRehash = false;        \n        // Note: since we'll make copies, no need to unshare, can just mark as such:\n        _mainNamesShared = false;\n\n        /* And then we can first deal with the main hash area. Since we\n         * are expanding linearly (double up), we know there'll be no\n         * collisions during this phase.\n         */\n        int[] oldMainHash = _mainHash;\n        int len = oldMainHash.length;\n        int newLen = len+len;\n\n        /* 13-Mar-2010, tatu: Let's guard against OOME that could be caused by\n         *    large documents with unique (or mostly so) names\n         */\n        if (newLen > MAX_TABLE_SIZE) {\n            nukeSymbols();\n            return;\n        }\n        \n        _mainHash = new int[newLen];\n        _mainHashMask = (newLen - 1);\n        Name[] oldNames = _mainNames;\n        _mainNames = new Name[newLen];\n        int symbolsSeen = 0; // let's do a sanity check\n        for (int i = 0; i < len; ++i) {\n            Name symbol = oldNames[i];\n            if (symbol != null) {\n                ++symbolsSeen;\n                int hash = symbol.hashCode();\n                int ix = (hash & _mainHashMask);\n                _mainNames[ix] = symbol;\n                _mainHash[ix] = hash << 8; // will clear spill index\n            }\n        }\n\n        /* And then the spill area. This may cause collisions, although\n         * not necessarily as many as there were earlier. Let's allocate\n         * same amount of space, however\n         */\n        int oldEnd = _collEnd;\n        if (oldEnd == 0) { // no prior collisions...\n            _longestCollisionList = 0;\n            return;\n        }\n\n        _collCount = 0;\n        _collEnd = 0;\n        _collListShared = false;\n\n        int maxColl = 0;\n        \n        Bucket[] oldBuckets = _collList;\n        _collList = new Bucket[oldBuckets.length];\n        for (int i = 0; i < oldEnd; ++i) {\n            for (Bucket curr = oldBuckets[i]; curr != null; curr = curr._next) {\n                ++symbolsSeen;\n                Name symbol = curr._name;\n                int hash = symbol.hashCode();\n                int ix = (hash & _mainHashMask);\n                int val = _mainHash[ix];\n                if (_mainNames[ix] == null) { // no primary entry?\n++_collEnd;\n                    _mainHash[ix] = (hash >>> 8);                    _mainNames[ix] = symbol;\n                } else { // nope, it's a collision, need to spill over\n                    ++_collCount;\n                    int bucket = val & 0xFF;\n                    if (bucket == 0) { // first spill over?\n                        if (_collEnd <= LAST_VALID_BUCKET) { // yup, still unshared bucket\n                            bucket = _collEnd;\n                            ++_collEnd;\n                            // need to expand?\n                            if (bucket >= _collList.length) {\n                                expandCollision();\n                            }\n                        } else { // nope, have to share... let's find shortest?\n                            bucket = findBestBucket();\n                        }\n                        // Need to mark the entry... and the spill index is 1-based\n                        _mainHash[ix] = (val & ~0xFF) | (bucket + 1);\n                    } else {\n                        --bucket; // 1-based index in value\n                    }\n                    // And then just need to link the new bucket entry in\n                    Bucket newB = new Bucket(symbol, _collList[bucket]);\n                    _collList[bucket] = newB;\n                    maxColl = Math.max(maxColl, newB.length());\n                }\n            } // for (... buckets in the chain ...)\n        } // for (... list of bucket heads ... )\n\n        _longestCollisionList = maxColl;\n        \n        if (symbolsSeen != _count) { // sanity check\n            throw new RuntimeException(\"Internal error: count after rehash \"+symbolsSeen+\"; should be \"+_count);\n        }\n    }",
          "52": "    private void rehash()\n    {\n        _needRehash = false;        \n        // Note: since we'll make copies, no need to unshare, can just mark as such:\n        _mainNamesShared = false;\n\n        /* And then we can first deal with the main hash area. Since we\n         * are expanding linearly (double up), we know there'll be no\n         * collisions during this phase.\n         */\n        int[] oldMainHash = _mainHash;\n        int len = oldMainHash.length;\n        int newLen = len+len;\n\n        /* 13-Mar-2010, tatu: Let's guard against OOME that could be caused by\n         *    large documents with unique (or mostly so) names\n         */\n        if (newLen > MAX_TABLE_SIZE) {\n            nukeSymbols();\n            return;\n        }\n        \n        _mainHash = new int[newLen];\n        _mainHashMask = (newLen - 1);\n        Name[] oldNames = _mainNames;\n        _mainNames = new Name[newLen];\n        int symbolsSeen = 0; // let's do a sanity check\n        for (int i = 0; i < len; ++i) {\n            Name symbol = oldNames[i];\n            if (symbol != null) {\n                ++symbolsSeen;\n                int hash = symbol.hashCode();\n                int ix = (hash & _mainHashMask);\n                _mainNames[ix] = symbol;\n                _mainHash[ix] = hash << 8; // will clear spill index\n            }\n        }\n\n        /* And then the spill area. This may cause collisions, although\n         * not necessarily as many as there were earlier. Let's allocate\n         * same amount of space, however\n         */\n        int oldEnd = _collEnd;\n        if (oldEnd == 0) { // no prior collisions...\n            _longestCollisionList = 0;\n            return;\n        }\n\n        _collCount = 0;\n        _collEnd = 0;\n        _collListShared = false;\n\n        int maxColl = 0;\n        \n        Bucket[] oldBuckets = _collList;\n        _collList = new Bucket[oldBuckets.length];\n        for (int i = 0; i < oldEnd; ++i) {\n            for (Bucket curr = oldBuckets[i]; curr != null; curr = curr._next) {\n                ++symbolsSeen;\n                Name symbol = curr._name;\n                int hash = symbol.hashCode();\n                int ix = (hash & _mainHashMask);\n                int val = _mainHash[ix];\n                if (_mainNames[ix] == null) { // no primary entry?\n++_collCount;\n                    _mainHash[ix] = (hash >>> 8);                    _mainNames[ix] = symbol;\n                } else { // nope, it's a collision, need to spill over\n                    ++_collCount;\n                    int bucket = val & 0xFF;\n                    if (bucket == 0) { // first spill over?\n                        if (_collEnd <= LAST_VALID_BUCKET) { // yup, still unshared bucket\n                            bucket = _collEnd;\n                            ++_collEnd;\n                            // need to expand?\n                            if (bucket >= _collList.length) {\n                                expandCollision();\n                            }\n                        } else { // nope, have to share... let's find shortest?\n                            bucket = findBestBucket();\n                        }\n                        // Need to mark the entry... and the spill index is 1-based\n                        _mainHash[ix] = (val & ~0xFF) | (bucket + 1);\n                    } else {\n                        --bucket; // 1-based index in value\n                    }\n                    // And then just need to link the new bucket entry in\n                    Bucket newB = new Bucket(symbol, _collList[bucket]);\n                    _collList[bucket] = newB;\n                    maxColl = Math.max(maxColl, newB.length());\n                }\n            } // for (... buckets in the chain ...)\n        } // for (... list of bucket heads ... )\n\n        _longestCollisionList = maxColl;\n        \n        if (symbolsSeen != _count) { // sanity check\n            throw new RuntimeException(\"Internal error: count after rehash \"+symbolsSeen+\"; should be \"+_count);\n        }\n    }",
          "53": "    private void rehash()\n    {\n        _needRehash = false;        \n        // Note: since we'll make copies, no need to unshare, can just mark as such:\n        _mainNamesShared = false;\n\n        /* And then we can first deal with the main hash area. Since we\n         * are expanding linearly (double up), we know there'll be no\n         * collisions during this phase.\n         */\n        int[] oldMainHash = _mainHash;\n        int len = oldMainHash.length;\n        int newLen = len+len;\n\n        /* 13-Mar-2010, tatu: Let's guard against OOME that could be caused by\n         *    large documents with unique (or mostly so) names\n         */\n        if (newLen > MAX_TABLE_SIZE) {\n            nukeSymbols();\n            return;\n        }\n        \n        _mainHash = new int[newLen];\n        _mainHashMask = (newLen - 1);\n        Name[] oldNames = _mainNames;\n        _mainNames = new Name[newLen];\n        int symbolsSeen = 0; // let's do a sanity check\n        for (int i = 0; i < len; ++i) {\n            Name symbol = oldNames[i];\n            if (symbol != null) {\n                ++symbolsSeen;\n                int hash = symbol.hashCode();\n                int ix = (hash & _mainHashMask);\n                _mainNames[ix] = symbol;\n                _mainHash[ix] = hash << 8; // will clear spill index\n            }\n        }\n\n        /* And then the spill area. This may cause collisions, although\n         * not necessarily as many as there were earlier. Let's allocate\n         * same amount of space, however\n         */\n        int oldEnd = _collEnd;\n        if (oldEnd == 0) { // no prior collisions...\n            _longestCollisionList = 0;\n            return;\n        }\n\n        _collCount = 0;\n        _collEnd = 0;\n        _collListShared = false;\n\n        int maxColl = 0;\n        \n        Bucket[] oldBuckets = _collList;\n        _collList = new Bucket[oldBuckets.length];\n        for (int i = 0; i < oldEnd; ++i) {\n            for (Bucket curr = oldBuckets[i]; curr != null; curr = curr._next) {\n                ++symbolsSeen;\n                Name symbol = curr._name;\n                int hash = symbol.hashCode();\n                int ix = (hash & _mainHashMask);\n                int val = _mainHash[ix];\n                if (_mainNames[ix] == null) { // no primary entry?\n_longestCollisionList = maxColl;\n                    _mainHash[ix] = (hash >>> 8);                    _mainNames[ix] = symbol;\n                } else { // nope, it's a collision, need to spill over\n                    ++_collCount;\n                    int bucket = val & 0xFF;\n                    if (bucket == 0) { // first spill over?\n                        if (_collEnd <= LAST_VALID_BUCKET) { // yup, still unshared bucket\n                            bucket = _collEnd;\n                            ++_collEnd;\n                            // need to expand?\n                            if (bucket >= _collList.length) {\n                                expandCollision();\n                            }\n                        } else { // nope, have to share... let's find shortest?\n                            bucket = findBestBucket();\n                        }\n                        // Need to mark the entry... and the spill index is 1-based\n                        _mainHash[ix] = (val & ~0xFF) | (bucket + 1);\n                    } else {\n                        --bucket; // 1-based index in value\n                    }\n                    // And then just need to link the new bucket entry in\n                    Bucket newB = new Bucket(symbol, _collList[bucket]);\n                    _collList[bucket] = newB;\n                    maxColl = Math.max(maxColl, newB.length());\n                }\n            } // for (... buckets in the chain ...)\n        } // for (... list of bucket heads ... )\n\n        _longestCollisionList = maxColl;\n        \n        if (symbolsSeen != _count) { // sanity check\n            throw new RuntimeException(\"Internal error: count after rehash \"+symbolsSeen+\"; should be \"+_count);\n        }\n    }",
          "54": "    private void rehash()\n    {\n        _needRehash = false;        \n        // Note: since we'll make copies, no need to unshare, can just mark as such:\n        _mainNamesShared = false;\n\n        /* And then we can first deal with the main hash area. Since we\n         * are expanding linearly (double up), we know there'll be no\n         * collisions during this phase.\n         */\n        int[] oldMainHash = _mainHash;\n        int len = oldMainHash.length;\n        int newLen = len+len;\n\n        /* 13-Mar-2010, tatu: Let's guard against OOME that could be caused by\n         *    large documents with unique (or mostly so) names\n         */\n        if (newLen > MAX_TABLE_SIZE) {\n            nukeSymbols();\n            return;\n        }\n        \n        _mainHash = new int[newLen];\n        _mainHashMask = (newLen - 1);\n        Name[] oldNames = _mainNames;\n        _mainNames = new Name[newLen];\n        int symbolsSeen = 0; // let's do a sanity check\n        for (int i = 0; i < len; ++i) {\n            Name symbol = oldNames[i];\n            if (symbol != null) {\n                ++symbolsSeen;\n                int hash = symbol.hashCode();\n                int ix = (hash & _mainHashMask);\n                _mainNames[ix] = symbol;\n                _mainHash[ix] = hash << 8; // will clear spill index\n            }\n        }\n\n        /* And then the spill area. This may cause collisions, although\n         * not necessarily as many as there were earlier. Let's allocate\n         * same amount of space, however\n         */\n        int oldEnd = _collEnd;\n        if (oldEnd == 0) { // no prior collisions...\n            _longestCollisionList = 0;\n            return;\n        }\n\n        _collCount = 0;\n        _collEnd = 0;\n        _collListShared = false;\n\n        int maxColl = 0;\n        \n        Bucket[] oldBuckets = _collList;\n        _collList = new Bucket[oldBuckets.length];\n        for (int i = 0; i < oldEnd; ++i) {\n            for (Bucket curr = oldBuckets[i]; curr != null; curr = curr._next) {\n                ++symbolsSeen;\n                Name symbol = curr._name;\n                int hash = symbol.hashCode();\n                int ix = (hash & _mainHashMask);\n                int val = _mainHash[ix];\n                if (_mainNames[ix] == null) { // no primary entry?\nhash[ix] = (hash >>> 8);\n                    _mainNames[ix] = symbol;\n                } else { // nope, it's a collision, need to spill over\n                    ++_collCount;\n                    int bucket = val & 0xFF;\n                    if (bucket == 0) { // first spill over?\n                        if (_collEnd <= LAST_VALID_BUCKET) { // yup, still unshared bucket\n                            bucket = _collEnd;\n                            ++_collEnd;\n                            // need to expand?\n                            if (bucket >= _collList.length) {\n                                expandCollision();\n                            }\n                        } else { // nope, have to share... let's find shortest?\n                            bucket = findBestBucket();\n                        }\n                        // Need to mark the entry... and the spill index is 1-based\n                        _mainHash[ix] = (val & ~0xFF) | (bucket + 1);\n                    } else {\n                        --bucket; // 1-based index in value\n                    }\n                    // And then just need to link the new bucket entry in\n                    Bucket newB = new Bucket(symbol, _collList[bucket]);\n                    _collList[bucket] = newB;\n                    maxColl = Math.max(maxColl, newB.length());\n                }\n            } // for (... buckets in the chain ...)\n        } // for (... list of bucket heads ... )\n\n        _longestCollisionList = maxColl;\n        \n        if (symbolsSeen != _count) { // sanity check\n            throw new RuntimeException(\"Internal error: count after rehash \"+symbolsSeen+\"; should be \"+_count);\n        }\n    }",
          "55": "    private void rehash()\n    {\n        _needRehash = false;        \n        // Note: since we'll make copies, no need to unshare, can just mark as such:\n        _mainNamesShared = false;\n\n        /* And then we can first deal with the main hash area. Since we\n         * are expanding linearly (double up), we know there'll be no\n         * collisions during this phase.\n         */\n        int[] oldMainHash = _mainHash;\n        int len = oldMainHash.length;\n        int newLen = len+len;\n\n        /* 13-Mar-2010, tatu: Let's guard against OOME that could be caused by\n         *    large documents with unique (or mostly so) names\n         */\n        if (newLen > MAX_TABLE_SIZE) {\n            nukeSymbols();\n            return;\n        }\n        \n        _mainHash = new int[newLen];\n        _mainHashMask = (newLen - 1);\n        Name[] oldNames = _mainNames;\n        _mainNames = new Name[newLen];\n        int symbolsSeen = 0; // let's do a sanity check\n        for (int i = 0; i < len; ++i) {\n            Name symbol = oldNames[i];\n            if (symbol != null) {\n                ++symbolsSeen;\n                int hash = symbol.hashCode();\n                int ix = (hash & _mainHashMask);\n                _mainNames[ix] = symbol;\n                _mainHash[ix] = hash << 8; // will clear spill index\n            }\n        }\n\n        /* And then the spill area. This may cause collisions, although\n         * not necessarily as many as there were earlier. Let's allocate\n         * same amount of space, however\n         */\n        int oldEnd = _collEnd;\n        if (oldEnd == 0) { // no prior collisions...\n            _longestCollisionList = 0;\n            return;\n        }\n\n        _collCount = 0;\n        _collEnd = 0;\n        _collListShared = false;\n\n        int maxColl = 0;\n        \n        Bucket[] oldBuckets = _collList;\n        _collList = new Bucket[oldBuckets.length];\n        for (int i = 0; i < oldEnd; ++i) {\n            for (Bucket curr = oldBuckets[i]; curr != null; curr = curr._next) {\n                ++symbolsSeen;\n                Name symbol = curr._name;\n                int hash = symbol.hashCode();\n                int ix = (hash & _mainHashMask);\n                int val = _mainHash[ix];\n                if (_mainNames[ix] == null) { // no primary entry?\nbucket = findBestBucket();\n                    _mainHash[ix] = (hash >>> 8);                    _mainNames[ix] = symbol;\n                } else { // nope, it's a collision, need to spill over\n                    ++_collCount;\n                    int bucket = val & 0xFF;\n                    if (bucket == 0) { // first spill over?\n                        if (_collEnd <= LAST_VALID_BUCKET) { // yup, still unshared bucket\n                            bucket = _collEnd;\n                            ++_collEnd;\n                            // need to expand?\n                            if (bucket >= _collList.length) {\n                                expandCollision();\n                            }\n                        } else { // nope, have to share... let's find shortest?\n                            bucket = findBestBucket();\n                        }\n                        // Need to mark the entry... and the spill index is 1-based\n                        _mainHash[ix] = (val & ~0xFF) | (bucket + 1);\n                    } else {\n                        --bucket; // 1-based index in value\n                    }\n                    // And then just need to link the new bucket entry in\n                    Bucket newB = new Bucket(symbol, _collList[bucket]);\n                    _collList[bucket] = newB;\n                    maxColl = Math.max(maxColl, newB.length());\n                }\n            } // for (... buckets in the chain ...)\n        } // for (... list of bucket heads ... )\n\n        _longestCollisionList = maxColl;\n        \n        if (symbolsSeen != _count) { // sanity check\n            throw new RuntimeException(\"Internal error: count after rehash \"+symbolsSeen+\"; should be \"+_count);\n        }\n    }",
          "56": "    private void rehash()\n    {\n        _needRehash = false;        \n        // Note: since we'll make copies, no need to unshare, can just mark as such:\n        _mainNamesShared = false;\n\n        /* And then we can first deal with the main hash area. Since we\n         * are expanding linearly (double up), we know there'll be no\n         * collisions during this phase.\n         */\n        int[] oldMainHash = _mainHash;\n        int len = oldMainHash.length;\n        int newLen = len+len;\n\n        /* 13-Mar-2010, tatu: Let's guard against OOME that could be caused by\n         *    large documents with unique (or mostly so) names\n         */\n        if (newLen > MAX_TABLE_SIZE) {\n            nukeSymbols();\n            return;\n        }\n        \n        _mainHash = new int[newLen];\n        _mainHashMask = (newLen - 1);\n        Name[] oldNames = _mainNames;\n        _mainNames = new Name[newLen];\n        int symbolsSeen = 0; // let's do a sanity check\n        for (int i = 0; i < len; ++i) {\n            Name symbol = oldNames[i];\n            if (symbol != null) {\n                ++symbolsSeen;\n                int hash = symbol.hashCode();\n                int ix = (hash & _mainHashMask);\n                _mainNames[ix] = symbol;\n                _mainHash[ix] = hash << 8; // will clear spill index\n            }\n        }\n\n        /* And then the spill area. This may cause collisions, although\n         * not necessarily as many as there were earlier. Let's allocate\n         * same amount of space, however\n         */\n        int oldEnd = _collEnd;\n        if (oldEnd == 0) { // no prior collisions...\n            _longestCollisionList = 0;\n            return;\n        }\n\n        _collCount = 0;\n        _collEnd = 0;\n        _collListShared = false;\n\n        int maxColl = 0;\n        \n        Bucket[] oldBuckets = _collList;\n        _collList = new Bucket[oldBuckets.length];\n        for (int i = 0; i < oldEnd; ++i) {\n            for (Bucket curr = oldBuckets[i]; curr != null; curr = curr._next) {\n                ++symbolsSeen;\n                Name symbol = curr._name;\n                int hash = symbol.hashCode();\n                int ix = (hash & _mainHashMask);\n                int val = _mainHash[ix];\n                if (_mainNames[ix] == null) { // no primary entry?\nhash[bucket] = (hash >>> 8);\n                    _mainNames[ix] = symbol;\n                } else { // nope, it's a collision, need to spill over\n                    ++_collCount;\n                    int bucket = val & 0xFF;\n                    if (bucket == 0) { // first spill over?\n                        if (_collEnd <= LAST_VALID_BUCKET) { // yup, still unshared bucket\n                            bucket = _collEnd;\n                            ++_collEnd;\n                            // need to expand?\n                            if (bucket >= _collList.length) {\n                                expandCollision();\n                            }\n                        } else { // nope, have to share... let's find shortest?\n                            bucket = findBestBucket();\n                        }\n                        // Need to mark the entry... and the spill index is 1-based\n                        _mainHash[ix] = (val & ~0xFF) | (bucket + 1);\n                    } else {\n                        --bucket; // 1-based index in value\n                    }\n                    // And then just need to link the new bucket entry in\n                    Bucket newB = new Bucket(symbol, _collList[bucket]);\n                    _collList[bucket] = newB;\n                    maxColl = Math.max(maxColl, newB.length());\n                }\n            } // for (... buckets in the chain ...)\n        } // for (... list of bucket heads ... )\n\n        _longestCollisionList = maxColl;\n        \n        if (symbolsSeen != _count) { // sanity check\n            throw new RuntimeException(\"Internal error: count after rehash \"+symbolsSeen+\"; should be \"+_count);\n        }\n    }",
          "57": "    private void rehash()\n    {\n        _needRehash = false;        \n        // Note: since we'll make copies, no need to unshare, can just mark as such:\n        _mainNamesShared = false;\n\n        /* And then we can first deal with the main hash area. Since we\n         * are expanding linearly (double up), we know there'll be no\n         * collisions during this phase.\n         */\n        int[] oldMainHash = _mainHash;\n        int len = oldMainHash.length;\n        int newLen = len+len;\n\n        /* 13-Mar-2010, tatu: Let's guard against OOME that could be caused by\n         *    large documents with unique (or mostly so) names\n         */\n        if (newLen > MAX_TABLE_SIZE) {\n            nukeSymbols();\n            return;\n        }\n        \n        _mainHash = new int[newLen];\n        _mainHashMask = (newLen - 1);\n        Name[] oldNames = _mainNames;\n        _mainNames = new Name[newLen];\n        int symbolsSeen = 0; // let's do a sanity check\n        for (int i = 0; i < len; ++i) {\n            Name symbol = oldNames[i];\n            if (symbol != null) {\n                ++symbolsSeen;\n                int hash = symbol.hashCode();\n                int ix = (hash & _mainHashMask);\n                _mainNames[ix] = symbol;\n                _mainHash[ix] = hash << 8; // will clear spill index\n            }\n        }\n\n        /* And then the spill area. This may cause collisions, although\n         * not necessarily as many as there were earlier. Let's allocate\n         * same amount of space, however\n         */\n        int oldEnd = _collEnd;\n        if (oldEnd == 0) { // no prior collisions...\n            _longestCollisionList = 0;\n            return;\n        }\n\n        _collCount = 0;\n        _collEnd = 0;\n        _collListShared = false;\n\n        int maxColl = 0;\n        \n        Bucket[] oldBuckets = _collList;\n        _collList = new Bucket[oldBuckets.length];\n        for (int i = 0; i < oldEnd; ++i) {\n            for (Bucket curr = oldBuckets[i]; curr != null; curr = curr._next) {\n                ++symbolsSeen;\n                Name symbol = curr._name;\n                int hash = symbol.hashCode();\n                int ix = (hash & _mainHashMask);\n                int val = _mainHash[ix];\n                if (_mainNames[ix] == null) { // no primary entry?\n_mainHash[ix] = (_mainHash[ix] >>> 8);\n                    _mainNames[ix] = symbol;\n                } else { // nope, it's a collision, need to spill over\n                    ++_collCount;\n                    int bucket = val & 0xFF;\n                    if (bucket == 0) { // first spill over?\n                        if (_collEnd <= LAST_VALID_BUCKET) { // yup, still unshared bucket\n                            bucket = _collEnd;\n                            ++_collEnd;\n                            // need to expand?\n                            if (bucket >= _collList.length) {\n                                expandCollision();\n                            }\n                        } else { // nope, have to share... let's find shortest?\n                            bucket = findBestBucket();\n                        }\n                        // Need to mark the entry... and the spill index is 1-based\n                        _mainHash[ix] = (val & ~0xFF) | (bucket + 1);\n                    } else {\n                        --bucket; // 1-based index in value\n                    }\n                    // And then just need to link the new bucket entry in\n                    Bucket newB = new Bucket(symbol, _collList[bucket]);\n                    _collList[bucket] = newB;\n                    maxColl = Math.max(maxColl, newB.length());\n                }\n            } // for (... buckets in the chain ...)\n        } // for (... list of bucket heads ... )\n\n        _longestCollisionList = maxColl;\n        \n        if (symbolsSeen != _count) { // sanity check\n            throw new RuntimeException(\"Internal error: count after rehash \"+symbolsSeen+\"; should be \"+_count);\n        }\n    }",
          "58": "    private void rehash()\n    {\n        _needRehash = false;        \n        // Note: since we'll make copies, no need to unshare, can just mark as such:\n        _mainNamesShared = false;\n\n        /* And then we can first deal with the main hash area. Since we\n         * are expanding linearly (double up), we know there'll be no\n         * collisions during this phase.\n         */\n        int[] oldMainHash = _mainHash;\n        int len = oldMainHash.length;\n        int newLen = len+len;\n\n        /* 13-Mar-2010, tatu: Let's guard against OOME that could be caused by\n         *    large documents with unique (or mostly so) names\n         */\n        if (newLen > MAX_TABLE_SIZE) {\n            nukeSymbols();\n            return;\n        }\n        \n        _mainHash = new int[newLen];\n        _mainHashMask = (newLen - 1);\n        Name[] oldNames = _mainNames;\n        _mainNames = new Name[newLen];\n        int symbolsSeen = 0; // let's do a sanity check\n        for (int i = 0; i < len; ++i) {\n            Name symbol = oldNames[i];\n            if (symbol != null) {\n                ++symbolsSeen;\n                int hash = symbol.hashCode();\n                int ix = (hash & _mainHashMask);\n                _mainNames[ix] = symbol;\n                _mainHash[ix] = hash << 8; // will clear spill index\n            }\n        }\n\n        /* And then the spill area. This may cause collisions, although\n         * not necessarily as many as there were earlier. Let's allocate\n         * same amount of space, however\n         */\n        int oldEnd = _collEnd;\n        if (oldEnd == 0) { // no prior collisions...\n            _longestCollisionList = 0;\n            return;\n        }\n\n        _collCount = 0;\n        _collEnd = 0;\n        _collListShared = false;\n\n        int maxColl = 0;\n        \n        Bucket[] oldBuckets = _collList;\n        _collList = new Bucket[oldBuckets.length];\n        for (int i = 0; i < oldEnd; ++i) {\n            for (Bucket curr = oldBuckets[i]; curr != null; curr = curr._next) {\n                ++symbolsSeen;\n                Name symbol = curr._name;\n                int hash = symbol.hashCode();\n                int ix = (hash & _mainHashMask);\n                int val = _mainHash[ix];\n                if (_mainNames[ix] == null) { // no primary entry?\nix[ix] = (hash >>> 8);\n                    _mainNames[ix] = symbol;\n                } else { // nope, it's a collision, need to spill over\n                    ++_collCount;\n                    int bucket = val & 0xFF;\n                    if (bucket == 0) { // first spill over?\n                        if (_collEnd <= LAST_VALID_BUCKET) { // yup, still unshared bucket\n                            bucket = _collEnd;\n                            ++_collEnd;\n                            // need to expand?\n                            if (bucket >= _collList.length) {\n                                expandCollision();\n                            }\n                        } else { // nope, have to share... let's find shortest?\n                            bucket = findBestBucket();\n                        }\n                        // Need to mark the entry... and the spill index is 1-based\n                        _mainHash[ix] = (val & ~0xFF) | (bucket + 1);\n                    } else {\n                        --bucket; // 1-based index in value\n                    }\n                    // And then just need to link the new bucket entry in\n                    Bucket newB = new Bucket(symbol, _collList[bucket]);\n                    _collList[bucket] = newB;\n                    maxColl = Math.max(maxColl, newB.length());\n                }\n            } // for (... buckets in the chain ...)\n        } // for (... list of bucket heads ... )\n\n        _longestCollisionList = maxColl;\n        \n        if (symbolsSeen != _count) { // sanity check\n            throw new RuntimeException(\"Internal error: count after rehash \"+symbolsSeen+\"; should be \"+_count);\n        }\n    }",
          "59": "    private void rehash()\n    {\n        _needRehash = false;        \n        // Note: since we'll make copies, no need to unshare, can just mark as such:\n        _mainNamesShared = false;\n\n        /* And then we can first deal with the main hash area. Since we\n         * are expanding linearly (double up), we know there'll be no\n         * collisions during this phase.\n         */\n        int[] oldMainHash = _mainHash;\n        int len = oldMainHash.length;\n        int newLen = len+len;\n\n        /* 13-Mar-2010, tatu: Let's guard against OOME that could be caused by\n         *    large documents with unique (or mostly so) names\n         */\n        if (newLen > MAX_TABLE_SIZE) {\n            nukeSymbols();\n            return;\n        }\n        \n        _mainHash = new int[newLen];\n        _mainHashMask = (newLen - 1);\n        Name[] oldNames = _mainNames;\n        _mainNames = new Name[newLen];\n        int symbolsSeen = 0; // let's do a sanity check\n        for (int i = 0; i < len; ++i) {\n            Name symbol = oldNames[i];\n            if (symbol != null) {\n                ++symbolsSeen;\n                int hash = symbol.hashCode();\n                int ix = (hash & _mainHashMask);\n                _mainNames[ix] = symbol;\n                _mainHash[ix] = hash << 8; // will clear spill index\n            }\n        }\n\n        /* And then the spill area. This may cause collisions, although\n         * not necessarily as many as there were earlier. Let's allocate\n         * same amount of space, however\n         */\n        int oldEnd = _collEnd;\n        if (oldEnd == 0) { // no prior collisions...\n            _longestCollisionList = 0;\n            return;\n        }\n\n        _collCount = 0;\n        _collEnd = 0;\n        _collListShared = false;\n\n        int maxColl = 0;\n        \n        Bucket[] oldBuckets = _collList;\n        _collList = new Bucket[oldBuckets.length];\n        for (int i = 0; i < oldEnd; ++i) {\n            for (Bucket curr = oldBuckets[i]; curr != null; curr = curr._next) {\n                ++symbolsSeen;\n                Name symbol = curr._name;\n                int hash = symbol.hashCode();\n                int ix = (hash & _mainHashMask);\n                int val = _mainHash[ix];\n                if (_mainNames[ix] == null) { // no primary entry?\nmaxColl = Math.max(maxColl, newB.length());\n                    _mainHash[ix] = (hash >>> 8);                    _mainNames[ix] = symbol;\n                } else { // nope, it's a collision, need to spill over\n                    ++_collCount;\n                    int bucket = val & 0xFF;\n                    if (bucket == 0) { // first spill over?\n                        if (_collEnd <= LAST_VALID_BUCKET) { // yup, still unshared bucket\n                            bucket = _collEnd;\n                            ++_collEnd;\n                            // need to expand?\n                            if (bucket >= _collList.length) {\n                                expandCollision();\n                            }\n                        } else { // nope, have to share... let's find shortest?\n                            bucket = findBestBucket();\n                        }\n                        // Need to mark the entry... and the spill index is 1-based\n                        _mainHash[ix] = (val & ~0xFF) | (bucket + 1);\n                    } else {\n                        --bucket; // 1-based index in value\n                    }\n                    // And then just need to link the new bucket entry in\n                    Bucket newB = new Bucket(symbol, _collList[bucket]);\n                    _collList[bucket] = newB;\n                    maxColl = Math.max(maxColl, newB.length());\n                }\n            } // for (... buckets in the chain ...)\n        } // for (... list of bucket heads ... )\n\n        _longestCollisionList = maxColl;\n        \n        if (symbolsSeen != _count) { // sanity check\n            throw new RuntimeException(\"Internal error: count after rehash \"+symbolsSeen+\"; should be \"+_count);\n        }\n    }",
          "60": "    private void rehash()\n    {\n        _needRehash = false;        \n        // Note: since we'll make copies, no need to unshare, can just mark as such:\n        _mainNamesShared = false;\n\n        /* And then we can first deal with the main hash area. Since we\n         * are expanding linearly (double up), we know there'll be no\n         * collisions during this phase.\n         */\n        int[] oldMainHash = _mainHash;\n        int len = oldMainHash.length;\n        int newLen = len+len;\n\n        /* 13-Mar-2010, tatu: Let's guard against OOME that could be caused by\n         *    large documents with unique (or mostly so) names\n         */\n        if (newLen > MAX_TABLE_SIZE) {\n            nukeSymbols();\n            return;\n        }\n        \n        _mainHash = new int[newLen];\n        _mainHashMask = (newLen - 1);\n        Name[] oldNames = _mainNames;\n        _mainNames = new Name[newLen];\n        int symbolsSeen = 0; // let's do a sanity check\n        for (int i = 0; i < len; ++i) {\n            Name symbol = oldNames[i];\n            if (symbol != null) {\n                ++symbolsSeen;\n                int hash = symbol.hashCode();\n                int ix = (hash & _mainHashMask);\n                _mainNames[ix] = symbol;\n                _mainHash[ix] = hash << 8; // will clear spill index\n            }\n        }\n\n        /* And then the spill area. This may cause collisions, although\n         * not necessarily as many as there were earlier. Let's allocate\n         * same amount of space, however\n         */\n        int oldEnd = _collEnd;\n        if (oldEnd == 0) { // no prior collisions...\n            _longestCollisionList = 0;\n            return;\n        }\n\n        _collCount = 0;\n        _collEnd = 0;\n        _collListShared = false;\n\n        int maxColl = 0;\n        \n        Bucket[] oldBuckets = _collList;\n        _collList = new Bucket[oldBuckets.length];\n        for (int i = 0; i < oldEnd; ++i) {\n            for (Bucket curr = oldBuckets[i]; curr != null; curr = curr._next) {\n                ++symbolsSeen;\n                Name symbol = curr._name;\n                int hash = symbol.hashCode();\n                int ix = (hash & _mainHashMask);\n                int val = _mainHash[ix];\n                if (_mainNames[ix] == null) { // no primary entry?\nif((val & ~0xFF)){\n                    _mainHash[ix] = (hash >>> 8);                    _mainNames[ix] = symbol;\n                } else { // nope, it's a collision, need to spill over\n                    ++_collCount;\n                    int bucket = val & 0xFF;\n                    if (bucket == 0) { // first spill over?\n                        if (_collEnd <= LAST_VALID_BUCKET) { // yup, still unshared bucket\n                            bucket = _collEnd;\n                            ++_collEnd;\n                            // need to expand?\n                            if (bucket >= _collList.length) {\n                                expandCollision();\n                            }\n                        } else { // nope, have to share... let's find shortest?\n                            bucket = findBestBucket();\n                        }\n                        // Need to mark the entry... and the spill index is 1-based\n                        _mainHash[ix] = (val & ~0xFF) | (bucket + 1);\n                    } else {\n                        --bucket; // 1-based index in value\n                    }\n                    // And then just need to link the new bucket entry in\n                    Bucket newB = new Bucket(symbol, _collList[bucket]);\n                    _collList[bucket] = newB;\n                    maxColl = Math.max(maxColl, newB.length());\n}\n                }\n            } // for (... buckets in the chain ...)\n        } // for (... list of bucket heads ... )\n\n        _longestCollisionList = maxColl;\n        \n        if (symbolsSeen != _count) { // sanity check\n            throw new RuntimeException(\"Internal error: count after rehash \"+symbolsSeen+\"; should be \"+_count);\n        }\n    }",
          "61": "    private void rehash()\n    {\n        _needRehash = false;        \n        // Note: since we'll make copies, no need to unshare, can just mark as such:\n        _mainNamesShared = false;\n\n        /* And then we can first deal with the main hash area. Since we\n         * are expanding linearly (double up), we know there'll be no\n         * collisions during this phase.\n         */\n        int[] oldMainHash = _mainHash;\n        int len = oldMainHash.length;\n        int newLen = len+len;\n\n        /* 13-Mar-2010, tatu: Let's guard against OOME that could be caused by\n         *    large documents with unique (or mostly so) names\n         */\n        if (newLen > MAX_TABLE_SIZE) {\n            nukeSymbols();\n            return;\n        }\n        \n        _mainHash = new int[newLen];\n        _mainHashMask = (newLen - 1);\n        Name[] oldNames = _mainNames;\n        _mainNames = new Name[newLen];\n        int symbolsSeen = 0; // let's do a sanity check\n        for (int i = 0; i < len; ++i) {\n            Name symbol = oldNames[i];\n            if (symbol != null) {\n                ++symbolsSeen;\n                int hash = symbol.hashCode();\n                int ix = (hash & _mainHashMask);\n                _mainNames[ix] = symbol;\n                _mainHash[ix] = hash << 8; // will clear spill index\n            }\n        }\n\n        /* And then the spill area. This may cause collisions, although\n         * not necessarily as many as there were earlier. Let's allocate\n         * same amount of space, however\n         */\n        int oldEnd = _collEnd;\n        if (oldEnd == 0) { // no prior collisions...\n            _longestCollisionList = 0;\n            return;\n        }\n\n        _collCount = 0;\n        _collEnd = 0;\n        _collListShared = false;\n\n        int maxColl = 0;\n        \n        Bucket[] oldBuckets = _collList;\n        _collList = new Bucket[oldBuckets.length];\n        for (int i = 0; i < oldEnd; ++i) {\n            for (Bucket curr = oldBuckets[i]; curr != null; curr = curr._next) {\n                ++symbolsSeen;\n                Name symbol = curr._name;\n                int hash = symbol.hashCode();\n                int ix = (hash & _mainHashMask);\n                int val = _mainHash[ix];\n                if (_mainNames[ix] == null) { // no primary entry?\n_mainHash[ix] = (symbol >>> 8);\n                    _mainNames[ix] = symbol;\n                } else { // nope, it's a collision, need to spill over\n                    ++_collCount;\n                    int bucket = val & 0xFF;\n                    if (bucket == 0) { // first spill over?\n                        if (_collEnd <= LAST_VALID_BUCKET) { // yup, still unshared bucket\n                            bucket = _collEnd;\n                            ++_collEnd;\n                            // need to expand?\n                            if (bucket >= _collList.length) {\n                                expandCollision();\n                            }\n                        } else { // nope, have to share... let's find shortest?\n                            bucket = findBestBucket();\n                        }\n                        // Need to mark the entry... and the spill index is 1-based\n                        _mainHash[ix] = (val & ~0xFF) | (bucket + 1);\n                    } else {\n                        --bucket; // 1-based index in value\n                    }\n                    // And then just need to link the new bucket entry in\n                    Bucket newB = new Bucket(symbol, _collList[bucket]);\n                    _collList[bucket] = newB;\n                    maxColl = Math.max(maxColl, newB.length());\n                }\n            } // for (... buckets in the chain ...)\n        } // for (... list of bucket heads ... )\n\n        _longestCollisionList = maxColl;\n        \n        if (symbolsSeen != _count) { // sanity check\n            throw new RuntimeException(\"Internal error: count after rehash \"+symbolsSeen+\"; should be \"+_count);\n        }\n    }",
          "62": "    private void rehash()\n    {\n        _needRehash = false;        \n        // Note: since we'll make copies, no need to unshare, can just mark as such:\n        _mainNamesShared = false;\n\n        /* And then we can first deal with the main hash area. Since we\n         * are expanding linearly (double up), we know there'll be no\n         * collisions during this phase.\n         */\n        int[] oldMainHash = _mainHash;\n        int len = oldMainHash.length;\n        int newLen = len+len;\n\n        /* 13-Mar-2010, tatu: Let's guard against OOME that could be caused by\n         *    large documents with unique (or mostly so) names\n         */\n        if (newLen > MAX_TABLE_SIZE) {\n            nukeSymbols();\n            return;\n        }\n        \n        _mainHash = new int[newLen];\n        _mainHashMask = (newLen - 1);\n        Name[] oldNames = _mainNames;\n        _mainNames = new Name[newLen];\n        int symbolsSeen = 0; // let's do a sanity check\n        for (int i = 0; i < len; ++i) {\n            Name symbol = oldNames[i];\n            if (symbol != null) {\n                ++symbolsSeen;\n                int hash = symbol.hashCode();\n                int ix = (hash & _mainHashMask);\n                _mainNames[ix] = symbol;\n                _mainHash[ix] = hash << 8; // will clear spill index\n            }\n        }\n\n        /* And then the spill area. This may cause collisions, although\n         * not necessarily as many as there were earlier. Let's allocate\n         * same amount of space, however\n         */\n        int oldEnd = _collEnd;\n        if (oldEnd == 0) { // no prior collisions...\n            _longestCollisionList = 0;\n            return;\n        }\n\n        _collCount = 0;\n        _collEnd = 0;\n        _collListShared = false;\n\n        int maxColl = 0;\n        \n        Bucket[] oldBuckets = _collList;\n        _collList = new Bucket[oldBuckets.length];\n        for (int i = 0; i < oldEnd; ++i) {\n            for (Bucket curr = oldBuckets[i]; curr != null; curr = curr._next) {\n                ++symbolsSeen;\n                Name symbol = curr._name;\n                int hash = symbol.hashCode();\n                int ix = (hash & _mainHashMask);\n                int val = _mainHash[ix];\n                if (_mainNames[ix] == null) { // no primary entry?\nif((bucket == 0)){\n                    _mainHash[ix] = (hash >>> 8);                    _mainNames[ix] = symbol;\n                } else { // nope, it's a collision, need to spill over\n                    ++_collCount;\n                    int bucket = val & 0xFF;\n                    if (bucket == 0) { // first spill over?\n                        if (_collEnd <= LAST_VALID_BUCKET) { // yup, still unshared bucket\n                            bucket = _collEnd;\n                            ++_collEnd;\n                            // need to expand?\n                            if (bucket >= _collList.length) {\n                                expandCollision();\n                            }\n                        } else { // nope, have to share... let's find shortest?\n                            bucket = findBestBucket();\n                        }\n                        // Need to mark the entry... and the spill index is 1-based\n                        _mainHash[ix] = (val & ~0xFF) | (bucket + 1);\n                    } else {\n                        --bucket; // 1-based index in value\n                    }\n                    // And then just need to link the new bucket entry in\n                    Bucket newB = new Bucket(symbol, _collList[bucket]);\n                    _collList[bucket] = newB;\n                    maxColl = Math.max(maxColl, newB.length());\n}\n                }\n            } // for (... buckets in the chain ...)\n        } // for (... list of bucket heads ... )\n\n        _longestCollisionList = maxColl;\n        \n        if (symbolsSeen != _count) { // sanity check\n            throw new RuntimeException(\"Internal error: count after rehash \"+symbolsSeen+\"; should be \"+_count);\n        }\n    }",
          "63": "    private void rehash()\n    {\n        _needRehash = false;        \n        // Note: since we'll make copies, no need to unshare, can just mark as such:\n        _mainNamesShared = false;\n\n        /* And then we can first deal with the main hash area. Since we\n         * are expanding linearly (double up), we know there'll be no\n         * collisions during this phase.\n         */\n        int[] oldMainHash = _mainHash;\n        int len = oldMainHash.length;\n        int newLen = len+len;\n\n        /* 13-Mar-2010, tatu: Let's guard against OOME that could be caused by\n         *    large documents with unique (or mostly so) names\n         */\n        if (newLen > MAX_TABLE_SIZE) {\n            nukeSymbols();\n            return;\n        }\n        \n        _mainHash = new int[newLen];\n        _mainHashMask = (newLen - 1);\n        Name[] oldNames = _mainNames;\n        _mainNames = new Name[newLen];\n        int symbolsSeen = 0; // let's do a sanity check\n        for (int i = 0; i < len; ++i) {\n            Name symbol = oldNames[i];\n            if (symbol != null) {\n                ++symbolsSeen;\n                int hash = symbol.hashCode();\n                int ix = (hash & _mainHashMask);\n                _mainNames[ix] = symbol;\n                _mainHash[ix] = hash << 8; // will clear spill index\n            }\n        }\n\n        /* And then the spill area. This may cause collisions, although\n         * not necessarily as many as there were earlier. Let's allocate\n         * same amount of space, however\n         */\n        int oldEnd = _collEnd;\n        if (oldEnd == 0) { // no prior collisions...\n            _longestCollisionList = 0;\n            return;\n        }\n\n        _collCount = 0;\n        _collEnd = 0;\n        _collListShared = false;\n\n        int maxColl = 0;\n        \n        Bucket[] oldBuckets = _collList;\n        _collList = new Bucket[oldBuckets.length];\n        for (int i = 0; i < oldEnd; ++i) {\n            for (Bucket curr = oldBuckets[i]; curr != null; curr = curr._next) {\n                ++symbolsSeen;\n                Name symbol = curr._name;\n                int hash = symbol.hashCode();\n                int ix = (hash & _mainHashMask);\n                int val = _mainHash[ix];\n                if (_mainNames[ix] == null) { // no primary entry?\nfor(Bucket curr = oldBuckets[i];(curr != null);curr = curr._next) {                    _mainHash[ix] = (hash >>> 8);                    _mainNames[ix] = symbol;\n                } else { // nope, it's a collision, need to spill over\n                    ++_collCount;\n                    int bucket = val & 0xFF;\n                    if (bucket == 0) { // first spill over?\n                        if (_collEnd <= LAST_VALID_BUCKET) { // yup, still unshared bucket\n                            bucket = _collEnd;\n                            ++_collEnd;\n                            // need to expand?\n                            if (bucket >= _collList.length) {\n                                expandCollision();\n                            }\n                        } else { // nope, have to share... let's find shortest?\n                            bucket = findBestBucket();\n                        }\n                        // Need to mark the entry... and the spill index is 1-based\n                        _mainHash[ix] = (val & ~0xFF) | (bucket + 1);\n                    } else {\n                        --bucket; // 1-based index in value\n                    }\n                    // And then just need to link the new bucket entry in\n                    Bucket newB = new Bucket(symbol, _collList[bucket]);\n                    _collList[bucket] = newB;\n                    maxColl = Math.max(maxColl, newB.length());\n                }\n            } // for (... buckets in the chain ...)\n        } // for (... list of bucket heads ... )\n\n        _longestCollisionList = maxColl;\n        \n        if (symbolsSeen != _count) { // sanity check\n            throw new RuntimeException(\"Internal error: count after rehash \"+symbolsSeen+\"; should be \"+_count);\n        }\n    }",
          "64": "    private void rehash()\n    {\n        _needRehash = false;        \n        // Note: since we'll make copies, no need to unshare, can just mark as such:\n        _mainNamesShared = false;\n\n        /* And then we can first deal with the main hash area. Since we\n         * are expanding linearly (double up), we know there'll be no\n         * collisions during this phase.\n         */\n        int[] oldMainHash = _mainHash;\n        int len = oldMainHash.length;\n        int newLen = len+len;\n\n        /* 13-Mar-2010, tatu: Let's guard against OOME that could be caused by\n         *    large documents with unique (or mostly so) names\n         */\n        if (newLen > MAX_TABLE_SIZE) {\n            nukeSymbols();\n            return;\n        }\n        \n        _mainHash = new int[newLen];\n        _mainHashMask = (newLen - 1);\n        Name[] oldNames = _mainNames;\n        _mainNames = new Name[newLen];\n        int symbolsSeen = 0; // let's do a sanity check\n        for (int i = 0; i < len; ++i) {\n            Name symbol = oldNames[i];\n            if (symbol != null) {\n                ++symbolsSeen;\n                int hash = symbol.hashCode();\n                int ix = (hash & _mainHashMask);\n                _mainNames[ix] = symbol;\n                _mainHash[ix] = hash << 8; // will clear spill index\n            }\n        }\n\n        /* And then the spill area. This may cause collisions, although\n         * not necessarily as many as there were earlier. Let's allocate\n         * same amount of space, however\n         */\n        int oldEnd = _collEnd;\n        if (oldEnd == 0) { // no prior collisions...\n            _longestCollisionList = 0;\n            return;\n        }\n\n        _collCount = 0;\n        _collEnd = 0;\n        _collListShared = false;\n\n        int maxColl = 0;\n        \n        Bucket[] oldBuckets = _collList;\n        _collList = new Bucket[oldBuckets.length];\n        for (int i = 0; i < oldEnd; ++i) {\n            for (Bucket curr = oldBuckets[i]; curr != null; curr = curr._next) {\n                ++symbolsSeen;\n                Name symbol = curr._name;\n                int hash = symbol.hashCode();\n                int ix = (hash & _mainHashMask);\n                int val = _mainHash[ix];\n                if (_mainNames[ix] == null) { // no primary entry?\n_mainHash[ix] = (hash >>> 1);\n                    _mainNames[ix] = symbol;\n                } else { // nope, it's a collision, need to spill over\n                    ++_collCount;\n                    int bucket = val & 0xFF;\n                    if (bucket == 0) { // first spill over?\n                        if (_collEnd <= LAST_VALID_BUCKET) { // yup, still unshared bucket\n                            bucket = _collEnd;\n                            ++_collEnd;\n                            // need to expand?\n                            if (bucket >= _collList.length) {\n                                expandCollision();\n                            }\n                        } else { // nope, have to share... let's find shortest?\n                            bucket = findBestBucket();\n                        }\n                        // Need to mark the entry... and the spill index is 1-based\n                        _mainHash[ix] = (val & ~0xFF) | (bucket + 1);\n                    } else {\n                        --bucket; // 1-based index in value\n                    }\n                    // And then just need to link the new bucket entry in\n                    Bucket newB = new Bucket(symbol, _collList[bucket]);\n                    _collList[bucket] = newB;\n                    maxColl = Math.max(maxColl, newB.length());\n                }\n            } // for (... buckets in the chain ...)\n        } // for (... list of bucket heads ... )\n\n        _longestCollisionList = maxColl;\n        \n        if (symbolsSeen != _count) { // sanity check\n            throw new RuntimeException(\"Internal error: count after rehash \"+symbolsSeen+\"; should be \"+_count);\n        }\n    }",
          "65": "    private void rehash()\n    {\n        _needRehash = false;        \n        // Note: since we'll make copies, no need to unshare, can just mark as such:\n        _mainNamesShared = false;\n\n        /* And then we can first deal with the main hash area. Since we\n         * are expanding linearly (double up), we know there'll be no\n         * collisions during this phase.\n         */\n        int[] oldMainHash = _mainHash;\n        int len = oldMainHash.length;\n        int newLen = len+len;\n\n        /* 13-Mar-2010, tatu: Let's guard against OOME that could be caused by\n         *    large documents with unique (or mostly so) names\n         */\n        if (newLen > MAX_TABLE_SIZE) {\n            nukeSymbols();\n            return;\n        }\n        \n        _mainHash = new int[newLen];\n        _mainHashMask = (newLen - 1);\n        Name[] oldNames = _mainNames;\n        _mainNames = new Name[newLen];\n        int symbolsSeen = 0; // let's do a sanity check\n        for (int i = 0; i < len; ++i) {\n            Name symbol = oldNames[i];\n            if (symbol != null) {\n                ++symbolsSeen;\n                int hash = symbol.hashCode();\n                int ix = (hash & _mainHashMask);\n                _mainNames[ix] = symbol;\n                _mainHash[ix] = hash << 8; // will clear spill index\n            }\n        }\n\n        /* And then the spill area. This may cause collisions, although\n         * not necessarily as many as there were earlier. Let's allocate\n         * same amount of space, however\n         */\n        int oldEnd = _collEnd;\n        if (oldEnd == 0) { // no prior collisions...\n            _longestCollisionList = 0;\n            return;\n        }\n\n        _collCount = 0;\n        _collEnd = 0;\n        _collListShared = false;\n\n        int maxColl = 0;\n        \n        Bucket[] oldBuckets = _collList;\n        _collList = new Bucket[oldBuckets.length];\n        for (int i = 0; i < oldEnd; ++i) {\n            for (Bucket curr = oldBuckets[i]; curr != null; curr = curr._next) {\n                ++symbolsSeen;\n                Name symbol = curr._name;\n                int hash = symbol.hashCode();\n                int ix = (hash & _mainHashMask);\n                int val = _mainHash[ix];\n                if (_mainNames[ix] == null) { // no primary entry?\nreturn;\n                    _mainNames[ix] = symbol;\n                } else { // nope, it's a collision, need to spill over\n                    ++_collCount;\n                    int bucket = val & 0xFF;\n                    if (bucket == 0) { // first spill over?\n                        if (_collEnd <= LAST_VALID_BUCKET) { // yup, still unshared bucket\n                            bucket = _collEnd;\n                            ++_collEnd;\n                            // need to expand?\n                            if (bucket >= _collList.length) {\n                                expandCollision();\n                            }\n                        } else { // nope, have to share... let's find shortest?\n                            bucket = findBestBucket();\n                        }\n                        // Need to mark the entry... and the spill index is 1-based\n                        _mainHash[ix] = (val & ~0xFF) | (bucket + 1);\n                    } else {\n                        --bucket; // 1-based index in value\n                    }\n                    // And then just need to link the new bucket entry in\n                    Bucket newB = new Bucket(symbol, _collList[bucket]);\n                    _collList[bucket] = newB;\n                    maxColl = Math.max(maxColl, newB.length());\n                }\n            } // for (... buckets in the chain ...)\n        } // for (... list of bucket heads ... )\n\n        _longestCollisionList = maxColl;\n        \n        if (symbolsSeen != _count) { // sanity check\n            throw new RuntimeException(\"Internal error: count after rehash \"+symbolsSeen+\"; should be \"+_count);\n        }\n    }",
          "66": "    private void rehash()\n    {\n        _needRehash = false;        \n        // Note: since we'll make copies, no need to unshare, can just mark as such:\n        _mainNamesShared = false;\n\n        /* And then we can first deal with the main hash area. Since we\n         * are expanding linearly (double up), we know there'll be no\n         * collisions during this phase.\n         */\n        int[] oldMainHash = _mainHash;\n        int len = oldMainHash.length;\n        int newLen = len+len;\n\n        /* 13-Mar-2010, tatu: Let's guard against OOME that could be caused by\n         *    large documents with unique (or mostly so) names\n         */\n        if (newLen > MAX_TABLE_SIZE) {\n            nukeSymbols();\n            return;\n        }\n        \n        _mainHash = new int[newLen];\n        _mainHashMask = (newLen - 1);\n        Name[] oldNames = _mainNames;\n        _mainNames = new Name[newLen];\n        int symbolsSeen = 0; // let's do a sanity check\n        for (int i = 0; i < len; ++i) {\n            Name symbol = oldNames[i];\n            if (symbol != null) {\n                ++symbolsSeen;\n                int hash = symbol.hashCode();\n                int ix = (hash & _mainHashMask);\n                _mainNames[ix] = symbol;\n                _mainHash[ix] = hash << 8; // will clear spill index\n            }\n        }\n\n        /* And then the spill area. This may cause collisions, although\n         * not necessarily as many as there were earlier. Let's allocate\n         * same amount of space, however\n         */\n        int oldEnd = _collEnd;\n        if (oldEnd == 0) { // no prior collisions...\n            _longestCollisionList = 0;\n            return;\n        }\n\n        _collCount = 0;\n        _collEnd = 0;\n        _collListShared = false;\n\n        int maxColl = 0;\n        \n        Bucket[] oldBuckets = _collList;\n        _collList = new Bucket[oldBuckets.length];\n        for (int i = 0; i < oldEnd; ++i) {\n            for (Bucket curr = oldBuckets[i]; curr != null; curr = curr._next) {\n                ++symbolsSeen;\n                Name symbol = curr._name;\n                int hash = symbol.hashCode();\n                int ix = (hash & _mainHashMask);\n                int val = _mainHash[ix];\n                if (_mainNames[ix] == null) { // no primary entry?\n_mainHash[ix] = (hash >>> null);\n                    _mainNames[ix] = symbol;\n                } else { // nope, it's a collision, need to spill over\n                    ++_collCount;\n                    int bucket = val & 0xFF;\n                    if (bucket == 0) { // first spill over?\n                        if (_collEnd <= LAST_VALID_BUCKET) { // yup, still unshared bucket\n                            bucket = _collEnd;\n                            ++_collEnd;\n                            // need to expand?\n                            if (bucket >= _collList.length) {\n                                expandCollision();\n                            }\n                        } else { // nope, have to share... let's find shortest?\n                            bucket = findBestBucket();\n                        }\n                        // Need to mark the entry... and the spill index is 1-based\n                        _mainHash[ix] = (val & ~0xFF) | (bucket + 1);\n                    } else {\n                        --bucket; // 1-based index in value\n                    }\n                    // And then just need to link the new bucket entry in\n                    Bucket newB = new Bucket(symbol, _collList[bucket]);\n                    _collList[bucket] = newB;\n                    maxColl = Math.max(maxColl, newB.length());\n                }\n            } // for (... buckets in the chain ...)\n        } // for (... list of bucket heads ... )\n\n        _longestCollisionList = maxColl;\n        \n        if (symbolsSeen != _count) { // sanity check\n            throw new RuntimeException(\"Internal error: count after rehash \"+symbolsSeen+\"; should be \"+_count);\n        }\n    }",
          "67": "    private void rehash()\n    {\n        _needRehash = false;        \n        // Note: since we'll make copies, no need to unshare, can just mark as such:\n        _mainNamesShared = false;\n\n        /* And then we can first deal with the main hash area. Since we\n         * are expanding linearly (double up), we know there'll be no\n         * collisions during this phase.\n         */\n        int[] oldMainHash = _mainHash;\n        int len = oldMainHash.length;\n        int newLen = len+len;\n\n        /* 13-Mar-2010, tatu: Let's guard against OOME that could be caused by\n         *    large documents with unique (or mostly so) names\n         */\n        if (newLen > MAX_TABLE_SIZE) {\n            nukeSymbols();\n            return;\n        }\n        \n        _mainHash = new int[newLen];\n        _mainHashMask = (newLen - 1);\n        Name[] oldNames = _mainNames;\n        _mainNames = new Name[newLen];\n        int symbolsSeen = 0; // let's do a sanity check\n        for (int i = 0; i < len; ++i) {\n            Name symbol = oldNames[i];\n            if (symbol != null) {\n                ++symbolsSeen;\n                int hash = symbol.hashCode();\n                int ix = (hash & _mainHashMask);\n                _mainNames[ix] = symbol;\n                _mainHash[ix] = hash << 8; // will clear spill index\n            }\n        }\n\n        /* And then the spill area. This may cause collisions, although\n         * not necessarily as many as there were earlier. Let's allocate\n         * same amount of space, however\n         */\n        int oldEnd = _collEnd;\n        if (oldEnd == 0) { // no prior collisions...\n            _longestCollisionList = 0;\n            return;\n        }\n\n        _collCount = 0;\n        _collEnd = 0;\n        _collListShared = false;\n\n        int maxColl = 0;\n        \n        Bucket[] oldBuckets = _collList;\n        _collList = new Bucket[oldBuckets.length];\n        for (int i = 0; i < oldEnd; ++i) {\n            for (Bucket curr = oldBuckets[i]; curr != null; curr = curr._next) {\n                ++symbolsSeen;\n                Name symbol = curr._name;\n                int hash = symbol.hashCode();\n                int ix = (hash & _mainHashMask);\n                int val = _mainHash[ix];\n                if (_mainNames[ix] == null) { // no primary entry?\nfor(int i = 0;(i < oldEnd);++i) {                    _mainHash[ix] = (hash >>> 8);                    _mainNames[ix] = symbol;\n                } else { // nope, it's a collision, need to spill over\n                    ++_collCount;\n                    int bucket = val & 0xFF;\n                    if (bucket == 0) { // first spill over?\n                        if (_collEnd <= LAST_VALID_BUCKET) { // yup, still unshared bucket\n                            bucket = _collEnd;\n                            ++_collEnd;\n                            // need to expand?\n                            if (bucket >= _collList.length) {\n                                expandCollision();\n                            }\n                        } else { // nope, have to share... let's find shortest?\n                            bucket = findBestBucket();\n                        }\n                        // Need to mark the entry... and the spill index is 1-based\n                        _mainHash[ix] = (val & ~0xFF) | (bucket + 1);\n                    } else {\n                        --bucket; // 1-based index in value\n                    }\n                    // And then just need to link the new bucket entry in\n                    Bucket newB = new Bucket(symbol, _collList[bucket]);\n                    _collList[bucket] = newB;\n                    maxColl = Math.max(maxColl, newB.length());\n                }\n            } // for (... buckets in the chain ...)\n        } // for (... list of bucket heads ... )\n\n        _longestCollisionList = maxColl;\n        \n        if (symbolsSeen != _count) { // sanity check\n            throw new RuntimeException(\"Internal error: count after rehash \"+symbolsSeen+\"; should be \"+_count);\n        }\n    }",
          "68": "    private void rehash()\n    {\n        _needRehash = false;        \n        // Note: since we'll make copies, no need to unshare, can just mark as such:\n        _mainNamesShared = false;\n\n        /* And then we can first deal with the main hash area. Since we\n         * are expanding linearly (double up), we know there'll be no\n         * collisions during this phase.\n         */\n        int[] oldMainHash = _mainHash;\n        int len = oldMainHash.length;\n        int newLen = len+len;\n\n        /* 13-Mar-2010, tatu: Let's guard against OOME that could be caused by\n         *    large documents with unique (or mostly so) names\n         */\n        if (newLen > MAX_TABLE_SIZE) {\n            nukeSymbols();\n            return;\n        }\n        \n        _mainHash = new int[newLen];\n        _mainHashMask = (newLen - 1);\n        Name[] oldNames = _mainNames;\n        _mainNames = new Name[newLen];\n        int symbolsSeen = 0; // let's do a sanity check\n        for (int i = 0; i < len; ++i) {\n            Name symbol = oldNames[i];\n            if (symbol != null) {\n                ++symbolsSeen;\n                int hash = symbol.hashCode();\n                int ix = (hash & _mainHashMask);\n                _mainNames[ix] = symbol;\n                _mainHash[ix] = hash << 8; // will clear spill index\n            }\n        }\n\n        /* And then the spill area. This may cause collisions, although\n         * not necessarily as many as there were earlier. Let's allocate\n         * same amount of space, however\n         */\n        int oldEnd = _collEnd;\n        if (oldEnd == 0) { // no prior collisions...\n            _longestCollisionList = 0;\n            return;\n        }\n\n        _collCount = 0;\n        _collEnd = 0;\n        _collListShared = false;\n\n        int maxColl = 0;\n        \n        Bucket[] oldBuckets = _collList;\n        _collList = new Bucket[oldBuckets.length];\n        for (int i = 0; i < oldEnd; ++i) {\n            for (Bucket curr = oldBuckets[i]; curr != null; curr = curr._next) {\n                ++symbolsSeen;\n                Name symbol = curr._name;\n                int hash = symbol.hashCode();\n                int ix = (hash & _mainHashMask);\n                int val = _mainHash[ix];\n                if (_mainNames[ix] == null) { // no primary entry?\ncontinue;\n                    _mainHash[ix] = (hash >>> 8);                    _mainNames[ix] = symbol;\n                } else { // nope, it's a collision, need to spill over\n                    ++_collCount;\n                    int bucket = val & 0xFF;\n                    if (bucket == 0) { // first spill over?\n                        if (_collEnd <= LAST_VALID_BUCKET) { // yup, still unshared bucket\n                            bucket = _collEnd;\n                            ++_collEnd;\n                            // need to expand?\n                            if (bucket >= _collList.length) {\n                                expandCollision();\n                            }\n                        } else { // nope, have to share... let's find shortest?\n                            bucket = findBestBucket();\n                        }\n                        // Need to mark the entry... and the spill index is 1-based\n                        _mainHash[ix] = (val & ~0xFF) | (bucket + 1);\n                    } else {\n                        --bucket; // 1-based index in value\n                    }\n                    // And then just need to link the new bucket entry in\n                    Bucket newB = new Bucket(symbol, _collList[bucket]);\n                    _collList[bucket] = newB;\n                    maxColl = Math.max(maxColl, newB.length());\n                }\n            } // for (... buckets in the chain ...)\n        } // for (... list of bucket heads ... )\n\n        _longestCollisionList = maxColl;\n        \n        if (symbolsSeen != _count) { // sanity check\n            throw new RuntimeException(\"Internal error: count after rehash \"+symbolsSeen+\"; should be \"+_count);\n        }\n    }",
          "69": "    private void rehash()\n    {\n        _needRehash = false;        \n        // Note: since we'll make copies, no need to unshare, can just mark as such:\n        _mainNamesShared = false;\n\n        /* And then we can first deal with the main hash area. Since we\n         * are expanding linearly (double up), we know there'll be no\n         * collisions during this phase.\n         */\n        int[] oldMainHash = _mainHash;\n        int len = oldMainHash.length;\n        int newLen = len+len;\n\n        /* 13-Mar-2010, tatu: Let's guard against OOME that could be caused by\n         *    large documents with unique (or mostly so) names\n         */\n        if (newLen > MAX_TABLE_SIZE) {\n            nukeSymbols();\n            return;\n        }\n        \n        _mainHash = new int[newLen];\n        _mainHashMask = (newLen - 1);\n        Name[] oldNames = _mainNames;\n        _mainNames = new Name[newLen];\n        int symbolsSeen = 0; // let's do a sanity check\n        for (int i = 0; i < len; ++i) {\n            Name symbol = oldNames[i];\n            if (symbol != null) {\n                ++symbolsSeen;\n                int hash = symbol.hashCode();\n                int ix = (hash & _mainHashMask);\n                _mainNames[ix] = symbol;\n                _mainHash[ix] = hash << 8; // will clear spill index\n            }\n        }\n\n        /* And then the spill area. This may cause collisions, although\n         * not necessarily as many as there were earlier. Let's allocate\n         * same amount of space, however\n         */\n        int oldEnd = _collEnd;\n        if (oldEnd == 0) { // no prior collisions...\n            _longestCollisionList = 0;\n            return;\n        }\n\n        _collCount = 0;\n        _collEnd = 0;\n        _collListShared = false;\n\n        int maxColl = 0;\n        \n        Bucket[] oldBuckets = _collList;\n        _collList = new Bucket[oldBuckets.length];\n        for (int i = 0; i < oldEnd; ++i) {\n            for (Bucket curr = oldBuckets[i]; curr != null; curr = curr._next) {\n                ++symbolsSeen;\n                Name symbol = curr._name;\n                int hash = symbol.hashCode();\n                int ix = (hash & _mainHashMask);\n                int val = _mainHash[ix];\n                if (_mainNames[ix] == null) { // no primary entry?\n_mainHash[ix] = ((hash >>> 8) + 8);\n                    _mainNames[ix] = symbol;\n                } else { // nope, it's a collision, need to spill over\n                    ++_collCount;\n                    int bucket = val & 0xFF;\n                    if (bucket == 0) { // first spill over?\n                        if (_collEnd <= LAST_VALID_BUCKET) { // yup, still unshared bucket\n                            bucket = _collEnd;\n                            ++_collEnd;\n                            // need to expand?\n                            if (bucket >= _collList.length) {\n                                expandCollision();\n                            }\n                        } else { // nope, have to share... let's find shortest?\n                            bucket = findBestBucket();\n                        }\n                        // Need to mark the entry... and the spill index is 1-based\n                        _mainHash[ix] = (val & ~0xFF) | (bucket + 1);\n                    } else {\n                        --bucket; // 1-based index in value\n                    }\n                    // And then just need to link the new bucket entry in\n                    Bucket newB = new Bucket(symbol, _collList[bucket]);\n                    _collList[bucket] = newB;\n                    maxColl = Math.max(maxColl, newB.length());\n                }\n            } // for (... buckets in the chain ...)\n        } // for (... list of bucket heads ... )\n\n        _longestCollisionList = maxColl;\n        \n        if (symbolsSeen != _count) { // sanity check\n            throw new RuntimeException(\"Internal error: count after rehash \"+symbolsSeen+\"; should be \"+_count);\n        }\n    }",
          "70": "    private void rehash()\n    {\n        _needRehash = false;        \n        // Note: since we'll make copies, no need to unshare, can just mark as such:\n        _mainNamesShared = false;\n\n        /* And then we can first deal with the main hash area. Since we\n         * are expanding linearly (double up), we know there'll be no\n         * collisions during this phase.\n         */\n        int[] oldMainHash = _mainHash;\n        int len = oldMainHash.length;\n        int newLen = len+len;\n\n        /* 13-Mar-2010, tatu: Let's guard against OOME that could be caused by\n         *    large documents with unique (or mostly so) names\n         */\n        if (newLen > MAX_TABLE_SIZE) {\n            nukeSymbols();\n            return;\n        }\n        \n        _mainHash = new int[newLen];\n        _mainHashMask = (newLen - 1);\n        Name[] oldNames = _mainNames;\n        _mainNames = new Name[newLen];\n        int symbolsSeen = 0; // let's do a sanity check\n        for (int i = 0; i < len; ++i) {\n            Name symbol = oldNames[i];\n            if (symbol != null) {\n                ++symbolsSeen;\n                int hash = symbol.hashCode();\n                int ix = (hash & _mainHashMask);\n                _mainNames[ix] = symbol;\n                _mainHash[ix] = hash << 8; // will clear spill index\n            }\n        }\n\n        /* And then the spill area. This may cause collisions, although\n         * not necessarily as many as there were earlier. Let's allocate\n         * same amount of space, however\n         */\n        int oldEnd = _collEnd;\n        if (oldEnd == 0) { // no prior collisions...\n            _longestCollisionList = 0;\n            return;\n        }\n\n        _collCount = 0;\n        _collEnd = 0;\n        _collListShared = false;\n\n        int maxColl = 0;\n        \n        Bucket[] oldBuckets = _collList;\n        _collList = new Bucket[oldBuckets.length];\n        for (int i = 0; i < oldEnd; ++i) {\n            for (Bucket curr = oldBuckets[i]; curr != null; curr = curr._next) {\n                ++symbolsSeen;\n                Name symbol = curr._name;\n                int hash = symbol.hashCode();\n                int ix = (hash & _mainHashMask);\n                int val = _mainHash[ix];\n                if (_mainNames[ix] == null) { // no primary entry?\n_mainHash[ix] = ((hash >>> 8) + 1);\n                    _mainNames[ix] = symbol;\n                } else { // nope, it's a collision, need to spill over\n                    ++_collCount;\n                    int bucket = val & 0xFF;\n                    if (bucket == 0) { // first spill over?\n                        if (_collEnd <= LAST_VALID_BUCKET) { // yup, still unshared bucket\n                            bucket = _collEnd;\n                            ++_collEnd;\n                            // need to expand?\n                            if (bucket >= _collList.length) {\n                                expandCollision();\n                            }\n                        } else { // nope, have to share... let's find shortest?\n                            bucket = findBestBucket();\n                        }\n                        // Need to mark the entry... and the spill index is 1-based\n                        _mainHash[ix] = (val & ~0xFF) | (bucket + 1);\n                    } else {\n                        --bucket; // 1-based index in value\n                    }\n                    // And then just need to link the new bucket entry in\n                    Bucket newB = new Bucket(symbol, _collList[bucket]);\n                    _collList[bucket] = newB;\n                    maxColl = Math.max(maxColl, newB.length());\n                }\n            } // for (... buckets in the chain ...)\n        } // for (... list of bucket heads ... )\n\n        _longestCollisionList = maxColl;\n        \n        if (symbolsSeen != _count) { // sanity check\n            throw new RuntimeException(\"Internal error: count after rehash \"+symbolsSeen+\"; should be \"+_count);\n        }\n    }",
          "71": "    private void rehash()\n    {\n        _needRehash = false;        \n        // Note: since we'll make copies, no need to unshare, can just mark as such:\n        _mainNamesShared = false;\n\n        /* And then we can first deal with the main hash area. Since we\n         * are expanding linearly (double up), we know there'll be no\n         * collisions during this phase.\n         */\n        int[] oldMainHash = _mainHash;\n        int len = oldMainHash.length;\n        int newLen = len+len;\n\n        /* 13-Mar-2010, tatu: Let's guard against OOME that could be caused by\n         *    large documents with unique (or mostly so) names\n         */\n        if (newLen > MAX_TABLE_SIZE) {\n            nukeSymbols();\n            return;\n        }\n        \n        _mainHash = new int[newLen];\n        _mainHashMask = (newLen - 1);\n        Name[] oldNames = _mainNames;\n        _mainNames = new Name[newLen];\n        int symbolsSeen = 0; // let's do a sanity check\n        for (int i = 0; i < len; ++i) {\n            Name symbol = oldNames[i];\n            if (symbol != null) {\n                ++symbolsSeen;\n                int hash = symbol.hashCode();\n                int ix = (hash & _mainHashMask);\n                _mainNames[ix] = symbol;\n                _mainHash[ix] = hash << 8; // will clear spill index\n            }\n        }\n\n        /* And then the spill area. This may cause collisions, although\n         * not necessarily as many as there were earlier. Let's allocate\n         * same amount of space, however\n         */\n        int oldEnd = _collEnd;\n        if (oldEnd == 0) { // no prior collisions...\n            _longestCollisionList = 0;\n            return;\n        }\n\n        _collCount = 0;\n        _collEnd = 0;\n        _collListShared = false;\n\n        int maxColl = 0;\n        \n        Bucket[] oldBuckets = _collList;\n        _collList = new Bucket[oldBuckets.length];\n        for (int i = 0; i < oldEnd; ++i) {\n            for (Bucket curr = oldBuckets[i]; curr != null; curr = curr._next) {\n                ++symbolsSeen;\n                Name symbol = curr._name;\n                int hash = symbol.hashCode();\n                int ix = (hash & _mainHashMask);\n                int val = _mainHash[ix];\n                if (_mainNames[ix] == null) { // no primary entry?\n_mainHash[ix] = ((hash >>> 8) + 0);\n                    _mainNames[ix] = symbol;\n                } else { // nope, it's a collision, need to spill over\n                    ++_collCount;\n                    int bucket = val & 0xFF;\n                    if (bucket == 0) { // first spill over?\n                        if (_collEnd <= LAST_VALID_BUCKET) { // yup, still unshared bucket\n                            bucket = _collEnd;\n                            ++_collEnd;\n                            // need to expand?\n                            if (bucket >= _collList.length) {\n                                expandCollision();\n                            }\n                        } else { // nope, have to share... let's find shortest?\n                            bucket = findBestBucket();\n                        }\n                        // Need to mark the entry... and the spill index is 1-based\n                        _mainHash[ix] = (val & ~0xFF) | (bucket + 1);\n                    } else {\n                        --bucket; // 1-based index in value\n                    }\n                    // And then just need to link the new bucket entry in\n                    Bucket newB = new Bucket(symbol, _collList[bucket]);\n                    _collList[bucket] = newB;\n                    maxColl = Math.max(maxColl, newB.length());\n                }\n            } // for (... buckets in the chain ...)\n        } // for (... list of bucket heads ... )\n\n        _longestCollisionList = maxColl;\n        \n        if (symbolsSeen != _count) { // sanity check\n            throw new RuntimeException(\"Internal error: count after rehash \"+symbolsSeen+\"; should be \"+_count);\n        }\n    }",
          "72": "    private void rehash()\n    {\n        _needRehash = false;        \n        // Note: since we'll make copies, no need to unshare, can just mark as such:\n        _mainNamesShared = false;\n\n        /* And then we can first deal with the main hash area. Since we\n         * are expanding linearly (double up), we know there'll be no\n         * collisions during this phase.\n         */\n        int[] oldMainHash = _mainHash;\n        int len = oldMainHash.length;\n        int newLen = len+len;\n\n        /* 13-Mar-2010, tatu: Let's guard against OOME that could be caused by\n         *    large documents with unique (or mostly so) names\n         */\n        if (newLen > MAX_TABLE_SIZE) {\n            nukeSymbols();\n            return;\n        }\n        \n        _mainHash = new int[newLen];\n        _mainHashMask = (newLen - 1);\n        Name[] oldNames = _mainNames;\n        _mainNames = new Name[newLen];\n        int symbolsSeen = 0; // let's do a sanity check\n        for (int i = 0; i < len; ++i) {\n            Name symbol = oldNames[i];\n            if (symbol != null) {\n                ++symbolsSeen;\n                int hash = symbol.hashCode();\n                int ix = (hash & _mainHashMask);\n                _mainNames[ix] = symbol;\n                _mainHash[ix] = hash << 8; // will clear spill index\n            }\n        }\n\n        /* And then the spill area. This may cause collisions, although\n         * not necessarily as many as there were earlier. Let's allocate\n         * same amount of space, however\n         */\n        int oldEnd = _collEnd;\n        if (oldEnd == 0) { // no prior collisions...\n            _longestCollisionList = 0;\n            return;\n        }\n\n        _collCount = 0;\n        _collEnd = 0;\n        _collListShared = false;\n\n        int maxColl = 0;\n        \n        Bucket[] oldBuckets = _collList;\n        _collList = new Bucket[oldBuckets.length];\n        for (int i = 0; i < oldEnd; ++i) {\n            for (Bucket curr = oldBuckets[i]; curr != null; curr = curr._next) {\n                ++symbolsSeen;\n                Name symbol = curr._name;\n                int hash = symbol.hashCode();\n                int ix = (hash & _mainHashMask);\n                int val = _mainHash[ix];\n                if (_mainNames[ix] == null) { // no primary entry?\n_mainHash[ix] = ((hash >>> 8) + 2);\n                    _mainNames[ix] = symbol;\n                } else { // nope, it's a collision, need to spill over\n                    ++_collCount;\n                    int bucket = val & 0xFF;\n                    if (bucket == 0) { // first spill over?\n                        if (_collEnd <= LAST_VALID_BUCKET) { // yup, still unshared bucket\n                            bucket = _collEnd;\n                            ++_collEnd;\n                            // need to expand?\n                            if (bucket >= _collList.length) {\n                                expandCollision();\n                            }\n                        } else { // nope, have to share... let's find shortest?\n                            bucket = findBestBucket();\n                        }\n                        // Need to mark the entry... and the spill index is 1-based\n                        _mainHash[ix] = (val & ~0xFF) | (bucket + 1);\n                    } else {\n                        --bucket; // 1-based index in value\n                    }\n                    // And then just need to link the new bucket entry in\n                    Bucket newB = new Bucket(symbol, _collList[bucket]);\n                    _collList[bucket] = newB;\n                    maxColl = Math.max(maxColl, newB.length());\n                }\n            } // for (... buckets in the chain ...)\n        } // for (... list of bucket heads ... )\n\n        _longestCollisionList = maxColl;\n        \n        if (symbolsSeen != _count) { // sanity check\n            throw new RuntimeException(\"Internal error: count after rehash \"+symbolsSeen+\"; should be \"+_count);\n        }\n    }",
          "73": "    private void rehash()\n    {\n        _needRehash = false;        \n        // Note: since we'll make copies, no need to unshare, can just mark as such:\n        _mainNamesShared = false;\n\n        /* And then we can first deal with the main hash area. Since we\n         * are expanding linearly (double up), we know there'll be no\n         * collisions during this phase.\n         */\n        int[] oldMainHash = _mainHash;\n        int len = oldMainHash.length;\n        int newLen = len+len;\n\n        /* 13-Mar-2010, tatu: Let's guard against OOME that could be caused by\n         *    large documents with unique (or mostly so) names\n         */\n        if (newLen > MAX_TABLE_SIZE) {\n            nukeSymbols();\n            return;\n        }\n        \n        _mainHash = new int[newLen];\n        _mainHashMask = (newLen - 1);\n        Name[] oldNames = _mainNames;\n        _mainNames = new Name[newLen];\n        int symbolsSeen = 0; // let's do a sanity check\n        for (int i = 0; i < len; ++i) {\n            Name symbol = oldNames[i];\n            if (symbol != null) {\n                ++symbolsSeen;\n                int hash = symbol.hashCode();\n                int ix = (hash & _mainHashMask);\n                _mainNames[ix] = symbol;\n                _mainHash[ix] = hash << 8; // will clear spill index\n            }\n        }\n\n        /* And then the spill area. This may cause collisions, although\n         * not necessarily as many as there were earlier. Let's allocate\n         * same amount of space, however\n         */\n        int oldEnd = _collEnd;\n        if (oldEnd == 0) { // no prior collisions...\n            _longestCollisionList = 0;\n            return;\n        }\n\n        _collCount = 0;\n        _collEnd = 0;\n        _collListShared = false;\n\n        int maxColl = 0;\n        \n        Bucket[] oldBuckets = _collList;\n        _collList = new Bucket[oldBuckets.length];\n        for (int i = 0; i < oldEnd; ++i) {\n            for (Bucket curr = oldBuckets[i]; curr != null; curr = curr._next) {\n                ++symbolsSeen;\n                Name symbol = curr._name;\n                int hash = symbol.hashCode();\n                int ix = (hash & _mainHashMask);\n                int val = _mainHash[ix];\n                if (_mainNames[ix] == null) { // no primary entry?\n_mainHash[ix] = (hash + 1);\n                    _mainNames[ix] = symbol;\n                } else { // nope, it's a collision, need to spill over\n                    ++_collCount;\n                    int bucket = val & 0xFF;\n                    if (bucket == 0) { // first spill over?\n                        if (_collEnd <= LAST_VALID_BUCKET) { // yup, still unshared bucket\n                            bucket = _collEnd;\n                            ++_collEnd;\n                            // need to expand?\n                            if (bucket >= _collList.length) {\n                                expandCollision();\n                            }\n                        } else { // nope, have to share... let's find shortest?\n                            bucket = findBestBucket();\n                        }\n                        // Need to mark the entry... and the spill index is 1-based\n                        _mainHash[ix] = (val & ~0xFF) | (bucket + 1);\n                    } else {\n                        --bucket; // 1-based index in value\n                    }\n                    // And then just need to link the new bucket entry in\n                    Bucket newB = new Bucket(symbol, _collList[bucket]);\n                    _collList[bucket] = newB;\n                    maxColl = Math.max(maxColl, newB.length());\n                }\n            } // for (... buckets in the chain ...)\n        } // for (... list of bucket heads ... )\n\n        _longestCollisionList = maxColl;\n        \n        if (symbolsSeen != _count) { // sanity check\n            throw new RuntimeException(\"Internal error: count after rehash \"+symbolsSeen+\"; should be \"+_count);\n        }\n    }",
          "74": "    private void rehash()\n    {\n        _needRehash = false;        \n        // Note: since we'll make copies, no need to unshare, can just mark as such:\n        _mainNamesShared = false;\n\n        /* And then we can first deal with the main hash area. Since we\n         * are expanding linearly (double up), we know there'll be no\n         * collisions during this phase.\n         */\n        int[] oldMainHash = _mainHash;\n        int len = oldMainHash.length;\n        int newLen = len+len;\n\n        /* 13-Mar-2010, tatu: Let's guard against OOME that could be caused by\n         *    large documents with unique (or mostly so) names\n         */\n        if (newLen > MAX_TABLE_SIZE) {\n            nukeSymbols();\n            return;\n        }\n        \n        _mainHash = new int[newLen];\n        _mainHashMask = (newLen - 1);\n        Name[] oldNames = _mainNames;\n        _mainNames = new Name[newLen];\n        int symbolsSeen = 0; // let's do a sanity check\n        for (int i = 0; i < len; ++i) {\n            Name symbol = oldNames[i];\n            if (symbol != null) {\n                ++symbolsSeen;\n                int hash = symbol.hashCode();\n                int ix = (hash & _mainHashMask);\n                _mainNames[ix] = symbol;\n                _mainHash[ix] = hash << 8; // will clear spill index\n            }\n        }\n\n        /* And then the spill area. This may cause collisions, although\n         * not necessarily as many as there were earlier. Let's allocate\n         * same amount of space, however\n         */\n        int oldEnd = _collEnd;\n        if (oldEnd == 0) { // no prior collisions...\n            _longestCollisionList = 0;\n            return;\n        }\n\n        _collCount = 0;\n        _collEnd = 0;\n        _collListShared = false;\n\n        int maxColl = 0;\n        \n        Bucket[] oldBuckets = _collList;\n        _collList = new Bucket[oldBuckets.length];\n        for (int i = 0; i < oldEnd; ++i) {\n            for (Bucket curr = oldBuckets[i]; curr != null; curr = curr._next) {\n                ++symbolsSeen;\n                Name symbol = curr._name;\n                int hash = symbol.hashCode();\n                int ix = (hash & _mainHashMask);\n                int val = _mainHash[ix];\n                if (_mainNames[ix] == null) { // no primary entry?\n_mainHash[ix] = (hash + 0);\n                    _mainNames[ix] = symbol;\n                } else { // nope, it's a collision, need to spill over\n                    ++_collCount;\n                    int bucket = val & 0xFF;\n                    if (bucket == 0) { // first spill over?\n                        if (_collEnd <= LAST_VALID_BUCKET) { // yup, still unshared bucket\n                            bucket = _collEnd;\n                            ++_collEnd;\n                            // need to expand?\n                            if (bucket >= _collList.length) {\n                                expandCollision();\n                            }\n                        } else { // nope, have to share... let's find shortest?\n                            bucket = findBestBucket();\n                        }\n                        // Need to mark the entry... and the spill index is 1-based\n                        _mainHash[ix] = (val & ~0xFF) | (bucket + 1);\n                    } else {\n                        --bucket; // 1-based index in value\n                    }\n                    // And then just need to link the new bucket entry in\n                    Bucket newB = new Bucket(symbol, _collList[bucket]);\n                    _collList[bucket] = newB;\n                    maxColl = Math.max(maxColl, newB.length());\n                }\n            } // for (... buckets in the chain ...)\n        } // for (... list of bucket heads ... )\n\n        _longestCollisionList = maxColl;\n        \n        if (symbolsSeen != _count) { // sanity check\n            throw new RuntimeException(\"Internal error: count after rehash \"+symbolsSeen+\"; should be \"+_count);\n        }\n    }",
          "75": "    private void rehash()\n    {\n        _needRehash = false;        \n        // Note: since we'll make copies, no need to unshare, can just mark as such:\n        _mainNamesShared = false;\n\n        /* And then we can first deal with the main hash area. Since we\n         * are expanding linearly (double up), we know there'll be no\n         * collisions during this phase.\n         */\n        int[] oldMainHash = _mainHash;\n        int len = oldMainHash.length;\n        int newLen = len+len;\n\n        /* 13-Mar-2010, tatu: Let's guard against OOME that could be caused by\n         *    large documents with unique (or mostly so) names\n         */\n        if (newLen > MAX_TABLE_SIZE) {\n            nukeSymbols();\n            return;\n        }\n        \n        _mainHash = new int[newLen];\n        _mainHashMask = (newLen - 1);\n        Name[] oldNames = _mainNames;\n        _mainNames = new Name[newLen];\n        int symbolsSeen = 0; // let's do a sanity check\n        for (int i = 0; i < len; ++i) {\n            Name symbol = oldNames[i];\n            if (symbol != null) {\n                ++symbolsSeen;\n                int hash = symbol.hashCode();\n                int ix = (hash & _mainHashMask);\n                _mainNames[ix] = symbol;\n                _mainHash[ix] = hash << 8; // will clear spill index\n            }\n        }\n\n        /* And then the spill area. This may cause collisions, although\n         * not necessarily as many as there were earlier. Let's allocate\n         * same amount of space, however\n         */\n        int oldEnd = _collEnd;\n        if (oldEnd == 0) { // no prior collisions...\n            _longestCollisionList = 0;\n            return;\n        }\n\n        _collCount = 0;\n        _collEnd = 0;\n        _collListShared = false;\n\n        int maxColl = 0;\n        \n        Bucket[] oldBuckets = _collList;\n        _collList = new Bucket[oldBuckets.length];\n        for (int i = 0; i < oldEnd; ++i) {\n            for (Bucket curr = oldBuckets[i]; curr != null; curr = curr._next) {\n                ++symbolsSeen;\n                Name symbol = curr._name;\n                int hash = symbol.hashCode();\n                int ix = (hash & _mainHashMask);\n                int val = _mainHash[ix];\n                if (_mainNames[ix] == null) { // no primary entry?\n_mainHash[ix] = (_mainHash + hash);\n                    _mainNames[ix] = symbol;\n                } else { // nope, it's a collision, need to spill over\n                    ++_collCount;\n                    int bucket = val & 0xFF;\n                    if (bucket == 0) { // first spill over?\n                        if (_collEnd <= LAST_VALID_BUCKET) { // yup, still unshared bucket\n                            bucket = _collEnd;\n                            ++_collEnd;\n                            // need to expand?\n                            if (bucket >= _collList.length) {\n                                expandCollision();\n                            }\n                        } else { // nope, have to share... let's find shortest?\n                            bucket = findBestBucket();\n                        }\n                        // Need to mark the entry... and the spill index is 1-based\n                        _mainHash[ix] = (val & ~0xFF) | (bucket + 1);\n                    } else {\n                        --bucket; // 1-based index in value\n                    }\n                    // And then just need to link the new bucket entry in\n                    Bucket newB = new Bucket(symbol, _collList[bucket]);\n                    _collList[bucket] = newB;\n                    maxColl = Math.max(maxColl, newB.length());\n                }\n            } // for (... buckets in the chain ...)\n        } // for (... list of bucket heads ... )\n\n        _longestCollisionList = maxColl;\n        \n        if (symbolsSeen != _count) { // sanity check\n            throw new RuntimeException(\"Internal error: count after rehash \"+symbolsSeen+\"; should be \"+_count);\n        }\n    }",
          "76": "    private void rehash()\n    {\n        _needRehash = false;        \n        // Note: since we'll make copies, no need to unshare, can just mark as such:\n        _mainNamesShared = false;\n\n        /* And then we can first deal with the main hash area. Since we\n         * are expanding linearly (double up), we know there'll be no\n         * collisions during this phase.\n         */\n        int[] oldMainHash = _mainHash;\n        int len = oldMainHash.length;\n        int newLen = len+len;\n\n        /* 13-Mar-2010, tatu: Let's guard against OOME that could be caused by\n         *    large documents with unique (or mostly so) names\n         */\n        if (newLen > MAX_TABLE_SIZE) {\n            nukeSymbols();\n            return;\n        }\n        \n        _mainHash = new int[newLen];\n        _mainHashMask = (newLen - 1);\n        Name[] oldNames = _mainNames;\n        _mainNames = new Name[newLen];\n        int symbolsSeen = 0; // let's do a sanity check\n        for (int i = 0; i < len; ++i) {\n            Name symbol = oldNames[i];\n            if (symbol != null) {\n                ++symbolsSeen;\n                int hash = symbol.hashCode();\n                int ix = (hash & _mainHashMask);\n                _mainNames[ix] = symbol;\n                _mainHash[ix] = hash << 8; // will clear spill index\n            }\n        }\n\n        /* And then the spill area. This may cause collisions, although\n         * not necessarily as many as there were earlier. Let's allocate\n         * same amount of space, however\n         */\n        int oldEnd = _collEnd;\n        if (oldEnd == 0) { // no prior collisions...\n            _longestCollisionList = 0;\n            return;\n        }\n\n        _collCount = 0;\n        _collEnd = 0;\n        _collListShared = false;\n\n        int maxColl = 0;\n        \n        Bucket[] oldBuckets = _collList;\n        _collList = new Bucket[oldBuckets.length];\n        for (int i = 0; i < oldEnd; ++i) {\n            for (Bucket curr = oldBuckets[i]; curr != null; curr = curr._next) {\n                ++symbolsSeen;\n                Name symbol = curr._name;\n                int hash = symbol.hashCode();\n                int ix = (hash & _mainHashMask);\n                int val = _mainHash[ix];\n                if (_mainNames[ix] == null) { // no primary entry?\n_mainHash[ix] = (hash + 2);\n                    _mainNames[ix] = symbol;\n                } else { // nope, it's a collision, need to spill over\n                    ++_collCount;\n                    int bucket = val & 0xFF;\n                    if (bucket == 0) { // first spill over?\n                        if (_collEnd <= LAST_VALID_BUCKET) { // yup, still unshared bucket\n                            bucket = _collEnd;\n                            ++_collEnd;\n                            // need to expand?\n                            if (bucket >= _collList.length) {\n                                expandCollision();\n                            }\n                        } else { // nope, have to share... let's find shortest?\n                            bucket = findBestBucket();\n                        }\n                        // Need to mark the entry... and the spill index is 1-based\n                        _mainHash[ix] = (val & ~0xFF) | (bucket + 1);\n                    } else {\n                        --bucket; // 1-based index in value\n                    }\n                    // And then just need to link the new bucket entry in\n                    Bucket newB = new Bucket(symbol, _collList[bucket]);\n                    _collList[bucket] = newB;\n                    maxColl = Math.max(maxColl, newB.length());\n                }\n            } // for (... buckets in the chain ...)\n        } // for (... list of bucket heads ... )\n\n        _longestCollisionList = maxColl;\n        \n        if (symbolsSeen != _count) { // sanity check\n            throw new RuntimeException(\"Internal error: count after rehash \"+symbolsSeen+\"; should be \"+_count);\n        }\n    }",
          "77": "    private void rehash()\n    {\n        _needRehash = false;        \n        // Note: since we'll make copies, no need to unshare, can just mark as such:\n        _mainNamesShared = false;\n\n        /* And then we can first deal with the main hash area. Since we\n         * are expanding linearly (double up), we know there'll be no\n         * collisions during this phase.\n         */\n        int[] oldMainHash = _mainHash;\n        int len = oldMainHash.length;\n        int newLen = len+len;\n\n        /* 13-Mar-2010, tatu: Let's guard against OOME that could be caused by\n         *    large documents with unique (or mostly so) names\n         */\n        if (newLen > MAX_TABLE_SIZE) {\n            nukeSymbols();\n            return;\n        }\n        \n        _mainHash = new int[newLen];\n        _mainHashMask = (newLen - 1);\n        Name[] oldNames = _mainNames;\n        _mainNames = new Name[newLen];\n        int symbolsSeen = 0; // let's do a sanity check\n        for (int i = 0; i < len; ++i) {\n            Name symbol = oldNames[i];\n            if (symbol != null) {\n                ++symbolsSeen;\n                int hash = symbol.hashCode();\n                int ix = (hash & _mainHashMask);\n                _mainNames[ix] = symbol;\n                _mainHash[ix] = hash << 8; // will clear spill index\n            }\n        }\n\n        /* And then the spill area. This may cause collisions, although\n         * not necessarily as many as there were earlier. Let's allocate\n         * same amount of space, however\n         */\n        int oldEnd = _collEnd;\n        if (oldEnd == 0) { // no prior collisions...\n            _longestCollisionList = 0;\n            return;\n        }\n\n        _collCount = 0;\n        _collEnd = 0;\n        _collListShared = false;\n\n        int maxColl = 0;\n        \n        Bucket[] oldBuckets = _collList;\n        _collList = new Bucket[oldBuckets.length];\n        for (int i = 0; i < oldEnd; ++i) {\n            for (Bucket curr = oldBuckets[i]; curr != null; curr = curr._next) {\n                ++symbolsSeen;\n                Name symbol = curr._name;\n                int hash = symbol.hashCode();\n                int ix = (hash & _mainHashMask);\n                int val = _mainHash[ix];\n                if (_mainNames[ix] == null) { // no primary entry?\n_mainHash[ix] = (_mainHash[ix] + 8);\n                    _mainNames[ix] = symbol;\n                } else { // nope, it's a collision, need to spill over\n                    ++_collCount;\n                    int bucket = val & 0xFF;\n                    if (bucket == 0) { // first spill over?\n                        if (_collEnd <= LAST_VALID_BUCKET) { // yup, still unshared bucket\n                            bucket = _collEnd;\n                            ++_collEnd;\n                            // need to expand?\n                            if (bucket >= _collList.length) {\n                                expandCollision();\n                            }\n                        } else { // nope, have to share... let's find shortest?\n                            bucket = findBestBucket();\n                        }\n                        // Need to mark the entry... and the spill index is 1-based\n                        _mainHash[ix] = (val & ~0xFF) | (bucket + 1);\n                    } else {\n                        --bucket; // 1-based index in value\n                    }\n                    // And then just need to link the new bucket entry in\n                    Bucket newB = new Bucket(symbol, _collList[bucket]);\n                    _collList[bucket] = newB;\n                    maxColl = Math.max(maxColl, newB.length());\n                }\n            } // for (... buckets in the chain ...)\n        } // for (... list of bucket heads ... )\n\n        _longestCollisionList = maxColl;\n        \n        if (symbolsSeen != _count) { // sanity check\n            throw new RuntimeException(\"Internal error: count after rehash \"+symbolsSeen+\"; should be \"+_count);\n        }\n    }",
          "78": "    private void rehash()\n    {\n        _needRehash = false;        \n        // Note: since we'll make copies, no need to unshare, can just mark as such:\n        _mainNamesShared = false;\n\n        /* And then we can first deal with the main hash area. Since we\n         * are expanding linearly (double up), we know there'll be no\n         * collisions during this phase.\n         */\n        int[] oldMainHash = _mainHash;\n        int len = oldMainHash.length;\n        int newLen = len+len;\n\n        /* 13-Mar-2010, tatu: Let's guard against OOME that could be caused by\n         *    large documents with unique (or mostly so) names\n         */\n        if (newLen > MAX_TABLE_SIZE) {\n            nukeSymbols();\n            return;\n        }\n        \n        _mainHash = new int[newLen];\n        _mainHashMask = (newLen - 1);\n        Name[] oldNames = _mainNames;\n        _mainNames = new Name[newLen];\n        int symbolsSeen = 0; // let's do a sanity check\n        for (int i = 0; i < len; ++i) {\n            Name symbol = oldNames[i];\n            if (symbol != null) {\n                ++symbolsSeen;\n                int hash = symbol.hashCode();\n                int ix = (hash & _mainHashMask);\n                _mainNames[ix] = symbol;\n                _mainHash[ix] = hash << 8; // will clear spill index\n            }\n        }\n\n        /* And then the spill area. This may cause collisions, although\n         * not necessarily as many as there were earlier. Let's allocate\n         * same amount of space, however\n         */\n        int oldEnd = _collEnd;\n        if (oldEnd == 0) { // no prior collisions...\n            _longestCollisionList = 0;\n            return;\n        }\n\n        _collCount = 0;\n        _collEnd = 0;\n        _collListShared = false;\n\n        int maxColl = 0;\n        \n        Bucket[] oldBuckets = _collList;\n        _collList = new Bucket[oldBuckets.length];\n        for (int i = 0; i < oldEnd; ++i) {\n            for (Bucket curr = oldBuckets[i]; curr != null; curr = curr._next) {\n                ++symbolsSeen;\n                Name symbol = curr._name;\n                int hash = symbol.hashCode();\n                int ix = (hash & _mainHashMask);\n                int val = _mainHash[ix];\n                if (_mainNames[ix] == null) { // no primary entry?\n_mainHash[ix] = (_mainHash + _mainHash[ix]);\n                    _mainNames[ix] = symbol;\n                } else { // nope, it's a collision, need to spill over\n                    ++_collCount;\n                    int bucket = val & 0xFF;\n                    if (bucket == 0) { // first spill over?\n                        if (_collEnd <= LAST_VALID_BUCKET) { // yup, still unshared bucket\n                            bucket = _collEnd;\n                            ++_collEnd;\n                            // need to expand?\n                            if (bucket >= _collList.length) {\n                                expandCollision();\n                            }\n                        } else { // nope, have to share... let's find shortest?\n                            bucket = findBestBucket();\n                        }\n                        // Need to mark the entry... and the spill index is 1-based\n                        _mainHash[ix] = (val & ~0xFF) | (bucket + 1);\n                    } else {\n                        --bucket; // 1-based index in value\n                    }\n                    // And then just need to link the new bucket entry in\n                    Bucket newB = new Bucket(symbol, _collList[bucket]);\n                    _collList[bucket] = newB;\n                    maxColl = Math.max(maxColl, newB.length());\n                }\n            } // for (... buckets in the chain ...)\n        } // for (... list of bucket heads ... )\n\n        _longestCollisionList = maxColl;\n        \n        if (symbolsSeen != _count) { // sanity check\n            throw new RuntimeException(\"Internal error: count after rehash \"+symbolsSeen+\"; should be \"+_count);\n        }\n    }",
          "79": "    private void rehash()\n    {\n        _needRehash = false;        \n        // Note: since we'll make copies, no need to unshare, can just mark as such:\n        _mainNamesShared = false;\n\n        /* And then we can first deal with the main hash area. Since we\n         * are expanding linearly (double up), we know there'll be no\n         * collisions during this phase.\n         */\n        int[] oldMainHash = _mainHash;\n        int len = oldMainHash.length;\n        int newLen = len+len;\n\n        /* 13-Mar-2010, tatu: Let's guard against OOME that could be caused by\n         *    large documents with unique (or mostly so) names\n         */\n        if (newLen > MAX_TABLE_SIZE) {\n            nukeSymbols();\n            return;\n        }\n        \n        _mainHash = new int[newLen];\n        _mainHashMask = (newLen - 1);\n        Name[] oldNames = _mainNames;\n        _mainNames = new Name[newLen];\n        int symbolsSeen = 0; // let's do a sanity check\n        for (int i = 0; i < len; ++i) {\n            Name symbol = oldNames[i];\n            if (symbol != null) {\n                ++symbolsSeen;\n                int hash = symbol.hashCode();\n                int ix = (hash & _mainHashMask);\n                _mainNames[ix] = symbol;\n                _mainHash[ix] = hash << 8; // will clear spill index\n            }\n        }\n\n        /* And then the spill area. This may cause collisions, although\n         * not necessarily as many as there were earlier. Let's allocate\n         * same amount of space, however\n         */\n        int oldEnd = _collEnd;\n        if (oldEnd == 0) { // no prior collisions...\n            _longestCollisionList = 0;\n            return;\n        }\n\n        _collCount = 0;\n        _collEnd = 0;\n        _collListShared = false;\n\n        int maxColl = 0;\n        \n        Bucket[] oldBuckets = _collList;\n        _collList = new Bucket[oldBuckets.length];\n        for (int i = 0; i < oldEnd; ++i) {\n            for (Bucket curr = oldBuckets[i]; curr != null; curr = curr._next) {\n                ++symbolsSeen;\n                Name symbol = curr._name;\n                int hash = symbol.hashCode();\n                int ix = (hash & _mainHashMask);\n                int val = _mainHash[ix];\n                if (_mainNames[ix] == null) { // no primary entry?\n_mainHash[ix] = (_mainHash[ix] + _mainHash[ix]);\n                    _mainNames[ix] = symbol;\n                } else { // nope, it's a collision, need to spill over\n                    ++_collCount;\n                    int bucket = val & 0xFF;\n                    if (bucket == 0) { // first spill over?\n                        if (_collEnd <= LAST_VALID_BUCKET) { // yup, still unshared bucket\n                            bucket = _collEnd;\n                            ++_collEnd;\n                            // need to expand?\n                            if (bucket >= _collList.length) {\n                                expandCollision();\n                            }\n                        } else { // nope, have to share... let's find shortest?\n                            bucket = findBestBucket();\n                        }\n                        // Need to mark the entry... and the spill index is 1-based\n                        _mainHash[ix] = (val & ~0xFF) | (bucket + 1);\n                    } else {\n                        --bucket; // 1-based index in value\n                    }\n                    // And then just need to link the new bucket entry in\n                    Bucket newB = new Bucket(symbol, _collList[bucket]);\n                    _collList[bucket] = newB;\n                    maxColl = Math.max(maxColl, newB.length());\n                }\n            } // for (... buckets in the chain ...)\n        } // for (... list of bucket heads ... )\n\n        _longestCollisionList = maxColl;\n        \n        if (symbolsSeen != _count) { // sanity check\n            throw new RuntimeException(\"Internal error: count after rehash \"+symbolsSeen+\"; should be \"+_count);\n        }\n    }",
          "80": "    private void rehash()\n    {\n        _needRehash = false;        \n        // Note: since we'll make copies, no need to unshare, can just mark as such:\n        _mainNamesShared = false;\n\n        /* And then we can first deal with the main hash area. Since we\n         * are expanding linearly (double up), we know there'll be no\n         * collisions during this phase.\n         */\n        int[] oldMainHash = _mainHash;\n        int len = oldMainHash.length;\n        int newLen = len+len;\n\n        /* 13-Mar-2010, tatu: Let's guard against OOME that could be caused by\n         *    large documents with unique (or mostly so) names\n         */\n        if (newLen > MAX_TABLE_SIZE) {\n            nukeSymbols();\n            return;\n        }\n        \n        _mainHash = new int[newLen];\n        _mainHashMask = (newLen - 1);\n        Name[] oldNames = _mainNames;\n        _mainNames = new Name[newLen];\n        int symbolsSeen = 0; // let's do a sanity check\n        for (int i = 0; i < len; ++i) {\n            Name symbol = oldNames[i];\n            if (symbol != null) {\n                ++symbolsSeen;\n                int hash = symbol.hashCode();\n                int ix = (hash & _mainHashMask);\n                _mainNames[ix] = symbol;\n                _mainHash[ix] = hash << 8; // will clear spill index\n            }\n        }\n\n        /* And then the spill area. This may cause collisions, although\n         * not necessarily as many as there were earlier. Let's allocate\n         * same amount of space, however\n         */\n        int oldEnd = _collEnd;\n        if (oldEnd == 0) { // no prior collisions...\n            _longestCollisionList = 0;\n            return;\n        }\n\n        _collCount = 0;\n        _collEnd = 0;\n        _collListShared = false;\n\n        int maxColl = 0;\n        \n        Bucket[] oldBuckets = _collList;\n        _collList = new Bucket[oldBuckets.length];\n        for (int i = 0; i < oldEnd; ++i) {\n            for (Bucket curr = oldBuckets[i]; curr != null; curr = curr._next) {\n                ++symbolsSeen;\n                Name symbol = curr._name;\n                int hash = symbol.hashCode();\n                int ix = (hash & _mainHashMask);\n                int val = _mainHash[ix];\n                if (_mainNames[ix] == null) { // no primary entry?\n_mainHash[ix] = ((_mainHash[ix] * 8) + 8);\n                    _mainNames[ix] = symbol;\n                } else { // nope, it's a collision, need to spill over\n                    ++_collCount;\n                    int bucket = val & 0xFF;\n                    if (bucket == 0) { // first spill over?\n                        if (_collEnd <= LAST_VALID_BUCKET) { // yup, still unshared bucket\n                            bucket = _collEnd;\n                            ++_collEnd;\n                            // need to expand?\n                            if (bucket >= _collList.length) {\n                                expandCollision();\n                            }\n                        } else { // nope, have to share... let's find shortest?\n                            bucket = findBestBucket();\n                        }\n                        // Need to mark the entry... and the spill index is 1-based\n                        _mainHash[ix] = (val & ~0xFF) | (bucket + 1);\n                    } else {\n                        --bucket; // 1-based index in value\n                    }\n                    // And then just need to link the new bucket entry in\n                    Bucket newB = new Bucket(symbol, _collList[bucket]);\n                    _collList[bucket] = newB;\n                    maxColl = Math.max(maxColl, newB.length());\n                }\n            } // for (... buckets in the chain ...)\n        } // for (... list of bucket heads ... )\n\n        _longestCollisionList = maxColl;\n        \n        if (symbolsSeen != _count) { // sanity check\n            throw new RuntimeException(\"Internal error: count after rehash \"+symbolsSeen+\"; should be \"+_count);\n        }\n    }",
          "81": "    private void rehash()\n    {\n        _needRehash = false;        \n        // Note: since we'll make copies, no need to unshare, can just mark as such:\n        _mainNamesShared = false;\n\n        /* And then we can first deal with the main hash area. Since we\n         * are expanding linearly (double up), we know there'll be no\n         * collisions during this phase.\n         */\n        int[] oldMainHash = _mainHash;\n        int len = oldMainHash.length;\n        int newLen = len+len;\n\n        /* 13-Mar-2010, tatu: Let's guard against OOME that could be caused by\n         *    large documents with unique (or mostly so) names\n         */\n        if (newLen > MAX_TABLE_SIZE) {\n            nukeSymbols();\n            return;\n        }\n        \n        _mainHash = new int[newLen];\n        _mainHashMask = (newLen - 1);\n        Name[] oldNames = _mainNames;\n        _mainNames = new Name[newLen];\n        int symbolsSeen = 0; // let's do a sanity check\n        for (int i = 0; i < len; ++i) {\n            Name symbol = oldNames[i];\n            if (symbol != null) {\n                ++symbolsSeen;\n                int hash = symbol.hashCode();\n                int ix = (hash & _mainHashMask);\n                _mainNames[ix] = symbol;\n                _mainHash[ix] = hash << 8; // will clear spill index\n            }\n        }\n\n        /* And then the spill area. This may cause collisions, although\n         * not necessarily as many as there were earlier. Let's allocate\n         * same amount of space, however\n         */\n        int oldEnd = _collEnd;\n        if (oldEnd == 0) { // no prior collisions...\n            _longestCollisionList = 0;\n            return;\n        }\n\n        _collCount = 0;\n        _collEnd = 0;\n        _collListShared = false;\n\n        int maxColl = 0;\n        \n        Bucket[] oldBuckets = _collList;\n        _collList = new Bucket[oldBuckets.length];\n        for (int i = 0; i < oldEnd; ++i) {\n            for (Bucket curr = oldBuckets[i]; curr != null; curr = curr._next) {\n                ++symbolsSeen;\n                Name symbol = curr._name;\n                int hash = symbol.hashCode();\n                int ix = (hash & _mainHashMask);\n                int val = _mainHash[ix];\n                if (_mainNames[ix] == null) { // no primary entry?\n_mainHash[ix] = ((hash >>> 8) + _mainHash[0]);\n                    _mainNames[ix] = symbol;\n                } else { // nope, it's a collision, need to spill over\n                    ++_collCount;\n                    int bucket = val & 0xFF;\n                    if (bucket == 0) { // first spill over?\n                        if (_collEnd <= LAST_VALID_BUCKET) { // yup, still unshared bucket\n                            bucket = _collEnd;\n                            ++_collEnd;\n                            // need to expand?\n                            if (bucket >= _collList.length) {\n                                expandCollision();\n                            }\n                        } else { // nope, have to share... let's find shortest?\n                            bucket = findBestBucket();\n                        }\n                        // Need to mark the entry... and the spill index is 1-based\n                        _mainHash[ix] = (val & ~0xFF) | (bucket + 1);\n                    } else {\n                        --bucket; // 1-based index in value\n                    }\n                    // And then just need to link the new bucket entry in\n                    Bucket newB = new Bucket(symbol, _collList[bucket]);\n                    _collList[bucket] = newB;\n                    maxColl = Math.max(maxColl, newB.length());\n                }\n            } // for (... buckets in the chain ...)\n        } // for (... list of bucket heads ... )\n\n        _longestCollisionList = maxColl;\n        \n        if (symbolsSeen != _count) { // sanity check\n            throw new RuntimeException(\"Internal error: count after rehash \"+symbolsSeen+\"; should be \"+_count);\n        }\n    }",
          "82": "    private void rehash()\n    {\n        _needRehash = false;        \n        // Note: since we'll make copies, no need to unshare, can just mark as such:\n        _mainNamesShared = false;\n\n        /* And then we can first deal with the main hash area. Since we\n         * are expanding linearly (double up), we know there'll be no\n         * collisions during this phase.\n         */\n        int[] oldMainHash = _mainHash;\n        int len = oldMainHash.length;\n        int newLen = len+len;\n\n        /* 13-Mar-2010, tatu: Let's guard against OOME that could be caused by\n         *    large documents with unique (or mostly so) names\n         */\n        if (newLen > MAX_TABLE_SIZE) {\n            nukeSymbols();\n            return;\n        }\n        \n        _mainHash = new int[newLen];\n        _mainHashMask = (newLen - 1);\n        Name[] oldNames = _mainNames;\n        _mainNames = new Name[newLen];\n        int symbolsSeen = 0; // let's do a sanity check\n        for (int i = 0; i < len; ++i) {\n            Name symbol = oldNames[i];\n            if (symbol != null) {\n                ++symbolsSeen;\n                int hash = symbol.hashCode();\n                int ix = (hash & _mainHashMask);\n                _mainNames[ix] = symbol;\n                _mainHash[ix] = hash << 8; // will clear spill index\n            }\n        }\n\n        /* And then the spill area. This may cause collisions, although\n         * not necessarily as many as there were earlier. Let's allocate\n         * same amount of space, however\n         */\n        int oldEnd = _collEnd;\n        if (oldEnd == 0) { // no prior collisions...\n            _longestCollisionList = 0;\n            return;\n        }\n\n        _collCount = 0;\n        _collEnd = 0;\n        _collListShared = false;\n\n        int maxColl = 0;\n        \n        Bucket[] oldBuckets = _collList;\n        _collList = new Bucket[oldBuckets.length];\n        for (int i = 0; i < oldEnd; ++i) {\n            for (Bucket curr = oldBuckets[i]; curr != null; curr = curr._next) {\n                ++symbolsSeen;\n                Name symbol = curr._name;\n                int hash = symbol.hashCode();\n                int ix = (hash & _mainHashMask);\n                int val = _mainHash[ix];\n                if (_mainNames[ix] == null) { // no primary entry?\n_mainHash[ix] = ((hash >>> 8) + hash[0]);\n                    _mainNames[ix] = symbol;\n                } else { // nope, it's a collision, need to spill over\n                    ++_collCount;\n                    int bucket = val & 0xFF;\n                    if (bucket == 0) { // first spill over?\n                        if (_collEnd <= LAST_VALID_BUCKET) { // yup, still unshared bucket\n                            bucket = _collEnd;\n                            ++_collEnd;\n                            // need to expand?\n                            if (bucket >= _collList.length) {\n                                expandCollision();\n                            }\n                        } else { // nope, have to share... let's find shortest?\n                            bucket = findBestBucket();\n                        }\n                        // Need to mark the entry... and the spill index is 1-based\n                        _mainHash[ix] = (val & ~0xFF) | (bucket + 1);\n                    } else {\n                        --bucket; // 1-based index in value\n                    }\n                    // And then just need to link the new bucket entry in\n                    Bucket newB = new Bucket(symbol, _collList[bucket]);\n                    _collList[bucket] = newB;\n                    maxColl = Math.max(maxColl, newB.length());\n                }\n            } // for (... buckets in the chain ...)\n        } // for (... list of bucket heads ... )\n\n        _longestCollisionList = maxColl;\n        \n        if (symbolsSeen != _count) { // sanity check\n            throw new RuntimeException(\"Internal error: count after rehash \"+symbolsSeen+\"; should be \"+_count);\n        }\n    }",
          "83": "    private void rehash()\n    {\n        _needRehash = false;        \n        // Note: since we'll make copies, no need to unshare, can just mark as such:\n        _mainNamesShared = false;\n\n        /* And then we can first deal with the main hash area. Since we\n         * are expanding linearly (double up), we know there'll be no\n         * collisions during this phase.\n         */\n        int[] oldMainHash = _mainHash;\n        int len = oldMainHash.length;\n        int newLen = len+len;\n\n        /* 13-Mar-2010, tatu: Let's guard against OOME that could be caused by\n         *    large documents with unique (or mostly so) names\n         */\n        if (newLen > MAX_TABLE_SIZE) {\n            nukeSymbols();\n            return;\n        }\n        \n        _mainHash = new int[newLen];\n        _mainHashMask = (newLen - 1);\n        Name[] oldNames = _mainNames;\n        _mainNames = new Name[newLen];\n        int symbolsSeen = 0; // let's do a sanity check\n        for (int i = 0; i < len; ++i) {\n            Name symbol = oldNames[i];\n            if (symbol != null) {\n                ++symbolsSeen;\n                int hash = symbol.hashCode();\n                int ix = (hash & _mainHashMask);\n                _mainNames[ix] = symbol;\n                _mainHash[ix] = hash << 8; // will clear spill index\n            }\n        }\n\n        /* And then the spill area. This may cause collisions, although\n         * not necessarily as many as there were earlier. Let's allocate\n         * same amount of space, however\n         */\n        int oldEnd = _collEnd;\n        if (oldEnd == 0) { // no prior collisions...\n            _longestCollisionList = 0;\n            return;\n        }\n\n        _collCount = 0;\n        _collEnd = 0;\n        _collListShared = false;\n\n        int maxColl = 0;\n        \n        Bucket[] oldBuckets = _collList;\n        _collList = new Bucket[oldBuckets.length];\n        for (int i = 0; i < oldEnd; ++i) {\n            for (Bucket curr = oldBuckets[i]; curr != null; curr = curr._next) {\n                ++symbolsSeen;\n                Name symbol = curr._name;\n                int hash = symbol.hashCode();\n                int ix = (hash & _mainHashMask);\n                int val = _mainHash[ix];\n                if (_mainNames[ix] == null) { // no primary entry?\n_mainHash[ix] = ((_mainHash * hash) + 8);\n                    _mainNames[ix] = symbol;\n                } else { // nope, it's a collision, need to spill over\n                    ++_collCount;\n                    int bucket = val & 0xFF;\n                    if (bucket == 0) { // first spill over?\n                        if (_collEnd <= LAST_VALID_BUCKET) { // yup, still unshared bucket\n                            bucket = _collEnd;\n                            ++_collEnd;\n                            // need to expand?\n                            if (bucket >= _collList.length) {\n                                expandCollision();\n                            }\n                        } else { // nope, have to share... let's find shortest?\n                            bucket = findBestBucket();\n                        }\n                        // Need to mark the entry... and the spill index is 1-based\n                        _mainHash[ix] = (val & ~0xFF) | (bucket + 1);\n                    } else {\n                        --bucket; // 1-based index in value\n                    }\n                    // And then just need to link the new bucket entry in\n                    Bucket newB = new Bucket(symbol, _collList[bucket]);\n                    _collList[bucket] = newB;\n                    maxColl = Math.max(maxColl, newB.length());\n                }\n            } // for (... buckets in the chain ...)\n        } // for (... list of bucket heads ... )\n\n        _longestCollisionList = maxColl;\n        \n        if (symbolsSeen != _count) { // sanity check\n            throw new RuntimeException(\"Internal error: count after rehash \"+symbolsSeen+\"; should be \"+_count);\n        }\n    }",
          "84": "    private void rehash()\n    {\n        _needRehash = false;        \n        // Note: since we'll make copies, no need to unshare, can just mark as such:\n        _mainNamesShared = false;\n\n        /* And then we can first deal with the main hash area. Since we\n         * are expanding linearly (double up), we know there'll be no\n         * collisions during this phase.\n         */\n        int[] oldMainHash = _mainHash;\n        int len = oldMainHash.length;\n        int newLen = len+len;\n\n        /* 13-Mar-2010, tatu: Let's guard against OOME that could be caused by\n         *    large documents with unique (or mostly so) names\n         */\n        if (newLen > MAX_TABLE_SIZE) {\n            nukeSymbols();\n            return;\n        }\n        \n        _mainHash = new int[newLen];\n        _mainHashMask = (newLen - 1);\n        Name[] oldNames = _mainNames;\n        _mainNames = new Name[newLen];\n        int symbolsSeen = 0; // let's do a sanity check\n        for (int i = 0; i < len; ++i) {\n            Name symbol = oldNames[i];\n            if (symbol != null) {\n                ++symbolsSeen;\n                int hash = symbol.hashCode();\n                int ix = (hash & _mainHashMask);\n                _mainNames[ix] = symbol;\n                _mainHash[ix] = hash << 8; // will clear spill index\n            }\n        }\n\n        /* And then the spill area. This may cause collisions, although\n         * not necessarily as many as there were earlier. Let's allocate\n         * same amount of space, however\n         */\n        int oldEnd = _collEnd;\n        if (oldEnd == 0) { // no prior collisions...\n            _longestCollisionList = 0;\n            return;\n        }\n\n        _collCount = 0;\n        _collEnd = 0;\n        _collListShared = false;\n\n        int maxColl = 0;\n        \n        Bucket[] oldBuckets = _collList;\n        _collList = new Bucket[oldBuckets.length];\n        for (int i = 0; i < oldEnd; ++i) {\n            for (Bucket curr = oldBuckets[i]; curr != null; curr = curr._next) {\n                ++symbolsSeen;\n                Name symbol = curr._name;\n                int hash = symbol.hashCode();\n                int ix = (hash & _mainHashMask);\n                int val = _mainHash[ix];\n                if (_mainNames[ix] == null) { // no primary entry?\n_mainHash[ix] = ((hash * _mainHash) + 8);\n                    _mainNames[ix] = symbol;\n                } else { // nope, it's a collision, need to spill over\n                    ++_collCount;\n                    int bucket = val & 0xFF;\n                    if (bucket == 0) { // first spill over?\n                        if (_collEnd <= LAST_VALID_BUCKET) { // yup, still unshared bucket\n                            bucket = _collEnd;\n                            ++_collEnd;\n                            // need to expand?\n                            if (bucket >= _collList.length) {\n                                expandCollision();\n                            }\n                        } else { // nope, have to share... let's find shortest?\n                            bucket = findBestBucket();\n                        }\n                        // Need to mark the entry... and the spill index is 1-based\n                        _mainHash[ix] = (val & ~0xFF) | (bucket + 1);\n                    } else {\n                        --bucket; // 1-based index in value\n                    }\n                    // And then just need to link the new bucket entry in\n                    Bucket newB = new Bucket(symbol, _collList[bucket]);\n                    _collList[bucket] = newB;\n                    maxColl = Math.max(maxColl, newB.length());\n                }\n            } // for (... buckets in the chain ...)\n        } // for (... list of bucket heads ... )\n\n        _longestCollisionList = maxColl;\n        \n        if (symbolsSeen != _count) { // sanity check\n            throw new RuntimeException(\"Internal error: count after rehash \"+symbolsSeen+\"; should be \"+_count);\n        }\n    }",
          "85": "    private void rehash()\n    {\n        _needRehash = false;        \n        // Note: since we'll make copies, no need to unshare, can just mark as such:\n        _mainNamesShared = false;\n\n        /* And then we can first deal with the main hash area. Since we\n         * are expanding linearly (double up), we know there'll be no\n         * collisions during this phase.\n         */\n        int[] oldMainHash = _mainHash;\n        int len = oldMainHash.length;\n        int newLen = len+len;\n\n        /* 13-Mar-2010, tatu: Let's guard against OOME that could be caused by\n         *    large documents with unique (or mostly so) names\n         */\n        if (newLen > MAX_TABLE_SIZE) {\n            nukeSymbols();\n            return;\n        }\n        \n        _mainHash = new int[newLen];\n        _mainHashMask = (newLen - 1);\n        Name[] oldNames = _mainNames;\n        _mainNames = new Name[newLen];\n        int symbolsSeen = 0; // let's do a sanity check\n        for (int i = 0; i < len; ++i) {\n            Name symbol = oldNames[i];\n            if (symbol != null) {\n                ++symbolsSeen;\n                int hash = symbol.hashCode();\n                int ix = (hash & _mainHashMask);\n                _mainNames[ix] = symbol;\n                _mainHash[ix] = hash << 8; // will clear spill index\n            }\n        }\n\n        /* And then the spill area. This may cause collisions, although\n         * not necessarily as many as there were earlier. Let's allocate\n         * same amount of space, however\n         */\n        int oldEnd = _collEnd;\n        if (oldEnd == 0) { // no prior collisions...\n            _longestCollisionList = 0;\n            return;\n        }\n\n        _collCount = 0;\n        _collEnd = 0;\n        _collListShared = false;\n\n        int maxColl = 0;\n        \n        Bucket[] oldBuckets = _collList;\n        _collList = new Bucket[oldBuckets.length];\n        for (int i = 0; i < oldEnd; ++i) {\n            for (Bucket curr = oldBuckets[i]; curr != null; curr = curr._next) {\n                ++symbolsSeen;\n                Name symbol = curr._name;\n                int hash = symbol.hashCode();\n                int ix = (hash & _mainHashMask);\n                int val = _mainHash[ix];\n                if (_mainNames[ix] == null) { // no primary entry?\n_mainHash[ix] = ((hash >>> 8) + symbol[0]);\n                    _mainNames[ix] = symbol;\n                } else { // nope, it's a collision, need to spill over\n                    ++_collCount;\n                    int bucket = val & 0xFF;\n                    if (bucket == 0) { // first spill over?\n                        if (_collEnd <= LAST_VALID_BUCKET) { // yup, still unshared bucket\n                            bucket = _collEnd;\n                            ++_collEnd;\n                            // need to expand?\n                            if (bucket >= _collList.length) {\n                                expandCollision();\n                            }\n                        } else { // nope, have to share... let's find shortest?\n                            bucket = findBestBucket();\n                        }\n                        // Need to mark the entry... and the spill index is 1-based\n                        _mainHash[ix] = (val & ~0xFF) | (bucket + 1);\n                    } else {\n                        --bucket; // 1-based index in value\n                    }\n                    // And then just need to link the new bucket entry in\n                    Bucket newB = new Bucket(symbol, _collList[bucket]);\n                    _collList[bucket] = newB;\n                    maxColl = Math.max(maxColl, newB.length());\n                }\n            } // for (... buckets in the chain ...)\n        } // for (... list of bucket heads ... )\n\n        _longestCollisionList = maxColl;\n        \n        if (symbolsSeen != _count) { // sanity check\n            throw new RuntimeException(\"Internal error: count after rehash \"+symbolsSeen+\"; should be \"+_count);\n        }\n    }",
          "86": "    private void rehash()\n    {\n        _needRehash = false;        \n        // Note: since we'll make copies, no need to unshare, can just mark as such:\n        _mainNamesShared = false;\n\n        /* And then we can first deal with the main hash area. Since we\n         * are expanding linearly (double up), we know there'll be no\n         * collisions during this phase.\n         */\n        int[] oldMainHash = _mainHash;\n        int len = oldMainHash.length;\n        int newLen = len+len;\n\n        /* 13-Mar-2010, tatu: Let's guard against OOME that could be caused by\n         *    large documents with unique (or mostly so) names\n         */\n        if (newLen > MAX_TABLE_SIZE) {\n            nukeSymbols();\n            return;\n        }\n        \n        _mainHash = new int[newLen];\n        _mainHashMask = (newLen - 1);\n        Name[] oldNames = _mainNames;\n        _mainNames = new Name[newLen];\n        int symbolsSeen = 0; // let's do a sanity check\n        for (int i = 0; i < len; ++i) {\n            Name symbol = oldNames[i];\n            if (symbol != null) {\n                ++symbolsSeen;\n                int hash = symbol.hashCode();\n                int ix = (hash & _mainHashMask);\n                _mainNames[ix] = symbol;\n                _mainHash[ix] = hash << 8; // will clear spill index\n            }\n        }\n\n        /* And then the spill area. This may cause collisions, although\n         * not necessarily as many as there were earlier. Let's allocate\n         * same amount of space, however\n         */\n        int oldEnd = _collEnd;\n        if (oldEnd == 0) { // no prior collisions...\n            _longestCollisionList = 0;\n            return;\n        }\n\n        _collCount = 0;\n        _collEnd = 0;\n        _collListShared = false;\n\n        int maxColl = 0;\n        \n        Bucket[] oldBuckets = _collList;\n        _collList = new Bucket[oldBuckets.length];\n        for (int i = 0; i < oldEnd; ++i) {\n            for (Bucket curr = oldBuckets[i]; curr != null; curr = curr._next) {\n                ++symbolsSeen;\n                Name symbol = curr._name;\n                int hash = symbol.hashCode();\n                int ix = (hash & _mainHashMask);\n                int val = _mainHash[ix];\n                if (_mainNames[ix] == null) { // no primary entry?\n_mainHash[ix] = ((hash >>> 8) + _mainHash[1]);\n                    _mainNames[ix] = symbol;\n                } else { // nope, it's a collision, need to spill over\n                    ++_collCount;\n                    int bucket = val & 0xFF;\n                    if (bucket == 0) { // first spill over?\n                        if (_collEnd <= LAST_VALID_BUCKET) { // yup, still unshared bucket\n                            bucket = _collEnd;\n                            ++_collEnd;\n                            // need to expand?\n                            if (bucket >= _collList.length) {\n                                expandCollision();\n                            }\n                        } else { // nope, have to share... let's find shortest?\n                            bucket = findBestBucket();\n                        }\n                        // Need to mark the entry... and the spill index is 1-based\n                        _mainHash[ix] = (val & ~0xFF) | (bucket + 1);\n                    } else {\n                        --bucket; // 1-based index in value\n                    }\n                    // And then just need to link the new bucket entry in\n                    Bucket newB = new Bucket(symbol, _collList[bucket]);\n                    _collList[bucket] = newB;\n                    maxColl = Math.max(maxColl, newB.length());\n                }\n            } // for (... buckets in the chain ...)\n        } // for (... list of bucket heads ... )\n\n        _longestCollisionList = maxColl;\n        \n        if (symbolsSeen != _count) { // sanity check\n            throw new RuntimeException(\"Internal error: count after rehash \"+symbolsSeen+\"; should be \"+_count);\n        }\n    }",
          "87": "    private void rehash()\n    {\n        _needRehash = false;        \n        // Note: since we'll make copies, no need to unshare, can just mark as such:\n        _mainNamesShared = false;\n\n        /* And then we can first deal with the main hash area. Since we\n         * are expanding linearly (double up), we know there'll be no\n         * collisions during this phase.\n         */\n        int[] oldMainHash = _mainHash;\n        int len = oldMainHash.length;\n        int newLen = len+len;\n\n        /* 13-Mar-2010, tatu: Let's guard against OOME that could be caused by\n         *    large documents with unique (or mostly so) names\n         */\n        if (newLen > MAX_TABLE_SIZE) {\n            nukeSymbols();\n            return;\n        }\n        \n        _mainHash = new int[newLen];\n        _mainHashMask = (newLen - 1);\n        Name[] oldNames = _mainNames;\n        _mainNames = new Name[newLen];\n        int symbolsSeen = 0; // let's do a sanity check\n        for (int i = 0; i < len; ++i) {\n            Name symbol = oldNames[i];\n            if (symbol != null) {\n                ++symbolsSeen;\n                int hash = symbol.hashCode();\n                int ix = (hash & _mainHashMask);\n                _mainNames[ix] = symbol;\n                _mainHash[ix] = hash << 8; // will clear spill index\n            }\n        }\n\n        /* And then the spill area. This may cause collisions, although\n         * not necessarily as many as there were earlier. Let's allocate\n         * same amount of space, however\n         */\n        int oldEnd = _collEnd;\n        if (oldEnd == 0) { // no prior collisions...\n            _longestCollisionList = 0;\n            return;\n        }\n\n        _collCount = 0;\n        _collEnd = 0;\n        _collListShared = false;\n\n        int maxColl = 0;\n        \n        Bucket[] oldBuckets = _collList;\n        _collList = new Bucket[oldBuckets.length];\n        for (int i = 0; i < oldEnd; ++i) {\n            for (Bucket curr = oldBuckets[i]; curr != null; curr = curr._next) {\n                ++symbolsSeen;\n                Name symbol = curr._name;\n                int hash = symbol.hashCode();\n                int ix = (hash & _mainHashMask);\n                int val = _mainHash[ix];\n                if (_mainNames[ix] == null) { // no primary entry?\n_mainHash[ix] = (_mainHash[ix] + _mainHash[0]);\n                    _mainNames[ix] = symbol;\n                } else { // nope, it's a collision, need to spill over\n                    ++_collCount;\n                    int bucket = val & 0xFF;\n                    if (bucket == 0) { // first spill over?\n                        if (_collEnd <= LAST_VALID_BUCKET) { // yup, still unshared bucket\n                            bucket = _collEnd;\n                            ++_collEnd;\n                            // need to expand?\n                            if (bucket >= _collList.length) {\n                                expandCollision();\n                            }\n                        } else { // nope, have to share... let's find shortest?\n                            bucket = findBestBucket();\n                        }\n                        // Need to mark the entry... and the spill index is 1-based\n                        _mainHash[ix] = (val & ~0xFF) | (bucket + 1);\n                    } else {\n                        --bucket; // 1-based index in value\n                    }\n                    // And then just need to link the new bucket entry in\n                    Bucket newB = new Bucket(symbol, _collList[bucket]);\n                    _collList[bucket] = newB;\n                    maxColl = Math.max(maxColl, newB.length());\n                }\n            } // for (... buckets in the chain ...)\n        } // for (... list of bucket heads ... )\n\n        _longestCollisionList = maxColl;\n        \n        if (symbolsSeen != _count) { // sanity check\n            throw new RuntimeException(\"Internal error: count after rehash \"+symbolsSeen+\"; should be \"+_count);\n        }\n    }",
          "88": "    private void rehash()\n    {\n        _needRehash = false;        \n        // Note: since we'll make copies, no need to unshare, can just mark as such:\n        _mainNamesShared = false;\n\n        /* And then we can first deal with the main hash area. Since we\n         * are expanding linearly (double up), we know there'll be no\n         * collisions during this phase.\n         */\n        int[] oldMainHash = _mainHash;\n        int len = oldMainHash.length;\n        int newLen = len+len;\n\n        /* 13-Mar-2010, tatu: Let's guard against OOME that could be caused by\n         *    large documents with unique (or mostly so) names\n         */\n        if (newLen > MAX_TABLE_SIZE) {\n            nukeSymbols();\n            return;\n        }\n        \n        _mainHash = new int[newLen];\n        _mainHashMask = (newLen - 1);\n        Name[] oldNames = _mainNames;\n        _mainNames = new Name[newLen];\n        int symbolsSeen = 0; // let's do a sanity check\n        for (int i = 0; i < len; ++i) {\n            Name symbol = oldNames[i];\n            if (symbol != null) {\n                ++symbolsSeen;\n                int hash = symbol.hashCode();\n                int ix = (hash & _mainHashMask);\n                _mainNames[ix] = symbol;\n                _mainHash[ix] = hash << 8; // will clear spill index\n            }\n        }\n\n        /* And then the spill area. This may cause collisions, although\n         * not necessarily as many as there were earlier. Let's allocate\n         * same amount of space, however\n         */\n        int oldEnd = _collEnd;\n        if (oldEnd == 0) { // no prior collisions...\n            _longestCollisionList = 0;\n            return;\n        }\n\n        _collCount = 0;\n        _collEnd = 0;\n        _collListShared = false;\n\n        int maxColl = 0;\n        \n        Bucket[] oldBuckets = _collList;\n        _collList = new Bucket[oldBuckets.length];\n        for (int i = 0; i < oldEnd; ++i) {\n            for (Bucket curr = oldBuckets[i]; curr != null; curr = curr._next) {\n                ++symbolsSeen;\n                Name symbol = curr._name;\n                int hash = symbol.hashCode();\n                int ix = (hash & _mainHashMask);\n                int val = _mainHash[ix];\n                if (_mainNames[ix] == null) { // no primary entry?\n_mainHash[ix] = (_mainHash[ix] + _mainHash[1]);\n                    _mainNames[ix] = symbol;\n                } else { // nope, it's a collision, need to spill over\n                    ++_collCount;\n                    int bucket = val & 0xFF;\n                    if (bucket == 0) { // first spill over?\n                        if (_collEnd <= LAST_VALID_BUCKET) { // yup, still unshared bucket\n                            bucket = _collEnd;\n                            ++_collEnd;\n                            // need to expand?\n                            if (bucket >= _collList.length) {\n                                expandCollision();\n                            }\n                        } else { // nope, have to share... let's find shortest?\n                            bucket = findBestBucket();\n                        }\n                        // Need to mark the entry... and the spill index is 1-based\n                        _mainHash[ix] = (val & ~0xFF) | (bucket + 1);\n                    } else {\n                        --bucket; // 1-based index in value\n                    }\n                    // And then just need to link the new bucket entry in\n                    Bucket newB = new Bucket(symbol, _collList[bucket]);\n                    _collList[bucket] = newB;\n                    maxColl = Math.max(maxColl, newB.length());\n                }\n            } // for (... buckets in the chain ...)\n        } // for (... list of bucket heads ... )\n\n        _longestCollisionList = maxColl;\n        \n        if (symbolsSeen != _count) { // sanity check\n            throw new RuntimeException(\"Internal error: count after rehash \"+symbolsSeen+\"; should be \"+_count);\n        }\n    }",
          "89": "    private void rehash()\n    {\n        _needRehash = false;        \n        // Note: since we'll make copies, no need to unshare, can just mark as such:\n        _mainNamesShared = false;\n\n        /* And then we can first deal with the main hash area. Since we\n         * are expanding linearly (double up), we know there'll be no\n         * collisions during this phase.\n         */\n        int[] oldMainHash = _mainHash;\n        int len = oldMainHash.length;\n        int newLen = len+len;\n\n        /* 13-Mar-2010, tatu: Let's guard against OOME that could be caused by\n         *    large documents with unique (or mostly so) names\n         */\n        if (newLen > MAX_TABLE_SIZE) {\n            nukeSymbols();\n            return;\n        }\n        \n        _mainHash = new int[newLen];\n        _mainHashMask = (newLen - 1);\n        Name[] oldNames = _mainNames;\n        _mainNames = new Name[newLen];\n        int symbolsSeen = 0; // let's do a sanity check\n        for (int i = 0; i < len; ++i) {\n            Name symbol = oldNames[i];\n            if (symbol != null) {\n                ++symbolsSeen;\n                int hash = symbol.hashCode();\n                int ix = (hash & _mainHashMask);\n                _mainNames[ix] = symbol;\n                _mainHash[ix] = hash << 8; // will clear spill index\n            }\n        }\n\n        /* And then the spill area. This may cause collisions, although\n         * not necessarily as many as there were earlier. Let's allocate\n         * same amount of space, however\n         */\n        int oldEnd = _collEnd;\n        if (oldEnd == 0) { // no prior collisions...\n            _longestCollisionList = 0;\n            return;\n        }\n\n        _collCount = 0;\n        _collEnd = 0;\n        _collListShared = false;\n\n        int maxColl = 0;\n        \n        Bucket[] oldBuckets = _collList;\n        _collList = new Bucket[oldBuckets.length];\n        for (int i = 0; i < oldEnd; ++i) {\n            for (Bucket curr = oldBuckets[i]; curr != null; curr = curr._next) {\n                ++symbolsSeen;\n                Name symbol = curr._name;\n                int hash = symbol.hashCode();\n                int ix = (hash & _mainHashMask);\n                int val = _mainHash[ix];\n                if (_mainNames[ix] == null) { // no primary entry?\n_mainHash[ix] = ((_mainHash[ix] * 8) + _mainHash[ix]);\n                    _mainNames[ix] = symbol;\n                } else { // nope, it's a collision, need to spill over\n                    ++_collCount;\n                    int bucket = val & 0xFF;\n                    if (bucket == 0) { // first spill over?\n                        if (_collEnd <= LAST_VALID_BUCKET) { // yup, still unshared bucket\n                            bucket = _collEnd;\n                            ++_collEnd;\n                            // need to expand?\n                            if (bucket >= _collList.length) {\n                                expandCollision();\n                            }\n                        } else { // nope, have to share... let's find shortest?\n                            bucket = findBestBucket();\n                        }\n                        // Need to mark the entry... and the spill index is 1-based\n                        _mainHash[ix] = (val & ~0xFF) | (bucket + 1);\n                    } else {\n                        --bucket; // 1-based index in value\n                    }\n                    // And then just need to link the new bucket entry in\n                    Bucket newB = new Bucket(symbol, _collList[bucket]);\n                    _collList[bucket] = newB;\n                    maxColl = Math.max(maxColl, newB.length());\n                }\n            } // for (... buckets in the chain ...)\n        } // for (... list of bucket heads ... )\n\n        _longestCollisionList = maxColl;\n        \n        if (symbolsSeen != _count) { // sanity check\n            throw new RuntimeException(\"Internal error: count after rehash \"+symbolsSeen+\"; should be \"+_count);\n        }\n    }",
          "90": "    private void rehash()\n    {\n        _needRehash = false;        \n        // Note: since we'll make copies, no need to unshare, can just mark as such:\n        _mainNamesShared = false;\n\n        /* And then we can first deal with the main hash area. Since we\n         * are expanding linearly (double up), we know there'll be no\n         * collisions during this phase.\n         */\n        int[] oldMainHash = _mainHash;\n        int len = oldMainHash.length;\n        int newLen = len+len;\n\n        /* 13-Mar-2010, tatu: Let's guard against OOME that could be caused by\n         *    large documents with unique (or mostly so) names\n         */\n        if (newLen > MAX_TABLE_SIZE) {\n            nukeSymbols();\n            return;\n        }\n        \n        _mainHash = new int[newLen];\n        _mainHashMask = (newLen - 1);\n        Name[] oldNames = _mainNames;\n        _mainNames = new Name[newLen];\n        int symbolsSeen = 0; // let's do a sanity check\n        for (int i = 0; i < len; ++i) {\n            Name symbol = oldNames[i];\n            if (symbol != null) {\n                ++symbolsSeen;\n                int hash = symbol.hashCode();\n                int ix = (hash & _mainHashMask);\n                _mainNames[ix] = symbol;\n                _mainHash[ix] = hash << 8; // will clear spill index\n            }\n        }\n\n        /* And then the spill area. This may cause collisions, although\n         * not necessarily as many as there were earlier. Let's allocate\n         * same amount of space, however\n         */\n        int oldEnd = _collEnd;\n        if (oldEnd == 0) { // no prior collisions...\n            _longestCollisionList = 0;\n            return;\n        }\n\n        _collCount = 0;\n        _collEnd = 0;\n        _collListShared = false;\n\n        int maxColl = 0;\n        \n        Bucket[] oldBuckets = _collList;\n        _collList = new Bucket[oldBuckets.length];\n        for (int i = 0; i < oldEnd; ++i) {\n            for (Bucket curr = oldBuckets[i]; curr != null; curr = curr._next) {\n                ++symbolsSeen;\n                Name symbol = curr._name;\n                int hash = symbol.hashCode();\n                int ix = (hash & _mainHashMask);\n                int val = _mainHash[ix];\n                if (_mainNames[ix] == null) { // no primary entry?\n_mainHash[ix] = ((_mainHash[ix] * 0) + 8);\n                    _mainNames[ix] = symbol;\n                } else { // nope, it's a collision, need to spill over\n                    ++_collCount;\n                    int bucket = val & 0xFF;\n                    if (bucket == 0) { // first spill over?\n                        if (_collEnd <= LAST_VALID_BUCKET) { // yup, still unshared bucket\n                            bucket = _collEnd;\n                            ++_collEnd;\n                            // need to expand?\n                            if (bucket >= _collList.length) {\n                                expandCollision();\n                            }\n                        } else { // nope, have to share... let's find shortest?\n                            bucket = findBestBucket();\n                        }\n                        // Need to mark the entry... and the spill index is 1-based\n                        _mainHash[ix] = (val & ~0xFF) | (bucket + 1);\n                    } else {\n                        --bucket; // 1-based index in value\n                    }\n                    // And then just need to link the new bucket entry in\n                    Bucket newB = new Bucket(symbol, _collList[bucket]);\n                    _collList[bucket] = newB;\n                    maxColl = Math.max(maxColl, newB.length());\n                }\n            } // for (... buckets in the chain ...)\n        } // for (... list of bucket heads ... )\n\n        _longestCollisionList = maxColl;\n        \n        if (symbolsSeen != _count) { // sanity check\n            throw new RuntimeException(\"Internal error: count after rehash \"+symbolsSeen+\"; should be \"+_count);\n        }\n    }",
          "91": "    private void rehash()\n    {\n        _needRehash = false;        \n        // Note: since we'll make copies, no need to unshare, can just mark as such:\n        _mainNamesShared = false;\n\n        /* And then we can first deal with the main hash area. Since we\n         * are expanding linearly (double up), we know there'll be no\n         * collisions during this phase.\n         */\n        int[] oldMainHash = _mainHash;\n        int len = oldMainHash.length;\n        int newLen = len+len;\n\n        /* 13-Mar-2010, tatu: Let's guard against OOME that could be caused by\n         *    large documents with unique (or mostly so) names\n         */\n        if (newLen > MAX_TABLE_SIZE) {\n            nukeSymbols();\n            return;\n        }\n        \n        _mainHash = new int[newLen];\n        _mainHashMask = (newLen - 1);\n        Name[] oldNames = _mainNames;\n        _mainNames = new Name[newLen];\n        int symbolsSeen = 0; // let's do a sanity check\n        for (int i = 0; i < len; ++i) {\n            Name symbol = oldNames[i];\n            if (symbol != null) {\n                ++symbolsSeen;\n                int hash = symbol.hashCode();\n                int ix = (hash & _mainHashMask);\n                _mainNames[ix] = symbol;\n                _mainHash[ix] = hash << 8; // will clear spill index\n            }\n        }\n\n        /* And then the spill area. This may cause collisions, although\n         * not necessarily as many as there were earlier. Let's allocate\n         * same amount of space, however\n         */\n        int oldEnd = _collEnd;\n        if (oldEnd == 0) { // no prior collisions...\n            _longestCollisionList = 0;\n            return;\n        }\n\n        _collCount = 0;\n        _collEnd = 0;\n        _collListShared = false;\n\n        int maxColl = 0;\n        \n        Bucket[] oldBuckets = _collList;\n        _collList = new Bucket[oldBuckets.length];\n        for (int i = 0; i < oldEnd; ++i) {\n            for (Bucket curr = oldBuckets[i]; curr != null; curr = curr._next) {\n                ++symbolsSeen;\n                Name symbol = curr._name;\n                int hash = symbol.hashCode();\n                int ix = (hash & _mainHashMask);\n                int val = _mainHash[ix];\n                if (_mainNames[ix] == null) { // no primary entry?\n_mainHash[ix] = ((_mainHash[ix] * 8) + _mainHash[1]);\n                    _mainNames[ix] = symbol;\n                } else { // nope, it's a collision, need to spill over\n                    ++_collCount;\n                    int bucket = val & 0xFF;\n                    if (bucket == 0) { // first spill over?\n                        if (_collEnd <= LAST_VALID_BUCKET) { // yup, still unshared bucket\n                            bucket = _collEnd;\n                            ++_collEnd;\n                            // need to expand?\n                            if (bucket >= _collList.length) {\n                                expandCollision();\n                            }\n                        } else { // nope, have to share... let's find shortest?\n                            bucket = findBestBucket();\n                        }\n                        // Need to mark the entry... and the spill index is 1-based\n                        _mainHash[ix] = (val & ~0xFF) | (bucket + 1);\n                    } else {\n                        --bucket; // 1-based index in value\n                    }\n                    // And then just need to link the new bucket entry in\n                    Bucket newB = new Bucket(symbol, _collList[bucket]);\n                    _collList[bucket] = newB;\n                    maxColl = Math.max(maxColl, newB.length());\n                }\n            } // for (... buckets in the chain ...)\n        } // for (... list of bucket heads ... )\n\n        _longestCollisionList = maxColl;\n        \n        if (symbolsSeen != _count) { // sanity check\n            throw new RuntimeException(\"Internal error: count after rehash \"+symbolsSeen+\"; should be \"+_count);\n        }\n    }"
}