{
          "0": "    public void acosh(final double[] operand, final int operandOffset,\n                     final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        double[] function = new double[1 + order];\n        final double x = operand[operandOffset];\n        function[0] = FastMath.acosh(x);\n        if (order > 0) {\n            // the nth order derivative of acosh has the form:\n            // dn(acosh(x)/dxn = P_n(x) / [x^2 - 1]^((2n-1)/2)\n            // where P_n(x) is a degree n-1 polynomial with same parity as n-1\n            // P_1(x) = 1, P_2(x) = -x, P_3(x) = 2x^2 + 1 ...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = (x^2-1) P_(n-1)'(x) - (2n-3) x P_(n-1)(x)\n            // as per polynomial parity, we can store coefficients of both P_(n-1) and P_n in the same array\n            final double[] p = new double[order];\n            p[0] = 1;\n            final double x2  = x * x;\n            final double f   = 1.0 / (x2 - 1);\n            double coeff = FastMath.sqrt(f);\n            function[1] = coeff * p[0];\n            for (int n = 2; n <= order; ++n) {\n\n                // update and evaluate polynomial P_n(x)\n                double v = 0;\n                p[n - 1] = (1 - n) * p[n - 2];\n                for (int k = n - 1; k >= 0; k -= 2) {\n                    v = v * x2 + p[k];\n                    if (k > 2) {\n                        p[k - 2] = (1 - k) * p[k - 1] + (k - 2 * n) * p[k - 3];\n                    } else if (k == 2) {\n                        p[0] = -p[1];\n                    }\n                }\nif((n ^<> 1)){\n                    v *= x;\n                }\n\n                coeff *= f;\n                function[n] = coeff * v;\n\n            }\n        }\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }",
          "1": "    public void acosh(final double[] operand, final int operandOffset,\n                     final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        double[] function = new double[1 + order];\n        final double x = operand[operandOffset];\n        function[0] = FastMath.acosh(x);\n        if (order > 0) {\n            // the nth order derivative of acosh has the form:\n            // dn(acosh(x)/dxn = P_n(x) / [x^2 - 1]^((2n-1)/2)\n            // where P_n(x) is a degree n-1 polynomial with same parity as n-1\n            // P_1(x) = 1, P_2(x) = -x, P_3(x) = 2x^2 + 1 ...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = (x^2-1) P_(n-1)'(x) - (2n-3) x P_(n-1)(x)\n            // as per polynomial parity, we can store coefficients of both P_(n-1) and P_n in the same array\n            final double[] p = new double[order];\n            p[0] = 1;\n            final double x2  = x * x;\n            final double f   = 1.0 / (x2 - 1);\n            double coeff = FastMath.sqrt(f);\n            function[1] = coeff * p[0];\n            for (int n = 2; n <= order; ++n) {\n\n                // update and evaluate polynomial P_n(x)\n                double v = 0;\n                p[n - 1] = (1 - n) * p[n - 2];\n                for (int k = n - 1; k >= 0; k -= 2) {\n                    v = v * x2 + p[k];\n                    if (k > 2) {\n                        p[k - 2] = (1 - k) * p[k - 1] + (k - 2 * n) * p[k - 3];\n                    } else if (k == 2) {\n                        p[0] = -p[1];\n                    }\n                }\np[0] = -p[1];\n                if ((n ^ 1) == 0) {                    v *= x;\n                }\n\n                coeff *= f;\n                function[n] = coeff * v;\n\n            }\n        }\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }",
          "2": "    public void acosh(final double[] operand, final int operandOffset,\n                     final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        double[] function = new double[1 + order];\n        final double x = operand[operandOffset];\n        function[0] = FastMath.acosh(x);\n        if (order > 0) {\n            // the nth order derivative of acosh has the form:\n            // dn(acosh(x)/dxn = P_n(x) / [x^2 - 1]^((2n-1)/2)\n            // where P_n(x) is a degree n-1 polynomial with same parity as n-1\n            // P_1(x) = 1, P_2(x) = -x, P_3(x) = 2x^2 + 1 ...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = (x^2-1) P_(n-1)'(x) - (2n-3) x P_(n-1)(x)\n            // as per polynomial parity, we can store coefficients of both P_(n-1) and P_n in the same array\n            final double[] p = new double[order];\n            p[0] = 1;\n            final double x2  = x * x;\n            final double f   = 1.0 / (x2 - 1);\n            double coeff = FastMath.sqrt(f);\n            function[1] = coeff * p[0];\n            for (int n = 2; n <= order; ++n) {\n\n                // update and evaluate polynomial P_n(x)\n                double v = 0;\n                p[n - 1] = (1 - n) * p[n - 2];\n                for (int k = n - 1; k >= 0; k -= 2) {\n                    v = v * x2 + p[k];\n                    if (k > 2) {\n                        p[k - 2] = (1 - k) * p[k - 1] + (k - 2 * n) * p[k - 3];\n                    } else if (k == 2) {\n                        p[0] = -p[1];\n                    }\n                }\nv *= x;\n                if ((n ^ 1) == 0) {                    v *= x;\n                }\n\n                coeff *= f;\n                function[n] = coeff * v;\n\n            }\n        }\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }",
          "3": "    public void acosh(final double[] operand, final int operandOffset,\n                     final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        double[] function = new double[1 + order];\n        final double x = operand[operandOffset];\n        function[0] = FastMath.acosh(x);\n        if (order > 0) {\n            // the nth order derivative of acosh has the form:\n            // dn(acosh(x)/dxn = P_n(x) / [x^2 - 1]^((2n-1)/2)\n            // where P_n(x) is a degree n-1 polynomial with same parity as n-1\n            // P_1(x) = 1, P_2(x) = -x, P_3(x) = 2x^2 + 1 ...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = (x^2-1) P_(n-1)'(x) - (2n-3) x P_(n-1)(x)\n            // as per polynomial parity, we can store coefficients of both P_(n-1) and P_n in the same array\n            final double[] p = new double[order];\n            p[0] = 1;\n            final double x2  = x * x;\n            final double f   = 1.0 / (x2 - 1);\n            double coeff = FastMath.sqrt(f);\n            function[1] = coeff * p[0];\n            for (int n = 2; n <= order; ++n) {\n\n                // update and evaluate polynomial P_n(x)\n                double v = 0;\n                p[n - 1] = (1 - n) * p[n - 2];\n                for (int k = n - 1; k >= 0; k -= 2) {\n                    v = v * x2 + p[k];\n                    if (k > 2) {\n                        p[k - 2] = (1 - k) * p[k - 1] + (k - 2 * n) * p[k - 3];\n                    } else if (k == 2) {\n                        p[0] = -p[1];\n                    }\n                }\nfunction[n] = (coeff * v);\n                if ((n ^ 1) == 0) {                    v *= x;\n                }\n\n                coeff *= f;\n                function[n] = coeff * v;\n\n            }\n        }\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }",
          "4": "    public void acosh(final double[] operand, final int operandOffset,\n                     final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        double[] function = new double[1 + order];\n        final double x = operand[operandOffset];\n        function[0] = FastMath.acosh(x);\n        if (order > 0) {\n            // the nth order derivative of acosh has the form:\n            // dn(acosh(x)/dxn = P_n(x) / [x^2 - 1]^((2n-1)/2)\n            // where P_n(x) is a degree n-1 polynomial with same parity as n-1\n            // P_1(x) = 1, P_2(x) = -x, P_3(x) = 2x^2 + 1 ...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = (x^2-1) P_(n-1)'(x) - (2n-3) x P_(n-1)(x)\n            // as per polynomial parity, we can store coefficients of both P_(n-1) and P_n in the same array\n            final double[] p = new double[order];\n            p[0] = 1;\n            final double x2  = x * x;\n            final double f   = 1.0 / (x2 - 1);\n            double coeff = FastMath.sqrt(f);\n            function[1] = coeff * p[0];\n            for (int n = 2; n <= order; ++n) {\n\n                // update and evaluate polynomial P_n(x)\n                double v = 0;\n                p[n - 1] = (1 - n) * p[n - 2];\n                for (int k = n - 1; k >= 0; k -= 2) {\n                    v = v * x2 + p[k];\n                    if (k > 2) {\n                        p[k - 2] = (1 - k) * p[k - 1] + (k - 2 * n) * p[k - 3];\n                    } else if (k == 2) {\n                        p[0] = -p[1];\n                    }\n                }\ncoeff *= f;\n                if ((n ^ 1) == 0) {                    v *= x;\n                }\n\n                coeff *= f;\n                function[n] = coeff * v;\n\n            }\n        }\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }",
          "5": "    public void acosh(final double[] operand, final int operandOffset,\n                     final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        double[] function = new double[1 + order];\n        final double x = operand[operandOffset];\n        function[0] = FastMath.acosh(x);\n        if (order > 0) {\n            // the nth order derivative of acosh has the form:\n            // dn(acosh(x)/dxn = P_n(x) / [x^2 - 1]^((2n-1)/2)\n            // where P_n(x) is a degree n-1 polynomial with same parity as n-1\n            // P_1(x) = 1, P_2(x) = -x, P_3(x) = 2x^2 + 1 ...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = (x^2-1) P_(n-1)'(x) - (2n-3) x P_(n-1)(x)\n            // as per polynomial parity, we can store coefficients of both P_(n-1) and P_n in the same array\n            final double[] p = new double[order];\n            p[0] = 1;\n            final double x2  = x * x;\n            final double f   = 1.0 / (x2 - 1);\n            double coeff = FastMath.sqrt(f);\n            function[1] = coeff * p[0];\n            for (int n = 2; n <= order; ++n) {\n\n                // update and evaluate polynomial P_n(x)\n                double v = 0;\n                p[n - 1] = (1 - n) * p[n - 2];\n                for (int k = n - 1; k >= 0; k -= 2) {\n                    v = v * x2 + p[k];\n                    if (k > 2) {\n                        p[k - 2] = (1 - k) * p[k - 1] + (k - 2 * n) * p[k - 3];\n                    } else if (k == 2) {\n                        p[0] = -p[1];\n                    }\n                }\nbreak;\n                if ((n ^ 1) == 0) {                    v *= x;\n                }\n\n                coeff *= f;\n                function[n] = coeff * v;\n\n            }\n        }\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }",
          "6": "    public void acosh(final double[] operand, final int operandOffset,\n                     final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        double[] function = new double[1 + order];\n        final double x = operand[operandOffset];\n        function[0] = FastMath.acosh(x);\n        if (order > 0) {\n            // the nth order derivative of acosh has the form:\n            // dn(acosh(x)/dxn = P_n(x) / [x^2 - 1]^((2n-1)/2)\n            // where P_n(x) is a degree n-1 polynomial with same parity as n-1\n            // P_1(x) = 1, P_2(x) = -x, P_3(x) = 2x^2 + 1 ...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = (x^2-1) P_(n-1)'(x) - (2n-3) x P_(n-1)(x)\n            // as per polynomial parity, we can store coefficients of both P_(n-1) and P_n in the same array\n            final double[] p = new double[order];\n            p[0] = 1;\n            final double x2  = x * x;\n            final double f   = 1.0 / (x2 - 1);\n            double coeff = FastMath.sqrt(f);\n            function[1] = coeff * p[0];\n            for (int n = 2; n <= order; ++n) {\n\n                // update and evaluate polynomial P_n(x)\n                double v = 0;\n                p[n - 1] = (1 - n) * p[n - 2];\n                for (int k = n - 1; k >= 0; k -= 2) {\n                    v = v * x2 + p[k];\n                    if (k > 2) {\n                        p[k - 2] = (1 - k) * p[k - 1] + (k - 2 * n) * p[k - 3];\n                    } else if (k == 2) {\n                        p[0] = -p[1];\n                    }\n                }\np[(k - 2)] = (((1 - k) * p[(k - 1)]) + ((k - (2 * n)) * p[(k - 3)]));\n                if ((n ^ 1) == 0) {                    v *= x;\n                }\n\n                coeff *= f;\n                function[n] = coeff * v;\n\n            }\n        }\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }",
          "7": "    public void acosh(final double[] operand, final int operandOffset,\n                     final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        double[] function = new double[1 + order];\n        final double x = operand[operandOffset];\n        function[0] = FastMath.acosh(x);\n        if (order > 0) {\n            // the nth order derivative of acosh has the form:\n            // dn(acosh(x)/dxn = P_n(x) / [x^2 - 1]^((2n-1)/2)\n            // where P_n(x) is a degree n-1 polynomial with same parity as n-1\n            // P_1(x) = 1, P_2(x) = -x, P_3(x) = 2x^2 + 1 ...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = (x^2-1) P_(n-1)'(x) - (2n-3) x P_(n-1)(x)\n            // as per polynomial parity, we can store coefficients of both P_(n-1) and P_n in the same array\n            final double[] p = new double[order];\n            p[0] = 1;\n            final double x2  = x * x;\n            final double f   = 1.0 / (x2 - 1);\n            double coeff = FastMath.sqrt(f);\n            function[1] = coeff * p[0];\n            for (int n = 2; n <= order; ++n) {\n\n                // update and evaluate polynomial P_n(x)\n                double v = 0;\n                p[n - 1] = (1 - n) * p[n - 2];\n                for (int k = n - 1; k >= 0; k -= 2) {\n                    v = v * x2 + p[k];\n                    if (k > 2) {\n                        p[k - 2] = (1 - k) * p[k - 1] + (k - 2 * n) * p[k - 3];\n                    } else if (k == 2) {\n                        p[0] = -p[1];\n                    }\n                }\nv = ((v * x2) + p[k]);\n                if ((n ^ 1) == 0) {                    v *= x;\n                }\n\n                coeff *= f;\n                function[n] = coeff * v;\n\n            }\n        }\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }",
          "8": "    public void acosh(final double[] operand, final int operandOffset,\n                     final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        double[] function = new double[1 + order];\n        final double x = operand[operandOffset];\n        function[0] = FastMath.acosh(x);\n        if (order > 0) {\n            // the nth order derivative of acosh has the form:\n            // dn(acosh(x)/dxn = P_n(x) / [x^2 - 1]^((2n-1)/2)\n            // where P_n(x) is a degree n-1 polynomial with same parity as n-1\n            // P_1(x) = 1, P_2(x) = -x, P_3(x) = 2x^2 + 1 ...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = (x^2-1) P_(n-1)'(x) - (2n-3) x P_(n-1)(x)\n            // as per polynomial parity, we can store coefficients of both P_(n-1) and P_n in the same array\n            final double[] p = new double[order];\n            p[0] = 1;\n            final double x2  = x * x;\n            final double f   = 1.0 / (x2 - 1);\n            double coeff = FastMath.sqrt(f);\n            function[1] = coeff * p[0];\n            for (int n = 2; n <= order; ++n) {\n\n                // update and evaluate polynomial P_n(x)\n                double v = 0;\n                p[n - 1] = (1 - n) * p[n - 2];\n                for (int k = n - 1; k >= 0; k -= 2) {\n                    v = v * x2 + p[k];\n                    if (k > 2) {\n                        p[k - 2] = (1 - k) * p[k - 1] + (k - 2 * n) * p[k - 3];\n                    } else if (k == 2) {\n                        p[0] = -p[1];\n                    }\n                }\nfunction[1] = (coeff * p[0]);\n                if ((n ^ 1) == 0) {                    v *= x;\n                }\n\n                coeff *= f;\n                function[n] = coeff * v;\n\n            }\n        }\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }",
          "9": "    public void acosh(final double[] operand, final int operandOffset,\n                     final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        double[] function = new double[1 + order];\n        final double x = operand[operandOffset];\n        function[0] = FastMath.acosh(x);\n        if (order > 0) {\n            // the nth order derivative of acosh has the form:\n            // dn(acosh(x)/dxn = P_n(x) / [x^2 - 1]^((2n-1)/2)\n            // where P_n(x) is a degree n-1 polynomial with same parity as n-1\n            // P_1(x) = 1, P_2(x) = -x, P_3(x) = 2x^2 + 1 ...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = (x^2-1) P_(n-1)'(x) - (2n-3) x P_(n-1)(x)\n            // as per polynomial parity, we can store coefficients of both P_(n-1) and P_n in the same array\n            final double[] p = new double[order];\n            p[0] = 1;\n            final double x2  = x * x;\n            final double f   = 1.0 / (x2 - 1);\n            double coeff = FastMath.sqrt(f);\n            function[1] = coeff * p[0];\n            for (int n = 2; n <= order; ++n) {\n\n                // update and evaluate polynomial P_n(x)\n                double v = 0;\n                p[n - 1] = (1 - n) * p[n - 2];\n                for (int k = n - 1; k >= 0; k -= 2) {\n                    v = v * x2 + p[k];\n                    if (k > 2) {\n                        p[k - 2] = (1 - k) * p[k - 1] + (k - 2 * n) * p[k - 3];\n                    } else if (k == 2) {\n                        p[0] = -p[1];\n                    }\n                }\np[(n - 1)] = ((1 - n) * p[(n - 2)]);\n                if ((n ^ 1) == 0) {                    v *= x;\n                }\n\n                coeff *= f;\n                function[n] = coeff * v;\n\n            }\n        }\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }",
          "10": "    public void acosh(final double[] operand, final int operandOffset,\n                     final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        double[] function = new double[1 + order];\n        final double x = operand[operandOffset];\n        function[0] = FastMath.acosh(x);\n        if (order > 0) {\n            // the nth order derivative of acosh has the form:\n            // dn(acosh(x)/dxn = P_n(x) / [x^2 - 1]^((2n-1)/2)\n            // where P_n(x) is a degree n-1 polynomial with same parity as n-1\n            // P_1(x) = 1, P_2(x) = -x, P_3(x) = 2x^2 + 1 ...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = (x^2-1) P_(n-1)'(x) - (2n-3) x P_(n-1)(x)\n            // as per polynomial parity, we can store coefficients of both P_(n-1) and P_n in the same array\n            final double[] p = new double[order];\n            p[0] = 1;\n            final double x2  = x * x;\n            final double f   = 1.0 / (x2 - 1);\n            double coeff = FastMath.sqrt(f);\n            function[1] = coeff * p[0];\n            for (int n = 2; n <= order; ++n) {\n\n                // update and evaluate polynomial P_n(x)\n                double v = 0;\n                p[n - 1] = (1 - n) * p[n - 2];\n                for (int k = n - 1; k >= 0; k -= 2) {\n                    v = v * x2 + p[k];\n                    if (k > 2) {\n                        p[k - 2] = (1 - k) * p[k - 1] + (k - 2 * n) * p[k - 3];\n                    } else if (k == 2) {\n                        p[0] = -p[1];\n                    }\n                }\nif(((n ^<> 1) >= 0)){                    v *= x;\n                }\n\n                coeff *= f;\n                function[n] = coeff * v;\n\n            }\n        }\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }",
          "11": "    public void acosh(final double[] operand, final int operandOffset,\n                     final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        double[] function = new double[1 + order];\n        final double x = operand[operandOffset];\n        function[0] = FastMath.acosh(x);\n        if (order > 0) {\n            // the nth order derivative of acosh has the form:\n            // dn(acosh(x)/dxn = P_n(x) / [x^2 - 1]^((2n-1)/2)\n            // where P_n(x) is a degree n-1 polynomial with same parity as n-1\n            // P_1(x) = 1, P_2(x) = -x, P_3(x) = 2x^2 + 1 ...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = (x^2-1) P_(n-1)'(x) - (2n-3) x P_(n-1)(x)\n            // as per polynomial parity, we can store coefficients of both P_(n-1) and P_n in the same array\n            final double[] p = new double[order];\n            p[0] = 1;\n            final double x2  = x * x;\n            final double f   = 1.0 / (x2 - 1);\n            double coeff = FastMath.sqrt(f);\n            function[1] = coeff * p[0];\n            for (int n = 2; n <= order; ++n) {\n\n                // update and evaluate polynomial P_n(x)\n                double v = 0;\n                p[n - 1] = (1 - n) * p[n - 2];\n                for (int k = n - 1; k >= 0; k -= 2) {\n                    v = v * x2 + p[k];\n                    if (k > 2) {\n                        p[k - 2] = (1 - k) * p[k - 1] + (k - 2 * n) * p[k - 3];\n                    } else if (k == 2) {\n                        p[0] = -p[1];\n                    }\n                }\nreturn;\n                if ((n ^ 1) == 0) {                    v *= x;\n                }\n\n                coeff *= f;\n                function[n] = coeff * v;\n\n            }\n        }\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }",
          "12": "    public void acosh(final double[] operand, final int operandOffset,\n                     final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        double[] function = new double[1 + order];\n        final double x = operand[operandOffset];\n        function[0] = FastMath.acosh(x);\n        if (order > 0) {\n            // the nth order derivative of acosh has the form:\n            // dn(acosh(x)/dxn = P_n(x) / [x^2 - 1]^((2n-1)/2)\n            // where P_n(x) is a degree n-1 polynomial with same parity as n-1\n            // P_1(x) = 1, P_2(x) = -x, P_3(x) = 2x^2 + 1 ...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = (x^2-1) P_(n-1)'(x) - (2n-3) x P_(n-1)(x)\n            // as per polynomial parity, we can store coefficients of both P_(n-1) and P_n in the same array\n            final double[] p = new double[order];\n            p[0] = 1;\n            final double x2  = x * x;\n            final double f   = 1.0 / (x2 - 1);\n            double coeff = FastMath.sqrt(f);\n            function[1] = coeff * p[0];\n            for (int n = 2; n <= order; ++n) {\n\n                // update and evaluate polynomial P_n(x)\n                double v = 0;\n                p[n - 1] = (1 - n) * p[n - 2];\n                for (int k = n - 1; k >= 0; k -= 2) {\n                    v = v * x2 + p[k];\n                    if (k > 2) {\n                        p[k - 2] = (1 - k) * p[k - 1] + (k - 2 * n) * p[k - 3];\n                    } else if (k == 2) {\n                        p[0] = -p[1];\n                    }\n                }\nif(((n ^<> 1) == 0)){\n                    v *= x;\n                }\n\n                coeff *= f;\n                function[n] = coeff * v;\n\n            }\n        }\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }",
          "13": "    public void acosh(final double[] operand, final int operandOffset,\n                     final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        double[] function = new double[1 + order];\n        final double x = operand[operandOffset];\n        function[0] = FastMath.acosh(x);\n        if (order > 0) {\n            // the nth order derivative of acosh has the form:\n            // dn(acosh(x)/dxn = P_n(x) / [x^2 - 1]^((2n-1)/2)\n            // where P_n(x) is a degree n-1 polynomial with same parity as n-1\n            // P_1(x) = 1, P_2(x) = -x, P_3(x) = 2x^2 + 1 ...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = (x^2-1) P_(n-1)'(x) - (2n-3) x P_(n-1)(x)\n            // as per polynomial parity, we can store coefficients of both P_(n-1) and P_n in the same array\n            final double[] p = new double[order];\n            p[0] = 1;\n            final double x2  = x * x;\n            final double f   = 1.0 / (x2 - 1);\n            double coeff = FastMath.sqrt(f);\n            function[1] = coeff * p[0];\n            for (int n = 2; n <= order; ++n) {\n\n                // update and evaluate polynomial P_n(x)\n                double v = 0;\n                p[n - 1] = (1 - n) * p[n - 2];\n                for (int k = n - 1; k >= 0; k -= 2) {\n                    v = v * x2 + p[k];\n                    if (k > 2) {\n                        p[k - 2] = (1 - k) * p[k - 1] + (k - 2 * n) * p[k - 3];\n                    } else if (k == 2) {\n                        p[0] = -p[1];\n                    }\n                }\nif(((v ^<> 1) == 0)){                    v *= x;\n                }\n\n                coeff *= f;\n                function[n] = coeff * v;\n\n            }\n        }\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }",
          "14": "    public void acosh(final double[] operand, final int operandOffset,\n                     final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        double[] function = new double[1 + order];\n        final double x = operand[operandOffset];\n        function[0] = FastMath.acosh(x);\n        if (order > 0) {\n            // the nth order derivative of acosh has the form:\n            // dn(acosh(x)/dxn = P_n(x) / [x^2 - 1]^((2n-1)/2)\n            // where P_n(x) is a degree n-1 polynomial with same parity as n-1\n            // P_1(x) = 1, P_2(x) = -x, P_3(x) = 2x^2 + 1 ...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = (x^2-1) P_(n-1)'(x) - (2n-3) x P_(n-1)(x)\n            // as per polynomial parity, we can store coefficients of both P_(n-1) and P_n in the same array\n            final double[] p = new double[order];\n            p[0] = 1;\n            final double x2  = x * x;\n            final double f   = 1.0 / (x2 - 1);\n            double coeff = FastMath.sqrt(f);\n            function[1] = coeff * p[0];\n            for (int n = 2; n <= order; ++n) {\n\n                // update and evaluate polynomial P_n(x)\n                double v = 0;\n                p[n - 1] = (1 - n) * p[n - 2];\n                for (int k = n - 1; k >= 0; k -= 2) {\n                    v = v * x2 + p[k];\n                    if (k > 2) {\n                        p[k - 2] = (1 - k) * p[k - 1] + (k - 2 * n) * p[k - 3];\n                    } else if (k == 2) {\n                        p[0] = -p[1];\n                    }\n                }\nif(((n ^<> 1) == 0)){                    v *= x;\n                }\n\n                coeff *= f;\n                function[n] = coeff * v;\n\n            }\n        }\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }",
          "15": "    public void acosh(final double[] operand, final int operandOffset,\n                     final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        double[] function = new double[1 + order];\n        final double x = operand[operandOffset];\n        function[0] = FastMath.acosh(x);\n        if (order > 0) {\n            // the nth order derivative of acosh has the form:\n            // dn(acosh(x)/dxn = P_n(x) / [x^2 - 1]^((2n-1)/2)\n            // where P_n(x) is a degree n-1 polynomial with same parity as n-1\n            // P_1(x) = 1, P_2(x) = -x, P_3(x) = 2x^2 + 1 ...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = (x^2-1) P_(n-1)'(x) - (2n-3) x P_(n-1)(x)\n            // as per polynomial parity, we can store coefficients of both P_(n-1) and P_n in the same array\n            final double[] p = new double[order];\n            p[0] = 1;\n            final double x2  = x * x;\n            final double f   = 1.0 / (x2 - 1);\n            double coeff = FastMath.sqrt(f);\n            function[1] = coeff * p[0];\n            for (int n = 2; n <= order; ++n) {\n\n                // update and evaluate polynomial P_n(x)\n                double v = 0;\n                p[n - 1] = (1 - n) * p[n - 2];\n                for (int k = n - 1; k >= 0; k -= 2) {\n                    v = v * x2 + p[k];\n                    if (k > 2) {\n                        p[k - 2] = (1 - k) * p[k - 1] + (k - 2 * n) * p[k - 3];\n                    } else if (k == 2) {\n                        p[0] = -p[1];\n                    }\n                }\nif(((n ^<> 1) <= 0)){                    v *= x;\n                }\n\n                coeff *= f;\n                function[n] = coeff * v;\n\n            }\n        }\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }",
          "16": "    public void acosh(final double[] operand, final int operandOffset,\n                     final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        double[] function = new double[1 + order];\n        final double x = operand[operandOffset];\n        function[0] = FastMath.acosh(x);\n        if (order > 0) {\n            // the nth order derivative of acosh has the form:\n            // dn(acosh(x)/dxn = P_n(x) / [x^2 - 1]^((2n-1)/2)\n            // where P_n(x) is a degree n-1 polynomial with same parity as n-1\n            // P_1(x) = 1, P_2(x) = -x, P_3(x) = 2x^2 + 1 ...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = (x^2-1) P_(n-1)'(x) - (2n-3) x P_(n-1)(x)\n            // as per polynomial parity, we can store coefficients of both P_(n-1) and P_n in the same array\n            final double[] p = new double[order];\n            p[0] = 1;\n            final double x2  = x * x;\n            final double f   = 1.0 / (x2 - 1);\n            double coeff = FastMath.sqrt(f);\n            function[1] = coeff * p[0];\n            for (int n = 2; n <= order; ++n) {\n\n                // update and evaluate polynomial P_n(x)\n                double v = 0;\n                p[n - 1] = (1 - n) * p[n - 2];\n                for (int k = n - 1; k >= 0; k -= 2) {\n                    v = v * x2 + p[k];\n                    if (k > 2) {\n                        p[k - 2] = (1 - k) * p[k - 1] + (k - 2 * n) * p[k - 3];\n                    } else if (k == 2) {\n                        p[0] = -p[1];\n                    }\n                }\nif(((n ^<> 1) > 0)){                    v *= x;\n                }\n\n                coeff *= f;\n                function[n] = coeff * v;\n\n            }\n        }\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }",
          "17": "    public void acosh(final double[] operand, final int operandOffset,\n                     final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        double[] function = new double[1 + order];\n        final double x = operand[operandOffset];\n        function[0] = FastMath.acosh(x);\n        if (order > 0) {\n            // the nth order derivative of acosh has the form:\n            // dn(acosh(x)/dxn = P_n(x) / [x^2 - 1]^((2n-1)/2)\n            // where P_n(x) is a degree n-1 polynomial with same parity as n-1\n            // P_1(x) = 1, P_2(x) = -x, P_3(x) = 2x^2 + 1 ...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = (x^2-1) P_(n-1)'(x) - (2n-3) x P_(n-1)(x)\n            // as per polynomial parity, we can store coefficients of both P_(n-1) and P_n in the same array\n            final double[] p = new double[order];\n            p[0] = 1;\n            final double x2  = x * x;\n            final double f   = 1.0 / (x2 - 1);\n            double coeff = FastMath.sqrt(f);\n            function[1] = coeff * p[0];\n            for (int n = 2; n <= order; ++n) {\n\n                // update and evaluate polynomial P_n(x)\n                double v = 0;\n                p[n - 1] = (1 - n) * p[n - 2];\n                for (int k = n - 1; k >= 0; k -= 2) {\n                    v = v * x2 + p[k];\n                    if (k > 2) {\n                        p[k - 2] = (1 - k) * p[k - 1] + (k - 2 * n) * p[k - 3];\n                    } else if (k == 2) {\n                        p[0] = -p[1];\n                    }\n                }\nif(((n ^<> 3) == 0)){                    v *= x;\n                }\n\n                coeff *= f;\n                function[n] = coeff * v;\n\n            }\n        }\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }",
          "18": "    public void acosh(final double[] operand, final int operandOffset,\n                     final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        double[] function = new double[1 + order];\n        final double x = operand[operandOffset];\n        function[0] = FastMath.acosh(x);\n        if (order > 0) {\n            // the nth order derivative of acosh has the form:\n            // dn(acosh(x)/dxn = P_n(x) / [x^2 - 1]^((2n-1)/2)\n            // where P_n(x) is a degree n-1 polynomial with same parity as n-1\n            // P_1(x) = 1, P_2(x) = -x, P_3(x) = 2x^2 + 1 ...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = (x^2-1) P_(n-1)'(x) - (2n-3) x P_(n-1)(x)\n            // as per polynomial parity, we can store coefficients of both P_(n-1) and P_n in the same array\n            final double[] p = new double[order];\n            p[0] = 1;\n            final double x2  = x * x;\n            final double f   = 1.0 / (x2 - 1);\n            double coeff = FastMath.sqrt(f);\n            function[1] = coeff * p[0];\n            for (int n = 2; n <= order; ++n) {\n\n                // update and evaluate polynomial P_n(x)\n                double v = 0;\n                p[n - 1] = (1 - n) * p[n - 2];\n                for (int k = n - 1; k >= 0; k -= 2) {\n                    v = v * x2 + p[k];\n                    if (k > 2) {\n                        p[k - 2] = (1 - k) * p[k - 1] + (k - 2 * n) * p[k - 3];\n                    } else if (k == 2) {\n                        p[0] = -p[1];\n                    }\n                }\nif(((n ^<> 1) != 0)){                    v *= x;\n                }\n\n                coeff *= f;\n                function[n] = coeff * v;\n\n            }\n        }\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }",
          "19": "    public void acosh(final double[] operand, final int operandOffset,\n                     final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        double[] function = new double[1 + order];\n        final double x = operand[operandOffset];\n        function[0] = FastMath.acosh(x);\n        if (order > 0) {\n            // the nth order derivative of acosh has the form:\n            // dn(acosh(x)/dxn = P_n(x) / [x^2 - 1]^((2n-1)/2)\n            // where P_n(x) is a degree n-1 polynomial with same parity as n-1\n            // P_1(x) = 1, P_2(x) = -x, P_3(x) = 2x^2 + 1 ...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = (x^2-1) P_(n-1)'(x) - (2n-3) x P_(n-1)(x)\n            // as per polynomial parity, we can store coefficients of both P_(n-1) and P_n in the same array\n            final double[] p = new double[order];\n            p[0] = 1;\n            final double x2  = x * x;\n            final double f   = 1.0 / (x2 - 1);\n            double coeff = FastMath.sqrt(f);\n            function[1] = coeff * p[0];\n            for (int n = 2; n <= order; ++n) {\n\n                // update and evaluate polynomial P_n(x)\n                double v = 0;\n                p[n - 1] = (1 - n) * p[n - 2];\n                for (int k = n - 1; k >= 0; k -= 2) {\n                    v = v * x2 + p[k];\n                    if (k > 2) {\n                        p[k - 2] = (1 - k) * p[k - 1] + (k - 2 * n) * p[k - 3];\n                    } else if (k == 2) {\n                        p[0] = -p[1];\n                    }\n                }\nif(((1 - k) * p[(k - 1)])){\n                    v *= x;\n                }\n\n                coeff *= f;\n                function[n] = coeff * v;\n\n            }\n        }\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }",
          "20": "    public void acosh(final double[] operand, final int operandOffset,\n                     final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        double[] function = new double[1 + order];\n        final double x = operand[operandOffset];\n        function[0] = FastMath.acosh(x);\n        if (order > 0) {\n            // the nth order derivative of acosh has the form:\n            // dn(acosh(x)/dxn = P_n(x) / [x^2 - 1]^((2n-1)/2)\n            // where P_n(x) is a degree n-1 polynomial with same parity as n-1\n            // P_1(x) = 1, P_2(x) = -x, P_3(x) = 2x^2 + 1 ...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = (x^2-1) P_(n-1)'(x) - (2n-3) x P_(n-1)(x)\n            // as per polynomial parity, we can store coefficients of both P_(n-1) and P_n in the same array\n            final double[] p = new double[order];\n            p[0] = 1;\n            final double x2  = x * x;\n            final double f   = 1.0 / (x2 - 1);\n            double coeff = FastMath.sqrt(f);\n            function[1] = coeff * p[0];\n            for (int n = 2; n <= order; ++n) {\n\n                // update and evaluate polynomial P_n(x)\n                double v = 0;\n                p[n - 1] = (1 - n) * p[n - 2];\n                for (int k = n - 1; k >= 0; k -= 2) {\n                    v = v * x2 + p[k];\n                    if (k > 2) {\n                        p[k - 2] = (1 - k) * p[k - 1] + (k - 2 * n) * p[k - 3];\n                    } else if (k == 2) {\n                        p[0] = -p[1];\n                    }\n                }\nif((k == 2)){\n                if ((n ^ 1) == 0) {                    v *= x;\n                }\n\n                coeff *= f;\n                function[n] = coeff * v;\n\n}\n            }\n        }\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }",
          "21": "    public void acosh(final double[] operand, final int operandOffset,\n                     final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        double[] function = new double[1 + order];\n        final double x = operand[operandOffset];\n        function[0] = FastMath.acosh(x);\n        if (order > 0) {\n            // the nth order derivative of acosh has the form:\n            // dn(acosh(x)/dxn = P_n(x) / [x^2 - 1]^((2n-1)/2)\n            // where P_n(x) is a degree n-1 polynomial with same parity as n-1\n            // P_1(x) = 1, P_2(x) = -x, P_3(x) = 2x^2 + 1 ...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = (x^2-1) P_(n-1)'(x) - (2n-3) x P_(n-1)(x)\n            // as per polynomial parity, we can store coefficients of both P_(n-1) and P_n in the same array\n            final double[] p = new double[order];\n            p[0] = 1;\n            final double x2  = x * x;\n            final double f   = 1.0 / (x2 - 1);\n            double coeff = FastMath.sqrt(f);\n            function[1] = coeff * p[0];\n            for (int n = 2; n <= order; ++n) {\n\n                // update and evaluate polynomial P_n(x)\n                double v = 0;\n                p[n - 1] = (1 - n) * p[n - 2];\n                for (int k = n - 1; k >= 0; k -= 2) {\n                    v = v * x2 + p[k];\n                    if (k > 2) {\n                        p[k - 2] = (1 - k) * p[k - 1] + (k - 2 * n) * p[k - 3];\n                    } else if (k == 2) {\n                        p[0] = -p[1];\n                    }\n                }\nif(((k - (2 * n)) * p[(k - 3)])){\n                    v *= x;\n                }\n\n                coeff *= f;\n                function[n] = coeff * v;\n\n            }\n        }\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }",
          "22": "    public void acosh(final double[] operand, final int operandOffset,\n                     final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        double[] function = new double[1 + order];\n        final double x = operand[operandOffset];\n        function[0] = FastMath.acosh(x);\n        if (order > 0) {\n            // the nth order derivative of acosh has the form:\n            // dn(acosh(x)/dxn = P_n(x) / [x^2 - 1]^((2n-1)/2)\n            // where P_n(x) is a degree n-1 polynomial with same parity as n-1\n            // P_1(x) = 1, P_2(x) = -x, P_3(x) = 2x^2 + 1 ...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = (x^2-1) P_(n-1)'(x) - (2n-3) x P_(n-1)(x)\n            // as per polynomial parity, we can store coefficients of both P_(n-1) and P_n in the same array\n            final double[] p = new double[order];\n            p[0] = 1;\n            final double x2  = x * x;\n            final double f   = 1.0 / (x2 - 1);\n            double coeff = FastMath.sqrt(f);\n            function[1] = coeff * p[0];\n            for (int n = 2; n <= order; ++n) {\n\n                // update and evaluate polynomial P_n(x)\n                double v = 0;\n                p[n - 1] = (1 - n) * p[n - 2];\n                for (int k = n - 1; k >= 0; k -= 2) {\n                    v = v * x2 + p[k];\n                    if (k > 2) {\n                        p[k - 2] = (1 - k) * p[k - 1] + (k - 2 * n) * p[k - 3];\n                    } else if (k == 2) {\n                        p[0] = -p[1];\n                    }\n                }\nif(n){\n                    v *= x;\n                }\n\n                coeff *= f;\n                function[n] = coeff * v;\n\n            }\n        }\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }",
          "23": "    public void acosh(final double[] operand, final int operandOffset,\n                     final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        double[] function = new double[1 + order];\n        final double x = operand[operandOffset];\n        function[0] = FastMath.acosh(x);\n        if (order > 0) {\n            // the nth order derivative of acosh has the form:\n            // dn(acosh(x)/dxn = P_n(x) / [x^2 - 1]^((2n-1)/2)\n            // where P_n(x) is a degree n-1 polynomial with same parity as n-1\n            // P_1(x) = 1, P_2(x) = -x, P_3(x) = 2x^2 + 1 ...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = (x^2-1) P_(n-1)'(x) - (2n-3) x P_(n-1)(x)\n            // as per polynomial parity, we can store coefficients of both P_(n-1) and P_n in the same array\n            final double[] p = new double[order];\n            p[0] = 1;\n            final double x2  = x * x;\n            final double f   = 1.0 / (x2 - 1);\n            double coeff = FastMath.sqrt(f);\n            function[1] = coeff * p[0];\n            for (int n = 2; n <= order; ++n) {\n\n                // update and evaluate polynomial P_n(x)\n                double v = 0;\n                p[n - 1] = (1 - n) * p[n - 2];\n                for (int k = n - 1; k >= 0; k -= 2) {\n                    v = v * x2 + p[k];\n                    if (k > 2) {\n                        p[k - 2] = (1 - k) * p[k - 1] + (k - 2 * n) * p[k - 3];\n                    } else if (k == 2) {\n                        p[0] = -p[1];\n                    }\n                }\nif((k - (2 * n))){\n                    v *= x;\n                }\n\n                coeff *= f;\n                function[n] = coeff * v;\n\n            }\n        }\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }",
          "24": "    public void acosh(final double[] operand, final int operandOffset,\n                     final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        double[] function = new double[1 + order];\n        final double x = operand[operandOffset];\n        function[0] = FastMath.acosh(x);\n        if (order > 0) {\n            // the nth order derivative of acosh has the form:\n            // dn(acosh(x)/dxn = P_n(x) / [x^2 - 1]^((2n-1)/2)\n            // where P_n(x) is a degree n-1 polynomial with same parity as n-1\n            // P_1(x) = 1, P_2(x) = -x, P_3(x) = 2x^2 + 1 ...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = (x^2-1) P_(n-1)'(x) - (2n-3) x P_(n-1)(x)\n            // as per polynomial parity, we can store coefficients of both P_(n-1) and P_n in the same array\n            final double[] p = new double[order];\n            p[0] = 1;\n            final double x2  = x * x;\n            final double f   = 1.0 / (x2 - 1);\n            double coeff = FastMath.sqrt(f);\n            function[1] = coeff * p[0];\n            for (int n = 2; n <= order; ++n) {\n\n                // update and evaluate polynomial P_n(x)\n                double v = 0;\n                p[n - 1] = (1 - n) * p[n - 2];\n                for (int k = n - 1; k >= 0; k -= 2) {\n                    v = v * x2 + p[k];\n                    if (k > 2) {\n                        p[k - 2] = (1 - k) * p[k - 1] + (k - 2 * n) * p[k - 3];\n                    } else if (k == 2) {\n                        p[0] = -p[1];\n                    }\n                }\n                    v *= x;\n                }\n\n                coeff *= f;\n                function[n] = coeff * v;\n\n            }\n        }\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }",
          "25": "    public void acosh(final double[] operand, final int operandOffset,\n                     final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        double[] function = new double[1 + order];\n        final double x = operand[operandOffset];\n        function[0] = FastMath.acosh(x);\n        if (order > 0) {\n            // the nth order derivative of acosh has the form:\n            // dn(acosh(x)/dxn = P_n(x) / [x^2 - 1]^((2n-1)/2)\n            // where P_n(x) is a degree n-1 polynomial with same parity as n-1\n            // P_1(x) = 1, P_2(x) = -x, P_3(x) = 2x^2 + 1 ...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = (x^2-1) P_(n-1)'(x) - (2n-3) x P_(n-1)(x)\n            // as per polynomial parity, we can store coefficients of both P_(n-1) and P_n in the same array\n            final double[] p = new double[order];\n            p[0] = 1;\n            final double x2  = x * x;\n            final double f   = 1.0 / (x2 - 1);\n            double coeff = FastMath.sqrt(f);\n            function[1] = coeff * p[0];\n            for (int n = 2; n <= order; ++n) {\n\n                // update and evaluate polynomial P_n(x)\n                double v = 0;\n                p[n - 1] = (1 - n) * p[n - 2];\n                for (int k = n - 1; k >= 0; k -= 2) {\n                    v = v * x2 + p[k];\n                    if (k > 2) {\n                        p[k - 2] = (1 - k) * p[k - 1] + (k - 2 * n) * p[k - 3];\n                    } else if (k == 2) {\n                        p[0] = -p[1];\n                    }\n                }\nif(((n ^<> 2) == 0)){                    v *= x;\n                }\n\n                coeff *= f;\n                function[n] = coeff * v;\n\n            }\n        }\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }",
          "26": "    public void acosh(final double[] operand, final int operandOffset,\n                     final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        double[] function = new double[1 + order];\n        final double x = operand[operandOffset];\n        function[0] = FastMath.acosh(x);\n        if (order > 0) {\n            // the nth order derivative of acosh has the form:\n            // dn(acosh(x)/dxn = P_n(x) / [x^2 - 1]^((2n-1)/2)\n            // where P_n(x) is a degree n-1 polynomial with same parity as n-1\n            // P_1(x) = 1, P_2(x) = -x, P_3(x) = 2x^2 + 1 ...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = (x^2-1) P_(n-1)'(x) - (2n-3) x P_(n-1)(x)\n            // as per polynomial parity, we can store coefficients of both P_(n-1) and P_n in the same array\n            final double[] p = new double[order];\n            p[0] = 1;\n            final double x2  = x * x;\n            final double f   = 1.0 / (x2 - 1);\n            double coeff = FastMath.sqrt(f);\n            function[1] = coeff * p[0];\n            for (int n = 2; n <= order; ++n) {\n\n                // update and evaluate polynomial P_n(x)\n                double v = 0;\n                p[n - 1] = (1 - n) * p[n - 2];\n                for (int k = n - 1; k >= 0; k -= 2) {\n                    v = v * x2 + p[k];\n                    if (k > 2) {\n                        p[k - 2] = (1 - k) * p[k - 1] + (k - 2 * n) * p[k - 3];\n                    } else if (k == 2) {\n                        p[0] = -p[1];\n                    }\n                }\ncontinue;\n                if ((n ^ 1) == 0) {                    v *= x;\n                }\n\n                coeff *= f;\n                function[n] = coeff * v;\n\n            }\n        }\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }",
          "27": "    public void acosh(final double[] operand, final int operandOffset,\n                     final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        double[] function = new double[1 + order];\n        final double x = operand[operandOffset];\n        function[0] = FastMath.acosh(x);\n        if (order > 0) {\n            // the nth order derivative of acosh has the form:\n            // dn(acosh(x)/dxn = P_n(x) / [x^2 - 1]^((2n-1)/2)\n            // where P_n(x) is a degree n-1 polynomial with same parity as n-1\n            // P_1(x) = 1, P_2(x) = -x, P_3(x) = 2x^2 + 1 ...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = (x^2-1) P_(n-1)'(x) - (2n-3) x P_(n-1)(x)\n            // as per polynomial parity, we can store coefficients of both P_(n-1) and P_n in the same array\n            final double[] p = new double[order];\n            p[0] = 1;\n            final double x2  = x * x;\n            final double f   = 1.0 / (x2 - 1);\n            double coeff = FastMath.sqrt(f);\n            function[1] = coeff * p[0];\n            for (int n = 2; n <= order; ++n) {\n\n                // update and evaluate polynomial P_n(x)\n                double v = 0;\n                p[n - 1] = (1 - n) * p[n - 2];\n                for (int k = n - 1; k >= 0; k -= 2) {\n                    v = v * x2 + p[k];\n                    if (k > 2) {\n                        p[k - 2] = (1 - k) * p[k - 1] + (k - 2 * n) * p[k - 3];\n                    } else if (k == 2) {\n                        p[0] = -p[1];\n                    }\n                }\nif(((n ^<> -1) == 0)){                    v *= x;\n                }\n\n                coeff *= f;\n                function[n] = coeff * v;\n\n            }\n        }\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }",
          "28": "    public void acosh(final double[] operand, final int operandOffset,\n                     final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        double[] function = new double[1 + order];\n        final double x = operand[operandOffset];\n        function[0] = FastMath.acosh(x);\n        if (order > 0) {\n            // the nth order derivative of acosh has the form:\n            // dn(acosh(x)/dxn = P_n(x) / [x^2 - 1]^((2n-1)/2)\n            // where P_n(x) is a degree n-1 polynomial with same parity as n-1\n            // P_1(x) = 1, P_2(x) = -x, P_3(x) = 2x^2 + 1 ...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = (x^2-1) P_(n-1)'(x) - (2n-3) x P_(n-1)(x)\n            // as per polynomial parity, we can store coefficients of both P_(n-1) and P_n in the same array\n            final double[] p = new double[order];\n            p[0] = 1;\n            final double x2  = x * x;\n            final double f   = 1.0 / (x2 - 1);\n            double coeff = FastMath.sqrt(f);\n            function[1] = coeff * p[0];\n            for (int n = 2; n <= order; ++n) {\n\n                // update and evaluate polynomial P_n(x)\n                double v = 0;\n                p[n - 1] = (1 - n) * p[n - 2];\n                for (int k = n - 1; k >= 0; k -= 2) {\n                    v = v * x2 + p[k];\n                    if (k > 2) {\n                        p[k - 2] = (1 - k) * p[k - 1] + (k - 2 * n) * p[k - 3];\n                    } else if (k == 2) {\n                        p[0] = -p[1];\n                    }\n                }\nif(((n >= 1) == 0)){                    v *= x;\n                }\n\n                coeff *= f;\n                function[n] = coeff * v;\n\n            }\n        }\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }",
          "29": "    public void acosh(final double[] operand, final int operandOffset,\n                     final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        double[] function = new double[1 + order];\n        final double x = operand[operandOffset];\n        function[0] = FastMath.acosh(x);\n        if (order > 0) {\n            // the nth order derivative of acosh has the form:\n            // dn(acosh(x)/dxn = P_n(x) / [x^2 - 1]^((2n-1)/2)\n            // where P_n(x) is a degree n-1 polynomial with same parity as n-1\n            // P_1(x) = 1, P_2(x) = -x, P_3(x) = 2x^2 + 1 ...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = (x^2-1) P_(n-1)'(x) - (2n-3) x P_(n-1)(x)\n            // as per polynomial parity, we can store coefficients of both P_(n-1) and P_n in the same array\n            final double[] p = new double[order];\n            p[0] = 1;\n            final double x2  = x * x;\n            final double f   = 1.0 / (x2 - 1);\n            double coeff = FastMath.sqrt(f);\n            function[1] = coeff * p[0];\n            for (int n = 2; n <= order; ++n) {\n\n                // update and evaluate polynomial P_n(x)\n                double v = 0;\n                p[n - 1] = (1 - n) * p[n - 2];\n                for (int k = n - 1; k >= 0; k -= 2) {\n                    v = v * x2 + p[k];\n                    if (k > 2) {\n                        p[k - 2] = (1 - k) * p[k - 1] + (k - 2 * n) * p[k - 3];\n                    } else if (k == 2) {\n                        p[0] = -p[1];\n                    }\n                }\nif(((k ^<> 1) == 0)){                    v *= x;\n                }\n\n                coeff *= f;\n                function[n] = coeff * v;\n\n            }\n        }\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }",
          "30": "    public void acosh(final double[] operand, final int operandOffset,\n                     final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        double[] function = new double[1 + order];\n        final double x = operand[operandOffset];\n        function[0] = FastMath.acosh(x);\n        if (order > 0) {\n            // the nth order derivative of acosh has the form:\n            // dn(acosh(x)/dxn = P_n(x) / [x^2 - 1]^((2n-1)/2)\n            // where P_n(x) is a degree n-1 polynomial with same parity as n-1\n            // P_1(x) = 1, P_2(x) = -x, P_3(x) = 2x^2 + 1 ...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = (x^2-1) P_(n-1)'(x) - (2n-3) x P_(n-1)(x)\n            // as per polynomial parity, we can store coefficients of both P_(n-1) and P_n in the same array\n            final double[] p = new double[order];\n            p[0] = 1;\n            final double x2  = x * x;\n            final double f   = 1.0 / (x2 - 1);\n            double coeff = FastMath.sqrt(f);\n            function[1] = coeff * p[0];\n            for (int n = 2; n <= order; ++n) {\n\n                // update and evaluate polynomial P_n(x)\n                double v = 0;\n                p[n - 1] = (1 - n) * p[n - 2];\n                for (int k = n - 1; k >= 0; k -= 2) {\n                    v = v * x2 + p[k];\n                    if (k > 2) {\n                        p[k - 2] = (1 - k) * p[k - 1] + (k - 2 * n) * p[k - 3];\n                    } else if (k == 2) {\n                        p[0] = -p[1];\n                    }\n                }\nfor(int k = (n - 1);(k >= 0);k -= 2) {                if ((n ^ 1) == 0) {                    v *= x;\n                }\n\n                coeff *= f;\n                function[n] = coeff * v;\n\n            }\n        }\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }",
          "31": "    public void acosh(final double[] operand, final int operandOffset,\n                     final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        double[] function = new double[1 + order];\n        final double x = operand[operandOffset];\n        function[0] = FastMath.acosh(x);\n        if (order > 0) {\n            // the nth order derivative of acosh has the form:\n            // dn(acosh(x)/dxn = P_n(x) / [x^2 - 1]^((2n-1)/2)\n            // where P_n(x) is a degree n-1 polynomial with same parity as n-1\n            // P_1(x) = 1, P_2(x) = -x, P_3(x) = 2x^2 + 1 ...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = (x^2-1) P_(n-1)'(x) - (2n-3) x P_(n-1)(x)\n            // as per polynomial parity, we can store coefficients of both P_(n-1) and P_n in the same array\n            final double[] p = new double[order];\n            p[0] = 1;\n            final double x2  = x * x;\n            final double f   = 1.0 / (x2 - 1);\n            double coeff = FastMath.sqrt(f);\n            function[1] = coeff * p[0];\n            for (int n = 2; n <= order; ++n) {\n\n                // update and evaluate polynomial P_n(x)\n                double v = 0;\n                p[n - 1] = (1 - n) * p[n - 2];\n                for (int k = n - 1; k >= 0; k -= 2) {\n                    v = v * x2 + p[k];\n                    if (k > 2) {\n                        p[k - 2] = (1 - k) * p[k - 1] + (k - 2 * n) * p[k - 3];\n                    } else if (k == 2) {\n                        p[0] = -p[1];\n                    }\n                }\nif(((n ^<> 1) < 0)){                    v *= x;\n                }\n\n                coeff *= f;\n                function[n] = coeff * v;\n\n            }\n        }\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }",
          "32": "    public void acosh(final double[] operand, final int operandOffset,\n                     final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        double[] function = new double[1 + order];\n        final double x = operand[operandOffset];\n        function[0] = FastMath.acosh(x);\n        if (order > 0) {\n            // the nth order derivative of acosh has the form:\n            // dn(acosh(x)/dxn = P_n(x) / [x^2 - 1]^((2n-1)/2)\n            // where P_n(x) is a degree n-1 polynomial with same parity as n-1\n            // P_1(x) = 1, P_2(x) = -x, P_3(x) = 2x^2 + 1 ...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = (x^2-1) P_(n-1)'(x) - (2n-3) x P_(n-1)(x)\n            // as per polynomial parity, we can store coefficients of both P_(n-1) and P_n in the same array\n            final double[] p = new double[order];\n            p[0] = 1;\n            final double x2  = x * x;\n            final double f   = 1.0 / (x2 - 1);\n            double coeff = FastMath.sqrt(f);\n            function[1] = coeff * p[0];\n            for (int n = 2; n <= order; ++n) {\n\n                // update and evaluate polynomial P_n(x)\n                double v = 0;\n                p[n - 1] = (1 - n) * p[n - 2];\n                for (int k = n - 1; k >= 0; k -= 2) {\n                    v = v * x2 + p[k];\n                    if (k > 2) {\n                        p[k - 2] = (1 - k) * p[k - 1] + (k - 2 * n) * p[k - 3];\n                    } else if (k == 2) {\n                        p[0] = -p[1];\n                    }\n                }\nif(((n ^<> 1) == 3)){                    v *= x;\n                }\n\n                coeff *= f;\n                function[n] = coeff * v;\n\n            }\n        }\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }",
          "33": "    public void acosh(final double[] operand, final int operandOffset,\n                     final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        double[] function = new double[1 + order];\n        final double x = operand[operandOffset];\n        function[0] = FastMath.acosh(x);\n        if (order > 0) {\n            // the nth order derivative of acosh has the form:\n            // dn(acosh(x)/dxn = P_n(x) / [x^2 - 1]^((2n-1)/2)\n            // where P_n(x) is a degree n-1 polynomial with same parity as n-1\n            // P_1(x) = 1, P_2(x) = -x, P_3(x) = 2x^2 + 1 ...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = (x^2-1) P_(n-1)'(x) - (2n-3) x P_(n-1)(x)\n            // as per polynomial parity, we can store coefficients of both P_(n-1) and P_n in the same array\n            final double[] p = new double[order];\n            p[0] = 1;\n            final double x2  = x * x;\n            final double f   = 1.0 / (x2 - 1);\n            double coeff = FastMath.sqrt(f);\n            function[1] = coeff * p[0];\n            for (int n = 2; n <= order; ++n) {\n\n                // update and evaluate polynomial P_n(x)\n                double v = 0;\n                p[n - 1] = (1 - n) * p[n - 2];\n                for (int k = n - 1; k >= 0; k -= 2) {\n                    v = v * x2 + p[k];\n                    if (k > 2) {\n                        p[k - 2] = (1 - k) * p[k - 1] + (k - 2 * n) * p[k - 3];\n                    } else if (k == 2) {\n                        p[0] = -p[1];\n                    }\n                }\nif((v * x2)){\n                    v *= x;\n                }\n\n                coeff *= f;\n                function[n] = coeff * v;\n\n            }\n        }\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }",
          "34": "    public void acosh(final double[] operand, final int operandOffset,\n                     final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        double[] function = new double[1 + order];\n        final double x = operand[operandOffset];\n        function[0] = FastMath.acosh(x);\n        if (order > 0) {\n            // the nth order derivative of acosh has the form:\n            // dn(acosh(x)/dxn = P_n(x) / [x^2 - 1]^((2n-1)/2)\n            // where P_n(x) is a degree n-1 polynomial with same parity as n-1\n            // P_1(x) = 1, P_2(x) = -x, P_3(x) = 2x^2 + 1 ...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = (x^2-1) P_(n-1)'(x) - (2n-3) x P_(n-1)(x)\n            // as per polynomial parity, we can store coefficients of both P_(n-1) and P_n in the same array\n            final double[] p = new double[order];\n            p[0] = 1;\n            final double x2  = x * x;\n            final double f   = 1.0 / (x2 - 1);\n            double coeff = FastMath.sqrt(f);\n            function[1] = coeff * p[0];\n            for (int n = 2; n <= order; ++n) {\n\n                // update and evaluate polynomial P_n(x)\n                double v = 0;\n                p[n - 1] = (1 - n) * p[n - 2];\n                for (int k = n - 1; k >= 0; k -= 2) {\n                    v = v * x2 + p[k];\n                    if (k > 2) {\n                        p[k - 2] = (1 - k) * p[k - 1] + (k - 2 * n) * p[k - 3];\n                    } else if (k == 2) {\n                        p[0] = -p[1];\n                    }\n                }\nif(((n ^<> 1) == 1)){                    v *= x;\n                }\n\n                coeff *= f;\n                function[n] = coeff * v;\n\n            }\n        }\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }",
          "35": "    public void acosh(final double[] operand, final int operandOffset,\n                     final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        double[] function = new double[1 + order];\n        final double x = operand[operandOffset];\n        function[0] = FastMath.acosh(x);\n        if (order > 0) {\n            // the nth order derivative of acosh has the form:\n            // dn(acosh(x)/dxn = P_n(x) / [x^2 - 1]^((2n-1)/2)\n            // where P_n(x) is a degree n-1 polynomial with same parity as n-1\n            // P_1(x) = 1, P_2(x) = -x, P_3(x) = 2x^2 + 1 ...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = (x^2-1) P_(n-1)'(x) - (2n-3) x P_(n-1)(x)\n            // as per polynomial parity, we can store coefficients of both P_(n-1) and P_n in the same array\n            final double[] p = new double[order];\n            p[0] = 1;\n            final double x2  = x * x;\n            final double f   = 1.0 / (x2 - 1);\n            double coeff = FastMath.sqrt(f);\n            function[1] = coeff * p[0];\n            for (int n = 2; n <= order; ++n) {\n\n                // update and evaluate polynomial P_n(x)\n                double v = 0;\n                p[n - 1] = (1 - n) * p[n - 2];\n                for (int k = n - 1; k >= 0; k -= 2) {\n                    v = v * x2 + p[k];\n                    if (k > 2) {\n                        p[k - 2] = (1 - k) * p[k - 1] + (k - 2 * n) * p[k - 3];\n                    } else if (k == 2) {\n                        p[0] = -p[1];\n                    }\n                }\nif(((n <= 1) == 0)){                    v *= x;\n                }\n\n                coeff *= f;\n                function[n] = coeff * v;\n\n            }\n        }\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }",
          "36": "    public void acosh(final double[] operand, final int operandOffset,\n                     final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        double[] function = new double[1 + order];\n        final double x = operand[operandOffset];\n        function[0] = FastMath.acosh(x);\n        if (order > 0) {\n            // the nth order derivative of acosh has the form:\n            // dn(acosh(x)/dxn = P_n(x) / [x^2 - 1]^((2n-1)/2)\n            // where P_n(x) is a degree n-1 polynomial with same parity as n-1\n            // P_1(x) = 1, P_2(x) = -x, P_3(x) = 2x^2 + 1 ...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = (x^2-1) P_(n-1)'(x) - (2n-3) x P_(n-1)(x)\n            // as per polynomial parity, we can store coefficients of both P_(n-1) and P_n in the same array\n            final double[] p = new double[order];\n            p[0] = 1;\n            final double x2  = x * x;\n            final double f   = 1.0 / (x2 - 1);\n            double coeff = FastMath.sqrt(f);\n            function[1] = coeff * p[0];\n            for (int n = 2; n <= order; ++n) {\n\n                // update and evaluate polynomial P_n(x)\n                double v = 0;\n                p[n - 1] = (1 - n) * p[n - 2];\n                for (int k = n - 1; k >= 0; k -= 2) {\n                    v = v * x2 + p[k];\n                    if (k > 2) {\n                        p[k - 2] = (1 - k) * p[k - 1] + (k - 2 * n) * p[k - 3];\n                    } else if (k == 2) {\n                        p[0] = -p[1];\n                    }\n                }\nif(((n == 1) == 0)){                    v *= x;\n                }\n\n                coeff *= f;\n                function[n] = coeff * v;\n\n            }\n        }\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }",
          "37": "    public void acosh(final double[] operand, final int operandOffset,\n                     final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        double[] function = new double[1 + order];\n        final double x = operand[operandOffset];\n        function[0] = FastMath.acosh(x);\n        if (order > 0) {\n            // the nth order derivative of acosh has the form:\n            // dn(acosh(x)/dxn = P_n(x) / [x^2 - 1]^((2n-1)/2)\n            // where P_n(x) is a degree n-1 polynomial with same parity as n-1\n            // P_1(x) = 1, P_2(x) = -x, P_3(x) = 2x^2 + 1 ...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = (x^2-1) P_(n-1)'(x) - (2n-3) x P_(n-1)(x)\n            // as per polynomial parity, we can store coefficients of both P_(n-1) and P_n in the same array\n            final double[] p = new double[order];\n            p[0] = 1;\n            final double x2  = x * x;\n            final double f   = 1.0 / (x2 - 1);\n            double coeff = FastMath.sqrt(f);\n            function[1] = coeff * p[0];\n            for (int n = 2; n <= order; ++n) {\n\n                // update and evaluate polynomial P_n(x)\n                double v = 0;\n                p[n - 1] = (1 - n) * p[n - 2];\n                for (int k = n - 1; k >= 0; k -= 2) {\n                    v = v * x2 + p[k];\n                    if (k > 2) {\n                        p[k - 2] = (1 - k) * p[k - 1] + (k - 2 * n) * p[k - 3];\n                    } else if (k == 2) {\n                        p[0] = -p[1];\n                    }\n                }\nif(((n ^<> 1) == 2)){                    v *= x;\n                }\n\n                coeff *= f;\n                function[n] = coeff * v;\n\n            }\n        }\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }",
          "38": "    public void acosh(final double[] operand, final int operandOffset,\n                     final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        double[] function = new double[1 + order];\n        final double x = operand[operandOffset];\n        function[0] = FastMath.acosh(x);\n        if (order > 0) {\n            // the nth order derivative of acosh has the form:\n            // dn(acosh(x)/dxn = P_n(x) / [x^2 - 1]^((2n-1)/2)\n            // where P_n(x) is a degree n-1 polynomial with same parity as n-1\n            // P_1(x) = 1, P_2(x) = -x, P_3(x) = 2x^2 + 1 ...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = (x^2-1) P_(n-1)'(x) - (2n-3) x P_(n-1)(x)\n            // as per polynomial parity, we can store coefficients of both P_(n-1) and P_n in the same array\n            final double[] p = new double[order];\n            p[0] = 1;\n            final double x2  = x * x;\n            final double f   = 1.0 / (x2 - 1);\n            double coeff = FastMath.sqrt(f);\n            function[1] = coeff * p[0];\n            for (int n = 2; n <= order; ++n) {\n\n                // update and evaluate polynomial P_n(x)\n                double v = 0;\n                p[n - 1] = (1 - n) * p[n - 2];\n                for (int k = n - 1; k >= 0; k -= 2) {\n                    v = v * x2 + p[k];\n                    if (k > 2) {\n                        p[k - 2] = (1 - k) * p[k - 1] + (k - 2 * n) * p[k - 3];\n                    } else if (k == 2) {\n                        p[0] = -p[1];\n                    }\n                }\nif((k > 2)){\n                if ((n ^ 1) == 0) {                    v *= x;\n                }\n\n                coeff *= f;\n                function[n] = coeff * v;\n\n}\n            }\n        }\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }",
          "39": "    public void acosh(final double[] operand, final int operandOffset,\n                     final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        double[] function = new double[1 + order];\n        final double x = operand[operandOffset];\n        function[0] = FastMath.acosh(x);\n        if (order > 0) {\n            // the nth order derivative of acosh has the form:\n            // dn(acosh(x)/dxn = P_n(x) / [x^2 - 1]^((2n-1)/2)\n            // where P_n(x) is a degree n-1 polynomial with same parity as n-1\n            // P_1(x) = 1, P_2(x) = -x, P_3(x) = 2x^2 + 1 ...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = (x^2-1) P_(n-1)'(x) - (2n-3) x P_(n-1)(x)\n            // as per polynomial parity, we can store coefficients of both P_(n-1) and P_n in the same array\n            final double[] p = new double[order];\n            p[0] = 1;\n            final double x2  = x * x;\n            final double f   = 1.0 / (x2 - 1);\n            double coeff = FastMath.sqrt(f);\n            function[1] = coeff * p[0];\n            for (int n = 2; n <= order; ++n) {\n\n                // update and evaluate polynomial P_n(x)\n                double v = 0;\n                p[n - 1] = (1 - n) * p[n - 2];\n                for (int k = n - 1; k >= 0; k -= 2) {\n                    v = v * x2 + p[k];\n                    if (k > 2) {\n                        p[k - 2] = (1 - k) * p[k - 1] + (k - 2 * n) * p[k - 3];\n                    } else if (k == 2) {\n                        p[0] = -p[1];\n                    }\n                }\nif((n != n)){\n                    v *= x;\n                }\n\n                coeff *= f;\n                function[n] = coeff * v;\n\n            }\n        }\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }",
          "40": "    public void acosh(final double[] operand, final int operandOffset,\n                     final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        double[] function = new double[1 + order];\n        final double x = operand[operandOffset];\n        function[0] = FastMath.acosh(x);\n        if (order > 0) {\n            // the nth order derivative of acosh has the form:\n            // dn(acosh(x)/dxn = P_n(x) / [x^2 - 1]^((2n-1)/2)\n            // where P_n(x) is a degree n-1 polynomial with same parity as n-1\n            // P_1(x) = 1, P_2(x) = -x, P_3(x) = 2x^2 + 1 ...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = (x^2-1) P_(n-1)'(x) - (2n-3) x P_(n-1)(x)\n            // as per polynomial parity, we can store coefficients of both P_(n-1) and P_n in the same array\n            final double[] p = new double[order];\n            p[0] = 1;\n            final double x2  = x * x;\n            final double f   = 1.0 / (x2 - 1);\n            double coeff = FastMath.sqrt(f);\n            function[1] = coeff * p[0];\n            for (int n = 2; n <= order; ++n) {\n\n                // update and evaluate polynomial P_n(x)\n                double v = 0;\n                p[n - 1] = (1 - n) * p[n - 2];\n                for (int k = n - 1; k >= 0; k -= 2) {\n                    v = v * x2 + p[k];\n                    if (k > 2) {\n                        p[k - 2] = (1 - k) * p[k - 1] + (k - 2 * n) * p[k - 3];\n                    } else if (k == 2) {\n                        p[0] = -p[1];\n                    }\n                }\nif(((n ^<> 1) == -1)){                    v *= x;\n                }\n\n                coeff *= f;\n                function[n] = coeff * v;\n\n            }\n        }\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }",
          "41": "    public void acosh(final double[] operand, final int operandOffset,\n                     final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        double[] function = new double[1 + order];\n        final double x = operand[operandOffset];\n        function[0] = FastMath.acosh(x);\n        if (order > 0) {\n            // the nth order derivative of acosh has the form:\n            // dn(acosh(x)/dxn = P_n(x) / [x^2 - 1]^((2n-1)/2)\n            // where P_n(x) is a degree n-1 polynomial with same parity as n-1\n            // P_1(x) = 1, P_2(x) = -x, P_3(x) = 2x^2 + 1 ...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = (x^2-1) P_(n-1)'(x) - (2n-3) x P_(n-1)(x)\n            // as per polynomial parity, we can store coefficients of both P_(n-1) and P_n in the same array\n            final double[] p = new double[order];\n            p[0] = 1;\n            final double x2  = x * x;\n            final double f   = 1.0 / (x2 - 1);\n            double coeff = FastMath.sqrt(f);\n            function[1] = coeff * p[0];\n            for (int n = 2; n <= order; ++n) {\n\n                // update and evaluate polynomial P_n(x)\n                double v = 0;\n                p[n - 1] = (1 - n) * p[n - 2];\n                for (int k = n - 1; k >= 0; k -= 2) {\n                    v = v * x2 + p[k];\n                    if (k > 2) {\n                        p[k - 2] = (1 - k) * p[k - 1] + (k - 2 * n) * p[k - 3];\n                    } else if (k == 2) {\n                        p[0] = -p[1];\n                    }\n                }\nif((n == n)){\n                    v *= x;\n                }\n\n                coeff *= f;\n                function[n] = coeff * v;\n\n            }\n        }\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }",
          "42": "    public void acosh(final double[] operand, final int operandOffset,\n                     final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        double[] function = new double[1 + order];\n        final double x = operand[operandOffset];\n        function[0] = FastMath.acosh(x);\n        if (order > 0) {\n            // the nth order derivative of acosh has the form:\n            // dn(acosh(x)/dxn = P_n(x) / [x^2 - 1]^((2n-1)/2)\n            // where P_n(x) is a degree n-1 polynomial with same parity as n-1\n            // P_1(x) = 1, P_2(x) = -x, P_3(x) = 2x^2 + 1 ...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = (x^2-1) P_(n-1)'(x) - (2n-3) x P_(n-1)(x)\n            // as per polynomial parity, we can store coefficients of both P_(n-1) and P_n in the same array\n            final double[] p = new double[order];\n            p[0] = 1;\n            final double x2  = x * x;\n            final double f   = 1.0 / (x2 - 1);\n            double coeff = FastMath.sqrt(f);\n            function[1] = coeff * p[0];\n            for (int n = 2; n <= order; ++n) {\n\n                // update and evaluate polynomial P_n(x)\n                double v = 0;\n                p[n - 1] = (1 - n) * p[n - 2];\n                for (int k = n - 1; k >= 0; k -= 2) {\n                    v = v * x2 + p[k];\n                    if (k > 2) {\n                        p[k - 2] = (1 - k) * p[k - 1] + (k - 2 * n) * p[k - 3];\n                    } else if (k == 2) {\n                        p[0] = -p[1];\n                    }\n                }\nif(((n != 1) == 0)){                    v *= x;\n                }\n\n                coeff *= f;\n                function[n] = coeff * v;\n\n            }\n        }\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }",
          "43": "    public void acosh(final double[] operand, final int operandOffset,\n                     final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        double[] function = new double[1 + order];\n        final double x = operand[operandOffset];\n        function[0] = FastMath.acosh(x);\n        if (order > 0) {\n            // the nth order derivative of acosh has the form:\n            // dn(acosh(x)/dxn = P_n(x) / [x^2 - 1]^((2n-1)/2)\n            // where P_n(x) is a degree n-1 polynomial with same parity as n-1\n            // P_1(x) = 1, P_2(x) = -x, P_3(x) = 2x^2 + 1 ...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = (x^2-1) P_(n-1)'(x) - (2n-3) x P_(n-1)(x)\n            // as per polynomial parity, we can store coefficients of both P_(n-1) and P_n in the same array\n            final double[] p = new double[order];\n            p[0] = 1;\n            final double x2  = x * x;\n            final double f   = 1.0 / (x2 - 1);\n            double coeff = FastMath.sqrt(f);\n            function[1] = coeff * p[0];\n            for (int n = 2; n <= order; ++n) {\n\n                // update and evaluate polynomial P_n(x)\n                double v = 0;\n                p[n - 1] = (1 - n) * p[n - 2];\n                for (int k = n - 1; k >= 0; k -= 2) {\n                    v = v * x2 + p[k];\n                    if (k > 2) {\n                        p[k - 2] = (1 - k) * p[k - 1] + (k - 2 * n) * p[k - 3];\n                    } else if (k == 2) {\n                        p[0] = -p[1];\n                    }\n                }\nif((2 * n)){\n                    v *= x;\n                }\n\n                coeff *= f;\n                function[n] = coeff * v;\n\n            }\n        }\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }",
          "44": "    public void acosh(final double[] operand, final int operandOffset,\n                     final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        double[] function = new double[1 + order];\n        final double x = operand[operandOffset];\n        function[0] = FastMath.acosh(x);\n        if (order > 0) {\n            // the nth order derivative of acosh has the form:\n            // dn(acosh(x)/dxn = P_n(x) / [x^2 - 1]^((2n-1)/2)\n            // where P_n(x) is a degree n-1 polynomial with same parity as n-1\n            // P_1(x) = 1, P_2(x) = -x, P_3(x) = 2x^2 + 1 ...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = (x^2-1) P_(n-1)'(x) - (2n-3) x P_(n-1)(x)\n            // as per polynomial parity, we can store coefficients of both P_(n-1) and P_n in the same array\n            final double[] p = new double[order];\n            p[0] = 1;\n            final double x2  = x * x;\n            final double f   = 1.0 / (x2 - 1);\n            double coeff = FastMath.sqrt(f);\n            function[1] = coeff * p[0];\n            for (int n = 2; n <= order; ++n) {\n\n                // update and evaluate polynomial P_n(x)\n                double v = 0;\n                p[n - 1] = (1 - n) * p[n - 2];\n                for (int k = n - 1; k >= 0; k -= 2) {\n                    v = v * x2 + p[k];\n                    if (k > 2) {\n                        p[k - 2] = (1 - k) * p[k - 1] + (k - 2 * n) * p[k - 3];\n                    } else if (k == 2) {\n                        p[0] = -p[1];\n                    }\n                }\nif((k - 3)){\n                    v *= x;\n                }\n\n                coeff *= f;\n                function[n] = coeff * v;\n\n            }\n        }\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }",
          "45": "    public void acosh(final double[] operand, final int operandOffset,\n                     final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        double[] function = new double[1 + order];\n        final double x = operand[operandOffset];\n        function[0] = FastMath.acosh(x);\n        if (order > 0) {\n            // the nth order derivative of acosh has the form:\n            // dn(acosh(x)/dxn = P_n(x) / [x^2 - 1]^((2n-1)/2)\n            // where P_n(x) is a degree n-1 polynomial with same parity as n-1\n            // P_1(x) = 1, P_2(x) = -x, P_3(x) = 2x^2 + 1 ...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = (x^2-1) P_(n-1)'(x) - (2n-3) x P_(n-1)(x)\n            // as per polynomial parity, we can store coefficients of both P_(n-1) and P_n in the same array\n            final double[] p = new double[order];\n            p[0] = 1;\n            final double x2  = x * x;\n            final double f   = 1.0 / (x2 - 1);\n            double coeff = FastMath.sqrt(f);\n            function[1] = coeff * p[0];\n            for (int n = 2; n <= order; ++n) {\n\n                // update and evaluate polynomial P_n(x)\n                double v = 0;\n                p[n - 1] = (1 - n) * p[n - 2];\n                for (int k = n - 1; k >= 0; k -= 2) {\n                    v = v * x2 + p[k];\n                    if (k > 2) {\n                        p[k - 2] = (1 - k) * p[k - 1] + (k - 2 * n) * p[k - 3];\n                    } else if (k == 2) {\n                        p[0] = -p[1];\n                    }\n                }\nif((n != 0)){\n                    v *= x;\n                }\n\n                coeff *= f;\n                function[n] = coeff * v;\n\n            }\n        }\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }",
          "46": "    public void acosh(final double[] operand, final int operandOffset,\n                     final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        double[] function = new double[1 + order];\n        final double x = operand[operandOffset];\n        function[0] = FastMath.acosh(x);\n        if (order > 0) {\n            // the nth order derivative of acosh has the form:\n            // dn(acosh(x)/dxn = P_n(x) / [x^2 - 1]^((2n-1)/2)\n            // where P_n(x) is a degree n-1 polynomial with same parity as n-1\n            // P_1(x) = 1, P_2(x) = -x, P_3(x) = 2x^2 + 1 ...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = (x^2-1) P_(n-1)'(x) - (2n-3) x P_(n-1)(x)\n            // as per polynomial parity, we can store coefficients of both P_(n-1) and P_n in the same array\n            final double[] p = new double[order];\n            p[0] = 1;\n            final double x2  = x * x;\n            final double f   = 1.0 / (x2 - 1);\n            double coeff = FastMath.sqrt(f);\n            function[1] = coeff * p[0];\n            for (int n = 2; n <= order; ++n) {\n\n                // update and evaluate polynomial P_n(x)\n                double v = 0;\n                p[n - 1] = (1 - n) * p[n - 2];\n                for (int k = n - 1; k >= 0; k -= 2) {\n                    v = v * x2 + p[k];\n                    if (k > 2) {\n                        p[k - 2] = (1 - k) * p[k - 1] + (k - 2 * n) * p[k - 3];\n                    } else if (k == 2) {\n                        p[0] = -p[1];\n                    }\n                }\nif(((n ^<> 0) == 0)){                    v *= x;\n                }\n\n                coeff *= f;\n                function[n] = coeff * v;\n\n            }\n        }\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }",
          "47": "    public void acosh(final double[] operand, final int operandOffset,\n                     final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        double[] function = new double[1 + order];\n        final double x = operand[operandOffset];\n        function[0] = FastMath.acosh(x);\n        if (order > 0) {\n            // the nth order derivative of acosh has the form:\n            // dn(acosh(x)/dxn = P_n(x) / [x^2 - 1]^((2n-1)/2)\n            // where P_n(x) is a degree n-1 polynomial with same parity as n-1\n            // P_1(x) = 1, P_2(x) = -x, P_3(x) = 2x^2 + 1 ...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = (x^2-1) P_(n-1)'(x) - (2n-3) x P_(n-1)(x)\n            // as per polynomial parity, we can store coefficients of both P_(n-1) and P_n in the same array\n            final double[] p = new double[order];\n            p[0] = 1;\n            final double x2  = x * x;\n            final double f   = 1.0 / (x2 - 1);\n            double coeff = FastMath.sqrt(f);\n            function[1] = coeff * p[0];\n            for (int n = 2; n <= order; ++n) {\n\n                // update and evaluate polynomial P_n(x)\n                double v = 0;\n                p[n - 1] = (1 - n) * p[n - 2];\n                for (int k = n - 1; k >= 0; k -= 2) {\n                    v = v * x2 + p[k];\n                    if (k > 2) {\n                        p[k - 2] = (1 - k) * p[k - 1] + (k - 2 * n) * p[k - 3];\n                    } else if (k == 2) {\n                        p[0] = -p[1];\n                    }\n                }\nif(((n > 1) == 0)){                    v *= x;\n                }\n\n                coeff *= f;\n                function[n] = coeff * v;\n\n            }\n        }\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }",
          "48": "    public void acosh(final double[] operand, final int operandOffset,\n                     final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        double[] function = new double[1 + order];\n        final double x = operand[operandOffset];\n        function[0] = FastMath.acosh(x);\n        if (order > 0) {\n            // the nth order derivative of acosh has the form:\n            // dn(acosh(x)/dxn = P_n(x) / [x^2 - 1]^((2n-1)/2)\n            // where P_n(x) is a degree n-1 polynomial with same parity as n-1\n            // P_1(x) = 1, P_2(x) = -x, P_3(x) = 2x^2 + 1 ...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = (x^2-1) P_(n-1)'(x) - (2n-3) x P_(n-1)(x)\n            // as per polynomial parity, we can store coefficients of both P_(n-1) and P_n in the same array\n            final double[] p = new double[order];\n            p[0] = 1;\n            final double x2  = x * x;\n            final double f   = 1.0 / (x2 - 1);\n            double coeff = FastMath.sqrt(f);\n            function[1] = coeff * p[0];\n            for (int n = 2; n <= order; ++n) {\n\n                // update and evaluate polynomial P_n(x)\n                double v = 0;\n                p[n - 1] = (1 - n) * p[n - 2];\n                for (int k = n - 1; k >= 0; k -= 2) {\n                    v = v * x2 + p[k];\n                    if (k > 2) {\n                        p[k - 2] = (1 - k) * p[k - 1] + (k - 2 * n) * p[k - 3];\n                    } else if (k == 2) {\n                        p[0] = -p[1];\n                    }\n                }\nif((1 - k)){\n                    v *= x;\n                }\n\n                coeff *= f;\n                function[n] = coeff * v;\n\n            }\n        }\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }",
          "49": "    public void acosh(final double[] operand, final int operandOffset,\n                     final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        double[] function = new double[1 + order];\n        final double x = operand[operandOffset];\n        function[0] = FastMath.acosh(x);\n        if (order > 0) {\n            // the nth order derivative of acosh has the form:\n            // dn(acosh(x)/dxn = P_n(x) / [x^2 - 1]^((2n-1)/2)\n            // where P_n(x) is a degree n-1 polynomial with same parity as n-1\n            // P_1(x) = 1, P_2(x) = -x, P_3(x) = 2x^2 + 1 ...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = (x^2-1) P_(n-1)'(x) - (2n-3) x P_(n-1)(x)\n            // as per polynomial parity, we can store coefficients of both P_(n-1) and P_n in the same array\n            final double[] p = new double[order];\n            p[0] = 1;\n            final double x2  = x * x;\n            final double f   = 1.0 / (x2 - 1);\n            double coeff = FastMath.sqrt(f);\n            function[1] = coeff * p[0];\n            for (int n = 2; n <= order; ++n) {\n\n                // update and evaluate polynomial P_n(x)\n                double v = 0;\n                p[n - 1] = (1 - n) * p[n - 2];\n                for (int k = n - 1; k >= 0; k -= 2) {\n                    v = v * x2 + p[k];\n                    if (k > 2) {\n                        p[k - 2] = (1 - k) * p[k - 1] + (k - 2 * n) * p[k - 3];\n                    } else if (k == 2) {\n                        p[0] = -p[1];\n                    }\n                }\nif((( ^<> 1) == 0)){                    v *= x;\n                }\n\n                coeff *= f;\n                function[n] = coeff * v;\n\n            }\n        }\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }",
          "50": "    public void acosh(final double[] operand, final int operandOffset,\n                     final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        double[] function = new double[1 + order];\n        final double x = operand[operandOffset];\n        function[0] = FastMath.acosh(x);\n        if (order > 0) {\n            // the nth order derivative of acosh has the form:\n            // dn(acosh(x)/dxn = P_n(x) / [x^2 - 1]^((2n-1)/2)\n            // where P_n(x) is a degree n-1 polynomial with same parity as n-1\n            // P_1(x) = 1, P_2(x) = -x, P_3(x) = 2x^2 + 1 ...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = (x^2-1) P_(n-1)'(x) - (2n-3) x P_(n-1)(x)\n            // as per polynomial parity, we can store coefficients of both P_(n-1) and P_n in the same array\n            final double[] p = new double[order];\n            p[0] = 1;\n            final double x2  = x * x;\n            final double f   = 1.0 / (x2 - 1);\n            double coeff = FastMath.sqrt(f);\n            function[1] = coeff * p[0];\n            for (int n = 2; n <= order; ++n) {\n\n                // update and evaluate polynomial P_n(x)\n                double v = 0;\n                p[n - 1] = (1 - n) * p[n - 2];\n                for (int k = n - 1; k >= 0; k -= 2) {\n                    v = v * x2 + p[k];\n                    if (k > 2) {\n                        p[k - 2] = (1 - k) * p[k - 1] + (k - 2 * n) * p[k - 3];\n                    } else if (k == 2) {\n                        p[0] = -p[1];\n                    }\n                }\nif((n ^<> 1)){\n                if ((n ^ 1) == 0) {                    v *= x;\n                }\n\n                coeff *= f;\n                function[n] = coeff * v;\n\n}\n            }\n        }\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }",
          "51": "    public void acosh(final double[] operand, final int operandOffset,\n                     final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        double[] function = new double[1 + order];\n        final double x = operand[operandOffset];\n        function[0] = FastMath.acosh(x);\n        if (order > 0) {\n            // the nth order derivative of acosh has the form:\n            // dn(acosh(x)/dxn = P_n(x) / [x^2 - 1]^((2n-1)/2)\n            // where P_n(x) is a degree n-1 polynomial with same parity as n-1\n            // P_1(x) = 1, P_2(x) = -x, P_3(x) = 2x^2 + 1 ...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = (x^2-1) P_(n-1)'(x) - (2n-3) x P_(n-1)(x)\n            // as per polynomial parity, we can store coefficients of both P_(n-1) and P_n in the same array\n            final double[] p = new double[order];\n            p[0] = 1;\n            final double x2  = x * x;\n            final double f   = 1.0 / (x2 - 1);\n            double coeff = FastMath.sqrt(f);\n            function[1] = coeff * p[0];\n            for (int n = 2; n <= order; ++n) {\n\n                // update and evaluate polynomial P_n(x)\n                double v = 0;\n                p[n - 1] = (1 - n) * p[n - 2];\n                for (int k = n - 1; k >= 0; k -= 2) {\n                    v = v * x2 + p[k];\n                    if (k > 2) {\n                        p[k - 2] = (1 - k) * p[k - 1] + (k - 2 * n) * p[k - 3];\n                    } else if (k == 2) {\n                        p[0] = -p[1];\n                    }\n                }\nif(((coeff ^<> 1) == 0)){                    v *= x;\n                }\n\n                coeff *= f;\n                function[n] = coeff * v;\n\n            }\n        }\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }",
          "52": "    public void acosh(final double[] operand, final int operandOffset,\n                     final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        double[] function = new double[1 + order];\n        final double x = operand[operandOffset];\n        function[0] = FastMath.acosh(x);\n        if (order > 0) {\n            // the nth order derivative of acosh has the form:\n            // dn(acosh(x)/dxn = P_n(x) / [x^2 - 1]^((2n-1)/2)\n            // where P_n(x) is a degree n-1 polynomial with same parity as n-1\n            // P_1(x) = 1, P_2(x) = -x, P_3(x) = 2x^2 + 1 ...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = (x^2-1) P_(n-1)'(x) - (2n-3) x P_(n-1)(x)\n            // as per polynomial parity, we can store coefficients of both P_(n-1) and P_n in the same array\n            final double[] p = new double[order];\n            p[0] = 1;\n            final double x2  = x * x;\n            final double f   = 1.0 / (x2 - 1);\n            double coeff = FastMath.sqrt(f);\n            function[1] = coeff * p[0];\n            for (int n = 2; n <= order; ++n) {\n\n                // update and evaluate polynomial P_n(x)\n                double v = 0;\n                p[n - 1] = (1 - n) * p[n - 2];\n                for (int k = n - 1; k >= 0; k -= 2) {\n                    v = v * x2 + p[k];\n                    if (k > 2) {\n                        p[k - 2] = (1 - k) * p[k - 1] + (k - 2 * n) * p[k - 3];\n                    } else if (k == 2) {\n                        p[0] = -p[1];\n                    }\n                }\nif((n == 0)){\n                    v *= x;\n                }\n\n                coeff *= f;\n                function[n] = coeff * v;\n\n            }\n        }\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }",
          "53": "    public void acosh(final double[] operand, final int operandOffset,\n                     final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        double[] function = new double[1 + order];\n        final double x = operand[operandOffset];\n        function[0] = FastMath.acosh(x);\n        if (order > 0) {\n            // the nth order derivative of acosh has the form:\n            // dn(acosh(x)/dxn = P_n(x) / [x^2 - 1]^((2n-1)/2)\n            // where P_n(x) is a degree n-1 polynomial with same parity as n-1\n            // P_1(x) = 1, P_2(x) = -x, P_3(x) = 2x^2 + 1 ...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = (x^2-1) P_(n-1)'(x) - (2n-3) x P_(n-1)(x)\n            // as per polynomial parity, we can store coefficients of both P_(n-1) and P_n in the same array\n            final double[] p = new double[order];\n            p[0] = 1;\n            final double x2  = x * x;\n            final double f   = 1.0 / (x2 - 1);\n            double coeff = FastMath.sqrt(f);\n            function[1] = coeff * p[0];\n            for (int n = 2; n <= order; ++n) {\n\n                // update and evaluate polynomial P_n(x)\n                double v = 0;\n                p[n - 1] = (1 - n) * p[n - 2];\n                for (int k = n - 1; k >= 0; k -= 2) {\n                    v = v * x2 + p[k];\n                    if (k > 2) {\n                        p[k - 2] = (1 - k) * p[k - 1] + (k - 2 * n) * p[k - 3];\n                    } else if (k == 2) {\n                        p[0] = -p[1];\n                    }\n                }\nif(((f ^<> 1) == 0)){                    v *= x;\n                }\n\n                coeff *= f;\n                function[n] = coeff * v;\n\n            }\n        }\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }",
          "54": "    public void acosh(final double[] operand, final int operandOffset,\n                     final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        double[] function = new double[1 + order];\n        final double x = operand[operandOffset];\n        function[0] = FastMath.acosh(x);\n        if (order > 0) {\n            // the nth order derivative of acosh has the form:\n            // dn(acosh(x)/dxn = P_n(x) / [x^2 - 1]^((2n-1)/2)\n            // where P_n(x) is a degree n-1 polynomial with same parity as n-1\n            // P_1(x) = 1, P_2(x) = -x, P_3(x) = 2x^2 + 1 ...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = (x^2-1) P_(n-1)'(x) - (2n-3) x P_(n-1)(x)\n            // as per polynomial parity, we can store coefficients of both P_(n-1) and P_n in the same array\n            final double[] p = new double[order];\n            p[0] = 1;\n            final double x2  = x * x;\n            final double f   = 1.0 / (x2 - 1);\n            double coeff = FastMath.sqrt(f);\n            function[1] = coeff * p[0];\n            for (int n = 2; n <= order; ++n) {\n\n                // update and evaluate polynomial P_n(x)\n                double v = 0;\n                p[n - 1] = (1 - n) * p[n - 2];\n                for (int k = n - 1; k >= 0; k -= 2) {\n                    v = v * x2 + p[k];\n                    if (k > 2) {\n                        p[k - 2] = (1 - k) * p[k - 1] + (k - 2 * n) * p[k - 3];\n                    } else if (k == 2) {\n                        p[0] = -p[1];\n                    }\n                }\nfor(int n = 2;(n <= order);++n) {                if ((n ^ 1) == 0) {                    v *= x;\n                }\n\n                coeff *= f;\n                function[n] = coeff * v;\n\n            }\n        }\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }",
          "55": "    public void acosh(final double[] operand, final int operandOffset,\n                     final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        double[] function = new double[1 + order];\n        final double x = operand[operandOffset];\n        function[0] = FastMath.acosh(x);\n        if (order > 0) {\n            // the nth order derivative of acosh has the form:\n            // dn(acosh(x)/dxn = P_n(x) / [x^2 - 1]^((2n-1)/2)\n            // where P_n(x) is a degree n-1 polynomial with same parity as n-1\n            // P_1(x) = 1, P_2(x) = -x, P_3(x) = 2x^2 + 1 ...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = (x^2-1) P_(n-1)'(x) - (2n-3) x P_(n-1)(x)\n            // as per polynomial parity, we can store coefficients of both P_(n-1) and P_n in the same array\n            final double[] p = new double[order];\n            p[0] = 1;\n            final double x2  = x * x;\n            final double f   = 1.0 / (x2 - 1);\n            double coeff = FastMath.sqrt(f);\n            function[1] = coeff * p[0];\n            for (int n = 2; n <= order; ++n) {\n\n                // update and evaluate polynomial P_n(x)\n                double v = 0;\n                p[n - 1] = (1 - n) * p[n - 2];\n                for (int k = n - 1; k >= 0; k -= 2) {\n                    v = v * x2 + p[k];\n                    if (k > 2) {\n                        p[k - 2] = (1 - k) * p[k - 1] + (k - 2 * n) * p[k - 3];\n                    } else if (k == 2) {\n                        p[0] = -p[1];\n                    }\n                }\nif((((n ^<> 1) == 0) && ((n ^<> 1) == 0))){\n                    v *= x;\n                }\n\n                coeff *= f;\n                function[n] = coeff * v;\n\n            }\n        }\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }",
          "56": "    public void acosh(final double[] operand, final int operandOffset,\n                     final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        double[] function = new double[1 + order];\n        final double x = operand[operandOffset];\n        function[0] = FastMath.acosh(x);\n        if (order > 0) {\n            // the nth order derivative of acosh has the form:\n            // dn(acosh(x)/dxn = P_n(x) / [x^2 - 1]^((2n-1)/2)\n            // where P_n(x) is a degree n-1 polynomial with same parity as n-1\n            // P_1(x) = 1, P_2(x) = -x, P_3(x) = 2x^2 + 1 ...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = (x^2-1) P_(n-1)'(x) - (2n-3) x P_(n-1)(x)\n            // as per polynomial parity, we can store coefficients of both P_(n-1) and P_n in the same array\n            final double[] p = new double[order];\n            p[0] = 1;\n            final double x2  = x * x;\n            final double f   = 1.0 / (x2 - 1);\n            double coeff = FastMath.sqrt(f);\n            function[1] = coeff * p[0];\n            for (int n = 2; n <= order; ++n) {\n\n                // update and evaluate polynomial P_n(x)\n                double v = 0;\n                p[n - 1] = (1 - n) * p[n - 2];\n                for (int k = n - 1; k >= 0; k -= 2) {\n                    v = v * x2 + p[k];\n                    if (k > 2) {\n                        p[k - 2] = (1 - k) * p[k - 1] + (k - 2 * n) * p[k - 3];\n                    } else if (k == 2) {\n                        p[0] = -p[1];\n                    }\n                }\nif((k == 2)){\n                    v *= x;\n                }\n\n                coeff *= f;\n                function[n] = coeff * v;\n\n            }\n        }\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }",
          "57": "    public void acosh(final double[] operand, final int operandOffset,\n                     final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        double[] function = new double[1 + order];\n        final double x = operand[operandOffset];\n        function[0] = FastMath.acosh(x);\n        if (order > 0) {\n            // the nth order derivative of acosh has the form:\n            // dn(acosh(x)/dxn = P_n(x) / [x^2 - 1]^((2n-1)/2)\n            // where P_n(x) is a degree n-1 polynomial with same parity as n-1\n            // P_1(x) = 1, P_2(x) = -x, P_3(x) = 2x^2 + 1 ...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = (x^2-1) P_(n-1)'(x) - (2n-3) x P_(n-1)(x)\n            // as per polynomial parity, we can store coefficients of both P_(n-1) and P_n in the same array\n            final double[] p = new double[order];\n            p[0] = 1;\n            final double x2  = x * x;\n            final double f   = 1.0 / (x2 - 1);\n            double coeff = FastMath.sqrt(f);\n            function[1] = coeff * p[0];\n            for (int n = 2; n <= order; ++n) {\n\n                // update and evaluate polynomial P_n(x)\n                double v = 0;\n                p[n - 1] = (1 - n) * p[n - 2];\n                for (int k = n - 1; k >= 0; k -= 2) {\n                    v = v * x2 + p[k];\n                    if (k > 2) {\n                        p[k - 2] = (1 - k) * p[k - 1] + (k - 2 * n) * p[k - 3];\n                    } else if (k == 2) {\n                        p[0] = -p[1];\n                    }\n                }\nif(((n ^<> 1) - 0)){                    v *= x;\n                }\n\n                coeff *= f;\n                function[n] = coeff * v;\n\n            }\n        }\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }",
          "58": "    public void acosh(final double[] operand, final int operandOffset,\n                     final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        double[] function = new double[1 + order];\n        final double x = operand[operandOffset];\n        function[0] = FastMath.acosh(x);\n        if (order > 0) {\n            // the nth order derivative of acosh has the form:\n            // dn(acosh(x)/dxn = P_n(x) / [x^2 - 1]^((2n-1)/2)\n            // where P_n(x) is a degree n-1 polynomial with same parity as n-1\n            // P_1(x) = 1, P_2(x) = -x, P_3(x) = 2x^2 + 1 ...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = (x^2-1) P_(n-1)'(x) - (2n-3) x P_(n-1)(x)\n            // as per polynomial parity, we can store coefficients of both P_(n-1) and P_n in the same array\n            final double[] p = new double[order];\n            p[0] = 1;\n            final double x2  = x * x;\n            final double f   = 1.0 / (x2 - 1);\n            double coeff = FastMath.sqrt(f);\n            function[1] = coeff * p[0];\n            for (int n = 2; n <= order; ++n) {\n\n                // update and evaluate polynomial P_n(x)\n                double v = 0;\n                p[n - 1] = (1 - n) * p[n - 2];\n                for (int k = n - 1; k >= 0; k -= 2) {\n                    v = v * x2 + p[k];\n                    if (k > 2) {\n                        p[k - 2] = (1 - k) * p[k - 1] + (k - 2 * n) * p[k - 3];\n                    } else if (k == 2) {\n                        p[0] = -p[1];\n                    }\n                }\nif(((n ^<> 1) == n)){\n                    v *= x;\n                }\n\n                coeff *= f;\n                function[n] = coeff * v;\n\n            }\n        }\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }",
          "59": "    public void acosh(final double[] operand, final int operandOffset,\n                     final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        double[] function = new double[1 + order];\n        final double x = operand[operandOffset];\n        function[0] = FastMath.acosh(x);\n        if (order > 0) {\n            // the nth order derivative of acosh has the form:\n            // dn(acosh(x)/dxn = P_n(x) / [x^2 - 1]^((2n-1)/2)\n            // where P_n(x) is a degree n-1 polynomial with same parity as n-1\n            // P_1(x) = 1, P_2(x) = -x, P_3(x) = 2x^2 + 1 ...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = (x^2-1) P_(n-1)'(x) - (2n-3) x P_(n-1)(x)\n            // as per polynomial parity, we can store coefficients of both P_(n-1) and P_n in the same array\n            final double[] p = new double[order];\n            p[0] = 1;\n            final double x2  = x * x;\n            final double f   = 1.0 / (x2 - 1);\n            double coeff = FastMath.sqrt(f);\n            function[1] = coeff * p[0];\n            for (int n = 2; n <= order; ++n) {\n\n                // update and evaluate polynomial P_n(x)\n                double v = 0;\n                p[n - 1] = (1 - n) * p[n - 2];\n                for (int k = n - 1; k >= 0; k -= 2) {\n                    v = v * x2 + p[k];\n                    if (k > 2) {\n                        p[k - 2] = (1 - k) * p[k - 1] + (k - 2 * n) * p[k - 3];\n                    } else if (k == 2) {\n                        p[0] = -p[1];\n                    }\n                }\nif(((x ^<> 1) == 0)){                    v *= x;\n                }\n\n                coeff *= f;\n                function[n] = coeff * v;\n\n            }\n        }\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }",
          "60": "    public void acosh(final double[] operand, final int operandOffset,\n                     final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        double[] function = new double[1 + order];\n        final double x = operand[operandOffset];\n        function[0] = FastMath.acosh(x);\n        if (order > 0) {\n            // the nth order derivative of acosh has the form:\n            // dn(acosh(x)/dxn = P_n(x) / [x^2 - 1]^((2n-1)/2)\n            // where P_n(x) is a degree n-1 polynomial with same parity as n-1\n            // P_1(x) = 1, P_2(x) = -x, P_3(x) = 2x^2 + 1 ...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = (x^2-1) P_(n-1)'(x) - (2n-3) x P_(n-1)(x)\n            // as per polynomial parity, we can store coefficients of both P_(n-1) and P_n in the same array\n            final double[] p = new double[order];\n            p[0] = 1;\n            final double x2  = x * x;\n            final double f   = 1.0 / (x2 - 1);\n            double coeff = FastMath.sqrt(f);\n            function[1] = coeff * p[0];\n            for (int n = 2; n <= order; ++n) {\n\n                // update and evaluate polynomial P_n(x)\n                double v = 0;\n                p[n - 1] = (1 - n) * p[n - 2];\n                for (int k = n - 1; k >= 0; k -= 2) {\n                    v = v * x2 + p[k];\n                    if (k > 2) {\n                        p[k - 2] = (1 - k) * p[k - 1] + (k - 2 * n) * p[k - 3];\n                    } else if (k == 2) {\n                        p[0] = -p[1];\n                    }\n                }\nif(((n ^<> 1) != n)){\n                    v *= x;\n                }\n\n                coeff *= f;\n                function[n] = coeff * v;\n\n            }\n        }\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }",
          "61": "    public void acosh(final double[] operand, final int operandOffset,\n                     final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        double[] function = new double[1 + order];\n        final double x = operand[operandOffset];\n        function[0] = FastMath.acosh(x);\n        if (order > 0) {\n            // the nth order derivative of acosh has the form:\n            // dn(acosh(x)/dxn = P_n(x) / [x^2 - 1]^((2n-1)/2)\n            // where P_n(x) is a degree n-1 polynomial with same parity as n-1\n            // P_1(x) = 1, P_2(x) = -x, P_3(x) = 2x^2 + 1 ...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = (x^2-1) P_(n-1)'(x) - (2n-3) x P_(n-1)(x)\n            // as per polynomial parity, we can store coefficients of both P_(n-1) and P_n in the same array\n            final double[] p = new double[order];\n            p[0] = 1;\n            final double x2  = x * x;\n            final double f   = 1.0 / (x2 - 1);\n            double coeff = FastMath.sqrt(f);\n            function[1] = coeff * p[0];\n            for (int n = 2; n <= order; ++n) {\n\n                // update and evaluate polynomial P_n(x)\n                double v = 0;\n                p[n - 1] = (1 - n) * p[n - 2];\n                for (int k = n - 1; k >= 0; k -= 2) {\n                    v = v * x2 + p[k];\n                    if (k > 2) {\n                        p[k - 2] = (1 - k) * p[k - 1] + (k - 2 * n) * p[k - 3];\n                    } else if (k == 2) {\n                        p[0] = -p[1];\n                    }\n                }\nif((n == ((n ^<> 1) == 0))){\n                    v *= x;\n                }\n\n                coeff *= f;\n                function[n] = coeff * v;\n\n            }\n        }\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }",
          "62": "    public void acosh(final double[] operand, final int operandOffset,\n                     final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        double[] function = new double[1 + order];\n        final double x = operand[operandOffset];\n        function[0] = FastMath.acosh(x);\n        if (order > 0) {\n            // the nth order derivative of acosh has the form:\n            // dn(acosh(x)/dxn = P_n(x) / [x^2 - 1]^((2n-1)/2)\n            // where P_n(x) is a degree n-1 polynomial with same parity as n-1\n            // P_1(x) = 1, P_2(x) = -x, P_3(x) = 2x^2 + 1 ...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = (x^2-1) P_(n-1)'(x) - (2n-3) x P_(n-1)(x)\n            // as per polynomial parity, we can store coefficients of both P_(n-1) and P_n in the same array\n            final double[] p = new double[order];\n            p[0] = 1;\n            final double x2  = x * x;\n            final double f   = 1.0 / (x2 - 1);\n            double coeff = FastMath.sqrt(f);\n            function[1] = coeff * p[0];\n            for (int n = 2; n <= order; ++n) {\n\n                // update and evaluate polynomial P_n(x)\n                double v = 0;\n                p[n - 1] = (1 - n) * p[n - 2];\n                for (int k = n - 1; k >= 0; k -= 2) {\n                    v = v * x2 + p[k];\n                    if (k > 2) {\n                        p[k - 2] = (1 - k) * p[k - 1] + (k - 2 * n) * p[k - 3];\n                    } else if (k == 2) {\n                        p[0] = -p[1];\n                    }\n                }\n                if ((n ^ 1) == 0) {                    v *= x;\n                }\n\n                coeff *= f;\n                function[n] = coeff * v;\n\n            }\n        }\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }",
          "63": "    public void acosh(final double[] operand, final int operandOffset,\n                     final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        double[] function = new double[1 + order];\n        final double x = operand[operandOffset];\n        function[0] = FastMath.acosh(x);\n        if (order > 0) {\n            // the nth order derivative of acosh has the form:\n            // dn(acosh(x)/dxn = P_n(x) / [x^2 - 1]^((2n-1)/2)\n            // where P_n(x) is a degree n-1 polynomial with same parity as n-1\n            // P_1(x) = 1, P_2(x) = -x, P_3(x) = 2x^2 + 1 ...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = (x^2-1) P_(n-1)'(x) - (2n-3) x P_(n-1)(x)\n            // as per polynomial parity, we can store coefficients of both P_(n-1) and P_n in the same array\n            final double[] p = new double[order];\n            p[0] = 1;\n            final double x2  = x * x;\n            final double f   = 1.0 / (x2 - 1);\n            double coeff = FastMath.sqrt(f);\n            function[1] = coeff * p[0];\n            for (int n = 2; n <= order; ++n) {\n\n                // update and evaluate polynomial P_n(x)\n                double v = 0;\n                p[n - 1] = (1 - n) * p[n - 2];\n                for (int k = n - 1; k >= 0; k -= 2) {\n                    v = v * x2 + p[k];\n                    if (k > 2) {\n                        p[k - 2] = (1 - k) * p[k - 1] + (k - 2 * n) * p[k - 3];\n                    } else if (k == 2) {\n                        p[0] = -p[1];\n                    }\n                }\nif((n != v)){\n                    v *= x;\n                }\n\n                coeff *= f;\n                function[n] = coeff * v;\n\n            }\n        }\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }",
          "64": "    public void acosh(final double[] operand, final int operandOffset,\n                     final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        double[] function = new double[1 + order];\n        final double x = operand[operandOffset];\n        function[0] = FastMath.acosh(x);\n        if (order > 0) {\n            // the nth order derivative of acosh has the form:\n            // dn(acosh(x)/dxn = P_n(x) / [x^2 - 1]^((2n-1)/2)\n            // where P_n(x) is a degree n-1 polynomial with same parity as n-1\n            // P_1(x) = 1, P_2(x) = -x, P_3(x) = 2x^2 + 1 ...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = (x^2-1) P_(n-1)'(x) - (2n-3) x P_(n-1)(x)\n            // as per polynomial parity, we can store coefficients of both P_(n-1) and P_n in the same array\n            final double[] p = new double[order];\n            p[0] = 1;\n            final double x2  = x * x;\n            final double f   = 1.0 / (x2 - 1);\n            double coeff = FastMath.sqrt(f);\n            function[1] = coeff * p[0];\n            for (int n = 2; n <= order; ++n) {\n\n                // update and evaluate polynomial P_n(x)\n                double v = 0;\n                p[n - 1] = (1 - n) * p[n - 2];\n                for (int k = n - 1; k >= 0; k -= 2) {\n                    v = v * x2 + p[k];\n                    if (k > 2) {\n                        p[k - 2] = (1 - k) * p[k - 1] + (k - 2 * n) * p[k - 3];\n                    } else if (k == 2) {\n                        p[0] = -p[1];\n                    }\n                }\nif(((n < 1) == 0)){                    v *= x;\n                }\n\n                coeff *= f;\n                function[n] = coeff * v;\n\n            }\n        }\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }",
          "65": "    public void acosh(final double[] operand, final int operandOffset,\n                     final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        double[] function = new double[1 + order];\n        final double x = operand[operandOffset];\n        function[0] = FastMath.acosh(x);\n        if (order > 0) {\n            // the nth order derivative of acosh has the form:\n            // dn(acosh(x)/dxn = P_n(x) / [x^2 - 1]^((2n-1)/2)\n            // where P_n(x) is a degree n-1 polynomial with same parity as n-1\n            // P_1(x) = 1, P_2(x) = -x, P_3(x) = 2x^2 + 1 ...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = (x^2-1) P_(n-1)'(x) - (2n-3) x P_(n-1)(x)\n            // as per polynomial parity, we can store coefficients of both P_(n-1) and P_n in the same array\n            final double[] p = new double[order];\n            p[0] = 1;\n            final double x2  = x * x;\n            final double f   = 1.0 / (x2 - 1);\n            double coeff = FastMath.sqrt(f);\n            function[1] = coeff * p[0];\n            for (int n = 2; n <= order; ++n) {\n\n                // update and evaluate polynomial P_n(x)\n                double v = 0;\n                p[n - 1] = (1 - n) * p[n - 2];\n                for (int k = n - 1; k >= 0; k -= 2) {\n                    v = v * x2 + p[k];\n                    if (k > 2) {\n                        p[k - 2] = (1 - k) * p[k - 1] + (k - 2 * n) * p[k - 3];\n                    } else if (k == 2) {\n                        p[0] = -p[1];\n                    }\n                }\nv *= x;\n                    v *= x;\n                }\n\n                coeff *= f;\n                function[n] = coeff * v;\n\n            }\n        }\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }",
          "66": "    public void acosh(final double[] operand, final int operandOffset,\n                     final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        double[] function = new double[1 + order];\n        final double x = operand[operandOffset];\n        function[0] = FastMath.acosh(x);\n        if (order > 0) {\n            // the nth order derivative of acosh has the form:\n            // dn(acosh(x)/dxn = P_n(x) / [x^2 - 1]^((2n-1)/2)\n            // where P_n(x) is a degree n-1 polynomial with same parity as n-1\n            // P_1(x) = 1, P_2(x) = -x, P_3(x) = 2x^2 + 1 ...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = (x^2-1) P_(n-1)'(x) - (2n-3) x P_(n-1)(x)\n            // as per polynomial parity, we can store coefficients of both P_(n-1) and P_n in the same array\n            final double[] p = new double[order];\n            p[0] = 1;\n            final double x2  = x * x;\n            final double f   = 1.0 / (x2 - 1);\n            double coeff = FastMath.sqrt(f);\n            function[1] = coeff * p[0];\n            for (int n = 2; n <= order; ++n) {\n\n                // update and evaluate polynomial P_n(x)\n                double v = 0;\n                p[n - 1] = (1 - n) * p[n - 2];\n                for (int k = n - 1; k >= 0; k -= 2) {\n                    v = v * x2 + p[k];\n                    if (k > 2) {\n                        p[k - 2] = (1 - k) * p[k - 1] + (k - 2 * n) * p[k - 3];\n                    } else if (k == 2) {\n                        p[0] = -p[1];\n                    }\n                }\nif(((n != 0) && ((n ^<> 1) == 0))){\n                    v *= x;\n                }\n\n                coeff *= f;\n                function[n] = coeff * v;\n\n            }\n        }\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }",
          "67": "    public void acosh(final double[] operand, final int operandOffset,\n                     final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        double[] function = new double[1 + order];\n        final double x = operand[operandOffset];\n        function[0] = FastMath.acosh(x);\n        if (order > 0) {\n            // the nth order derivative of acosh has the form:\n            // dn(acosh(x)/dxn = P_n(x) / [x^2 - 1]^((2n-1)/2)\n            // where P_n(x) is a degree n-1 polynomial with same parity as n-1\n            // P_1(x) = 1, P_2(x) = -x, P_3(x) = 2x^2 + 1 ...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = (x^2-1) P_(n-1)'(x) - (2n-3) x P_(n-1)(x)\n            // as per polynomial parity, we can store coefficients of both P_(n-1) and P_n in the same array\n            final double[] p = new double[order];\n            p[0] = 1;\n            final double x2  = x * x;\n            final double f   = 1.0 / (x2 - 1);\n            double coeff = FastMath.sqrt(f);\n            function[1] = coeff * p[0];\n            for (int n = 2; n <= order; ++n) {\n\n                // update and evaluate polynomial P_n(x)\n                double v = 0;\n                p[n - 1] = (1 - n) * p[n - 2];\n                for (int k = n - 1; k >= 0; k -= 2) {\n                    v = v * x2 + p[k];\n                    if (k > 2) {\n                        p[k - 2] = (1 - k) * p[k - 1] + (k - 2 * n) * p[k - 3];\n                    } else if (k == 2) {\n                        p[0] = -p[1];\n                    }\n                }\nif(((n ^<> 1) && 0)){                    v *= x;\n                }\n\n                coeff *= f;\n                function[n] = coeff * v;\n\n            }\n        }\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }",
          "68": "    public void acosh(final double[] operand, final int operandOffset,\n                     final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        double[] function = new double[1 + order];\n        final double x = operand[operandOffset];\n        function[0] = FastMath.acosh(x);\n        if (order > 0) {\n            // the nth order derivative of acosh has the form:\n            // dn(acosh(x)/dxn = P_n(x) / [x^2 - 1]^((2n-1)/2)\n            // where P_n(x) is a degree n-1 polynomial with same parity as n-1\n            // P_1(x) = 1, P_2(x) = -x, P_3(x) = 2x^2 + 1 ...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = (x^2-1) P_(n-1)'(x) - (2n-3) x P_(n-1)(x)\n            // as per polynomial parity, we can store coefficients of both P_(n-1) and P_n in the same array\n            final double[] p = new double[order];\n            p[0] = 1;\n            final double x2  = x * x;\n            final double f   = 1.0 / (x2 - 1);\n            double coeff = FastMath.sqrt(f);\n            function[1] = coeff * p[0];\n            for (int n = 2; n <= order; ++n) {\n\n                // update and evaluate polynomial P_n(x)\n                double v = 0;\n                p[n - 1] = (1 - n) * p[n - 2];\n                for (int k = n - 1; k >= 0; k -= 2) {\n                    v = v * x2 + p[k];\n                    if (k > 2) {\n                        p[k - 2] = (1 - k) * p[k - 1] + (k - 2 * n) * p[k - 3];\n                    } else if (k == 2) {\n                        p[0] = -p[1];\n                    }\n                }\nif((((n ^<> 1) == 0) && (n == 0))){\n                    v *= x;\n                }\n\n                coeff *= f;\n                function[n] = coeff * v;\n\n            }\n        }\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }",
          "69": "    public void acosh(final double[] operand, final int operandOffset,\n                     final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        double[] function = new double[1 + order];\n        final double x = operand[operandOffset];\n        function[0] = FastMath.acosh(x);\n        if (order > 0) {\n            // the nth order derivative of acosh has the form:\n            // dn(acosh(x)/dxn = P_n(x) / [x^2 - 1]^((2n-1)/2)\n            // where P_n(x) is a degree n-1 polynomial with same parity as n-1\n            // P_1(x) = 1, P_2(x) = -x, P_3(x) = 2x^2 + 1 ...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = (x^2-1) P_(n-1)'(x) - (2n-3) x P_(n-1)(x)\n            // as per polynomial parity, we can store coefficients of both P_(n-1) and P_n in the same array\n            final double[] p = new double[order];\n            p[0] = 1;\n            final double x2  = x * x;\n            final double f   = 1.0 / (x2 - 1);\n            double coeff = FastMath.sqrt(f);\n            function[1] = coeff * p[0];\n            for (int n = 2; n <= order; ++n) {\n\n                // update and evaluate polynomial P_n(x)\n                double v = 0;\n                p[n - 1] = (1 - n) * p[n - 2];\n                for (int k = n - 1; k >= 0; k -= 2) {\n                    v = v * x2 + p[k];\n                    if (k > 2) {\n                        p[k - 2] = (1 - k) * p[k - 1] + (k - 2 * n) * p[k - 3];\n                    } else if (k == 2) {\n                        p[0] = -p[1];\n                    }\n                }\nv = ((v * x2) + p[k]);\n                    v *= x;\n                }\n\n                coeff *= f;\n                function[n] = coeff * v;\n\n            }\n        }\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }",
          "70": "    public void acosh(final double[] operand, final int operandOffset,\n                     final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        double[] function = new double[1 + order];\n        final double x = operand[operandOffset];\n        function[0] = FastMath.acosh(x);\n        if (order > 0) {\n            // the nth order derivative of acosh has the form:\n            // dn(acosh(x)/dxn = P_n(x) / [x^2 - 1]^((2n-1)/2)\n            // where P_n(x) is a degree n-1 polynomial with same parity as n-1\n            // P_1(x) = 1, P_2(x) = -x, P_3(x) = 2x^2 + 1 ...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = (x^2-1) P_(n-1)'(x) - (2n-3) x P_(n-1)(x)\n            // as per polynomial parity, we can store coefficients of both P_(n-1) and P_n in the same array\n            final double[] p = new double[order];\n            p[0] = 1;\n            final double x2  = x * x;\n            final double f   = 1.0 / (x2 - 1);\n            double coeff = FastMath.sqrt(f);\n            function[1] = coeff * p[0];\n            for (int n = 2; n <= order; ++n) {\n\n                // update and evaluate polynomial P_n(x)\n                double v = 0;\n                p[n - 1] = (1 - n) * p[n - 2];\n                for (int k = n - 1; k >= 0; k -= 2) {\n                    v = v * x2 + p[k];\n                    if (k > 2) {\n                        p[k - 2] = (1 - k) * p[k - 1] + (k - 2 * n) * p[k - 3];\n                    } else if (k == 2) {\n                        p[0] = -p[1];\n                    }\n                }\ndouble v = 0;\n                if ((n ^ 1) == 0) {                    v *= x;\n                }\n\n                coeff *= f;\n                function[n] = coeff * v;\n\n            }\n        }\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }",
          "71": "    public void acosh(final double[] operand, final int operandOffset,\n                     final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        double[] function = new double[1 + order];\n        final double x = operand[operandOffset];\n        function[0] = FastMath.acosh(x);\n        if (order > 0) {\n            // the nth order derivative of acosh has the form:\n            // dn(acosh(x)/dxn = P_n(x) / [x^2 - 1]^((2n-1)/2)\n            // where P_n(x) is a degree n-1 polynomial with same parity as n-1\n            // P_1(x) = 1, P_2(x) = -x, P_3(x) = 2x^2 + 1 ...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = (x^2-1) P_(n-1)'(x) - (2n-3) x P_(n-1)(x)\n            // as per polynomial parity, we can store coefficients of both P_(n-1) and P_n in the same array\n            final double[] p = new double[order];\n            p[0] = 1;\n            final double x2  = x * x;\n            final double f   = 1.0 / (x2 - 1);\n            double coeff = FastMath.sqrt(f);\n            function[1] = coeff * p[0];\n            for (int n = 2; n <= order; ++n) {\n\n                // update and evaluate polynomial P_n(x)\n                double v = 0;\n                p[n - 1] = (1 - n) * p[n - 2];\n                for (int k = n - 1; k >= 0; k -= 2) {\n                    v = v * x2 + p[k];\n                    if (k > 2) {\n                        p[k - 2] = (1 - k) * p[k - 1] + (k - 2 * n) * p[k - 3];\n                    } else if (k == 2) {\n                        p[0] = -p[1];\n                    }\n                }\np[(k - 2)] = (((1 - k) * p[(k - 1)]) + ((k - (2 * n)) * p[(k - 3)]));\n                    v *= x;\n                }\n\n                coeff *= f;\n                function[n] = coeff * v;\n\n            }\n        }\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }",
          "72": "    public void acosh(final double[] operand, final int operandOffset,\n                     final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        double[] function = new double[1 + order];\n        final double x = operand[operandOffset];\n        function[0] = FastMath.acosh(x);\n        if (order > 0) {\n            // the nth order derivative of acosh has the form:\n            // dn(acosh(x)/dxn = P_n(x) / [x^2 - 1]^((2n-1)/2)\n            // where P_n(x) is a degree n-1 polynomial with same parity as n-1\n            // P_1(x) = 1, P_2(x) = -x, P_3(x) = 2x^2 + 1 ...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = (x^2-1) P_(n-1)'(x) - (2n-3) x P_(n-1)(x)\n            // as per polynomial parity, we can store coefficients of both P_(n-1) and P_n in the same array\n            final double[] p = new double[order];\n            p[0] = 1;\n            final double x2  = x * x;\n            final double f   = 1.0 / (x2 - 1);\n            double coeff = FastMath.sqrt(f);\n            function[1] = coeff * p[0];\n            for (int n = 2; n <= order; ++n) {\n\n                // update and evaluate polynomial P_n(x)\n                double v = 0;\n                p[n - 1] = (1 - n) * p[n - 2];\n                for (int k = n - 1; k >= 0; k -= 2) {\n                    v = v * x2 + p[k];\n                    if (k > 2) {\n                        p[k - 2] = (1 - k) * p[k - 1] + (k - 2 * n) * p[k - 3];\n                    } else if (k == 2) {\n                        p[0] = -p[1];\n                    }\n                }\nif(((n != n) && ((n ^<> 1) == 0))){\n                    v *= x;\n                }\n\n                coeff *= f;\n                function[n] = coeff * v;\n\n            }\n        }\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }",
          "73": "    public void acosh(final double[] operand, final int operandOffset,\n                     final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        double[] function = new double[1 + order];\n        final double x = operand[operandOffset];\n        function[0] = FastMath.acosh(x);\n        if (order > 0) {\n            // the nth order derivative of acosh has the form:\n            // dn(acosh(x)/dxn = P_n(x) / [x^2 - 1]^((2n-1)/2)\n            // where P_n(x) is a degree n-1 polynomial with same parity as n-1\n            // P_1(x) = 1, P_2(x) = -x, P_3(x) = 2x^2 + 1 ...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = (x^2-1) P_(n-1)'(x) - (2n-3) x P_(n-1)(x)\n            // as per polynomial parity, we can store coefficients of both P_(n-1) and P_n in the same array\n            final double[] p = new double[order];\n            p[0] = 1;\n            final double x2  = x * x;\n            final double f   = 1.0 / (x2 - 1);\n            double coeff = FastMath.sqrt(f);\n            function[1] = coeff * p[0];\n            for (int n = 2; n <= order; ++n) {\n\n                // update and evaluate polynomial P_n(x)\n                double v = 0;\n                p[n - 1] = (1 - n) * p[n - 2];\n                for (int k = n - 1; k >= 0; k -= 2) {\n                    v = v * x2 + p[k];\n                    if (k > 2) {\n                        p[k - 2] = (1 - k) * p[k - 1] + (k - 2 * n) * p[k - 3];\n                    } else if (k == 2) {\n                        p[0] = -p[1];\n                    }\n                }\nif(((n == n) && ((n ^<> 1) == 0))){\n                    v *= x;\n                }\n\n                coeff *= f;\n                function[n] = coeff * v;\n\n            }\n        }\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }",
          "74": "    public void acosh(final double[] operand, final int operandOffset,\n                     final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        double[] function = new double[1 + order];\n        final double x = operand[operandOffset];\n        function[0] = FastMath.acosh(x);\n        if (order > 0) {\n            // the nth order derivative of acosh has the form:\n            // dn(acosh(x)/dxn = P_n(x) / [x^2 - 1]^((2n-1)/2)\n            // where P_n(x) is a degree n-1 polynomial with same parity as n-1\n            // P_1(x) = 1, P_2(x) = -x, P_3(x) = 2x^2 + 1 ...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = (x^2-1) P_(n-1)'(x) - (2n-3) x P_(n-1)(x)\n            // as per polynomial parity, we can store coefficients of both P_(n-1) and P_n in the same array\n            final double[] p = new double[order];\n            p[0] = 1;\n            final double x2  = x * x;\n            final double f   = 1.0 / (x2 - 1);\n            double coeff = FastMath.sqrt(f);\n            function[1] = coeff * p[0];\n            for (int n = 2; n <= order; ++n) {\n\n                // update and evaluate polynomial P_n(x)\n                double v = 0;\n                p[n - 1] = (1 - n) * p[n - 2];\n                for (int k = n - 1; k >= 0; k -= 2) {\n                    v = v * x2 + p[k];\n                    if (k > 2) {\n                        p[k - 2] = (1 - k) * p[k - 1] + (k - 2 * n) * p[k - 3];\n                    } else if (k == 2) {\n                        p[0] = -p[1];\n                    }\n                }\nif(((n == 0) && ((n ^<> 1) == 0))){\n                    v *= x;\n                }\n\n                coeff *= f;\n                function[n] = coeff * v;\n\n            }\n        }\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }",
          "75": "    public void acosh(final double[] operand, final int operandOffset,\n                     final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        double[] function = new double[1 + order];\n        final double x = operand[operandOffset];\n        function[0] = FastMath.acosh(x);\n        if (order > 0) {\n            // the nth order derivative of acosh has the form:\n            // dn(acosh(x)/dxn = P_n(x) / [x^2 - 1]^((2n-1)/2)\n            // where P_n(x) is a degree n-1 polynomial with same parity as n-1\n            // P_1(x) = 1, P_2(x) = -x, P_3(x) = 2x^2 + 1 ...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = (x^2-1) P_(n-1)'(x) - (2n-3) x P_(n-1)(x)\n            // as per polynomial parity, we can store coefficients of both P_(n-1) and P_n in the same array\n            final double[] p = new double[order];\n            p[0] = 1;\n            final double x2  = x * x;\n            final double f   = 1.0 / (x2 - 1);\n            double coeff = FastMath.sqrt(f);\n            function[1] = coeff * p[0];\n            for (int n = 2; n <= order; ++n) {\n\n                // update and evaluate polynomial P_n(x)\n                double v = 0;\n                p[n - 1] = (1 - n) * p[n - 2];\n                for (int k = n - 1; k >= 0; k -= 2) {\n                    v = v * x2 + p[k];\n                    if (k > 2) {\n                        p[k - 2] = (1 - k) * p[k - 1] + (k - 2 * n) * p[k - 3];\n                    } else if (k == 2) {\n                        p[0] = -p[1];\n                    }\n                }\nif(((n != 2) && ((n ^<> 1) == 0))){\n                    v *= x;\n                }\n\n                coeff *= f;\n                function[n] = coeff * v;\n\n            }\n        }\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }",
          "76": "    public void acosh(final double[] operand, final int operandOffset,\n                     final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        double[] function = new double[1 + order];\n        final double x = operand[operandOffset];\n        function[0] = FastMath.acosh(x);\n        if (order > 0) {\n            // the nth order derivative of acosh has the form:\n            // dn(acosh(x)/dxn = P_n(x) / [x^2 - 1]^((2n-1)/2)\n            // where P_n(x) is a degree n-1 polynomial with same parity as n-1\n            // P_1(x) = 1, P_2(x) = -x, P_3(x) = 2x^2 + 1 ...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = (x^2-1) P_(n-1)'(x) - (2n-3) x P_(n-1)(x)\n            // as per polynomial parity, we can store coefficients of both P_(n-1) and P_n in the same array\n            final double[] p = new double[order];\n            p[0] = 1;\n            final double x2  = x * x;\n            final double f   = 1.0 / (x2 - 1);\n            double coeff = FastMath.sqrt(f);\n            function[1] = coeff * p[0];\n            for (int n = 2; n <= order; ++n) {\n\n                // update and evaluate polynomial P_n(x)\n                double v = 0;\n                p[n - 1] = (1 - n) * p[n - 2];\n                for (int k = n - 1; k >= 0; k -= 2) {\n                    v = v * x2 + p[k];\n                    if (k > 2) {\n                        p[k - 2] = (1 - k) * p[k - 1] + (k - 2 * n) * p[k - 3];\n                    } else if (k == 2) {\n                        p[0] = -p[1];\n                    }\n                }\nif((((n ^<> 1) == 0) && (n != 0))){\n                    v *= x;\n                }\n\n                coeff *= f;\n                function[n] = coeff * v;\n\n            }\n        }\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }",
          "77": "    public void acosh(final double[] operand, final int operandOffset,\n                     final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        double[] function = new double[1 + order];\n        final double x = operand[operandOffset];\n        function[0] = FastMath.acosh(x);\n        if (order > 0) {\n            // the nth order derivative of acosh has the form:\n            // dn(acosh(x)/dxn = P_n(x) / [x^2 - 1]^((2n-1)/2)\n            // where P_n(x) is a degree n-1 polynomial with same parity as n-1\n            // P_1(x) = 1, P_2(x) = -x, P_3(x) = 2x^2 + 1 ...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = (x^2-1) P_(n-1)'(x) - (2n-3) x P_(n-1)(x)\n            // as per polynomial parity, we can store coefficients of both P_(n-1) and P_n in the same array\n            final double[] p = new double[order];\n            p[0] = 1;\n            final double x2  = x * x;\n            final double f   = 1.0 / (x2 - 1);\n            double coeff = FastMath.sqrt(f);\n            function[1] = coeff * p[0];\n            for (int n = 2; n <= order; ++n) {\n\n                // update and evaluate polynomial P_n(x)\n                double v = 0;\n                p[n - 1] = (1 - n) * p[n - 2];\n                for (int k = n - 1; k >= 0; k -= 2) {\n                    v = v * x2 + p[k];\n                    if (k > 2) {\n                        p[k - 2] = (1 - k) * p[k - 1] + (k - 2 * n) * p[k - 3];\n                    } else if (k == 2) {\n                        p[0] = -p[1];\n                    }\n                }\nif((((n ^<> 1) == 0) && (n == 2))){\n                    v *= x;\n                }\n\n                coeff *= f;\n                function[n] = coeff * v;\n\n            }\n        }\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }",
          "78": "    public void acosh(final double[] operand, final int operandOffset,\n                     final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        double[] function = new double[1 + order];\n        final double x = operand[operandOffset];\n        function[0] = FastMath.acosh(x);\n        if (order > 0) {\n            // the nth order derivative of acosh has the form:\n            // dn(acosh(x)/dxn = P_n(x) / [x^2 - 1]^((2n-1)/2)\n            // where P_n(x) is a degree n-1 polynomial with same parity as n-1\n            // P_1(x) = 1, P_2(x) = -x, P_3(x) = 2x^2 + 1 ...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = (x^2-1) P_(n-1)'(x) - (2n-3) x P_(n-1)(x)\n            // as per polynomial parity, we can store coefficients of both P_(n-1) and P_n in the same array\n            final double[] p = new double[order];\n            p[0] = 1;\n            final double x2  = x * x;\n            final double f   = 1.0 / (x2 - 1);\n            double coeff = FastMath.sqrt(f);\n            function[1] = coeff * p[0];\n            for (int n = 2; n <= order; ++n) {\n\n                // update and evaluate polynomial P_n(x)\n                double v = 0;\n                p[n - 1] = (1 - n) * p[n - 2];\n                for (int k = n - 1; k >= 0; k -= 2) {\n                    v = v * x2 + p[k];\n                    if (k > 2) {\n                        p[k - 2] = (1 - k) * p[k - 1] + (k - 2 * n) * p[k - 3];\n                    } else if (k == 2) {\n                        p[0] = -p[1];\n                    }\n                }\nif((((n ^<> 1) == 0) && (n == v))){\n                    v *= x;\n                }\n\n                coeff *= f;\n                function[n] = coeff * v;\n\n            }\n        }\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }",
          "79": "    public void acosh(final double[] operand, final int operandOffset,\n                     final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        double[] function = new double[1 + order];\n        final double x = operand[operandOffset];\n        function[0] = FastMath.acosh(x);\n        if (order > 0) {\n            // the nth order derivative of acosh has the form:\n            // dn(acosh(x)/dxn = P_n(x) / [x^2 - 1]^((2n-1)/2)\n            // where P_n(x) is a degree n-1 polynomial with same parity as n-1\n            // P_1(x) = 1, P_2(x) = -x, P_3(x) = 2x^2 + 1 ...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = (x^2-1) P_(n-1)'(x) - (2n-3) x P_(n-1)(x)\n            // as per polynomial parity, we can store coefficients of both P_(n-1) and P_n in the same array\n            final double[] p = new double[order];\n            p[0] = 1;\n            final double x2  = x * x;\n            final double f   = 1.0 / (x2 - 1);\n            double coeff = FastMath.sqrt(f);\n            function[1] = coeff * p[0];\n            for (int n = 2; n <= order; ++n) {\n\n                // update and evaluate polynomial P_n(x)\n                double v = 0;\n                p[n - 1] = (1 - n) * p[n - 2];\n                for (int k = n - 1; k >= 0; k -= 2) {\n                    v = v * x2 + p[k];\n                    if (k > 2) {\n                        p[k - 2] = (1 - k) * p[k - 1] + (k - 2 * n) * p[k - 3];\n                    } else if (k == 2) {\n                        p[0] = -p[1];\n                    }\n                }\nbreak;\n                    v *= x;\n                }\n\n                coeff *= f;\n                function[n] = coeff * v;\n\n            }\n        }\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }",
          "80": "    public void acosh(final double[] operand, final int operandOffset,\n                     final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        double[] function = new double[1 + order];\n        final double x = operand[operandOffset];\n        function[0] = FastMath.acosh(x);\n        if (order > 0) {\n            // the nth order derivative of acosh has the form:\n            // dn(acosh(x)/dxn = P_n(x) / [x^2 - 1]^((2n-1)/2)\n            // where P_n(x) is a degree n-1 polynomial with same parity as n-1\n            // P_1(x) = 1, P_2(x) = -x, P_3(x) = 2x^2 + 1 ...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = (x^2-1) P_(n-1)'(x) - (2n-3) x P_(n-1)(x)\n            // as per polynomial parity, we can store coefficients of both P_(n-1) and P_n in the same array\n            final double[] p = new double[order];\n            p[0] = 1;\n            final double x2  = x * x;\n            final double f   = 1.0 / (x2 - 1);\n            double coeff = FastMath.sqrt(f);\n            function[1] = coeff * p[0];\n            for (int n = 2; n <= order; ++n) {\n\n                // update and evaluate polynomial P_n(x)\n                double v = 0;\n                p[n - 1] = (1 - n) * p[n - 2];\n                for (int k = n - 1; k >= 0; k -= 2) {\n                    v = v * x2 + p[k];\n                    if (k > 2) {\n                        p[k - 2] = (1 - k) * p[k - 1] + (k - 2 * n) * p[k - 3];\n                    } else if (k == 2) {\n                        p[0] = -p[1];\n                    }\n                }\nif(((n != null) && ((n ^<> 1) == 0))){\n                    v *= x;\n                }\n\n                coeff *= f;\n                function[n] = coeff * v;\n\n            }\n        }\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }",
          "81": "    public void acosh(final double[] operand, final int operandOffset,\n                     final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        double[] function = new double[1 + order];\n        final double x = operand[operandOffset];\n        function[0] = FastMath.acosh(x);\n        if (order > 0) {\n            // the nth order derivative of acosh has the form:\n            // dn(acosh(x)/dxn = P_n(x) / [x^2 - 1]^((2n-1)/2)\n            // where P_n(x) is a degree n-1 polynomial with same parity as n-1\n            // P_1(x) = 1, P_2(x) = -x, P_3(x) = 2x^2 + 1 ...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = (x^2-1) P_(n-1)'(x) - (2n-3) x P_(n-1)(x)\n            // as per polynomial parity, we can store coefficients of both P_(n-1) and P_n in the same array\n            final double[] p = new double[order];\n            p[0] = 1;\n            final double x2  = x * x;\n            final double f   = 1.0 / (x2 - 1);\n            double coeff = FastMath.sqrt(f);\n            function[1] = coeff * p[0];\n            for (int n = 2; n <= order; ++n) {\n\n                // update and evaluate polynomial P_n(x)\n                double v = 0;\n                p[n - 1] = (1 - n) * p[n - 2];\n                for (int k = n - 1; k >= 0; k -= 2) {\n                    v = v * x2 + p[k];\n                    if (k > 2) {\n                        p[k - 2] = (1 - k) * p[k - 1] + (k - 2 * n) * p[k - 3];\n                    } else if (k == 2) {\n                        p[0] = -p[1];\n                    }\n                }\nif((((n ^<> 1) == 0) && (n != v))){\n                    v *= x;\n                }\n\n                coeff *= f;\n                function[n] = coeff * v;\n\n            }\n        }\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }",
          "82": "    public void acosh(final double[] operand, final int operandOffset,\n                     final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        double[] function = new double[1 + order];\n        final double x = operand[operandOffset];\n        function[0] = FastMath.acosh(x);\n        if (order > 0) {\n            // the nth order derivative of acosh has the form:\n            // dn(acosh(x)/dxn = P_n(x) / [x^2 - 1]^((2n-1)/2)\n            // where P_n(x) is a degree n-1 polynomial with same parity as n-1\n            // P_1(x) = 1, P_2(x) = -x, P_3(x) = 2x^2 + 1 ...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = (x^2-1) P_(n-1)'(x) - (2n-3) x P_(n-1)(x)\n            // as per polynomial parity, we can store coefficients of both P_(n-1) and P_n in the same array\n            final double[] p = new double[order];\n            p[0] = 1;\n            final double x2  = x * x;\n            final double f   = 1.0 / (x2 - 1);\n            double coeff = FastMath.sqrt(f);\n            function[1] = coeff * p[0];\n            for (int n = 2; n <= order; ++n) {\n\n                // update and evaluate polynomial P_n(x)\n                double v = 0;\n                p[n - 1] = (1 - n) * p[n - 2];\n                for (int k = n - 1; k >= 0; k -= 2) {\n                    v = v * x2 + p[k];\n                    if (k > 2) {\n                        p[k - 2] = (1 - k) * p[k - 1] + (k - 2 * n) * p[k - 3];\n                    } else if (k == 2) {\n                        p[0] = -p[1];\n                    }\n                }\nif((((n ^<> 1) == 0) && (n == null))){\n                    v *= x;\n                }\n\n                coeff *= f;\n                function[n] = coeff * v;\n\n            }\n        }\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }",
          "83": "    public void acosh(final double[] operand, final int operandOffset,\n                     final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        double[] function = new double[1 + order];\n        final double x = operand[operandOffset];\n        function[0] = FastMath.acosh(x);\n        if (order > 0) {\n            // the nth order derivative of acosh has the form:\n            // dn(acosh(x)/dxn = P_n(x) / [x^2 - 1]^((2n-1)/2)\n            // where P_n(x) is a degree n-1 polynomial with same parity as n-1\n            // P_1(x) = 1, P_2(x) = -x, P_3(x) = 2x^2 + 1 ...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = (x^2-1) P_(n-1)'(x) - (2n-3) x P_(n-1)(x)\n            // as per polynomial parity, we can store coefficients of both P_(n-1) and P_n in the same array\n            final double[] p = new double[order];\n            p[0] = 1;\n            final double x2  = x * x;\n            final double f   = 1.0 / (x2 - 1);\n            double coeff = FastMath.sqrt(f);\n            function[1] = coeff * p[0];\n            for (int n = 2; n <= order; ++n) {\n\n                // update and evaluate polynomial P_n(x)\n                double v = 0;\n                p[n - 1] = (1 - n) * p[n - 2];\n                for (int k = n - 1; k >= 0; k -= 2) {\n                    v = v * x2 + p[k];\n                    if (k > 2) {\n                        p[k - 2] = (1 - k) * p[k - 1] + (k - 2 * n) * p[k - 3];\n                    } else if (k == 2) {\n                        p[0] = -p[1];\n                    }\n                }\nif((((n ^<> 1) == 0) && (n != null))){\n                    v *= x;\n                }\n\n                coeff *= f;\n                function[n] = coeff * v;\n\n            }\n        }\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }",
          "84": "    public void acosh(final double[] operand, final int operandOffset,\n                     final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        double[] function = new double[1 + order];\n        final double x = operand[operandOffset];\n        function[0] = FastMath.acosh(x);\n        if (order > 0) {\n            // the nth order derivative of acosh has the form:\n            // dn(acosh(x)/dxn = P_n(x) / [x^2 - 1]^((2n-1)/2)\n            // where P_n(x) is a degree n-1 polynomial with same parity as n-1\n            // P_1(x) = 1, P_2(x) = -x, P_3(x) = 2x^2 + 1 ...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = (x^2-1) P_(n-1)'(x) - (2n-3) x P_(n-1)(x)\n            // as per polynomial parity, we can store coefficients of both P_(n-1) and P_n in the same array\n            final double[] p = new double[order];\n            p[0] = 1;\n            final double x2  = x * x;\n            final double f   = 1.0 / (x2 - 1);\n            double coeff = FastMath.sqrt(f);\n            function[1] = coeff * p[0];\n            for (int n = 2; n <= order; ++n) {\n\n                // update and evaluate polynomial P_n(x)\n                double v = 0;\n                p[n - 1] = (1 - n) * p[n - 2];\n                for (int k = n - 1; k >= 0; k -= 2) {\n                    v = v * x2 + p[k];\n                    if (k > 2) {\n                        p[k - 2] = (1 - k) * p[k - 1] + (k - 2 * n) * p[k - 3];\n                    } else if (k == 2) {\n                        p[0] = -p[1];\n                    }\n                }\nif((((n ^<> 1) == 0) && (n == n))){\n                    v *= x;\n                }\n\n                coeff *= f;\n                function[n] = coeff * v;\n\n            }\n        }\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }",
          "85": "    public void acosh(final double[] operand, final int operandOffset,\n                     final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        double[] function = new double[1 + order];\n        final double x = operand[operandOffset];\n        function[0] = FastMath.acosh(x);\n        if (order > 0) {\n            // the nth order derivative of acosh has the form:\n            // dn(acosh(x)/dxn = P_n(x) / [x^2 - 1]^((2n-1)/2)\n            // where P_n(x) is a degree n-1 polynomial with same parity as n-1\n            // P_1(x) = 1, P_2(x) = -x, P_3(x) = 2x^2 + 1 ...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = (x^2-1) P_(n-1)'(x) - (2n-3) x P_(n-1)(x)\n            // as per polynomial parity, we can store coefficients of both P_(n-1) and P_n in the same array\n            final double[] p = new double[order];\n            p[0] = 1;\n            final double x2  = x * x;\n            final double f   = 1.0 / (x2 - 1);\n            double coeff = FastMath.sqrt(f);\n            function[1] = coeff * p[0];\n            for (int n = 2; n <= order; ++n) {\n\n                // update and evaluate polynomial P_n(x)\n                double v = 0;\n                p[n - 1] = (1 - n) * p[n - 2];\n                for (int k = n - 1; k >= 0; k -= 2) {\n                    v = v * x2 + p[k];\n                    if (k > 2) {\n                        p[k - 2] = (1 - k) * p[k - 1] + (k - 2 * n) * p[k - 3];\n                    } else if (k == 2) {\n                        p[0] = -p[1];\n                    }\n                }\nif((((n ^<> 1) == 0) && (n < n))){\n                    v *= x;\n                }\n\n                coeff *= f;\n                function[n] = coeff * v;\n\n            }\n        }\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }",
          "86": "    public void acosh(final double[] operand, final int operandOffset,\n                     final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        double[] function = new double[1 + order];\n        final double x = operand[operandOffset];\n        function[0] = FastMath.acosh(x);\n        if (order > 0) {\n            // the nth order derivative of acosh has the form:\n            // dn(acosh(x)/dxn = P_n(x) / [x^2 - 1]^((2n-1)/2)\n            // where P_n(x) is a degree n-1 polynomial with same parity as n-1\n            // P_1(x) = 1, P_2(x) = -x, P_3(x) = 2x^2 + 1 ...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = (x^2-1) P_(n-1)'(x) - (2n-3) x P_(n-1)(x)\n            // as per polynomial parity, we can store coefficients of both P_(n-1) and P_n in the same array\n            final double[] p = new double[order];\n            p[0] = 1;\n            final double x2  = x * x;\n            final double f   = 1.0 / (x2 - 1);\n            double coeff = FastMath.sqrt(f);\n            function[1] = coeff * p[0];\n            for (int n = 2; n <= order; ++n) {\n\n                // update and evaluate polynomial P_n(x)\n                double v = 0;\n                p[n - 1] = (1 - n) * p[n - 2];\n                for (int k = n - 1; k >= 0; k -= 2) {\n                    v = v * x2 + p[k];\n                    if (k > 2) {\n                        p[k - 2] = (1 - k) * p[k - 1] + (k - 2 * n) * p[k - 3];\n                    } else if (k == 2) {\n                        p[0] = -p[1];\n                    }\n                }\nif((((n ^<> 1) == 0) && (n < v))){\n                    v *= x;\n                }\n\n                coeff *= f;\n                function[n] = coeff * v;\n\n            }\n        }\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }"
}