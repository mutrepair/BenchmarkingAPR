{
          "0": "    public static double asin(double x) {\n      if (x != x) {\n          return Double.NaN;\n      }\n\nif(((x > 1.0) || (x < +1.0))){          return Double.NaN;\n      }\n\n      if (x == 1.0) {\n          return Math.PI/2.0;\n      }\n\n      if (x == -1.0) {\n          return -Math.PI/2.0;\n      }\n\n      if (x == 0.0) { // Matches +/- 0.0; return correct sign\n          return x;\n      }\n\n      /* Compute asin(x) = atan(x/sqrt(1-x*x)) */\n\n      /* Split x */\n      double temp = x * HEX_40000000;\n      final double xa = x + temp - temp;\n      final double xb = x - xa;\n\n      /* Square it */\n      double ya = xa*xa;\n      double yb = xa*xb*2.0 + xb*xb;\n\n      /* Subtract from 1 */\n      ya = -ya;\n      yb = -yb;\n\n      double za = 1.0 + ya;\n      double zb = -(za - 1.0 - ya);\n\n      temp = za + yb;\n      zb += -(temp - za - yb);\n      za = temp;\n\n      /* Square root */\n      double y;\n      y = sqrt(za);\n      temp = y * HEX_40000000;\n      ya = y + temp - temp;\n      yb = y - ya;\n\n      /* Extend precision of sqrt */\n      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      /* Contribution of zb to sqrt */\n      double dx = zb / (2.0*y);\n\n      // Compute ratio r = x/y\n      double r = x/y;\n      temp = r * HEX_40000000;\n      double ra = r + temp - temp;\n      double rb = r - ra;\n\n      rb += (x - ra*ya - ra*yb - rb*ya - rb*yb) / y;  // Correct for rounding in division\n      rb += -x * dx / y / y;  // Add in effect additional bits of sqrt.\n\n      temp = ra + rb;\n      rb = -(temp - ra - rb);\n      ra = temp;\n\n      return atan(ra, rb, false);\n    }",
          "1": "    public static double asin(double x) {\n      if (x != x) {\n          return Double.NaN;\n      }\n\nif((x < +1.0)){\n          return Double.NaN;\n      }\n\n      if (x == 1.0) {\n          return Math.PI/2.0;\n      }\n\n      if (x == -1.0) {\n          return -Math.PI/2.0;\n      }\n\n      if (x == 0.0) { // Matches +/- 0.0; return correct sign\n          return x;\n      }\n\n      /* Compute asin(x) = atan(x/sqrt(1-x*x)) */\n\n      /* Split x */\n      double temp = x * HEX_40000000;\n      final double xa = x + temp - temp;\n      final double xb = x - xa;\n\n      /* Square it */\n      double ya = xa*xa;\n      double yb = xa*xb*2.0 + xb*xb;\n\n      /* Subtract from 1 */\n      ya = -ya;\n      yb = -yb;\n\n      double za = 1.0 + ya;\n      double zb = -(za - 1.0 - ya);\n\n      temp = za + yb;\n      zb += -(temp - za - yb);\n      za = temp;\n\n      /* Square root */\n      double y;\n      y = sqrt(za);\n      temp = y * HEX_40000000;\n      ya = y + temp - temp;\n      yb = y - ya;\n\n      /* Extend precision of sqrt */\n      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      /* Contribution of zb to sqrt */\n      double dx = zb / (2.0*y);\n\n      // Compute ratio r = x/y\n      double r = x/y;\n      temp = r * HEX_40000000;\n      double ra = r + temp - temp;\n      double rb = r - ra;\n\n      rb += (x - ra*ya - ra*yb - rb*ya - rb*yb) / y;  // Correct for rounding in division\n      rb += -x * dx / y / y;  // Add in effect additional bits of sqrt.\n\n      temp = ra + rb;\n      rb = -(temp - ra - rb);\n      ra = temp;\n\n      return atan(ra, rb, false);\n    }",
          "2": "    public static double asin(double x) {\n      if (x != x) {\n          return Double.NaN;\n      }\n\nif((x > 1.0)){\n          return Double.NaN;\n      }\n\n      if (x == 1.0) {\n          return Math.PI/2.0;\n      }\n\n      if (x == -1.0) {\n          return -Math.PI/2.0;\n      }\n\n      if (x == 0.0) { // Matches +/- 0.0; return correct sign\n          return x;\n      }\n\n      /* Compute asin(x) = atan(x/sqrt(1-x*x)) */\n\n      /* Split x */\n      double temp = x * HEX_40000000;\n      final double xa = x + temp - temp;\n      final double xb = x - xa;\n\n      /* Square it */\n      double ya = xa*xa;\n      double yb = xa*xb*2.0 + xb*xb;\n\n      /* Subtract from 1 */\n      ya = -ya;\n      yb = -yb;\n\n      double za = 1.0 + ya;\n      double zb = -(za - 1.0 - ya);\n\n      temp = za + yb;\n      zb += -(temp - za - yb);\n      za = temp;\n\n      /* Square root */\n      double y;\n      y = sqrt(za);\n      temp = y * HEX_40000000;\n      ya = y + temp - temp;\n      yb = y - ya;\n\n      /* Extend precision of sqrt */\n      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      /* Contribution of zb to sqrt */\n      double dx = zb / (2.0*y);\n\n      // Compute ratio r = x/y\n      double r = x/y;\n      temp = r * HEX_40000000;\n      double ra = r + temp - temp;\n      double rb = r - ra;\n\n      rb += (x - ra*ya - ra*yb - rb*ya - rb*yb) / y;  // Correct for rounding in division\n      rb += -x * dx / y / y;  // Add in effect additional bits of sqrt.\n\n      temp = ra + rb;\n      rb = -(temp - ra - rb);\n      ra = temp;\n\n      return atan(ra, rb, false);\n    }",
          "3": "    public static double asin(double x) {\n      if (x != x) {\n          return Double.NaN;\n      }\n\nif(((x > 1.0) && (x < +1.0))){          return Double.NaN;\n      }\n\n      if (x == 1.0) {\n          return Math.PI/2.0;\n      }\n\n      if (x == -1.0) {\n          return -Math.PI/2.0;\n      }\n\n      if (x == 0.0) { // Matches +/- 0.0; return correct sign\n          return x;\n      }\n\n      /* Compute asin(x) = atan(x/sqrt(1-x*x)) */\n\n      /* Split x */\n      double temp = x * HEX_40000000;\n      final double xa = x + temp - temp;\n      final double xb = x - xa;\n\n      /* Square it */\n      double ya = xa*xa;\n      double yb = xa*xb*2.0 + xb*xb;\n\n      /* Subtract from 1 */\n      ya = -ya;\n      yb = -yb;\n\n      double za = 1.0 + ya;\n      double zb = -(za - 1.0 - ya);\n\n      temp = za + yb;\n      zb += -(temp - za - yb);\n      za = temp;\n\n      /* Square root */\n      double y;\n      y = sqrt(za);\n      temp = y * HEX_40000000;\n      ya = y + temp - temp;\n      yb = y - ya;\n\n      /* Extend precision of sqrt */\n      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      /* Contribution of zb to sqrt */\n      double dx = zb / (2.0*y);\n\n      // Compute ratio r = x/y\n      double r = x/y;\n      temp = r * HEX_40000000;\n      double ra = r + temp - temp;\n      double rb = r - ra;\n\n      rb += (x - ra*ya - ra*yb - rb*ya - rb*yb) / y;  // Correct for rounding in division\n      rb += -x * dx / y / y;  // Add in effect additional bits of sqrt.\n\n      temp = ra + rb;\n      rb = -(temp - ra - rb);\n      ra = temp;\n\n      return atan(ra, rb, false);\n    }",
          "4": "    public static double asin(double x) {\n      if (x != x) {\n          return Double.NaN;\n      }\n\nif(((x > 1.0) || (x >= +1.0))){          return Double.NaN;\n      }\n\n      if (x == 1.0) {\n          return Math.PI/2.0;\n      }\n\n      if (x == -1.0) {\n          return -Math.PI/2.0;\n      }\n\n      if (x == 0.0) { // Matches +/- 0.0; return correct sign\n          return x;\n      }\n\n      /* Compute asin(x) = atan(x/sqrt(1-x*x)) */\n\n      /* Split x */\n      double temp = x * HEX_40000000;\n      final double xa = x + temp - temp;\n      final double xb = x - xa;\n\n      /* Square it */\n      double ya = xa*xa;\n      double yb = xa*xb*2.0 + xb*xb;\n\n      /* Subtract from 1 */\n      ya = -ya;\n      yb = -yb;\n\n      double za = 1.0 + ya;\n      double zb = -(za - 1.0 - ya);\n\n      temp = za + yb;\n      zb += -(temp - za - yb);\n      za = temp;\n\n      /* Square root */\n      double y;\n      y = sqrt(za);\n      temp = y * HEX_40000000;\n      ya = y + temp - temp;\n      yb = y - ya;\n\n      /* Extend precision of sqrt */\n      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      /* Contribution of zb to sqrt */\n      double dx = zb / (2.0*y);\n\n      // Compute ratio r = x/y\n      double r = x/y;\n      temp = r * HEX_40000000;\n      double ra = r + temp - temp;\n      double rb = r - ra;\n\n      rb += (x - ra*ya - ra*yb - rb*ya - rb*yb) / y;  // Correct for rounding in division\n      rb += -x * dx / y / y;  // Add in effect additional bits of sqrt.\n\n      temp = ra + rb;\n      rb = -(temp - ra - rb);\n      ra = temp;\n\n      return atan(ra, rb, false);\n    }",
          "5": "    public static double asin(double x) {\n      if (x != x) {\n          return Double.NaN;\n      }\n\nif(((x > 1.0) || (x <= +1.0))){          return Double.NaN;\n      }\n\n      if (x == 1.0) {\n          return Math.PI/2.0;\n      }\n\n      if (x == -1.0) {\n          return -Math.PI/2.0;\n      }\n\n      if (x == 0.0) { // Matches +/- 0.0; return correct sign\n          return x;\n      }\n\n      /* Compute asin(x) = atan(x/sqrt(1-x*x)) */\n\n      /* Split x */\n      double temp = x * HEX_40000000;\n      final double xa = x + temp - temp;\n      final double xb = x - xa;\n\n      /* Square it */\n      double ya = xa*xa;\n      double yb = xa*xb*2.0 + xb*xb;\n\n      /* Subtract from 1 */\n      ya = -ya;\n      yb = -yb;\n\n      double za = 1.0 + ya;\n      double zb = -(za - 1.0 - ya);\n\n      temp = za + yb;\n      zb += -(temp - za - yb);\n      za = temp;\n\n      /* Square root */\n      double y;\n      y = sqrt(za);\n      temp = y * HEX_40000000;\n      ya = y + temp - temp;\n      yb = y - ya;\n\n      /* Extend precision of sqrt */\n      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      /* Contribution of zb to sqrt */\n      double dx = zb / (2.0*y);\n\n      // Compute ratio r = x/y\n      double r = x/y;\n      temp = r * HEX_40000000;\n      double ra = r + temp - temp;\n      double rb = r - ra;\n\n      rb += (x - ra*ya - ra*yb - rb*ya - rb*yb) / y;  // Correct for rounding in division\n      rb += -x * dx / y / y;  // Add in effect additional bits of sqrt.\n\n      temp = ra + rb;\n      rb = -(temp - ra - rb);\n      ra = temp;\n\n      return atan(ra, rb, false);\n    }",
          "6": "    public static double asin(double x) {\n      if (x != x) {\n          return Double.NaN;\n      }\n\nif(((x > 1.0) || (x > +1.0))){          return Double.NaN;\n      }\n\n      if (x == 1.0) {\n          return Math.PI/2.0;\n      }\n\n      if (x == -1.0) {\n          return -Math.PI/2.0;\n      }\n\n      if (x == 0.0) { // Matches +/- 0.0; return correct sign\n          return x;\n      }\n\n      /* Compute asin(x) = atan(x/sqrt(1-x*x)) */\n\n      /* Split x */\n      double temp = x * HEX_40000000;\n      final double xa = x + temp - temp;\n      final double xb = x - xa;\n\n      /* Square it */\n      double ya = xa*xa;\n      double yb = xa*xb*2.0 + xb*xb;\n\n      /* Subtract from 1 */\n      ya = -ya;\n      yb = -yb;\n\n      double za = 1.0 + ya;\n      double zb = -(za - 1.0 - ya);\n\n      temp = za + yb;\n      zb += -(temp - za - yb);\n      za = temp;\n\n      /* Square root */\n      double y;\n      y = sqrt(za);\n      temp = y * HEX_40000000;\n      ya = y + temp - temp;\n      yb = y - ya;\n\n      /* Extend precision of sqrt */\n      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      /* Contribution of zb to sqrt */\n      double dx = zb / (2.0*y);\n\n      // Compute ratio r = x/y\n      double r = x/y;\n      temp = r * HEX_40000000;\n      double ra = r + temp - temp;\n      double rb = r - ra;\n\n      rb += (x - ra*ya - ra*yb - rb*ya - rb*yb) / y;  // Correct for rounding in division\n      rb += -x * dx / y / y;  // Add in effect additional bits of sqrt.\n\n      temp = ra + rb;\n      rb = -(temp - ra - rb);\n      ra = temp;\n\n      return atan(ra, rb, false);\n    }",
          "7": "    public static double asin(double x) {\n      if (x != x) {\n          return Double.NaN;\n      }\n\nif(((x > 1.0) || (x < +1.0))){\n          return Double.NaN;\n      }\n\n      if (x == 1.0) {\n          return Math.PI/2.0;\n      }\n\n      if (x == -1.0) {\n          return -Math.PI/2.0;\n      }\n\n      if (x == 0.0) { // Matches +/- 0.0; return correct sign\n          return x;\n      }\n\n      /* Compute asin(x) = atan(x/sqrt(1-x*x)) */\n\n      /* Split x */\n      double temp = x * HEX_40000000;\n      final double xa = x + temp - temp;\n      final double xb = x - xa;\n\n      /* Square it */\n      double ya = xa*xa;\n      double yb = xa*xb*2.0 + xb*xb;\n\n      /* Subtract from 1 */\n      ya = -ya;\n      yb = -yb;\n\n      double za = 1.0 + ya;\n      double zb = -(za - 1.0 - ya);\n\n      temp = za + yb;\n      zb += -(temp - za - yb);\n      za = temp;\n\n      /* Square root */\n      double y;\n      y = sqrt(za);\n      temp = y * HEX_40000000;\n      ya = y + temp - temp;\n      yb = y - ya;\n\n      /* Extend precision of sqrt */\n      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      /* Contribution of zb to sqrt */\n      double dx = zb / (2.0*y);\n\n      // Compute ratio r = x/y\n      double r = x/y;\n      temp = r * HEX_40000000;\n      double ra = r + temp - temp;\n      double rb = r - ra;\n\n      rb += (x - ra*ya - ra*yb - rb*ya - rb*yb) / y;  // Correct for rounding in division\n      rb += -x * dx / y / y;  // Add in effect additional bits of sqrt.\n\n      temp = ra + rb;\n      rb = -(temp - ra - rb);\n      ra = temp;\n\n      return atan(ra, rb, false);\n    }",
          "8": "    public static double asin(double x) {\n      if (x != x) {\n          return Double.NaN;\n      }\n\nif(((x >= 1.0) || (x < +1.0))){          return Double.NaN;\n      }\n\n      if (x == 1.0) {\n          return Math.PI/2.0;\n      }\n\n      if (x == -1.0) {\n          return -Math.PI/2.0;\n      }\n\n      if (x == 0.0) { // Matches +/- 0.0; return correct sign\n          return x;\n      }\n\n      /* Compute asin(x) = atan(x/sqrt(1-x*x)) */\n\n      /* Split x */\n      double temp = x * HEX_40000000;\n      final double xa = x + temp - temp;\n      final double xb = x - xa;\n\n      /* Square it */\n      double ya = xa*xa;\n      double yb = xa*xb*2.0 + xb*xb;\n\n      /* Subtract from 1 */\n      ya = -ya;\n      yb = -yb;\n\n      double za = 1.0 + ya;\n      double zb = -(za - 1.0 - ya);\n\n      temp = za + yb;\n      zb += -(temp - za - yb);\n      za = temp;\n\n      /* Square root */\n      double y;\n      y = sqrt(za);\n      temp = y * HEX_40000000;\n      ya = y + temp - temp;\n      yb = y - ya;\n\n      /* Extend precision of sqrt */\n      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      /* Contribution of zb to sqrt */\n      double dx = zb / (2.0*y);\n\n      // Compute ratio r = x/y\n      double r = x/y;\n      temp = r * HEX_40000000;\n      double ra = r + temp - temp;\n      double rb = r - ra;\n\n      rb += (x - ra*ya - ra*yb - rb*ya - rb*yb) / y;  // Correct for rounding in division\n      rb += -x * dx / y / y;  // Add in effect additional bits of sqrt.\n\n      temp = ra + rb;\n      rb = -(temp - ra - rb);\n      ra = temp;\n\n      return atan(ra, rb, false);\n    }",
          "9": "    public static double asin(double x) {\n      if (x != x) {\n          return Double.NaN;\n      }\n\nif(((x <= 1.0) || (x < +1.0))){          return Double.NaN;\n      }\n\n      if (x == 1.0) {\n          return Math.PI/2.0;\n      }\n\n      if (x == -1.0) {\n          return -Math.PI/2.0;\n      }\n\n      if (x == 0.0) { // Matches +/- 0.0; return correct sign\n          return x;\n      }\n\n      /* Compute asin(x) = atan(x/sqrt(1-x*x)) */\n\n      /* Split x */\n      double temp = x * HEX_40000000;\n      final double xa = x + temp - temp;\n      final double xb = x - xa;\n\n      /* Square it */\n      double ya = xa*xa;\n      double yb = xa*xb*2.0 + xb*xb;\n\n      /* Subtract from 1 */\n      ya = -ya;\n      yb = -yb;\n\n      double za = 1.0 + ya;\n      double zb = -(za - 1.0 - ya);\n\n      temp = za + yb;\n      zb += -(temp - za - yb);\n      za = temp;\n\n      /* Square root */\n      double y;\n      y = sqrt(za);\n      temp = y * HEX_40000000;\n      ya = y + temp - temp;\n      yb = y - ya;\n\n      /* Extend precision of sqrt */\n      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      /* Contribution of zb to sqrt */\n      double dx = zb / (2.0*y);\n\n      // Compute ratio r = x/y\n      double r = x/y;\n      temp = r * HEX_40000000;\n      double ra = r + temp - temp;\n      double rb = r - ra;\n\n      rb += (x - ra*ya - ra*yb - rb*ya - rb*yb) / y;  // Correct for rounding in division\n      rb += -x * dx / y / y;  // Add in effect additional bits of sqrt.\n\n      temp = ra + rb;\n      rb = -(temp - ra - rb);\n      ra = temp;\n\n      return atan(ra, rb, false);\n    }",
          "10": "    public static double asin(double x) {\n      if (x != x) {\n          return Double.NaN;\n      }\n\nif(((x > 1.0) || (x == +1.0))){          return Double.NaN;\n      }\n\n      if (x == 1.0) {\n          return Math.PI/2.0;\n      }\n\n      if (x == -1.0) {\n          return -Math.PI/2.0;\n      }\n\n      if (x == 0.0) { // Matches +/- 0.0; return correct sign\n          return x;\n      }\n\n      /* Compute asin(x) = atan(x/sqrt(1-x*x)) */\n\n      /* Split x */\n      double temp = x * HEX_40000000;\n      final double xa = x + temp - temp;\n      final double xb = x - xa;\n\n      /* Square it */\n      double ya = xa*xa;\n      double yb = xa*xb*2.0 + xb*xb;\n\n      /* Subtract from 1 */\n      ya = -ya;\n      yb = -yb;\n\n      double za = 1.0 + ya;\n      double zb = -(za - 1.0 - ya);\n\n      temp = za + yb;\n      zb += -(temp - za - yb);\n      za = temp;\n\n      /* Square root */\n      double y;\n      y = sqrt(za);\n      temp = y * HEX_40000000;\n      ya = y + temp - temp;\n      yb = y - ya;\n\n      /* Extend precision of sqrt */\n      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      /* Contribution of zb to sqrt */\n      double dx = zb / (2.0*y);\n\n      // Compute ratio r = x/y\n      double r = x/y;\n      temp = r * HEX_40000000;\n      double ra = r + temp - temp;\n      double rb = r - ra;\n\n      rb += (x - ra*ya - ra*yb - rb*ya - rb*yb) / y;  // Correct for rounding in division\n      rb += -x * dx / y / y;  // Add in effect additional bits of sqrt.\n\n      temp = ra + rb;\n      rb = -(temp - ra - rb);\n      ra = temp;\n\n      return atan(ra, rb, false);\n    }",
          "11": "    public static double asin(double x) {\n      if (x != x) {\n          return Double.NaN;\n      }\n\nif(((x < 1.0) || (x < +1.0))){          return Double.NaN;\n      }\n\n      if (x == 1.0) {\n          return Math.PI/2.0;\n      }\n\n      if (x == -1.0) {\n          return -Math.PI/2.0;\n      }\n\n      if (x == 0.0) { // Matches +/- 0.0; return correct sign\n          return x;\n      }\n\n      /* Compute asin(x) = atan(x/sqrt(1-x*x)) */\n\n      /* Split x */\n      double temp = x * HEX_40000000;\n      final double xa = x + temp - temp;\n      final double xb = x - xa;\n\n      /* Square it */\n      double ya = xa*xa;\n      double yb = xa*xb*2.0 + xb*xb;\n\n      /* Subtract from 1 */\n      ya = -ya;\n      yb = -yb;\n\n      double za = 1.0 + ya;\n      double zb = -(za - 1.0 - ya);\n\n      temp = za + yb;\n      zb += -(temp - za - yb);\n      za = temp;\n\n      /* Square root */\n      double y;\n      y = sqrt(za);\n      temp = y * HEX_40000000;\n      ya = y + temp - temp;\n      yb = y - ya;\n\n      /* Extend precision of sqrt */\n      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      /* Contribution of zb to sqrt */\n      double dx = zb / (2.0*y);\n\n      // Compute ratio r = x/y\n      double r = x/y;\n      temp = r * HEX_40000000;\n      double ra = r + temp - temp;\n      double rb = r - ra;\n\n      rb += (x - ra*ya - ra*yb - rb*ya - rb*yb) / y;  // Correct for rounding in division\n      rb += -x * dx / y / y;  // Add in effect additional bits of sqrt.\n\n      temp = ra + rb;\n      rb = -(temp - ra - rb);\n      ra = temp;\n\n      return atan(ra, rb, false);\n    }",
          "12": "    public static double asin(double x) {\n      if (x != x) {\n          return Double.NaN;\n      }\n\nif(((x == 1.0) || (x < +1.0))){          return Double.NaN;\n      }\n\n      if (x == 1.0) {\n          return Math.PI/2.0;\n      }\n\n      if (x == -1.0) {\n          return -Math.PI/2.0;\n      }\n\n      if (x == 0.0) { // Matches +/- 0.0; return correct sign\n          return x;\n      }\n\n      /* Compute asin(x) = atan(x/sqrt(1-x*x)) */\n\n      /* Split x */\n      double temp = x * HEX_40000000;\n      final double xa = x + temp - temp;\n      final double xb = x - xa;\n\n      /* Square it */\n      double ya = xa*xa;\n      double yb = xa*xb*2.0 + xb*xb;\n\n      /* Subtract from 1 */\n      ya = -ya;\n      yb = -yb;\n\n      double za = 1.0 + ya;\n      double zb = -(za - 1.0 - ya);\n\n      temp = za + yb;\n      zb += -(temp - za - yb);\n      za = temp;\n\n      /* Square root */\n      double y;\n      y = sqrt(za);\n      temp = y * HEX_40000000;\n      ya = y + temp - temp;\n      yb = y - ya;\n\n      /* Extend precision of sqrt */\n      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      /* Contribution of zb to sqrt */\n      double dx = zb / (2.0*y);\n\n      // Compute ratio r = x/y\n      double r = x/y;\n      temp = r * HEX_40000000;\n      double ra = r + temp - temp;\n      double rb = r - ra;\n\n      rb += (x - ra*ya - ra*yb - rb*ya - rb*yb) / y;  // Correct for rounding in division\n      rb += -x * dx / y / y;  // Add in effect additional bits of sqrt.\n\n      temp = ra + rb;\n      rb = -(temp - ra - rb);\n      ra = temp;\n\n      return atan(ra, rb, false);\n    }",
          "13": "    public static double asin(double x) {\n      if (x != x) {\n          return Double.NaN;\n      }\n\nif(((x > 1.0) || (x != +1.0))){          return Double.NaN;\n      }\n\n      if (x == 1.0) {\n          return Math.PI/2.0;\n      }\n\n      if (x == -1.0) {\n          return -Math.PI/2.0;\n      }\n\n      if (x == 0.0) { // Matches +/- 0.0; return correct sign\n          return x;\n      }\n\n      /* Compute asin(x) = atan(x/sqrt(1-x*x)) */\n\n      /* Split x */\n      double temp = x * HEX_40000000;\n      final double xa = x + temp - temp;\n      final double xb = x - xa;\n\n      /* Square it */\n      double ya = xa*xa;\n      double yb = xa*xb*2.0 + xb*xb;\n\n      /* Subtract from 1 */\n      ya = -ya;\n      yb = -yb;\n\n      double za = 1.0 + ya;\n      double zb = -(za - 1.0 - ya);\n\n      temp = za + yb;\n      zb += -(temp - za - yb);\n      za = temp;\n\n      /* Square root */\n      double y;\n      y = sqrt(za);\n      temp = y * HEX_40000000;\n      ya = y + temp - temp;\n      yb = y - ya;\n\n      /* Extend precision of sqrt */\n      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      /* Contribution of zb to sqrt */\n      double dx = zb / (2.0*y);\n\n      // Compute ratio r = x/y\n      double r = x/y;\n      temp = r * HEX_40000000;\n      double ra = r + temp - temp;\n      double rb = r - ra;\n\n      rb += (x - ra*ya - ra*yb - rb*ya - rb*yb) / y;  // Correct for rounding in division\n      rb += -x * dx / y / y;  // Add in effect additional bits of sqrt.\n\n      temp = ra + rb;\n      rb = -(temp - ra - rb);\n      ra = temp;\n\n      return atan(ra, rb, false);\n    }",
          "14": "    public static double asin(double x) {\n      if (x != x) {\n          return Double.NaN;\n      }\n\nif(((x > 1.0) && (x < +1.0))){\n          return Double.NaN;\n      }\n\n      if (x == 1.0) {\n          return Math.PI/2.0;\n      }\n\n      if (x == -1.0) {\n          return -Math.PI/2.0;\n      }\n\n      if (x == 0.0) { // Matches +/- 0.0; return correct sign\n          return x;\n      }\n\n      /* Compute asin(x) = atan(x/sqrt(1-x*x)) */\n\n      /* Split x */\n      double temp = x * HEX_40000000;\n      final double xa = x + temp - temp;\n      final double xb = x - xa;\n\n      /* Square it */\n      double ya = xa*xa;\n      double yb = xa*xb*2.0 + xb*xb;\n\n      /* Subtract from 1 */\n      ya = -ya;\n      yb = -yb;\n\n      double za = 1.0 + ya;\n      double zb = -(za - 1.0 - ya);\n\n      temp = za + yb;\n      zb += -(temp - za - yb);\n      za = temp;\n\n      /* Square root */\n      double y;\n      y = sqrt(za);\n      temp = y * HEX_40000000;\n      ya = y + temp - temp;\n      yb = y - ya;\n\n      /* Extend precision of sqrt */\n      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      /* Contribution of zb to sqrt */\n      double dx = zb / (2.0*y);\n\n      // Compute ratio r = x/y\n      double r = x/y;\n      temp = r * HEX_40000000;\n      double ra = r + temp - temp;\n      double rb = r - ra;\n\n      rb += (x - ra*ya - ra*yb - rb*ya - rb*yb) / y;  // Correct for rounding in division\n      rb += -x * dx / y / y;  // Add in effect additional bits of sqrt.\n\n      temp = ra + rb;\n      rb = -(temp - ra - rb);\n      ra = temp;\n\n      return atan(ra, rb, false);\n    }",
          "15": "    public static double asin(double x) {\n      if (x != x) {\n          return Double.NaN;\n      }\n\nif(x){\n          return Double.NaN;\n      }\n\n      if (x == 1.0) {\n          return Math.PI/2.0;\n      }\n\n      if (x == -1.0) {\n          return -Math.PI/2.0;\n      }\n\n      if (x == 0.0) { // Matches +/- 0.0; return correct sign\n          return x;\n      }\n\n      /* Compute asin(x) = atan(x/sqrt(1-x*x)) */\n\n      /* Split x */\n      double temp = x * HEX_40000000;\n      final double xa = x + temp - temp;\n      final double xb = x - xa;\n\n      /* Square it */\n      double ya = xa*xa;\n      double yb = xa*xb*2.0 + xb*xb;\n\n      /* Subtract from 1 */\n      ya = -ya;\n      yb = -yb;\n\n      double za = 1.0 + ya;\n      double zb = -(za - 1.0 - ya);\n\n      temp = za + yb;\n      zb += -(temp - za - yb);\n      za = temp;\n\n      /* Square root */\n      double y;\n      y = sqrt(za);\n      temp = y * HEX_40000000;\n      ya = y + temp - temp;\n      yb = y - ya;\n\n      /* Extend precision of sqrt */\n      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      /* Contribution of zb to sqrt */\n      double dx = zb / (2.0*y);\n\n      // Compute ratio r = x/y\n      double r = x/y;\n      temp = r * HEX_40000000;\n      double ra = r + temp - temp;\n      double rb = r - ra;\n\n      rb += (x - ra*ya - ra*yb - rb*ya - rb*yb) / y;  // Correct for rounding in division\n      rb += -x * dx / y / y;  // Add in effect additional bits of sqrt.\n\n      temp = ra + rb;\n      rb = -(temp - ra - rb);\n      ra = temp;\n\n      return atan(ra, rb, false);\n    }",
          "16": "    public static double asin(double x) {\n      if (x != x) {\n          return Double.NaN;\n      }\n\nif(((x > 1.0) || (x - +1.0))){          return Double.NaN;\n      }\n\n      if (x == 1.0) {\n          return Math.PI/2.0;\n      }\n\n      if (x == -1.0) {\n          return -Math.PI/2.0;\n      }\n\n      if (x == 0.0) { // Matches +/- 0.0; return correct sign\n          return x;\n      }\n\n      /* Compute asin(x) = atan(x/sqrt(1-x*x)) */\n\n      /* Split x */\n      double temp = x * HEX_40000000;\n      final double xa = x + temp - temp;\n      final double xb = x - xa;\n\n      /* Square it */\n      double ya = xa*xa;\n      double yb = xa*xb*2.0 + xb*xb;\n\n      /* Subtract from 1 */\n      ya = -ya;\n      yb = -yb;\n\n      double za = 1.0 + ya;\n      double zb = -(za - 1.0 - ya);\n\n      temp = za + yb;\n      zb += -(temp - za - yb);\n      za = temp;\n\n      /* Square root */\n      double y;\n      y = sqrt(za);\n      temp = y * HEX_40000000;\n      ya = y + temp - temp;\n      yb = y - ya;\n\n      /* Extend precision of sqrt */\n      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      /* Contribution of zb to sqrt */\n      double dx = zb / (2.0*y);\n\n      // Compute ratio r = x/y\n      double r = x/y;\n      temp = r * HEX_40000000;\n      double ra = r + temp - temp;\n      double rb = r - ra;\n\n      rb += (x - ra*ya - ra*yb - rb*ya - rb*yb) / y;  // Correct for rounding in division\n      rb += -x * dx / y / y;  // Add in effect additional bits of sqrt.\n\n      temp = ra + rb;\n      rb = -(temp - ra - rb);\n      ra = temp;\n\n      return atan(ra, rb, false);\n    }",
          "17": "    public static double asin(double x) {\n      if (x != x) {\n          return Double.NaN;\n      }\n\nif(NaN){\n          return Double.NaN;\n      }\n\n      if (x == 1.0) {\n          return Math.PI/2.0;\n      }\n\n      if (x == -1.0) {\n          return -Math.PI/2.0;\n      }\n\n      if (x == 0.0) { // Matches +/- 0.0; return correct sign\n          return x;\n      }\n\n      /* Compute asin(x) = atan(x/sqrt(1-x*x)) */\n\n      /* Split x */\n      double temp = x * HEX_40000000;\n      final double xa = x + temp - temp;\n      final double xb = x - xa;\n\n      /* Square it */\n      double ya = xa*xa;\n      double yb = xa*xb*2.0 + xb*xb;\n\n      /* Subtract from 1 */\n      ya = -ya;\n      yb = -yb;\n\n      double za = 1.0 + ya;\n      double zb = -(za - 1.0 - ya);\n\n      temp = za + yb;\n      zb += -(temp - za - yb);\n      za = temp;\n\n      /* Square root */\n      double y;\n      y = sqrt(za);\n      temp = y * HEX_40000000;\n      ya = y + temp - temp;\n      yb = y - ya;\n\n      /* Extend precision of sqrt */\n      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      /* Contribution of zb to sqrt */\n      double dx = zb / (2.0*y);\n\n      // Compute ratio r = x/y\n      double r = x/y;\n      temp = r * HEX_40000000;\n      double ra = r + temp - temp;\n      double rb = r - ra;\n\n      rb += (x - ra*ya - ra*yb - rb*ya - rb*yb) / y;  // Correct for rounding in division\n      rb += -x * dx / y / y;  // Add in effect additional bits of sqrt.\n\n      temp = ra + rb;\n      rb = -(temp - ra - rb);\n      ra = temp;\n\n      return atan(ra, rb, false);\n    }",
          "18": "    public static double asin(double x) {\n      if (x != x) {\n          return Double.NaN;\n      }\n\nif((x != x)){\n          return Double.NaN;\n      }\n\n      if (x == 1.0) {\n          return Math.PI/2.0;\n      }\n\n      if (x == -1.0) {\n          return -Math.PI/2.0;\n      }\n\n      if (x == 0.0) { // Matches +/- 0.0; return correct sign\n          return x;\n      }\n\n      /* Compute asin(x) = atan(x/sqrt(1-x*x)) */\n\n      /* Split x */\n      double temp = x * HEX_40000000;\n      final double xa = x + temp - temp;\n      final double xb = x - xa;\n\n      /* Square it */\n      double ya = xa*xa;\n      double yb = xa*xb*2.0 + xb*xb;\n\n      /* Subtract from 1 */\n      ya = -ya;\n      yb = -yb;\n\n      double za = 1.0 + ya;\n      double zb = -(za - 1.0 - ya);\n\n      temp = za + yb;\n      zb += -(temp - za - yb);\n      za = temp;\n\n      /* Square root */\n      double y;\n      y = sqrt(za);\n      temp = y * HEX_40000000;\n      ya = y + temp - temp;\n      yb = y - ya;\n\n      /* Extend precision of sqrt */\n      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      /* Contribution of zb to sqrt */\n      double dx = zb / (2.0*y);\n\n      // Compute ratio r = x/y\n      double r = x/y;\n      temp = r * HEX_40000000;\n      double ra = r + temp - temp;\n      double rb = r - ra;\n\n      rb += (x - ra*ya - ra*yb - rb*ya - rb*yb) / y;  // Correct for rounding in division\n      rb += -x * dx / y / y;  // Add in effect additional bits of sqrt.\n\n      temp = ra + rb;\n      rb = -(temp - ra - rb);\n      ra = temp;\n\n      return atan(ra, rb, false);\n    }",
          "19": "    public static double asin(double x) {\n      if (x != x) {\n          return Double.NaN;\n      }\n\nif(((x > 1.0) || (x || +1.0))){          return Double.NaN;\n      }\n\n      if (x == 1.0) {\n          return Math.PI/2.0;\n      }\n\n      if (x == -1.0) {\n          return -Math.PI/2.0;\n      }\n\n      if (x == 0.0) { // Matches +/- 0.0; return correct sign\n          return x;\n      }\n\n      /* Compute asin(x) = atan(x/sqrt(1-x*x)) */\n\n      /* Split x */\n      double temp = x * HEX_40000000;\n      final double xa = x + temp - temp;\n      final double xb = x - xa;\n\n      /* Square it */\n      double ya = xa*xa;\n      double yb = xa*xb*2.0 + xb*xb;\n\n      /* Subtract from 1 */\n      ya = -ya;\n      yb = -yb;\n\n      double za = 1.0 + ya;\n      double zb = -(za - 1.0 - ya);\n\n      temp = za + yb;\n      zb += -(temp - za - yb);\n      za = temp;\n\n      /* Square root */\n      double y;\n      y = sqrt(za);\n      temp = y * HEX_40000000;\n      ya = y + temp - temp;\n      yb = y - ya;\n\n      /* Extend precision of sqrt */\n      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      /* Contribution of zb to sqrt */\n      double dx = zb / (2.0*y);\n\n      // Compute ratio r = x/y\n      double r = x/y;\n      temp = r * HEX_40000000;\n      double ra = r + temp - temp;\n      double rb = r - ra;\n\n      rb += (x - ra*ya - ra*yb - rb*ya - rb*yb) / y;  // Correct for rounding in division\n      rb += -x * dx / y / y;  // Add in effect additional bits of sqrt.\n\n      temp = ra + rb;\n      rb = -(temp - ra - rb);\n      ra = temp;\n\n      return atan(ra, rb, false);\n    }",
          "20": "    public static double asin(double x) {\n      if (x != x) {\n          return Double.NaN;\n      }\n\nif(((x > 1.0) || (NaN < +1.0))){          return Double.NaN;\n      }\n\n      if (x == 1.0) {\n          return Math.PI/2.0;\n      }\n\n      if (x == -1.0) {\n          return -Math.PI/2.0;\n      }\n\n      if (x == 0.0) { // Matches +/- 0.0; return correct sign\n          return x;\n      }\n\n      /* Compute asin(x) = atan(x/sqrt(1-x*x)) */\n\n      /* Split x */\n      double temp = x * HEX_40000000;\n      final double xa = x + temp - temp;\n      final double xb = x - xa;\n\n      /* Square it */\n      double ya = xa*xa;\n      double yb = xa*xb*2.0 + xb*xb;\n\n      /* Subtract from 1 */\n      ya = -ya;\n      yb = -yb;\n\n      double za = 1.0 + ya;\n      double zb = -(za - 1.0 - ya);\n\n      temp = za + yb;\n      zb += -(temp - za - yb);\n      za = temp;\n\n      /* Square root */\n      double y;\n      y = sqrt(za);\n      temp = y * HEX_40000000;\n      ya = y + temp - temp;\n      yb = y - ya;\n\n      /* Extend precision of sqrt */\n      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      /* Contribution of zb to sqrt */\n      double dx = zb / (2.0*y);\n\n      // Compute ratio r = x/y\n      double r = x/y;\n      temp = r * HEX_40000000;\n      double ra = r + temp - temp;\n      double rb = r - ra;\n\n      rb += (x - ra*ya - ra*yb - rb*ya - rb*yb) / y;  // Correct for rounding in division\n      rb += -x * dx / y / y;  // Add in effect additional bits of sqrt.\n\n      temp = ra + rb;\n      rb = -(temp - ra - rb);\n      ra = temp;\n\n      return atan(ra, rb, false);\n    }",
          "21": "    public static double asin(double x) {\n      if (x != x) {\n          return Double.NaN;\n      }\n\nif(((x > 1.0) != (x < +1.0))){          return Double.NaN;\n      }\n\n      if (x == 1.0) {\n          return Math.PI/2.0;\n      }\n\n      if (x == -1.0) {\n          return -Math.PI/2.0;\n      }\n\n      if (x == 0.0) { // Matches +/- 0.0; return correct sign\n          return x;\n      }\n\n      /* Compute asin(x) = atan(x/sqrt(1-x*x)) */\n\n      /* Split x */\n      double temp = x * HEX_40000000;\n      final double xa = x + temp - temp;\n      final double xb = x - xa;\n\n      /* Square it */\n      double ya = xa*xa;\n      double yb = xa*xb*2.0 + xb*xb;\n\n      /* Subtract from 1 */\n      ya = -ya;\n      yb = -yb;\n\n      double za = 1.0 + ya;\n      double zb = -(za - 1.0 - ya);\n\n      temp = za + yb;\n      zb += -(temp - za - yb);\n      za = temp;\n\n      /* Square root */\n      double y;\n      y = sqrt(za);\n      temp = y * HEX_40000000;\n      ya = y + temp - temp;\n      yb = y - ya;\n\n      /* Extend precision of sqrt */\n      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      /* Contribution of zb to sqrt */\n      double dx = zb / (2.0*y);\n\n      // Compute ratio r = x/y\n      double r = x/y;\n      temp = r * HEX_40000000;\n      double ra = r + temp - temp;\n      double rb = r - ra;\n\n      rb += (x - ra*ya - ra*yb - rb*ya - rb*yb) / y;  // Correct for rounding in division\n      rb += -x * dx / y / y;  // Add in effect additional bits of sqrt.\n\n      temp = ra + rb;\n      rb = -(temp - ra - rb);\n      ra = temp;\n\n      return atan(ra, rb, false);\n    }",
          "22": "    public static double asin(double x) {\n      if (x != x) {\n          return Double.NaN;\n      }\n\nif(((x > 1.0) || (x + +1.0))){          return Double.NaN;\n      }\n\n      if (x == 1.0) {\n          return Math.PI/2.0;\n      }\n\n      if (x == -1.0) {\n          return -Math.PI/2.0;\n      }\n\n      if (x == 0.0) { // Matches +/- 0.0; return correct sign\n          return x;\n      }\n\n      /* Compute asin(x) = atan(x/sqrt(1-x*x)) */\n\n      /* Split x */\n      double temp = x * HEX_40000000;\n      final double xa = x + temp - temp;\n      final double xb = x - xa;\n\n      /* Square it */\n      double ya = xa*xa;\n      double yb = xa*xb*2.0 + xb*xb;\n\n      /* Subtract from 1 */\n      ya = -ya;\n      yb = -yb;\n\n      double za = 1.0 + ya;\n      double zb = -(za - 1.0 - ya);\n\n      temp = za + yb;\n      zb += -(temp - za - yb);\n      za = temp;\n\n      /* Square root */\n      double y;\n      y = sqrt(za);\n      temp = y * HEX_40000000;\n      ya = y + temp - temp;\n      yb = y - ya;\n\n      /* Extend precision of sqrt */\n      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      /* Contribution of zb to sqrt */\n      double dx = zb / (2.0*y);\n\n      // Compute ratio r = x/y\n      double r = x/y;\n      temp = r * HEX_40000000;\n      double ra = r + temp - temp;\n      double rb = r - ra;\n\n      rb += (x - ra*ya - ra*yb - rb*ya - rb*yb) / y;  // Correct for rounding in division\n      rb += -x * dx / y / y;  // Add in effect additional bits of sqrt.\n\n      temp = ra + rb;\n      rb = -(temp - ra - rb);\n      ra = temp;\n\n      return atan(ra, rb, false);\n    }",
          "23": "    public static double asin(double x) {\n      if (x != x) {\n          return Double.NaN;\n      }\n\nif(((x > 1.0) || (x < x))){\n          return Double.NaN;\n      }\n\n      if (x == 1.0) {\n          return Math.PI/2.0;\n      }\n\n      if (x == -1.0) {\n          return -Math.PI/2.0;\n      }\n\n      if (x == 0.0) { // Matches +/- 0.0; return correct sign\n          return x;\n      }\n\n      /* Compute asin(x) = atan(x/sqrt(1-x*x)) */\n\n      /* Split x */\n      double temp = x * HEX_40000000;\n      final double xa = x + temp - temp;\n      final double xb = x - xa;\n\n      /* Square it */\n      double ya = xa*xa;\n      double yb = xa*xb*2.0 + xb*xb;\n\n      /* Subtract from 1 */\n      ya = -ya;\n      yb = -yb;\n\n      double za = 1.0 + ya;\n      double zb = -(za - 1.0 - ya);\n\n      temp = za + yb;\n      zb += -(temp - za - yb);\n      za = temp;\n\n      /* Square root */\n      double y;\n      y = sqrt(za);\n      temp = y * HEX_40000000;\n      ya = y + temp - temp;\n      yb = y - ya;\n\n      /* Extend precision of sqrt */\n      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      /* Contribution of zb to sqrt */\n      double dx = zb / (2.0*y);\n\n      // Compute ratio r = x/y\n      double r = x/y;\n      temp = r * HEX_40000000;\n      double ra = r + temp - temp;\n      double rb = r - ra;\n\n      rb += (x - ra*ya - ra*yb - rb*ya - rb*yb) / y;  // Correct for rounding in division\n      rb += -x * dx / y / y;  // Add in effect additional bits of sqrt.\n\n      temp = ra + rb;\n      rb = -(temp - ra - rb);\n      ra = temp;\n\n      return atan(ra, rb, false);\n    }",
          "24": "    public static double asin(double x) {\n      if (x != x) {\n          return Double.NaN;\n      }\n\nif(((x > 1.0) || (x && +1.0))){          return Double.NaN;\n      }\n\n      if (x == 1.0) {\n          return Math.PI/2.0;\n      }\n\n      if (x == -1.0) {\n          return -Math.PI/2.0;\n      }\n\n      if (x == 0.0) { // Matches +/- 0.0; return correct sign\n          return x;\n      }\n\n      /* Compute asin(x) = atan(x/sqrt(1-x*x)) */\n\n      /* Split x */\n      double temp = x * HEX_40000000;\n      final double xa = x + temp - temp;\n      final double xb = x - xa;\n\n      /* Square it */\n      double ya = xa*xa;\n      double yb = xa*xb*2.0 + xb*xb;\n\n      /* Subtract from 1 */\n      ya = -ya;\n      yb = -yb;\n\n      double za = 1.0 + ya;\n      double zb = -(za - 1.0 - ya);\n\n      temp = za + yb;\n      zb += -(temp - za - yb);\n      za = temp;\n\n      /* Square root */\n      double y;\n      y = sqrt(za);\n      temp = y * HEX_40000000;\n      ya = y + temp - temp;\n      yb = y - ya;\n\n      /* Extend precision of sqrt */\n      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      /* Contribution of zb to sqrt */\n      double dx = zb / (2.0*y);\n\n      // Compute ratio r = x/y\n      double r = x/y;\n      temp = r * HEX_40000000;\n      double ra = r + temp - temp;\n      double rb = r - ra;\n\n      rb += (x - ra*ya - ra*yb - rb*ya - rb*yb) / y;  // Correct for rounding in division\n      rb += -x * dx / y / y;  // Add in effect additional bits of sqrt.\n\n      temp = ra + rb;\n      rb = -(temp - ra - rb);\n      ra = temp;\n\n      return atan(ra, rb, false);\n    }",
          "25": "    public static double asin(double x) {\n      if (x != x) {\n          return Double.NaN;\n      }\n\nif(((x != 1.0) || (x < +1.0))){          return Double.NaN;\n      }\n\n      if (x == 1.0) {\n          return Math.PI/2.0;\n      }\n\n      if (x == -1.0) {\n          return -Math.PI/2.0;\n      }\n\n      if (x == 0.0) { // Matches +/- 0.0; return correct sign\n          return x;\n      }\n\n      /* Compute asin(x) = atan(x/sqrt(1-x*x)) */\n\n      /* Split x */\n      double temp = x * HEX_40000000;\n      final double xa = x + temp - temp;\n      final double xb = x - xa;\n\n      /* Square it */\n      double ya = xa*xa;\n      double yb = xa*xb*2.0 + xb*xb;\n\n      /* Subtract from 1 */\n      ya = -ya;\n      yb = -yb;\n\n      double za = 1.0 + ya;\n      double zb = -(za - 1.0 - ya);\n\n      temp = za + yb;\n      zb += -(temp - za - yb);\n      za = temp;\n\n      /* Square root */\n      double y;\n      y = sqrt(za);\n      temp = y * HEX_40000000;\n      ya = y + temp - temp;\n      yb = y - ya;\n\n      /* Extend precision of sqrt */\n      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      /* Contribution of zb to sqrt */\n      double dx = zb / (2.0*y);\n\n      // Compute ratio r = x/y\n      double r = x/y;\n      temp = r * HEX_40000000;\n      double ra = r + temp - temp;\n      double rb = r - ra;\n\n      rb += (x - ra*ya - ra*yb - rb*ya - rb*yb) / y;  // Correct for rounding in division\n      rb += -x * dx / y / y;  // Add in effect additional bits of sqrt.\n\n      temp = ra + rb;\n      rb = -(temp - ra - rb);\n      ra = temp;\n\n      return atan(ra, rb, false);\n    }",
          "26": "    public static double asin(double x) {\n      if (x != x) {\n          return Double.NaN;\n      }\n\nif(((x > 1.0) == (x < +1.0))){          return Double.NaN;\n      }\n\n      if (x == 1.0) {\n          return Math.PI/2.0;\n      }\n\n      if (x == -1.0) {\n          return -Math.PI/2.0;\n      }\n\n      if (x == 0.0) { // Matches +/- 0.0; return correct sign\n          return x;\n      }\n\n      /* Compute asin(x) = atan(x/sqrt(1-x*x)) */\n\n      /* Split x */\n      double temp = x * HEX_40000000;\n      final double xa = x + temp - temp;\n      final double xb = x - xa;\n\n      /* Square it */\n      double ya = xa*xa;\n      double yb = xa*xb*2.0 + xb*xb;\n\n      /* Subtract from 1 */\n      ya = -ya;\n      yb = -yb;\n\n      double za = 1.0 + ya;\n      double zb = -(za - 1.0 - ya);\n\n      temp = za + yb;\n      zb += -(temp - za - yb);\n      za = temp;\n\n      /* Square root */\n      double y;\n      y = sqrt(za);\n      temp = y * HEX_40000000;\n      ya = y + temp - temp;\n      yb = y - ya;\n\n      /* Extend precision of sqrt */\n      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      /* Contribution of zb to sqrt */\n      double dx = zb / (2.0*y);\n\n      // Compute ratio r = x/y\n      double r = x/y;\n      temp = r * HEX_40000000;\n      double ra = r + temp - temp;\n      double rb = r - ra;\n\n      rb += (x - ra*ya - ra*yb - rb*ya - rb*yb) / y;  // Correct for rounding in division\n      rb += -x * dx / y / y;  // Add in effect additional bits of sqrt.\n\n      temp = ra + rb;\n      rb = -(temp - ra - rb);\n      ra = temp;\n\n      return atan(ra, rb, false);\n    }",
          "27": "    public static double asin(double x) {\n      if (x != x) {\n          return Double.NaN;\n      }\n\nif(((x - 1.0) || (x < +1.0))){          return Double.NaN;\n      }\n\n      if (x == 1.0) {\n          return Math.PI/2.0;\n      }\n\n      if (x == -1.0) {\n          return -Math.PI/2.0;\n      }\n\n      if (x == 0.0) { // Matches +/- 0.0; return correct sign\n          return x;\n      }\n\n      /* Compute asin(x) = atan(x/sqrt(1-x*x)) */\n\n      /* Split x */\n      double temp = x * HEX_40000000;\n      final double xa = x + temp - temp;\n      final double xb = x - xa;\n\n      /* Square it */\n      double ya = xa*xa;\n      double yb = xa*xb*2.0 + xb*xb;\n\n      /* Subtract from 1 */\n      ya = -ya;\n      yb = -yb;\n\n      double za = 1.0 + ya;\n      double zb = -(za - 1.0 - ya);\n\n      temp = za + yb;\n      zb += -(temp - za - yb);\n      za = temp;\n\n      /* Square root */\n      double y;\n      y = sqrt(za);\n      temp = y * HEX_40000000;\n      ya = y + temp - temp;\n      yb = y - ya;\n\n      /* Extend precision of sqrt */\n      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      /* Contribution of zb to sqrt */\n      double dx = zb / (2.0*y);\n\n      // Compute ratio r = x/y\n      double r = x/y;\n      temp = r * HEX_40000000;\n      double ra = r + temp - temp;\n      double rb = r - ra;\n\n      rb += (x - ra*ya - ra*yb - rb*ya - rb*yb) / y;  // Correct for rounding in division\n      rb += -x * dx / y / y;  // Add in effect additional bits of sqrt.\n\n      temp = ra + rb;\n      rb = -(temp - ra - rb);\n      ra = temp;\n\n      return atan(ra, rb, false);\n    }",
          "28": "    public static double asin(double x) {\n      if (x != x) {\n          return Double.NaN;\n      }\n\nif(((x + 1.0) || (x < +1.0))){          return Double.NaN;\n      }\n\n      if (x == 1.0) {\n          return Math.PI/2.0;\n      }\n\n      if (x == -1.0) {\n          return -Math.PI/2.0;\n      }\n\n      if (x == 0.0) { // Matches +/- 0.0; return correct sign\n          return x;\n      }\n\n      /* Compute asin(x) = atan(x/sqrt(1-x*x)) */\n\n      /* Split x */\n      double temp = x * HEX_40000000;\n      final double xa = x + temp - temp;\n      final double xb = x - xa;\n\n      /* Square it */\n      double ya = xa*xa;\n      double yb = xa*xb*2.0 + xb*xb;\n\n      /* Subtract from 1 */\n      ya = -ya;\n      yb = -yb;\n\n      double za = 1.0 + ya;\n      double zb = -(za - 1.0 - ya);\n\n      temp = za + yb;\n      zb += -(temp - za - yb);\n      za = temp;\n\n      /* Square root */\n      double y;\n      y = sqrt(za);\n      temp = y * HEX_40000000;\n      ya = y + temp - temp;\n      yb = y - ya;\n\n      /* Extend precision of sqrt */\n      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      /* Contribution of zb to sqrt */\n      double dx = zb / (2.0*y);\n\n      // Compute ratio r = x/y\n      double r = x/y;\n      temp = r * HEX_40000000;\n      double ra = r + temp - temp;\n      double rb = r - ra;\n\n      rb += (x - ra*ya - ra*yb - rb*ya - rb*yb) / y;  // Correct for rounding in division\n      rb += -x * dx / y / y;  // Add in effect additional bits of sqrt.\n\n      temp = ra + rb;\n      rb = -(temp - ra - rb);\n      ra = temp;\n\n      return atan(ra, rb, false);\n    }",
          "29": "    public static double asin(double x) {\n      if (x != x) {\n          return Double.NaN;\n      }\n\nif(((x || 1.0) || (x < +1.0))){          return Double.NaN;\n      }\n\n      if (x == 1.0) {\n          return Math.PI/2.0;\n      }\n\n      if (x == -1.0) {\n          return -Math.PI/2.0;\n      }\n\n      if (x == 0.0) { // Matches +/- 0.0; return correct sign\n          return x;\n      }\n\n      /* Compute asin(x) = atan(x/sqrt(1-x*x)) */\n\n      /* Split x */\n      double temp = x * HEX_40000000;\n      final double xa = x + temp - temp;\n      final double xb = x - xa;\n\n      /* Square it */\n      double ya = xa*xa;\n      double yb = xa*xb*2.0 + xb*xb;\n\n      /* Subtract from 1 */\n      ya = -ya;\n      yb = -yb;\n\n      double za = 1.0 + ya;\n      double zb = -(za - 1.0 - ya);\n\n      temp = za + yb;\n      zb += -(temp - za - yb);\n      za = temp;\n\n      /* Square root */\n      double y;\n      y = sqrt(za);\n      temp = y * HEX_40000000;\n      ya = y + temp - temp;\n      yb = y - ya;\n\n      /* Extend precision of sqrt */\n      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      /* Contribution of zb to sqrt */\n      double dx = zb / (2.0*y);\n\n      // Compute ratio r = x/y\n      double r = x/y;\n      temp = r * HEX_40000000;\n      double ra = r + temp - temp;\n      double rb = r - ra;\n\n      rb += (x - ra*ya - ra*yb - rb*ya - rb*yb) / y;  // Correct for rounding in division\n      rb += -x * dx / y / y;  // Add in effect additional bits of sqrt.\n\n      temp = ra + rb;\n      rb = -(temp - ra - rb);\n      ra = temp;\n\n      return atan(ra, rb, false);\n    }",
          "30": "    public static double asin(double x) {\n      if (x != x) {\n          return Double.NaN;\n      }\n\nif((((x > 1.0) || (x < x)) || (x < +1.0))){\n          return Double.NaN;\n      }\n\n      if (x == 1.0) {\n          return Math.PI/2.0;\n      }\n\n      if (x == -1.0) {\n          return -Math.PI/2.0;\n      }\n\n      if (x == 0.0) { // Matches +/- 0.0; return correct sign\n          return x;\n      }\n\n      /* Compute asin(x) = atan(x/sqrt(1-x*x)) */\n\n      /* Split x */\n      double temp = x * HEX_40000000;\n      final double xa = x + temp - temp;\n      final double xb = x - xa;\n\n      /* Square it */\n      double ya = xa*xa;\n      double yb = xa*xb*2.0 + xb*xb;\n\n      /* Subtract from 1 */\n      ya = -ya;\n      yb = -yb;\n\n      double za = 1.0 + ya;\n      double zb = -(za - 1.0 - ya);\n\n      temp = za + yb;\n      zb += -(temp - za - yb);\n      za = temp;\n\n      /* Square root */\n      double y;\n      y = sqrt(za);\n      temp = y * HEX_40000000;\n      ya = y + temp - temp;\n      yb = y - ya;\n\n      /* Extend precision of sqrt */\n      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      /* Contribution of zb to sqrt */\n      double dx = zb / (2.0*y);\n\n      // Compute ratio r = x/y\n      double r = x/y;\n      temp = r * HEX_40000000;\n      double ra = r + temp - temp;\n      double rb = r - ra;\n\n      rb += (x - ra*ya - ra*yb - rb*ya - rb*yb) / y;  // Correct for rounding in division\n      rb += -x * dx / y / y;  // Add in effect additional bits of sqrt.\n\n      temp = ra + rb;\n      rb = -(temp - ra - rb);\n      ra = temp;\n\n      return atan(ra, rb, false);\n    }",
          "31": "    public static double asin(double x) {\n      if (x != x) {\n          return Double.NaN;\n      }\n\n      if (x > 1.0 || x < +1.0) {          return Double.NaN;\n      }\n\n      if (x == 1.0) {\n          return Math.PI/2.0;\n      }\n\n      if (x == -1.0) {\n          return -Math.PI/2.0;\n      }\n\n      if (x == 0.0) { // Matches +/- 0.0; return correct sign\n          return x;\n      }\n\n      /* Compute asin(x) = atan(x/sqrt(1-x*x)) */\n\n      /* Split x */\n      double temp = x * HEX_40000000;\n      final double xa = x + temp - temp;\n      final double xb = x - xa;\n\n      /* Square it */\n      double ya = xa*xa;\n      double yb = xa*xb*2.0 + xb*xb;\n\n      /* Subtract from 1 */\n      ya = -ya;\n      yb = -yb;\n\n      double za = 1.0 + ya;\n      double zb = -(za - 1.0 - ya);\n\n      temp = za + yb;\n      zb += -(temp - za - yb);\n      za = temp;\n\n      /* Square root */\n      double y;\n      y = sqrt(za);\n      temp = y * HEX_40000000;\n      ya = y + temp - temp;\n      yb = y - ya;\n\n      /* Extend precision of sqrt */\n      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      /* Contribution of zb to sqrt */\n      double dx = zb / (2.0*y);\n\n      // Compute ratio r = x/y\n      double r = x/y;\n      temp = r * HEX_40000000;\n      double ra = r + temp - temp;\n      double rb = r - ra;\n\n      rb += (x - ra*ya - ra*yb - rb*ya - rb*yb) / y;  // Correct for rounding in division\n      rb += -x * dx / y / y;  // Add in effect additional bits of sqrt.\n\n      temp = ra + rb;\n      rb = -(temp - ra - rb);\n      ra = temp;\n\n      return atan(ra, rb, false);\n    }"
}