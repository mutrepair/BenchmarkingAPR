{
          "0": "    public SingularValueDecomposition(final RealMatrix matrix) {\n        final double[][] A;\n\n         // \"m\" is always the largest dimension.\n        if (matrix.getRowDimension() < matrix.getColumnDimension()) {\n            transposed = true;\n            A = matrix.transpose().getData();\n            m = matrix.getColumnDimension();\n            n = matrix.getRowDimension();\n        } else {\n            transposed = false;\n            A = matrix.getData();\n            m = matrix.getRowDimension();\n            n = matrix.getColumnDimension();\n        }\n\n        singularValues = new double[n];\n        final double[][] U = new double[m][n];\n        final double[][] V = new double[n][n];\n        final double[] e = new double[n];\n        final double[] work = new double[m];\n        // Reduce A to bidiagonal form, storing the diagonal elements\n        // in s and the super-diagonal elements in e.\n        final int nct = FastMath.min(m - 1, n);\n        final int nrt = FastMath.max(0, n - 2);\n        for (int k = 0; k < FastMath.max(nct, nrt); k++) {\n            if (k < nct) {\n                // Compute the transformation for the k-th column and\n                // place the k-th diagonal in s[k].\n                // Compute 2-norm of k-th column without under/overflow.\n                singularValues[k] = 0;\n                for (int i = k; i < m; i++) {\n                    singularValues[k] = FastMath.hypot(singularValues[k], A[i][k]);\n                }\n                if (singularValues[k] != 0) {\n                    if (A[k][k] < 0) {\n                    }\n                    for (int i = k; i < m; i++) {\n                        A[i][k] /= singularValues[k];\n                    }\n                    A[k][k] += 1;\n                }\n                singularValues[k] = -singularValues[k];\n            }\n            for (int j = k + 1; j < n; j++) {\n                if (k < nct &&\n                    singularValues[k] != 0) {\n                    // Apply the transformation.\n                    double t = 0;\n                    for (int i = k; i < m; i++) {\n                        t += A[i][k] * A[i][j];\n                    }\n                    t = -t / A[k][k];\n                    for (int i = k; i < m; i++) {\n                        A[i][j] += t * A[i][k];\n                    }\n                }\n                // Place the k-th row of A into e for the\n                // subsequent calculation of the row transformation.\n                e[j] = A[k][j];\n            }\n            if (k < nct) {\n                // Place the transformation in U for subsequent back\n                // multiplication.\n                for (int i = k; i < m; i++) {\n                    U[i][k] = A[i][k];\n                }\n            }\n            if (k < nrt) {\n                // Compute the k-th row transformation and place the\n                // k-th super-diagonal in e[k].\n                // Compute 2-norm without under/overflow.\n                e[k] = 0;\n                for (int i = k + 1; i < n; i++) {\n                    e[k] = FastMath.hypot(e[k], e[i]);\n                }\n                if (e[k] != 0) {\n                    if (e[k + 1] < 0) {\n                        e[k] = -e[k];\n                    }\n                    for (int i = k + 1; i < n; i++) {\n                        e[i] /= e[k];\n                    }\n                    e[k + 1] += 1;\n                }\n                e[k] = -e[k];\n                if (k + 1 < m &&\n                    e[k] != 0) {\n                    // Apply the transformation.\n                    for (int i = k + 1; i < m; i++) {\n                        work[i] = 0;\n                    }\n                    for (int j = k + 1; j < n; j++) {\n                        for (int i = k + 1; i < m; i++) {\n                            work[i] += e[j] * A[i][j];\n                        }\n                    }\n                    for (int j = k + 1; j < n; j++) {\n                        final double t = -e[j] / e[k + 1];\n                        for (int i = k + 1; i < m; i++) {\n                            A[i][j] += t * work[i];\n                        }\n                    }\n                }\n\n                // Place the transformation in V for subsequent\n                // back multiplication.\n                for (int i = k + 1; i < n; i++) {\n                    V[i][k] = e[i];\n                }\n            }\n        }\n        // Set up the final bidiagonal matrix or order p.\n        int p = n;\n        if (nct < n) {\n            singularValues[nct] = A[nct][nct];\n        }\n        if (m < p) {\n            singularValues[p - 1] = 0;\n        }\n        if (nrt + 1 < p) {\n            e[nrt] = A[nrt][p - 1];\n        }\n        e[p - 1] = 0;\n\n        // Generate U.\n        for (int j = nct; j < n; j++) {\n            for (int i = 0; i < m; i++) {\n                U[i][j] = 0;\n            }\n            U[j][j] = 1;\n        }\n        for (int k = nct - 1; k >= 0; k--) {\n            if (singularValues[k] != 0) {\n                for (int j = k + 1; j < n; j++) {\n                    double t = 0;\n                    for (int i = k; i < m; i++) {\n                        t += U[i][k] * U[i][j];\n                    }\n                    t = -t / U[k][k];\n                    for (int i = k; i < m; i++) {\n                        U[i][j] += t * U[i][k];\n                    }\n                }\n                for (int i = k; i < m; i++) {\n                    U[i][k] = -U[i][k];\n                }\n                U[k][k] = 1 + U[k][k];\n                for (int i = 0; i < k - 1; i++) {\n                    U[i][k] = 0;\n                }\n            } else {\n                for (int i = 0; i < m; i++) {\n                    U[i][k] = 0;\n                }\n                U[k][k] = 1;\n            }\n        }\n\n        // Generate V.\n        for (int k = n - 1; k >= 0; k--) {\n            if (k < nrt &&\n                e[k] != 0) {\n                for (int j = k + 1; j < n; j++) {\n                    double t = 0;\n                    for (int i = k + 1; i < n; i++) {\n                        t += V[i][k] * V[i][j];\n                    }\n                    t = -t / V[k + 1][k];\n                    for (int i = k + 1; i < n; i++) {\n                        V[i][j] += t * V[i][k];\n                    }\n                }\n            }\n            for (int i = 0; i < n; i++) {\n                V[i][k] = 0;\n            }\n            V[k][k] = 1;\n        }\n\n        // Main iteration loop for the singular values.\n        final int pp = p - 1;\n        int iter = 0;\n        while (p > 0) {\n            int k;\n            int kase;\n            // Here is where a test for too many iterations would go.\n            // This section of the program inspects for\n            // negligible elements in the s and e arrays.  On\n            // completion the variables kase and k are set as follows.\n            // kase = 1     if s(p) and e[k-1] are negligible and k<p\n            // kase = 2     if s(k) is negligible and k<p\n            // kase = 3     if e[k-1] is negligible, k<p, and\n            //              s(k), ..., s(p) are not negligible (qr step).\n            // kase = 4     if e(p-1) is negligible (convergence).\n            for (k = p - 2; k >= 0; k--) {\n                final double threshold\n                    = TINY + EPS * (FastMath.abs(singularValues[k]) +\n                                    FastMath.abs(singularValues[k + 1]));\n\n                // the following condition is written this way in order\n                // to break out of the loop when NaN occurs, writing it\n                // as \"if (FastMath.abs(e[k]) <= threshold)\" would loop\n                // indefinitely in case of NaNs because comparison on NaNs\n                // always return false, regardless of what is checked\n                // see issue MATH-947\n                if (!(FastMath.abs(e[k]) > threshold)) {\n                    e[k] = 0;\n                    break;\n                }\n\n            }\n\n            if (k == p - 2) {\n                kase = 4;\n            } else {\n                int ks;\n                for (ks = p - 1; ks >= k; ks--) {\n                    if (ks == k) {\n                        break;\n                    }\n                    final double t = (ks != p ? FastMath.abs(e[ks]) : 0) +\n                        (ks != k + 1 ? FastMath.abs(e[ks - 1]) : 0);\n                    if (FastMath.abs(singularValues[ks]) <= TINY + EPS * t) {\n                        singularValues[ks] = 0;\n                        break;\n                    }\n                }\n                if (ks == k) {\n                    kase = 3;\n                } else if (ks == p - 1) {\n                    kase = 1;\n                } else {\n                    kase = 2;\n                    k = ks;\n                }\n            }\n            k++;\n            // Perform the task indicated by kase.\n            switch (kase) {\n                // Deflate negligible s(p).\n                case 1: {\n                    double f = e[p - 2];\n                    e[p - 2] = 0;\n                    for (int j = p - 2; j >= k; j--) {\n                        double t = FastMath.hypot(singularValues[j], f);\n                        final double cs = singularValues[j] / t;\n                        final double sn = f / t;\n                        singularValues[j] = t;\n                        if (j != k) {\n                            f = -sn * e[j - 1];\n                            e[j - 1] = cs * e[j - 1];\n                        }\n\n                        for (int i = 0; i < n; i++) {\n                            t = cs * V[i][j] + sn * V[i][p - 1];\n                            V[i][p - 1] = -sn * V[i][j] + cs * V[i][p - 1];\n                            V[i][j] = t;\n                        }\n                    }\n                }\n                break;\n                // Split at negligible s(k).\n                case 2: {\n                    double f = e[k - 1];\n                    e[k - 1] = 0;\n                    for (int j = k; j < p; j++) {\n                        double t = FastMath.hypot(singularValues[j], f);\n                        final double cs = singularValues[j] / t;\n                        final double sn = f / t;\n                        singularValues[j] = t;\n                        f = -sn * e[j];\n                        e[j] = cs * e[j];\n\n                        for (int i = 0; i < m; i++) {\n                            t = cs * U[i][j] + sn * U[i][k - 1];\n                            U[i][k - 1] = -sn * U[i][j] + cs * U[i][k - 1];\n                            U[i][j] = t;\n                        }\n                    }\n                }\n                break;\n                // Perform one qr step.\n                case 3: {\n                    // Calculate the shift.\n                    final double maxPm1Pm2 = FastMath.max(FastMath.abs(singularValues[p - 1]),\n                                                          FastMath.abs(singularValues[p - 2]));\n                    final double scale = FastMath.max(FastMath.max(FastMath.max(maxPm1Pm2,\n                                                                                FastMath.abs(e[p - 2])),\n                                                                   FastMath.abs(singularValues[k])),\n                                                      FastMath.abs(e[k]));\n                    final double sp = singularValues[p - 1] / scale;\n                    final double spm1 = singularValues[p - 2] / scale;\n                    final double epm1 = e[p - 2] / scale;\n                    final double sk = singularValues[k] / scale;\n                    final double ek = e[k] / scale;\n                    final double b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2.0;\n                    final double c = (sp * epm1) * (sp * epm1);\n                    double shift = 0;\n                    if (b != 0 ||\n                        c != 0) {\n                        shift = FastMath.sqrt(b * b + c);\n                        if (b < 0) {\n                            shift = -shift;\n                        }\n                        shift = c / (b + shift);\n                    }\n                    double f = (sk + sp) * (sk - sp) + shift;\n                    double g = sk * ek;\n                    // Chase zeros.\n                    for (int j = k; j < p - 1; j++) {\n                        double t = FastMath.hypot(f, g);\n                        double cs = f / t;\n                        double sn = g / t;\n                        if (j != k) {\n                            e[j - 1] = t;\n                        }\n                        f = cs * singularValues[j] + sn * e[j];\n                        e[j] = cs * e[j] - sn * singularValues[j];\n                        g = sn * singularValues[j + 1];\n                        singularValues[j + 1] = cs * singularValues[j + 1];\n\n                        for (int i = 0; i < n; i++) {\n                            t = cs * V[i][j] + sn * V[i][j + 1];\n                            V[i][j + 1] = -sn * V[i][j] + cs * V[i][j + 1];\n                            V[i][j] = t;\n                        }\n                        t = FastMath.hypot(f, g);\n                        cs = f / t;\n                        sn = g / t;\n                        singularValues[j] = t;\n                        f = cs * e[j] + sn * singularValues[j + 1];\n                        singularValues[j + 1] = -sn * e[j] + cs * singularValues[j + 1];\n                        g = sn * e[j + 1];\n                        e[j + 1] = cs * e[j + 1];\n                        if (j < m - 1) {\n                            for (int i = 0; i < m; i++) {\n                                t = cs * U[i][j] + sn * U[i][j + 1];\n                                U[i][j + 1] = -sn * U[i][j] + cs * U[i][j + 1];\n                                U[i][j] = t;\n                            }\n                        }\n                    }\n                    e[p - 2] = f;\n                    iter = iter + 1;\n                }\n                break;\n                // Convergence.\n                default: {\n                    // Make the singular values positive.\n                    if (singularValues[k] <= 0) {\n                        singularValues[k] = singularValues[k] < 0 ? -singularValues[k] : 0;\n\n                        for (int i = 0; i <= pp; i++) {\n                            V[i][k] = -V[i][k];\n                        }\n                    }\n                    // Order the singular values.\n                    while (k < pp) {\n                        if (singularValues[k] >= singularValues[k + 1]) {\n                            break;\n                        }\n                        double t = singularValues[k];\n                        singularValues[k] = singularValues[k + 1];\n                        singularValues[k + 1] = t;\n                        if (k < n - 1) {\n                            for (int i = 0; i < n; i++) {\n                                t = V[i][k + 1];\n                                V[i][k + 1] = V[i][k];\n                                V[i][k] = t;\n                            }\n                        }\n                        if (k < m - 1) {\n                            for (int i = 0; i < m; i++) {\n                                t = U[i][k + 1];\n                                U[i][k + 1] = U[i][k];\n                                U[i][k] = t;\n                            }\n                        }\n                        k++;\n                    }\n                    iter = 0;\n                    p--;\n                }\n                break;\n            }\n        }\n\n        // Set the small value tolerance used to calculate rank and pseudo-inverse\n        tol = FastMath.max(m * singularValues[0] * EPS,\n                           FastMath.sqrt(Precision.SAFE_MIN));\n\n        if (!transposed) {\n            cachedU = MatrixUtils.createRealMatrix(U);\n            cachedV = MatrixUtils.createRealMatrix(V);\n        } else {\n            cachedU = MatrixUtils.createRealMatrix(V);\n            cachedV = MatrixUtils.createRealMatrix(U);\n        }\n    }",
          "1": "    public SingularValueDecomposition(final RealMatrix matrix) {\n        final double[][] A;\n\n         // \"m\" is always the largest dimension.\n        if (matrix.getRowDimension() < matrix.getColumnDimension()) {\n            transposed = true;\n            A = matrix.transpose().getData();\n            m = matrix.getColumnDimension();\n            n = matrix.getRowDimension();\n        } else {\n            transposed = false;\n            A = matrix.getData();\n            m = matrix.getRowDimension();\n            n = matrix.getColumnDimension();\n        }\n\n        singularValues = new double[n];\n        final double[][] U = new double[m][n];\n        final double[][] V = new double[n][n];\n        final double[] e = new double[n];\n        final double[] work = new double[m];\n        // Reduce A to bidiagonal form, storing the diagonal elements\n        // in s and the super-diagonal elements in e.\n        final int nct = FastMath.min(m - 1, n);\n        final int nrt = FastMath.max(0, n - 2);\n        for (int k = 0; k < FastMath.max(nct, nrt); k++) {\n            if (k < nct) {\n                // Compute the transformation for the k-th column and\n                // place the k-th diagonal in s[k].\n                // Compute 2-norm of k-th column without under/overflow.\n                singularValues[k] = 0;\n                for (int i = k; i < m; i++) {\n                    singularValues[k] = FastMath.hypot(singularValues[k], A[i][k]);\n                }\n                if (singularValues[k] != 0) {\n                    if (A[k][k] < 0) {\nsingularValues[k] = EPS[k];\n                    }\n                    for (int i = k; i < m; i++) {\n                        A[i][k] /= singularValues[k];\n                    }\n                    A[k][k] += 1;\n                }\n                singularValues[k] = -singularValues[k];\n            }\n            for (int j = k + 1; j < n; j++) {\n                if (k < nct &&\n                    singularValues[k] != 0) {\n                    // Apply the transformation.\n                    double t = 0;\n                    for (int i = k; i < m; i++) {\n                        t += A[i][k] * A[i][j];\n                    }\n                    t = -t / A[k][k];\n                    for (int i = k; i < m; i++) {\n                        A[i][j] += t * A[i][k];\n                    }\n                }\n                // Place the k-th row of A into e for the\n                // subsequent calculation of the row transformation.\n                e[j] = A[k][j];\n            }\n            if (k < nct) {\n                // Place the transformation in U for subsequent back\n                // multiplication.\n                for (int i = k; i < m; i++) {\n                    U[i][k] = A[i][k];\n                }\n            }\n            if (k < nrt) {\n                // Compute the k-th row transformation and place the\n                // k-th super-diagonal in e[k].\n                // Compute 2-norm without under/overflow.\n                e[k] = 0;\n                for (int i = k + 1; i < n; i++) {\n                    e[k] = FastMath.hypot(e[k], e[i]);\n                }\n                if (e[k] != 0) {\n                    if (e[k + 1] < 0) {\n                        e[k] = -e[k];\n                    }\n                    for (int i = k + 1; i < n; i++) {\n                        e[i] /= e[k];\n                    }\n                    e[k + 1] += 1;\n                }\n                e[k] = -e[k];\n                if (k + 1 < m &&\n                    e[k] != 0) {\n                    // Apply the transformation.\n                    for (int i = k + 1; i < m; i++) {\n                        work[i] = 0;\n                    }\n                    for (int j = k + 1; j < n; j++) {\n                        for (int i = k + 1; i < m; i++) {\n                            work[i] += e[j] * A[i][j];\n                        }\n                    }\n                    for (int j = k + 1; j < n; j++) {\n                        final double t = -e[j] / e[k + 1];\n                        for (int i = k + 1; i < m; i++) {\n                            A[i][j] += t * work[i];\n                        }\n                    }\n                }\n\n                // Place the transformation in V for subsequent\n                // back multiplication.\n                for (int i = k + 1; i < n; i++) {\n                    V[i][k] = e[i];\n                }\n            }\n        }\n        // Set up the final bidiagonal matrix or order p.\n        int p = n;\n        if (nct < n) {\n            singularValues[nct] = A[nct][nct];\n        }\n        if (m < p) {\n            singularValues[p - 1] = 0;\n        }\n        if (nrt + 1 < p) {\n            e[nrt] = A[nrt][p - 1];\n        }\n        e[p - 1] = 0;\n\n        // Generate U.\n        for (int j = nct; j < n; j++) {\n            for (int i = 0; i < m; i++) {\n                U[i][j] = 0;\n            }\n            U[j][j] = 1;\n        }\n        for (int k = nct - 1; k >= 0; k--) {\n            if (singularValues[k] != 0) {\n                for (int j = k + 1; j < n; j++) {\n                    double t = 0;\n                    for (int i = k; i < m; i++) {\n                        t += U[i][k] * U[i][j];\n                    }\n                    t = -t / U[k][k];\n                    for (int i = k; i < m; i++) {\n                        U[i][j] += t * U[i][k];\n                    }\n                }\n                for (int i = k; i < m; i++) {\n                    U[i][k] = -U[i][k];\n                }\n                U[k][k] = 1 + U[k][k];\n                for (int i = 0; i < k - 1; i++) {\n                    U[i][k] = 0;\n                }\n            } else {\n                for (int i = 0; i < m; i++) {\n                    U[i][k] = 0;\n                }\n                U[k][k] = 1;\n            }\n        }\n\n        // Generate V.\n        for (int k = n - 1; k >= 0; k--) {\n            if (k < nrt &&\n                e[k] != 0) {\n                for (int j = k + 1; j < n; j++) {\n                    double t = 0;\n                    for (int i = k + 1; i < n; i++) {\n                        t += V[i][k] * V[i][j];\n                    }\n                    t = -t / V[k + 1][k];\n                    for (int i = k + 1; i < n; i++) {\n                        V[i][j] += t * V[i][k];\n                    }\n                }\n            }\n            for (int i = 0; i < n; i++) {\n                V[i][k] = 0;\n            }\n            V[k][k] = 1;\n        }\n\n        // Main iteration loop for the singular values.\n        final int pp = p - 1;\n        int iter = 0;\n        while (p > 0) {\n            int k;\n            int kase;\n            // Here is where a test for too many iterations would go.\n            // This section of the program inspects for\n            // negligible elements in the s and e arrays.  On\n            // completion the variables kase and k are set as follows.\n            // kase = 1     if s(p) and e[k-1] are negligible and k<p\n            // kase = 2     if s(k) is negligible and k<p\n            // kase = 3     if e[k-1] is negligible, k<p, and\n            //              s(k), ..., s(p) are not negligible (qr step).\n            // kase = 4     if e(p-1) is negligible (convergence).\n            for (k = p - 2; k >= 0; k--) {\n                final double threshold\n                    = TINY + EPS * (FastMath.abs(singularValues[k]) +\n                                    FastMath.abs(singularValues[k + 1]));\n\n                // the following condition is written this way in order\n                // to break out of the loop when NaN occurs, writing it\n                // as \"if (FastMath.abs(e[k]) <= threshold)\" would loop\n                // indefinitely in case of NaNs because comparison on NaNs\n                // always return false, regardless of what is checked\n                // see issue MATH-947\n                if (!(FastMath.abs(e[k]) > threshold)) {\n                    e[k] = 0;\n                    break;\n                }\n\n            }\n\n            if (k == p - 2) {\n                kase = 4;\n            } else {\n                int ks;\n                for (ks = p - 1; ks >= k; ks--) {\n                    if (ks == k) {\n                        break;\n                    }\n                    final double t = (ks != p ? FastMath.abs(e[ks]) : 0) +\n                        (ks != k + 1 ? FastMath.abs(e[ks - 1]) : 0);\n                    if (FastMath.abs(singularValues[ks]) <= TINY + EPS * t) {\n                        singularValues[ks] = 0;\n                        break;\n                    }\n                }\n                if (ks == k) {\n                    kase = 3;\n                } else if (ks == p - 1) {\n                    kase = 1;\n                } else {\n                    kase = 2;\n                    k = ks;\n                }\n            }\n            k++;\n            // Perform the task indicated by kase.\n            switch (kase) {\n                // Deflate negligible s(p).\n                case 1: {\n                    double f = e[p - 2];\n                    e[p - 2] = 0;\n                    for (int j = p - 2; j >= k; j--) {\n                        double t = FastMath.hypot(singularValues[j], f);\n                        final double cs = singularValues[j] / t;\n                        final double sn = f / t;\n                        singularValues[j] = t;\n                        if (j != k) {\n                            f = -sn * e[j - 1];\n                            e[j - 1] = cs * e[j - 1];\n                        }\n\n                        for (int i = 0; i < n; i++) {\n                            t = cs * V[i][j] + sn * V[i][p - 1];\n                            V[i][p - 1] = -sn * V[i][j] + cs * V[i][p - 1];\n                            V[i][j] = t;\n                        }\n                    }\n                }\n                break;\n                // Split at negligible s(k).\n                case 2: {\n                    double f = e[k - 1];\n                    e[k - 1] = 0;\n                    for (int j = k; j < p; j++) {\n                        double t = FastMath.hypot(singularValues[j], f);\n                        final double cs = singularValues[j] / t;\n                        final double sn = f / t;\n                        singularValues[j] = t;\n                        f = -sn * e[j];\n                        e[j] = cs * e[j];\n\n                        for (int i = 0; i < m; i++) {\n                            t = cs * U[i][j] + sn * U[i][k - 1];\n                            U[i][k - 1] = -sn * U[i][j] + cs * U[i][k - 1];\n                            U[i][j] = t;\n                        }\n                    }\n                }\n                break;\n                // Perform one qr step.\n                case 3: {\n                    // Calculate the shift.\n                    final double maxPm1Pm2 = FastMath.max(FastMath.abs(singularValues[p - 1]),\n                                                          FastMath.abs(singularValues[p - 2]));\n                    final double scale = FastMath.max(FastMath.max(FastMath.max(maxPm1Pm2,\n                                                                                FastMath.abs(e[p - 2])),\n                                                                   FastMath.abs(singularValues[k])),\n                                                      FastMath.abs(e[k]));\n                    final double sp = singularValues[p - 1] / scale;\n                    final double spm1 = singularValues[p - 2] / scale;\n                    final double epm1 = e[p - 2] / scale;\n                    final double sk = singularValues[k] / scale;\n                    final double ek = e[k] / scale;\n                    final double b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2.0;\n                    final double c = (sp * epm1) * (sp * epm1);\n                    double shift = 0;\n                    if (b != 0 ||\n                        c != 0) {\n                        shift = FastMath.sqrt(b * b + c);\n                        if (b < 0) {\n                            shift = -shift;\n                        }\n                        shift = c / (b + shift);\n                    }\n                    double f = (sk + sp) * (sk - sp) + shift;\n                    double g = sk * ek;\n                    // Chase zeros.\n                    for (int j = k; j < p - 1; j++) {\n                        double t = FastMath.hypot(f, g);\n                        double cs = f / t;\n                        double sn = g / t;\n                        if (j != k) {\n                            e[j - 1] = t;\n                        }\n                        f = cs * singularValues[j] + sn * e[j];\n                        e[j] = cs * e[j] - sn * singularValues[j];\n                        g = sn * singularValues[j + 1];\n                        singularValues[j + 1] = cs * singularValues[j + 1];\n\n                        for (int i = 0; i < n; i++) {\n                            t = cs * V[i][j] + sn * V[i][j + 1];\n                            V[i][j + 1] = -sn * V[i][j] + cs * V[i][j + 1];\n                            V[i][j] = t;\n                        }\n                        t = FastMath.hypot(f, g);\n                        cs = f / t;\n                        sn = g / t;\n                        singularValues[j] = t;\n                        f = cs * e[j] + sn * singularValues[j + 1];\n                        singularValues[j + 1] = -sn * e[j] + cs * singularValues[j + 1];\n                        g = sn * e[j + 1];\n                        e[j + 1] = cs * e[j + 1];\n                        if (j < m - 1) {\n                            for (int i = 0; i < m; i++) {\n                                t = cs * U[i][j] + sn * U[i][j + 1];\n                                U[i][j + 1] = -sn * U[i][j] + cs * U[i][j + 1];\n                                U[i][j] = t;\n                            }\n                        }\n                    }\n                    e[p - 2] = f;\n                    iter = iter + 1;\n                }\n                break;\n                // Convergence.\n                default: {\n                    // Make the singular values positive.\n                    if (singularValues[k] <= 0) {\n                        singularValues[k] = singularValues[k] < 0 ? -singularValues[k] : 0;\n\n                        for (int i = 0; i <= pp; i++) {\n                            V[i][k] = -V[i][k];\n                        }\n                    }\n                    // Order the singular values.\n                    while (k < pp) {\n                        if (singularValues[k] >= singularValues[k + 1]) {\n                            break;\n                        }\n                        double t = singularValues[k];\n                        singularValues[k] = singularValues[k + 1];\n                        singularValues[k + 1] = t;\n                        if (k < n - 1) {\n                            for (int i = 0; i < n; i++) {\n                                t = V[i][k + 1];\n                                V[i][k + 1] = V[i][k];\n                                V[i][k] = t;\n                            }\n                        }\n                        if (k < m - 1) {\n                            for (int i = 0; i < m; i++) {\n                                t = U[i][k + 1];\n                                U[i][k + 1] = U[i][k];\n                                U[i][k] = t;\n                            }\n                        }\n                        k++;\n                    }\n                    iter = 0;\n                    p--;\n                }\n                break;\n            }\n        }\n\n        // Set the small value tolerance used to calculate rank and pseudo-inverse\n        tol = FastMath.max(m * singularValues[0] * EPS,\n                           FastMath.sqrt(Precision.SAFE_MIN));\n\n        if (!transposed) {\n            cachedU = MatrixUtils.createRealMatrix(U);\n            cachedV = MatrixUtils.createRealMatrix(V);\n        } else {\n            cachedU = MatrixUtils.createRealMatrix(V);\n            cachedV = MatrixUtils.createRealMatrix(U);\n        }\n    }",
          "2": "    public SingularValueDecomposition(final RealMatrix matrix) {\n        final double[][] A;\n\n         // \"m\" is always the largest dimension.\n        if (matrix.getRowDimension() < matrix.getColumnDimension()) {\n            transposed = true;\n            A = matrix.transpose().getData();\n            m = matrix.getColumnDimension();\n            n = matrix.getRowDimension();\n        } else {\n            transposed = false;\n            A = matrix.getData();\n            m = matrix.getRowDimension();\n            n = matrix.getColumnDimension();\n        }\n\n        singularValues = new double[n];\n        final double[][] U = new double[m][n];\n        final double[][] V = new double[n][n];\n        final double[] e = new double[n];\n        final double[] work = new double[m];\n        // Reduce A to bidiagonal form, storing the diagonal elements\n        // in s and the super-diagonal elements in e.\n        final int nct = FastMath.min(m - 1, n);\n        final int nrt = FastMath.max(0, n - 2);\n        for (int k = 0; k < FastMath.max(nct, nrt); k++) {\n            if (k < nct) {\n                // Compute the transformation for the k-th column and\n                // place the k-th diagonal in s[k].\n                // Compute 2-norm of k-th column without under/overflow.\n                singularValues[k] = 0;\n                for (int i = k; i < m; i++) {\n                    singularValues[k] = FastMath.hypot(singularValues[k], A[i][k]);\n                }\n                if (singularValues[k] != 0) {\n                    if (A[k][k] < 0) {\nsingularValues[k] = TINY[k];\n                    }\n                    for (int i = k; i < m; i++) {\n                        A[i][k] /= singularValues[k];\n                    }\n                    A[k][k] += 1;\n                }\n                singularValues[k] = -singularValues[k];\n            }\n            for (int j = k + 1; j < n; j++) {\n                if (k < nct &&\n                    singularValues[k] != 0) {\n                    // Apply the transformation.\n                    double t = 0;\n                    for (int i = k; i < m; i++) {\n                        t += A[i][k] * A[i][j];\n                    }\n                    t = -t / A[k][k];\n                    for (int i = k; i < m; i++) {\n                        A[i][j] += t * A[i][k];\n                    }\n                }\n                // Place the k-th row of A into e for the\n                // subsequent calculation of the row transformation.\n                e[j] = A[k][j];\n            }\n            if (k < nct) {\n                // Place the transformation in U for subsequent back\n                // multiplication.\n                for (int i = k; i < m; i++) {\n                    U[i][k] = A[i][k];\n                }\n            }\n            if (k < nrt) {\n                // Compute the k-th row transformation and place the\n                // k-th super-diagonal in e[k].\n                // Compute 2-norm without under/overflow.\n                e[k] = 0;\n                for (int i = k + 1; i < n; i++) {\n                    e[k] = FastMath.hypot(e[k], e[i]);\n                }\n                if (e[k] != 0) {\n                    if (e[k + 1] < 0) {\n                        e[k] = -e[k];\n                    }\n                    for (int i = k + 1; i < n; i++) {\n                        e[i] /= e[k];\n                    }\n                    e[k + 1] += 1;\n                }\n                e[k] = -e[k];\n                if (k + 1 < m &&\n                    e[k] != 0) {\n                    // Apply the transformation.\n                    for (int i = k + 1; i < m; i++) {\n                        work[i] = 0;\n                    }\n                    for (int j = k + 1; j < n; j++) {\n                        for (int i = k + 1; i < m; i++) {\n                            work[i] += e[j] * A[i][j];\n                        }\n                    }\n                    for (int j = k + 1; j < n; j++) {\n                        final double t = -e[j] / e[k + 1];\n                        for (int i = k + 1; i < m; i++) {\n                            A[i][j] += t * work[i];\n                        }\n                    }\n                }\n\n                // Place the transformation in V for subsequent\n                // back multiplication.\n                for (int i = k + 1; i < n; i++) {\n                    V[i][k] = e[i];\n                }\n            }\n        }\n        // Set up the final bidiagonal matrix or order p.\n        int p = n;\n        if (nct < n) {\n            singularValues[nct] = A[nct][nct];\n        }\n        if (m < p) {\n            singularValues[p - 1] = 0;\n        }\n        if (nrt + 1 < p) {\n            e[nrt] = A[nrt][p - 1];\n        }\n        e[p - 1] = 0;\n\n        // Generate U.\n        for (int j = nct; j < n; j++) {\n            for (int i = 0; i < m; i++) {\n                U[i][j] = 0;\n            }\n            U[j][j] = 1;\n        }\n        for (int k = nct - 1; k >= 0; k--) {\n            if (singularValues[k] != 0) {\n                for (int j = k + 1; j < n; j++) {\n                    double t = 0;\n                    for (int i = k; i < m; i++) {\n                        t += U[i][k] * U[i][j];\n                    }\n                    t = -t / U[k][k];\n                    for (int i = k; i < m; i++) {\n                        U[i][j] += t * U[i][k];\n                    }\n                }\n                for (int i = k; i < m; i++) {\n                    U[i][k] = -U[i][k];\n                }\n                U[k][k] = 1 + U[k][k];\n                for (int i = 0; i < k - 1; i++) {\n                    U[i][k] = 0;\n                }\n            } else {\n                for (int i = 0; i < m; i++) {\n                    U[i][k] = 0;\n                }\n                U[k][k] = 1;\n            }\n        }\n\n        // Generate V.\n        for (int k = n - 1; k >= 0; k--) {\n            if (k < nrt &&\n                e[k] != 0) {\n                for (int j = k + 1; j < n; j++) {\n                    double t = 0;\n                    for (int i = k + 1; i < n; i++) {\n                        t += V[i][k] * V[i][j];\n                    }\n                    t = -t / V[k + 1][k];\n                    for (int i = k + 1; i < n; i++) {\n                        V[i][j] += t * V[i][k];\n                    }\n                }\n            }\n            for (int i = 0; i < n; i++) {\n                V[i][k] = 0;\n            }\n            V[k][k] = 1;\n        }\n\n        // Main iteration loop for the singular values.\n        final int pp = p - 1;\n        int iter = 0;\n        while (p > 0) {\n            int k;\n            int kase;\n            // Here is where a test for too many iterations would go.\n            // This section of the program inspects for\n            // negligible elements in the s and e arrays.  On\n            // completion the variables kase and k are set as follows.\n            // kase = 1     if s(p) and e[k-1] are negligible and k<p\n            // kase = 2     if s(k) is negligible and k<p\n            // kase = 3     if e[k-1] is negligible, k<p, and\n            //              s(k), ..., s(p) are not negligible (qr step).\n            // kase = 4     if e(p-1) is negligible (convergence).\n            for (k = p - 2; k >= 0; k--) {\n                final double threshold\n                    = TINY + EPS * (FastMath.abs(singularValues[k]) +\n                                    FastMath.abs(singularValues[k + 1]));\n\n                // the following condition is written this way in order\n                // to break out of the loop when NaN occurs, writing it\n                // as \"if (FastMath.abs(e[k]) <= threshold)\" would loop\n                // indefinitely in case of NaNs because comparison on NaNs\n                // always return false, regardless of what is checked\n                // see issue MATH-947\n                if (!(FastMath.abs(e[k]) > threshold)) {\n                    e[k] = 0;\n                    break;\n                }\n\n            }\n\n            if (k == p - 2) {\n                kase = 4;\n            } else {\n                int ks;\n                for (ks = p - 1; ks >= k; ks--) {\n                    if (ks == k) {\n                        break;\n                    }\n                    final double t = (ks != p ? FastMath.abs(e[ks]) : 0) +\n                        (ks != k + 1 ? FastMath.abs(e[ks - 1]) : 0);\n                    if (FastMath.abs(singularValues[ks]) <= TINY + EPS * t) {\n                        singularValues[ks] = 0;\n                        break;\n                    }\n                }\n                if (ks == k) {\n                    kase = 3;\n                } else if (ks == p - 1) {\n                    kase = 1;\n                } else {\n                    kase = 2;\n                    k = ks;\n                }\n            }\n            k++;\n            // Perform the task indicated by kase.\n            switch (kase) {\n                // Deflate negligible s(p).\n                case 1: {\n                    double f = e[p - 2];\n                    e[p - 2] = 0;\n                    for (int j = p - 2; j >= k; j--) {\n                        double t = FastMath.hypot(singularValues[j], f);\n                        final double cs = singularValues[j] / t;\n                        final double sn = f / t;\n                        singularValues[j] = t;\n                        if (j != k) {\n                            f = -sn * e[j - 1];\n                            e[j - 1] = cs * e[j - 1];\n                        }\n\n                        for (int i = 0; i < n; i++) {\n                            t = cs * V[i][j] + sn * V[i][p - 1];\n                            V[i][p - 1] = -sn * V[i][j] + cs * V[i][p - 1];\n                            V[i][j] = t;\n                        }\n                    }\n                }\n                break;\n                // Split at negligible s(k).\n                case 2: {\n                    double f = e[k - 1];\n                    e[k - 1] = 0;\n                    for (int j = k; j < p; j++) {\n                        double t = FastMath.hypot(singularValues[j], f);\n                        final double cs = singularValues[j] / t;\n                        final double sn = f / t;\n                        singularValues[j] = t;\n                        f = -sn * e[j];\n                        e[j] = cs * e[j];\n\n                        for (int i = 0; i < m; i++) {\n                            t = cs * U[i][j] + sn * U[i][k - 1];\n                            U[i][k - 1] = -sn * U[i][j] + cs * U[i][k - 1];\n                            U[i][j] = t;\n                        }\n                    }\n                }\n                break;\n                // Perform one qr step.\n                case 3: {\n                    // Calculate the shift.\n                    final double maxPm1Pm2 = FastMath.max(FastMath.abs(singularValues[p - 1]),\n                                                          FastMath.abs(singularValues[p - 2]));\n                    final double scale = FastMath.max(FastMath.max(FastMath.max(maxPm1Pm2,\n                                                                                FastMath.abs(e[p - 2])),\n                                                                   FastMath.abs(singularValues[k])),\n                                                      FastMath.abs(e[k]));\n                    final double sp = singularValues[p - 1] / scale;\n                    final double spm1 = singularValues[p - 2] / scale;\n                    final double epm1 = e[p - 2] / scale;\n                    final double sk = singularValues[k] / scale;\n                    final double ek = e[k] / scale;\n                    final double b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2.0;\n                    final double c = (sp * epm1) * (sp * epm1);\n                    double shift = 0;\n                    if (b != 0 ||\n                        c != 0) {\n                        shift = FastMath.sqrt(b * b + c);\n                        if (b < 0) {\n                            shift = -shift;\n                        }\n                        shift = c / (b + shift);\n                    }\n                    double f = (sk + sp) * (sk - sp) + shift;\n                    double g = sk * ek;\n                    // Chase zeros.\n                    for (int j = k; j < p - 1; j++) {\n                        double t = FastMath.hypot(f, g);\n                        double cs = f / t;\n                        double sn = g / t;\n                        if (j != k) {\n                            e[j - 1] = t;\n                        }\n                        f = cs * singularValues[j] + sn * e[j];\n                        e[j] = cs * e[j] - sn * singularValues[j];\n                        g = sn * singularValues[j + 1];\n                        singularValues[j + 1] = cs * singularValues[j + 1];\n\n                        for (int i = 0; i < n; i++) {\n                            t = cs * V[i][j] + sn * V[i][j + 1];\n                            V[i][j + 1] = -sn * V[i][j] + cs * V[i][j + 1];\n                            V[i][j] = t;\n                        }\n                        t = FastMath.hypot(f, g);\n                        cs = f / t;\n                        sn = g / t;\n                        singularValues[j] = t;\n                        f = cs * e[j] + sn * singularValues[j + 1];\n                        singularValues[j + 1] = -sn * e[j] + cs * singularValues[j + 1];\n                        g = sn * e[j + 1];\n                        e[j + 1] = cs * e[j + 1];\n                        if (j < m - 1) {\n                            for (int i = 0; i < m; i++) {\n                                t = cs * U[i][j] + sn * U[i][j + 1];\n                                U[i][j + 1] = -sn * U[i][j] + cs * U[i][j + 1];\n                                U[i][j] = t;\n                            }\n                        }\n                    }\n                    e[p - 2] = f;\n                    iter = iter + 1;\n                }\n                break;\n                // Convergence.\n                default: {\n                    // Make the singular values positive.\n                    if (singularValues[k] <= 0) {\n                        singularValues[k] = singularValues[k] < 0 ? -singularValues[k] : 0;\n\n                        for (int i = 0; i <= pp; i++) {\n                            V[i][k] = -V[i][k];\n                        }\n                    }\n                    // Order the singular values.\n                    while (k < pp) {\n                        if (singularValues[k] >= singularValues[k + 1]) {\n                            break;\n                        }\n                        double t = singularValues[k];\n                        singularValues[k] = singularValues[k + 1];\n                        singularValues[k + 1] = t;\n                        if (k < n - 1) {\n                            for (int i = 0; i < n; i++) {\n                                t = V[i][k + 1];\n                                V[i][k + 1] = V[i][k];\n                                V[i][k] = t;\n                            }\n                        }\n                        if (k < m - 1) {\n                            for (int i = 0; i < m; i++) {\n                                t = U[i][k + 1];\n                                U[i][k + 1] = U[i][k];\n                                U[i][k] = t;\n                            }\n                        }\n                        k++;\n                    }\n                    iter = 0;\n                    p--;\n                }\n                break;\n            }\n        }\n\n        // Set the small value tolerance used to calculate rank and pseudo-inverse\n        tol = FastMath.max(m * singularValues[0] * EPS,\n                           FastMath.sqrt(Precision.SAFE_MIN));\n\n        if (!transposed) {\n            cachedU = MatrixUtils.createRealMatrix(U);\n            cachedV = MatrixUtils.createRealMatrix(V);\n        } else {\n            cachedU = MatrixUtils.createRealMatrix(V);\n            cachedV = MatrixUtils.createRealMatrix(U);\n        }\n    }",
          "3": "    public SingularValueDecomposition(final RealMatrix matrix) {\n        final double[][] A;\n\n         // \"m\" is always the largest dimension.\n        if (matrix.getRowDimension() < matrix.getColumnDimension()) {\n            transposed = true;\n            A = matrix.transpose().getData();\n            m = matrix.getColumnDimension();\n            n = matrix.getRowDimension();\n        } else {\n            transposed = false;\n            A = matrix.getData();\n            m = matrix.getRowDimension();\n            n = matrix.getColumnDimension();\n        }\n\n        singularValues = new double[n];\n        final double[][] U = new double[m][n];\n        final double[][] V = new double[n][n];\n        final double[] e = new double[n];\n        final double[] work = new double[m];\n        // Reduce A to bidiagonal form, storing the diagonal elements\n        // in s and the super-diagonal elements in e.\n        final int nct = FastMath.min(m - 1, n);\n        final int nrt = FastMath.max(0, n - 2);\n        for (int k = 0; k < FastMath.max(nct, nrt); k++) {\n            if (k < nct) {\n                // Compute the transformation for the k-th column and\n                // place the k-th diagonal in s[k].\n                // Compute 2-norm of k-th column without under/overflow.\n                singularValues[k] = 0;\n                for (int i = k; i < m; i++) {\n                    singularValues[k] = FastMath.hypot(singularValues[k], A[i][k]);\n                }\n                if (singularValues[k] != 0) {\n                    if (A[k][k] < 0) {\nsingularValues[k] = singularValues[k];\n                    }\n                    for (int i = k; i < m; i++) {\n                        A[i][k] /= singularValues[k];\n                    }\n                    A[k][k] += 1;\n                }\n                singularValues[k] = -singularValues[k];\n            }\n            for (int j = k + 1; j < n; j++) {\n                if (k < nct &&\n                    singularValues[k] != 0) {\n                    // Apply the transformation.\n                    double t = 0;\n                    for (int i = k; i < m; i++) {\n                        t += A[i][k] * A[i][j];\n                    }\n                    t = -t / A[k][k];\n                    for (int i = k; i < m; i++) {\n                        A[i][j] += t * A[i][k];\n                    }\n                }\n                // Place the k-th row of A into e for the\n                // subsequent calculation of the row transformation.\n                e[j] = A[k][j];\n            }\n            if (k < nct) {\n                // Place the transformation in U for subsequent back\n                // multiplication.\n                for (int i = k; i < m; i++) {\n                    U[i][k] = A[i][k];\n                }\n            }\n            if (k < nrt) {\n                // Compute the k-th row transformation and place the\n                // k-th super-diagonal in e[k].\n                // Compute 2-norm without under/overflow.\n                e[k] = 0;\n                for (int i = k + 1; i < n; i++) {\n                    e[k] = FastMath.hypot(e[k], e[i]);\n                }\n                if (e[k] != 0) {\n                    if (e[k + 1] < 0) {\n                        e[k] = -e[k];\n                    }\n                    for (int i = k + 1; i < n; i++) {\n                        e[i] /= e[k];\n                    }\n                    e[k + 1] += 1;\n                }\n                e[k] = -e[k];\n                if (k + 1 < m &&\n                    e[k] != 0) {\n                    // Apply the transformation.\n                    for (int i = k + 1; i < m; i++) {\n                        work[i] = 0;\n                    }\n                    for (int j = k + 1; j < n; j++) {\n                        for (int i = k + 1; i < m; i++) {\n                            work[i] += e[j] * A[i][j];\n                        }\n                    }\n                    for (int j = k + 1; j < n; j++) {\n                        final double t = -e[j] / e[k + 1];\n                        for (int i = k + 1; i < m; i++) {\n                            A[i][j] += t * work[i];\n                        }\n                    }\n                }\n\n                // Place the transformation in V for subsequent\n                // back multiplication.\n                for (int i = k + 1; i < n; i++) {\n                    V[i][k] = e[i];\n                }\n            }\n        }\n        // Set up the final bidiagonal matrix or order p.\n        int p = n;\n        if (nct < n) {\n            singularValues[nct] = A[nct][nct];\n        }\n        if (m < p) {\n            singularValues[p - 1] = 0;\n        }\n        if (nrt + 1 < p) {\n            e[nrt] = A[nrt][p - 1];\n        }\n        e[p - 1] = 0;\n\n        // Generate U.\n        for (int j = nct; j < n; j++) {\n            for (int i = 0; i < m; i++) {\n                U[i][j] = 0;\n            }\n            U[j][j] = 1;\n        }\n        for (int k = nct - 1; k >= 0; k--) {\n            if (singularValues[k] != 0) {\n                for (int j = k + 1; j < n; j++) {\n                    double t = 0;\n                    for (int i = k; i < m; i++) {\n                        t += U[i][k] * U[i][j];\n                    }\n                    t = -t / U[k][k];\n                    for (int i = k; i < m; i++) {\n                        U[i][j] += t * U[i][k];\n                    }\n                }\n                for (int i = k; i < m; i++) {\n                    U[i][k] = -U[i][k];\n                }\n                U[k][k] = 1 + U[k][k];\n                for (int i = 0; i < k - 1; i++) {\n                    U[i][k] = 0;\n                }\n            } else {\n                for (int i = 0; i < m; i++) {\n                    U[i][k] = 0;\n                }\n                U[k][k] = 1;\n            }\n        }\n\n        // Generate V.\n        for (int k = n - 1; k >= 0; k--) {\n            if (k < nrt &&\n                e[k] != 0) {\n                for (int j = k + 1; j < n; j++) {\n                    double t = 0;\n                    for (int i = k + 1; i < n; i++) {\n                        t += V[i][k] * V[i][j];\n                    }\n                    t = -t / V[k + 1][k];\n                    for (int i = k + 1; i < n; i++) {\n                        V[i][j] += t * V[i][k];\n                    }\n                }\n            }\n            for (int i = 0; i < n; i++) {\n                V[i][k] = 0;\n            }\n            V[k][k] = 1;\n        }\n\n        // Main iteration loop for the singular values.\n        final int pp = p - 1;\n        int iter = 0;\n        while (p > 0) {\n            int k;\n            int kase;\n            // Here is where a test for too many iterations would go.\n            // This section of the program inspects for\n            // negligible elements in the s and e arrays.  On\n            // completion the variables kase and k are set as follows.\n            // kase = 1     if s(p) and e[k-1] are negligible and k<p\n            // kase = 2     if s(k) is negligible and k<p\n            // kase = 3     if e[k-1] is negligible, k<p, and\n            //              s(k), ..., s(p) are not negligible (qr step).\n            // kase = 4     if e(p-1) is negligible (convergence).\n            for (k = p - 2; k >= 0; k--) {\n                final double threshold\n                    = TINY + EPS * (FastMath.abs(singularValues[k]) +\n                                    FastMath.abs(singularValues[k + 1]));\n\n                // the following condition is written this way in order\n                // to break out of the loop when NaN occurs, writing it\n                // as \"if (FastMath.abs(e[k]) <= threshold)\" would loop\n                // indefinitely in case of NaNs because comparison on NaNs\n                // always return false, regardless of what is checked\n                // see issue MATH-947\n                if (!(FastMath.abs(e[k]) > threshold)) {\n                    e[k] = 0;\n                    break;\n                }\n\n            }\n\n            if (k == p - 2) {\n                kase = 4;\n            } else {\n                int ks;\n                for (ks = p - 1; ks >= k; ks--) {\n                    if (ks == k) {\n                        break;\n                    }\n                    final double t = (ks != p ? FastMath.abs(e[ks]) : 0) +\n                        (ks != k + 1 ? FastMath.abs(e[ks - 1]) : 0);\n                    if (FastMath.abs(singularValues[ks]) <= TINY + EPS * t) {\n                        singularValues[ks] = 0;\n                        break;\n                    }\n                }\n                if (ks == k) {\n                    kase = 3;\n                } else if (ks == p - 1) {\n                    kase = 1;\n                } else {\n                    kase = 2;\n                    k = ks;\n                }\n            }\n            k++;\n            // Perform the task indicated by kase.\n            switch (kase) {\n                // Deflate negligible s(p).\n                case 1: {\n                    double f = e[p - 2];\n                    e[p - 2] = 0;\n                    for (int j = p - 2; j >= k; j--) {\n                        double t = FastMath.hypot(singularValues[j], f);\n                        final double cs = singularValues[j] / t;\n                        final double sn = f / t;\n                        singularValues[j] = t;\n                        if (j != k) {\n                            f = -sn * e[j - 1];\n                            e[j - 1] = cs * e[j - 1];\n                        }\n\n                        for (int i = 0; i < n; i++) {\n                            t = cs * V[i][j] + sn * V[i][p - 1];\n                            V[i][p - 1] = -sn * V[i][j] + cs * V[i][p - 1];\n                            V[i][j] = t;\n                        }\n                    }\n                }\n                break;\n                // Split at negligible s(k).\n                case 2: {\n                    double f = e[k - 1];\n                    e[k - 1] = 0;\n                    for (int j = k; j < p; j++) {\n                        double t = FastMath.hypot(singularValues[j], f);\n                        final double cs = singularValues[j] / t;\n                        final double sn = f / t;\n                        singularValues[j] = t;\n                        f = -sn * e[j];\n                        e[j] = cs * e[j];\n\n                        for (int i = 0; i < m; i++) {\n                            t = cs * U[i][j] + sn * U[i][k - 1];\n                            U[i][k - 1] = -sn * U[i][j] + cs * U[i][k - 1];\n                            U[i][j] = t;\n                        }\n                    }\n                }\n                break;\n                // Perform one qr step.\n                case 3: {\n                    // Calculate the shift.\n                    final double maxPm1Pm2 = FastMath.max(FastMath.abs(singularValues[p - 1]),\n                                                          FastMath.abs(singularValues[p - 2]));\n                    final double scale = FastMath.max(FastMath.max(FastMath.max(maxPm1Pm2,\n                                                                                FastMath.abs(e[p - 2])),\n                                                                   FastMath.abs(singularValues[k])),\n                                                      FastMath.abs(e[k]));\n                    final double sp = singularValues[p - 1] / scale;\n                    final double spm1 = singularValues[p - 2] / scale;\n                    final double epm1 = e[p - 2] / scale;\n                    final double sk = singularValues[k] / scale;\n                    final double ek = e[k] / scale;\n                    final double b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2.0;\n                    final double c = (sp * epm1) * (sp * epm1);\n                    double shift = 0;\n                    if (b != 0 ||\n                        c != 0) {\n                        shift = FastMath.sqrt(b * b + c);\n                        if (b < 0) {\n                            shift = -shift;\n                        }\n                        shift = c / (b + shift);\n                    }\n                    double f = (sk + sp) * (sk - sp) + shift;\n                    double g = sk * ek;\n                    // Chase zeros.\n                    for (int j = k; j < p - 1; j++) {\n                        double t = FastMath.hypot(f, g);\n                        double cs = f / t;\n                        double sn = g / t;\n                        if (j != k) {\n                            e[j - 1] = t;\n                        }\n                        f = cs * singularValues[j] + sn * e[j];\n                        e[j] = cs * e[j] - sn * singularValues[j];\n                        g = sn * singularValues[j + 1];\n                        singularValues[j + 1] = cs * singularValues[j + 1];\n\n                        for (int i = 0; i < n; i++) {\n                            t = cs * V[i][j] + sn * V[i][j + 1];\n                            V[i][j + 1] = -sn * V[i][j] + cs * V[i][j + 1];\n                            V[i][j] = t;\n                        }\n                        t = FastMath.hypot(f, g);\n                        cs = f / t;\n                        sn = g / t;\n                        singularValues[j] = t;\n                        f = cs * e[j] + sn * singularValues[j + 1];\n                        singularValues[j + 1] = -sn * e[j] + cs * singularValues[j + 1];\n                        g = sn * e[j + 1];\n                        e[j + 1] = cs * e[j + 1];\n                        if (j < m - 1) {\n                            for (int i = 0; i < m; i++) {\n                                t = cs * U[i][j] + sn * U[i][j + 1];\n                                U[i][j + 1] = -sn * U[i][j] + cs * U[i][j + 1];\n                                U[i][j] = t;\n                            }\n                        }\n                    }\n                    e[p - 2] = f;\n                    iter = iter + 1;\n                }\n                break;\n                // Convergence.\n                default: {\n                    // Make the singular values positive.\n                    if (singularValues[k] <= 0) {\n                        singularValues[k] = singularValues[k] < 0 ? -singularValues[k] : 0;\n\n                        for (int i = 0; i <= pp; i++) {\n                            V[i][k] = -V[i][k];\n                        }\n                    }\n                    // Order the singular values.\n                    while (k < pp) {\n                        if (singularValues[k] >= singularValues[k + 1]) {\n                            break;\n                        }\n                        double t = singularValues[k];\n                        singularValues[k] = singularValues[k + 1];\n                        singularValues[k + 1] = t;\n                        if (k < n - 1) {\n                            for (int i = 0; i < n; i++) {\n                                t = V[i][k + 1];\n                                V[i][k + 1] = V[i][k];\n                                V[i][k] = t;\n                            }\n                        }\n                        if (k < m - 1) {\n                            for (int i = 0; i < m; i++) {\n                                t = U[i][k + 1];\n                                U[i][k + 1] = U[i][k];\n                                U[i][k] = t;\n                            }\n                        }\n                        k++;\n                    }\n                    iter = 0;\n                    p--;\n                }\n                break;\n            }\n        }\n\n        // Set the small value tolerance used to calculate rank and pseudo-inverse\n        tol = FastMath.max(m * singularValues[0] * EPS,\n                           FastMath.sqrt(Precision.SAFE_MIN));\n\n        if (!transposed) {\n            cachedU = MatrixUtils.createRealMatrix(U);\n            cachedV = MatrixUtils.createRealMatrix(V);\n        } else {\n            cachedU = MatrixUtils.createRealMatrix(V);\n            cachedV = MatrixUtils.createRealMatrix(U);\n        }\n    }",
          "4": "    public SingularValueDecomposition(final RealMatrix matrix) {\n        final double[][] A;\n\n         // \"m\" is always the largest dimension.\n        if (matrix.getRowDimension() < matrix.getColumnDimension()) {\n            transposed = true;\n            A = matrix.transpose().getData();\n            m = matrix.getColumnDimension();\n            n = matrix.getRowDimension();\n        } else {\n            transposed = false;\n            A = matrix.getData();\n            m = matrix.getRowDimension();\n            n = matrix.getColumnDimension();\n        }\n\n        singularValues = new double[n];\n        final double[][] U = new double[m][n];\n        final double[][] V = new double[n][n];\n        final double[] e = new double[n];\n        final double[] work = new double[m];\n        // Reduce A to bidiagonal form, storing the diagonal elements\n        // in s and the super-diagonal elements in e.\n        final int nct = FastMath.min(m - 1, n);\n        final int nrt = FastMath.max(0, n - 2);\n        for (int k = 0; k < FastMath.max(nct, nrt); k++) {\n            if (k < nct) {\n                // Compute the transformation for the k-th column and\n                // place the k-th diagonal in s[k].\n                // Compute 2-norm of k-th column without under/overflow.\n                singularValues[k] = 0;\n                for (int i = k; i < m; i++) {\n                    singularValues[k] = FastMath.hypot(singularValues[k], A[i][k]);\n                }\n                if (singularValues[k] != 0) {\n                    if (A[k][k] < 0) {\nsingularValues[k] = tol[k];\n                    }\n                    for (int i = k; i < m; i++) {\n                        A[i][k] /= singularValues[k];\n                    }\n                    A[k][k] += 1;\n                }\n                singularValues[k] = -singularValues[k];\n            }\n            for (int j = k + 1; j < n; j++) {\n                if (k < nct &&\n                    singularValues[k] != 0) {\n                    // Apply the transformation.\n                    double t = 0;\n                    for (int i = k; i < m; i++) {\n                        t += A[i][k] * A[i][j];\n                    }\n                    t = -t / A[k][k];\n                    for (int i = k; i < m; i++) {\n                        A[i][j] += t * A[i][k];\n                    }\n                }\n                // Place the k-th row of A into e for the\n                // subsequent calculation of the row transformation.\n                e[j] = A[k][j];\n            }\n            if (k < nct) {\n                // Place the transformation in U for subsequent back\n                // multiplication.\n                for (int i = k; i < m; i++) {\n                    U[i][k] = A[i][k];\n                }\n            }\n            if (k < nrt) {\n                // Compute the k-th row transformation and place the\n                // k-th super-diagonal in e[k].\n                // Compute 2-norm without under/overflow.\n                e[k] = 0;\n                for (int i = k + 1; i < n; i++) {\n                    e[k] = FastMath.hypot(e[k], e[i]);\n                }\n                if (e[k] != 0) {\n                    if (e[k + 1] < 0) {\n                        e[k] = -e[k];\n                    }\n                    for (int i = k + 1; i < n; i++) {\n                        e[i] /= e[k];\n                    }\n                    e[k + 1] += 1;\n                }\n                e[k] = -e[k];\n                if (k + 1 < m &&\n                    e[k] != 0) {\n                    // Apply the transformation.\n                    for (int i = k + 1; i < m; i++) {\n                        work[i] = 0;\n                    }\n                    for (int j = k + 1; j < n; j++) {\n                        for (int i = k + 1; i < m; i++) {\n                            work[i] += e[j] * A[i][j];\n                        }\n                    }\n                    for (int j = k + 1; j < n; j++) {\n                        final double t = -e[j] / e[k + 1];\n                        for (int i = k + 1; i < m; i++) {\n                            A[i][j] += t * work[i];\n                        }\n                    }\n                }\n\n                // Place the transformation in V for subsequent\n                // back multiplication.\n                for (int i = k + 1; i < n; i++) {\n                    V[i][k] = e[i];\n                }\n            }\n        }\n        // Set up the final bidiagonal matrix or order p.\n        int p = n;\n        if (nct < n) {\n            singularValues[nct] = A[nct][nct];\n        }\n        if (m < p) {\n            singularValues[p - 1] = 0;\n        }\n        if (nrt + 1 < p) {\n            e[nrt] = A[nrt][p - 1];\n        }\n        e[p - 1] = 0;\n\n        // Generate U.\n        for (int j = nct; j < n; j++) {\n            for (int i = 0; i < m; i++) {\n                U[i][j] = 0;\n            }\n            U[j][j] = 1;\n        }\n        for (int k = nct - 1; k >= 0; k--) {\n            if (singularValues[k] != 0) {\n                for (int j = k + 1; j < n; j++) {\n                    double t = 0;\n                    for (int i = k; i < m; i++) {\n                        t += U[i][k] * U[i][j];\n                    }\n                    t = -t / U[k][k];\n                    for (int i = k; i < m; i++) {\n                        U[i][j] += t * U[i][k];\n                    }\n                }\n                for (int i = k; i < m; i++) {\n                    U[i][k] = -U[i][k];\n                }\n                U[k][k] = 1 + U[k][k];\n                for (int i = 0; i < k - 1; i++) {\n                    U[i][k] = 0;\n                }\n            } else {\n                for (int i = 0; i < m; i++) {\n                    U[i][k] = 0;\n                }\n                U[k][k] = 1;\n            }\n        }\n\n        // Generate V.\n        for (int k = n - 1; k >= 0; k--) {\n            if (k < nrt &&\n                e[k] != 0) {\n                for (int j = k + 1; j < n; j++) {\n                    double t = 0;\n                    for (int i = k + 1; i < n; i++) {\n                        t += V[i][k] * V[i][j];\n                    }\n                    t = -t / V[k + 1][k];\n                    for (int i = k + 1; i < n; i++) {\n                        V[i][j] += t * V[i][k];\n                    }\n                }\n            }\n            for (int i = 0; i < n; i++) {\n                V[i][k] = 0;\n            }\n            V[k][k] = 1;\n        }\n\n        // Main iteration loop for the singular values.\n        final int pp = p - 1;\n        int iter = 0;\n        while (p > 0) {\n            int k;\n            int kase;\n            // Here is where a test for too many iterations would go.\n            // This section of the program inspects for\n            // negligible elements in the s and e arrays.  On\n            // completion the variables kase and k are set as follows.\n            // kase = 1     if s(p) and e[k-1] are negligible and k<p\n            // kase = 2     if s(k) is negligible and k<p\n            // kase = 3     if e[k-1] is negligible, k<p, and\n            //              s(k), ..., s(p) are not negligible (qr step).\n            // kase = 4     if e(p-1) is negligible (convergence).\n            for (k = p - 2; k >= 0; k--) {\n                final double threshold\n                    = TINY + EPS * (FastMath.abs(singularValues[k]) +\n                                    FastMath.abs(singularValues[k + 1]));\n\n                // the following condition is written this way in order\n                // to break out of the loop when NaN occurs, writing it\n                // as \"if (FastMath.abs(e[k]) <= threshold)\" would loop\n                // indefinitely in case of NaNs because comparison on NaNs\n                // always return false, regardless of what is checked\n                // see issue MATH-947\n                if (!(FastMath.abs(e[k]) > threshold)) {\n                    e[k] = 0;\n                    break;\n                }\n\n            }\n\n            if (k == p - 2) {\n                kase = 4;\n            } else {\n                int ks;\n                for (ks = p - 1; ks >= k; ks--) {\n                    if (ks == k) {\n                        break;\n                    }\n                    final double t = (ks != p ? FastMath.abs(e[ks]) : 0) +\n                        (ks != k + 1 ? FastMath.abs(e[ks - 1]) : 0);\n                    if (FastMath.abs(singularValues[ks]) <= TINY + EPS * t) {\n                        singularValues[ks] = 0;\n                        break;\n                    }\n                }\n                if (ks == k) {\n                    kase = 3;\n                } else if (ks == p - 1) {\n                    kase = 1;\n                } else {\n                    kase = 2;\n                    k = ks;\n                }\n            }\n            k++;\n            // Perform the task indicated by kase.\n            switch (kase) {\n                // Deflate negligible s(p).\n                case 1: {\n                    double f = e[p - 2];\n                    e[p - 2] = 0;\n                    for (int j = p - 2; j >= k; j--) {\n                        double t = FastMath.hypot(singularValues[j], f);\n                        final double cs = singularValues[j] / t;\n                        final double sn = f / t;\n                        singularValues[j] = t;\n                        if (j != k) {\n                            f = -sn * e[j - 1];\n                            e[j - 1] = cs * e[j - 1];\n                        }\n\n                        for (int i = 0; i < n; i++) {\n                            t = cs * V[i][j] + sn * V[i][p - 1];\n                            V[i][p - 1] = -sn * V[i][j] + cs * V[i][p - 1];\n                            V[i][j] = t;\n                        }\n                    }\n                }\n                break;\n                // Split at negligible s(k).\n                case 2: {\n                    double f = e[k - 1];\n                    e[k - 1] = 0;\n                    for (int j = k; j < p; j++) {\n                        double t = FastMath.hypot(singularValues[j], f);\n                        final double cs = singularValues[j] / t;\n                        final double sn = f / t;\n                        singularValues[j] = t;\n                        f = -sn * e[j];\n                        e[j] = cs * e[j];\n\n                        for (int i = 0; i < m; i++) {\n                            t = cs * U[i][j] + sn * U[i][k - 1];\n                            U[i][k - 1] = -sn * U[i][j] + cs * U[i][k - 1];\n                            U[i][j] = t;\n                        }\n                    }\n                }\n                break;\n                // Perform one qr step.\n                case 3: {\n                    // Calculate the shift.\n                    final double maxPm1Pm2 = FastMath.max(FastMath.abs(singularValues[p - 1]),\n                                                          FastMath.abs(singularValues[p - 2]));\n                    final double scale = FastMath.max(FastMath.max(FastMath.max(maxPm1Pm2,\n                                                                                FastMath.abs(e[p - 2])),\n                                                                   FastMath.abs(singularValues[k])),\n                                                      FastMath.abs(e[k]));\n                    final double sp = singularValues[p - 1] / scale;\n                    final double spm1 = singularValues[p - 2] / scale;\n                    final double epm1 = e[p - 2] / scale;\n                    final double sk = singularValues[k] / scale;\n                    final double ek = e[k] / scale;\n                    final double b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2.0;\n                    final double c = (sp * epm1) * (sp * epm1);\n                    double shift = 0;\n                    if (b != 0 ||\n                        c != 0) {\n                        shift = FastMath.sqrt(b * b + c);\n                        if (b < 0) {\n                            shift = -shift;\n                        }\n                        shift = c / (b + shift);\n                    }\n                    double f = (sk + sp) * (sk - sp) + shift;\n                    double g = sk * ek;\n                    // Chase zeros.\n                    for (int j = k; j < p - 1; j++) {\n                        double t = FastMath.hypot(f, g);\n                        double cs = f / t;\n                        double sn = g / t;\n                        if (j != k) {\n                            e[j - 1] = t;\n                        }\n                        f = cs * singularValues[j] + sn * e[j];\n                        e[j] = cs * e[j] - sn * singularValues[j];\n                        g = sn * singularValues[j + 1];\n                        singularValues[j + 1] = cs * singularValues[j + 1];\n\n                        for (int i = 0; i < n; i++) {\n                            t = cs * V[i][j] + sn * V[i][j + 1];\n                            V[i][j + 1] = -sn * V[i][j] + cs * V[i][j + 1];\n                            V[i][j] = t;\n                        }\n                        t = FastMath.hypot(f, g);\n                        cs = f / t;\n                        sn = g / t;\n                        singularValues[j] = t;\n                        f = cs * e[j] + sn * singularValues[j + 1];\n                        singularValues[j + 1] = -sn * e[j] + cs * singularValues[j + 1];\n                        g = sn * e[j + 1];\n                        e[j + 1] = cs * e[j + 1];\n                        if (j < m - 1) {\n                            for (int i = 0; i < m; i++) {\n                                t = cs * U[i][j] + sn * U[i][j + 1];\n                                U[i][j + 1] = -sn * U[i][j] + cs * U[i][j + 1];\n                                U[i][j] = t;\n                            }\n                        }\n                    }\n                    e[p - 2] = f;\n                    iter = iter + 1;\n                }\n                break;\n                // Convergence.\n                default: {\n                    // Make the singular values positive.\n                    if (singularValues[k] <= 0) {\n                        singularValues[k] = singularValues[k] < 0 ? -singularValues[k] : 0;\n\n                        for (int i = 0; i <= pp; i++) {\n                            V[i][k] = -V[i][k];\n                        }\n                    }\n                    // Order the singular values.\n                    while (k < pp) {\n                        if (singularValues[k] >= singularValues[k + 1]) {\n                            break;\n                        }\n                        double t = singularValues[k];\n                        singularValues[k] = singularValues[k + 1];\n                        singularValues[k + 1] = t;\n                        if (k < n - 1) {\n                            for (int i = 0; i < n; i++) {\n                                t = V[i][k + 1];\n                                V[i][k + 1] = V[i][k];\n                                V[i][k] = t;\n                            }\n                        }\n                        if (k < m - 1) {\n                            for (int i = 0; i < m; i++) {\n                                t = U[i][k + 1];\n                                U[i][k + 1] = U[i][k];\n                                U[i][k] = t;\n                            }\n                        }\n                        k++;\n                    }\n                    iter = 0;\n                    p--;\n                }\n                break;\n            }\n        }\n\n        // Set the small value tolerance used to calculate rank and pseudo-inverse\n        tol = FastMath.max(m * singularValues[0] * EPS,\n                           FastMath.sqrt(Precision.SAFE_MIN));\n\n        if (!transposed) {\n            cachedU = MatrixUtils.createRealMatrix(U);\n            cachedV = MatrixUtils.createRealMatrix(V);\n        } else {\n            cachedU = MatrixUtils.createRealMatrix(V);\n            cachedV = MatrixUtils.createRealMatrix(U);\n        }\n    }",
          "5": "    public SingularValueDecomposition(final RealMatrix matrix) {\n        final double[][] A;\n\n         // \"m\" is always the largest dimension.\n        if (matrix.getRowDimension() < matrix.getColumnDimension()) {\n            transposed = true;\n            A = matrix.transpose().getData();\n            m = matrix.getColumnDimension();\n            n = matrix.getRowDimension();\n        } else {\n            transposed = false;\n            A = matrix.getData();\n            m = matrix.getRowDimension();\n            n = matrix.getColumnDimension();\n        }\n\n        singularValues = new double[n];\n        final double[][] U = new double[m][n];\n        final double[][] V = new double[n][n];\n        final double[] e = new double[n];\n        final double[] work = new double[m];\n        // Reduce A to bidiagonal form, storing the diagonal elements\n        // in s and the super-diagonal elements in e.\n        final int nct = FastMath.min(m - 1, n);\n        final int nrt = FastMath.max(0, n - 2);\n        for (int k = 0; k < FastMath.max(nct, nrt); k++) {\n            if (k < nct) {\n                // Compute the transformation for the k-th column and\n                // place the k-th diagonal in s[k].\n                // Compute 2-norm of k-th column without under/overflow.\n                singularValues[k] = 0;\n                for (int i = k; i < m; i++) {\n                    singularValues[k] = FastMath.hypot(singularValues[k], A[i][k]);\n                }\n                if (singularValues[k] != 0) {\n                    if (A[k][k] < 0) {\nbreak;\n                        singularValues[k] = +singularValues[k];                    }\n                    for (int i = k; i < m; i++) {\n                        A[i][k] /= singularValues[k];\n                    }\n                    A[k][k] += 1;\n                }\n                singularValues[k] = -singularValues[k];\n            }\n            for (int j = k + 1; j < n; j++) {\n                if (k < nct &&\n                    singularValues[k] != 0) {\n                    // Apply the transformation.\n                    double t = 0;\n                    for (int i = k; i < m; i++) {\n                        t += A[i][k] * A[i][j];\n                    }\n                    t = -t / A[k][k];\n                    for (int i = k; i < m; i++) {\n                        A[i][j] += t * A[i][k];\n                    }\n                }\n                // Place the k-th row of A into e for the\n                // subsequent calculation of the row transformation.\n                e[j] = A[k][j];\n            }\n            if (k < nct) {\n                // Place the transformation in U for subsequent back\n                // multiplication.\n                for (int i = k; i < m; i++) {\n                    U[i][k] = A[i][k];\n                }\n            }\n            if (k < nrt) {\n                // Compute the k-th row transformation and place the\n                // k-th super-diagonal in e[k].\n                // Compute 2-norm without under/overflow.\n                e[k] = 0;\n                for (int i = k + 1; i < n; i++) {\n                    e[k] = FastMath.hypot(e[k], e[i]);\n                }\n                if (e[k] != 0) {\n                    if (e[k + 1] < 0) {\n                        e[k] = -e[k];\n                    }\n                    for (int i = k + 1; i < n; i++) {\n                        e[i] /= e[k];\n                    }\n                    e[k + 1] += 1;\n                }\n                e[k] = -e[k];\n                if (k + 1 < m &&\n                    e[k] != 0) {\n                    // Apply the transformation.\n                    for (int i = k + 1; i < m; i++) {\n                        work[i] = 0;\n                    }\n                    for (int j = k + 1; j < n; j++) {\n                        for (int i = k + 1; i < m; i++) {\n                            work[i] += e[j] * A[i][j];\n                        }\n                    }\n                    for (int j = k + 1; j < n; j++) {\n                        final double t = -e[j] / e[k + 1];\n                        for (int i = k + 1; i < m; i++) {\n                            A[i][j] += t * work[i];\n                        }\n                    }\n                }\n\n                // Place the transformation in V for subsequent\n                // back multiplication.\n                for (int i = k + 1; i < n; i++) {\n                    V[i][k] = e[i];\n                }\n            }\n        }\n        // Set up the final bidiagonal matrix or order p.\n        int p = n;\n        if (nct < n) {\n            singularValues[nct] = A[nct][nct];\n        }\n        if (m < p) {\n            singularValues[p - 1] = 0;\n        }\n        if (nrt + 1 < p) {\n            e[nrt] = A[nrt][p - 1];\n        }\n        e[p - 1] = 0;\n\n        // Generate U.\n        for (int j = nct; j < n; j++) {\n            for (int i = 0; i < m; i++) {\n                U[i][j] = 0;\n            }\n            U[j][j] = 1;\n        }\n        for (int k = nct - 1; k >= 0; k--) {\n            if (singularValues[k] != 0) {\n                for (int j = k + 1; j < n; j++) {\n                    double t = 0;\n                    for (int i = k; i < m; i++) {\n                        t += U[i][k] * U[i][j];\n                    }\n                    t = -t / U[k][k];\n                    for (int i = k; i < m; i++) {\n                        U[i][j] += t * U[i][k];\n                    }\n                }\n                for (int i = k; i < m; i++) {\n                    U[i][k] = -U[i][k];\n                }\n                U[k][k] = 1 + U[k][k];\n                for (int i = 0; i < k - 1; i++) {\n                    U[i][k] = 0;\n                }\n            } else {\n                for (int i = 0; i < m; i++) {\n                    U[i][k] = 0;\n                }\n                U[k][k] = 1;\n            }\n        }\n\n        // Generate V.\n        for (int k = n - 1; k >= 0; k--) {\n            if (k < nrt &&\n                e[k] != 0) {\n                for (int j = k + 1; j < n; j++) {\n                    double t = 0;\n                    for (int i = k + 1; i < n; i++) {\n                        t += V[i][k] * V[i][j];\n                    }\n                    t = -t / V[k + 1][k];\n                    for (int i = k + 1; i < n; i++) {\n                        V[i][j] += t * V[i][k];\n                    }\n                }\n            }\n            for (int i = 0; i < n; i++) {\n                V[i][k] = 0;\n            }\n            V[k][k] = 1;\n        }\n\n        // Main iteration loop for the singular values.\n        final int pp = p - 1;\n        int iter = 0;\n        while (p > 0) {\n            int k;\n            int kase;\n            // Here is where a test for too many iterations would go.\n            // This section of the program inspects for\n            // negligible elements in the s and e arrays.  On\n            // completion the variables kase and k are set as follows.\n            // kase = 1     if s(p) and e[k-1] are negligible and k<p\n            // kase = 2     if s(k) is negligible and k<p\n            // kase = 3     if e[k-1] is negligible, k<p, and\n            //              s(k), ..., s(p) are not negligible (qr step).\n            // kase = 4     if e(p-1) is negligible (convergence).\n            for (k = p - 2; k >= 0; k--) {\n                final double threshold\n                    = TINY + EPS * (FastMath.abs(singularValues[k]) +\n                                    FastMath.abs(singularValues[k + 1]));\n\n                // the following condition is written this way in order\n                // to break out of the loop when NaN occurs, writing it\n                // as \"if (FastMath.abs(e[k]) <= threshold)\" would loop\n                // indefinitely in case of NaNs because comparison on NaNs\n                // always return false, regardless of what is checked\n                // see issue MATH-947\n                if (!(FastMath.abs(e[k]) > threshold)) {\n                    e[k] = 0;\n                    break;\n                }\n\n            }\n\n            if (k == p - 2) {\n                kase = 4;\n            } else {\n                int ks;\n                for (ks = p - 1; ks >= k; ks--) {\n                    if (ks == k) {\n                        break;\n                    }\n                    final double t = (ks != p ? FastMath.abs(e[ks]) : 0) +\n                        (ks != k + 1 ? FastMath.abs(e[ks - 1]) : 0);\n                    if (FastMath.abs(singularValues[ks]) <= TINY + EPS * t) {\n                        singularValues[ks] = 0;\n                        break;\n                    }\n                }\n                if (ks == k) {\n                    kase = 3;\n                } else if (ks == p - 1) {\n                    kase = 1;\n                } else {\n                    kase = 2;\n                    k = ks;\n                }\n            }\n            k++;\n            // Perform the task indicated by kase.\n            switch (kase) {\n                // Deflate negligible s(p).\n                case 1: {\n                    double f = e[p - 2];\n                    e[p - 2] = 0;\n                    for (int j = p - 2; j >= k; j--) {\n                        double t = FastMath.hypot(singularValues[j], f);\n                        final double cs = singularValues[j] / t;\n                        final double sn = f / t;\n                        singularValues[j] = t;\n                        if (j != k) {\n                            f = -sn * e[j - 1];\n                            e[j - 1] = cs * e[j - 1];\n                        }\n\n                        for (int i = 0; i < n; i++) {\n                            t = cs * V[i][j] + sn * V[i][p - 1];\n                            V[i][p - 1] = -sn * V[i][j] + cs * V[i][p - 1];\n                            V[i][j] = t;\n                        }\n                    }\n                }\n                break;\n                // Split at negligible s(k).\n                case 2: {\n                    double f = e[k - 1];\n                    e[k - 1] = 0;\n                    for (int j = k; j < p; j++) {\n                        double t = FastMath.hypot(singularValues[j], f);\n                        final double cs = singularValues[j] / t;\n                        final double sn = f / t;\n                        singularValues[j] = t;\n                        f = -sn * e[j];\n                        e[j] = cs * e[j];\n\n                        for (int i = 0; i < m; i++) {\n                            t = cs * U[i][j] + sn * U[i][k - 1];\n                            U[i][k - 1] = -sn * U[i][j] + cs * U[i][k - 1];\n                            U[i][j] = t;\n                        }\n                    }\n                }\n                break;\n                // Perform one qr step.\n                case 3: {\n                    // Calculate the shift.\n                    final double maxPm1Pm2 = FastMath.max(FastMath.abs(singularValues[p - 1]),\n                                                          FastMath.abs(singularValues[p - 2]));\n                    final double scale = FastMath.max(FastMath.max(FastMath.max(maxPm1Pm2,\n                                                                                FastMath.abs(e[p - 2])),\n                                                                   FastMath.abs(singularValues[k])),\n                                                      FastMath.abs(e[k]));\n                    final double sp = singularValues[p - 1] / scale;\n                    final double spm1 = singularValues[p - 2] / scale;\n                    final double epm1 = e[p - 2] / scale;\n                    final double sk = singularValues[k] / scale;\n                    final double ek = e[k] / scale;\n                    final double b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2.0;\n                    final double c = (sp * epm1) * (sp * epm1);\n                    double shift = 0;\n                    if (b != 0 ||\n                        c != 0) {\n                        shift = FastMath.sqrt(b * b + c);\n                        if (b < 0) {\n                            shift = -shift;\n                        }\n                        shift = c / (b + shift);\n                    }\n                    double f = (sk + sp) * (sk - sp) + shift;\n                    double g = sk * ek;\n                    // Chase zeros.\n                    for (int j = k; j < p - 1; j++) {\n                        double t = FastMath.hypot(f, g);\n                        double cs = f / t;\n                        double sn = g / t;\n                        if (j != k) {\n                            e[j - 1] = t;\n                        }\n                        f = cs * singularValues[j] + sn * e[j];\n                        e[j] = cs * e[j] - sn * singularValues[j];\n                        g = sn * singularValues[j + 1];\n                        singularValues[j + 1] = cs * singularValues[j + 1];\n\n                        for (int i = 0; i < n; i++) {\n                            t = cs * V[i][j] + sn * V[i][j + 1];\n                            V[i][j + 1] = -sn * V[i][j] + cs * V[i][j + 1];\n                            V[i][j] = t;\n                        }\n                        t = FastMath.hypot(f, g);\n                        cs = f / t;\n                        sn = g / t;\n                        singularValues[j] = t;\n                        f = cs * e[j] + sn * singularValues[j + 1];\n                        singularValues[j + 1] = -sn * e[j] + cs * singularValues[j + 1];\n                        g = sn * e[j + 1];\n                        e[j + 1] = cs * e[j + 1];\n                        if (j < m - 1) {\n                            for (int i = 0; i < m; i++) {\n                                t = cs * U[i][j] + sn * U[i][j + 1];\n                                U[i][j + 1] = -sn * U[i][j] + cs * U[i][j + 1];\n                                U[i][j] = t;\n                            }\n                        }\n                    }\n                    e[p - 2] = f;\n                    iter = iter + 1;\n                }\n                break;\n                // Convergence.\n                default: {\n                    // Make the singular values positive.\n                    if (singularValues[k] <= 0) {\n                        singularValues[k] = singularValues[k] < 0 ? -singularValues[k] : 0;\n\n                        for (int i = 0; i <= pp; i++) {\n                            V[i][k] = -V[i][k];\n                        }\n                    }\n                    // Order the singular values.\n                    while (k < pp) {\n                        if (singularValues[k] >= singularValues[k + 1]) {\n                            break;\n                        }\n                        double t = singularValues[k];\n                        singularValues[k] = singularValues[k + 1];\n                        singularValues[k + 1] = t;\n                        if (k < n - 1) {\n                            for (int i = 0; i < n; i++) {\n                                t = V[i][k + 1];\n                                V[i][k + 1] = V[i][k];\n                                V[i][k] = t;\n                            }\n                        }\n                        if (k < m - 1) {\n                            for (int i = 0; i < m; i++) {\n                                t = U[i][k + 1];\n                                U[i][k + 1] = U[i][k];\n                                U[i][k] = t;\n                            }\n                        }\n                        k++;\n                    }\n                    iter = 0;\n                    p--;\n                }\n                break;\n            }\n        }\n\n        // Set the small value tolerance used to calculate rank and pseudo-inverse\n        tol = FastMath.max(m * singularValues[0] * EPS,\n                           FastMath.sqrt(Precision.SAFE_MIN));\n\n        if (!transposed) {\n            cachedU = MatrixUtils.createRealMatrix(U);\n            cachedV = MatrixUtils.createRealMatrix(V);\n        } else {\n            cachedU = MatrixUtils.createRealMatrix(V);\n            cachedV = MatrixUtils.createRealMatrix(U);\n        }\n    }",
          "6": "    public SingularValueDecomposition(final RealMatrix matrix) {\n        final double[][] A;\n\n         // \"m\" is always the largest dimension.\n        if (matrix.getRowDimension() < matrix.getColumnDimension()) {\n            transposed = true;\n            A = matrix.transpose().getData();\n            m = matrix.getColumnDimension();\n            n = matrix.getRowDimension();\n        } else {\n            transposed = false;\n            A = matrix.getData();\n            m = matrix.getRowDimension();\n            n = matrix.getColumnDimension();\n        }\n\n        singularValues = new double[n];\n        final double[][] U = new double[m][n];\n        final double[][] V = new double[n][n];\n        final double[] e = new double[n];\n        final double[] work = new double[m];\n        // Reduce A to bidiagonal form, storing the diagonal elements\n        // in s and the super-diagonal elements in e.\n        final int nct = FastMath.min(m - 1, n);\n        final int nrt = FastMath.max(0, n - 2);\n        for (int k = 0; k < FastMath.max(nct, nrt); k++) {\n            if (k < nct) {\n                // Compute the transformation for the k-th column and\n                // place the k-th diagonal in s[k].\n                // Compute 2-norm of k-th column without under/overflow.\n                singularValues[k] = 0;\n                for (int i = k; i < m; i++) {\n                    singularValues[k] = FastMath.hypot(singularValues[k], A[i][k]);\n                }\n                if (singularValues[k] != 0) {\n                    if (A[k][k] < 0) {\nA[i].[k] /= singularValues[k];\n                    }\n                    for (int i = k; i < m; i++) {\n                        A[i][k] /= singularValues[k];\n                    }\n                    A[k][k] += 1;\n                }\n                singularValues[k] = -singularValues[k];\n            }\n            for (int j = k + 1; j < n; j++) {\n                if (k < nct &&\n                    singularValues[k] != 0) {\n                    // Apply the transformation.\n                    double t = 0;\n                    for (int i = k; i < m; i++) {\n                        t += A[i][k] * A[i][j];\n                    }\n                    t = -t / A[k][k];\n                    for (int i = k; i < m; i++) {\n                        A[i][j] += t * A[i][k];\n                    }\n                }\n                // Place the k-th row of A into e for the\n                // subsequent calculation of the row transformation.\n                e[j] = A[k][j];\n            }\n            if (k < nct) {\n                // Place the transformation in U for subsequent back\n                // multiplication.\n                for (int i = k; i < m; i++) {\n                    U[i][k] = A[i][k];\n                }\n            }\n            if (k < nrt) {\n                // Compute the k-th row transformation and place the\n                // k-th super-diagonal in e[k].\n                // Compute 2-norm without under/overflow.\n                e[k] = 0;\n                for (int i = k + 1; i < n; i++) {\n                    e[k] = FastMath.hypot(e[k], e[i]);\n                }\n                if (e[k] != 0) {\n                    if (e[k + 1] < 0) {\n                        e[k] = -e[k];\n                    }\n                    for (int i = k + 1; i < n; i++) {\n                        e[i] /= e[k];\n                    }\n                    e[k + 1] += 1;\n                }\n                e[k] = -e[k];\n                if (k + 1 < m &&\n                    e[k] != 0) {\n                    // Apply the transformation.\n                    for (int i = k + 1; i < m; i++) {\n                        work[i] = 0;\n                    }\n                    for (int j = k + 1; j < n; j++) {\n                        for (int i = k + 1; i < m; i++) {\n                            work[i] += e[j] * A[i][j];\n                        }\n                    }\n                    for (int j = k + 1; j < n; j++) {\n                        final double t = -e[j] / e[k + 1];\n                        for (int i = k + 1; i < m; i++) {\n                            A[i][j] += t * work[i];\n                        }\n                    }\n                }\n\n                // Place the transformation in V for subsequent\n                // back multiplication.\n                for (int i = k + 1; i < n; i++) {\n                    V[i][k] = e[i];\n                }\n            }\n        }\n        // Set up the final bidiagonal matrix or order p.\n        int p = n;\n        if (nct < n) {\n            singularValues[nct] = A[nct][nct];\n        }\n        if (m < p) {\n            singularValues[p - 1] = 0;\n        }\n        if (nrt + 1 < p) {\n            e[nrt] = A[nrt][p - 1];\n        }\n        e[p - 1] = 0;\n\n        // Generate U.\n        for (int j = nct; j < n; j++) {\n            for (int i = 0; i < m; i++) {\n                U[i][j] = 0;\n            }\n            U[j][j] = 1;\n        }\n        for (int k = nct - 1; k >= 0; k--) {\n            if (singularValues[k] != 0) {\n                for (int j = k + 1; j < n; j++) {\n                    double t = 0;\n                    for (int i = k; i < m; i++) {\n                        t += U[i][k] * U[i][j];\n                    }\n                    t = -t / U[k][k];\n                    for (int i = k; i < m; i++) {\n                        U[i][j] += t * U[i][k];\n                    }\n                }\n                for (int i = k; i < m; i++) {\n                    U[i][k] = -U[i][k];\n                }\n                U[k][k] = 1 + U[k][k];\n                for (int i = 0; i < k - 1; i++) {\n                    U[i][k] = 0;\n                }\n            } else {\n                for (int i = 0; i < m; i++) {\n                    U[i][k] = 0;\n                }\n                U[k][k] = 1;\n            }\n        }\n\n        // Generate V.\n        for (int k = n - 1; k >= 0; k--) {\n            if (k < nrt &&\n                e[k] != 0) {\n                for (int j = k + 1; j < n; j++) {\n                    double t = 0;\n                    for (int i = k + 1; i < n; i++) {\n                        t += V[i][k] * V[i][j];\n                    }\n                    t = -t / V[k + 1][k];\n                    for (int i = k + 1; i < n; i++) {\n                        V[i][j] += t * V[i][k];\n                    }\n                }\n            }\n            for (int i = 0; i < n; i++) {\n                V[i][k] = 0;\n            }\n            V[k][k] = 1;\n        }\n\n        // Main iteration loop for the singular values.\n        final int pp = p - 1;\n        int iter = 0;\n        while (p > 0) {\n            int k;\n            int kase;\n            // Here is where a test for too many iterations would go.\n            // This section of the program inspects for\n            // negligible elements in the s and e arrays.  On\n            // completion the variables kase and k are set as follows.\n            // kase = 1     if s(p) and e[k-1] are negligible and k<p\n            // kase = 2     if s(k) is negligible and k<p\n            // kase = 3     if e[k-1] is negligible, k<p, and\n            //              s(k), ..., s(p) are not negligible (qr step).\n            // kase = 4     if e(p-1) is negligible (convergence).\n            for (k = p - 2; k >= 0; k--) {\n                final double threshold\n                    = TINY + EPS * (FastMath.abs(singularValues[k]) +\n                                    FastMath.abs(singularValues[k + 1]));\n\n                // the following condition is written this way in order\n                // to break out of the loop when NaN occurs, writing it\n                // as \"if (FastMath.abs(e[k]) <= threshold)\" would loop\n                // indefinitely in case of NaNs because comparison on NaNs\n                // always return false, regardless of what is checked\n                // see issue MATH-947\n                if (!(FastMath.abs(e[k]) > threshold)) {\n                    e[k] = 0;\n                    break;\n                }\n\n            }\n\n            if (k == p - 2) {\n                kase = 4;\n            } else {\n                int ks;\n                for (ks = p - 1; ks >= k; ks--) {\n                    if (ks == k) {\n                        break;\n                    }\n                    final double t = (ks != p ? FastMath.abs(e[ks]) : 0) +\n                        (ks != k + 1 ? FastMath.abs(e[ks - 1]) : 0);\n                    if (FastMath.abs(singularValues[ks]) <= TINY + EPS * t) {\n                        singularValues[ks] = 0;\n                        break;\n                    }\n                }\n                if (ks == k) {\n                    kase = 3;\n                } else if (ks == p - 1) {\n                    kase = 1;\n                } else {\n                    kase = 2;\n                    k = ks;\n                }\n            }\n            k++;\n            // Perform the task indicated by kase.\n            switch (kase) {\n                // Deflate negligible s(p).\n                case 1: {\n                    double f = e[p - 2];\n                    e[p - 2] = 0;\n                    for (int j = p - 2; j >= k; j--) {\n                        double t = FastMath.hypot(singularValues[j], f);\n                        final double cs = singularValues[j] / t;\n                        final double sn = f / t;\n                        singularValues[j] = t;\n                        if (j != k) {\n                            f = -sn * e[j - 1];\n                            e[j - 1] = cs * e[j - 1];\n                        }\n\n                        for (int i = 0; i < n; i++) {\n                            t = cs * V[i][j] + sn * V[i][p - 1];\n                            V[i][p - 1] = -sn * V[i][j] + cs * V[i][p - 1];\n                            V[i][j] = t;\n                        }\n                    }\n                }\n                break;\n                // Split at negligible s(k).\n                case 2: {\n                    double f = e[k - 1];\n                    e[k - 1] = 0;\n                    for (int j = k; j < p; j++) {\n                        double t = FastMath.hypot(singularValues[j], f);\n                        final double cs = singularValues[j] / t;\n                        final double sn = f / t;\n                        singularValues[j] = t;\n                        f = -sn * e[j];\n                        e[j] = cs * e[j];\n\n                        for (int i = 0; i < m; i++) {\n                            t = cs * U[i][j] + sn * U[i][k - 1];\n                            U[i][k - 1] = -sn * U[i][j] + cs * U[i][k - 1];\n                            U[i][j] = t;\n                        }\n                    }\n                }\n                break;\n                // Perform one qr step.\n                case 3: {\n                    // Calculate the shift.\n                    final double maxPm1Pm2 = FastMath.max(FastMath.abs(singularValues[p - 1]),\n                                                          FastMath.abs(singularValues[p - 2]));\n                    final double scale = FastMath.max(FastMath.max(FastMath.max(maxPm1Pm2,\n                                                                                FastMath.abs(e[p - 2])),\n                                                                   FastMath.abs(singularValues[k])),\n                                                      FastMath.abs(e[k]));\n                    final double sp = singularValues[p - 1] / scale;\n                    final double spm1 = singularValues[p - 2] / scale;\n                    final double epm1 = e[p - 2] / scale;\n                    final double sk = singularValues[k] / scale;\n                    final double ek = e[k] / scale;\n                    final double b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2.0;\n                    final double c = (sp * epm1) * (sp * epm1);\n                    double shift = 0;\n                    if (b != 0 ||\n                        c != 0) {\n                        shift = FastMath.sqrt(b * b + c);\n                        if (b < 0) {\n                            shift = -shift;\n                        }\n                        shift = c / (b + shift);\n                    }\n                    double f = (sk + sp) * (sk - sp) + shift;\n                    double g = sk * ek;\n                    // Chase zeros.\n                    for (int j = k; j < p - 1; j++) {\n                        double t = FastMath.hypot(f, g);\n                        double cs = f / t;\n                        double sn = g / t;\n                        if (j != k) {\n                            e[j - 1] = t;\n                        }\n                        f = cs * singularValues[j] + sn * e[j];\n                        e[j] = cs * e[j] - sn * singularValues[j];\n                        g = sn * singularValues[j + 1];\n                        singularValues[j + 1] = cs * singularValues[j + 1];\n\n                        for (int i = 0; i < n; i++) {\n                            t = cs * V[i][j] + sn * V[i][j + 1];\n                            V[i][j + 1] = -sn * V[i][j] + cs * V[i][j + 1];\n                            V[i][j] = t;\n                        }\n                        t = FastMath.hypot(f, g);\n                        cs = f / t;\n                        sn = g / t;\n                        singularValues[j] = t;\n                        f = cs * e[j] + sn * singularValues[j + 1];\n                        singularValues[j + 1] = -sn * e[j] + cs * singularValues[j + 1];\n                        g = sn * e[j + 1];\n                        e[j + 1] = cs * e[j + 1];\n                        if (j < m - 1) {\n                            for (int i = 0; i < m; i++) {\n                                t = cs * U[i][j] + sn * U[i][j + 1];\n                                U[i][j + 1] = -sn * U[i][j] + cs * U[i][j + 1];\n                                U[i][j] = t;\n                            }\n                        }\n                    }\n                    e[p - 2] = f;\n                    iter = iter + 1;\n                }\n                break;\n                // Convergence.\n                default: {\n                    // Make the singular values positive.\n                    if (singularValues[k] <= 0) {\n                        singularValues[k] = singularValues[k] < 0 ? -singularValues[k] : 0;\n\n                        for (int i = 0; i <= pp; i++) {\n                            V[i][k] = -V[i][k];\n                        }\n                    }\n                    // Order the singular values.\n                    while (k < pp) {\n                        if (singularValues[k] >= singularValues[k + 1]) {\n                            break;\n                        }\n                        double t = singularValues[k];\n                        singularValues[k] = singularValues[k + 1];\n                        singularValues[k + 1] = t;\n                        if (k < n - 1) {\n                            for (int i = 0; i < n; i++) {\n                                t = V[i][k + 1];\n                                V[i][k + 1] = V[i][k];\n                                V[i][k] = t;\n                            }\n                        }\n                        if (k < m - 1) {\n                            for (int i = 0; i < m; i++) {\n                                t = U[i][k + 1];\n                                U[i][k + 1] = U[i][k];\n                                U[i][k] = t;\n                            }\n                        }\n                        k++;\n                    }\n                    iter = 0;\n                    p--;\n                }\n                break;\n            }\n        }\n\n        // Set the small value tolerance used to calculate rank and pseudo-inverse\n        tol = FastMath.max(m * singularValues[0] * EPS,\n                           FastMath.sqrt(Precision.SAFE_MIN));\n\n        if (!transposed) {\n            cachedU = MatrixUtils.createRealMatrix(U);\n            cachedV = MatrixUtils.createRealMatrix(V);\n        } else {\n            cachedU = MatrixUtils.createRealMatrix(V);\n            cachedV = MatrixUtils.createRealMatrix(U);\n        }\n    }",
          "7": "    public SingularValueDecomposition(final RealMatrix matrix) {\n        final double[][] A;\n\n         // \"m\" is always the largest dimension.\n        if (matrix.getRowDimension() < matrix.getColumnDimension()) {\n            transposed = true;\n            A = matrix.transpose().getData();\n            m = matrix.getColumnDimension();\n            n = matrix.getRowDimension();\n        } else {\n            transposed = false;\n            A = matrix.getData();\n            m = matrix.getRowDimension();\n            n = matrix.getColumnDimension();\n        }\n\n        singularValues = new double[n];\n        final double[][] U = new double[m][n];\n        final double[][] V = new double[n][n];\n        final double[] e = new double[n];\n        final double[] work = new double[m];\n        // Reduce A to bidiagonal form, storing the diagonal elements\n        // in s and the super-diagonal elements in e.\n        final int nct = FastMath.min(m - 1, n);\n        final int nrt = FastMath.max(0, n - 2);\n        for (int k = 0; k < FastMath.max(nct, nrt); k++) {\n            if (k < nct) {\n                // Compute the transformation for the k-th column and\n                // place the k-th diagonal in s[k].\n                // Compute 2-norm of k-th column without under/overflow.\n                singularValues[k] = 0;\n                for (int i = k; i < m; i++) {\n                    singularValues[k] = FastMath.hypot(singularValues[k], A[i][k]);\n                }\n                if (singularValues[k] != 0) {\n                    if (A[k][k] < 0) {\nsingularValues[k] = FastMath.hypot(singularValues[k], A[i].[k]);\n                    }\n                    for (int i = k; i < m; i++) {\n                        A[i][k] /= singularValues[k];\n                    }\n                    A[k][k] += 1;\n                }\n                singularValues[k] = -singularValues[k];\n            }\n            for (int j = k + 1; j < n; j++) {\n                if (k < nct &&\n                    singularValues[k] != 0) {\n                    // Apply the transformation.\n                    double t = 0;\n                    for (int i = k; i < m; i++) {\n                        t += A[i][k] * A[i][j];\n                    }\n                    t = -t / A[k][k];\n                    for (int i = k; i < m; i++) {\n                        A[i][j] += t * A[i][k];\n                    }\n                }\n                // Place the k-th row of A into e for the\n                // subsequent calculation of the row transformation.\n                e[j] = A[k][j];\n            }\n            if (k < nct) {\n                // Place the transformation in U for subsequent back\n                // multiplication.\n                for (int i = k; i < m; i++) {\n                    U[i][k] = A[i][k];\n                }\n            }\n            if (k < nrt) {\n                // Compute the k-th row transformation and place the\n                // k-th super-diagonal in e[k].\n                // Compute 2-norm without under/overflow.\n                e[k] = 0;\n                for (int i = k + 1; i < n; i++) {\n                    e[k] = FastMath.hypot(e[k], e[i]);\n                }\n                if (e[k] != 0) {\n                    if (e[k + 1] < 0) {\n                        e[k] = -e[k];\n                    }\n                    for (int i = k + 1; i < n; i++) {\n                        e[i] /= e[k];\n                    }\n                    e[k + 1] += 1;\n                }\n                e[k] = -e[k];\n                if (k + 1 < m &&\n                    e[k] != 0) {\n                    // Apply the transformation.\n                    for (int i = k + 1; i < m; i++) {\n                        work[i] = 0;\n                    }\n                    for (int j = k + 1; j < n; j++) {\n                        for (int i = k + 1; i < m; i++) {\n                            work[i] += e[j] * A[i][j];\n                        }\n                    }\n                    for (int j = k + 1; j < n; j++) {\n                        final double t = -e[j] / e[k + 1];\n                        for (int i = k + 1; i < m; i++) {\n                            A[i][j] += t * work[i];\n                        }\n                    }\n                }\n\n                // Place the transformation in V for subsequent\n                // back multiplication.\n                for (int i = k + 1; i < n; i++) {\n                    V[i][k] = e[i];\n                }\n            }\n        }\n        // Set up the final bidiagonal matrix or order p.\n        int p = n;\n        if (nct < n) {\n            singularValues[nct] = A[nct][nct];\n        }\n        if (m < p) {\n            singularValues[p - 1] = 0;\n        }\n        if (nrt + 1 < p) {\n            e[nrt] = A[nrt][p - 1];\n        }\n        e[p - 1] = 0;\n\n        // Generate U.\n        for (int j = nct; j < n; j++) {\n            for (int i = 0; i < m; i++) {\n                U[i][j] = 0;\n            }\n            U[j][j] = 1;\n        }\n        for (int k = nct - 1; k >= 0; k--) {\n            if (singularValues[k] != 0) {\n                for (int j = k + 1; j < n; j++) {\n                    double t = 0;\n                    for (int i = k; i < m; i++) {\n                        t += U[i][k] * U[i][j];\n                    }\n                    t = -t / U[k][k];\n                    for (int i = k; i < m; i++) {\n                        U[i][j] += t * U[i][k];\n                    }\n                }\n                for (int i = k; i < m; i++) {\n                    U[i][k] = -U[i][k];\n                }\n                U[k][k] = 1 + U[k][k];\n                for (int i = 0; i < k - 1; i++) {\n                    U[i][k] = 0;\n                }\n            } else {\n                for (int i = 0; i < m; i++) {\n                    U[i][k] = 0;\n                }\n                U[k][k] = 1;\n            }\n        }\n\n        // Generate V.\n        for (int k = n - 1; k >= 0; k--) {\n            if (k < nrt &&\n                e[k] != 0) {\n                for (int j = k + 1; j < n; j++) {\n                    double t = 0;\n                    for (int i = k + 1; i < n; i++) {\n                        t += V[i][k] * V[i][j];\n                    }\n                    t = -t / V[k + 1][k];\n                    for (int i = k + 1; i < n; i++) {\n                        V[i][j] += t * V[i][k];\n                    }\n                }\n            }\n            for (int i = 0; i < n; i++) {\n                V[i][k] = 0;\n            }\n            V[k][k] = 1;\n        }\n\n        // Main iteration loop for the singular values.\n        final int pp = p - 1;\n        int iter = 0;\n        while (p > 0) {\n            int k;\n            int kase;\n            // Here is where a test for too many iterations would go.\n            // This section of the program inspects for\n            // negligible elements in the s and e arrays.  On\n            // completion the variables kase and k are set as follows.\n            // kase = 1     if s(p) and e[k-1] are negligible and k<p\n            // kase = 2     if s(k) is negligible and k<p\n            // kase = 3     if e[k-1] is negligible, k<p, and\n            //              s(k), ..., s(p) are not negligible (qr step).\n            // kase = 4     if e(p-1) is negligible (convergence).\n            for (k = p - 2; k >= 0; k--) {\n                final double threshold\n                    = TINY + EPS * (FastMath.abs(singularValues[k]) +\n                                    FastMath.abs(singularValues[k + 1]));\n\n                // the following condition is written this way in order\n                // to break out of the loop when NaN occurs, writing it\n                // as \"if (FastMath.abs(e[k]) <= threshold)\" would loop\n                // indefinitely in case of NaNs because comparison on NaNs\n                // always return false, regardless of what is checked\n                // see issue MATH-947\n                if (!(FastMath.abs(e[k]) > threshold)) {\n                    e[k] = 0;\n                    break;\n                }\n\n            }\n\n            if (k == p - 2) {\n                kase = 4;\n            } else {\n                int ks;\n                for (ks = p - 1; ks >= k; ks--) {\n                    if (ks == k) {\n                        break;\n                    }\n                    final double t = (ks != p ? FastMath.abs(e[ks]) : 0) +\n                        (ks != k + 1 ? FastMath.abs(e[ks - 1]) : 0);\n                    if (FastMath.abs(singularValues[ks]) <= TINY + EPS * t) {\n                        singularValues[ks] = 0;\n                        break;\n                    }\n                }\n                if (ks == k) {\n                    kase = 3;\n                } else if (ks == p - 1) {\n                    kase = 1;\n                } else {\n                    kase = 2;\n                    k = ks;\n                }\n            }\n            k++;\n            // Perform the task indicated by kase.\n            switch (kase) {\n                // Deflate negligible s(p).\n                case 1: {\n                    double f = e[p - 2];\n                    e[p - 2] = 0;\n                    for (int j = p - 2; j >= k; j--) {\n                        double t = FastMath.hypot(singularValues[j], f);\n                        final double cs = singularValues[j] / t;\n                        final double sn = f / t;\n                        singularValues[j] = t;\n                        if (j != k) {\n                            f = -sn * e[j - 1];\n                            e[j - 1] = cs * e[j - 1];\n                        }\n\n                        for (int i = 0; i < n; i++) {\n                            t = cs * V[i][j] + sn * V[i][p - 1];\n                            V[i][p - 1] = -sn * V[i][j] + cs * V[i][p - 1];\n                            V[i][j] = t;\n                        }\n                    }\n                }\n                break;\n                // Split at negligible s(k).\n                case 2: {\n                    double f = e[k - 1];\n                    e[k - 1] = 0;\n                    for (int j = k; j < p; j++) {\n                        double t = FastMath.hypot(singularValues[j], f);\n                        final double cs = singularValues[j] / t;\n                        final double sn = f / t;\n                        singularValues[j] = t;\n                        f = -sn * e[j];\n                        e[j] = cs * e[j];\n\n                        for (int i = 0; i < m; i++) {\n                            t = cs * U[i][j] + sn * U[i][k - 1];\n                            U[i][k - 1] = -sn * U[i][j] + cs * U[i][k - 1];\n                            U[i][j] = t;\n                        }\n                    }\n                }\n                break;\n                // Perform one qr step.\n                case 3: {\n                    // Calculate the shift.\n                    final double maxPm1Pm2 = FastMath.max(FastMath.abs(singularValues[p - 1]),\n                                                          FastMath.abs(singularValues[p - 2]));\n                    final double scale = FastMath.max(FastMath.max(FastMath.max(maxPm1Pm2,\n                                                                                FastMath.abs(e[p - 2])),\n                                                                   FastMath.abs(singularValues[k])),\n                                                      FastMath.abs(e[k]));\n                    final double sp = singularValues[p - 1] / scale;\n                    final double spm1 = singularValues[p - 2] / scale;\n                    final double epm1 = e[p - 2] / scale;\n                    final double sk = singularValues[k] / scale;\n                    final double ek = e[k] / scale;\n                    final double b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2.0;\n                    final double c = (sp * epm1) * (sp * epm1);\n                    double shift = 0;\n                    if (b != 0 ||\n                        c != 0) {\n                        shift = FastMath.sqrt(b * b + c);\n                        if (b < 0) {\n                            shift = -shift;\n                        }\n                        shift = c / (b + shift);\n                    }\n                    double f = (sk + sp) * (sk - sp) + shift;\n                    double g = sk * ek;\n                    // Chase zeros.\n                    for (int j = k; j < p - 1; j++) {\n                        double t = FastMath.hypot(f, g);\n                        double cs = f / t;\n                        double sn = g / t;\n                        if (j != k) {\n                            e[j - 1] = t;\n                        }\n                        f = cs * singularValues[j] + sn * e[j];\n                        e[j] = cs * e[j] - sn * singularValues[j];\n                        g = sn * singularValues[j + 1];\n                        singularValues[j + 1] = cs * singularValues[j + 1];\n\n                        for (int i = 0; i < n; i++) {\n                            t = cs * V[i][j] + sn * V[i][j + 1];\n                            V[i][j + 1] = -sn * V[i][j] + cs * V[i][j + 1];\n                            V[i][j] = t;\n                        }\n                        t = FastMath.hypot(f, g);\n                        cs = f / t;\n                        sn = g / t;\n                        singularValues[j] = t;\n                        f = cs * e[j] + sn * singularValues[j + 1];\n                        singularValues[j + 1] = -sn * e[j] + cs * singularValues[j + 1];\n                        g = sn * e[j + 1];\n                        e[j + 1] = cs * e[j + 1];\n                        if (j < m - 1) {\n                            for (int i = 0; i < m; i++) {\n                                t = cs * U[i][j] + sn * U[i][j + 1];\n                                U[i][j + 1] = -sn * U[i][j] + cs * U[i][j + 1];\n                                U[i][j] = t;\n                            }\n                        }\n                    }\n                    e[p - 2] = f;\n                    iter = iter + 1;\n                }\n                break;\n                // Convergence.\n                default: {\n                    // Make the singular values positive.\n                    if (singularValues[k] <= 0) {\n                        singularValues[k] = singularValues[k] < 0 ? -singularValues[k] : 0;\n\n                        for (int i = 0; i <= pp; i++) {\n                            V[i][k] = -V[i][k];\n                        }\n                    }\n                    // Order the singular values.\n                    while (k < pp) {\n                        if (singularValues[k] >= singularValues[k + 1]) {\n                            break;\n                        }\n                        double t = singularValues[k];\n                        singularValues[k] = singularValues[k + 1];\n                        singularValues[k + 1] = t;\n                        if (k < n - 1) {\n                            for (int i = 0; i < n; i++) {\n                                t = V[i][k + 1];\n                                V[i][k + 1] = V[i][k];\n                                V[i][k] = t;\n                            }\n                        }\n                        if (k < m - 1) {\n                            for (int i = 0; i < m; i++) {\n                                t = U[i][k + 1];\n                                U[i][k + 1] = U[i][k];\n                                U[i][k] = t;\n                            }\n                        }\n                        k++;\n                    }\n                    iter = 0;\n                    p--;\n                }\n                break;\n            }\n        }\n\n        // Set the small value tolerance used to calculate rank and pseudo-inverse\n        tol = FastMath.max(m * singularValues[0] * EPS,\n                           FastMath.sqrt(Precision.SAFE_MIN));\n\n        if (!transposed) {\n            cachedU = MatrixUtils.createRealMatrix(U);\n            cachedV = MatrixUtils.createRealMatrix(V);\n        } else {\n            cachedU = MatrixUtils.createRealMatrix(V);\n            cachedV = MatrixUtils.createRealMatrix(U);\n        }\n    }",
          "8": "    public SingularValueDecomposition(final RealMatrix matrix) {\n        final double[][] A;\n\n         // \"m\" is always the largest dimension.\n        if (matrix.getRowDimension() < matrix.getColumnDimension()) {\n            transposed = true;\n            A = matrix.transpose().getData();\n            m = matrix.getColumnDimension();\n            n = matrix.getRowDimension();\n        } else {\n            transposed = false;\n            A = matrix.getData();\n            m = matrix.getRowDimension();\n            n = matrix.getColumnDimension();\n        }\n\n        singularValues = new double[n];\n        final double[][] U = new double[m][n];\n        final double[][] V = new double[n][n];\n        final double[] e = new double[n];\n        final double[] work = new double[m];\n        // Reduce A to bidiagonal form, storing the diagonal elements\n        // in s and the super-diagonal elements in e.\n        final int nct = FastMath.min(m - 1, n);\n        final int nrt = FastMath.max(0, n - 2);\n        for (int k = 0; k < FastMath.max(nct, nrt); k++) {\n            if (k < nct) {\n                // Compute the transformation for the k-th column and\n                // place the k-th diagonal in s[k].\n                // Compute 2-norm of k-th column without under/overflow.\n                singularValues[k] = 0;\n                for (int i = k; i < m; i++) {\n                    singularValues[k] = FastMath.hypot(singularValues[k], A[i][k]);\n                }\n                if (singularValues[k] != 0) {\n                    if (A[k][k] < 0) {\nEPS[k] = +singularValues[k];\n                    }\n                    for (int i = k; i < m; i++) {\n                        A[i][k] /= singularValues[k];\n                    }\n                    A[k][k] += 1;\n                }\n                singularValues[k] = -singularValues[k];\n            }\n            for (int j = k + 1; j < n; j++) {\n                if (k < nct &&\n                    singularValues[k] != 0) {\n                    // Apply the transformation.\n                    double t = 0;\n                    for (int i = k; i < m; i++) {\n                        t += A[i][k] * A[i][j];\n                    }\n                    t = -t / A[k][k];\n                    for (int i = k; i < m; i++) {\n                        A[i][j] += t * A[i][k];\n                    }\n                }\n                // Place the k-th row of A into e for the\n                // subsequent calculation of the row transformation.\n                e[j] = A[k][j];\n            }\n            if (k < nct) {\n                // Place the transformation in U for subsequent back\n                // multiplication.\n                for (int i = k; i < m; i++) {\n                    U[i][k] = A[i][k];\n                }\n            }\n            if (k < nrt) {\n                // Compute the k-th row transformation and place the\n                // k-th super-diagonal in e[k].\n                // Compute 2-norm without under/overflow.\n                e[k] = 0;\n                for (int i = k + 1; i < n; i++) {\n                    e[k] = FastMath.hypot(e[k], e[i]);\n                }\n                if (e[k] != 0) {\n                    if (e[k + 1] < 0) {\n                        e[k] = -e[k];\n                    }\n                    for (int i = k + 1; i < n; i++) {\n                        e[i] /= e[k];\n                    }\n                    e[k + 1] += 1;\n                }\n                e[k] = -e[k];\n                if (k + 1 < m &&\n                    e[k] != 0) {\n                    // Apply the transformation.\n                    for (int i = k + 1; i < m; i++) {\n                        work[i] = 0;\n                    }\n                    for (int j = k + 1; j < n; j++) {\n                        for (int i = k + 1; i < m; i++) {\n                            work[i] += e[j] * A[i][j];\n                        }\n                    }\n                    for (int j = k + 1; j < n; j++) {\n                        final double t = -e[j] / e[k + 1];\n                        for (int i = k + 1; i < m; i++) {\n                            A[i][j] += t * work[i];\n                        }\n                    }\n                }\n\n                // Place the transformation in V for subsequent\n                // back multiplication.\n                for (int i = k + 1; i < n; i++) {\n                    V[i][k] = e[i];\n                }\n            }\n        }\n        // Set up the final bidiagonal matrix or order p.\n        int p = n;\n        if (nct < n) {\n            singularValues[nct] = A[nct][nct];\n        }\n        if (m < p) {\n            singularValues[p - 1] = 0;\n        }\n        if (nrt + 1 < p) {\n            e[nrt] = A[nrt][p - 1];\n        }\n        e[p - 1] = 0;\n\n        // Generate U.\n        for (int j = nct; j < n; j++) {\n            for (int i = 0; i < m; i++) {\n                U[i][j] = 0;\n            }\n            U[j][j] = 1;\n        }\n        for (int k = nct - 1; k >= 0; k--) {\n            if (singularValues[k] != 0) {\n                for (int j = k + 1; j < n; j++) {\n                    double t = 0;\n                    for (int i = k; i < m; i++) {\n                        t += U[i][k] * U[i][j];\n                    }\n                    t = -t / U[k][k];\n                    for (int i = k; i < m; i++) {\n                        U[i][j] += t * U[i][k];\n                    }\n                }\n                for (int i = k; i < m; i++) {\n                    U[i][k] = -U[i][k];\n                }\n                U[k][k] = 1 + U[k][k];\n                for (int i = 0; i < k - 1; i++) {\n                    U[i][k] = 0;\n                }\n            } else {\n                for (int i = 0; i < m; i++) {\n                    U[i][k] = 0;\n                }\n                U[k][k] = 1;\n            }\n        }\n\n        // Generate V.\n        for (int k = n - 1; k >= 0; k--) {\n            if (k < nrt &&\n                e[k] != 0) {\n                for (int j = k + 1; j < n; j++) {\n                    double t = 0;\n                    for (int i = k + 1; i < n; i++) {\n                        t += V[i][k] * V[i][j];\n                    }\n                    t = -t / V[k + 1][k];\n                    for (int i = k + 1; i < n; i++) {\n                        V[i][j] += t * V[i][k];\n                    }\n                }\n            }\n            for (int i = 0; i < n; i++) {\n                V[i][k] = 0;\n            }\n            V[k][k] = 1;\n        }\n\n        // Main iteration loop for the singular values.\n        final int pp = p - 1;\n        int iter = 0;\n        while (p > 0) {\n            int k;\n            int kase;\n            // Here is where a test for too many iterations would go.\n            // This section of the program inspects for\n            // negligible elements in the s and e arrays.  On\n            // completion the variables kase and k are set as follows.\n            // kase = 1     if s(p) and e[k-1] are negligible and k<p\n            // kase = 2     if s(k) is negligible and k<p\n            // kase = 3     if e[k-1] is negligible, k<p, and\n            //              s(k), ..., s(p) are not negligible (qr step).\n            // kase = 4     if e(p-1) is negligible (convergence).\n            for (k = p - 2; k >= 0; k--) {\n                final double threshold\n                    = TINY + EPS * (FastMath.abs(singularValues[k]) +\n                                    FastMath.abs(singularValues[k + 1]));\n\n                // the following condition is written this way in order\n                // to break out of the loop when NaN occurs, writing it\n                // as \"if (FastMath.abs(e[k]) <= threshold)\" would loop\n                // indefinitely in case of NaNs because comparison on NaNs\n                // always return false, regardless of what is checked\n                // see issue MATH-947\n                if (!(FastMath.abs(e[k]) > threshold)) {\n                    e[k] = 0;\n                    break;\n                }\n\n            }\n\n            if (k == p - 2) {\n                kase = 4;\n            } else {\n                int ks;\n                for (ks = p - 1; ks >= k; ks--) {\n                    if (ks == k) {\n                        break;\n                    }\n                    final double t = (ks != p ? FastMath.abs(e[ks]) : 0) +\n                        (ks != k + 1 ? FastMath.abs(e[ks - 1]) : 0);\n                    if (FastMath.abs(singularValues[ks]) <= TINY + EPS * t) {\n                        singularValues[ks] = 0;\n                        break;\n                    }\n                }\n                if (ks == k) {\n                    kase = 3;\n                } else if (ks == p - 1) {\n                    kase = 1;\n                } else {\n                    kase = 2;\n                    k = ks;\n                }\n            }\n            k++;\n            // Perform the task indicated by kase.\n            switch (kase) {\n                // Deflate negligible s(p).\n                case 1: {\n                    double f = e[p - 2];\n                    e[p - 2] = 0;\n                    for (int j = p - 2; j >= k; j--) {\n                        double t = FastMath.hypot(singularValues[j], f);\n                        final double cs = singularValues[j] / t;\n                        final double sn = f / t;\n                        singularValues[j] = t;\n                        if (j != k) {\n                            f = -sn * e[j - 1];\n                            e[j - 1] = cs * e[j - 1];\n                        }\n\n                        for (int i = 0; i < n; i++) {\n                            t = cs * V[i][j] + sn * V[i][p - 1];\n                            V[i][p - 1] = -sn * V[i][j] + cs * V[i][p - 1];\n                            V[i][j] = t;\n                        }\n                    }\n                }\n                break;\n                // Split at negligible s(k).\n                case 2: {\n                    double f = e[k - 1];\n                    e[k - 1] = 0;\n                    for (int j = k; j < p; j++) {\n                        double t = FastMath.hypot(singularValues[j], f);\n                        final double cs = singularValues[j] / t;\n                        final double sn = f / t;\n                        singularValues[j] = t;\n                        f = -sn * e[j];\n                        e[j] = cs * e[j];\n\n                        for (int i = 0; i < m; i++) {\n                            t = cs * U[i][j] + sn * U[i][k - 1];\n                            U[i][k - 1] = -sn * U[i][j] + cs * U[i][k - 1];\n                            U[i][j] = t;\n                        }\n                    }\n                }\n                break;\n                // Perform one qr step.\n                case 3: {\n                    // Calculate the shift.\n                    final double maxPm1Pm2 = FastMath.max(FastMath.abs(singularValues[p - 1]),\n                                                          FastMath.abs(singularValues[p - 2]));\n                    final double scale = FastMath.max(FastMath.max(FastMath.max(maxPm1Pm2,\n                                                                                FastMath.abs(e[p - 2])),\n                                                                   FastMath.abs(singularValues[k])),\n                                                      FastMath.abs(e[k]));\n                    final double sp = singularValues[p - 1] / scale;\n                    final double spm1 = singularValues[p - 2] / scale;\n                    final double epm1 = e[p - 2] / scale;\n                    final double sk = singularValues[k] / scale;\n                    final double ek = e[k] / scale;\n                    final double b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2.0;\n                    final double c = (sp * epm1) * (sp * epm1);\n                    double shift = 0;\n                    if (b != 0 ||\n                        c != 0) {\n                        shift = FastMath.sqrt(b * b + c);\n                        if (b < 0) {\n                            shift = -shift;\n                        }\n                        shift = c / (b + shift);\n                    }\n                    double f = (sk + sp) * (sk - sp) + shift;\n                    double g = sk * ek;\n                    // Chase zeros.\n                    for (int j = k; j < p - 1; j++) {\n                        double t = FastMath.hypot(f, g);\n                        double cs = f / t;\n                        double sn = g / t;\n                        if (j != k) {\n                            e[j - 1] = t;\n                        }\n                        f = cs * singularValues[j] + sn * e[j];\n                        e[j] = cs * e[j] - sn * singularValues[j];\n                        g = sn * singularValues[j + 1];\n                        singularValues[j + 1] = cs * singularValues[j + 1];\n\n                        for (int i = 0; i < n; i++) {\n                            t = cs * V[i][j] + sn * V[i][j + 1];\n                            V[i][j + 1] = -sn * V[i][j] + cs * V[i][j + 1];\n                            V[i][j] = t;\n                        }\n                        t = FastMath.hypot(f, g);\n                        cs = f / t;\n                        sn = g / t;\n                        singularValues[j] = t;\n                        f = cs * e[j] + sn * singularValues[j + 1];\n                        singularValues[j + 1] = -sn * e[j] + cs * singularValues[j + 1];\n                        g = sn * e[j + 1];\n                        e[j + 1] = cs * e[j + 1];\n                        if (j < m - 1) {\n                            for (int i = 0; i < m; i++) {\n                                t = cs * U[i][j] + sn * U[i][j + 1];\n                                U[i][j + 1] = -sn * U[i][j] + cs * U[i][j + 1];\n                                U[i][j] = t;\n                            }\n                        }\n                    }\n                    e[p - 2] = f;\n                    iter = iter + 1;\n                }\n                break;\n                // Convergence.\n                default: {\n                    // Make the singular values positive.\n                    if (singularValues[k] <= 0) {\n                        singularValues[k] = singularValues[k] < 0 ? -singularValues[k] : 0;\n\n                        for (int i = 0; i <= pp; i++) {\n                            V[i][k] = -V[i][k];\n                        }\n                    }\n                    // Order the singular values.\n                    while (k < pp) {\n                        if (singularValues[k] >= singularValues[k + 1]) {\n                            break;\n                        }\n                        double t = singularValues[k];\n                        singularValues[k] = singularValues[k + 1];\n                        singularValues[k + 1] = t;\n                        if (k < n - 1) {\n                            for (int i = 0; i < n; i++) {\n                                t = V[i][k + 1];\n                                V[i][k + 1] = V[i][k];\n                                V[i][k] = t;\n                            }\n                        }\n                        if (k < m - 1) {\n                            for (int i = 0; i < m; i++) {\n                                t = U[i][k + 1];\n                                U[i][k + 1] = U[i][k];\n                                U[i][k] = t;\n                            }\n                        }\n                        k++;\n                    }\n                    iter = 0;\n                    p--;\n                }\n                break;\n            }\n        }\n\n        // Set the small value tolerance used to calculate rank and pseudo-inverse\n        tol = FastMath.max(m * singularValues[0] * EPS,\n                           FastMath.sqrt(Precision.SAFE_MIN));\n\n        if (!transposed) {\n            cachedU = MatrixUtils.createRealMatrix(U);\n            cachedV = MatrixUtils.createRealMatrix(V);\n        } else {\n            cachedU = MatrixUtils.createRealMatrix(V);\n            cachedV = MatrixUtils.createRealMatrix(U);\n        }\n    }",
          "9": "    public SingularValueDecomposition(final RealMatrix matrix) {\n        final double[][] A;\n\n         // \"m\" is always the largest dimension.\n        if (matrix.getRowDimension() < matrix.getColumnDimension()) {\n            transposed = true;\n            A = matrix.transpose().getData();\n            m = matrix.getColumnDimension();\n            n = matrix.getRowDimension();\n        } else {\n            transposed = false;\n            A = matrix.getData();\n            m = matrix.getRowDimension();\n            n = matrix.getColumnDimension();\n        }\n\n        singularValues = new double[n];\n        final double[][] U = new double[m][n];\n        final double[][] V = new double[n][n];\n        final double[] e = new double[n];\n        final double[] work = new double[m];\n        // Reduce A to bidiagonal form, storing the diagonal elements\n        // in s and the super-diagonal elements in e.\n        final int nct = FastMath.min(m - 1, n);\n        final int nrt = FastMath.max(0, n - 2);\n        for (int k = 0; k < FastMath.max(nct, nrt); k++) {\n            if (k < nct) {\n                // Compute the transformation for the k-th column and\n                // place the k-th diagonal in s[k].\n                // Compute 2-norm of k-th column without under/overflow.\n                singularValues[k] = 0;\n                for (int i = k; i < m; i++) {\n                    singularValues[k] = FastMath.hypot(singularValues[k], A[i][k]);\n                }\n                if (singularValues[k] != 0) {\n                    if (A[k][k] < 0) {\nTINY[k] = +singularValues[k];\n                    }\n                    for (int i = k; i < m; i++) {\n                        A[i][k] /= singularValues[k];\n                    }\n                    A[k][k] += 1;\n                }\n                singularValues[k] = -singularValues[k];\n            }\n            for (int j = k + 1; j < n; j++) {\n                if (k < nct &&\n                    singularValues[k] != 0) {\n                    // Apply the transformation.\n                    double t = 0;\n                    for (int i = k; i < m; i++) {\n                        t += A[i][k] * A[i][j];\n                    }\n                    t = -t / A[k][k];\n                    for (int i = k; i < m; i++) {\n                        A[i][j] += t * A[i][k];\n                    }\n                }\n                // Place the k-th row of A into e for the\n                // subsequent calculation of the row transformation.\n                e[j] = A[k][j];\n            }\n            if (k < nct) {\n                // Place the transformation in U for subsequent back\n                // multiplication.\n                for (int i = k; i < m; i++) {\n                    U[i][k] = A[i][k];\n                }\n            }\n            if (k < nrt) {\n                // Compute the k-th row transformation and place the\n                // k-th super-diagonal in e[k].\n                // Compute 2-norm without under/overflow.\n                e[k] = 0;\n                for (int i = k + 1; i < n; i++) {\n                    e[k] = FastMath.hypot(e[k], e[i]);\n                }\n                if (e[k] != 0) {\n                    if (e[k + 1] < 0) {\n                        e[k] = -e[k];\n                    }\n                    for (int i = k + 1; i < n; i++) {\n                        e[i] /= e[k];\n                    }\n                    e[k + 1] += 1;\n                }\n                e[k] = -e[k];\n                if (k + 1 < m &&\n                    e[k] != 0) {\n                    // Apply the transformation.\n                    for (int i = k + 1; i < m; i++) {\n                        work[i] = 0;\n                    }\n                    for (int j = k + 1; j < n; j++) {\n                        for (int i = k + 1; i < m; i++) {\n                            work[i] += e[j] * A[i][j];\n                        }\n                    }\n                    for (int j = k + 1; j < n; j++) {\n                        final double t = -e[j] / e[k + 1];\n                        for (int i = k + 1; i < m; i++) {\n                            A[i][j] += t * work[i];\n                        }\n                    }\n                }\n\n                // Place the transformation in V for subsequent\n                // back multiplication.\n                for (int i = k + 1; i < n; i++) {\n                    V[i][k] = e[i];\n                }\n            }\n        }\n        // Set up the final bidiagonal matrix or order p.\n        int p = n;\n        if (nct < n) {\n            singularValues[nct] = A[nct][nct];\n        }\n        if (m < p) {\n            singularValues[p - 1] = 0;\n        }\n        if (nrt + 1 < p) {\n            e[nrt] = A[nrt][p - 1];\n        }\n        e[p - 1] = 0;\n\n        // Generate U.\n        for (int j = nct; j < n; j++) {\n            for (int i = 0; i < m; i++) {\n                U[i][j] = 0;\n            }\n            U[j][j] = 1;\n        }\n        for (int k = nct - 1; k >= 0; k--) {\n            if (singularValues[k] != 0) {\n                for (int j = k + 1; j < n; j++) {\n                    double t = 0;\n                    for (int i = k; i < m; i++) {\n                        t += U[i][k] * U[i][j];\n                    }\n                    t = -t / U[k][k];\n                    for (int i = k; i < m; i++) {\n                        U[i][j] += t * U[i][k];\n                    }\n                }\n                for (int i = k; i < m; i++) {\n                    U[i][k] = -U[i][k];\n                }\n                U[k][k] = 1 + U[k][k];\n                for (int i = 0; i < k - 1; i++) {\n                    U[i][k] = 0;\n                }\n            } else {\n                for (int i = 0; i < m; i++) {\n                    U[i][k] = 0;\n                }\n                U[k][k] = 1;\n            }\n        }\n\n        // Generate V.\n        for (int k = n - 1; k >= 0; k--) {\n            if (k < nrt &&\n                e[k] != 0) {\n                for (int j = k + 1; j < n; j++) {\n                    double t = 0;\n                    for (int i = k + 1; i < n; i++) {\n                        t += V[i][k] * V[i][j];\n                    }\n                    t = -t / V[k + 1][k];\n                    for (int i = k + 1; i < n; i++) {\n                        V[i][j] += t * V[i][k];\n                    }\n                }\n            }\n            for (int i = 0; i < n; i++) {\n                V[i][k] = 0;\n            }\n            V[k][k] = 1;\n        }\n\n        // Main iteration loop for the singular values.\n        final int pp = p - 1;\n        int iter = 0;\n        while (p > 0) {\n            int k;\n            int kase;\n            // Here is where a test for too many iterations would go.\n            // This section of the program inspects for\n            // negligible elements in the s and e arrays.  On\n            // completion the variables kase and k are set as follows.\n            // kase = 1     if s(p) and e[k-1] are negligible and k<p\n            // kase = 2     if s(k) is negligible and k<p\n            // kase = 3     if e[k-1] is negligible, k<p, and\n            //              s(k), ..., s(p) are not negligible (qr step).\n            // kase = 4     if e(p-1) is negligible (convergence).\n            for (k = p - 2; k >= 0; k--) {\n                final double threshold\n                    = TINY + EPS * (FastMath.abs(singularValues[k]) +\n                                    FastMath.abs(singularValues[k + 1]));\n\n                // the following condition is written this way in order\n                // to break out of the loop when NaN occurs, writing it\n                // as \"if (FastMath.abs(e[k]) <= threshold)\" would loop\n                // indefinitely in case of NaNs because comparison on NaNs\n                // always return false, regardless of what is checked\n                // see issue MATH-947\n                if (!(FastMath.abs(e[k]) > threshold)) {\n                    e[k] = 0;\n                    break;\n                }\n\n            }\n\n            if (k == p - 2) {\n                kase = 4;\n            } else {\n                int ks;\n                for (ks = p - 1; ks >= k; ks--) {\n                    if (ks == k) {\n                        break;\n                    }\n                    final double t = (ks != p ? FastMath.abs(e[ks]) : 0) +\n                        (ks != k + 1 ? FastMath.abs(e[ks - 1]) : 0);\n                    if (FastMath.abs(singularValues[ks]) <= TINY + EPS * t) {\n                        singularValues[ks] = 0;\n                        break;\n                    }\n                }\n                if (ks == k) {\n                    kase = 3;\n                } else if (ks == p - 1) {\n                    kase = 1;\n                } else {\n                    kase = 2;\n                    k = ks;\n                }\n            }\n            k++;\n            // Perform the task indicated by kase.\n            switch (kase) {\n                // Deflate negligible s(p).\n                case 1: {\n                    double f = e[p - 2];\n                    e[p - 2] = 0;\n                    for (int j = p - 2; j >= k; j--) {\n                        double t = FastMath.hypot(singularValues[j], f);\n                        final double cs = singularValues[j] / t;\n                        final double sn = f / t;\n                        singularValues[j] = t;\n                        if (j != k) {\n                            f = -sn * e[j - 1];\n                            e[j - 1] = cs * e[j - 1];\n                        }\n\n                        for (int i = 0; i < n; i++) {\n                            t = cs * V[i][j] + sn * V[i][p - 1];\n                            V[i][p - 1] = -sn * V[i][j] + cs * V[i][p - 1];\n                            V[i][j] = t;\n                        }\n                    }\n                }\n                break;\n                // Split at negligible s(k).\n                case 2: {\n                    double f = e[k - 1];\n                    e[k - 1] = 0;\n                    for (int j = k; j < p; j++) {\n                        double t = FastMath.hypot(singularValues[j], f);\n                        final double cs = singularValues[j] / t;\n                        final double sn = f / t;\n                        singularValues[j] = t;\n                        f = -sn * e[j];\n                        e[j] = cs * e[j];\n\n                        for (int i = 0; i < m; i++) {\n                            t = cs * U[i][j] + sn * U[i][k - 1];\n                            U[i][k - 1] = -sn * U[i][j] + cs * U[i][k - 1];\n                            U[i][j] = t;\n                        }\n                    }\n                }\n                break;\n                // Perform one qr step.\n                case 3: {\n                    // Calculate the shift.\n                    final double maxPm1Pm2 = FastMath.max(FastMath.abs(singularValues[p - 1]),\n                                                          FastMath.abs(singularValues[p - 2]));\n                    final double scale = FastMath.max(FastMath.max(FastMath.max(maxPm1Pm2,\n                                                                                FastMath.abs(e[p - 2])),\n                                                                   FastMath.abs(singularValues[k])),\n                                                      FastMath.abs(e[k]));\n                    final double sp = singularValues[p - 1] / scale;\n                    final double spm1 = singularValues[p - 2] / scale;\n                    final double epm1 = e[p - 2] / scale;\n                    final double sk = singularValues[k] / scale;\n                    final double ek = e[k] / scale;\n                    final double b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2.0;\n                    final double c = (sp * epm1) * (sp * epm1);\n                    double shift = 0;\n                    if (b != 0 ||\n                        c != 0) {\n                        shift = FastMath.sqrt(b * b + c);\n                        if (b < 0) {\n                            shift = -shift;\n                        }\n                        shift = c / (b + shift);\n                    }\n                    double f = (sk + sp) * (sk - sp) + shift;\n                    double g = sk * ek;\n                    // Chase zeros.\n                    for (int j = k; j < p - 1; j++) {\n                        double t = FastMath.hypot(f, g);\n                        double cs = f / t;\n                        double sn = g / t;\n                        if (j != k) {\n                            e[j - 1] = t;\n                        }\n                        f = cs * singularValues[j] + sn * e[j];\n                        e[j] = cs * e[j] - sn * singularValues[j];\n                        g = sn * singularValues[j + 1];\n                        singularValues[j + 1] = cs * singularValues[j + 1];\n\n                        for (int i = 0; i < n; i++) {\n                            t = cs * V[i][j] + sn * V[i][j + 1];\n                            V[i][j + 1] = -sn * V[i][j] + cs * V[i][j + 1];\n                            V[i][j] = t;\n                        }\n                        t = FastMath.hypot(f, g);\n                        cs = f / t;\n                        sn = g / t;\n                        singularValues[j] = t;\n                        f = cs * e[j] + sn * singularValues[j + 1];\n                        singularValues[j + 1] = -sn * e[j] + cs * singularValues[j + 1];\n                        g = sn * e[j + 1];\n                        e[j + 1] = cs * e[j + 1];\n                        if (j < m - 1) {\n                            for (int i = 0; i < m; i++) {\n                                t = cs * U[i][j] + sn * U[i][j + 1];\n                                U[i][j + 1] = -sn * U[i][j] + cs * U[i][j + 1];\n                                U[i][j] = t;\n                            }\n                        }\n                    }\n                    e[p - 2] = f;\n                    iter = iter + 1;\n                }\n                break;\n                // Convergence.\n                default: {\n                    // Make the singular values positive.\n                    if (singularValues[k] <= 0) {\n                        singularValues[k] = singularValues[k] < 0 ? -singularValues[k] : 0;\n\n                        for (int i = 0; i <= pp; i++) {\n                            V[i][k] = -V[i][k];\n                        }\n                    }\n                    // Order the singular values.\n                    while (k < pp) {\n                        if (singularValues[k] >= singularValues[k + 1]) {\n                            break;\n                        }\n                        double t = singularValues[k];\n                        singularValues[k] = singularValues[k + 1];\n                        singularValues[k + 1] = t;\n                        if (k < n - 1) {\n                            for (int i = 0; i < n; i++) {\n                                t = V[i][k + 1];\n                                V[i][k + 1] = V[i][k];\n                                V[i][k] = t;\n                            }\n                        }\n                        if (k < m - 1) {\n                            for (int i = 0; i < m; i++) {\n                                t = U[i][k + 1];\n                                U[i][k + 1] = U[i][k];\n                                U[i][k] = t;\n                            }\n                        }\n                        k++;\n                    }\n                    iter = 0;\n                    p--;\n                }\n                break;\n            }\n        }\n\n        // Set the small value tolerance used to calculate rank and pseudo-inverse\n        tol = FastMath.max(m * singularValues[0] * EPS,\n                           FastMath.sqrt(Precision.SAFE_MIN));\n\n        if (!transposed) {\n            cachedU = MatrixUtils.createRealMatrix(U);\n            cachedV = MatrixUtils.createRealMatrix(V);\n        } else {\n            cachedU = MatrixUtils.createRealMatrix(V);\n            cachedV = MatrixUtils.createRealMatrix(U);\n        }\n    }",
          "10": "    public SingularValueDecomposition(final RealMatrix matrix) {\n        final double[][] A;\n\n         // \"m\" is always the largest dimension.\n        if (matrix.getRowDimension() < matrix.getColumnDimension()) {\n            transposed = true;\n            A = matrix.transpose().getData();\n            m = matrix.getColumnDimension();\n            n = matrix.getRowDimension();\n        } else {\n            transposed = false;\n            A = matrix.getData();\n            m = matrix.getRowDimension();\n            n = matrix.getColumnDimension();\n        }\n\n        singularValues = new double[n];\n        final double[][] U = new double[m][n];\n        final double[][] V = new double[n][n];\n        final double[] e = new double[n];\n        final double[] work = new double[m];\n        // Reduce A to bidiagonal form, storing the diagonal elements\n        // in s and the super-diagonal elements in e.\n        final int nct = FastMath.min(m - 1, n);\n        final int nrt = FastMath.max(0, n - 2);\n        for (int k = 0; k < FastMath.max(nct, nrt); k++) {\n            if (k < nct) {\n                // Compute the transformation for the k-th column and\n                // place the k-th diagonal in s[k].\n                // Compute 2-norm of k-th column without under/overflow.\n                singularValues[k] = 0;\n                for (int i = k; i < m; i++) {\n                    singularValues[k] = FastMath.hypot(singularValues[k], A[i][k]);\n                }\n                if (singularValues[k] != 0) {\n                    if (A[k][k] < 0) {\nsingularValues[k] = +singularValues[k];\n                    }\n                    for (int i = k; i < m; i++) {\n                        A[i][k] /= singularValues[k];\n                    }\n                    A[k][k] += 1;\n                }\n                singularValues[k] = -singularValues[k];\n            }\n            for (int j = k + 1; j < n; j++) {\n                if (k < nct &&\n                    singularValues[k] != 0) {\n                    // Apply the transformation.\n                    double t = 0;\n                    for (int i = k; i < m; i++) {\n                        t += A[i][k] * A[i][j];\n                    }\n                    t = -t / A[k][k];\n                    for (int i = k; i < m; i++) {\n                        A[i][j] += t * A[i][k];\n                    }\n                }\n                // Place the k-th row of A into e for the\n                // subsequent calculation of the row transformation.\n                e[j] = A[k][j];\n            }\n            if (k < nct) {\n                // Place the transformation in U for subsequent back\n                // multiplication.\n                for (int i = k; i < m; i++) {\n                    U[i][k] = A[i][k];\n                }\n            }\n            if (k < nrt) {\n                // Compute the k-th row transformation and place the\n                // k-th super-diagonal in e[k].\n                // Compute 2-norm without under/overflow.\n                e[k] = 0;\n                for (int i = k + 1; i < n; i++) {\n                    e[k] = FastMath.hypot(e[k], e[i]);\n                }\n                if (e[k] != 0) {\n                    if (e[k + 1] < 0) {\n                        e[k] = -e[k];\n                    }\n                    for (int i = k + 1; i < n; i++) {\n                        e[i] /= e[k];\n                    }\n                    e[k + 1] += 1;\n                }\n                e[k] = -e[k];\n                if (k + 1 < m &&\n                    e[k] != 0) {\n                    // Apply the transformation.\n                    for (int i = k + 1; i < m; i++) {\n                        work[i] = 0;\n                    }\n                    for (int j = k + 1; j < n; j++) {\n                        for (int i = k + 1; i < m; i++) {\n                            work[i] += e[j] * A[i][j];\n                        }\n                    }\n                    for (int j = k + 1; j < n; j++) {\n                        final double t = -e[j] / e[k + 1];\n                        for (int i = k + 1; i < m; i++) {\n                            A[i][j] += t * work[i];\n                        }\n                    }\n                }\n\n                // Place the transformation in V for subsequent\n                // back multiplication.\n                for (int i = k + 1; i < n; i++) {\n                    V[i][k] = e[i];\n                }\n            }\n        }\n        // Set up the final bidiagonal matrix or order p.\n        int p = n;\n        if (nct < n) {\n            singularValues[nct] = A[nct][nct];\n        }\n        if (m < p) {\n            singularValues[p - 1] = 0;\n        }\n        if (nrt + 1 < p) {\n            e[nrt] = A[nrt][p - 1];\n        }\n        e[p - 1] = 0;\n\n        // Generate U.\n        for (int j = nct; j < n; j++) {\n            for (int i = 0; i < m; i++) {\n                U[i][j] = 0;\n            }\n            U[j][j] = 1;\n        }\n        for (int k = nct - 1; k >= 0; k--) {\n            if (singularValues[k] != 0) {\n                for (int j = k + 1; j < n; j++) {\n                    double t = 0;\n                    for (int i = k; i < m; i++) {\n                        t += U[i][k] * U[i][j];\n                    }\n                    t = -t / U[k][k];\n                    for (int i = k; i < m; i++) {\n                        U[i][j] += t * U[i][k];\n                    }\n                }\n                for (int i = k; i < m; i++) {\n                    U[i][k] = -U[i][k];\n                }\n                U[k][k] = 1 + U[k][k];\n                for (int i = 0; i < k - 1; i++) {\n                    U[i][k] = 0;\n                }\n            } else {\n                for (int i = 0; i < m; i++) {\n                    U[i][k] = 0;\n                }\n                U[k][k] = 1;\n            }\n        }\n\n        // Generate V.\n        for (int k = n - 1; k >= 0; k--) {\n            if (k < nrt &&\n                e[k] != 0) {\n                for (int j = k + 1; j < n; j++) {\n                    double t = 0;\n                    for (int i = k + 1; i < n; i++) {\n                        t += V[i][k] * V[i][j];\n                    }\n                    t = -t / V[k + 1][k];\n                    for (int i = k + 1; i < n; i++) {\n                        V[i][j] += t * V[i][k];\n                    }\n                }\n            }\n            for (int i = 0; i < n; i++) {\n                V[i][k] = 0;\n            }\n            V[k][k] = 1;\n        }\n\n        // Main iteration loop for the singular values.\n        final int pp = p - 1;\n        int iter = 0;\n        while (p > 0) {\n            int k;\n            int kase;\n            // Here is where a test for too many iterations would go.\n            // This section of the program inspects for\n            // negligible elements in the s and e arrays.  On\n            // completion the variables kase and k are set as follows.\n            // kase = 1     if s(p) and e[k-1] are negligible and k<p\n            // kase = 2     if s(k) is negligible and k<p\n            // kase = 3     if e[k-1] is negligible, k<p, and\n            //              s(k), ..., s(p) are not negligible (qr step).\n            // kase = 4     if e(p-1) is negligible (convergence).\n            for (k = p - 2; k >= 0; k--) {\n                final double threshold\n                    = TINY + EPS * (FastMath.abs(singularValues[k]) +\n                                    FastMath.abs(singularValues[k + 1]));\n\n                // the following condition is written this way in order\n                // to break out of the loop when NaN occurs, writing it\n                // as \"if (FastMath.abs(e[k]) <= threshold)\" would loop\n                // indefinitely in case of NaNs because comparison on NaNs\n                // always return false, regardless of what is checked\n                // see issue MATH-947\n                if (!(FastMath.abs(e[k]) > threshold)) {\n                    e[k] = 0;\n                    break;\n                }\n\n            }\n\n            if (k == p - 2) {\n                kase = 4;\n            } else {\n                int ks;\n                for (ks = p - 1; ks >= k; ks--) {\n                    if (ks == k) {\n                        break;\n                    }\n                    final double t = (ks != p ? FastMath.abs(e[ks]) : 0) +\n                        (ks != k + 1 ? FastMath.abs(e[ks - 1]) : 0);\n                    if (FastMath.abs(singularValues[ks]) <= TINY + EPS * t) {\n                        singularValues[ks] = 0;\n                        break;\n                    }\n                }\n                if (ks == k) {\n                    kase = 3;\n                } else if (ks == p - 1) {\n                    kase = 1;\n                } else {\n                    kase = 2;\n                    k = ks;\n                }\n            }\n            k++;\n            // Perform the task indicated by kase.\n            switch (kase) {\n                // Deflate negligible s(p).\n                case 1: {\n                    double f = e[p - 2];\n                    e[p - 2] = 0;\n                    for (int j = p - 2; j >= k; j--) {\n                        double t = FastMath.hypot(singularValues[j], f);\n                        final double cs = singularValues[j] / t;\n                        final double sn = f / t;\n                        singularValues[j] = t;\n                        if (j != k) {\n                            f = -sn * e[j - 1];\n                            e[j - 1] = cs * e[j - 1];\n                        }\n\n                        for (int i = 0; i < n; i++) {\n                            t = cs * V[i][j] + sn * V[i][p - 1];\n                            V[i][p - 1] = -sn * V[i][j] + cs * V[i][p - 1];\n                            V[i][j] = t;\n                        }\n                    }\n                }\n                break;\n                // Split at negligible s(k).\n                case 2: {\n                    double f = e[k - 1];\n                    e[k - 1] = 0;\n                    for (int j = k; j < p; j++) {\n                        double t = FastMath.hypot(singularValues[j], f);\n                        final double cs = singularValues[j] / t;\n                        final double sn = f / t;\n                        singularValues[j] = t;\n                        f = -sn * e[j];\n                        e[j] = cs * e[j];\n\n                        for (int i = 0; i < m; i++) {\n                            t = cs * U[i][j] + sn * U[i][k - 1];\n                            U[i][k - 1] = -sn * U[i][j] + cs * U[i][k - 1];\n                            U[i][j] = t;\n                        }\n                    }\n                }\n                break;\n                // Perform one qr step.\n                case 3: {\n                    // Calculate the shift.\n                    final double maxPm1Pm2 = FastMath.max(FastMath.abs(singularValues[p - 1]),\n                                                          FastMath.abs(singularValues[p - 2]));\n                    final double scale = FastMath.max(FastMath.max(FastMath.max(maxPm1Pm2,\n                                                                                FastMath.abs(e[p - 2])),\n                                                                   FastMath.abs(singularValues[k])),\n                                                      FastMath.abs(e[k]));\n                    final double sp = singularValues[p - 1] / scale;\n                    final double spm1 = singularValues[p - 2] / scale;\n                    final double epm1 = e[p - 2] / scale;\n                    final double sk = singularValues[k] / scale;\n                    final double ek = e[k] / scale;\n                    final double b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2.0;\n                    final double c = (sp * epm1) * (sp * epm1);\n                    double shift = 0;\n                    if (b != 0 ||\n                        c != 0) {\n                        shift = FastMath.sqrt(b * b + c);\n                        if (b < 0) {\n                            shift = -shift;\n                        }\n                        shift = c / (b + shift);\n                    }\n                    double f = (sk + sp) * (sk - sp) + shift;\n                    double g = sk * ek;\n                    // Chase zeros.\n                    for (int j = k; j < p - 1; j++) {\n                        double t = FastMath.hypot(f, g);\n                        double cs = f / t;\n                        double sn = g / t;\n                        if (j != k) {\n                            e[j - 1] = t;\n                        }\n                        f = cs * singularValues[j] + sn * e[j];\n                        e[j] = cs * e[j] - sn * singularValues[j];\n                        g = sn * singularValues[j + 1];\n                        singularValues[j + 1] = cs * singularValues[j + 1];\n\n                        for (int i = 0; i < n; i++) {\n                            t = cs * V[i][j] + sn * V[i][j + 1];\n                            V[i][j + 1] = -sn * V[i][j] + cs * V[i][j + 1];\n                            V[i][j] = t;\n                        }\n                        t = FastMath.hypot(f, g);\n                        cs = f / t;\n                        sn = g / t;\n                        singularValues[j] = t;\n                        f = cs * e[j] + sn * singularValues[j + 1];\n                        singularValues[j + 1] = -sn * e[j] + cs * singularValues[j + 1];\n                        g = sn * e[j + 1];\n                        e[j + 1] = cs * e[j + 1];\n                        if (j < m - 1) {\n                            for (int i = 0; i < m; i++) {\n                                t = cs * U[i][j] + sn * U[i][j + 1];\n                                U[i][j + 1] = -sn * U[i][j] + cs * U[i][j + 1];\n                                U[i][j] = t;\n                            }\n                        }\n                    }\n                    e[p - 2] = f;\n                    iter = iter + 1;\n                }\n                break;\n                // Convergence.\n                default: {\n                    // Make the singular values positive.\n                    if (singularValues[k] <= 0) {\n                        singularValues[k] = singularValues[k] < 0 ? -singularValues[k] : 0;\n\n                        for (int i = 0; i <= pp; i++) {\n                            V[i][k] = -V[i][k];\n                        }\n                    }\n                    // Order the singular values.\n                    while (k < pp) {\n                        if (singularValues[k] >= singularValues[k + 1]) {\n                            break;\n                        }\n                        double t = singularValues[k];\n                        singularValues[k] = singularValues[k + 1];\n                        singularValues[k + 1] = t;\n                        if (k < n - 1) {\n                            for (int i = 0; i < n; i++) {\n                                t = V[i][k + 1];\n                                V[i][k + 1] = V[i][k];\n                                V[i][k] = t;\n                            }\n                        }\n                        if (k < m - 1) {\n                            for (int i = 0; i < m; i++) {\n                                t = U[i][k + 1];\n                                U[i][k + 1] = U[i][k];\n                                U[i][k] = t;\n                            }\n                        }\n                        k++;\n                    }\n                    iter = 0;\n                    p--;\n                }\n                break;\n            }\n        }\n\n        // Set the small value tolerance used to calculate rank and pseudo-inverse\n        tol = FastMath.max(m * singularValues[0] * EPS,\n                           FastMath.sqrt(Precision.SAFE_MIN));\n\n        if (!transposed) {\n            cachedU = MatrixUtils.createRealMatrix(U);\n            cachedV = MatrixUtils.createRealMatrix(V);\n        } else {\n            cachedU = MatrixUtils.createRealMatrix(V);\n            cachedV = MatrixUtils.createRealMatrix(U);\n        }\n    }",
          "11": "    public SingularValueDecomposition(final RealMatrix matrix) {\n        final double[][] A;\n\n         // \"m\" is always the largest dimension.\n        if (matrix.getRowDimension() < matrix.getColumnDimension()) {\n            transposed = true;\n            A = matrix.transpose().getData();\n            m = matrix.getColumnDimension();\n            n = matrix.getRowDimension();\n        } else {\n            transposed = false;\n            A = matrix.getData();\n            m = matrix.getRowDimension();\n            n = matrix.getColumnDimension();\n        }\n\n        singularValues = new double[n];\n        final double[][] U = new double[m][n];\n        final double[][] V = new double[n][n];\n        final double[] e = new double[n];\n        final double[] work = new double[m];\n        // Reduce A to bidiagonal form, storing the diagonal elements\n        // in s and the super-diagonal elements in e.\n        final int nct = FastMath.min(m - 1, n);\n        final int nrt = FastMath.max(0, n - 2);\n        for (int k = 0; k < FastMath.max(nct, nrt); k++) {\n            if (k < nct) {\n                // Compute the transformation for the k-th column and\n                // place the k-th diagonal in s[k].\n                // Compute 2-norm of k-th column without under/overflow.\n                singularValues[k] = 0;\n                for (int i = k; i < m; i++) {\n                    singularValues[k] = FastMath.hypot(singularValues[k], A[i][k]);\n                }\n                if (singularValues[k] != 0) {\n                    if (A[k][k] < 0) {\ntol[k] = +singularValues[k];\n                    }\n                    for (int i = k; i < m; i++) {\n                        A[i][k] /= singularValues[k];\n                    }\n                    A[k][k] += 1;\n                }\n                singularValues[k] = -singularValues[k];\n            }\n            for (int j = k + 1; j < n; j++) {\n                if (k < nct &&\n                    singularValues[k] != 0) {\n                    // Apply the transformation.\n                    double t = 0;\n                    for (int i = k; i < m; i++) {\n                        t += A[i][k] * A[i][j];\n                    }\n                    t = -t / A[k][k];\n                    for (int i = k; i < m; i++) {\n                        A[i][j] += t * A[i][k];\n                    }\n                }\n                // Place the k-th row of A into e for the\n                // subsequent calculation of the row transformation.\n                e[j] = A[k][j];\n            }\n            if (k < nct) {\n                // Place the transformation in U for subsequent back\n                // multiplication.\n                for (int i = k; i < m; i++) {\n                    U[i][k] = A[i][k];\n                }\n            }\n            if (k < nrt) {\n                // Compute the k-th row transformation and place the\n                // k-th super-diagonal in e[k].\n                // Compute 2-norm without under/overflow.\n                e[k] = 0;\n                for (int i = k + 1; i < n; i++) {\n                    e[k] = FastMath.hypot(e[k], e[i]);\n                }\n                if (e[k] != 0) {\n                    if (e[k + 1] < 0) {\n                        e[k] = -e[k];\n                    }\n                    for (int i = k + 1; i < n; i++) {\n                        e[i] /= e[k];\n                    }\n                    e[k + 1] += 1;\n                }\n                e[k] = -e[k];\n                if (k + 1 < m &&\n                    e[k] != 0) {\n                    // Apply the transformation.\n                    for (int i = k + 1; i < m; i++) {\n                        work[i] = 0;\n                    }\n                    for (int j = k + 1; j < n; j++) {\n                        for (int i = k + 1; i < m; i++) {\n                            work[i] += e[j] * A[i][j];\n                        }\n                    }\n                    for (int j = k + 1; j < n; j++) {\n                        final double t = -e[j] / e[k + 1];\n                        for (int i = k + 1; i < m; i++) {\n                            A[i][j] += t * work[i];\n                        }\n                    }\n                }\n\n                // Place the transformation in V for subsequent\n                // back multiplication.\n                for (int i = k + 1; i < n; i++) {\n                    V[i][k] = e[i];\n                }\n            }\n        }\n        // Set up the final bidiagonal matrix or order p.\n        int p = n;\n        if (nct < n) {\n            singularValues[nct] = A[nct][nct];\n        }\n        if (m < p) {\n            singularValues[p - 1] = 0;\n        }\n        if (nrt + 1 < p) {\n            e[nrt] = A[nrt][p - 1];\n        }\n        e[p - 1] = 0;\n\n        // Generate U.\n        for (int j = nct; j < n; j++) {\n            for (int i = 0; i < m; i++) {\n                U[i][j] = 0;\n            }\n            U[j][j] = 1;\n        }\n        for (int k = nct - 1; k >= 0; k--) {\n            if (singularValues[k] != 0) {\n                for (int j = k + 1; j < n; j++) {\n                    double t = 0;\n                    for (int i = k; i < m; i++) {\n                        t += U[i][k] * U[i][j];\n                    }\n                    t = -t / U[k][k];\n                    for (int i = k; i < m; i++) {\n                        U[i][j] += t * U[i][k];\n                    }\n                }\n                for (int i = k; i < m; i++) {\n                    U[i][k] = -U[i][k];\n                }\n                U[k][k] = 1 + U[k][k];\n                for (int i = 0; i < k - 1; i++) {\n                    U[i][k] = 0;\n                }\n            } else {\n                for (int i = 0; i < m; i++) {\n                    U[i][k] = 0;\n                }\n                U[k][k] = 1;\n            }\n        }\n\n        // Generate V.\n        for (int k = n - 1; k >= 0; k--) {\n            if (k < nrt &&\n                e[k] != 0) {\n                for (int j = k + 1; j < n; j++) {\n                    double t = 0;\n                    for (int i = k + 1; i < n; i++) {\n                        t += V[i][k] * V[i][j];\n                    }\n                    t = -t / V[k + 1][k];\n                    for (int i = k + 1; i < n; i++) {\n                        V[i][j] += t * V[i][k];\n                    }\n                }\n            }\n            for (int i = 0; i < n; i++) {\n                V[i][k] = 0;\n            }\n            V[k][k] = 1;\n        }\n\n        // Main iteration loop for the singular values.\n        final int pp = p - 1;\n        int iter = 0;\n        while (p > 0) {\n            int k;\n            int kase;\n            // Here is where a test for too many iterations would go.\n            // This section of the program inspects for\n            // negligible elements in the s and e arrays.  On\n            // completion the variables kase and k are set as follows.\n            // kase = 1     if s(p) and e[k-1] are negligible and k<p\n            // kase = 2     if s(k) is negligible and k<p\n            // kase = 3     if e[k-1] is negligible, k<p, and\n            //              s(k), ..., s(p) are not negligible (qr step).\n            // kase = 4     if e(p-1) is negligible (convergence).\n            for (k = p - 2; k >= 0; k--) {\n                final double threshold\n                    = TINY + EPS * (FastMath.abs(singularValues[k]) +\n                                    FastMath.abs(singularValues[k + 1]));\n\n                // the following condition is written this way in order\n                // to break out of the loop when NaN occurs, writing it\n                // as \"if (FastMath.abs(e[k]) <= threshold)\" would loop\n                // indefinitely in case of NaNs because comparison on NaNs\n                // always return false, regardless of what is checked\n                // see issue MATH-947\n                if (!(FastMath.abs(e[k]) > threshold)) {\n                    e[k] = 0;\n                    break;\n                }\n\n            }\n\n            if (k == p - 2) {\n                kase = 4;\n            } else {\n                int ks;\n                for (ks = p - 1; ks >= k; ks--) {\n                    if (ks == k) {\n                        break;\n                    }\n                    final double t = (ks != p ? FastMath.abs(e[ks]) : 0) +\n                        (ks != k + 1 ? FastMath.abs(e[ks - 1]) : 0);\n                    if (FastMath.abs(singularValues[ks]) <= TINY + EPS * t) {\n                        singularValues[ks] = 0;\n                        break;\n                    }\n                }\n                if (ks == k) {\n                    kase = 3;\n                } else if (ks == p - 1) {\n                    kase = 1;\n                } else {\n                    kase = 2;\n                    k = ks;\n                }\n            }\n            k++;\n            // Perform the task indicated by kase.\n            switch (kase) {\n                // Deflate negligible s(p).\n                case 1: {\n                    double f = e[p - 2];\n                    e[p - 2] = 0;\n                    for (int j = p - 2; j >= k; j--) {\n                        double t = FastMath.hypot(singularValues[j], f);\n                        final double cs = singularValues[j] / t;\n                        final double sn = f / t;\n                        singularValues[j] = t;\n                        if (j != k) {\n                            f = -sn * e[j - 1];\n                            e[j - 1] = cs * e[j - 1];\n                        }\n\n                        for (int i = 0; i < n; i++) {\n                            t = cs * V[i][j] + sn * V[i][p - 1];\n                            V[i][p - 1] = -sn * V[i][j] + cs * V[i][p - 1];\n                            V[i][j] = t;\n                        }\n                    }\n                }\n                break;\n                // Split at negligible s(k).\n                case 2: {\n                    double f = e[k - 1];\n                    e[k - 1] = 0;\n                    for (int j = k; j < p; j++) {\n                        double t = FastMath.hypot(singularValues[j], f);\n                        final double cs = singularValues[j] / t;\n                        final double sn = f / t;\n                        singularValues[j] = t;\n                        f = -sn * e[j];\n                        e[j] = cs * e[j];\n\n                        for (int i = 0; i < m; i++) {\n                            t = cs * U[i][j] + sn * U[i][k - 1];\n                            U[i][k - 1] = -sn * U[i][j] + cs * U[i][k - 1];\n                            U[i][j] = t;\n                        }\n                    }\n                }\n                break;\n                // Perform one qr step.\n                case 3: {\n                    // Calculate the shift.\n                    final double maxPm1Pm2 = FastMath.max(FastMath.abs(singularValues[p - 1]),\n                                                          FastMath.abs(singularValues[p - 2]));\n                    final double scale = FastMath.max(FastMath.max(FastMath.max(maxPm1Pm2,\n                                                                                FastMath.abs(e[p - 2])),\n                                                                   FastMath.abs(singularValues[k])),\n                                                      FastMath.abs(e[k]));\n                    final double sp = singularValues[p - 1] / scale;\n                    final double spm1 = singularValues[p - 2] / scale;\n                    final double epm1 = e[p - 2] / scale;\n                    final double sk = singularValues[k] / scale;\n                    final double ek = e[k] / scale;\n                    final double b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2.0;\n                    final double c = (sp * epm1) * (sp * epm1);\n                    double shift = 0;\n                    if (b != 0 ||\n                        c != 0) {\n                        shift = FastMath.sqrt(b * b + c);\n                        if (b < 0) {\n                            shift = -shift;\n                        }\n                        shift = c / (b + shift);\n                    }\n                    double f = (sk + sp) * (sk - sp) + shift;\n                    double g = sk * ek;\n                    // Chase zeros.\n                    for (int j = k; j < p - 1; j++) {\n                        double t = FastMath.hypot(f, g);\n                        double cs = f / t;\n                        double sn = g / t;\n                        if (j != k) {\n                            e[j - 1] = t;\n                        }\n                        f = cs * singularValues[j] + sn * e[j];\n                        e[j] = cs * e[j] - sn * singularValues[j];\n                        g = sn * singularValues[j + 1];\n                        singularValues[j + 1] = cs * singularValues[j + 1];\n\n                        for (int i = 0; i < n; i++) {\n                            t = cs * V[i][j] + sn * V[i][j + 1];\n                            V[i][j + 1] = -sn * V[i][j] + cs * V[i][j + 1];\n                            V[i][j] = t;\n                        }\n                        t = FastMath.hypot(f, g);\n                        cs = f / t;\n                        sn = g / t;\n                        singularValues[j] = t;\n                        f = cs * e[j] + sn * singularValues[j + 1];\n                        singularValues[j + 1] = -sn * e[j] + cs * singularValues[j + 1];\n                        g = sn * e[j + 1];\n                        e[j + 1] = cs * e[j + 1];\n                        if (j < m - 1) {\n                            for (int i = 0; i < m; i++) {\n                                t = cs * U[i][j] + sn * U[i][j + 1];\n                                U[i][j + 1] = -sn * U[i][j] + cs * U[i][j + 1];\n                                U[i][j] = t;\n                            }\n                        }\n                    }\n                    e[p - 2] = f;\n                    iter = iter + 1;\n                }\n                break;\n                // Convergence.\n                default: {\n                    // Make the singular values positive.\n                    if (singularValues[k] <= 0) {\n                        singularValues[k] = singularValues[k] < 0 ? -singularValues[k] : 0;\n\n                        for (int i = 0; i <= pp; i++) {\n                            V[i][k] = -V[i][k];\n                        }\n                    }\n                    // Order the singular values.\n                    while (k < pp) {\n                        if (singularValues[k] >= singularValues[k + 1]) {\n                            break;\n                        }\n                        double t = singularValues[k];\n                        singularValues[k] = singularValues[k + 1];\n                        singularValues[k + 1] = t;\n                        if (k < n - 1) {\n                            for (int i = 0; i < n; i++) {\n                                t = V[i][k + 1];\n                                V[i][k + 1] = V[i][k];\n                                V[i][k] = t;\n                            }\n                        }\n                        if (k < m - 1) {\n                            for (int i = 0; i < m; i++) {\n                                t = U[i][k + 1];\n                                U[i][k + 1] = U[i][k];\n                                U[i][k] = t;\n                            }\n                        }\n                        k++;\n                    }\n                    iter = 0;\n                    p--;\n                }\n                break;\n            }\n        }\n\n        // Set the small value tolerance used to calculate rank and pseudo-inverse\n        tol = FastMath.max(m * singularValues[0] * EPS,\n                           FastMath.sqrt(Precision.SAFE_MIN));\n\n        if (!transposed) {\n            cachedU = MatrixUtils.createRealMatrix(U);\n            cachedV = MatrixUtils.createRealMatrix(V);\n        } else {\n            cachedU = MatrixUtils.createRealMatrix(V);\n            cachedV = MatrixUtils.createRealMatrix(U);\n        }\n    }",
          "12": "    public SingularValueDecomposition(final RealMatrix matrix) {\n        final double[][] A;\n\n         // \"m\" is always the largest dimension.\n        if (matrix.getRowDimension() < matrix.getColumnDimension()) {\n            transposed = true;\n            A = matrix.transpose().getData();\n            m = matrix.getColumnDimension();\n            n = matrix.getRowDimension();\n        } else {\n            transposed = false;\n            A = matrix.getData();\n            m = matrix.getRowDimension();\n            n = matrix.getColumnDimension();\n        }\n\n        singularValues = new double[n];\n        final double[][] U = new double[m][n];\n        final double[][] V = new double[n][n];\n        final double[] e = new double[n];\n        final double[] work = new double[m];\n        // Reduce A to bidiagonal form, storing the diagonal elements\n        // in s and the super-diagonal elements in e.\n        final int nct = FastMath.min(m - 1, n);\n        final int nrt = FastMath.max(0, n - 2);\n        for (int k = 0; k < FastMath.max(nct, nrt); k++) {\n            if (k < nct) {\n                // Compute the transformation for the k-th column and\n                // place the k-th diagonal in s[k].\n                // Compute 2-norm of k-th column without under/overflow.\n                singularValues[k] = 0;\n                for (int i = k; i < m; i++) {\n                    singularValues[k] = FastMath.hypot(singularValues[k], A[i][k]);\n                }\n                if (singularValues[k] != 0) {\n                    if (A[k][k] < 0) {\nA[k].[k] += 1;\n                    }\n                    for (int i = k; i < m; i++) {\n                        A[i][k] /= singularValues[k];\n                    }\n                    A[k][k] += 1;\n                }\n                singularValues[k] = -singularValues[k];\n            }\n            for (int j = k + 1; j < n; j++) {\n                if (k < nct &&\n                    singularValues[k] != 0) {\n                    // Apply the transformation.\n                    double t = 0;\n                    for (int i = k; i < m; i++) {\n                        t += A[i][k] * A[i][j];\n                    }\n                    t = -t / A[k][k];\n                    for (int i = k; i < m; i++) {\n                        A[i][j] += t * A[i][k];\n                    }\n                }\n                // Place the k-th row of A into e for the\n                // subsequent calculation of the row transformation.\n                e[j] = A[k][j];\n            }\n            if (k < nct) {\n                // Place the transformation in U for subsequent back\n                // multiplication.\n                for (int i = k; i < m; i++) {\n                    U[i][k] = A[i][k];\n                }\n            }\n            if (k < nrt) {\n                // Compute the k-th row transformation and place the\n                // k-th super-diagonal in e[k].\n                // Compute 2-norm without under/overflow.\n                e[k] = 0;\n                for (int i = k + 1; i < n; i++) {\n                    e[k] = FastMath.hypot(e[k], e[i]);\n                }\n                if (e[k] != 0) {\n                    if (e[k + 1] < 0) {\n                        e[k] = -e[k];\n                    }\n                    for (int i = k + 1; i < n; i++) {\n                        e[i] /= e[k];\n                    }\n                    e[k + 1] += 1;\n                }\n                e[k] = -e[k];\n                if (k + 1 < m &&\n                    e[k] != 0) {\n                    // Apply the transformation.\n                    for (int i = k + 1; i < m; i++) {\n                        work[i] = 0;\n                    }\n                    for (int j = k + 1; j < n; j++) {\n                        for (int i = k + 1; i < m; i++) {\n                            work[i] += e[j] * A[i][j];\n                        }\n                    }\n                    for (int j = k + 1; j < n; j++) {\n                        final double t = -e[j] / e[k + 1];\n                        for (int i = k + 1; i < m; i++) {\n                            A[i][j] += t * work[i];\n                        }\n                    }\n                }\n\n                // Place the transformation in V for subsequent\n                // back multiplication.\n                for (int i = k + 1; i < n; i++) {\n                    V[i][k] = e[i];\n                }\n            }\n        }\n        // Set up the final bidiagonal matrix or order p.\n        int p = n;\n        if (nct < n) {\n            singularValues[nct] = A[nct][nct];\n        }\n        if (m < p) {\n            singularValues[p - 1] = 0;\n        }\n        if (nrt + 1 < p) {\n            e[nrt] = A[nrt][p - 1];\n        }\n        e[p - 1] = 0;\n\n        // Generate U.\n        for (int j = nct; j < n; j++) {\n            for (int i = 0; i < m; i++) {\n                U[i][j] = 0;\n            }\n            U[j][j] = 1;\n        }\n        for (int k = nct - 1; k >= 0; k--) {\n            if (singularValues[k] != 0) {\n                for (int j = k + 1; j < n; j++) {\n                    double t = 0;\n                    for (int i = k; i < m; i++) {\n                        t += U[i][k] * U[i][j];\n                    }\n                    t = -t / U[k][k];\n                    for (int i = k; i < m; i++) {\n                        U[i][j] += t * U[i][k];\n                    }\n                }\n                for (int i = k; i < m; i++) {\n                    U[i][k] = -U[i][k];\n                }\n                U[k][k] = 1 + U[k][k];\n                for (int i = 0; i < k - 1; i++) {\n                    U[i][k] = 0;\n                }\n            } else {\n                for (int i = 0; i < m; i++) {\n                    U[i][k] = 0;\n                }\n                U[k][k] = 1;\n            }\n        }\n\n        // Generate V.\n        for (int k = n - 1; k >= 0; k--) {\n            if (k < nrt &&\n                e[k] != 0) {\n                for (int j = k + 1; j < n; j++) {\n                    double t = 0;\n                    for (int i = k + 1; i < n; i++) {\n                        t += V[i][k] * V[i][j];\n                    }\n                    t = -t / V[k + 1][k];\n                    for (int i = k + 1; i < n; i++) {\n                        V[i][j] += t * V[i][k];\n                    }\n                }\n            }\n            for (int i = 0; i < n; i++) {\n                V[i][k] = 0;\n            }\n            V[k][k] = 1;\n        }\n\n        // Main iteration loop for the singular values.\n        final int pp = p - 1;\n        int iter = 0;\n        while (p > 0) {\n            int k;\n            int kase;\n            // Here is where a test for too many iterations would go.\n            // This section of the program inspects for\n            // negligible elements in the s and e arrays.  On\n            // completion the variables kase and k are set as follows.\n            // kase = 1     if s(p) and e[k-1] are negligible and k<p\n            // kase = 2     if s(k) is negligible and k<p\n            // kase = 3     if e[k-1] is negligible, k<p, and\n            //              s(k), ..., s(p) are not negligible (qr step).\n            // kase = 4     if e(p-1) is negligible (convergence).\n            for (k = p - 2; k >= 0; k--) {\n                final double threshold\n                    = TINY + EPS * (FastMath.abs(singularValues[k]) +\n                                    FastMath.abs(singularValues[k + 1]));\n\n                // the following condition is written this way in order\n                // to break out of the loop when NaN occurs, writing it\n                // as \"if (FastMath.abs(e[k]) <= threshold)\" would loop\n                // indefinitely in case of NaNs because comparison on NaNs\n                // always return false, regardless of what is checked\n                // see issue MATH-947\n                if (!(FastMath.abs(e[k]) > threshold)) {\n                    e[k] = 0;\n                    break;\n                }\n\n            }\n\n            if (k == p - 2) {\n                kase = 4;\n            } else {\n                int ks;\n                for (ks = p - 1; ks >= k; ks--) {\n                    if (ks == k) {\n                        break;\n                    }\n                    final double t = (ks != p ? FastMath.abs(e[ks]) : 0) +\n                        (ks != k + 1 ? FastMath.abs(e[ks - 1]) : 0);\n                    if (FastMath.abs(singularValues[ks]) <= TINY + EPS * t) {\n                        singularValues[ks] = 0;\n                        break;\n                    }\n                }\n                if (ks == k) {\n                    kase = 3;\n                } else if (ks == p - 1) {\n                    kase = 1;\n                } else {\n                    kase = 2;\n                    k = ks;\n                }\n            }\n            k++;\n            // Perform the task indicated by kase.\n            switch (kase) {\n                // Deflate negligible s(p).\n                case 1: {\n                    double f = e[p - 2];\n                    e[p - 2] = 0;\n                    for (int j = p - 2; j >= k; j--) {\n                        double t = FastMath.hypot(singularValues[j], f);\n                        final double cs = singularValues[j] / t;\n                        final double sn = f / t;\n                        singularValues[j] = t;\n                        if (j != k) {\n                            f = -sn * e[j - 1];\n                            e[j - 1] = cs * e[j - 1];\n                        }\n\n                        for (int i = 0; i < n; i++) {\n                            t = cs * V[i][j] + sn * V[i][p - 1];\n                            V[i][p - 1] = -sn * V[i][j] + cs * V[i][p - 1];\n                            V[i][j] = t;\n                        }\n                    }\n                }\n                break;\n                // Split at negligible s(k).\n                case 2: {\n                    double f = e[k - 1];\n                    e[k - 1] = 0;\n                    for (int j = k; j < p; j++) {\n                        double t = FastMath.hypot(singularValues[j], f);\n                        final double cs = singularValues[j] / t;\n                        final double sn = f / t;\n                        singularValues[j] = t;\n                        f = -sn * e[j];\n                        e[j] = cs * e[j];\n\n                        for (int i = 0; i < m; i++) {\n                            t = cs * U[i][j] + sn * U[i][k - 1];\n                            U[i][k - 1] = -sn * U[i][j] + cs * U[i][k - 1];\n                            U[i][j] = t;\n                        }\n                    }\n                }\n                break;\n                // Perform one qr step.\n                case 3: {\n                    // Calculate the shift.\n                    final double maxPm1Pm2 = FastMath.max(FastMath.abs(singularValues[p - 1]),\n                                                          FastMath.abs(singularValues[p - 2]));\n                    final double scale = FastMath.max(FastMath.max(FastMath.max(maxPm1Pm2,\n                                                                                FastMath.abs(e[p - 2])),\n                                                                   FastMath.abs(singularValues[k])),\n                                                      FastMath.abs(e[k]));\n                    final double sp = singularValues[p - 1] / scale;\n                    final double spm1 = singularValues[p - 2] / scale;\n                    final double epm1 = e[p - 2] / scale;\n                    final double sk = singularValues[k] / scale;\n                    final double ek = e[k] / scale;\n                    final double b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2.0;\n                    final double c = (sp * epm1) * (sp * epm1);\n                    double shift = 0;\n                    if (b != 0 ||\n                        c != 0) {\n                        shift = FastMath.sqrt(b * b + c);\n                        if (b < 0) {\n                            shift = -shift;\n                        }\n                        shift = c / (b + shift);\n                    }\n                    double f = (sk + sp) * (sk - sp) + shift;\n                    double g = sk * ek;\n                    // Chase zeros.\n                    for (int j = k; j < p - 1; j++) {\n                        double t = FastMath.hypot(f, g);\n                        double cs = f / t;\n                        double sn = g / t;\n                        if (j != k) {\n                            e[j - 1] = t;\n                        }\n                        f = cs * singularValues[j] + sn * e[j];\n                        e[j] = cs * e[j] - sn * singularValues[j];\n                        g = sn * singularValues[j + 1];\n                        singularValues[j + 1] = cs * singularValues[j + 1];\n\n                        for (int i = 0; i < n; i++) {\n                            t = cs * V[i][j] + sn * V[i][j + 1];\n                            V[i][j + 1] = -sn * V[i][j] + cs * V[i][j + 1];\n                            V[i][j] = t;\n                        }\n                        t = FastMath.hypot(f, g);\n                        cs = f / t;\n                        sn = g / t;\n                        singularValues[j] = t;\n                        f = cs * e[j] + sn * singularValues[j + 1];\n                        singularValues[j + 1] = -sn * e[j] + cs * singularValues[j + 1];\n                        g = sn * e[j + 1];\n                        e[j + 1] = cs * e[j + 1];\n                        if (j < m - 1) {\n                            for (int i = 0; i < m; i++) {\n                                t = cs * U[i][j] + sn * U[i][j + 1];\n                                U[i][j + 1] = -sn * U[i][j] + cs * U[i][j + 1];\n                                U[i][j] = t;\n                            }\n                        }\n                    }\n                    e[p - 2] = f;\n                    iter = iter + 1;\n                }\n                break;\n                // Convergence.\n                default: {\n                    // Make the singular values positive.\n                    if (singularValues[k] <= 0) {\n                        singularValues[k] = singularValues[k] < 0 ? -singularValues[k] : 0;\n\n                        for (int i = 0; i <= pp; i++) {\n                            V[i][k] = -V[i][k];\n                        }\n                    }\n                    // Order the singular values.\n                    while (k < pp) {\n                        if (singularValues[k] >= singularValues[k + 1]) {\n                            break;\n                        }\n                        double t = singularValues[k];\n                        singularValues[k] = singularValues[k + 1];\n                        singularValues[k + 1] = t;\n                        if (k < n - 1) {\n                            for (int i = 0; i < n; i++) {\n                                t = V[i][k + 1];\n                                V[i][k + 1] = V[i][k];\n                                V[i][k] = t;\n                            }\n                        }\n                        if (k < m - 1) {\n                            for (int i = 0; i < m; i++) {\n                                t = U[i][k + 1];\n                                U[i][k + 1] = U[i][k];\n                                U[i][k] = t;\n                            }\n                        }\n                        k++;\n                    }\n                    iter = 0;\n                    p--;\n                }\n                break;\n            }\n        }\n\n        // Set the small value tolerance used to calculate rank and pseudo-inverse\n        tol = FastMath.max(m * singularValues[0] * EPS,\n                           FastMath.sqrt(Precision.SAFE_MIN));\n\n        if (!transposed) {\n            cachedU = MatrixUtils.createRealMatrix(U);\n            cachedV = MatrixUtils.createRealMatrix(V);\n        } else {\n            cachedU = MatrixUtils.createRealMatrix(V);\n            cachedV = MatrixUtils.createRealMatrix(U);\n        }\n    }",
          "13": "    public SingularValueDecomposition(final RealMatrix matrix) {\n        final double[][] A;\n\n         // \"m\" is always the largest dimension.\n        if (matrix.getRowDimension() < matrix.getColumnDimension()) {\n            transposed = true;\n            A = matrix.transpose().getData();\n            m = matrix.getColumnDimension();\n            n = matrix.getRowDimension();\n        } else {\n            transposed = false;\n            A = matrix.getData();\n            m = matrix.getRowDimension();\n            n = matrix.getColumnDimension();\n        }\n\n        singularValues = new double[n];\n        final double[][] U = new double[m][n];\n        final double[][] V = new double[n][n];\n        final double[] e = new double[n];\n        final double[] work = new double[m];\n        // Reduce A to bidiagonal form, storing the diagonal elements\n        // in s and the super-diagonal elements in e.\n        final int nct = FastMath.min(m - 1, n);\n        final int nrt = FastMath.max(0, n - 2);\n        for (int k = 0; k < FastMath.max(nct, nrt); k++) {\n            if (k < nct) {\n                // Compute the transformation for the k-th column and\n                // place the k-th diagonal in s[k].\n                // Compute 2-norm of k-th column without under/overflow.\n                singularValues[k] = 0;\n                for (int i = k; i < m; i++) {\n                    singularValues[k] = FastMath.hypot(singularValues[k], A[i][k]);\n                }\n                if (singularValues[k] != 0) {\n                    if (A[k][k] < 0) {\nsingularValues[k] = EPS[k].[k];\n                    }\n                    for (int i = k; i < m; i++) {\n                        A[i][k] /= singularValues[k];\n                    }\n                    A[k][k] += 1;\n                }\n                singularValues[k] = -singularValues[k];\n            }\n            for (int j = k + 1; j < n; j++) {\n                if (k < nct &&\n                    singularValues[k] != 0) {\n                    // Apply the transformation.\n                    double t = 0;\n                    for (int i = k; i < m; i++) {\n                        t += A[i][k] * A[i][j];\n                    }\n                    t = -t / A[k][k];\n                    for (int i = k; i < m; i++) {\n                        A[i][j] += t * A[i][k];\n                    }\n                }\n                // Place the k-th row of A into e for the\n                // subsequent calculation of the row transformation.\n                e[j] = A[k][j];\n            }\n            if (k < nct) {\n                // Place the transformation in U for subsequent back\n                // multiplication.\n                for (int i = k; i < m; i++) {\n                    U[i][k] = A[i][k];\n                }\n            }\n            if (k < nrt) {\n                // Compute the k-th row transformation and place the\n                // k-th super-diagonal in e[k].\n                // Compute 2-norm without under/overflow.\n                e[k] = 0;\n                for (int i = k + 1; i < n; i++) {\n                    e[k] = FastMath.hypot(e[k], e[i]);\n                }\n                if (e[k] != 0) {\n                    if (e[k + 1] < 0) {\n                        e[k] = -e[k];\n                    }\n                    for (int i = k + 1; i < n; i++) {\n                        e[i] /= e[k];\n                    }\n                    e[k + 1] += 1;\n                }\n                e[k] = -e[k];\n                if (k + 1 < m &&\n                    e[k] != 0) {\n                    // Apply the transformation.\n                    for (int i = k + 1; i < m; i++) {\n                        work[i] = 0;\n                    }\n                    for (int j = k + 1; j < n; j++) {\n                        for (int i = k + 1; i < m; i++) {\n                            work[i] += e[j] * A[i][j];\n                        }\n                    }\n                    for (int j = k + 1; j < n; j++) {\n                        final double t = -e[j] / e[k + 1];\n                        for (int i = k + 1; i < m; i++) {\n                            A[i][j] += t * work[i];\n                        }\n                    }\n                }\n\n                // Place the transformation in V for subsequent\n                // back multiplication.\n                for (int i = k + 1; i < n; i++) {\n                    V[i][k] = e[i];\n                }\n            }\n        }\n        // Set up the final bidiagonal matrix or order p.\n        int p = n;\n        if (nct < n) {\n            singularValues[nct] = A[nct][nct];\n        }\n        if (m < p) {\n            singularValues[p - 1] = 0;\n        }\n        if (nrt + 1 < p) {\n            e[nrt] = A[nrt][p - 1];\n        }\n        e[p - 1] = 0;\n\n        // Generate U.\n        for (int j = nct; j < n; j++) {\n            for (int i = 0; i < m; i++) {\n                U[i][j] = 0;\n            }\n            U[j][j] = 1;\n        }\n        for (int k = nct - 1; k >= 0; k--) {\n            if (singularValues[k] != 0) {\n                for (int j = k + 1; j < n; j++) {\n                    double t = 0;\n                    for (int i = k; i < m; i++) {\n                        t += U[i][k] * U[i][j];\n                    }\n                    t = -t / U[k][k];\n                    for (int i = k; i < m; i++) {\n                        U[i][j] += t * U[i][k];\n                    }\n                }\n                for (int i = k; i < m; i++) {\n                    U[i][k] = -U[i][k];\n                }\n                U[k][k] = 1 + U[k][k];\n                for (int i = 0; i < k - 1; i++) {\n                    U[i][k] = 0;\n                }\n            } else {\n                for (int i = 0; i < m; i++) {\n                    U[i][k] = 0;\n                }\n                U[k][k] = 1;\n            }\n        }\n\n        // Generate V.\n        for (int k = n - 1; k >= 0; k--) {\n            if (k < nrt &&\n                e[k] != 0) {\n                for (int j = k + 1; j < n; j++) {\n                    double t = 0;\n                    for (int i = k + 1; i < n; i++) {\n                        t += V[i][k] * V[i][j];\n                    }\n                    t = -t / V[k + 1][k];\n                    for (int i = k + 1; i < n; i++) {\n                        V[i][j] += t * V[i][k];\n                    }\n                }\n            }\n            for (int i = 0; i < n; i++) {\n                V[i][k] = 0;\n            }\n            V[k][k] = 1;\n        }\n\n        // Main iteration loop for the singular values.\n        final int pp = p - 1;\n        int iter = 0;\n        while (p > 0) {\n            int k;\n            int kase;\n            // Here is where a test for too many iterations would go.\n            // This section of the program inspects for\n            // negligible elements in the s and e arrays.  On\n            // completion the variables kase and k are set as follows.\n            // kase = 1     if s(p) and e[k-1] are negligible and k<p\n            // kase = 2     if s(k) is negligible and k<p\n            // kase = 3     if e[k-1] is negligible, k<p, and\n            //              s(k), ..., s(p) are not negligible (qr step).\n            // kase = 4     if e(p-1) is negligible (convergence).\n            for (k = p - 2; k >= 0; k--) {\n                final double threshold\n                    = TINY + EPS * (FastMath.abs(singularValues[k]) +\n                                    FastMath.abs(singularValues[k + 1]));\n\n                // the following condition is written this way in order\n                // to break out of the loop when NaN occurs, writing it\n                // as \"if (FastMath.abs(e[k]) <= threshold)\" would loop\n                // indefinitely in case of NaNs because comparison on NaNs\n                // always return false, regardless of what is checked\n                // see issue MATH-947\n                if (!(FastMath.abs(e[k]) > threshold)) {\n                    e[k] = 0;\n                    break;\n                }\n\n            }\n\n            if (k == p - 2) {\n                kase = 4;\n            } else {\n                int ks;\n                for (ks = p - 1; ks >= k; ks--) {\n                    if (ks == k) {\n                        break;\n                    }\n                    final double t = (ks != p ? FastMath.abs(e[ks]) : 0) +\n                        (ks != k + 1 ? FastMath.abs(e[ks - 1]) : 0);\n                    if (FastMath.abs(singularValues[ks]) <= TINY + EPS * t) {\n                        singularValues[ks] = 0;\n                        break;\n                    }\n                }\n                if (ks == k) {\n                    kase = 3;\n                } else if (ks == p - 1) {\n                    kase = 1;\n                } else {\n                    kase = 2;\n                    k = ks;\n                }\n            }\n            k++;\n            // Perform the task indicated by kase.\n            switch (kase) {\n                // Deflate negligible s(p).\n                case 1: {\n                    double f = e[p - 2];\n                    e[p - 2] = 0;\n                    for (int j = p - 2; j >= k; j--) {\n                        double t = FastMath.hypot(singularValues[j], f);\n                        final double cs = singularValues[j] / t;\n                        final double sn = f / t;\n                        singularValues[j] = t;\n                        if (j != k) {\n                            f = -sn * e[j - 1];\n                            e[j - 1] = cs * e[j - 1];\n                        }\n\n                        for (int i = 0; i < n; i++) {\n                            t = cs * V[i][j] + sn * V[i][p - 1];\n                            V[i][p - 1] = -sn * V[i][j] + cs * V[i][p - 1];\n                            V[i][j] = t;\n                        }\n                    }\n                }\n                break;\n                // Split at negligible s(k).\n                case 2: {\n                    double f = e[k - 1];\n                    e[k - 1] = 0;\n                    for (int j = k; j < p; j++) {\n                        double t = FastMath.hypot(singularValues[j], f);\n                        final double cs = singularValues[j] / t;\n                        final double sn = f / t;\n                        singularValues[j] = t;\n                        f = -sn * e[j];\n                        e[j] = cs * e[j];\n\n                        for (int i = 0; i < m; i++) {\n                            t = cs * U[i][j] + sn * U[i][k - 1];\n                            U[i][k - 1] = -sn * U[i][j] + cs * U[i][k - 1];\n                            U[i][j] = t;\n                        }\n                    }\n                }\n                break;\n                // Perform one qr step.\n                case 3: {\n                    // Calculate the shift.\n                    final double maxPm1Pm2 = FastMath.max(FastMath.abs(singularValues[p - 1]),\n                                                          FastMath.abs(singularValues[p - 2]));\n                    final double scale = FastMath.max(FastMath.max(FastMath.max(maxPm1Pm2,\n                                                                                FastMath.abs(e[p - 2])),\n                                                                   FastMath.abs(singularValues[k])),\n                                                      FastMath.abs(e[k]));\n                    final double sp = singularValues[p - 1] / scale;\n                    final double spm1 = singularValues[p - 2] / scale;\n                    final double epm1 = e[p - 2] / scale;\n                    final double sk = singularValues[k] / scale;\n                    final double ek = e[k] / scale;\n                    final double b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2.0;\n                    final double c = (sp * epm1) * (sp * epm1);\n                    double shift = 0;\n                    if (b != 0 ||\n                        c != 0) {\n                        shift = FastMath.sqrt(b * b + c);\n                        if (b < 0) {\n                            shift = -shift;\n                        }\n                        shift = c / (b + shift);\n                    }\n                    double f = (sk + sp) * (sk - sp) + shift;\n                    double g = sk * ek;\n                    // Chase zeros.\n                    for (int j = k; j < p - 1; j++) {\n                        double t = FastMath.hypot(f, g);\n                        double cs = f / t;\n                        double sn = g / t;\n                        if (j != k) {\n                            e[j - 1] = t;\n                        }\n                        f = cs * singularValues[j] + sn * e[j];\n                        e[j] = cs * e[j] - sn * singularValues[j];\n                        g = sn * singularValues[j + 1];\n                        singularValues[j + 1] = cs * singularValues[j + 1];\n\n                        for (int i = 0; i < n; i++) {\n                            t = cs * V[i][j] + sn * V[i][j + 1];\n                            V[i][j + 1] = -sn * V[i][j] + cs * V[i][j + 1];\n                            V[i][j] = t;\n                        }\n                        t = FastMath.hypot(f, g);\n                        cs = f / t;\n                        sn = g / t;\n                        singularValues[j] = t;\n                        f = cs * e[j] + sn * singularValues[j + 1];\n                        singularValues[j + 1] = -sn * e[j] + cs * singularValues[j + 1];\n                        g = sn * e[j + 1];\n                        e[j + 1] = cs * e[j + 1];\n                        if (j < m - 1) {\n                            for (int i = 0; i < m; i++) {\n                                t = cs * U[i][j] + sn * U[i][j + 1];\n                                U[i][j + 1] = -sn * U[i][j] + cs * U[i][j + 1];\n                                U[i][j] = t;\n                            }\n                        }\n                    }\n                    e[p - 2] = f;\n                    iter = iter + 1;\n                }\n                break;\n                // Convergence.\n                default: {\n                    // Make the singular values positive.\n                    if (singularValues[k] <= 0) {\n                        singularValues[k] = singularValues[k] < 0 ? -singularValues[k] : 0;\n\n                        for (int i = 0; i <= pp; i++) {\n                            V[i][k] = -V[i][k];\n                        }\n                    }\n                    // Order the singular values.\n                    while (k < pp) {\n                        if (singularValues[k] >= singularValues[k + 1]) {\n                            break;\n                        }\n                        double t = singularValues[k];\n                        singularValues[k] = singularValues[k + 1];\n                        singularValues[k + 1] = t;\n                        if (k < n - 1) {\n                            for (int i = 0; i < n; i++) {\n                                t = V[i][k + 1];\n                                V[i][k + 1] = V[i][k];\n                                V[i][k] = t;\n                            }\n                        }\n                        if (k < m - 1) {\n                            for (int i = 0; i < m; i++) {\n                                t = U[i][k + 1];\n                                U[i][k + 1] = U[i][k];\n                                U[i][k] = t;\n                            }\n                        }\n                        k++;\n                    }\n                    iter = 0;\n                    p--;\n                }\n                break;\n            }\n        }\n\n        // Set the small value tolerance used to calculate rank and pseudo-inverse\n        tol = FastMath.max(m * singularValues[0] * EPS,\n                           FastMath.sqrt(Precision.SAFE_MIN));\n\n        if (!transposed) {\n            cachedU = MatrixUtils.createRealMatrix(U);\n            cachedV = MatrixUtils.createRealMatrix(V);\n        } else {\n            cachedU = MatrixUtils.createRealMatrix(V);\n            cachedV = MatrixUtils.createRealMatrix(U);\n        }\n    }",
          "14": "    public SingularValueDecomposition(final RealMatrix matrix) {\n        final double[][] A;\n\n         // \"m\" is always the largest dimension.\n        if (matrix.getRowDimension() < matrix.getColumnDimension()) {\n            transposed = true;\n            A = matrix.transpose().getData();\n            m = matrix.getColumnDimension();\n            n = matrix.getRowDimension();\n        } else {\n            transposed = false;\n            A = matrix.getData();\n            m = matrix.getRowDimension();\n            n = matrix.getColumnDimension();\n        }\n\n        singularValues = new double[n];\n        final double[][] U = new double[m][n];\n        final double[][] V = new double[n][n];\n        final double[] e = new double[n];\n        final double[] work = new double[m];\n        // Reduce A to bidiagonal form, storing the diagonal elements\n        // in s and the super-diagonal elements in e.\n        final int nct = FastMath.min(m - 1, n);\n        final int nrt = FastMath.max(0, n - 2);\n        for (int k = 0; k < FastMath.max(nct, nrt); k++) {\n            if (k < nct) {\n                // Compute the transformation for the k-th column and\n                // place the k-th diagonal in s[k].\n                // Compute 2-norm of k-th column without under/overflow.\n                singularValues[k] = 0;\n                for (int i = k; i < m; i++) {\n                    singularValues[k] = FastMath.hypot(singularValues[k], A[i][k]);\n                }\n                if (singularValues[k] != 0) {\n                    if (A[k][k] < 0) {\nsingularValues[k] = TINY[k].[k];\n                    }\n                    for (int i = k; i < m; i++) {\n                        A[i][k] /= singularValues[k];\n                    }\n                    A[k][k] += 1;\n                }\n                singularValues[k] = -singularValues[k];\n            }\n            for (int j = k + 1; j < n; j++) {\n                if (k < nct &&\n                    singularValues[k] != 0) {\n                    // Apply the transformation.\n                    double t = 0;\n                    for (int i = k; i < m; i++) {\n                        t += A[i][k] * A[i][j];\n                    }\n                    t = -t / A[k][k];\n                    for (int i = k; i < m; i++) {\n                        A[i][j] += t * A[i][k];\n                    }\n                }\n                // Place the k-th row of A into e for the\n                // subsequent calculation of the row transformation.\n                e[j] = A[k][j];\n            }\n            if (k < nct) {\n                // Place the transformation in U for subsequent back\n                // multiplication.\n                for (int i = k; i < m; i++) {\n                    U[i][k] = A[i][k];\n                }\n            }\n            if (k < nrt) {\n                // Compute the k-th row transformation and place the\n                // k-th super-diagonal in e[k].\n                // Compute 2-norm without under/overflow.\n                e[k] = 0;\n                for (int i = k + 1; i < n; i++) {\n                    e[k] = FastMath.hypot(e[k], e[i]);\n                }\n                if (e[k] != 0) {\n                    if (e[k + 1] < 0) {\n                        e[k] = -e[k];\n                    }\n                    for (int i = k + 1; i < n; i++) {\n                        e[i] /= e[k];\n                    }\n                    e[k + 1] += 1;\n                }\n                e[k] = -e[k];\n                if (k + 1 < m &&\n                    e[k] != 0) {\n                    // Apply the transformation.\n                    for (int i = k + 1; i < m; i++) {\n                        work[i] = 0;\n                    }\n                    for (int j = k + 1; j < n; j++) {\n                        for (int i = k + 1; i < m; i++) {\n                            work[i] += e[j] * A[i][j];\n                        }\n                    }\n                    for (int j = k + 1; j < n; j++) {\n                        final double t = -e[j] / e[k + 1];\n                        for (int i = k + 1; i < m; i++) {\n                            A[i][j] += t * work[i];\n                        }\n                    }\n                }\n\n                // Place the transformation in V for subsequent\n                // back multiplication.\n                for (int i = k + 1; i < n; i++) {\n                    V[i][k] = e[i];\n                }\n            }\n        }\n        // Set up the final bidiagonal matrix or order p.\n        int p = n;\n        if (nct < n) {\n            singularValues[nct] = A[nct][nct];\n        }\n        if (m < p) {\n            singularValues[p - 1] = 0;\n        }\n        if (nrt + 1 < p) {\n            e[nrt] = A[nrt][p - 1];\n        }\n        e[p - 1] = 0;\n\n        // Generate U.\n        for (int j = nct; j < n; j++) {\n            for (int i = 0; i < m; i++) {\n                U[i][j] = 0;\n            }\n            U[j][j] = 1;\n        }\n        for (int k = nct - 1; k >= 0; k--) {\n            if (singularValues[k] != 0) {\n                for (int j = k + 1; j < n; j++) {\n                    double t = 0;\n                    for (int i = k; i < m; i++) {\n                        t += U[i][k] * U[i][j];\n                    }\n                    t = -t / U[k][k];\n                    for (int i = k; i < m; i++) {\n                        U[i][j] += t * U[i][k];\n                    }\n                }\n                for (int i = k; i < m; i++) {\n                    U[i][k] = -U[i][k];\n                }\n                U[k][k] = 1 + U[k][k];\n                for (int i = 0; i < k - 1; i++) {\n                    U[i][k] = 0;\n                }\n            } else {\n                for (int i = 0; i < m; i++) {\n                    U[i][k] = 0;\n                }\n                U[k][k] = 1;\n            }\n        }\n\n        // Generate V.\n        for (int k = n - 1; k >= 0; k--) {\n            if (k < nrt &&\n                e[k] != 0) {\n                for (int j = k + 1; j < n; j++) {\n                    double t = 0;\n                    for (int i = k + 1; i < n; i++) {\n                        t += V[i][k] * V[i][j];\n                    }\n                    t = -t / V[k + 1][k];\n                    for (int i = k + 1; i < n; i++) {\n                        V[i][j] += t * V[i][k];\n                    }\n                }\n            }\n            for (int i = 0; i < n; i++) {\n                V[i][k] = 0;\n            }\n            V[k][k] = 1;\n        }\n\n        // Main iteration loop for the singular values.\n        final int pp = p - 1;\n        int iter = 0;\n        while (p > 0) {\n            int k;\n            int kase;\n            // Here is where a test for too many iterations would go.\n            // This section of the program inspects for\n            // negligible elements in the s and e arrays.  On\n            // completion the variables kase and k are set as follows.\n            // kase = 1     if s(p) and e[k-1] are negligible and k<p\n            // kase = 2     if s(k) is negligible and k<p\n            // kase = 3     if e[k-1] is negligible, k<p, and\n            //              s(k), ..., s(p) are not negligible (qr step).\n            // kase = 4     if e(p-1) is negligible (convergence).\n            for (k = p - 2; k >= 0; k--) {\n                final double threshold\n                    = TINY + EPS * (FastMath.abs(singularValues[k]) +\n                                    FastMath.abs(singularValues[k + 1]));\n\n                // the following condition is written this way in order\n                // to break out of the loop when NaN occurs, writing it\n                // as \"if (FastMath.abs(e[k]) <= threshold)\" would loop\n                // indefinitely in case of NaNs because comparison on NaNs\n                // always return false, regardless of what is checked\n                // see issue MATH-947\n                if (!(FastMath.abs(e[k]) > threshold)) {\n                    e[k] = 0;\n                    break;\n                }\n\n            }\n\n            if (k == p - 2) {\n                kase = 4;\n            } else {\n                int ks;\n                for (ks = p - 1; ks >= k; ks--) {\n                    if (ks == k) {\n                        break;\n                    }\n                    final double t = (ks != p ? FastMath.abs(e[ks]) : 0) +\n                        (ks != k + 1 ? FastMath.abs(e[ks - 1]) : 0);\n                    if (FastMath.abs(singularValues[ks]) <= TINY + EPS * t) {\n                        singularValues[ks] = 0;\n                        break;\n                    }\n                }\n                if (ks == k) {\n                    kase = 3;\n                } else if (ks == p - 1) {\n                    kase = 1;\n                } else {\n                    kase = 2;\n                    k = ks;\n                }\n            }\n            k++;\n            // Perform the task indicated by kase.\n            switch (kase) {\n                // Deflate negligible s(p).\n                case 1: {\n                    double f = e[p - 2];\n                    e[p - 2] = 0;\n                    for (int j = p - 2; j >= k; j--) {\n                        double t = FastMath.hypot(singularValues[j], f);\n                        final double cs = singularValues[j] / t;\n                        final double sn = f / t;\n                        singularValues[j] = t;\n                        if (j != k) {\n                            f = -sn * e[j - 1];\n                            e[j - 1] = cs * e[j - 1];\n                        }\n\n                        for (int i = 0; i < n; i++) {\n                            t = cs * V[i][j] + sn * V[i][p - 1];\n                            V[i][p - 1] = -sn * V[i][j] + cs * V[i][p - 1];\n                            V[i][j] = t;\n                        }\n                    }\n                }\n                break;\n                // Split at negligible s(k).\n                case 2: {\n                    double f = e[k - 1];\n                    e[k - 1] = 0;\n                    for (int j = k; j < p; j++) {\n                        double t = FastMath.hypot(singularValues[j], f);\n                        final double cs = singularValues[j] / t;\n                        final double sn = f / t;\n                        singularValues[j] = t;\n                        f = -sn * e[j];\n                        e[j] = cs * e[j];\n\n                        for (int i = 0; i < m; i++) {\n                            t = cs * U[i][j] + sn * U[i][k - 1];\n                            U[i][k - 1] = -sn * U[i][j] + cs * U[i][k - 1];\n                            U[i][j] = t;\n                        }\n                    }\n                }\n                break;\n                // Perform one qr step.\n                case 3: {\n                    // Calculate the shift.\n                    final double maxPm1Pm2 = FastMath.max(FastMath.abs(singularValues[p - 1]),\n                                                          FastMath.abs(singularValues[p - 2]));\n                    final double scale = FastMath.max(FastMath.max(FastMath.max(maxPm1Pm2,\n                                                                                FastMath.abs(e[p - 2])),\n                                                                   FastMath.abs(singularValues[k])),\n                                                      FastMath.abs(e[k]));\n                    final double sp = singularValues[p - 1] / scale;\n                    final double spm1 = singularValues[p - 2] / scale;\n                    final double epm1 = e[p - 2] / scale;\n                    final double sk = singularValues[k] / scale;\n                    final double ek = e[k] / scale;\n                    final double b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2.0;\n                    final double c = (sp * epm1) * (sp * epm1);\n                    double shift = 0;\n                    if (b != 0 ||\n                        c != 0) {\n                        shift = FastMath.sqrt(b * b + c);\n                        if (b < 0) {\n                            shift = -shift;\n                        }\n                        shift = c / (b + shift);\n                    }\n                    double f = (sk + sp) * (sk - sp) + shift;\n                    double g = sk * ek;\n                    // Chase zeros.\n                    for (int j = k; j < p - 1; j++) {\n                        double t = FastMath.hypot(f, g);\n                        double cs = f / t;\n                        double sn = g / t;\n                        if (j != k) {\n                            e[j - 1] = t;\n                        }\n                        f = cs * singularValues[j] + sn * e[j];\n                        e[j] = cs * e[j] - sn * singularValues[j];\n                        g = sn * singularValues[j + 1];\n                        singularValues[j + 1] = cs * singularValues[j + 1];\n\n                        for (int i = 0; i < n; i++) {\n                            t = cs * V[i][j] + sn * V[i][j + 1];\n                            V[i][j + 1] = -sn * V[i][j] + cs * V[i][j + 1];\n                            V[i][j] = t;\n                        }\n                        t = FastMath.hypot(f, g);\n                        cs = f / t;\n                        sn = g / t;\n                        singularValues[j] = t;\n                        f = cs * e[j] + sn * singularValues[j + 1];\n                        singularValues[j + 1] = -sn * e[j] + cs * singularValues[j + 1];\n                        g = sn * e[j + 1];\n                        e[j + 1] = cs * e[j + 1];\n                        if (j < m - 1) {\n                            for (int i = 0; i < m; i++) {\n                                t = cs * U[i][j] + sn * U[i][j + 1];\n                                U[i][j + 1] = -sn * U[i][j] + cs * U[i][j + 1];\n                                U[i][j] = t;\n                            }\n                        }\n                    }\n                    e[p - 2] = f;\n                    iter = iter + 1;\n                }\n                break;\n                // Convergence.\n                default: {\n                    // Make the singular values positive.\n                    if (singularValues[k] <= 0) {\n                        singularValues[k] = singularValues[k] < 0 ? -singularValues[k] : 0;\n\n                        for (int i = 0; i <= pp; i++) {\n                            V[i][k] = -V[i][k];\n                        }\n                    }\n                    // Order the singular values.\n                    while (k < pp) {\n                        if (singularValues[k] >= singularValues[k + 1]) {\n                            break;\n                        }\n                        double t = singularValues[k];\n                        singularValues[k] = singularValues[k + 1];\n                        singularValues[k + 1] = t;\n                        if (k < n - 1) {\n                            for (int i = 0; i < n; i++) {\n                                t = V[i][k + 1];\n                                V[i][k + 1] = V[i][k];\n                                V[i][k] = t;\n                            }\n                        }\n                        if (k < m - 1) {\n                            for (int i = 0; i < m; i++) {\n                                t = U[i][k + 1];\n                                U[i][k + 1] = U[i][k];\n                                U[i][k] = t;\n                            }\n                        }\n                        k++;\n                    }\n                    iter = 0;\n                    p--;\n                }\n                break;\n            }\n        }\n\n        // Set the small value tolerance used to calculate rank and pseudo-inverse\n        tol = FastMath.max(m * singularValues[0] * EPS,\n                           FastMath.sqrt(Precision.SAFE_MIN));\n\n        if (!transposed) {\n            cachedU = MatrixUtils.createRealMatrix(U);\n            cachedV = MatrixUtils.createRealMatrix(V);\n        } else {\n            cachedU = MatrixUtils.createRealMatrix(V);\n            cachedV = MatrixUtils.createRealMatrix(U);\n        }\n    }",
          "15": "    public SingularValueDecomposition(final RealMatrix matrix) {\n        final double[][] A;\n\n         // \"m\" is always the largest dimension.\n        if (matrix.getRowDimension() < matrix.getColumnDimension()) {\n            transposed = true;\n            A = matrix.transpose().getData();\n            m = matrix.getColumnDimension();\n            n = matrix.getRowDimension();\n        } else {\n            transposed = false;\n            A = matrix.getData();\n            m = matrix.getRowDimension();\n            n = matrix.getColumnDimension();\n        }\n\n        singularValues = new double[n];\n        final double[][] U = new double[m][n];\n        final double[][] V = new double[n][n];\n        final double[] e = new double[n];\n        final double[] work = new double[m];\n        // Reduce A to bidiagonal form, storing the diagonal elements\n        // in s and the super-diagonal elements in e.\n        final int nct = FastMath.min(m - 1, n);\n        final int nrt = FastMath.max(0, n - 2);\n        for (int k = 0; k < FastMath.max(nct, nrt); k++) {\n            if (k < nct) {\n                // Compute the transformation for the k-th column and\n                // place the k-th diagonal in s[k].\n                // Compute 2-norm of k-th column without under/overflow.\n                singularValues[k] = 0;\n                for (int i = k; i < m; i++) {\n                    singularValues[k] = FastMath.hypot(singularValues[k], A[i][k]);\n                }\n                if (singularValues[k] != 0) {\n                    if (A[k][k] < 0) {\nsingularValues[k] = singularValues[k].[k];\n                    }\n                    for (int i = k; i < m; i++) {\n                        A[i][k] /= singularValues[k];\n                    }\n                    A[k][k] += 1;\n                }\n                singularValues[k] = -singularValues[k];\n            }\n            for (int j = k + 1; j < n; j++) {\n                if (k < nct &&\n                    singularValues[k] != 0) {\n                    // Apply the transformation.\n                    double t = 0;\n                    for (int i = k; i < m; i++) {\n                        t += A[i][k] * A[i][j];\n                    }\n                    t = -t / A[k][k];\n                    for (int i = k; i < m; i++) {\n                        A[i][j] += t * A[i][k];\n                    }\n                }\n                // Place the k-th row of A into e for the\n                // subsequent calculation of the row transformation.\n                e[j] = A[k][j];\n            }\n            if (k < nct) {\n                // Place the transformation in U for subsequent back\n                // multiplication.\n                for (int i = k; i < m; i++) {\n                    U[i][k] = A[i][k];\n                }\n            }\n            if (k < nrt) {\n                // Compute the k-th row transformation and place the\n                // k-th super-diagonal in e[k].\n                // Compute 2-norm without under/overflow.\n                e[k] = 0;\n                for (int i = k + 1; i < n; i++) {\n                    e[k] = FastMath.hypot(e[k], e[i]);\n                }\n                if (e[k] != 0) {\n                    if (e[k + 1] < 0) {\n                        e[k] = -e[k];\n                    }\n                    for (int i = k + 1; i < n; i++) {\n                        e[i] /= e[k];\n                    }\n                    e[k + 1] += 1;\n                }\n                e[k] = -e[k];\n                if (k + 1 < m &&\n                    e[k] != 0) {\n                    // Apply the transformation.\n                    for (int i = k + 1; i < m; i++) {\n                        work[i] = 0;\n                    }\n                    for (int j = k + 1; j < n; j++) {\n                        for (int i = k + 1; i < m; i++) {\n                            work[i] += e[j] * A[i][j];\n                        }\n                    }\n                    for (int j = k + 1; j < n; j++) {\n                        final double t = -e[j] / e[k + 1];\n                        for (int i = k + 1; i < m; i++) {\n                            A[i][j] += t * work[i];\n                        }\n                    }\n                }\n\n                // Place the transformation in V for subsequent\n                // back multiplication.\n                for (int i = k + 1; i < n; i++) {\n                    V[i][k] = e[i];\n                }\n            }\n        }\n        // Set up the final bidiagonal matrix or order p.\n        int p = n;\n        if (nct < n) {\n            singularValues[nct] = A[nct][nct];\n        }\n        if (m < p) {\n            singularValues[p - 1] = 0;\n        }\n        if (nrt + 1 < p) {\n            e[nrt] = A[nrt][p - 1];\n        }\n        e[p - 1] = 0;\n\n        // Generate U.\n        for (int j = nct; j < n; j++) {\n            for (int i = 0; i < m; i++) {\n                U[i][j] = 0;\n            }\n            U[j][j] = 1;\n        }\n        for (int k = nct - 1; k >= 0; k--) {\n            if (singularValues[k] != 0) {\n                for (int j = k + 1; j < n; j++) {\n                    double t = 0;\n                    for (int i = k; i < m; i++) {\n                        t += U[i][k] * U[i][j];\n                    }\n                    t = -t / U[k][k];\n                    for (int i = k; i < m; i++) {\n                        U[i][j] += t * U[i][k];\n                    }\n                }\n                for (int i = k; i < m; i++) {\n                    U[i][k] = -U[i][k];\n                }\n                U[k][k] = 1 + U[k][k];\n                for (int i = 0; i < k - 1; i++) {\n                    U[i][k] = 0;\n                }\n            } else {\n                for (int i = 0; i < m; i++) {\n                    U[i][k] = 0;\n                }\n                U[k][k] = 1;\n            }\n        }\n\n        // Generate V.\n        for (int k = n - 1; k >= 0; k--) {\n            if (k < nrt &&\n                e[k] != 0) {\n                for (int j = k + 1; j < n; j++) {\n                    double t = 0;\n                    for (int i = k + 1; i < n; i++) {\n                        t += V[i][k] * V[i][j];\n                    }\n                    t = -t / V[k + 1][k];\n                    for (int i = k + 1; i < n; i++) {\n                        V[i][j] += t * V[i][k];\n                    }\n                }\n            }\n            for (int i = 0; i < n; i++) {\n                V[i][k] = 0;\n            }\n            V[k][k] = 1;\n        }\n\n        // Main iteration loop for the singular values.\n        final int pp = p - 1;\n        int iter = 0;\n        while (p > 0) {\n            int k;\n            int kase;\n            // Here is where a test for too many iterations would go.\n            // This section of the program inspects for\n            // negligible elements in the s and e arrays.  On\n            // completion the variables kase and k are set as follows.\n            // kase = 1     if s(p) and e[k-1] are negligible and k<p\n            // kase = 2     if s(k) is negligible and k<p\n            // kase = 3     if e[k-1] is negligible, k<p, and\n            //              s(k), ..., s(p) are not negligible (qr step).\n            // kase = 4     if e(p-1) is negligible (convergence).\n            for (k = p - 2; k >= 0; k--) {\n                final double threshold\n                    = TINY + EPS * (FastMath.abs(singularValues[k]) +\n                                    FastMath.abs(singularValues[k + 1]));\n\n                // the following condition is written this way in order\n                // to break out of the loop when NaN occurs, writing it\n                // as \"if (FastMath.abs(e[k]) <= threshold)\" would loop\n                // indefinitely in case of NaNs because comparison on NaNs\n                // always return false, regardless of what is checked\n                // see issue MATH-947\n                if (!(FastMath.abs(e[k]) > threshold)) {\n                    e[k] = 0;\n                    break;\n                }\n\n            }\n\n            if (k == p - 2) {\n                kase = 4;\n            } else {\n                int ks;\n                for (ks = p - 1; ks >= k; ks--) {\n                    if (ks == k) {\n                        break;\n                    }\n                    final double t = (ks != p ? FastMath.abs(e[ks]) : 0) +\n                        (ks != k + 1 ? FastMath.abs(e[ks - 1]) : 0);\n                    if (FastMath.abs(singularValues[ks]) <= TINY + EPS * t) {\n                        singularValues[ks] = 0;\n                        break;\n                    }\n                }\n                if (ks == k) {\n                    kase = 3;\n                } else if (ks == p - 1) {\n                    kase = 1;\n                } else {\n                    kase = 2;\n                    k = ks;\n                }\n            }\n            k++;\n            // Perform the task indicated by kase.\n            switch (kase) {\n                // Deflate negligible s(p).\n                case 1: {\n                    double f = e[p - 2];\n                    e[p - 2] = 0;\n                    for (int j = p - 2; j >= k; j--) {\n                        double t = FastMath.hypot(singularValues[j], f);\n                        final double cs = singularValues[j] / t;\n                        final double sn = f / t;\n                        singularValues[j] = t;\n                        if (j != k) {\n                            f = -sn * e[j - 1];\n                            e[j - 1] = cs * e[j - 1];\n                        }\n\n                        for (int i = 0; i < n; i++) {\n                            t = cs * V[i][j] + sn * V[i][p - 1];\n                            V[i][p - 1] = -sn * V[i][j] + cs * V[i][p - 1];\n                            V[i][j] = t;\n                        }\n                    }\n                }\n                break;\n                // Split at negligible s(k).\n                case 2: {\n                    double f = e[k - 1];\n                    e[k - 1] = 0;\n                    for (int j = k; j < p; j++) {\n                        double t = FastMath.hypot(singularValues[j], f);\n                        final double cs = singularValues[j] / t;\n                        final double sn = f / t;\n                        singularValues[j] = t;\n                        f = -sn * e[j];\n                        e[j] = cs * e[j];\n\n                        for (int i = 0; i < m; i++) {\n                            t = cs * U[i][j] + sn * U[i][k - 1];\n                            U[i][k - 1] = -sn * U[i][j] + cs * U[i][k - 1];\n                            U[i][j] = t;\n                        }\n                    }\n                }\n                break;\n                // Perform one qr step.\n                case 3: {\n                    // Calculate the shift.\n                    final double maxPm1Pm2 = FastMath.max(FastMath.abs(singularValues[p - 1]),\n                                                          FastMath.abs(singularValues[p - 2]));\n                    final double scale = FastMath.max(FastMath.max(FastMath.max(maxPm1Pm2,\n                                                                                FastMath.abs(e[p - 2])),\n                                                                   FastMath.abs(singularValues[k])),\n                                                      FastMath.abs(e[k]));\n                    final double sp = singularValues[p - 1] / scale;\n                    final double spm1 = singularValues[p - 2] / scale;\n                    final double epm1 = e[p - 2] / scale;\n                    final double sk = singularValues[k] / scale;\n                    final double ek = e[k] / scale;\n                    final double b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2.0;\n                    final double c = (sp * epm1) * (sp * epm1);\n                    double shift = 0;\n                    if (b != 0 ||\n                        c != 0) {\n                        shift = FastMath.sqrt(b * b + c);\n                        if (b < 0) {\n                            shift = -shift;\n                        }\n                        shift = c / (b + shift);\n                    }\n                    double f = (sk + sp) * (sk - sp) + shift;\n                    double g = sk * ek;\n                    // Chase zeros.\n                    for (int j = k; j < p - 1; j++) {\n                        double t = FastMath.hypot(f, g);\n                        double cs = f / t;\n                        double sn = g / t;\n                        if (j != k) {\n                            e[j - 1] = t;\n                        }\n                        f = cs * singularValues[j] + sn * e[j];\n                        e[j] = cs * e[j] - sn * singularValues[j];\n                        g = sn * singularValues[j + 1];\n                        singularValues[j + 1] = cs * singularValues[j + 1];\n\n                        for (int i = 0; i < n; i++) {\n                            t = cs * V[i][j] + sn * V[i][j + 1];\n                            V[i][j + 1] = -sn * V[i][j] + cs * V[i][j + 1];\n                            V[i][j] = t;\n                        }\n                        t = FastMath.hypot(f, g);\n                        cs = f / t;\n                        sn = g / t;\n                        singularValues[j] = t;\n                        f = cs * e[j] + sn * singularValues[j + 1];\n                        singularValues[j + 1] = -sn * e[j] + cs * singularValues[j + 1];\n                        g = sn * e[j + 1];\n                        e[j + 1] = cs * e[j + 1];\n                        if (j < m - 1) {\n                            for (int i = 0; i < m; i++) {\n                                t = cs * U[i][j] + sn * U[i][j + 1];\n                                U[i][j + 1] = -sn * U[i][j] + cs * U[i][j + 1];\n                                U[i][j] = t;\n                            }\n                        }\n                    }\n                    e[p - 2] = f;\n                    iter = iter + 1;\n                }\n                break;\n                // Convergence.\n                default: {\n                    // Make the singular values positive.\n                    if (singularValues[k] <= 0) {\n                        singularValues[k] = singularValues[k] < 0 ? -singularValues[k] : 0;\n\n                        for (int i = 0; i <= pp; i++) {\n                            V[i][k] = -V[i][k];\n                        }\n                    }\n                    // Order the singular values.\n                    while (k < pp) {\n                        if (singularValues[k] >= singularValues[k + 1]) {\n                            break;\n                        }\n                        double t = singularValues[k];\n                        singularValues[k] = singularValues[k + 1];\n                        singularValues[k + 1] = t;\n                        if (k < n - 1) {\n                            for (int i = 0; i < n; i++) {\n                                t = V[i][k + 1];\n                                V[i][k + 1] = V[i][k];\n                                V[i][k] = t;\n                            }\n                        }\n                        if (k < m - 1) {\n                            for (int i = 0; i < m; i++) {\n                                t = U[i][k + 1];\n                                U[i][k + 1] = U[i][k];\n                                U[i][k] = t;\n                            }\n                        }\n                        k++;\n                    }\n                    iter = 0;\n                    p--;\n                }\n                break;\n            }\n        }\n\n        // Set the small value tolerance used to calculate rank and pseudo-inverse\n        tol = FastMath.max(m * singularValues[0] * EPS,\n                           FastMath.sqrt(Precision.SAFE_MIN));\n\n        if (!transposed) {\n            cachedU = MatrixUtils.createRealMatrix(U);\n            cachedV = MatrixUtils.createRealMatrix(V);\n        } else {\n            cachedU = MatrixUtils.createRealMatrix(V);\n            cachedV = MatrixUtils.createRealMatrix(U);\n        }\n    }",
          "16": "    public SingularValueDecomposition(final RealMatrix matrix) {\n        final double[][] A;\n\n         // \"m\" is always the largest dimension.\n        if (matrix.getRowDimension() < matrix.getColumnDimension()) {\n            transposed = true;\n            A = matrix.transpose().getData();\n            m = matrix.getColumnDimension();\n            n = matrix.getRowDimension();\n        } else {\n            transposed = false;\n            A = matrix.getData();\n            m = matrix.getRowDimension();\n            n = matrix.getColumnDimension();\n        }\n\n        singularValues = new double[n];\n        final double[][] U = new double[m][n];\n        final double[][] V = new double[n][n];\n        final double[] e = new double[n];\n        final double[] work = new double[m];\n        // Reduce A to bidiagonal form, storing the diagonal elements\n        // in s and the super-diagonal elements in e.\n        final int nct = FastMath.min(m - 1, n);\n        final int nrt = FastMath.max(0, n - 2);\n        for (int k = 0; k < FastMath.max(nct, nrt); k++) {\n            if (k < nct) {\n                // Compute the transformation for the k-th column and\n                // place the k-th diagonal in s[k].\n                // Compute 2-norm of k-th column without under/overflow.\n                singularValues[k] = 0;\n                for (int i = k; i < m; i++) {\n                    singularValues[k] = FastMath.hypot(singularValues[k], A[i][k]);\n                }\n                if (singularValues[k] != 0) {\n                    if (A[k][k] < 0) {\nsingularValues[k] = tol[k].[k];\n                    }\n                    for (int i = k; i < m; i++) {\n                        A[i][k] /= singularValues[k];\n                    }\n                    A[k][k] += 1;\n                }\n                singularValues[k] = -singularValues[k];\n            }\n            for (int j = k + 1; j < n; j++) {\n                if (k < nct &&\n                    singularValues[k] != 0) {\n                    // Apply the transformation.\n                    double t = 0;\n                    for (int i = k; i < m; i++) {\n                        t += A[i][k] * A[i][j];\n                    }\n                    t = -t / A[k][k];\n                    for (int i = k; i < m; i++) {\n                        A[i][j] += t * A[i][k];\n                    }\n                }\n                // Place the k-th row of A into e for the\n                // subsequent calculation of the row transformation.\n                e[j] = A[k][j];\n            }\n            if (k < nct) {\n                // Place the transformation in U for subsequent back\n                // multiplication.\n                for (int i = k; i < m; i++) {\n                    U[i][k] = A[i][k];\n                }\n            }\n            if (k < nrt) {\n                // Compute the k-th row transformation and place the\n                // k-th super-diagonal in e[k].\n                // Compute 2-norm without under/overflow.\n                e[k] = 0;\n                for (int i = k + 1; i < n; i++) {\n                    e[k] = FastMath.hypot(e[k], e[i]);\n                }\n                if (e[k] != 0) {\n                    if (e[k + 1] < 0) {\n                        e[k] = -e[k];\n                    }\n                    for (int i = k + 1; i < n; i++) {\n                        e[i] /= e[k];\n                    }\n                    e[k + 1] += 1;\n                }\n                e[k] = -e[k];\n                if (k + 1 < m &&\n                    e[k] != 0) {\n                    // Apply the transformation.\n                    for (int i = k + 1; i < m; i++) {\n                        work[i] = 0;\n                    }\n                    for (int j = k + 1; j < n; j++) {\n                        for (int i = k + 1; i < m; i++) {\n                            work[i] += e[j] * A[i][j];\n                        }\n                    }\n                    for (int j = k + 1; j < n; j++) {\n                        final double t = -e[j] / e[k + 1];\n                        for (int i = k + 1; i < m; i++) {\n                            A[i][j] += t * work[i];\n                        }\n                    }\n                }\n\n                // Place the transformation in V for subsequent\n                // back multiplication.\n                for (int i = k + 1; i < n; i++) {\n                    V[i][k] = e[i];\n                }\n            }\n        }\n        // Set up the final bidiagonal matrix or order p.\n        int p = n;\n        if (nct < n) {\n            singularValues[nct] = A[nct][nct];\n        }\n        if (m < p) {\n            singularValues[p - 1] = 0;\n        }\n        if (nrt + 1 < p) {\n            e[nrt] = A[nrt][p - 1];\n        }\n        e[p - 1] = 0;\n\n        // Generate U.\n        for (int j = nct; j < n; j++) {\n            for (int i = 0; i < m; i++) {\n                U[i][j] = 0;\n            }\n            U[j][j] = 1;\n        }\n        for (int k = nct - 1; k >= 0; k--) {\n            if (singularValues[k] != 0) {\n                for (int j = k + 1; j < n; j++) {\n                    double t = 0;\n                    for (int i = k; i < m; i++) {\n                        t += U[i][k] * U[i][j];\n                    }\n                    t = -t / U[k][k];\n                    for (int i = k; i < m; i++) {\n                        U[i][j] += t * U[i][k];\n                    }\n                }\n                for (int i = k; i < m; i++) {\n                    U[i][k] = -U[i][k];\n                }\n                U[k][k] = 1 + U[k][k];\n                for (int i = 0; i < k - 1; i++) {\n                    U[i][k] = 0;\n                }\n            } else {\n                for (int i = 0; i < m; i++) {\n                    U[i][k] = 0;\n                }\n                U[k][k] = 1;\n            }\n        }\n\n        // Generate V.\n        for (int k = n - 1; k >= 0; k--) {\n            if (k < nrt &&\n                e[k] != 0) {\n                for (int j = k + 1; j < n; j++) {\n                    double t = 0;\n                    for (int i = k + 1; i < n; i++) {\n                        t += V[i][k] * V[i][j];\n                    }\n                    t = -t / V[k + 1][k];\n                    for (int i = k + 1; i < n; i++) {\n                        V[i][j] += t * V[i][k];\n                    }\n                }\n            }\n            for (int i = 0; i < n; i++) {\n                V[i][k] = 0;\n            }\n            V[k][k] = 1;\n        }\n\n        // Main iteration loop for the singular values.\n        final int pp = p - 1;\n        int iter = 0;\n        while (p > 0) {\n            int k;\n            int kase;\n            // Here is where a test for too many iterations would go.\n            // This section of the program inspects for\n            // negligible elements in the s and e arrays.  On\n            // completion the variables kase and k are set as follows.\n            // kase = 1     if s(p) and e[k-1] are negligible and k<p\n            // kase = 2     if s(k) is negligible and k<p\n            // kase = 3     if e[k-1] is negligible, k<p, and\n            //              s(k), ..., s(p) are not negligible (qr step).\n            // kase = 4     if e(p-1) is negligible (convergence).\n            for (k = p - 2; k >= 0; k--) {\n                final double threshold\n                    = TINY + EPS * (FastMath.abs(singularValues[k]) +\n                                    FastMath.abs(singularValues[k + 1]));\n\n                // the following condition is written this way in order\n                // to break out of the loop when NaN occurs, writing it\n                // as \"if (FastMath.abs(e[k]) <= threshold)\" would loop\n                // indefinitely in case of NaNs because comparison on NaNs\n                // always return false, regardless of what is checked\n                // see issue MATH-947\n                if (!(FastMath.abs(e[k]) > threshold)) {\n                    e[k] = 0;\n                    break;\n                }\n\n            }\n\n            if (k == p - 2) {\n                kase = 4;\n            } else {\n                int ks;\n                for (ks = p - 1; ks >= k; ks--) {\n                    if (ks == k) {\n                        break;\n                    }\n                    final double t = (ks != p ? FastMath.abs(e[ks]) : 0) +\n                        (ks != k + 1 ? FastMath.abs(e[ks - 1]) : 0);\n                    if (FastMath.abs(singularValues[ks]) <= TINY + EPS * t) {\n                        singularValues[ks] = 0;\n                        break;\n                    }\n                }\n                if (ks == k) {\n                    kase = 3;\n                } else if (ks == p - 1) {\n                    kase = 1;\n                } else {\n                    kase = 2;\n                    k = ks;\n                }\n            }\n            k++;\n            // Perform the task indicated by kase.\n            switch (kase) {\n                // Deflate negligible s(p).\n                case 1: {\n                    double f = e[p - 2];\n                    e[p - 2] = 0;\n                    for (int j = p - 2; j >= k; j--) {\n                        double t = FastMath.hypot(singularValues[j], f);\n                        final double cs = singularValues[j] / t;\n                        final double sn = f / t;\n                        singularValues[j] = t;\n                        if (j != k) {\n                            f = -sn * e[j - 1];\n                            e[j - 1] = cs * e[j - 1];\n                        }\n\n                        for (int i = 0; i < n; i++) {\n                            t = cs * V[i][j] + sn * V[i][p - 1];\n                            V[i][p - 1] = -sn * V[i][j] + cs * V[i][p - 1];\n                            V[i][j] = t;\n                        }\n                    }\n                }\n                break;\n                // Split at negligible s(k).\n                case 2: {\n                    double f = e[k - 1];\n                    e[k - 1] = 0;\n                    for (int j = k; j < p; j++) {\n                        double t = FastMath.hypot(singularValues[j], f);\n                        final double cs = singularValues[j] / t;\n                        final double sn = f / t;\n                        singularValues[j] = t;\n                        f = -sn * e[j];\n                        e[j] = cs * e[j];\n\n                        for (int i = 0; i < m; i++) {\n                            t = cs * U[i][j] + sn * U[i][k - 1];\n                            U[i][k - 1] = -sn * U[i][j] + cs * U[i][k - 1];\n                            U[i][j] = t;\n                        }\n                    }\n                }\n                break;\n                // Perform one qr step.\n                case 3: {\n                    // Calculate the shift.\n                    final double maxPm1Pm2 = FastMath.max(FastMath.abs(singularValues[p - 1]),\n                                                          FastMath.abs(singularValues[p - 2]));\n                    final double scale = FastMath.max(FastMath.max(FastMath.max(maxPm1Pm2,\n                                                                                FastMath.abs(e[p - 2])),\n                                                                   FastMath.abs(singularValues[k])),\n                                                      FastMath.abs(e[k]));\n                    final double sp = singularValues[p - 1] / scale;\n                    final double spm1 = singularValues[p - 2] / scale;\n                    final double epm1 = e[p - 2] / scale;\n                    final double sk = singularValues[k] / scale;\n                    final double ek = e[k] / scale;\n                    final double b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2.0;\n                    final double c = (sp * epm1) * (sp * epm1);\n                    double shift = 0;\n                    if (b != 0 ||\n                        c != 0) {\n                        shift = FastMath.sqrt(b * b + c);\n                        if (b < 0) {\n                            shift = -shift;\n                        }\n                        shift = c / (b + shift);\n                    }\n                    double f = (sk + sp) * (sk - sp) + shift;\n                    double g = sk * ek;\n                    // Chase zeros.\n                    for (int j = k; j < p - 1; j++) {\n                        double t = FastMath.hypot(f, g);\n                        double cs = f / t;\n                        double sn = g / t;\n                        if (j != k) {\n                            e[j - 1] = t;\n                        }\n                        f = cs * singularValues[j] + sn * e[j];\n                        e[j] = cs * e[j] - sn * singularValues[j];\n                        g = sn * singularValues[j + 1];\n                        singularValues[j + 1] = cs * singularValues[j + 1];\n\n                        for (int i = 0; i < n; i++) {\n                            t = cs * V[i][j] + sn * V[i][j + 1];\n                            V[i][j + 1] = -sn * V[i][j] + cs * V[i][j + 1];\n                            V[i][j] = t;\n                        }\n                        t = FastMath.hypot(f, g);\n                        cs = f / t;\n                        sn = g / t;\n                        singularValues[j] = t;\n                        f = cs * e[j] + sn * singularValues[j + 1];\n                        singularValues[j + 1] = -sn * e[j] + cs * singularValues[j + 1];\n                        g = sn * e[j + 1];\n                        e[j + 1] = cs * e[j + 1];\n                        if (j < m - 1) {\n                            for (int i = 0; i < m; i++) {\n                                t = cs * U[i][j] + sn * U[i][j + 1];\n                                U[i][j + 1] = -sn * U[i][j] + cs * U[i][j + 1];\n                                U[i][j] = t;\n                            }\n                        }\n                    }\n                    e[p - 2] = f;\n                    iter = iter + 1;\n                }\n                break;\n                // Convergence.\n                default: {\n                    // Make the singular values positive.\n                    if (singularValues[k] <= 0) {\n                        singularValues[k] = singularValues[k] < 0 ? -singularValues[k] : 0;\n\n                        for (int i = 0; i <= pp; i++) {\n                            V[i][k] = -V[i][k];\n                        }\n                    }\n                    // Order the singular values.\n                    while (k < pp) {\n                        if (singularValues[k] >= singularValues[k + 1]) {\n                            break;\n                        }\n                        double t = singularValues[k];\n                        singularValues[k] = singularValues[k + 1];\n                        singularValues[k + 1] = t;\n                        if (k < n - 1) {\n                            for (int i = 0; i < n; i++) {\n                                t = V[i][k + 1];\n                                V[i][k + 1] = V[i][k];\n                                V[i][k] = t;\n                            }\n                        }\n                        if (k < m - 1) {\n                            for (int i = 0; i < m; i++) {\n                                t = U[i][k + 1];\n                                U[i][k + 1] = U[i][k];\n                                U[i][k] = t;\n                            }\n                        }\n                        k++;\n                    }\n                    iter = 0;\n                    p--;\n                }\n                break;\n            }\n        }\n\n        // Set the small value tolerance used to calculate rank and pseudo-inverse\n        tol = FastMath.max(m * singularValues[0] * EPS,\n                           FastMath.sqrt(Precision.SAFE_MIN));\n\n        if (!transposed) {\n            cachedU = MatrixUtils.createRealMatrix(U);\n            cachedV = MatrixUtils.createRealMatrix(V);\n        } else {\n            cachedU = MatrixUtils.createRealMatrix(V);\n            cachedV = MatrixUtils.createRealMatrix(U);\n        }\n    }",
          "17": "    public SingularValueDecomposition(final RealMatrix matrix) {\n        final double[][] A;\n\n         // \"m\" is always the largest dimension.\n        if (matrix.getRowDimension() < matrix.getColumnDimension()) {\n            transposed = true;\n            A = matrix.transpose().getData();\n            m = matrix.getColumnDimension();\n            n = matrix.getRowDimension();\n        } else {\n            transposed = false;\n            A = matrix.getData();\n            m = matrix.getRowDimension();\n            n = matrix.getColumnDimension();\n        }\n\n        singularValues = new double[n];\n        final double[][] U = new double[m][n];\n        final double[][] V = new double[n][n];\n        final double[] e = new double[n];\n        final double[] work = new double[m];\n        // Reduce A to bidiagonal form, storing the diagonal elements\n        // in s and the super-diagonal elements in e.\n        final int nct = FastMath.min(m - 1, n);\n        final int nrt = FastMath.max(0, n - 2);\n        for (int k = 0; k < FastMath.max(nct, nrt); k++) {\n            if (k < nct) {\n                // Compute the transformation for the k-th column and\n                // place the k-th diagonal in s[k].\n                // Compute 2-norm of k-th column without under/overflow.\n                singularValues[k] = 0;\n                for (int i = k; i < m; i++) {\n                    singularValues[k] = FastMath.hypot(singularValues[k], A[i][k]);\n                }\n                if (singularValues[k] != 0) {\n                    if (A[k][k] < 0) {\nsingularValues[k] = -singularValues[k];\n                    }\n                    for (int i = k; i < m; i++) {\n                        A[i][k] /= singularValues[k];\n                    }\n                    A[k][k] += 1;\n                }\n                singularValues[k] = -singularValues[k];\n            }\n            for (int j = k + 1; j < n; j++) {\n                if (k < nct &&\n                    singularValues[k] != 0) {\n                    // Apply the transformation.\n                    double t = 0;\n                    for (int i = k; i < m; i++) {\n                        t += A[i][k] * A[i][j];\n                    }\n                    t = -t / A[k][k];\n                    for (int i = k; i < m; i++) {\n                        A[i][j] += t * A[i][k];\n                    }\n                }\n                // Place the k-th row of A into e for the\n                // subsequent calculation of the row transformation.\n                e[j] = A[k][j];\n            }\n            if (k < nct) {\n                // Place the transformation in U for subsequent back\n                // multiplication.\n                for (int i = k; i < m; i++) {\n                    U[i][k] = A[i][k];\n                }\n            }\n            if (k < nrt) {\n                // Compute the k-th row transformation and place the\n                // k-th super-diagonal in e[k].\n                // Compute 2-norm without under/overflow.\n                e[k] = 0;\n                for (int i = k + 1; i < n; i++) {\n                    e[k] = FastMath.hypot(e[k], e[i]);\n                }\n                if (e[k] != 0) {\n                    if (e[k + 1] < 0) {\n                        e[k] = -e[k];\n                    }\n                    for (int i = k + 1; i < n; i++) {\n                        e[i] /= e[k];\n                    }\n                    e[k + 1] += 1;\n                }\n                e[k] = -e[k];\n                if (k + 1 < m &&\n                    e[k] != 0) {\n                    // Apply the transformation.\n                    for (int i = k + 1; i < m; i++) {\n                        work[i] = 0;\n                    }\n                    for (int j = k + 1; j < n; j++) {\n                        for (int i = k + 1; i < m; i++) {\n                            work[i] += e[j] * A[i][j];\n                        }\n                    }\n                    for (int j = k + 1; j < n; j++) {\n                        final double t = -e[j] / e[k + 1];\n                        for (int i = k + 1; i < m; i++) {\n                            A[i][j] += t * work[i];\n                        }\n                    }\n                }\n\n                // Place the transformation in V for subsequent\n                // back multiplication.\n                for (int i = k + 1; i < n; i++) {\n                    V[i][k] = e[i];\n                }\n            }\n        }\n        // Set up the final bidiagonal matrix or order p.\n        int p = n;\n        if (nct < n) {\n            singularValues[nct] = A[nct][nct];\n        }\n        if (m < p) {\n            singularValues[p - 1] = 0;\n        }\n        if (nrt + 1 < p) {\n            e[nrt] = A[nrt][p - 1];\n        }\n        e[p - 1] = 0;\n\n        // Generate U.\n        for (int j = nct; j < n; j++) {\n            for (int i = 0; i < m; i++) {\n                U[i][j] = 0;\n            }\n            U[j][j] = 1;\n        }\n        for (int k = nct - 1; k >= 0; k--) {\n            if (singularValues[k] != 0) {\n                for (int j = k + 1; j < n; j++) {\n                    double t = 0;\n                    for (int i = k; i < m; i++) {\n                        t += U[i][k] * U[i][j];\n                    }\n                    t = -t / U[k][k];\n                    for (int i = k; i < m; i++) {\n                        U[i][j] += t * U[i][k];\n                    }\n                }\n                for (int i = k; i < m; i++) {\n                    U[i][k] = -U[i][k];\n                }\n                U[k][k] = 1 + U[k][k];\n                for (int i = 0; i < k - 1; i++) {\n                    U[i][k] = 0;\n                }\n            } else {\n                for (int i = 0; i < m; i++) {\n                    U[i][k] = 0;\n                }\n                U[k][k] = 1;\n            }\n        }\n\n        // Generate V.\n        for (int k = n - 1; k >= 0; k--) {\n            if (k < nrt &&\n                e[k] != 0) {\n                for (int j = k + 1; j < n; j++) {\n                    double t = 0;\n                    for (int i = k + 1; i < n; i++) {\n                        t += V[i][k] * V[i][j];\n                    }\n                    t = -t / V[k + 1][k];\n                    for (int i = k + 1; i < n; i++) {\n                        V[i][j] += t * V[i][k];\n                    }\n                }\n            }\n            for (int i = 0; i < n; i++) {\n                V[i][k] = 0;\n            }\n            V[k][k] = 1;\n        }\n\n        // Main iteration loop for the singular values.\n        final int pp = p - 1;\n        int iter = 0;\n        while (p > 0) {\n            int k;\n            int kase;\n            // Here is where a test for too many iterations would go.\n            // This section of the program inspects for\n            // negligible elements in the s and e arrays.  On\n            // completion the variables kase and k are set as follows.\n            // kase = 1     if s(p) and e[k-1] are negligible and k<p\n            // kase = 2     if s(k) is negligible and k<p\n            // kase = 3     if e[k-1] is negligible, k<p, and\n            //              s(k), ..., s(p) are not negligible (qr step).\n            // kase = 4     if e(p-1) is negligible (convergence).\n            for (k = p - 2; k >= 0; k--) {\n                final double threshold\n                    = TINY + EPS * (FastMath.abs(singularValues[k]) +\n                                    FastMath.abs(singularValues[k + 1]));\n\n                // the following condition is written this way in order\n                // to break out of the loop when NaN occurs, writing it\n                // as \"if (FastMath.abs(e[k]) <= threshold)\" would loop\n                // indefinitely in case of NaNs because comparison on NaNs\n                // always return false, regardless of what is checked\n                // see issue MATH-947\n                if (!(FastMath.abs(e[k]) > threshold)) {\n                    e[k] = 0;\n                    break;\n                }\n\n            }\n\n            if (k == p - 2) {\n                kase = 4;\n            } else {\n                int ks;\n                for (ks = p - 1; ks >= k; ks--) {\n                    if (ks == k) {\n                        break;\n                    }\n                    final double t = (ks != p ? FastMath.abs(e[ks]) : 0) +\n                        (ks != k + 1 ? FastMath.abs(e[ks - 1]) : 0);\n                    if (FastMath.abs(singularValues[ks]) <= TINY + EPS * t) {\n                        singularValues[ks] = 0;\n                        break;\n                    }\n                }\n                if (ks == k) {\n                    kase = 3;\n                } else if (ks == p - 1) {\n                    kase = 1;\n                } else {\n                    kase = 2;\n                    k = ks;\n                }\n            }\n            k++;\n            // Perform the task indicated by kase.\n            switch (kase) {\n                // Deflate negligible s(p).\n                case 1: {\n                    double f = e[p - 2];\n                    e[p - 2] = 0;\n                    for (int j = p - 2; j >= k; j--) {\n                        double t = FastMath.hypot(singularValues[j], f);\n                        final double cs = singularValues[j] / t;\n                        final double sn = f / t;\n                        singularValues[j] = t;\n                        if (j != k) {\n                            f = -sn * e[j - 1];\n                            e[j - 1] = cs * e[j - 1];\n                        }\n\n                        for (int i = 0; i < n; i++) {\n                            t = cs * V[i][j] + sn * V[i][p - 1];\n                            V[i][p - 1] = -sn * V[i][j] + cs * V[i][p - 1];\n                            V[i][j] = t;\n                        }\n                    }\n                }\n                break;\n                // Split at negligible s(k).\n                case 2: {\n                    double f = e[k - 1];\n                    e[k - 1] = 0;\n                    for (int j = k; j < p; j++) {\n                        double t = FastMath.hypot(singularValues[j], f);\n                        final double cs = singularValues[j] / t;\n                        final double sn = f / t;\n                        singularValues[j] = t;\n                        f = -sn * e[j];\n                        e[j] = cs * e[j];\n\n                        for (int i = 0; i < m; i++) {\n                            t = cs * U[i][j] + sn * U[i][k - 1];\n                            U[i][k - 1] = -sn * U[i][j] + cs * U[i][k - 1];\n                            U[i][j] = t;\n                        }\n                    }\n                }\n                break;\n                // Perform one qr step.\n                case 3: {\n                    // Calculate the shift.\n                    final double maxPm1Pm2 = FastMath.max(FastMath.abs(singularValues[p - 1]),\n                                                          FastMath.abs(singularValues[p - 2]));\n                    final double scale = FastMath.max(FastMath.max(FastMath.max(maxPm1Pm2,\n                                                                                FastMath.abs(e[p - 2])),\n                                                                   FastMath.abs(singularValues[k])),\n                                                      FastMath.abs(e[k]));\n                    final double sp = singularValues[p - 1] / scale;\n                    final double spm1 = singularValues[p - 2] / scale;\n                    final double epm1 = e[p - 2] / scale;\n                    final double sk = singularValues[k] / scale;\n                    final double ek = e[k] / scale;\n                    final double b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2.0;\n                    final double c = (sp * epm1) * (sp * epm1);\n                    double shift = 0;\n                    if (b != 0 ||\n                        c != 0) {\n                        shift = FastMath.sqrt(b * b + c);\n                        if (b < 0) {\n                            shift = -shift;\n                        }\n                        shift = c / (b + shift);\n                    }\n                    double f = (sk + sp) * (sk - sp) + shift;\n                    double g = sk * ek;\n                    // Chase zeros.\n                    for (int j = k; j < p - 1; j++) {\n                        double t = FastMath.hypot(f, g);\n                        double cs = f / t;\n                        double sn = g / t;\n                        if (j != k) {\n                            e[j - 1] = t;\n                        }\n                        f = cs * singularValues[j] + sn * e[j];\n                        e[j] = cs * e[j] - sn * singularValues[j];\n                        g = sn * singularValues[j + 1];\n                        singularValues[j + 1] = cs * singularValues[j + 1];\n\n                        for (int i = 0; i < n; i++) {\n                            t = cs * V[i][j] + sn * V[i][j + 1];\n                            V[i][j + 1] = -sn * V[i][j] + cs * V[i][j + 1];\n                            V[i][j] = t;\n                        }\n                        t = FastMath.hypot(f, g);\n                        cs = f / t;\n                        sn = g / t;\n                        singularValues[j] = t;\n                        f = cs * e[j] + sn * singularValues[j + 1];\n                        singularValues[j + 1] = -sn * e[j] + cs * singularValues[j + 1];\n                        g = sn * e[j + 1];\n                        e[j + 1] = cs * e[j + 1];\n                        if (j < m - 1) {\n                            for (int i = 0; i < m; i++) {\n                                t = cs * U[i][j] + sn * U[i][j + 1];\n                                U[i][j + 1] = -sn * U[i][j] + cs * U[i][j + 1];\n                                U[i][j] = t;\n                            }\n                        }\n                    }\n                    e[p - 2] = f;\n                    iter = iter + 1;\n                }\n                break;\n                // Convergence.\n                default: {\n                    // Make the singular values positive.\n                    if (singularValues[k] <= 0) {\n                        singularValues[k] = singularValues[k] < 0 ? -singularValues[k] : 0;\n\n                        for (int i = 0; i <= pp; i++) {\n                            V[i][k] = -V[i][k];\n                        }\n                    }\n                    // Order the singular values.\n                    while (k < pp) {\n                        if (singularValues[k] >= singularValues[k + 1]) {\n                            break;\n                        }\n                        double t = singularValues[k];\n                        singularValues[k] = singularValues[k + 1];\n                        singularValues[k + 1] = t;\n                        if (k < n - 1) {\n                            for (int i = 0; i < n; i++) {\n                                t = V[i][k + 1];\n                                V[i][k + 1] = V[i][k];\n                                V[i][k] = t;\n                            }\n                        }\n                        if (k < m - 1) {\n                            for (int i = 0; i < m; i++) {\n                                t = U[i][k + 1];\n                                U[i][k + 1] = U[i][k];\n                                U[i][k] = t;\n                            }\n                        }\n                        k++;\n                    }\n                    iter = 0;\n                    p--;\n                }\n                break;\n            }\n        }\n\n        // Set the small value tolerance used to calculate rank and pseudo-inverse\n        tol = FastMath.max(m * singularValues[0] * EPS,\n                           FastMath.sqrt(Precision.SAFE_MIN));\n\n        if (!transposed) {\n            cachedU = MatrixUtils.createRealMatrix(U);\n            cachedV = MatrixUtils.createRealMatrix(V);\n        } else {\n            cachedU = MatrixUtils.createRealMatrix(V);\n            cachedV = MatrixUtils.createRealMatrix(U);\n        }\n    }",
          "18": "    public SingularValueDecomposition(final RealMatrix matrix) {\n        final double[][] A;\n\n         // \"m\" is always the largest dimension.\n        if (matrix.getRowDimension() < matrix.getColumnDimension()) {\n            transposed = true;\n            A = matrix.transpose().getData();\n            m = matrix.getColumnDimension();\n            n = matrix.getRowDimension();\n        } else {\n            transposed = false;\n            A = matrix.getData();\n            m = matrix.getRowDimension();\n            n = matrix.getColumnDimension();\n        }\n\n        singularValues = new double[n];\n        final double[][] U = new double[m][n];\n        final double[][] V = new double[n][n];\n        final double[] e = new double[n];\n        final double[] work = new double[m];\n        // Reduce A to bidiagonal form, storing the diagonal elements\n        // in s and the super-diagonal elements in e.\n        final int nct = FastMath.min(m - 1, n);\n        final int nrt = FastMath.max(0, n - 2);\n        for (int k = 0; k < FastMath.max(nct, nrt); k++) {\n            if (k < nct) {\n                // Compute the transformation for the k-th column and\n                // place the k-th diagonal in s[k].\n                // Compute 2-norm of k-th column without under/overflow.\n                singularValues[k] = 0;\n                for (int i = k; i < m; i++) {\n                    singularValues[k] = FastMath.hypot(singularValues[k], A[i][k]);\n                }\n                if (singularValues[k] != 0) {\n                    if (A[k][k] < 0) {\nfor(int i = k;(i < m);i++) {                        singularValues[k] = +singularValues[k];                    }\n                    for (int i = k; i < m; i++) {\n                        A[i][k] /= singularValues[k];\n                    }\n                    A[k][k] += 1;\n                }\n                singularValues[k] = -singularValues[k];\n            }\n            for (int j = k + 1; j < n; j++) {\n                if (k < nct &&\n                    singularValues[k] != 0) {\n                    // Apply the transformation.\n                    double t = 0;\n                    for (int i = k; i < m; i++) {\n                        t += A[i][k] * A[i][j];\n                    }\n                    t = -t / A[k][k];\n                    for (int i = k; i < m; i++) {\n                        A[i][j] += t * A[i][k];\n                    }\n                }\n                // Place the k-th row of A into e for the\n                // subsequent calculation of the row transformation.\n                e[j] = A[k][j];\n            }\n            if (k < nct) {\n                // Place the transformation in U for subsequent back\n                // multiplication.\n                for (int i = k; i < m; i++) {\n                    U[i][k] = A[i][k];\n                }\n            }\n            if (k < nrt) {\n                // Compute the k-th row transformation and place the\n                // k-th super-diagonal in e[k].\n                // Compute 2-norm without under/overflow.\n                e[k] = 0;\n                for (int i = k + 1; i < n; i++) {\n                    e[k] = FastMath.hypot(e[k], e[i]);\n                }\n                if (e[k] != 0) {\n                    if (e[k + 1] < 0) {\n                        e[k] = -e[k];\n                    }\n                    for (int i = k + 1; i < n; i++) {\n                        e[i] /= e[k];\n                    }\n                    e[k + 1] += 1;\n                }\n                e[k] = -e[k];\n                if (k + 1 < m &&\n                    e[k] != 0) {\n                    // Apply the transformation.\n                    for (int i = k + 1; i < m; i++) {\n                        work[i] = 0;\n                    }\n                    for (int j = k + 1; j < n; j++) {\n                        for (int i = k + 1; i < m; i++) {\n                            work[i] += e[j] * A[i][j];\n                        }\n                    }\n                    for (int j = k + 1; j < n; j++) {\n                        final double t = -e[j] / e[k + 1];\n                        for (int i = k + 1; i < m; i++) {\n                            A[i][j] += t * work[i];\n                        }\n                    }\n                }\n\n                // Place the transformation in V for subsequent\n                // back multiplication.\n                for (int i = k + 1; i < n; i++) {\n                    V[i][k] = e[i];\n                }\n            }\n        }\n        // Set up the final bidiagonal matrix or order p.\n        int p = n;\n        if (nct < n) {\n            singularValues[nct] = A[nct][nct];\n        }\n        if (m < p) {\n            singularValues[p - 1] = 0;\n        }\n        if (nrt + 1 < p) {\n            e[nrt] = A[nrt][p - 1];\n        }\n        e[p - 1] = 0;\n\n        // Generate U.\n        for (int j = nct; j < n; j++) {\n            for (int i = 0; i < m; i++) {\n                U[i][j] = 0;\n            }\n            U[j][j] = 1;\n        }\n        for (int k = nct - 1; k >= 0; k--) {\n            if (singularValues[k] != 0) {\n                for (int j = k + 1; j < n; j++) {\n                    double t = 0;\n                    for (int i = k; i < m; i++) {\n                        t += U[i][k] * U[i][j];\n                    }\n                    t = -t / U[k][k];\n                    for (int i = k; i < m; i++) {\n                        U[i][j] += t * U[i][k];\n                    }\n                }\n                for (int i = k; i < m; i++) {\n                    U[i][k] = -U[i][k];\n                }\n                U[k][k] = 1 + U[k][k];\n                for (int i = 0; i < k - 1; i++) {\n                    U[i][k] = 0;\n                }\n            } else {\n                for (int i = 0; i < m; i++) {\n                    U[i][k] = 0;\n                }\n                U[k][k] = 1;\n            }\n        }\n\n        // Generate V.\n        for (int k = n - 1; k >= 0; k--) {\n            if (k < nrt &&\n                e[k] != 0) {\n                for (int j = k + 1; j < n; j++) {\n                    double t = 0;\n                    for (int i = k + 1; i < n; i++) {\n                        t += V[i][k] * V[i][j];\n                    }\n                    t = -t / V[k + 1][k];\n                    for (int i = k + 1; i < n; i++) {\n                        V[i][j] += t * V[i][k];\n                    }\n                }\n            }\n            for (int i = 0; i < n; i++) {\n                V[i][k] = 0;\n            }\n            V[k][k] = 1;\n        }\n\n        // Main iteration loop for the singular values.\n        final int pp = p - 1;\n        int iter = 0;\n        while (p > 0) {\n            int k;\n            int kase;\n            // Here is where a test for too many iterations would go.\n            // This section of the program inspects for\n            // negligible elements in the s and e arrays.  On\n            // completion the variables kase and k are set as follows.\n            // kase = 1     if s(p) and e[k-1] are negligible and k<p\n            // kase = 2     if s(k) is negligible and k<p\n            // kase = 3     if e[k-1] is negligible, k<p, and\n            //              s(k), ..., s(p) are not negligible (qr step).\n            // kase = 4     if e(p-1) is negligible (convergence).\n            for (k = p - 2; k >= 0; k--) {\n                final double threshold\n                    = TINY + EPS * (FastMath.abs(singularValues[k]) +\n                                    FastMath.abs(singularValues[k + 1]));\n\n                // the following condition is written this way in order\n                // to break out of the loop when NaN occurs, writing it\n                // as \"if (FastMath.abs(e[k]) <= threshold)\" would loop\n                // indefinitely in case of NaNs because comparison on NaNs\n                // always return false, regardless of what is checked\n                // see issue MATH-947\n                if (!(FastMath.abs(e[k]) > threshold)) {\n                    e[k] = 0;\n                    break;\n                }\n\n            }\n\n            if (k == p - 2) {\n                kase = 4;\n            } else {\n                int ks;\n                for (ks = p - 1; ks >= k; ks--) {\n                    if (ks == k) {\n                        break;\n                    }\n                    final double t = (ks != p ? FastMath.abs(e[ks]) : 0) +\n                        (ks != k + 1 ? FastMath.abs(e[ks - 1]) : 0);\n                    if (FastMath.abs(singularValues[ks]) <= TINY + EPS * t) {\n                        singularValues[ks] = 0;\n                        break;\n                    }\n                }\n                if (ks == k) {\n                    kase = 3;\n                } else if (ks == p - 1) {\n                    kase = 1;\n                } else {\n                    kase = 2;\n                    k = ks;\n                }\n            }\n            k++;\n            // Perform the task indicated by kase.\n            switch (kase) {\n                // Deflate negligible s(p).\n                case 1: {\n                    double f = e[p - 2];\n                    e[p - 2] = 0;\n                    for (int j = p - 2; j >= k; j--) {\n                        double t = FastMath.hypot(singularValues[j], f);\n                        final double cs = singularValues[j] / t;\n                        final double sn = f / t;\n                        singularValues[j] = t;\n                        if (j != k) {\n                            f = -sn * e[j - 1];\n                            e[j - 1] = cs * e[j - 1];\n                        }\n\n                        for (int i = 0; i < n; i++) {\n                            t = cs * V[i][j] + sn * V[i][p - 1];\n                            V[i][p - 1] = -sn * V[i][j] + cs * V[i][p - 1];\n                            V[i][j] = t;\n                        }\n                    }\n                }\n                break;\n                // Split at negligible s(k).\n                case 2: {\n                    double f = e[k - 1];\n                    e[k - 1] = 0;\n                    for (int j = k; j < p; j++) {\n                        double t = FastMath.hypot(singularValues[j], f);\n                        final double cs = singularValues[j] / t;\n                        final double sn = f / t;\n                        singularValues[j] = t;\n                        f = -sn * e[j];\n                        e[j] = cs * e[j];\n\n                        for (int i = 0; i < m; i++) {\n                            t = cs * U[i][j] + sn * U[i][k - 1];\n                            U[i][k - 1] = -sn * U[i][j] + cs * U[i][k - 1];\n                            U[i][j] = t;\n                        }\n                    }\n                }\n                break;\n                // Perform one qr step.\n                case 3: {\n                    // Calculate the shift.\n                    final double maxPm1Pm2 = FastMath.max(FastMath.abs(singularValues[p - 1]),\n                                                          FastMath.abs(singularValues[p - 2]));\n                    final double scale = FastMath.max(FastMath.max(FastMath.max(maxPm1Pm2,\n                                                                                FastMath.abs(e[p - 2])),\n                                                                   FastMath.abs(singularValues[k])),\n                                                      FastMath.abs(e[k]));\n                    final double sp = singularValues[p - 1] / scale;\n                    final double spm1 = singularValues[p - 2] / scale;\n                    final double epm1 = e[p - 2] / scale;\n                    final double sk = singularValues[k] / scale;\n                    final double ek = e[k] / scale;\n                    final double b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2.0;\n                    final double c = (sp * epm1) * (sp * epm1);\n                    double shift = 0;\n                    if (b != 0 ||\n                        c != 0) {\n                        shift = FastMath.sqrt(b * b + c);\n                        if (b < 0) {\n                            shift = -shift;\n                        }\n                        shift = c / (b + shift);\n                    }\n                    double f = (sk + sp) * (sk - sp) + shift;\n                    double g = sk * ek;\n                    // Chase zeros.\n                    for (int j = k; j < p - 1; j++) {\n                        double t = FastMath.hypot(f, g);\n                        double cs = f / t;\n                        double sn = g / t;\n                        if (j != k) {\n                            e[j - 1] = t;\n                        }\n                        f = cs * singularValues[j] + sn * e[j];\n                        e[j] = cs * e[j] - sn * singularValues[j];\n                        g = sn * singularValues[j + 1];\n                        singularValues[j + 1] = cs * singularValues[j + 1];\n\n                        for (int i = 0; i < n; i++) {\n                            t = cs * V[i][j] + sn * V[i][j + 1];\n                            V[i][j + 1] = -sn * V[i][j] + cs * V[i][j + 1];\n                            V[i][j] = t;\n                        }\n                        t = FastMath.hypot(f, g);\n                        cs = f / t;\n                        sn = g / t;\n                        singularValues[j] = t;\n                        f = cs * e[j] + sn * singularValues[j + 1];\n                        singularValues[j + 1] = -sn * e[j] + cs * singularValues[j + 1];\n                        g = sn * e[j + 1];\n                        e[j + 1] = cs * e[j + 1];\n                        if (j < m - 1) {\n                            for (int i = 0; i < m; i++) {\n                                t = cs * U[i][j] + sn * U[i][j + 1];\n                                U[i][j + 1] = -sn * U[i][j] + cs * U[i][j + 1];\n                                U[i][j] = t;\n                            }\n                        }\n                    }\n                    e[p - 2] = f;\n                    iter = iter + 1;\n                }\n                break;\n                // Convergence.\n                default: {\n                    // Make the singular values positive.\n                    if (singularValues[k] <= 0) {\n                        singularValues[k] = singularValues[k] < 0 ? -singularValues[k] : 0;\n\n                        for (int i = 0; i <= pp; i++) {\n                            V[i][k] = -V[i][k];\n                        }\n                    }\n                    // Order the singular values.\n                    while (k < pp) {\n                        if (singularValues[k] >= singularValues[k + 1]) {\n                            break;\n                        }\n                        double t = singularValues[k];\n                        singularValues[k] = singularValues[k + 1];\n                        singularValues[k + 1] = t;\n                        if (k < n - 1) {\n                            for (int i = 0; i < n; i++) {\n                                t = V[i][k + 1];\n                                V[i][k + 1] = V[i][k];\n                                V[i][k] = t;\n                            }\n                        }\n                        if (k < m - 1) {\n                            for (int i = 0; i < m; i++) {\n                                t = U[i][k + 1];\n                                U[i][k + 1] = U[i][k];\n                                U[i][k] = t;\n                            }\n                        }\n                        k++;\n                    }\n                    iter = 0;\n                    p--;\n                }\n                break;\n            }\n        }\n\n        // Set the small value tolerance used to calculate rank and pseudo-inverse\n        tol = FastMath.max(m * singularValues[0] * EPS,\n                           FastMath.sqrt(Precision.SAFE_MIN));\n\n        if (!transposed) {\n            cachedU = MatrixUtils.createRealMatrix(U);\n            cachedV = MatrixUtils.createRealMatrix(V);\n        } else {\n            cachedU = MatrixUtils.createRealMatrix(V);\n            cachedV = MatrixUtils.createRealMatrix(U);\n        }\n    }",
          "19": "    public SingularValueDecomposition(final RealMatrix matrix) {\n        final double[][] A;\n\n         // \"m\" is always the largest dimension.\n        if (matrix.getRowDimension() < matrix.getColumnDimension()) {\n            transposed = true;\n            A = matrix.transpose().getData();\n            m = matrix.getColumnDimension();\n            n = matrix.getRowDimension();\n        } else {\n            transposed = false;\n            A = matrix.getData();\n            m = matrix.getRowDimension();\n            n = matrix.getColumnDimension();\n        }\n\n        singularValues = new double[n];\n        final double[][] U = new double[m][n];\n        final double[][] V = new double[n][n];\n        final double[] e = new double[n];\n        final double[] work = new double[m];\n        // Reduce A to bidiagonal form, storing the diagonal elements\n        // in s and the super-diagonal elements in e.\n        final int nct = FastMath.min(m - 1, n);\n        final int nrt = FastMath.max(0, n - 2);\n        for (int k = 0; k < FastMath.max(nct, nrt); k++) {\n            if (k < nct) {\n                // Compute the transformation for the k-th column and\n                // place the k-th diagonal in s[k].\n                // Compute 2-norm of k-th column without under/overflow.\n                singularValues[k] = 0;\n                for (int i = k; i < m; i++) {\n                    singularValues[k] = FastMath.hypot(singularValues[k], A[i][k]);\n                }\n                if (singularValues[k] != 0) {\n                    if (A[k][k] < 0) {\nA[k].[k] += 1;\n                        singularValues[k] = +singularValues[k];                    }\n                    for (int i = k; i < m; i++) {\n                        A[i][k] /= singularValues[k];\n                    }\n                    A[k][k] += 1;\n                }\n                singularValues[k] = -singularValues[k];\n            }\n            for (int j = k + 1; j < n; j++) {\n                if (k < nct &&\n                    singularValues[k] != 0) {\n                    // Apply the transformation.\n                    double t = 0;\n                    for (int i = k; i < m; i++) {\n                        t += A[i][k] * A[i][j];\n                    }\n                    t = -t / A[k][k];\n                    for (int i = k; i < m; i++) {\n                        A[i][j] += t * A[i][k];\n                    }\n                }\n                // Place the k-th row of A into e for the\n                // subsequent calculation of the row transformation.\n                e[j] = A[k][j];\n            }\n            if (k < nct) {\n                // Place the transformation in U for subsequent back\n                // multiplication.\n                for (int i = k; i < m; i++) {\n                    U[i][k] = A[i][k];\n                }\n            }\n            if (k < nrt) {\n                // Compute the k-th row transformation and place the\n                // k-th super-diagonal in e[k].\n                // Compute 2-norm without under/overflow.\n                e[k] = 0;\n                for (int i = k + 1; i < n; i++) {\n                    e[k] = FastMath.hypot(e[k], e[i]);\n                }\n                if (e[k] != 0) {\n                    if (e[k + 1] < 0) {\n                        e[k] = -e[k];\n                    }\n                    for (int i = k + 1; i < n; i++) {\n                        e[i] /= e[k];\n                    }\n                    e[k + 1] += 1;\n                }\n                e[k] = -e[k];\n                if (k + 1 < m &&\n                    e[k] != 0) {\n                    // Apply the transformation.\n                    for (int i = k + 1; i < m; i++) {\n                        work[i] = 0;\n                    }\n                    for (int j = k + 1; j < n; j++) {\n                        for (int i = k + 1; i < m; i++) {\n                            work[i] += e[j] * A[i][j];\n                        }\n                    }\n                    for (int j = k + 1; j < n; j++) {\n                        final double t = -e[j] / e[k + 1];\n                        for (int i = k + 1; i < m; i++) {\n                            A[i][j] += t * work[i];\n                        }\n                    }\n                }\n\n                // Place the transformation in V for subsequent\n                // back multiplication.\n                for (int i = k + 1; i < n; i++) {\n                    V[i][k] = e[i];\n                }\n            }\n        }\n        // Set up the final bidiagonal matrix or order p.\n        int p = n;\n        if (nct < n) {\n            singularValues[nct] = A[nct][nct];\n        }\n        if (m < p) {\n            singularValues[p - 1] = 0;\n        }\n        if (nrt + 1 < p) {\n            e[nrt] = A[nrt][p - 1];\n        }\n        e[p - 1] = 0;\n\n        // Generate U.\n        for (int j = nct; j < n; j++) {\n            for (int i = 0; i < m; i++) {\n                U[i][j] = 0;\n            }\n            U[j][j] = 1;\n        }\n        for (int k = nct - 1; k >= 0; k--) {\n            if (singularValues[k] != 0) {\n                for (int j = k + 1; j < n; j++) {\n                    double t = 0;\n                    for (int i = k; i < m; i++) {\n                        t += U[i][k] * U[i][j];\n                    }\n                    t = -t / U[k][k];\n                    for (int i = k; i < m; i++) {\n                        U[i][j] += t * U[i][k];\n                    }\n                }\n                for (int i = k; i < m; i++) {\n                    U[i][k] = -U[i][k];\n                }\n                U[k][k] = 1 + U[k][k];\n                for (int i = 0; i < k - 1; i++) {\n                    U[i][k] = 0;\n                }\n            } else {\n                for (int i = 0; i < m; i++) {\n                    U[i][k] = 0;\n                }\n                U[k][k] = 1;\n            }\n        }\n\n        // Generate V.\n        for (int k = n - 1; k >= 0; k--) {\n            if (k < nrt &&\n                e[k] != 0) {\n                for (int j = k + 1; j < n; j++) {\n                    double t = 0;\n                    for (int i = k + 1; i < n; i++) {\n                        t += V[i][k] * V[i][j];\n                    }\n                    t = -t / V[k + 1][k];\n                    for (int i = k + 1; i < n; i++) {\n                        V[i][j] += t * V[i][k];\n                    }\n                }\n            }\n            for (int i = 0; i < n; i++) {\n                V[i][k] = 0;\n            }\n            V[k][k] = 1;\n        }\n\n        // Main iteration loop for the singular values.\n        final int pp = p - 1;\n        int iter = 0;\n        while (p > 0) {\n            int k;\n            int kase;\n            // Here is where a test for too many iterations would go.\n            // This section of the program inspects for\n            // negligible elements in the s and e arrays.  On\n            // completion the variables kase and k are set as follows.\n            // kase = 1     if s(p) and e[k-1] are negligible and k<p\n            // kase = 2     if s(k) is negligible and k<p\n            // kase = 3     if e[k-1] is negligible, k<p, and\n            //              s(k), ..., s(p) are not negligible (qr step).\n            // kase = 4     if e(p-1) is negligible (convergence).\n            for (k = p - 2; k >= 0; k--) {\n                final double threshold\n                    = TINY + EPS * (FastMath.abs(singularValues[k]) +\n                                    FastMath.abs(singularValues[k + 1]));\n\n                // the following condition is written this way in order\n                // to break out of the loop when NaN occurs, writing it\n                // as \"if (FastMath.abs(e[k]) <= threshold)\" would loop\n                // indefinitely in case of NaNs because comparison on NaNs\n                // always return false, regardless of what is checked\n                // see issue MATH-947\n                if (!(FastMath.abs(e[k]) > threshold)) {\n                    e[k] = 0;\n                    break;\n                }\n\n            }\n\n            if (k == p - 2) {\n                kase = 4;\n            } else {\n                int ks;\n                for (ks = p - 1; ks >= k; ks--) {\n                    if (ks == k) {\n                        break;\n                    }\n                    final double t = (ks != p ? FastMath.abs(e[ks]) : 0) +\n                        (ks != k + 1 ? FastMath.abs(e[ks - 1]) : 0);\n                    if (FastMath.abs(singularValues[ks]) <= TINY + EPS * t) {\n                        singularValues[ks] = 0;\n                        break;\n                    }\n                }\n                if (ks == k) {\n                    kase = 3;\n                } else if (ks == p - 1) {\n                    kase = 1;\n                } else {\n                    kase = 2;\n                    k = ks;\n                }\n            }\n            k++;\n            // Perform the task indicated by kase.\n            switch (kase) {\n                // Deflate negligible s(p).\n                case 1: {\n                    double f = e[p - 2];\n                    e[p - 2] = 0;\n                    for (int j = p - 2; j >= k; j--) {\n                        double t = FastMath.hypot(singularValues[j], f);\n                        final double cs = singularValues[j] / t;\n                        final double sn = f / t;\n                        singularValues[j] = t;\n                        if (j != k) {\n                            f = -sn * e[j - 1];\n                            e[j - 1] = cs * e[j - 1];\n                        }\n\n                        for (int i = 0; i < n; i++) {\n                            t = cs * V[i][j] + sn * V[i][p - 1];\n                            V[i][p - 1] = -sn * V[i][j] + cs * V[i][p - 1];\n                            V[i][j] = t;\n                        }\n                    }\n                }\n                break;\n                // Split at negligible s(k).\n                case 2: {\n                    double f = e[k - 1];\n                    e[k - 1] = 0;\n                    for (int j = k; j < p; j++) {\n                        double t = FastMath.hypot(singularValues[j], f);\n                        final double cs = singularValues[j] / t;\n                        final double sn = f / t;\n                        singularValues[j] = t;\n                        f = -sn * e[j];\n                        e[j] = cs * e[j];\n\n                        for (int i = 0; i < m; i++) {\n                            t = cs * U[i][j] + sn * U[i][k - 1];\n                            U[i][k - 1] = -sn * U[i][j] + cs * U[i][k - 1];\n                            U[i][j] = t;\n                        }\n                    }\n                }\n                break;\n                // Perform one qr step.\n                case 3: {\n                    // Calculate the shift.\n                    final double maxPm1Pm2 = FastMath.max(FastMath.abs(singularValues[p - 1]),\n                                                          FastMath.abs(singularValues[p - 2]));\n                    final double scale = FastMath.max(FastMath.max(FastMath.max(maxPm1Pm2,\n                                                                                FastMath.abs(e[p - 2])),\n                                                                   FastMath.abs(singularValues[k])),\n                                                      FastMath.abs(e[k]));\n                    final double sp = singularValues[p - 1] / scale;\n                    final double spm1 = singularValues[p - 2] / scale;\n                    final double epm1 = e[p - 2] / scale;\n                    final double sk = singularValues[k] / scale;\n                    final double ek = e[k] / scale;\n                    final double b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2.0;\n                    final double c = (sp * epm1) * (sp * epm1);\n                    double shift = 0;\n                    if (b != 0 ||\n                        c != 0) {\n                        shift = FastMath.sqrt(b * b + c);\n                        if (b < 0) {\n                            shift = -shift;\n                        }\n                        shift = c / (b + shift);\n                    }\n                    double f = (sk + sp) * (sk - sp) + shift;\n                    double g = sk * ek;\n                    // Chase zeros.\n                    for (int j = k; j < p - 1; j++) {\n                        double t = FastMath.hypot(f, g);\n                        double cs = f / t;\n                        double sn = g / t;\n                        if (j != k) {\n                            e[j - 1] = t;\n                        }\n                        f = cs * singularValues[j] + sn * e[j];\n                        e[j] = cs * e[j] - sn * singularValues[j];\n                        g = sn * singularValues[j + 1];\n                        singularValues[j + 1] = cs * singularValues[j + 1];\n\n                        for (int i = 0; i < n; i++) {\n                            t = cs * V[i][j] + sn * V[i][j + 1];\n                            V[i][j + 1] = -sn * V[i][j] + cs * V[i][j + 1];\n                            V[i][j] = t;\n                        }\n                        t = FastMath.hypot(f, g);\n                        cs = f / t;\n                        sn = g / t;\n                        singularValues[j] = t;\n                        f = cs * e[j] + sn * singularValues[j + 1];\n                        singularValues[j + 1] = -sn * e[j] + cs * singularValues[j + 1];\n                        g = sn * e[j + 1];\n                        e[j + 1] = cs * e[j + 1];\n                        if (j < m - 1) {\n                            for (int i = 0; i < m; i++) {\n                                t = cs * U[i][j] + sn * U[i][j + 1];\n                                U[i][j + 1] = -sn * U[i][j] + cs * U[i][j + 1];\n                                U[i][j] = t;\n                            }\n                        }\n                    }\n                    e[p - 2] = f;\n                    iter = iter + 1;\n                }\n                break;\n                // Convergence.\n                default: {\n                    // Make the singular values positive.\n                    if (singularValues[k] <= 0) {\n                        singularValues[k] = singularValues[k] < 0 ? -singularValues[k] : 0;\n\n                        for (int i = 0; i <= pp; i++) {\n                            V[i][k] = -V[i][k];\n                        }\n                    }\n                    // Order the singular values.\n                    while (k < pp) {\n                        if (singularValues[k] >= singularValues[k + 1]) {\n                            break;\n                        }\n                        double t = singularValues[k];\n                        singularValues[k] = singularValues[k + 1];\n                        singularValues[k + 1] = t;\n                        if (k < n - 1) {\n                            for (int i = 0; i < n; i++) {\n                                t = V[i][k + 1];\n                                V[i][k + 1] = V[i][k];\n                                V[i][k] = t;\n                            }\n                        }\n                        if (k < m - 1) {\n                            for (int i = 0; i < m; i++) {\n                                t = U[i][k + 1];\n                                U[i][k + 1] = U[i][k];\n                                U[i][k] = t;\n                            }\n                        }\n                        k++;\n                    }\n                    iter = 0;\n                    p--;\n                }\n                break;\n            }\n        }\n\n        // Set the small value tolerance used to calculate rank and pseudo-inverse\n        tol = FastMath.max(m * singularValues[0] * EPS,\n                           FastMath.sqrt(Precision.SAFE_MIN));\n\n        if (!transposed) {\n            cachedU = MatrixUtils.createRealMatrix(U);\n            cachedV = MatrixUtils.createRealMatrix(V);\n        } else {\n            cachedU = MatrixUtils.createRealMatrix(V);\n            cachedV = MatrixUtils.createRealMatrix(U);\n        }\n    }",
          "20": "    public SingularValueDecomposition(final RealMatrix matrix) {\n        final double[][] A;\n\n         // \"m\" is always the largest dimension.\n        if (matrix.getRowDimension() < matrix.getColumnDimension()) {\n            transposed = true;\n            A = matrix.transpose().getData();\n            m = matrix.getColumnDimension();\n            n = matrix.getRowDimension();\n        } else {\n            transposed = false;\n            A = matrix.getData();\n            m = matrix.getRowDimension();\n            n = matrix.getColumnDimension();\n        }\n\n        singularValues = new double[n];\n        final double[][] U = new double[m][n];\n        final double[][] V = new double[n][n];\n        final double[] e = new double[n];\n        final double[] work = new double[m];\n        // Reduce A to bidiagonal form, storing the diagonal elements\n        // in s and the super-diagonal elements in e.\n        final int nct = FastMath.min(m - 1, n);\n        final int nrt = FastMath.max(0, n - 2);\n        for (int k = 0; k < FastMath.max(nct, nrt); k++) {\n            if (k < nct) {\n                // Compute the transformation for the k-th column and\n                // place the k-th diagonal in s[k].\n                // Compute 2-norm of k-th column without under/overflow.\n                singularValues[k] = 0;\n                for (int i = k; i < m; i++) {\n                    singularValues[k] = FastMath.hypot(singularValues[k], A[i][k]);\n                }\n                if (singularValues[k] != 0) {\n                    if (A[k][k] < 0) {\nA[i].[k] /= singularValues[k];\n                        singularValues[k] = +singularValues[k];                    }\n                    for (int i = k; i < m; i++) {\n                        A[i][k] /= singularValues[k];\n                    }\n                    A[k][k] += 1;\n                }\n                singularValues[k] = -singularValues[k];\n            }\n            for (int j = k + 1; j < n; j++) {\n                if (k < nct &&\n                    singularValues[k] != 0) {\n                    // Apply the transformation.\n                    double t = 0;\n                    for (int i = k; i < m; i++) {\n                        t += A[i][k] * A[i][j];\n                    }\n                    t = -t / A[k][k];\n                    for (int i = k; i < m; i++) {\n                        A[i][j] += t * A[i][k];\n                    }\n                }\n                // Place the k-th row of A into e for the\n                // subsequent calculation of the row transformation.\n                e[j] = A[k][j];\n            }\n            if (k < nct) {\n                // Place the transformation in U for subsequent back\n                // multiplication.\n                for (int i = k; i < m; i++) {\n                    U[i][k] = A[i][k];\n                }\n            }\n            if (k < nrt) {\n                // Compute the k-th row transformation and place the\n                // k-th super-diagonal in e[k].\n                // Compute 2-norm without under/overflow.\n                e[k] = 0;\n                for (int i = k + 1; i < n; i++) {\n                    e[k] = FastMath.hypot(e[k], e[i]);\n                }\n                if (e[k] != 0) {\n                    if (e[k + 1] < 0) {\n                        e[k] = -e[k];\n                    }\n                    for (int i = k + 1; i < n; i++) {\n                        e[i] /= e[k];\n                    }\n                    e[k + 1] += 1;\n                }\n                e[k] = -e[k];\n                if (k + 1 < m &&\n                    e[k] != 0) {\n                    // Apply the transformation.\n                    for (int i = k + 1; i < m; i++) {\n                        work[i] = 0;\n                    }\n                    for (int j = k + 1; j < n; j++) {\n                        for (int i = k + 1; i < m; i++) {\n                            work[i] += e[j] * A[i][j];\n                        }\n                    }\n                    for (int j = k + 1; j < n; j++) {\n                        final double t = -e[j] / e[k + 1];\n                        for (int i = k + 1; i < m; i++) {\n                            A[i][j] += t * work[i];\n                        }\n                    }\n                }\n\n                // Place the transformation in V for subsequent\n                // back multiplication.\n                for (int i = k + 1; i < n; i++) {\n                    V[i][k] = e[i];\n                }\n            }\n        }\n        // Set up the final bidiagonal matrix or order p.\n        int p = n;\n        if (nct < n) {\n            singularValues[nct] = A[nct][nct];\n        }\n        if (m < p) {\n            singularValues[p - 1] = 0;\n        }\n        if (nrt + 1 < p) {\n            e[nrt] = A[nrt][p - 1];\n        }\n        e[p - 1] = 0;\n\n        // Generate U.\n        for (int j = nct; j < n; j++) {\n            for (int i = 0; i < m; i++) {\n                U[i][j] = 0;\n            }\n            U[j][j] = 1;\n        }\n        for (int k = nct - 1; k >= 0; k--) {\n            if (singularValues[k] != 0) {\n                for (int j = k + 1; j < n; j++) {\n                    double t = 0;\n                    for (int i = k; i < m; i++) {\n                        t += U[i][k] * U[i][j];\n                    }\n                    t = -t / U[k][k];\n                    for (int i = k; i < m; i++) {\n                        U[i][j] += t * U[i][k];\n                    }\n                }\n                for (int i = k; i < m; i++) {\n                    U[i][k] = -U[i][k];\n                }\n                U[k][k] = 1 + U[k][k];\n                for (int i = 0; i < k - 1; i++) {\n                    U[i][k] = 0;\n                }\n            } else {\n                for (int i = 0; i < m; i++) {\n                    U[i][k] = 0;\n                }\n                U[k][k] = 1;\n            }\n        }\n\n        // Generate V.\n        for (int k = n - 1; k >= 0; k--) {\n            if (k < nrt &&\n                e[k] != 0) {\n                for (int j = k + 1; j < n; j++) {\n                    double t = 0;\n                    for (int i = k + 1; i < n; i++) {\n                        t += V[i][k] * V[i][j];\n                    }\n                    t = -t / V[k + 1][k];\n                    for (int i = k + 1; i < n; i++) {\n                        V[i][j] += t * V[i][k];\n                    }\n                }\n            }\n            for (int i = 0; i < n; i++) {\n                V[i][k] = 0;\n            }\n            V[k][k] = 1;\n        }\n\n        // Main iteration loop for the singular values.\n        final int pp = p - 1;\n        int iter = 0;\n        while (p > 0) {\n            int k;\n            int kase;\n            // Here is where a test for too many iterations would go.\n            // This section of the program inspects for\n            // negligible elements in the s and e arrays.  On\n            // completion the variables kase and k are set as follows.\n            // kase = 1     if s(p) and e[k-1] are negligible and k<p\n            // kase = 2     if s(k) is negligible and k<p\n            // kase = 3     if e[k-1] is negligible, k<p, and\n            //              s(k), ..., s(p) are not negligible (qr step).\n            // kase = 4     if e(p-1) is negligible (convergence).\n            for (k = p - 2; k >= 0; k--) {\n                final double threshold\n                    = TINY + EPS * (FastMath.abs(singularValues[k]) +\n                                    FastMath.abs(singularValues[k + 1]));\n\n                // the following condition is written this way in order\n                // to break out of the loop when NaN occurs, writing it\n                // as \"if (FastMath.abs(e[k]) <= threshold)\" would loop\n                // indefinitely in case of NaNs because comparison on NaNs\n                // always return false, regardless of what is checked\n                // see issue MATH-947\n                if (!(FastMath.abs(e[k]) > threshold)) {\n                    e[k] = 0;\n                    break;\n                }\n\n            }\n\n            if (k == p - 2) {\n                kase = 4;\n            } else {\n                int ks;\n                for (ks = p - 1; ks >= k; ks--) {\n                    if (ks == k) {\n                        break;\n                    }\n                    final double t = (ks != p ? FastMath.abs(e[ks]) : 0) +\n                        (ks != k + 1 ? FastMath.abs(e[ks - 1]) : 0);\n                    if (FastMath.abs(singularValues[ks]) <= TINY + EPS * t) {\n                        singularValues[ks] = 0;\n                        break;\n                    }\n                }\n                if (ks == k) {\n                    kase = 3;\n                } else if (ks == p - 1) {\n                    kase = 1;\n                } else {\n                    kase = 2;\n                    k = ks;\n                }\n            }\n            k++;\n            // Perform the task indicated by kase.\n            switch (kase) {\n                // Deflate negligible s(p).\n                case 1: {\n                    double f = e[p - 2];\n                    e[p - 2] = 0;\n                    for (int j = p - 2; j >= k; j--) {\n                        double t = FastMath.hypot(singularValues[j], f);\n                        final double cs = singularValues[j] / t;\n                        final double sn = f / t;\n                        singularValues[j] = t;\n                        if (j != k) {\n                            f = -sn * e[j - 1];\n                            e[j - 1] = cs * e[j - 1];\n                        }\n\n                        for (int i = 0; i < n; i++) {\n                            t = cs * V[i][j] + sn * V[i][p - 1];\n                            V[i][p - 1] = -sn * V[i][j] + cs * V[i][p - 1];\n                            V[i][j] = t;\n                        }\n                    }\n                }\n                break;\n                // Split at negligible s(k).\n                case 2: {\n                    double f = e[k - 1];\n                    e[k - 1] = 0;\n                    for (int j = k; j < p; j++) {\n                        double t = FastMath.hypot(singularValues[j], f);\n                        final double cs = singularValues[j] / t;\n                        final double sn = f / t;\n                        singularValues[j] = t;\n                        f = -sn * e[j];\n                        e[j] = cs * e[j];\n\n                        for (int i = 0; i < m; i++) {\n                            t = cs * U[i][j] + sn * U[i][k - 1];\n                            U[i][k - 1] = -sn * U[i][j] + cs * U[i][k - 1];\n                            U[i][j] = t;\n                        }\n                    }\n                }\n                break;\n                // Perform one qr step.\n                case 3: {\n                    // Calculate the shift.\n                    final double maxPm1Pm2 = FastMath.max(FastMath.abs(singularValues[p - 1]),\n                                                          FastMath.abs(singularValues[p - 2]));\n                    final double scale = FastMath.max(FastMath.max(FastMath.max(maxPm1Pm2,\n                                                                                FastMath.abs(e[p - 2])),\n                                                                   FastMath.abs(singularValues[k])),\n                                                      FastMath.abs(e[k]));\n                    final double sp = singularValues[p - 1] / scale;\n                    final double spm1 = singularValues[p - 2] / scale;\n                    final double epm1 = e[p - 2] / scale;\n                    final double sk = singularValues[k] / scale;\n                    final double ek = e[k] / scale;\n                    final double b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2.0;\n                    final double c = (sp * epm1) * (sp * epm1);\n                    double shift = 0;\n                    if (b != 0 ||\n                        c != 0) {\n                        shift = FastMath.sqrt(b * b + c);\n                        if (b < 0) {\n                            shift = -shift;\n                        }\n                        shift = c / (b + shift);\n                    }\n                    double f = (sk + sp) * (sk - sp) + shift;\n                    double g = sk * ek;\n                    // Chase zeros.\n                    for (int j = k; j < p - 1; j++) {\n                        double t = FastMath.hypot(f, g);\n                        double cs = f / t;\n                        double sn = g / t;\n                        if (j != k) {\n                            e[j - 1] = t;\n                        }\n                        f = cs * singularValues[j] + sn * e[j];\n                        e[j] = cs * e[j] - sn * singularValues[j];\n                        g = sn * singularValues[j + 1];\n                        singularValues[j + 1] = cs * singularValues[j + 1];\n\n                        for (int i = 0; i < n; i++) {\n                            t = cs * V[i][j] + sn * V[i][j + 1];\n                            V[i][j + 1] = -sn * V[i][j] + cs * V[i][j + 1];\n                            V[i][j] = t;\n                        }\n                        t = FastMath.hypot(f, g);\n                        cs = f / t;\n                        sn = g / t;\n                        singularValues[j] = t;\n                        f = cs * e[j] + sn * singularValues[j + 1];\n                        singularValues[j + 1] = -sn * e[j] + cs * singularValues[j + 1];\n                        g = sn * e[j + 1];\n                        e[j + 1] = cs * e[j + 1];\n                        if (j < m - 1) {\n                            for (int i = 0; i < m; i++) {\n                                t = cs * U[i][j] + sn * U[i][j + 1];\n                                U[i][j + 1] = -sn * U[i][j] + cs * U[i][j + 1];\n                                U[i][j] = t;\n                            }\n                        }\n                    }\n                    e[p - 2] = f;\n                    iter = iter + 1;\n                }\n                break;\n                // Convergence.\n                default: {\n                    // Make the singular values positive.\n                    if (singularValues[k] <= 0) {\n                        singularValues[k] = singularValues[k] < 0 ? -singularValues[k] : 0;\n\n                        for (int i = 0; i <= pp; i++) {\n                            V[i][k] = -V[i][k];\n                        }\n                    }\n                    // Order the singular values.\n                    while (k < pp) {\n                        if (singularValues[k] >= singularValues[k + 1]) {\n                            break;\n                        }\n                        double t = singularValues[k];\n                        singularValues[k] = singularValues[k + 1];\n                        singularValues[k + 1] = t;\n                        if (k < n - 1) {\n                            for (int i = 0; i < n; i++) {\n                                t = V[i][k + 1];\n                                V[i][k + 1] = V[i][k];\n                                V[i][k] = t;\n                            }\n                        }\n                        if (k < m - 1) {\n                            for (int i = 0; i < m; i++) {\n                                t = U[i][k + 1];\n                                U[i][k + 1] = U[i][k];\n                                U[i][k] = t;\n                            }\n                        }\n                        k++;\n                    }\n                    iter = 0;\n                    p--;\n                }\n                break;\n            }\n        }\n\n        // Set the small value tolerance used to calculate rank and pseudo-inverse\n        tol = FastMath.max(m * singularValues[0] * EPS,\n                           FastMath.sqrt(Precision.SAFE_MIN));\n\n        if (!transposed) {\n            cachedU = MatrixUtils.createRealMatrix(U);\n            cachedV = MatrixUtils.createRealMatrix(V);\n        } else {\n            cachedU = MatrixUtils.createRealMatrix(V);\n            cachedV = MatrixUtils.createRealMatrix(U);\n        }\n    }",
          "21": "    public SingularValueDecomposition(final RealMatrix matrix) {\n        final double[][] A;\n\n         // \"m\" is always the largest dimension.\n        if (matrix.getRowDimension() < matrix.getColumnDimension()) {\n            transposed = true;\n            A = matrix.transpose().getData();\n            m = matrix.getColumnDimension();\n            n = matrix.getRowDimension();\n        } else {\n            transposed = false;\n            A = matrix.getData();\n            m = matrix.getRowDimension();\n            n = matrix.getColumnDimension();\n        }\n\n        singularValues = new double[n];\n        final double[][] U = new double[m][n];\n        final double[][] V = new double[n][n];\n        final double[] e = new double[n];\n        final double[] work = new double[m];\n        // Reduce A to bidiagonal form, storing the diagonal elements\n        // in s and the super-diagonal elements in e.\n        final int nct = FastMath.min(m - 1, n);\n        final int nrt = FastMath.max(0, n - 2);\n        for (int k = 0; k < FastMath.max(nct, nrt); k++) {\n            if (k < nct) {\n                // Compute the transformation for the k-th column and\n                // place the k-th diagonal in s[k].\n                // Compute 2-norm of k-th column without under/overflow.\n                singularValues[k] = 0;\n                for (int i = k; i < m; i++) {\n                    singularValues[k] = FastMath.hypot(singularValues[k], A[i][k]);\n                }\n                if (singularValues[k] != 0) {\n                    if (A[k][k] < 0) {\nsingularValues[k] = -singularValues[k];\n                        singularValues[k] = +singularValues[k];                    }\n                    for (int i = k; i < m; i++) {\n                        A[i][k] /= singularValues[k];\n                    }\n                    A[k][k] += 1;\n                }\n                singularValues[k] = -singularValues[k];\n            }\n            for (int j = k + 1; j < n; j++) {\n                if (k < nct &&\n                    singularValues[k] != 0) {\n                    // Apply the transformation.\n                    double t = 0;\n                    for (int i = k; i < m; i++) {\n                        t += A[i][k] * A[i][j];\n                    }\n                    t = -t / A[k][k];\n                    for (int i = k; i < m; i++) {\n                        A[i][j] += t * A[i][k];\n                    }\n                }\n                // Place the k-th row of A into e for the\n                // subsequent calculation of the row transformation.\n                e[j] = A[k][j];\n            }\n            if (k < nct) {\n                // Place the transformation in U for subsequent back\n                // multiplication.\n                for (int i = k; i < m; i++) {\n                    U[i][k] = A[i][k];\n                }\n            }\n            if (k < nrt) {\n                // Compute the k-th row transformation and place the\n                // k-th super-diagonal in e[k].\n                // Compute 2-norm without under/overflow.\n                e[k] = 0;\n                for (int i = k + 1; i < n; i++) {\n                    e[k] = FastMath.hypot(e[k], e[i]);\n                }\n                if (e[k] != 0) {\n                    if (e[k + 1] < 0) {\n                        e[k] = -e[k];\n                    }\n                    for (int i = k + 1; i < n; i++) {\n                        e[i] /= e[k];\n                    }\n                    e[k + 1] += 1;\n                }\n                e[k] = -e[k];\n                if (k + 1 < m &&\n                    e[k] != 0) {\n                    // Apply the transformation.\n                    for (int i = k + 1; i < m; i++) {\n                        work[i] = 0;\n                    }\n                    for (int j = k + 1; j < n; j++) {\n                        for (int i = k + 1; i < m; i++) {\n                            work[i] += e[j] * A[i][j];\n                        }\n                    }\n                    for (int j = k + 1; j < n; j++) {\n                        final double t = -e[j] / e[k + 1];\n                        for (int i = k + 1; i < m; i++) {\n                            A[i][j] += t * work[i];\n                        }\n                    }\n                }\n\n                // Place the transformation in V for subsequent\n                // back multiplication.\n                for (int i = k + 1; i < n; i++) {\n                    V[i][k] = e[i];\n                }\n            }\n        }\n        // Set up the final bidiagonal matrix or order p.\n        int p = n;\n        if (nct < n) {\n            singularValues[nct] = A[nct][nct];\n        }\n        if (m < p) {\n            singularValues[p - 1] = 0;\n        }\n        if (nrt + 1 < p) {\n            e[nrt] = A[nrt][p - 1];\n        }\n        e[p - 1] = 0;\n\n        // Generate U.\n        for (int j = nct; j < n; j++) {\n            for (int i = 0; i < m; i++) {\n                U[i][j] = 0;\n            }\n            U[j][j] = 1;\n        }\n        for (int k = nct - 1; k >= 0; k--) {\n            if (singularValues[k] != 0) {\n                for (int j = k + 1; j < n; j++) {\n                    double t = 0;\n                    for (int i = k; i < m; i++) {\n                        t += U[i][k] * U[i][j];\n                    }\n                    t = -t / U[k][k];\n                    for (int i = k; i < m; i++) {\n                        U[i][j] += t * U[i][k];\n                    }\n                }\n                for (int i = k; i < m; i++) {\n                    U[i][k] = -U[i][k];\n                }\n                U[k][k] = 1 + U[k][k];\n                for (int i = 0; i < k - 1; i++) {\n                    U[i][k] = 0;\n                }\n            } else {\n                for (int i = 0; i < m; i++) {\n                    U[i][k] = 0;\n                }\n                U[k][k] = 1;\n            }\n        }\n\n        // Generate V.\n        for (int k = n - 1; k >= 0; k--) {\n            if (k < nrt &&\n                e[k] != 0) {\n                for (int j = k + 1; j < n; j++) {\n                    double t = 0;\n                    for (int i = k + 1; i < n; i++) {\n                        t += V[i][k] * V[i][j];\n                    }\n                    t = -t / V[k + 1][k];\n                    for (int i = k + 1; i < n; i++) {\n                        V[i][j] += t * V[i][k];\n                    }\n                }\n            }\n            for (int i = 0; i < n; i++) {\n                V[i][k] = 0;\n            }\n            V[k][k] = 1;\n        }\n\n        // Main iteration loop for the singular values.\n        final int pp = p - 1;\n        int iter = 0;\n        while (p > 0) {\n            int k;\n            int kase;\n            // Here is where a test for too many iterations would go.\n            // This section of the program inspects for\n            // negligible elements in the s and e arrays.  On\n            // completion the variables kase and k are set as follows.\n            // kase = 1     if s(p) and e[k-1] are negligible and k<p\n            // kase = 2     if s(k) is negligible and k<p\n            // kase = 3     if e[k-1] is negligible, k<p, and\n            //              s(k), ..., s(p) are not negligible (qr step).\n            // kase = 4     if e(p-1) is negligible (convergence).\n            for (k = p - 2; k >= 0; k--) {\n                final double threshold\n                    = TINY + EPS * (FastMath.abs(singularValues[k]) +\n                                    FastMath.abs(singularValues[k + 1]));\n\n                // the following condition is written this way in order\n                // to break out of the loop when NaN occurs, writing it\n                // as \"if (FastMath.abs(e[k]) <= threshold)\" would loop\n                // indefinitely in case of NaNs because comparison on NaNs\n                // always return false, regardless of what is checked\n                // see issue MATH-947\n                if (!(FastMath.abs(e[k]) > threshold)) {\n                    e[k] = 0;\n                    break;\n                }\n\n            }\n\n            if (k == p - 2) {\n                kase = 4;\n            } else {\n                int ks;\n                for (ks = p - 1; ks >= k; ks--) {\n                    if (ks == k) {\n                        break;\n                    }\n                    final double t = (ks != p ? FastMath.abs(e[ks]) : 0) +\n                        (ks != k + 1 ? FastMath.abs(e[ks - 1]) : 0);\n                    if (FastMath.abs(singularValues[ks]) <= TINY + EPS * t) {\n                        singularValues[ks] = 0;\n                        break;\n                    }\n                }\n                if (ks == k) {\n                    kase = 3;\n                } else if (ks == p - 1) {\n                    kase = 1;\n                } else {\n                    kase = 2;\n                    k = ks;\n                }\n            }\n            k++;\n            // Perform the task indicated by kase.\n            switch (kase) {\n                // Deflate negligible s(p).\n                case 1: {\n                    double f = e[p - 2];\n                    e[p - 2] = 0;\n                    for (int j = p - 2; j >= k; j--) {\n                        double t = FastMath.hypot(singularValues[j], f);\n                        final double cs = singularValues[j] / t;\n                        final double sn = f / t;\n                        singularValues[j] = t;\n                        if (j != k) {\n                            f = -sn * e[j - 1];\n                            e[j - 1] = cs * e[j - 1];\n                        }\n\n                        for (int i = 0; i < n; i++) {\n                            t = cs * V[i][j] + sn * V[i][p - 1];\n                            V[i][p - 1] = -sn * V[i][j] + cs * V[i][p - 1];\n                            V[i][j] = t;\n                        }\n                    }\n                }\n                break;\n                // Split at negligible s(k).\n                case 2: {\n                    double f = e[k - 1];\n                    e[k - 1] = 0;\n                    for (int j = k; j < p; j++) {\n                        double t = FastMath.hypot(singularValues[j], f);\n                        final double cs = singularValues[j] / t;\n                        final double sn = f / t;\n                        singularValues[j] = t;\n                        f = -sn * e[j];\n                        e[j] = cs * e[j];\n\n                        for (int i = 0; i < m; i++) {\n                            t = cs * U[i][j] + sn * U[i][k - 1];\n                            U[i][k - 1] = -sn * U[i][j] + cs * U[i][k - 1];\n                            U[i][j] = t;\n                        }\n                    }\n                }\n                break;\n                // Perform one qr step.\n                case 3: {\n                    // Calculate the shift.\n                    final double maxPm1Pm2 = FastMath.max(FastMath.abs(singularValues[p - 1]),\n                                                          FastMath.abs(singularValues[p - 2]));\n                    final double scale = FastMath.max(FastMath.max(FastMath.max(maxPm1Pm2,\n                                                                                FastMath.abs(e[p - 2])),\n                                                                   FastMath.abs(singularValues[k])),\n                                                      FastMath.abs(e[k]));\n                    final double sp = singularValues[p - 1] / scale;\n                    final double spm1 = singularValues[p - 2] / scale;\n                    final double epm1 = e[p - 2] / scale;\n                    final double sk = singularValues[k] / scale;\n                    final double ek = e[k] / scale;\n                    final double b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2.0;\n                    final double c = (sp * epm1) * (sp * epm1);\n                    double shift = 0;\n                    if (b != 0 ||\n                        c != 0) {\n                        shift = FastMath.sqrt(b * b + c);\n                        if (b < 0) {\n                            shift = -shift;\n                        }\n                        shift = c / (b + shift);\n                    }\n                    double f = (sk + sp) * (sk - sp) + shift;\n                    double g = sk * ek;\n                    // Chase zeros.\n                    for (int j = k; j < p - 1; j++) {\n                        double t = FastMath.hypot(f, g);\n                        double cs = f / t;\n                        double sn = g / t;\n                        if (j != k) {\n                            e[j - 1] = t;\n                        }\n                        f = cs * singularValues[j] + sn * e[j];\n                        e[j] = cs * e[j] - sn * singularValues[j];\n                        g = sn * singularValues[j + 1];\n                        singularValues[j + 1] = cs * singularValues[j + 1];\n\n                        for (int i = 0; i < n; i++) {\n                            t = cs * V[i][j] + sn * V[i][j + 1];\n                            V[i][j + 1] = -sn * V[i][j] + cs * V[i][j + 1];\n                            V[i][j] = t;\n                        }\n                        t = FastMath.hypot(f, g);\n                        cs = f / t;\n                        sn = g / t;\n                        singularValues[j] = t;\n                        f = cs * e[j] + sn * singularValues[j + 1];\n                        singularValues[j + 1] = -sn * e[j] + cs * singularValues[j + 1];\n                        g = sn * e[j + 1];\n                        e[j + 1] = cs * e[j + 1];\n                        if (j < m - 1) {\n                            for (int i = 0; i < m; i++) {\n                                t = cs * U[i][j] + sn * U[i][j + 1];\n                                U[i][j + 1] = -sn * U[i][j] + cs * U[i][j + 1];\n                                U[i][j] = t;\n                            }\n                        }\n                    }\n                    e[p - 2] = f;\n                    iter = iter + 1;\n                }\n                break;\n                // Convergence.\n                default: {\n                    // Make the singular values positive.\n                    if (singularValues[k] <= 0) {\n                        singularValues[k] = singularValues[k] < 0 ? -singularValues[k] : 0;\n\n                        for (int i = 0; i <= pp; i++) {\n                            V[i][k] = -V[i][k];\n                        }\n                    }\n                    // Order the singular values.\n                    while (k < pp) {\n                        if (singularValues[k] >= singularValues[k + 1]) {\n                            break;\n                        }\n                        double t = singularValues[k];\n                        singularValues[k] = singularValues[k + 1];\n                        singularValues[k + 1] = t;\n                        if (k < n - 1) {\n                            for (int i = 0; i < n; i++) {\n                                t = V[i][k + 1];\n                                V[i][k + 1] = V[i][k];\n                                V[i][k] = t;\n                            }\n                        }\n                        if (k < m - 1) {\n                            for (int i = 0; i < m; i++) {\n                                t = U[i][k + 1];\n                                U[i][k + 1] = U[i][k];\n                                U[i][k] = t;\n                            }\n                        }\n                        k++;\n                    }\n                    iter = 0;\n                    p--;\n                }\n                break;\n            }\n        }\n\n        // Set the small value tolerance used to calculate rank and pseudo-inverse\n        tol = FastMath.max(m * singularValues[0] * EPS,\n                           FastMath.sqrt(Precision.SAFE_MIN));\n\n        if (!transposed) {\n            cachedU = MatrixUtils.createRealMatrix(U);\n            cachedV = MatrixUtils.createRealMatrix(V);\n        } else {\n            cachedU = MatrixUtils.createRealMatrix(V);\n            cachedV = MatrixUtils.createRealMatrix(U);\n        }\n    }",
          "22": "    public SingularValueDecomposition(final RealMatrix matrix) {\n        final double[][] A;\n\n         // \"m\" is always the largest dimension.\n        if (matrix.getRowDimension() < matrix.getColumnDimension()) {\n            transposed = true;\n            A = matrix.transpose().getData();\n            m = matrix.getColumnDimension();\n            n = matrix.getRowDimension();\n        } else {\n            transposed = false;\n            A = matrix.getData();\n            m = matrix.getRowDimension();\n            n = matrix.getColumnDimension();\n        }\n\n        singularValues = new double[n];\n        final double[][] U = new double[m][n];\n        final double[][] V = new double[n][n];\n        final double[] e = new double[n];\n        final double[] work = new double[m];\n        // Reduce A to bidiagonal form, storing the diagonal elements\n        // in s and the super-diagonal elements in e.\n        final int nct = FastMath.min(m - 1, n);\n        final int nrt = FastMath.max(0, n - 2);\n        for (int k = 0; k < FastMath.max(nct, nrt); k++) {\n            if (k < nct) {\n                // Compute the transformation for the k-th column and\n                // place the k-th diagonal in s[k].\n                // Compute 2-norm of k-th column without under/overflow.\n                singularValues[k] = 0;\n                for (int i = k; i < m; i++) {\n                    singularValues[k] = FastMath.hypot(singularValues[k], A[i][k]);\n                }\n                if (singularValues[k] != 0) {\n                    if (A[k][k] < 0) {\nsingularValues[k] = EPS;\n                    }\n                    for (int i = k; i < m; i++) {\n                        A[i][k] /= singularValues[k];\n                    }\n                    A[k][k] += 1;\n                }\n                singularValues[k] = -singularValues[k];\n            }\n            for (int j = k + 1; j < n; j++) {\n                if (k < nct &&\n                    singularValues[k] != 0) {\n                    // Apply the transformation.\n                    double t = 0;\n                    for (int i = k; i < m; i++) {\n                        t += A[i][k] * A[i][j];\n                    }\n                    t = -t / A[k][k];\n                    for (int i = k; i < m; i++) {\n                        A[i][j] += t * A[i][k];\n                    }\n                }\n                // Place the k-th row of A into e for the\n                // subsequent calculation of the row transformation.\n                e[j] = A[k][j];\n            }\n            if (k < nct) {\n                // Place the transformation in U for subsequent back\n                // multiplication.\n                for (int i = k; i < m; i++) {\n                    U[i][k] = A[i][k];\n                }\n            }\n            if (k < nrt) {\n                // Compute the k-th row transformation and place the\n                // k-th super-diagonal in e[k].\n                // Compute 2-norm without under/overflow.\n                e[k] = 0;\n                for (int i = k + 1; i < n; i++) {\n                    e[k] = FastMath.hypot(e[k], e[i]);\n                }\n                if (e[k] != 0) {\n                    if (e[k + 1] < 0) {\n                        e[k] = -e[k];\n                    }\n                    for (int i = k + 1; i < n; i++) {\n                        e[i] /= e[k];\n                    }\n                    e[k + 1] += 1;\n                }\n                e[k] = -e[k];\n                if (k + 1 < m &&\n                    e[k] != 0) {\n                    // Apply the transformation.\n                    for (int i = k + 1; i < m; i++) {\n                        work[i] = 0;\n                    }\n                    for (int j = k + 1; j < n; j++) {\n                        for (int i = k + 1; i < m; i++) {\n                            work[i] += e[j] * A[i][j];\n                        }\n                    }\n                    for (int j = k + 1; j < n; j++) {\n                        final double t = -e[j] / e[k + 1];\n                        for (int i = k + 1; i < m; i++) {\n                            A[i][j] += t * work[i];\n                        }\n                    }\n                }\n\n                // Place the transformation in V for subsequent\n                // back multiplication.\n                for (int i = k + 1; i < n; i++) {\n                    V[i][k] = e[i];\n                }\n            }\n        }\n        // Set up the final bidiagonal matrix or order p.\n        int p = n;\n        if (nct < n) {\n            singularValues[nct] = A[nct][nct];\n        }\n        if (m < p) {\n            singularValues[p - 1] = 0;\n        }\n        if (nrt + 1 < p) {\n            e[nrt] = A[nrt][p - 1];\n        }\n        e[p - 1] = 0;\n\n        // Generate U.\n        for (int j = nct; j < n; j++) {\n            for (int i = 0; i < m; i++) {\n                U[i][j] = 0;\n            }\n            U[j][j] = 1;\n        }\n        for (int k = nct - 1; k >= 0; k--) {\n            if (singularValues[k] != 0) {\n                for (int j = k + 1; j < n; j++) {\n                    double t = 0;\n                    for (int i = k; i < m; i++) {\n                        t += U[i][k] * U[i][j];\n                    }\n                    t = -t / U[k][k];\n                    for (int i = k; i < m; i++) {\n                        U[i][j] += t * U[i][k];\n                    }\n                }\n                for (int i = k; i < m; i++) {\n                    U[i][k] = -U[i][k];\n                }\n                U[k][k] = 1 + U[k][k];\n                for (int i = 0; i < k - 1; i++) {\n                    U[i][k] = 0;\n                }\n            } else {\n                for (int i = 0; i < m; i++) {\n                    U[i][k] = 0;\n                }\n                U[k][k] = 1;\n            }\n        }\n\n        // Generate V.\n        for (int k = n - 1; k >= 0; k--) {\n            if (k < nrt &&\n                e[k] != 0) {\n                for (int j = k + 1; j < n; j++) {\n                    double t = 0;\n                    for (int i = k + 1; i < n; i++) {\n                        t += V[i][k] * V[i][j];\n                    }\n                    t = -t / V[k + 1][k];\n                    for (int i = k + 1; i < n; i++) {\n                        V[i][j] += t * V[i][k];\n                    }\n                }\n            }\n            for (int i = 0; i < n; i++) {\n                V[i][k] = 0;\n            }\n            V[k][k] = 1;\n        }\n\n        // Main iteration loop for the singular values.\n        final int pp = p - 1;\n        int iter = 0;\n        while (p > 0) {\n            int k;\n            int kase;\n            // Here is where a test for too many iterations would go.\n            // This section of the program inspects for\n            // negligible elements in the s and e arrays.  On\n            // completion the variables kase and k are set as follows.\n            // kase = 1     if s(p) and e[k-1] are negligible and k<p\n            // kase = 2     if s(k) is negligible and k<p\n            // kase = 3     if e[k-1] is negligible, k<p, and\n            //              s(k), ..., s(p) are not negligible (qr step).\n            // kase = 4     if e(p-1) is negligible (convergence).\n            for (k = p - 2; k >= 0; k--) {\n                final double threshold\n                    = TINY + EPS * (FastMath.abs(singularValues[k]) +\n                                    FastMath.abs(singularValues[k + 1]));\n\n                // the following condition is written this way in order\n                // to break out of the loop when NaN occurs, writing it\n                // as \"if (FastMath.abs(e[k]) <= threshold)\" would loop\n                // indefinitely in case of NaNs because comparison on NaNs\n                // always return false, regardless of what is checked\n                // see issue MATH-947\n                if (!(FastMath.abs(e[k]) > threshold)) {\n                    e[k] = 0;\n                    break;\n                }\n\n            }\n\n            if (k == p - 2) {\n                kase = 4;\n            } else {\n                int ks;\n                for (ks = p - 1; ks >= k; ks--) {\n                    if (ks == k) {\n                        break;\n                    }\n                    final double t = (ks != p ? FastMath.abs(e[ks]) : 0) +\n                        (ks != k + 1 ? FastMath.abs(e[ks - 1]) : 0);\n                    if (FastMath.abs(singularValues[ks]) <= TINY + EPS * t) {\n                        singularValues[ks] = 0;\n                        break;\n                    }\n                }\n                if (ks == k) {\n                    kase = 3;\n                } else if (ks == p - 1) {\n                    kase = 1;\n                } else {\n                    kase = 2;\n                    k = ks;\n                }\n            }\n            k++;\n            // Perform the task indicated by kase.\n            switch (kase) {\n                // Deflate negligible s(p).\n                case 1: {\n                    double f = e[p - 2];\n                    e[p - 2] = 0;\n                    for (int j = p - 2; j >= k; j--) {\n                        double t = FastMath.hypot(singularValues[j], f);\n                        final double cs = singularValues[j] / t;\n                        final double sn = f / t;\n                        singularValues[j] = t;\n                        if (j != k) {\n                            f = -sn * e[j - 1];\n                            e[j - 1] = cs * e[j - 1];\n                        }\n\n                        for (int i = 0; i < n; i++) {\n                            t = cs * V[i][j] + sn * V[i][p - 1];\n                            V[i][p - 1] = -sn * V[i][j] + cs * V[i][p - 1];\n                            V[i][j] = t;\n                        }\n                    }\n                }\n                break;\n                // Split at negligible s(k).\n                case 2: {\n                    double f = e[k - 1];\n                    e[k - 1] = 0;\n                    for (int j = k; j < p; j++) {\n                        double t = FastMath.hypot(singularValues[j], f);\n                        final double cs = singularValues[j] / t;\n                        final double sn = f / t;\n                        singularValues[j] = t;\n                        f = -sn * e[j];\n                        e[j] = cs * e[j];\n\n                        for (int i = 0; i < m; i++) {\n                            t = cs * U[i][j] + sn * U[i][k - 1];\n                            U[i][k - 1] = -sn * U[i][j] + cs * U[i][k - 1];\n                            U[i][j] = t;\n                        }\n                    }\n                }\n                break;\n                // Perform one qr step.\n                case 3: {\n                    // Calculate the shift.\n                    final double maxPm1Pm2 = FastMath.max(FastMath.abs(singularValues[p - 1]),\n                                                          FastMath.abs(singularValues[p - 2]));\n                    final double scale = FastMath.max(FastMath.max(FastMath.max(maxPm1Pm2,\n                                                                                FastMath.abs(e[p - 2])),\n                                                                   FastMath.abs(singularValues[k])),\n                                                      FastMath.abs(e[k]));\n                    final double sp = singularValues[p - 1] / scale;\n                    final double spm1 = singularValues[p - 2] / scale;\n                    final double epm1 = e[p - 2] / scale;\n                    final double sk = singularValues[k] / scale;\n                    final double ek = e[k] / scale;\n                    final double b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2.0;\n                    final double c = (sp * epm1) * (sp * epm1);\n                    double shift = 0;\n                    if (b != 0 ||\n                        c != 0) {\n                        shift = FastMath.sqrt(b * b + c);\n                        if (b < 0) {\n                            shift = -shift;\n                        }\n                        shift = c / (b + shift);\n                    }\n                    double f = (sk + sp) * (sk - sp) + shift;\n                    double g = sk * ek;\n                    // Chase zeros.\n                    for (int j = k; j < p - 1; j++) {\n                        double t = FastMath.hypot(f, g);\n                        double cs = f / t;\n                        double sn = g / t;\n                        if (j != k) {\n                            e[j - 1] = t;\n                        }\n                        f = cs * singularValues[j] + sn * e[j];\n                        e[j] = cs * e[j] - sn * singularValues[j];\n                        g = sn * singularValues[j + 1];\n                        singularValues[j + 1] = cs * singularValues[j + 1];\n\n                        for (int i = 0; i < n; i++) {\n                            t = cs * V[i][j] + sn * V[i][j + 1];\n                            V[i][j + 1] = -sn * V[i][j] + cs * V[i][j + 1];\n                            V[i][j] = t;\n                        }\n                        t = FastMath.hypot(f, g);\n                        cs = f / t;\n                        sn = g / t;\n                        singularValues[j] = t;\n                        f = cs * e[j] + sn * singularValues[j + 1];\n                        singularValues[j + 1] = -sn * e[j] + cs * singularValues[j + 1];\n                        g = sn * e[j + 1];\n                        e[j + 1] = cs * e[j + 1];\n                        if (j < m - 1) {\n                            for (int i = 0; i < m; i++) {\n                                t = cs * U[i][j] + sn * U[i][j + 1];\n                                U[i][j + 1] = -sn * U[i][j] + cs * U[i][j + 1];\n                                U[i][j] = t;\n                            }\n                        }\n                    }\n                    e[p - 2] = f;\n                    iter = iter + 1;\n                }\n                break;\n                // Convergence.\n                default: {\n                    // Make the singular values positive.\n                    if (singularValues[k] <= 0) {\n                        singularValues[k] = singularValues[k] < 0 ? -singularValues[k] : 0;\n\n                        for (int i = 0; i <= pp; i++) {\n                            V[i][k] = -V[i][k];\n                        }\n                    }\n                    // Order the singular values.\n                    while (k < pp) {\n                        if (singularValues[k] >= singularValues[k + 1]) {\n                            break;\n                        }\n                        double t = singularValues[k];\n                        singularValues[k] = singularValues[k + 1];\n                        singularValues[k + 1] = t;\n                        if (k < n - 1) {\n                            for (int i = 0; i < n; i++) {\n                                t = V[i][k + 1];\n                                V[i][k + 1] = V[i][k];\n                                V[i][k] = t;\n                            }\n                        }\n                        if (k < m - 1) {\n                            for (int i = 0; i < m; i++) {\n                                t = U[i][k + 1];\n                                U[i][k + 1] = U[i][k];\n                                U[i][k] = t;\n                            }\n                        }\n                        k++;\n                    }\n                    iter = 0;\n                    p--;\n                }\n                break;\n            }\n        }\n\n        // Set the small value tolerance used to calculate rank and pseudo-inverse\n        tol = FastMath.max(m * singularValues[0] * EPS,\n                           FastMath.sqrt(Precision.SAFE_MIN));\n\n        if (!transposed) {\n            cachedU = MatrixUtils.createRealMatrix(U);\n            cachedV = MatrixUtils.createRealMatrix(V);\n        } else {\n            cachedU = MatrixUtils.createRealMatrix(V);\n            cachedV = MatrixUtils.createRealMatrix(U);\n        }\n    }",
          "23": "    public SingularValueDecomposition(final RealMatrix matrix) {\n        final double[][] A;\n\n         // \"m\" is always the largest dimension.\n        if (matrix.getRowDimension() < matrix.getColumnDimension()) {\n            transposed = true;\n            A = matrix.transpose().getData();\n            m = matrix.getColumnDimension();\n            n = matrix.getRowDimension();\n        } else {\n            transposed = false;\n            A = matrix.getData();\n            m = matrix.getRowDimension();\n            n = matrix.getColumnDimension();\n        }\n\n        singularValues = new double[n];\n        final double[][] U = new double[m][n];\n        final double[][] V = new double[n][n];\n        final double[] e = new double[n];\n        final double[] work = new double[m];\n        // Reduce A to bidiagonal form, storing the diagonal elements\n        // in s and the super-diagonal elements in e.\n        final int nct = FastMath.min(m - 1, n);\n        final int nrt = FastMath.max(0, n - 2);\n        for (int k = 0; k < FastMath.max(nct, nrt); k++) {\n            if (k < nct) {\n                // Compute the transformation for the k-th column and\n                // place the k-th diagonal in s[k].\n                // Compute 2-norm of k-th column without under/overflow.\n                singularValues[k] = 0;\n                for (int i = k; i < m; i++) {\n                    singularValues[k] = FastMath.hypot(singularValues[k], A[i][k]);\n                }\n                if (singularValues[k] != 0) {\n                    if (A[k][k] < 0) {\nsingularValues[k] = TINY;\n                    }\n                    for (int i = k; i < m; i++) {\n                        A[i][k] /= singularValues[k];\n                    }\n                    A[k][k] += 1;\n                }\n                singularValues[k] = -singularValues[k];\n            }\n            for (int j = k + 1; j < n; j++) {\n                if (k < nct &&\n                    singularValues[k] != 0) {\n                    // Apply the transformation.\n                    double t = 0;\n                    for (int i = k; i < m; i++) {\n                        t += A[i][k] * A[i][j];\n                    }\n                    t = -t / A[k][k];\n                    for (int i = k; i < m; i++) {\n                        A[i][j] += t * A[i][k];\n                    }\n                }\n                // Place the k-th row of A into e for the\n                // subsequent calculation of the row transformation.\n                e[j] = A[k][j];\n            }\n            if (k < nct) {\n                // Place the transformation in U for subsequent back\n                // multiplication.\n                for (int i = k; i < m; i++) {\n                    U[i][k] = A[i][k];\n                }\n            }\n            if (k < nrt) {\n                // Compute the k-th row transformation and place the\n                // k-th super-diagonal in e[k].\n                // Compute 2-norm without under/overflow.\n                e[k] = 0;\n                for (int i = k + 1; i < n; i++) {\n                    e[k] = FastMath.hypot(e[k], e[i]);\n                }\n                if (e[k] != 0) {\n                    if (e[k + 1] < 0) {\n                        e[k] = -e[k];\n                    }\n                    for (int i = k + 1; i < n; i++) {\n                        e[i] /= e[k];\n                    }\n                    e[k + 1] += 1;\n                }\n                e[k] = -e[k];\n                if (k + 1 < m &&\n                    e[k] != 0) {\n                    // Apply the transformation.\n                    for (int i = k + 1; i < m; i++) {\n                        work[i] = 0;\n                    }\n                    for (int j = k + 1; j < n; j++) {\n                        for (int i = k + 1; i < m; i++) {\n                            work[i] += e[j] * A[i][j];\n                        }\n                    }\n                    for (int j = k + 1; j < n; j++) {\n                        final double t = -e[j] / e[k + 1];\n                        for (int i = k + 1; i < m; i++) {\n                            A[i][j] += t * work[i];\n                        }\n                    }\n                }\n\n                // Place the transformation in V for subsequent\n                // back multiplication.\n                for (int i = k + 1; i < n; i++) {\n                    V[i][k] = e[i];\n                }\n            }\n        }\n        // Set up the final bidiagonal matrix or order p.\n        int p = n;\n        if (nct < n) {\n            singularValues[nct] = A[nct][nct];\n        }\n        if (m < p) {\n            singularValues[p - 1] = 0;\n        }\n        if (nrt + 1 < p) {\n            e[nrt] = A[nrt][p - 1];\n        }\n        e[p - 1] = 0;\n\n        // Generate U.\n        for (int j = nct; j < n; j++) {\n            for (int i = 0; i < m; i++) {\n                U[i][j] = 0;\n            }\n            U[j][j] = 1;\n        }\n        for (int k = nct - 1; k >= 0; k--) {\n            if (singularValues[k] != 0) {\n                for (int j = k + 1; j < n; j++) {\n                    double t = 0;\n                    for (int i = k; i < m; i++) {\n                        t += U[i][k] * U[i][j];\n                    }\n                    t = -t / U[k][k];\n                    for (int i = k; i < m; i++) {\n                        U[i][j] += t * U[i][k];\n                    }\n                }\n                for (int i = k; i < m; i++) {\n                    U[i][k] = -U[i][k];\n                }\n                U[k][k] = 1 + U[k][k];\n                for (int i = 0; i < k - 1; i++) {\n                    U[i][k] = 0;\n                }\n            } else {\n                for (int i = 0; i < m; i++) {\n                    U[i][k] = 0;\n                }\n                U[k][k] = 1;\n            }\n        }\n\n        // Generate V.\n        for (int k = n - 1; k >= 0; k--) {\n            if (k < nrt &&\n                e[k] != 0) {\n                for (int j = k + 1; j < n; j++) {\n                    double t = 0;\n                    for (int i = k + 1; i < n; i++) {\n                        t += V[i][k] * V[i][j];\n                    }\n                    t = -t / V[k + 1][k];\n                    for (int i = k + 1; i < n; i++) {\n                        V[i][j] += t * V[i][k];\n                    }\n                }\n            }\n            for (int i = 0; i < n; i++) {\n                V[i][k] = 0;\n            }\n            V[k][k] = 1;\n        }\n\n        // Main iteration loop for the singular values.\n        final int pp = p - 1;\n        int iter = 0;\n        while (p > 0) {\n            int k;\n            int kase;\n            // Here is where a test for too many iterations would go.\n            // This section of the program inspects for\n            // negligible elements in the s and e arrays.  On\n            // completion the variables kase and k are set as follows.\n            // kase = 1     if s(p) and e[k-1] are negligible and k<p\n            // kase = 2     if s(k) is negligible and k<p\n            // kase = 3     if e[k-1] is negligible, k<p, and\n            //              s(k), ..., s(p) are not negligible (qr step).\n            // kase = 4     if e(p-1) is negligible (convergence).\n            for (k = p - 2; k >= 0; k--) {\n                final double threshold\n                    = TINY + EPS * (FastMath.abs(singularValues[k]) +\n                                    FastMath.abs(singularValues[k + 1]));\n\n                // the following condition is written this way in order\n                // to break out of the loop when NaN occurs, writing it\n                // as \"if (FastMath.abs(e[k]) <= threshold)\" would loop\n                // indefinitely in case of NaNs because comparison on NaNs\n                // always return false, regardless of what is checked\n                // see issue MATH-947\n                if (!(FastMath.abs(e[k]) > threshold)) {\n                    e[k] = 0;\n                    break;\n                }\n\n            }\n\n            if (k == p - 2) {\n                kase = 4;\n            } else {\n                int ks;\n                for (ks = p - 1; ks >= k; ks--) {\n                    if (ks == k) {\n                        break;\n                    }\n                    final double t = (ks != p ? FastMath.abs(e[ks]) : 0) +\n                        (ks != k + 1 ? FastMath.abs(e[ks - 1]) : 0);\n                    if (FastMath.abs(singularValues[ks]) <= TINY + EPS * t) {\n                        singularValues[ks] = 0;\n                        break;\n                    }\n                }\n                if (ks == k) {\n                    kase = 3;\n                } else if (ks == p - 1) {\n                    kase = 1;\n                } else {\n                    kase = 2;\n                    k = ks;\n                }\n            }\n            k++;\n            // Perform the task indicated by kase.\n            switch (kase) {\n                // Deflate negligible s(p).\n                case 1: {\n                    double f = e[p - 2];\n                    e[p - 2] = 0;\n                    for (int j = p - 2; j >= k; j--) {\n                        double t = FastMath.hypot(singularValues[j], f);\n                        final double cs = singularValues[j] / t;\n                        final double sn = f / t;\n                        singularValues[j] = t;\n                        if (j != k) {\n                            f = -sn * e[j - 1];\n                            e[j - 1] = cs * e[j - 1];\n                        }\n\n                        for (int i = 0; i < n; i++) {\n                            t = cs * V[i][j] + sn * V[i][p - 1];\n                            V[i][p - 1] = -sn * V[i][j] + cs * V[i][p - 1];\n                            V[i][j] = t;\n                        }\n                    }\n                }\n                break;\n                // Split at negligible s(k).\n                case 2: {\n                    double f = e[k - 1];\n                    e[k - 1] = 0;\n                    for (int j = k; j < p; j++) {\n                        double t = FastMath.hypot(singularValues[j], f);\n                        final double cs = singularValues[j] / t;\n                        final double sn = f / t;\n                        singularValues[j] = t;\n                        f = -sn * e[j];\n                        e[j] = cs * e[j];\n\n                        for (int i = 0; i < m; i++) {\n                            t = cs * U[i][j] + sn * U[i][k - 1];\n                            U[i][k - 1] = -sn * U[i][j] + cs * U[i][k - 1];\n                            U[i][j] = t;\n                        }\n                    }\n                }\n                break;\n                // Perform one qr step.\n                case 3: {\n                    // Calculate the shift.\n                    final double maxPm1Pm2 = FastMath.max(FastMath.abs(singularValues[p - 1]),\n                                                          FastMath.abs(singularValues[p - 2]));\n                    final double scale = FastMath.max(FastMath.max(FastMath.max(maxPm1Pm2,\n                                                                                FastMath.abs(e[p - 2])),\n                                                                   FastMath.abs(singularValues[k])),\n                                                      FastMath.abs(e[k]));\n                    final double sp = singularValues[p - 1] / scale;\n                    final double spm1 = singularValues[p - 2] / scale;\n                    final double epm1 = e[p - 2] / scale;\n                    final double sk = singularValues[k] / scale;\n                    final double ek = e[k] / scale;\n                    final double b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2.0;\n                    final double c = (sp * epm1) * (sp * epm1);\n                    double shift = 0;\n                    if (b != 0 ||\n                        c != 0) {\n                        shift = FastMath.sqrt(b * b + c);\n                        if (b < 0) {\n                            shift = -shift;\n                        }\n                        shift = c / (b + shift);\n                    }\n                    double f = (sk + sp) * (sk - sp) + shift;\n                    double g = sk * ek;\n                    // Chase zeros.\n                    for (int j = k; j < p - 1; j++) {\n                        double t = FastMath.hypot(f, g);\n                        double cs = f / t;\n                        double sn = g / t;\n                        if (j != k) {\n                            e[j - 1] = t;\n                        }\n                        f = cs * singularValues[j] + sn * e[j];\n                        e[j] = cs * e[j] - sn * singularValues[j];\n                        g = sn * singularValues[j + 1];\n                        singularValues[j + 1] = cs * singularValues[j + 1];\n\n                        for (int i = 0; i < n; i++) {\n                            t = cs * V[i][j] + sn * V[i][j + 1];\n                            V[i][j + 1] = -sn * V[i][j] + cs * V[i][j + 1];\n                            V[i][j] = t;\n                        }\n                        t = FastMath.hypot(f, g);\n                        cs = f / t;\n                        sn = g / t;\n                        singularValues[j] = t;\n                        f = cs * e[j] + sn * singularValues[j + 1];\n                        singularValues[j + 1] = -sn * e[j] + cs * singularValues[j + 1];\n                        g = sn * e[j + 1];\n                        e[j + 1] = cs * e[j + 1];\n                        if (j < m - 1) {\n                            for (int i = 0; i < m; i++) {\n                                t = cs * U[i][j] + sn * U[i][j + 1];\n                                U[i][j + 1] = -sn * U[i][j] + cs * U[i][j + 1];\n                                U[i][j] = t;\n                            }\n                        }\n                    }\n                    e[p - 2] = f;\n                    iter = iter + 1;\n                }\n                break;\n                // Convergence.\n                default: {\n                    // Make the singular values positive.\n                    if (singularValues[k] <= 0) {\n                        singularValues[k] = singularValues[k] < 0 ? -singularValues[k] : 0;\n\n                        for (int i = 0; i <= pp; i++) {\n                            V[i][k] = -V[i][k];\n                        }\n                    }\n                    // Order the singular values.\n                    while (k < pp) {\n                        if (singularValues[k] >= singularValues[k + 1]) {\n                            break;\n                        }\n                        double t = singularValues[k];\n                        singularValues[k] = singularValues[k + 1];\n                        singularValues[k + 1] = t;\n                        if (k < n - 1) {\n                            for (int i = 0; i < n; i++) {\n                                t = V[i][k + 1];\n                                V[i][k + 1] = V[i][k];\n                                V[i][k] = t;\n                            }\n                        }\n                        if (k < m - 1) {\n                            for (int i = 0; i < m; i++) {\n                                t = U[i][k + 1];\n                                U[i][k + 1] = U[i][k];\n                                U[i][k] = t;\n                            }\n                        }\n                        k++;\n                    }\n                    iter = 0;\n                    p--;\n                }\n                break;\n            }\n        }\n\n        // Set the small value tolerance used to calculate rank and pseudo-inverse\n        tol = FastMath.max(m * singularValues[0] * EPS,\n                           FastMath.sqrt(Precision.SAFE_MIN));\n\n        if (!transposed) {\n            cachedU = MatrixUtils.createRealMatrix(U);\n            cachedV = MatrixUtils.createRealMatrix(V);\n        } else {\n            cachedU = MatrixUtils.createRealMatrix(V);\n            cachedV = MatrixUtils.createRealMatrix(U);\n        }\n    }",
          "24": "    public SingularValueDecomposition(final RealMatrix matrix) {\n        final double[][] A;\n\n         // \"m\" is always the largest dimension.\n        if (matrix.getRowDimension() < matrix.getColumnDimension()) {\n            transposed = true;\n            A = matrix.transpose().getData();\n            m = matrix.getColumnDimension();\n            n = matrix.getRowDimension();\n        } else {\n            transposed = false;\n            A = matrix.getData();\n            m = matrix.getRowDimension();\n            n = matrix.getColumnDimension();\n        }\n\n        singularValues = new double[n];\n        final double[][] U = new double[m][n];\n        final double[][] V = new double[n][n];\n        final double[] e = new double[n];\n        final double[] work = new double[m];\n        // Reduce A to bidiagonal form, storing the diagonal elements\n        // in s and the super-diagonal elements in e.\n        final int nct = FastMath.min(m - 1, n);\n        final int nrt = FastMath.max(0, n - 2);\n        for (int k = 0; k < FastMath.max(nct, nrt); k++) {\n            if (k < nct) {\n                // Compute the transformation for the k-th column and\n                // place the k-th diagonal in s[k].\n                // Compute 2-norm of k-th column without under/overflow.\n                singularValues[k] = 0;\n                for (int i = k; i < m; i++) {\n                    singularValues[k] = FastMath.hypot(singularValues[k], A[i][k]);\n                }\n                if (singularValues[k] != 0) {\n                    if (A[k][k] < 0) {\nsingularValues[k] = singularValues;\n                    }\n                    for (int i = k; i < m; i++) {\n                        A[i][k] /= singularValues[k];\n                    }\n                    A[k][k] += 1;\n                }\n                singularValues[k] = -singularValues[k];\n            }\n            for (int j = k + 1; j < n; j++) {\n                if (k < nct &&\n                    singularValues[k] != 0) {\n                    // Apply the transformation.\n                    double t = 0;\n                    for (int i = k; i < m; i++) {\n                        t += A[i][k] * A[i][j];\n                    }\n                    t = -t / A[k][k];\n                    for (int i = k; i < m; i++) {\n                        A[i][j] += t * A[i][k];\n                    }\n                }\n                // Place the k-th row of A into e for the\n                // subsequent calculation of the row transformation.\n                e[j] = A[k][j];\n            }\n            if (k < nct) {\n                // Place the transformation in U for subsequent back\n                // multiplication.\n                for (int i = k; i < m; i++) {\n                    U[i][k] = A[i][k];\n                }\n            }\n            if (k < nrt) {\n                // Compute the k-th row transformation and place the\n                // k-th super-diagonal in e[k].\n                // Compute 2-norm without under/overflow.\n                e[k] = 0;\n                for (int i = k + 1; i < n; i++) {\n                    e[k] = FastMath.hypot(e[k], e[i]);\n                }\n                if (e[k] != 0) {\n                    if (e[k + 1] < 0) {\n                        e[k] = -e[k];\n                    }\n                    for (int i = k + 1; i < n; i++) {\n                        e[i] /= e[k];\n                    }\n                    e[k + 1] += 1;\n                }\n                e[k] = -e[k];\n                if (k + 1 < m &&\n                    e[k] != 0) {\n                    // Apply the transformation.\n                    for (int i = k + 1; i < m; i++) {\n                        work[i] = 0;\n                    }\n                    for (int j = k + 1; j < n; j++) {\n                        for (int i = k + 1; i < m; i++) {\n                            work[i] += e[j] * A[i][j];\n                        }\n                    }\n                    for (int j = k + 1; j < n; j++) {\n                        final double t = -e[j] / e[k + 1];\n                        for (int i = k + 1; i < m; i++) {\n                            A[i][j] += t * work[i];\n                        }\n                    }\n                }\n\n                // Place the transformation in V for subsequent\n                // back multiplication.\n                for (int i = k + 1; i < n; i++) {\n                    V[i][k] = e[i];\n                }\n            }\n        }\n        // Set up the final bidiagonal matrix or order p.\n        int p = n;\n        if (nct < n) {\n            singularValues[nct] = A[nct][nct];\n        }\n        if (m < p) {\n            singularValues[p - 1] = 0;\n        }\n        if (nrt + 1 < p) {\n            e[nrt] = A[nrt][p - 1];\n        }\n        e[p - 1] = 0;\n\n        // Generate U.\n        for (int j = nct; j < n; j++) {\n            for (int i = 0; i < m; i++) {\n                U[i][j] = 0;\n            }\n            U[j][j] = 1;\n        }\n        for (int k = nct - 1; k >= 0; k--) {\n            if (singularValues[k] != 0) {\n                for (int j = k + 1; j < n; j++) {\n                    double t = 0;\n                    for (int i = k; i < m; i++) {\n                        t += U[i][k] * U[i][j];\n                    }\n                    t = -t / U[k][k];\n                    for (int i = k; i < m; i++) {\n                        U[i][j] += t * U[i][k];\n                    }\n                }\n                for (int i = k; i < m; i++) {\n                    U[i][k] = -U[i][k];\n                }\n                U[k][k] = 1 + U[k][k];\n                for (int i = 0; i < k - 1; i++) {\n                    U[i][k] = 0;\n                }\n            } else {\n                for (int i = 0; i < m; i++) {\n                    U[i][k] = 0;\n                }\n                U[k][k] = 1;\n            }\n        }\n\n        // Generate V.\n        for (int k = n - 1; k >= 0; k--) {\n            if (k < nrt &&\n                e[k] != 0) {\n                for (int j = k + 1; j < n; j++) {\n                    double t = 0;\n                    for (int i = k + 1; i < n; i++) {\n                        t += V[i][k] * V[i][j];\n                    }\n                    t = -t / V[k + 1][k];\n                    for (int i = k + 1; i < n; i++) {\n                        V[i][j] += t * V[i][k];\n                    }\n                }\n            }\n            for (int i = 0; i < n; i++) {\n                V[i][k] = 0;\n            }\n            V[k][k] = 1;\n        }\n\n        // Main iteration loop for the singular values.\n        final int pp = p - 1;\n        int iter = 0;\n        while (p > 0) {\n            int k;\n            int kase;\n            // Here is where a test for too many iterations would go.\n            // This section of the program inspects for\n            // negligible elements in the s and e arrays.  On\n            // completion the variables kase and k are set as follows.\n            // kase = 1     if s(p) and e[k-1] are negligible and k<p\n            // kase = 2     if s(k) is negligible and k<p\n            // kase = 3     if e[k-1] is negligible, k<p, and\n            //              s(k), ..., s(p) are not negligible (qr step).\n            // kase = 4     if e(p-1) is negligible (convergence).\n            for (k = p - 2; k >= 0; k--) {\n                final double threshold\n                    = TINY + EPS * (FastMath.abs(singularValues[k]) +\n                                    FastMath.abs(singularValues[k + 1]));\n\n                // the following condition is written this way in order\n                // to break out of the loop when NaN occurs, writing it\n                // as \"if (FastMath.abs(e[k]) <= threshold)\" would loop\n                // indefinitely in case of NaNs because comparison on NaNs\n                // always return false, regardless of what is checked\n                // see issue MATH-947\n                if (!(FastMath.abs(e[k]) > threshold)) {\n                    e[k] = 0;\n                    break;\n                }\n\n            }\n\n            if (k == p - 2) {\n                kase = 4;\n            } else {\n                int ks;\n                for (ks = p - 1; ks >= k; ks--) {\n                    if (ks == k) {\n                        break;\n                    }\n                    final double t = (ks != p ? FastMath.abs(e[ks]) : 0) +\n                        (ks != k + 1 ? FastMath.abs(e[ks - 1]) : 0);\n                    if (FastMath.abs(singularValues[ks]) <= TINY + EPS * t) {\n                        singularValues[ks] = 0;\n                        break;\n                    }\n                }\n                if (ks == k) {\n                    kase = 3;\n                } else if (ks == p - 1) {\n                    kase = 1;\n                } else {\n                    kase = 2;\n                    k = ks;\n                }\n            }\n            k++;\n            // Perform the task indicated by kase.\n            switch (kase) {\n                // Deflate negligible s(p).\n                case 1: {\n                    double f = e[p - 2];\n                    e[p - 2] = 0;\n                    for (int j = p - 2; j >= k; j--) {\n                        double t = FastMath.hypot(singularValues[j], f);\n                        final double cs = singularValues[j] / t;\n                        final double sn = f / t;\n                        singularValues[j] = t;\n                        if (j != k) {\n                            f = -sn * e[j - 1];\n                            e[j - 1] = cs * e[j - 1];\n                        }\n\n                        for (int i = 0; i < n; i++) {\n                            t = cs * V[i][j] + sn * V[i][p - 1];\n                            V[i][p - 1] = -sn * V[i][j] + cs * V[i][p - 1];\n                            V[i][j] = t;\n                        }\n                    }\n                }\n                break;\n                // Split at negligible s(k).\n                case 2: {\n                    double f = e[k - 1];\n                    e[k - 1] = 0;\n                    for (int j = k; j < p; j++) {\n                        double t = FastMath.hypot(singularValues[j], f);\n                        final double cs = singularValues[j] / t;\n                        final double sn = f / t;\n                        singularValues[j] = t;\n                        f = -sn * e[j];\n                        e[j] = cs * e[j];\n\n                        for (int i = 0; i < m; i++) {\n                            t = cs * U[i][j] + sn * U[i][k - 1];\n                            U[i][k - 1] = -sn * U[i][j] + cs * U[i][k - 1];\n                            U[i][j] = t;\n                        }\n                    }\n                }\n                break;\n                // Perform one qr step.\n                case 3: {\n                    // Calculate the shift.\n                    final double maxPm1Pm2 = FastMath.max(FastMath.abs(singularValues[p - 1]),\n                                                          FastMath.abs(singularValues[p - 2]));\n                    final double scale = FastMath.max(FastMath.max(FastMath.max(maxPm1Pm2,\n                                                                                FastMath.abs(e[p - 2])),\n                                                                   FastMath.abs(singularValues[k])),\n                                                      FastMath.abs(e[k]));\n                    final double sp = singularValues[p - 1] / scale;\n                    final double spm1 = singularValues[p - 2] / scale;\n                    final double epm1 = e[p - 2] / scale;\n                    final double sk = singularValues[k] / scale;\n                    final double ek = e[k] / scale;\n                    final double b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2.0;\n                    final double c = (sp * epm1) * (sp * epm1);\n                    double shift = 0;\n                    if (b != 0 ||\n                        c != 0) {\n                        shift = FastMath.sqrt(b * b + c);\n                        if (b < 0) {\n                            shift = -shift;\n                        }\n                        shift = c / (b + shift);\n                    }\n                    double f = (sk + sp) * (sk - sp) + shift;\n                    double g = sk * ek;\n                    // Chase zeros.\n                    for (int j = k; j < p - 1; j++) {\n                        double t = FastMath.hypot(f, g);\n                        double cs = f / t;\n                        double sn = g / t;\n                        if (j != k) {\n                            e[j - 1] = t;\n                        }\n                        f = cs * singularValues[j] + sn * e[j];\n                        e[j] = cs * e[j] - sn * singularValues[j];\n                        g = sn * singularValues[j + 1];\n                        singularValues[j + 1] = cs * singularValues[j + 1];\n\n                        for (int i = 0; i < n; i++) {\n                            t = cs * V[i][j] + sn * V[i][j + 1];\n                            V[i][j + 1] = -sn * V[i][j] + cs * V[i][j + 1];\n                            V[i][j] = t;\n                        }\n                        t = FastMath.hypot(f, g);\n                        cs = f / t;\n                        sn = g / t;\n                        singularValues[j] = t;\n                        f = cs * e[j] + sn * singularValues[j + 1];\n                        singularValues[j + 1] = -sn * e[j] + cs * singularValues[j + 1];\n                        g = sn * e[j + 1];\n                        e[j + 1] = cs * e[j + 1];\n                        if (j < m - 1) {\n                            for (int i = 0; i < m; i++) {\n                                t = cs * U[i][j] + sn * U[i][j + 1];\n                                U[i][j + 1] = -sn * U[i][j] + cs * U[i][j + 1];\n                                U[i][j] = t;\n                            }\n                        }\n                    }\n                    e[p - 2] = f;\n                    iter = iter + 1;\n                }\n                break;\n                // Convergence.\n                default: {\n                    // Make the singular values positive.\n                    if (singularValues[k] <= 0) {\n                        singularValues[k] = singularValues[k] < 0 ? -singularValues[k] : 0;\n\n                        for (int i = 0; i <= pp; i++) {\n                            V[i][k] = -V[i][k];\n                        }\n                    }\n                    // Order the singular values.\n                    while (k < pp) {\n                        if (singularValues[k] >= singularValues[k + 1]) {\n                            break;\n                        }\n                        double t = singularValues[k];\n                        singularValues[k] = singularValues[k + 1];\n                        singularValues[k + 1] = t;\n                        if (k < n - 1) {\n                            for (int i = 0; i < n; i++) {\n                                t = V[i][k + 1];\n                                V[i][k + 1] = V[i][k];\n                                V[i][k] = t;\n                            }\n                        }\n                        if (k < m - 1) {\n                            for (int i = 0; i < m; i++) {\n                                t = U[i][k + 1];\n                                U[i][k + 1] = U[i][k];\n                                U[i][k] = t;\n                            }\n                        }\n                        k++;\n                    }\n                    iter = 0;\n                    p--;\n                }\n                break;\n            }\n        }\n\n        // Set the small value tolerance used to calculate rank and pseudo-inverse\n        tol = FastMath.max(m * singularValues[0] * EPS,\n                           FastMath.sqrt(Precision.SAFE_MIN));\n\n        if (!transposed) {\n            cachedU = MatrixUtils.createRealMatrix(U);\n            cachedV = MatrixUtils.createRealMatrix(V);\n        } else {\n            cachedU = MatrixUtils.createRealMatrix(V);\n            cachedV = MatrixUtils.createRealMatrix(U);\n        }\n    }",
          "25": "    public SingularValueDecomposition(final RealMatrix matrix) {\n        final double[][] A;\n\n         // \"m\" is always the largest dimension.\n        if (matrix.getRowDimension() < matrix.getColumnDimension()) {\n            transposed = true;\n            A = matrix.transpose().getData();\n            m = matrix.getColumnDimension();\n            n = matrix.getRowDimension();\n        } else {\n            transposed = false;\n            A = matrix.getData();\n            m = matrix.getRowDimension();\n            n = matrix.getColumnDimension();\n        }\n\n        singularValues = new double[n];\n        final double[][] U = new double[m][n];\n        final double[][] V = new double[n][n];\n        final double[] e = new double[n];\n        final double[] work = new double[m];\n        // Reduce A to bidiagonal form, storing the diagonal elements\n        // in s and the super-diagonal elements in e.\n        final int nct = FastMath.min(m - 1, n);\n        final int nrt = FastMath.max(0, n - 2);\n        for (int k = 0; k < FastMath.max(nct, nrt); k++) {\n            if (k < nct) {\n                // Compute the transformation for the k-th column and\n                // place the k-th diagonal in s[k].\n                // Compute 2-norm of k-th column without under/overflow.\n                singularValues[k] = 0;\n                for (int i = k; i < m; i++) {\n                    singularValues[k] = FastMath.hypot(singularValues[k], A[i][k]);\n                }\n                if (singularValues[k] != 0) {\n                    if (A[k][k] < 0) {\nsingularValues[k] = tol;\n                    }\n                    for (int i = k; i < m; i++) {\n                        A[i][k] /= singularValues[k];\n                    }\n                    A[k][k] += 1;\n                }\n                singularValues[k] = -singularValues[k];\n            }\n            for (int j = k + 1; j < n; j++) {\n                if (k < nct &&\n                    singularValues[k] != 0) {\n                    // Apply the transformation.\n                    double t = 0;\n                    for (int i = k; i < m; i++) {\n                        t += A[i][k] * A[i][j];\n                    }\n                    t = -t / A[k][k];\n                    for (int i = k; i < m; i++) {\n                        A[i][j] += t * A[i][k];\n                    }\n                }\n                // Place the k-th row of A into e for the\n                // subsequent calculation of the row transformation.\n                e[j] = A[k][j];\n            }\n            if (k < nct) {\n                // Place the transformation in U for subsequent back\n                // multiplication.\n                for (int i = k; i < m; i++) {\n                    U[i][k] = A[i][k];\n                }\n            }\n            if (k < nrt) {\n                // Compute the k-th row transformation and place the\n                // k-th super-diagonal in e[k].\n                // Compute 2-norm without under/overflow.\n                e[k] = 0;\n                for (int i = k + 1; i < n; i++) {\n                    e[k] = FastMath.hypot(e[k], e[i]);\n                }\n                if (e[k] != 0) {\n                    if (e[k + 1] < 0) {\n                        e[k] = -e[k];\n                    }\n                    for (int i = k + 1; i < n; i++) {\n                        e[i] /= e[k];\n                    }\n                    e[k + 1] += 1;\n                }\n                e[k] = -e[k];\n                if (k + 1 < m &&\n                    e[k] != 0) {\n                    // Apply the transformation.\n                    for (int i = k + 1; i < m; i++) {\n                        work[i] = 0;\n                    }\n                    for (int j = k + 1; j < n; j++) {\n                        for (int i = k + 1; i < m; i++) {\n                            work[i] += e[j] * A[i][j];\n                        }\n                    }\n                    for (int j = k + 1; j < n; j++) {\n                        final double t = -e[j] / e[k + 1];\n                        for (int i = k + 1; i < m; i++) {\n                            A[i][j] += t * work[i];\n                        }\n                    }\n                }\n\n                // Place the transformation in V for subsequent\n                // back multiplication.\n                for (int i = k + 1; i < n; i++) {\n                    V[i][k] = e[i];\n                }\n            }\n        }\n        // Set up the final bidiagonal matrix or order p.\n        int p = n;\n        if (nct < n) {\n            singularValues[nct] = A[nct][nct];\n        }\n        if (m < p) {\n            singularValues[p - 1] = 0;\n        }\n        if (nrt + 1 < p) {\n            e[nrt] = A[nrt][p - 1];\n        }\n        e[p - 1] = 0;\n\n        // Generate U.\n        for (int j = nct; j < n; j++) {\n            for (int i = 0; i < m; i++) {\n                U[i][j] = 0;\n            }\n            U[j][j] = 1;\n        }\n        for (int k = nct - 1; k >= 0; k--) {\n            if (singularValues[k] != 0) {\n                for (int j = k + 1; j < n; j++) {\n                    double t = 0;\n                    for (int i = k; i < m; i++) {\n                        t += U[i][k] * U[i][j];\n                    }\n                    t = -t / U[k][k];\n                    for (int i = k; i < m; i++) {\n                        U[i][j] += t * U[i][k];\n                    }\n                }\n                for (int i = k; i < m; i++) {\n                    U[i][k] = -U[i][k];\n                }\n                U[k][k] = 1 + U[k][k];\n                for (int i = 0; i < k - 1; i++) {\n                    U[i][k] = 0;\n                }\n            } else {\n                for (int i = 0; i < m; i++) {\n                    U[i][k] = 0;\n                }\n                U[k][k] = 1;\n            }\n        }\n\n        // Generate V.\n        for (int k = n - 1; k >= 0; k--) {\n            if (k < nrt &&\n                e[k] != 0) {\n                for (int j = k + 1; j < n; j++) {\n                    double t = 0;\n                    for (int i = k + 1; i < n; i++) {\n                        t += V[i][k] * V[i][j];\n                    }\n                    t = -t / V[k + 1][k];\n                    for (int i = k + 1; i < n; i++) {\n                        V[i][j] += t * V[i][k];\n                    }\n                }\n            }\n            for (int i = 0; i < n; i++) {\n                V[i][k] = 0;\n            }\n            V[k][k] = 1;\n        }\n\n        // Main iteration loop for the singular values.\n        final int pp = p - 1;\n        int iter = 0;\n        while (p > 0) {\n            int k;\n            int kase;\n            // Here is where a test for too many iterations would go.\n            // This section of the program inspects for\n            // negligible elements in the s and e arrays.  On\n            // completion the variables kase and k are set as follows.\n            // kase = 1     if s(p) and e[k-1] are negligible and k<p\n            // kase = 2     if s(k) is negligible and k<p\n            // kase = 3     if e[k-1] is negligible, k<p, and\n            //              s(k), ..., s(p) are not negligible (qr step).\n            // kase = 4     if e(p-1) is negligible (convergence).\n            for (k = p - 2; k >= 0; k--) {\n                final double threshold\n                    = TINY + EPS * (FastMath.abs(singularValues[k]) +\n                                    FastMath.abs(singularValues[k + 1]));\n\n                // the following condition is written this way in order\n                // to break out of the loop when NaN occurs, writing it\n                // as \"if (FastMath.abs(e[k]) <= threshold)\" would loop\n                // indefinitely in case of NaNs because comparison on NaNs\n                // always return false, regardless of what is checked\n                // see issue MATH-947\n                if (!(FastMath.abs(e[k]) > threshold)) {\n                    e[k] = 0;\n                    break;\n                }\n\n            }\n\n            if (k == p - 2) {\n                kase = 4;\n            } else {\n                int ks;\n                for (ks = p - 1; ks >= k; ks--) {\n                    if (ks == k) {\n                        break;\n                    }\n                    final double t = (ks != p ? FastMath.abs(e[ks]) : 0) +\n                        (ks != k + 1 ? FastMath.abs(e[ks - 1]) : 0);\n                    if (FastMath.abs(singularValues[ks]) <= TINY + EPS * t) {\n                        singularValues[ks] = 0;\n                        break;\n                    }\n                }\n                if (ks == k) {\n                    kase = 3;\n                } else if (ks == p - 1) {\n                    kase = 1;\n                } else {\n                    kase = 2;\n                    k = ks;\n                }\n            }\n            k++;\n            // Perform the task indicated by kase.\n            switch (kase) {\n                // Deflate negligible s(p).\n                case 1: {\n                    double f = e[p - 2];\n                    e[p - 2] = 0;\n                    for (int j = p - 2; j >= k; j--) {\n                        double t = FastMath.hypot(singularValues[j], f);\n                        final double cs = singularValues[j] / t;\n                        final double sn = f / t;\n                        singularValues[j] = t;\n                        if (j != k) {\n                            f = -sn * e[j - 1];\n                            e[j - 1] = cs * e[j - 1];\n                        }\n\n                        for (int i = 0; i < n; i++) {\n                            t = cs * V[i][j] + sn * V[i][p - 1];\n                            V[i][p - 1] = -sn * V[i][j] + cs * V[i][p - 1];\n                            V[i][j] = t;\n                        }\n                    }\n                }\n                break;\n                // Split at negligible s(k).\n                case 2: {\n                    double f = e[k - 1];\n                    e[k - 1] = 0;\n                    for (int j = k; j < p; j++) {\n                        double t = FastMath.hypot(singularValues[j], f);\n                        final double cs = singularValues[j] / t;\n                        final double sn = f / t;\n                        singularValues[j] = t;\n                        f = -sn * e[j];\n                        e[j] = cs * e[j];\n\n                        for (int i = 0; i < m; i++) {\n                            t = cs * U[i][j] + sn * U[i][k - 1];\n                            U[i][k - 1] = -sn * U[i][j] + cs * U[i][k - 1];\n                            U[i][j] = t;\n                        }\n                    }\n                }\n                break;\n                // Perform one qr step.\n                case 3: {\n                    // Calculate the shift.\n                    final double maxPm1Pm2 = FastMath.max(FastMath.abs(singularValues[p - 1]),\n                                                          FastMath.abs(singularValues[p - 2]));\n                    final double scale = FastMath.max(FastMath.max(FastMath.max(maxPm1Pm2,\n                                                                                FastMath.abs(e[p - 2])),\n                                                                   FastMath.abs(singularValues[k])),\n                                                      FastMath.abs(e[k]));\n                    final double sp = singularValues[p - 1] / scale;\n                    final double spm1 = singularValues[p - 2] / scale;\n                    final double epm1 = e[p - 2] / scale;\n                    final double sk = singularValues[k] / scale;\n                    final double ek = e[k] / scale;\n                    final double b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2.0;\n                    final double c = (sp * epm1) * (sp * epm1);\n                    double shift = 0;\n                    if (b != 0 ||\n                        c != 0) {\n                        shift = FastMath.sqrt(b * b + c);\n                        if (b < 0) {\n                            shift = -shift;\n                        }\n                        shift = c / (b + shift);\n                    }\n                    double f = (sk + sp) * (sk - sp) + shift;\n                    double g = sk * ek;\n                    // Chase zeros.\n                    for (int j = k; j < p - 1; j++) {\n                        double t = FastMath.hypot(f, g);\n                        double cs = f / t;\n                        double sn = g / t;\n                        if (j != k) {\n                            e[j - 1] = t;\n                        }\n                        f = cs * singularValues[j] + sn * e[j];\n                        e[j] = cs * e[j] - sn * singularValues[j];\n                        g = sn * singularValues[j + 1];\n                        singularValues[j + 1] = cs * singularValues[j + 1];\n\n                        for (int i = 0; i < n; i++) {\n                            t = cs * V[i][j] + sn * V[i][j + 1];\n                            V[i][j + 1] = -sn * V[i][j] + cs * V[i][j + 1];\n                            V[i][j] = t;\n                        }\n                        t = FastMath.hypot(f, g);\n                        cs = f / t;\n                        sn = g / t;\n                        singularValues[j] = t;\n                        f = cs * e[j] + sn * singularValues[j + 1];\n                        singularValues[j + 1] = -sn * e[j] + cs * singularValues[j + 1];\n                        g = sn * e[j + 1];\n                        e[j + 1] = cs * e[j + 1];\n                        if (j < m - 1) {\n                            for (int i = 0; i < m; i++) {\n                                t = cs * U[i][j] + sn * U[i][j + 1];\n                                U[i][j + 1] = -sn * U[i][j] + cs * U[i][j + 1];\n                                U[i][j] = t;\n                            }\n                        }\n                    }\n                    e[p - 2] = f;\n                    iter = iter + 1;\n                }\n                break;\n                // Convergence.\n                default: {\n                    // Make the singular values positive.\n                    if (singularValues[k] <= 0) {\n                        singularValues[k] = singularValues[k] < 0 ? -singularValues[k] : 0;\n\n                        for (int i = 0; i <= pp; i++) {\n                            V[i][k] = -V[i][k];\n                        }\n                    }\n                    // Order the singular values.\n                    while (k < pp) {\n                        if (singularValues[k] >= singularValues[k + 1]) {\n                            break;\n                        }\n                        double t = singularValues[k];\n                        singularValues[k] = singularValues[k + 1];\n                        singularValues[k + 1] = t;\n                        if (k < n - 1) {\n                            for (int i = 0; i < n; i++) {\n                                t = V[i][k + 1];\n                                V[i][k + 1] = V[i][k];\n                                V[i][k] = t;\n                            }\n                        }\n                        if (k < m - 1) {\n                            for (int i = 0; i < m; i++) {\n                                t = U[i][k + 1];\n                                U[i][k + 1] = U[i][k];\n                                U[i][k] = t;\n                            }\n                        }\n                        k++;\n                    }\n                    iter = 0;\n                    p--;\n                }\n                break;\n            }\n        }\n\n        // Set the small value tolerance used to calculate rank and pseudo-inverse\n        tol = FastMath.max(m * singularValues[0] * EPS,\n                           FastMath.sqrt(Precision.SAFE_MIN));\n\n        if (!transposed) {\n            cachedU = MatrixUtils.createRealMatrix(U);\n            cachedV = MatrixUtils.createRealMatrix(V);\n        } else {\n            cachedU = MatrixUtils.createRealMatrix(V);\n            cachedV = MatrixUtils.createRealMatrix(U);\n        }\n    }",
          "26": "    public SingularValueDecomposition(final RealMatrix matrix) {\n        final double[][] A;\n\n         // \"m\" is always the largest dimension.\n        if (matrix.getRowDimension() < matrix.getColumnDimension()) {\n            transposed = true;\n            A = matrix.transpose().getData();\n            m = matrix.getColumnDimension();\n            n = matrix.getRowDimension();\n        } else {\n            transposed = false;\n            A = matrix.getData();\n            m = matrix.getRowDimension();\n            n = matrix.getColumnDimension();\n        }\n\n        singularValues = new double[n];\n        final double[][] U = new double[m][n];\n        final double[][] V = new double[n][n];\n        final double[] e = new double[n];\n        final double[] work = new double[m];\n        // Reduce A to bidiagonal form, storing the diagonal elements\n        // in s and the super-diagonal elements in e.\n        final int nct = FastMath.min(m - 1, n);\n        final int nrt = FastMath.max(0, n - 2);\n        for (int k = 0; k < FastMath.max(nct, nrt); k++) {\n            if (k < nct) {\n                // Compute the transformation for the k-th column and\n                // place the k-th diagonal in s[k].\n                // Compute 2-norm of k-th column without under/overflow.\n                singularValues[k] = 0;\n                for (int i = k; i < m; i++) {\n                    singularValues[k] = FastMath.hypot(singularValues[k], A[i][k]);\n                }\n                if (singularValues[k] != 0) {\n                    if (A[k][k] < 0) {\nsingularValues[k] = 0;\n                    }\n                    for (int i = k; i < m; i++) {\n                        A[i][k] /= singularValues[k];\n                    }\n                    A[k][k] += 1;\n                }\n                singularValues[k] = -singularValues[k];\n            }\n            for (int j = k + 1; j < n; j++) {\n                if (k < nct &&\n                    singularValues[k] != 0) {\n                    // Apply the transformation.\n                    double t = 0;\n                    for (int i = k; i < m; i++) {\n                        t += A[i][k] * A[i][j];\n                    }\n                    t = -t / A[k][k];\n                    for (int i = k; i < m; i++) {\n                        A[i][j] += t * A[i][k];\n                    }\n                }\n                // Place the k-th row of A into e for the\n                // subsequent calculation of the row transformation.\n                e[j] = A[k][j];\n            }\n            if (k < nct) {\n                // Place the transformation in U for subsequent back\n                // multiplication.\n                for (int i = k; i < m; i++) {\n                    U[i][k] = A[i][k];\n                }\n            }\n            if (k < nrt) {\n                // Compute the k-th row transformation and place the\n                // k-th super-diagonal in e[k].\n                // Compute 2-norm without under/overflow.\n                e[k] = 0;\n                for (int i = k + 1; i < n; i++) {\n                    e[k] = FastMath.hypot(e[k], e[i]);\n                }\n                if (e[k] != 0) {\n                    if (e[k + 1] < 0) {\n                        e[k] = -e[k];\n                    }\n                    for (int i = k + 1; i < n; i++) {\n                        e[i] /= e[k];\n                    }\n                    e[k + 1] += 1;\n                }\n                e[k] = -e[k];\n                if (k + 1 < m &&\n                    e[k] != 0) {\n                    // Apply the transformation.\n                    for (int i = k + 1; i < m; i++) {\n                        work[i] = 0;\n                    }\n                    for (int j = k + 1; j < n; j++) {\n                        for (int i = k + 1; i < m; i++) {\n                            work[i] += e[j] * A[i][j];\n                        }\n                    }\n                    for (int j = k + 1; j < n; j++) {\n                        final double t = -e[j] / e[k + 1];\n                        for (int i = k + 1; i < m; i++) {\n                            A[i][j] += t * work[i];\n                        }\n                    }\n                }\n\n                // Place the transformation in V for subsequent\n                // back multiplication.\n                for (int i = k + 1; i < n; i++) {\n                    V[i][k] = e[i];\n                }\n            }\n        }\n        // Set up the final bidiagonal matrix or order p.\n        int p = n;\n        if (nct < n) {\n            singularValues[nct] = A[nct][nct];\n        }\n        if (m < p) {\n            singularValues[p - 1] = 0;\n        }\n        if (nrt + 1 < p) {\n            e[nrt] = A[nrt][p - 1];\n        }\n        e[p - 1] = 0;\n\n        // Generate U.\n        for (int j = nct; j < n; j++) {\n            for (int i = 0; i < m; i++) {\n                U[i][j] = 0;\n            }\n            U[j][j] = 1;\n        }\n        for (int k = nct - 1; k >= 0; k--) {\n            if (singularValues[k] != 0) {\n                for (int j = k + 1; j < n; j++) {\n                    double t = 0;\n                    for (int i = k; i < m; i++) {\n                        t += U[i][k] * U[i][j];\n                    }\n                    t = -t / U[k][k];\n                    for (int i = k; i < m; i++) {\n                        U[i][j] += t * U[i][k];\n                    }\n                }\n                for (int i = k; i < m; i++) {\n                    U[i][k] = -U[i][k];\n                }\n                U[k][k] = 1 + U[k][k];\n                for (int i = 0; i < k - 1; i++) {\n                    U[i][k] = 0;\n                }\n            } else {\n                for (int i = 0; i < m; i++) {\n                    U[i][k] = 0;\n                }\n                U[k][k] = 1;\n            }\n        }\n\n        // Generate V.\n        for (int k = n - 1; k >= 0; k--) {\n            if (k < nrt &&\n                e[k] != 0) {\n                for (int j = k + 1; j < n; j++) {\n                    double t = 0;\n                    for (int i = k + 1; i < n; i++) {\n                        t += V[i][k] * V[i][j];\n                    }\n                    t = -t / V[k + 1][k];\n                    for (int i = k + 1; i < n; i++) {\n                        V[i][j] += t * V[i][k];\n                    }\n                }\n            }\n            for (int i = 0; i < n; i++) {\n                V[i][k] = 0;\n            }\n            V[k][k] = 1;\n        }\n\n        // Main iteration loop for the singular values.\n        final int pp = p - 1;\n        int iter = 0;\n        while (p > 0) {\n            int k;\n            int kase;\n            // Here is where a test for too many iterations would go.\n            // This section of the program inspects for\n            // negligible elements in the s and e arrays.  On\n            // completion the variables kase and k are set as follows.\n            // kase = 1     if s(p) and e[k-1] are negligible and k<p\n            // kase = 2     if s(k) is negligible and k<p\n            // kase = 3     if e[k-1] is negligible, k<p, and\n            //              s(k), ..., s(p) are not negligible (qr step).\n            // kase = 4     if e(p-1) is negligible (convergence).\n            for (k = p - 2; k >= 0; k--) {\n                final double threshold\n                    = TINY + EPS * (FastMath.abs(singularValues[k]) +\n                                    FastMath.abs(singularValues[k + 1]));\n\n                // the following condition is written this way in order\n                // to break out of the loop when NaN occurs, writing it\n                // as \"if (FastMath.abs(e[k]) <= threshold)\" would loop\n                // indefinitely in case of NaNs because comparison on NaNs\n                // always return false, regardless of what is checked\n                // see issue MATH-947\n                if (!(FastMath.abs(e[k]) > threshold)) {\n                    e[k] = 0;\n                    break;\n                }\n\n            }\n\n            if (k == p - 2) {\n                kase = 4;\n            } else {\n                int ks;\n                for (ks = p - 1; ks >= k; ks--) {\n                    if (ks == k) {\n                        break;\n                    }\n                    final double t = (ks != p ? FastMath.abs(e[ks]) : 0) +\n                        (ks != k + 1 ? FastMath.abs(e[ks - 1]) : 0);\n                    if (FastMath.abs(singularValues[ks]) <= TINY + EPS * t) {\n                        singularValues[ks] = 0;\n                        break;\n                    }\n                }\n                if (ks == k) {\n                    kase = 3;\n                } else if (ks == p - 1) {\n                    kase = 1;\n                } else {\n                    kase = 2;\n                    k = ks;\n                }\n            }\n            k++;\n            // Perform the task indicated by kase.\n            switch (kase) {\n                // Deflate negligible s(p).\n                case 1: {\n                    double f = e[p - 2];\n                    e[p - 2] = 0;\n                    for (int j = p - 2; j >= k; j--) {\n                        double t = FastMath.hypot(singularValues[j], f);\n                        final double cs = singularValues[j] / t;\n                        final double sn = f / t;\n                        singularValues[j] = t;\n                        if (j != k) {\n                            f = -sn * e[j - 1];\n                            e[j - 1] = cs * e[j - 1];\n                        }\n\n                        for (int i = 0; i < n; i++) {\n                            t = cs * V[i][j] + sn * V[i][p - 1];\n                            V[i][p - 1] = -sn * V[i][j] + cs * V[i][p - 1];\n                            V[i][j] = t;\n                        }\n                    }\n                }\n                break;\n                // Split at negligible s(k).\n                case 2: {\n                    double f = e[k - 1];\n                    e[k - 1] = 0;\n                    for (int j = k; j < p; j++) {\n                        double t = FastMath.hypot(singularValues[j], f);\n                        final double cs = singularValues[j] / t;\n                        final double sn = f / t;\n                        singularValues[j] = t;\n                        f = -sn * e[j];\n                        e[j] = cs * e[j];\n\n                        for (int i = 0; i < m; i++) {\n                            t = cs * U[i][j] + sn * U[i][k - 1];\n                            U[i][k - 1] = -sn * U[i][j] + cs * U[i][k - 1];\n                            U[i][j] = t;\n                        }\n                    }\n                }\n                break;\n                // Perform one qr step.\n                case 3: {\n                    // Calculate the shift.\n                    final double maxPm1Pm2 = FastMath.max(FastMath.abs(singularValues[p - 1]),\n                                                          FastMath.abs(singularValues[p - 2]));\n                    final double scale = FastMath.max(FastMath.max(FastMath.max(maxPm1Pm2,\n                                                                                FastMath.abs(e[p - 2])),\n                                                                   FastMath.abs(singularValues[k])),\n                                                      FastMath.abs(e[k]));\n                    final double sp = singularValues[p - 1] / scale;\n                    final double spm1 = singularValues[p - 2] / scale;\n                    final double epm1 = e[p - 2] / scale;\n                    final double sk = singularValues[k] / scale;\n                    final double ek = e[k] / scale;\n                    final double b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2.0;\n                    final double c = (sp * epm1) * (sp * epm1);\n                    double shift = 0;\n                    if (b != 0 ||\n                        c != 0) {\n                        shift = FastMath.sqrt(b * b + c);\n                        if (b < 0) {\n                            shift = -shift;\n                        }\n                        shift = c / (b + shift);\n                    }\n                    double f = (sk + sp) * (sk - sp) + shift;\n                    double g = sk * ek;\n                    // Chase zeros.\n                    for (int j = k; j < p - 1; j++) {\n                        double t = FastMath.hypot(f, g);\n                        double cs = f / t;\n                        double sn = g / t;\n                        if (j != k) {\n                            e[j - 1] = t;\n                        }\n                        f = cs * singularValues[j] + sn * e[j];\n                        e[j] = cs * e[j] - sn * singularValues[j];\n                        g = sn * singularValues[j + 1];\n                        singularValues[j + 1] = cs * singularValues[j + 1];\n\n                        for (int i = 0; i < n; i++) {\n                            t = cs * V[i][j] + sn * V[i][j + 1];\n                            V[i][j + 1] = -sn * V[i][j] + cs * V[i][j + 1];\n                            V[i][j] = t;\n                        }\n                        t = FastMath.hypot(f, g);\n                        cs = f / t;\n                        sn = g / t;\n                        singularValues[j] = t;\n                        f = cs * e[j] + sn * singularValues[j + 1];\n                        singularValues[j + 1] = -sn * e[j] + cs * singularValues[j + 1];\n                        g = sn * e[j + 1];\n                        e[j + 1] = cs * e[j + 1];\n                        if (j < m - 1) {\n                            for (int i = 0; i < m; i++) {\n                                t = cs * U[i][j] + sn * U[i][j + 1];\n                                U[i][j + 1] = -sn * U[i][j] + cs * U[i][j + 1];\n                                U[i][j] = t;\n                            }\n                        }\n                    }\n                    e[p - 2] = f;\n                    iter = iter + 1;\n                }\n                break;\n                // Convergence.\n                default: {\n                    // Make the singular values positive.\n                    if (singularValues[k] <= 0) {\n                        singularValues[k] = singularValues[k] < 0 ? -singularValues[k] : 0;\n\n                        for (int i = 0; i <= pp; i++) {\n                            V[i][k] = -V[i][k];\n                        }\n                    }\n                    // Order the singular values.\n                    while (k < pp) {\n                        if (singularValues[k] >= singularValues[k + 1]) {\n                            break;\n                        }\n                        double t = singularValues[k];\n                        singularValues[k] = singularValues[k + 1];\n                        singularValues[k + 1] = t;\n                        if (k < n - 1) {\n                            for (int i = 0; i < n; i++) {\n                                t = V[i][k + 1];\n                                V[i][k + 1] = V[i][k];\n                                V[i][k] = t;\n                            }\n                        }\n                        if (k < m - 1) {\n                            for (int i = 0; i < m; i++) {\n                                t = U[i][k + 1];\n                                U[i][k + 1] = U[i][k];\n                                U[i][k] = t;\n                            }\n                        }\n                        k++;\n                    }\n                    iter = 0;\n                    p--;\n                }\n                break;\n            }\n        }\n\n        // Set the small value tolerance used to calculate rank and pseudo-inverse\n        tol = FastMath.max(m * singularValues[0] * EPS,\n                           FastMath.sqrt(Precision.SAFE_MIN));\n\n        if (!transposed) {\n            cachedU = MatrixUtils.createRealMatrix(U);\n            cachedV = MatrixUtils.createRealMatrix(V);\n        } else {\n            cachedU = MatrixUtils.createRealMatrix(V);\n            cachedV = MatrixUtils.createRealMatrix(U);\n        }\n    }",
          "27": "    public SingularValueDecomposition(final RealMatrix matrix) {\n        final double[][] A;\n\n         // \"m\" is always the largest dimension.\n        if (matrix.getRowDimension() < matrix.getColumnDimension()) {\n            transposed = true;\n            A = matrix.transpose().getData();\n            m = matrix.getColumnDimension();\n            n = matrix.getRowDimension();\n        } else {\n            transposed = false;\n            A = matrix.getData();\n            m = matrix.getRowDimension();\n            n = matrix.getColumnDimension();\n        }\n\n        singularValues = new double[n];\n        final double[][] U = new double[m][n];\n        final double[][] V = new double[n][n];\n        final double[] e = new double[n];\n        final double[] work = new double[m];\n        // Reduce A to bidiagonal form, storing the diagonal elements\n        // in s and the super-diagonal elements in e.\n        final int nct = FastMath.min(m - 1, n);\n        final int nrt = FastMath.max(0, n - 2);\n        for (int k = 0; k < FastMath.max(nct, nrt); k++) {\n            if (k < nct) {\n                // Compute the transformation for the k-th column and\n                // place the k-th diagonal in s[k].\n                // Compute 2-norm of k-th column without under/overflow.\n                singularValues[k] = 0;\n                for (int i = k; i < m; i++) {\n                    singularValues[k] = FastMath.hypot(singularValues[k], A[i][k]);\n                }\n                if (singularValues[k] != 0) {\n                    if (A[k][k] < 0) {\nsingularValues[k] = EPS[i].[k];\n                    }\n                    for (int i = k; i < m; i++) {\n                        A[i][k] /= singularValues[k];\n                    }\n                    A[k][k] += 1;\n                }\n                singularValues[k] = -singularValues[k];\n            }\n            for (int j = k + 1; j < n; j++) {\n                if (k < nct &&\n                    singularValues[k] != 0) {\n                    // Apply the transformation.\n                    double t = 0;\n                    for (int i = k; i < m; i++) {\n                        t += A[i][k] * A[i][j];\n                    }\n                    t = -t / A[k][k];\n                    for (int i = k; i < m; i++) {\n                        A[i][j] += t * A[i][k];\n                    }\n                }\n                // Place the k-th row of A into e for the\n                // subsequent calculation of the row transformation.\n                e[j] = A[k][j];\n            }\n            if (k < nct) {\n                // Place the transformation in U for subsequent back\n                // multiplication.\n                for (int i = k; i < m; i++) {\n                    U[i][k] = A[i][k];\n                }\n            }\n            if (k < nrt) {\n                // Compute the k-th row transformation and place the\n                // k-th super-diagonal in e[k].\n                // Compute 2-norm without under/overflow.\n                e[k] = 0;\n                for (int i = k + 1; i < n; i++) {\n                    e[k] = FastMath.hypot(e[k], e[i]);\n                }\n                if (e[k] != 0) {\n                    if (e[k + 1] < 0) {\n                        e[k] = -e[k];\n                    }\n                    for (int i = k + 1; i < n; i++) {\n                        e[i] /= e[k];\n                    }\n                    e[k + 1] += 1;\n                }\n                e[k] = -e[k];\n                if (k + 1 < m &&\n                    e[k] != 0) {\n                    // Apply the transformation.\n                    for (int i = k + 1; i < m; i++) {\n                        work[i] = 0;\n                    }\n                    for (int j = k + 1; j < n; j++) {\n                        for (int i = k + 1; i < m; i++) {\n                            work[i] += e[j] * A[i][j];\n                        }\n                    }\n                    for (int j = k + 1; j < n; j++) {\n                        final double t = -e[j] / e[k + 1];\n                        for (int i = k + 1; i < m; i++) {\n                            A[i][j] += t * work[i];\n                        }\n                    }\n                }\n\n                // Place the transformation in V for subsequent\n                // back multiplication.\n                for (int i = k + 1; i < n; i++) {\n                    V[i][k] = e[i];\n                }\n            }\n        }\n        // Set up the final bidiagonal matrix or order p.\n        int p = n;\n        if (nct < n) {\n            singularValues[nct] = A[nct][nct];\n        }\n        if (m < p) {\n            singularValues[p - 1] = 0;\n        }\n        if (nrt + 1 < p) {\n            e[nrt] = A[nrt][p - 1];\n        }\n        e[p - 1] = 0;\n\n        // Generate U.\n        for (int j = nct; j < n; j++) {\n            for (int i = 0; i < m; i++) {\n                U[i][j] = 0;\n            }\n            U[j][j] = 1;\n        }\n        for (int k = nct - 1; k >= 0; k--) {\n            if (singularValues[k] != 0) {\n                for (int j = k + 1; j < n; j++) {\n                    double t = 0;\n                    for (int i = k; i < m; i++) {\n                        t += U[i][k] * U[i][j];\n                    }\n                    t = -t / U[k][k];\n                    for (int i = k; i < m; i++) {\n                        U[i][j] += t * U[i][k];\n                    }\n                }\n                for (int i = k; i < m; i++) {\n                    U[i][k] = -U[i][k];\n                }\n                U[k][k] = 1 + U[k][k];\n                for (int i = 0; i < k - 1; i++) {\n                    U[i][k] = 0;\n                }\n            } else {\n                for (int i = 0; i < m; i++) {\n                    U[i][k] = 0;\n                }\n                U[k][k] = 1;\n            }\n        }\n\n        // Generate V.\n        for (int k = n - 1; k >= 0; k--) {\n            if (k < nrt &&\n                e[k] != 0) {\n                for (int j = k + 1; j < n; j++) {\n                    double t = 0;\n                    for (int i = k + 1; i < n; i++) {\n                        t += V[i][k] * V[i][j];\n                    }\n                    t = -t / V[k + 1][k];\n                    for (int i = k + 1; i < n; i++) {\n                        V[i][j] += t * V[i][k];\n                    }\n                }\n            }\n            for (int i = 0; i < n; i++) {\n                V[i][k] = 0;\n            }\n            V[k][k] = 1;\n        }\n\n        // Main iteration loop for the singular values.\n        final int pp = p - 1;\n        int iter = 0;\n        while (p > 0) {\n            int k;\n            int kase;\n            // Here is where a test for too many iterations would go.\n            // This section of the program inspects for\n            // negligible elements in the s and e arrays.  On\n            // completion the variables kase and k are set as follows.\n            // kase = 1     if s(p) and e[k-1] are negligible and k<p\n            // kase = 2     if s(k) is negligible and k<p\n            // kase = 3     if e[k-1] is negligible, k<p, and\n            //              s(k), ..., s(p) are not negligible (qr step).\n            // kase = 4     if e(p-1) is negligible (convergence).\n            for (k = p - 2; k >= 0; k--) {\n                final double threshold\n                    = TINY + EPS * (FastMath.abs(singularValues[k]) +\n                                    FastMath.abs(singularValues[k + 1]));\n\n                // the following condition is written this way in order\n                // to break out of the loop when NaN occurs, writing it\n                // as \"if (FastMath.abs(e[k]) <= threshold)\" would loop\n                // indefinitely in case of NaNs because comparison on NaNs\n                // always return false, regardless of what is checked\n                // see issue MATH-947\n                if (!(FastMath.abs(e[k]) > threshold)) {\n                    e[k] = 0;\n                    break;\n                }\n\n            }\n\n            if (k == p - 2) {\n                kase = 4;\n            } else {\n                int ks;\n                for (ks = p - 1; ks >= k; ks--) {\n                    if (ks == k) {\n                        break;\n                    }\n                    final double t = (ks != p ? FastMath.abs(e[ks]) : 0) +\n                        (ks != k + 1 ? FastMath.abs(e[ks - 1]) : 0);\n                    if (FastMath.abs(singularValues[ks]) <= TINY + EPS * t) {\n                        singularValues[ks] = 0;\n                        break;\n                    }\n                }\n                if (ks == k) {\n                    kase = 3;\n                } else if (ks == p - 1) {\n                    kase = 1;\n                } else {\n                    kase = 2;\n                    k = ks;\n                }\n            }\n            k++;\n            // Perform the task indicated by kase.\n            switch (kase) {\n                // Deflate negligible s(p).\n                case 1: {\n                    double f = e[p - 2];\n                    e[p - 2] = 0;\n                    for (int j = p - 2; j >= k; j--) {\n                        double t = FastMath.hypot(singularValues[j], f);\n                        final double cs = singularValues[j] / t;\n                        final double sn = f / t;\n                        singularValues[j] = t;\n                        if (j != k) {\n                            f = -sn * e[j - 1];\n                            e[j - 1] = cs * e[j - 1];\n                        }\n\n                        for (int i = 0; i < n; i++) {\n                            t = cs * V[i][j] + sn * V[i][p - 1];\n                            V[i][p - 1] = -sn * V[i][j] + cs * V[i][p - 1];\n                            V[i][j] = t;\n                        }\n                    }\n                }\n                break;\n                // Split at negligible s(k).\n                case 2: {\n                    double f = e[k - 1];\n                    e[k - 1] = 0;\n                    for (int j = k; j < p; j++) {\n                        double t = FastMath.hypot(singularValues[j], f);\n                        final double cs = singularValues[j] / t;\n                        final double sn = f / t;\n                        singularValues[j] = t;\n                        f = -sn * e[j];\n                        e[j] = cs * e[j];\n\n                        for (int i = 0; i < m; i++) {\n                            t = cs * U[i][j] + sn * U[i][k - 1];\n                            U[i][k - 1] = -sn * U[i][j] + cs * U[i][k - 1];\n                            U[i][j] = t;\n                        }\n                    }\n                }\n                break;\n                // Perform one qr step.\n                case 3: {\n                    // Calculate the shift.\n                    final double maxPm1Pm2 = FastMath.max(FastMath.abs(singularValues[p - 1]),\n                                                          FastMath.abs(singularValues[p - 2]));\n                    final double scale = FastMath.max(FastMath.max(FastMath.max(maxPm1Pm2,\n                                                                                FastMath.abs(e[p - 2])),\n                                                                   FastMath.abs(singularValues[k])),\n                                                      FastMath.abs(e[k]));\n                    final double sp = singularValues[p - 1] / scale;\n                    final double spm1 = singularValues[p - 2] / scale;\n                    final double epm1 = e[p - 2] / scale;\n                    final double sk = singularValues[k] / scale;\n                    final double ek = e[k] / scale;\n                    final double b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2.0;\n                    final double c = (sp * epm1) * (sp * epm1);\n                    double shift = 0;\n                    if (b != 0 ||\n                        c != 0) {\n                        shift = FastMath.sqrt(b * b + c);\n                        if (b < 0) {\n                            shift = -shift;\n                        }\n                        shift = c / (b + shift);\n                    }\n                    double f = (sk + sp) * (sk - sp) + shift;\n                    double g = sk * ek;\n                    // Chase zeros.\n                    for (int j = k; j < p - 1; j++) {\n                        double t = FastMath.hypot(f, g);\n                        double cs = f / t;\n                        double sn = g / t;\n                        if (j != k) {\n                            e[j - 1] = t;\n                        }\n                        f = cs * singularValues[j] + sn * e[j];\n                        e[j] = cs * e[j] - sn * singularValues[j];\n                        g = sn * singularValues[j + 1];\n                        singularValues[j + 1] = cs * singularValues[j + 1];\n\n                        for (int i = 0; i < n; i++) {\n                            t = cs * V[i][j] + sn * V[i][j + 1];\n                            V[i][j + 1] = -sn * V[i][j] + cs * V[i][j + 1];\n                            V[i][j] = t;\n                        }\n                        t = FastMath.hypot(f, g);\n                        cs = f / t;\n                        sn = g / t;\n                        singularValues[j] = t;\n                        f = cs * e[j] + sn * singularValues[j + 1];\n                        singularValues[j + 1] = -sn * e[j] + cs * singularValues[j + 1];\n                        g = sn * e[j + 1];\n                        e[j + 1] = cs * e[j + 1];\n                        if (j < m - 1) {\n                            for (int i = 0; i < m; i++) {\n                                t = cs * U[i][j] + sn * U[i][j + 1];\n                                U[i][j + 1] = -sn * U[i][j] + cs * U[i][j + 1];\n                                U[i][j] = t;\n                            }\n                        }\n                    }\n                    e[p - 2] = f;\n                    iter = iter + 1;\n                }\n                break;\n                // Convergence.\n                default: {\n                    // Make the singular values positive.\n                    if (singularValues[k] <= 0) {\n                        singularValues[k] = singularValues[k] < 0 ? -singularValues[k] : 0;\n\n                        for (int i = 0; i <= pp; i++) {\n                            V[i][k] = -V[i][k];\n                        }\n                    }\n                    // Order the singular values.\n                    while (k < pp) {\n                        if (singularValues[k] >= singularValues[k + 1]) {\n                            break;\n                        }\n                        double t = singularValues[k];\n                        singularValues[k] = singularValues[k + 1];\n                        singularValues[k + 1] = t;\n                        if (k < n - 1) {\n                            for (int i = 0; i < n; i++) {\n                                t = V[i][k + 1];\n                                V[i][k + 1] = V[i][k];\n                                V[i][k] = t;\n                            }\n                        }\n                        if (k < m - 1) {\n                            for (int i = 0; i < m; i++) {\n                                t = U[i][k + 1];\n                                U[i][k + 1] = U[i][k];\n                                U[i][k] = t;\n                            }\n                        }\n                        k++;\n                    }\n                    iter = 0;\n                    p--;\n                }\n                break;\n            }\n        }\n\n        // Set the small value tolerance used to calculate rank and pseudo-inverse\n        tol = FastMath.max(m * singularValues[0] * EPS,\n                           FastMath.sqrt(Precision.SAFE_MIN));\n\n        if (!transposed) {\n            cachedU = MatrixUtils.createRealMatrix(U);\n            cachedV = MatrixUtils.createRealMatrix(V);\n        } else {\n            cachedU = MatrixUtils.createRealMatrix(V);\n            cachedV = MatrixUtils.createRealMatrix(U);\n        }\n    }",
          "28": "    public SingularValueDecomposition(final RealMatrix matrix) {\n        final double[][] A;\n\n         // \"m\" is always the largest dimension.\n        if (matrix.getRowDimension() < matrix.getColumnDimension()) {\n            transposed = true;\n            A = matrix.transpose().getData();\n            m = matrix.getColumnDimension();\n            n = matrix.getRowDimension();\n        } else {\n            transposed = false;\n            A = matrix.getData();\n            m = matrix.getRowDimension();\n            n = matrix.getColumnDimension();\n        }\n\n        singularValues = new double[n];\n        final double[][] U = new double[m][n];\n        final double[][] V = new double[n][n];\n        final double[] e = new double[n];\n        final double[] work = new double[m];\n        // Reduce A to bidiagonal form, storing the diagonal elements\n        // in s and the super-diagonal elements in e.\n        final int nct = FastMath.min(m - 1, n);\n        final int nrt = FastMath.max(0, n - 2);\n        for (int k = 0; k < FastMath.max(nct, nrt); k++) {\n            if (k < nct) {\n                // Compute the transformation for the k-th column and\n                // place the k-th diagonal in s[k].\n                // Compute 2-norm of k-th column without under/overflow.\n                singularValues[k] = 0;\n                for (int i = k; i < m; i++) {\n                    singularValues[k] = FastMath.hypot(singularValues[k], A[i][k]);\n                }\n                if (singularValues[k] != 0) {\n                    if (A[k][k] < 0) {\nsingularValues[k] = TINY[i].[k];\n                    }\n                    for (int i = k; i < m; i++) {\n                        A[i][k] /= singularValues[k];\n                    }\n                    A[k][k] += 1;\n                }\n                singularValues[k] = -singularValues[k];\n            }\n            for (int j = k + 1; j < n; j++) {\n                if (k < nct &&\n                    singularValues[k] != 0) {\n                    // Apply the transformation.\n                    double t = 0;\n                    for (int i = k; i < m; i++) {\n                        t += A[i][k] * A[i][j];\n                    }\n                    t = -t / A[k][k];\n                    for (int i = k; i < m; i++) {\n                        A[i][j] += t * A[i][k];\n                    }\n                }\n                // Place the k-th row of A into e for the\n                // subsequent calculation of the row transformation.\n                e[j] = A[k][j];\n            }\n            if (k < nct) {\n                // Place the transformation in U for subsequent back\n                // multiplication.\n                for (int i = k; i < m; i++) {\n                    U[i][k] = A[i][k];\n                }\n            }\n            if (k < nrt) {\n                // Compute the k-th row transformation and place the\n                // k-th super-diagonal in e[k].\n                // Compute 2-norm without under/overflow.\n                e[k] = 0;\n                for (int i = k + 1; i < n; i++) {\n                    e[k] = FastMath.hypot(e[k], e[i]);\n                }\n                if (e[k] != 0) {\n                    if (e[k + 1] < 0) {\n                        e[k] = -e[k];\n                    }\n                    for (int i = k + 1; i < n; i++) {\n                        e[i] /= e[k];\n                    }\n                    e[k + 1] += 1;\n                }\n                e[k] = -e[k];\n                if (k + 1 < m &&\n                    e[k] != 0) {\n                    // Apply the transformation.\n                    for (int i = k + 1; i < m; i++) {\n                        work[i] = 0;\n                    }\n                    for (int j = k + 1; j < n; j++) {\n                        for (int i = k + 1; i < m; i++) {\n                            work[i] += e[j] * A[i][j];\n                        }\n                    }\n                    for (int j = k + 1; j < n; j++) {\n                        final double t = -e[j] / e[k + 1];\n                        for (int i = k + 1; i < m; i++) {\n                            A[i][j] += t * work[i];\n                        }\n                    }\n                }\n\n                // Place the transformation in V for subsequent\n                // back multiplication.\n                for (int i = k + 1; i < n; i++) {\n                    V[i][k] = e[i];\n                }\n            }\n        }\n        // Set up the final bidiagonal matrix or order p.\n        int p = n;\n        if (nct < n) {\n            singularValues[nct] = A[nct][nct];\n        }\n        if (m < p) {\n            singularValues[p - 1] = 0;\n        }\n        if (nrt + 1 < p) {\n            e[nrt] = A[nrt][p - 1];\n        }\n        e[p - 1] = 0;\n\n        // Generate U.\n        for (int j = nct; j < n; j++) {\n            for (int i = 0; i < m; i++) {\n                U[i][j] = 0;\n            }\n            U[j][j] = 1;\n        }\n        for (int k = nct - 1; k >= 0; k--) {\n            if (singularValues[k] != 0) {\n                for (int j = k + 1; j < n; j++) {\n                    double t = 0;\n                    for (int i = k; i < m; i++) {\n                        t += U[i][k] * U[i][j];\n                    }\n                    t = -t / U[k][k];\n                    for (int i = k; i < m; i++) {\n                        U[i][j] += t * U[i][k];\n                    }\n                }\n                for (int i = k; i < m; i++) {\n                    U[i][k] = -U[i][k];\n                }\n                U[k][k] = 1 + U[k][k];\n                for (int i = 0; i < k - 1; i++) {\n                    U[i][k] = 0;\n                }\n            } else {\n                for (int i = 0; i < m; i++) {\n                    U[i][k] = 0;\n                }\n                U[k][k] = 1;\n            }\n        }\n\n        // Generate V.\n        for (int k = n - 1; k >= 0; k--) {\n            if (k < nrt &&\n                e[k] != 0) {\n                for (int j = k + 1; j < n; j++) {\n                    double t = 0;\n                    for (int i = k + 1; i < n; i++) {\n                        t += V[i][k] * V[i][j];\n                    }\n                    t = -t / V[k + 1][k];\n                    for (int i = k + 1; i < n; i++) {\n                        V[i][j] += t * V[i][k];\n                    }\n                }\n            }\n            for (int i = 0; i < n; i++) {\n                V[i][k] = 0;\n            }\n            V[k][k] = 1;\n        }\n\n        // Main iteration loop for the singular values.\n        final int pp = p - 1;\n        int iter = 0;\n        while (p > 0) {\n            int k;\n            int kase;\n            // Here is where a test for too many iterations would go.\n            // This section of the program inspects for\n            // negligible elements in the s and e arrays.  On\n            // completion the variables kase and k are set as follows.\n            // kase = 1     if s(p) and e[k-1] are negligible and k<p\n            // kase = 2     if s(k) is negligible and k<p\n            // kase = 3     if e[k-1] is negligible, k<p, and\n            //              s(k), ..., s(p) are not negligible (qr step).\n            // kase = 4     if e(p-1) is negligible (convergence).\n            for (k = p - 2; k >= 0; k--) {\n                final double threshold\n                    = TINY + EPS * (FastMath.abs(singularValues[k]) +\n                                    FastMath.abs(singularValues[k + 1]));\n\n                // the following condition is written this way in order\n                // to break out of the loop when NaN occurs, writing it\n                // as \"if (FastMath.abs(e[k]) <= threshold)\" would loop\n                // indefinitely in case of NaNs because comparison on NaNs\n                // always return false, regardless of what is checked\n                // see issue MATH-947\n                if (!(FastMath.abs(e[k]) > threshold)) {\n                    e[k] = 0;\n                    break;\n                }\n\n            }\n\n            if (k == p - 2) {\n                kase = 4;\n            } else {\n                int ks;\n                for (ks = p - 1; ks >= k; ks--) {\n                    if (ks == k) {\n                        break;\n                    }\n                    final double t = (ks != p ? FastMath.abs(e[ks]) : 0) +\n                        (ks != k + 1 ? FastMath.abs(e[ks - 1]) : 0);\n                    if (FastMath.abs(singularValues[ks]) <= TINY + EPS * t) {\n                        singularValues[ks] = 0;\n                        break;\n                    }\n                }\n                if (ks == k) {\n                    kase = 3;\n                } else if (ks == p - 1) {\n                    kase = 1;\n                } else {\n                    kase = 2;\n                    k = ks;\n                }\n            }\n            k++;\n            // Perform the task indicated by kase.\n            switch (kase) {\n                // Deflate negligible s(p).\n                case 1: {\n                    double f = e[p - 2];\n                    e[p - 2] = 0;\n                    for (int j = p - 2; j >= k; j--) {\n                        double t = FastMath.hypot(singularValues[j], f);\n                        final double cs = singularValues[j] / t;\n                        final double sn = f / t;\n                        singularValues[j] = t;\n                        if (j != k) {\n                            f = -sn * e[j - 1];\n                            e[j - 1] = cs * e[j - 1];\n                        }\n\n                        for (int i = 0; i < n; i++) {\n                            t = cs * V[i][j] + sn * V[i][p - 1];\n                            V[i][p - 1] = -sn * V[i][j] + cs * V[i][p - 1];\n                            V[i][j] = t;\n                        }\n                    }\n                }\n                break;\n                // Split at negligible s(k).\n                case 2: {\n                    double f = e[k - 1];\n                    e[k - 1] = 0;\n                    for (int j = k; j < p; j++) {\n                        double t = FastMath.hypot(singularValues[j], f);\n                        final double cs = singularValues[j] / t;\n                        final double sn = f / t;\n                        singularValues[j] = t;\n                        f = -sn * e[j];\n                        e[j] = cs * e[j];\n\n                        for (int i = 0; i < m; i++) {\n                            t = cs * U[i][j] + sn * U[i][k - 1];\n                            U[i][k - 1] = -sn * U[i][j] + cs * U[i][k - 1];\n                            U[i][j] = t;\n                        }\n                    }\n                }\n                break;\n                // Perform one qr step.\n                case 3: {\n                    // Calculate the shift.\n                    final double maxPm1Pm2 = FastMath.max(FastMath.abs(singularValues[p - 1]),\n                                                          FastMath.abs(singularValues[p - 2]));\n                    final double scale = FastMath.max(FastMath.max(FastMath.max(maxPm1Pm2,\n                                                                                FastMath.abs(e[p - 2])),\n                                                                   FastMath.abs(singularValues[k])),\n                                                      FastMath.abs(e[k]));\n                    final double sp = singularValues[p - 1] / scale;\n                    final double spm1 = singularValues[p - 2] / scale;\n                    final double epm1 = e[p - 2] / scale;\n                    final double sk = singularValues[k] / scale;\n                    final double ek = e[k] / scale;\n                    final double b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2.0;\n                    final double c = (sp * epm1) * (sp * epm1);\n                    double shift = 0;\n                    if (b != 0 ||\n                        c != 0) {\n                        shift = FastMath.sqrt(b * b + c);\n                        if (b < 0) {\n                            shift = -shift;\n                        }\n                        shift = c / (b + shift);\n                    }\n                    double f = (sk + sp) * (sk - sp) + shift;\n                    double g = sk * ek;\n                    // Chase zeros.\n                    for (int j = k; j < p - 1; j++) {\n                        double t = FastMath.hypot(f, g);\n                        double cs = f / t;\n                        double sn = g / t;\n                        if (j != k) {\n                            e[j - 1] = t;\n                        }\n                        f = cs * singularValues[j] + sn * e[j];\n                        e[j] = cs * e[j] - sn * singularValues[j];\n                        g = sn * singularValues[j + 1];\n                        singularValues[j + 1] = cs * singularValues[j + 1];\n\n                        for (int i = 0; i < n; i++) {\n                            t = cs * V[i][j] + sn * V[i][j + 1];\n                            V[i][j + 1] = -sn * V[i][j] + cs * V[i][j + 1];\n                            V[i][j] = t;\n                        }\n                        t = FastMath.hypot(f, g);\n                        cs = f / t;\n                        sn = g / t;\n                        singularValues[j] = t;\n                        f = cs * e[j] + sn * singularValues[j + 1];\n                        singularValues[j + 1] = -sn * e[j] + cs * singularValues[j + 1];\n                        g = sn * e[j + 1];\n                        e[j + 1] = cs * e[j + 1];\n                        if (j < m - 1) {\n                            for (int i = 0; i < m; i++) {\n                                t = cs * U[i][j] + sn * U[i][j + 1];\n                                U[i][j + 1] = -sn * U[i][j] + cs * U[i][j + 1];\n                                U[i][j] = t;\n                            }\n                        }\n                    }\n                    e[p - 2] = f;\n                    iter = iter + 1;\n                }\n                break;\n                // Convergence.\n                default: {\n                    // Make the singular values positive.\n                    if (singularValues[k] <= 0) {\n                        singularValues[k] = singularValues[k] < 0 ? -singularValues[k] : 0;\n\n                        for (int i = 0; i <= pp; i++) {\n                            V[i][k] = -V[i][k];\n                        }\n                    }\n                    // Order the singular values.\n                    while (k < pp) {\n                        if (singularValues[k] >= singularValues[k + 1]) {\n                            break;\n                        }\n                        double t = singularValues[k];\n                        singularValues[k] = singularValues[k + 1];\n                        singularValues[k + 1] = t;\n                        if (k < n - 1) {\n                            for (int i = 0; i < n; i++) {\n                                t = V[i][k + 1];\n                                V[i][k + 1] = V[i][k];\n                                V[i][k] = t;\n                            }\n                        }\n                        if (k < m - 1) {\n                            for (int i = 0; i < m; i++) {\n                                t = U[i][k + 1];\n                                U[i][k + 1] = U[i][k];\n                                U[i][k] = t;\n                            }\n                        }\n                        k++;\n                    }\n                    iter = 0;\n                    p--;\n                }\n                break;\n            }\n        }\n\n        // Set the small value tolerance used to calculate rank and pseudo-inverse\n        tol = FastMath.max(m * singularValues[0] * EPS,\n                           FastMath.sqrt(Precision.SAFE_MIN));\n\n        if (!transposed) {\n            cachedU = MatrixUtils.createRealMatrix(U);\n            cachedV = MatrixUtils.createRealMatrix(V);\n        } else {\n            cachedU = MatrixUtils.createRealMatrix(V);\n            cachedV = MatrixUtils.createRealMatrix(U);\n        }\n    }",
          "29": "    public SingularValueDecomposition(final RealMatrix matrix) {\n        final double[][] A;\n\n         // \"m\" is always the largest dimension.\n        if (matrix.getRowDimension() < matrix.getColumnDimension()) {\n            transposed = true;\n            A = matrix.transpose().getData();\n            m = matrix.getColumnDimension();\n            n = matrix.getRowDimension();\n        } else {\n            transposed = false;\n            A = matrix.getData();\n            m = matrix.getRowDimension();\n            n = matrix.getColumnDimension();\n        }\n\n        singularValues = new double[n];\n        final double[][] U = new double[m][n];\n        final double[][] V = new double[n][n];\n        final double[] e = new double[n];\n        final double[] work = new double[m];\n        // Reduce A to bidiagonal form, storing the diagonal elements\n        // in s and the super-diagonal elements in e.\n        final int nct = FastMath.min(m - 1, n);\n        final int nrt = FastMath.max(0, n - 2);\n        for (int k = 0; k < FastMath.max(nct, nrt); k++) {\n            if (k < nct) {\n                // Compute the transformation for the k-th column and\n                // place the k-th diagonal in s[k].\n                // Compute 2-norm of k-th column without under/overflow.\n                singularValues[k] = 0;\n                for (int i = k; i < m; i++) {\n                    singularValues[k] = FastMath.hypot(singularValues[k], A[i][k]);\n                }\n                if (singularValues[k] != 0) {\n                    if (A[k][k] < 0) {\nsingularValues[k] = singularValues[i].[k];\n                    }\n                    for (int i = k; i < m; i++) {\n                        A[i][k] /= singularValues[k];\n                    }\n                    A[k][k] += 1;\n                }\n                singularValues[k] = -singularValues[k];\n            }\n            for (int j = k + 1; j < n; j++) {\n                if (k < nct &&\n                    singularValues[k] != 0) {\n                    // Apply the transformation.\n                    double t = 0;\n                    for (int i = k; i < m; i++) {\n                        t += A[i][k] * A[i][j];\n                    }\n                    t = -t / A[k][k];\n                    for (int i = k; i < m; i++) {\n                        A[i][j] += t * A[i][k];\n                    }\n                }\n                // Place the k-th row of A into e for the\n                // subsequent calculation of the row transformation.\n                e[j] = A[k][j];\n            }\n            if (k < nct) {\n                // Place the transformation in U for subsequent back\n                // multiplication.\n                for (int i = k; i < m; i++) {\n                    U[i][k] = A[i][k];\n                }\n            }\n            if (k < nrt) {\n                // Compute the k-th row transformation and place the\n                // k-th super-diagonal in e[k].\n                // Compute 2-norm without under/overflow.\n                e[k] = 0;\n                for (int i = k + 1; i < n; i++) {\n                    e[k] = FastMath.hypot(e[k], e[i]);\n                }\n                if (e[k] != 0) {\n                    if (e[k + 1] < 0) {\n                        e[k] = -e[k];\n                    }\n                    for (int i = k + 1; i < n; i++) {\n                        e[i] /= e[k];\n                    }\n                    e[k + 1] += 1;\n                }\n                e[k] = -e[k];\n                if (k + 1 < m &&\n                    e[k] != 0) {\n                    // Apply the transformation.\n                    for (int i = k + 1; i < m; i++) {\n                        work[i] = 0;\n                    }\n                    for (int j = k + 1; j < n; j++) {\n                        for (int i = k + 1; i < m; i++) {\n                            work[i] += e[j] * A[i][j];\n                        }\n                    }\n                    for (int j = k + 1; j < n; j++) {\n                        final double t = -e[j] / e[k + 1];\n                        for (int i = k + 1; i < m; i++) {\n                            A[i][j] += t * work[i];\n                        }\n                    }\n                }\n\n                // Place the transformation in V for subsequent\n                // back multiplication.\n                for (int i = k + 1; i < n; i++) {\n                    V[i][k] = e[i];\n                }\n            }\n        }\n        // Set up the final bidiagonal matrix or order p.\n        int p = n;\n        if (nct < n) {\n            singularValues[nct] = A[nct][nct];\n        }\n        if (m < p) {\n            singularValues[p - 1] = 0;\n        }\n        if (nrt + 1 < p) {\n            e[nrt] = A[nrt][p - 1];\n        }\n        e[p - 1] = 0;\n\n        // Generate U.\n        for (int j = nct; j < n; j++) {\n            for (int i = 0; i < m; i++) {\n                U[i][j] = 0;\n            }\n            U[j][j] = 1;\n        }\n        for (int k = nct - 1; k >= 0; k--) {\n            if (singularValues[k] != 0) {\n                for (int j = k + 1; j < n; j++) {\n                    double t = 0;\n                    for (int i = k; i < m; i++) {\n                        t += U[i][k] * U[i][j];\n                    }\n                    t = -t / U[k][k];\n                    for (int i = k; i < m; i++) {\n                        U[i][j] += t * U[i][k];\n                    }\n                }\n                for (int i = k; i < m; i++) {\n                    U[i][k] = -U[i][k];\n                }\n                U[k][k] = 1 + U[k][k];\n                for (int i = 0; i < k - 1; i++) {\n                    U[i][k] = 0;\n                }\n            } else {\n                for (int i = 0; i < m; i++) {\n                    U[i][k] = 0;\n                }\n                U[k][k] = 1;\n            }\n        }\n\n        // Generate V.\n        for (int k = n - 1; k >= 0; k--) {\n            if (k < nrt &&\n                e[k] != 0) {\n                for (int j = k + 1; j < n; j++) {\n                    double t = 0;\n                    for (int i = k + 1; i < n; i++) {\n                        t += V[i][k] * V[i][j];\n                    }\n                    t = -t / V[k + 1][k];\n                    for (int i = k + 1; i < n; i++) {\n                        V[i][j] += t * V[i][k];\n                    }\n                }\n            }\n            for (int i = 0; i < n; i++) {\n                V[i][k] = 0;\n            }\n            V[k][k] = 1;\n        }\n\n        // Main iteration loop for the singular values.\n        final int pp = p - 1;\n        int iter = 0;\n        while (p > 0) {\n            int k;\n            int kase;\n            // Here is where a test for too many iterations would go.\n            // This section of the program inspects for\n            // negligible elements in the s and e arrays.  On\n            // completion the variables kase and k are set as follows.\n            // kase = 1     if s(p) and e[k-1] are negligible and k<p\n            // kase = 2     if s(k) is negligible and k<p\n            // kase = 3     if e[k-1] is negligible, k<p, and\n            //              s(k), ..., s(p) are not negligible (qr step).\n            // kase = 4     if e(p-1) is negligible (convergence).\n            for (k = p - 2; k >= 0; k--) {\n                final double threshold\n                    = TINY + EPS * (FastMath.abs(singularValues[k]) +\n                                    FastMath.abs(singularValues[k + 1]));\n\n                // the following condition is written this way in order\n                // to break out of the loop when NaN occurs, writing it\n                // as \"if (FastMath.abs(e[k]) <= threshold)\" would loop\n                // indefinitely in case of NaNs because comparison on NaNs\n                // always return false, regardless of what is checked\n                // see issue MATH-947\n                if (!(FastMath.abs(e[k]) > threshold)) {\n                    e[k] = 0;\n                    break;\n                }\n\n            }\n\n            if (k == p - 2) {\n                kase = 4;\n            } else {\n                int ks;\n                for (ks = p - 1; ks >= k; ks--) {\n                    if (ks == k) {\n                        break;\n                    }\n                    final double t = (ks != p ? FastMath.abs(e[ks]) : 0) +\n                        (ks != k + 1 ? FastMath.abs(e[ks - 1]) : 0);\n                    if (FastMath.abs(singularValues[ks]) <= TINY + EPS * t) {\n                        singularValues[ks] = 0;\n                        break;\n                    }\n                }\n                if (ks == k) {\n                    kase = 3;\n                } else if (ks == p - 1) {\n                    kase = 1;\n                } else {\n                    kase = 2;\n                    k = ks;\n                }\n            }\n            k++;\n            // Perform the task indicated by kase.\n            switch (kase) {\n                // Deflate negligible s(p).\n                case 1: {\n                    double f = e[p - 2];\n                    e[p - 2] = 0;\n                    for (int j = p - 2; j >= k; j--) {\n                        double t = FastMath.hypot(singularValues[j], f);\n                        final double cs = singularValues[j] / t;\n                        final double sn = f / t;\n                        singularValues[j] = t;\n                        if (j != k) {\n                            f = -sn * e[j - 1];\n                            e[j - 1] = cs * e[j - 1];\n                        }\n\n                        for (int i = 0; i < n; i++) {\n                            t = cs * V[i][j] + sn * V[i][p - 1];\n                            V[i][p - 1] = -sn * V[i][j] + cs * V[i][p - 1];\n                            V[i][j] = t;\n                        }\n                    }\n                }\n                break;\n                // Split at negligible s(k).\n                case 2: {\n                    double f = e[k - 1];\n                    e[k - 1] = 0;\n                    for (int j = k; j < p; j++) {\n                        double t = FastMath.hypot(singularValues[j], f);\n                        final double cs = singularValues[j] / t;\n                        final double sn = f / t;\n                        singularValues[j] = t;\n                        f = -sn * e[j];\n                        e[j] = cs * e[j];\n\n                        for (int i = 0; i < m; i++) {\n                            t = cs * U[i][j] + sn * U[i][k - 1];\n                            U[i][k - 1] = -sn * U[i][j] + cs * U[i][k - 1];\n                            U[i][j] = t;\n                        }\n                    }\n                }\n                break;\n                // Perform one qr step.\n                case 3: {\n                    // Calculate the shift.\n                    final double maxPm1Pm2 = FastMath.max(FastMath.abs(singularValues[p - 1]),\n                                                          FastMath.abs(singularValues[p - 2]));\n                    final double scale = FastMath.max(FastMath.max(FastMath.max(maxPm1Pm2,\n                                                                                FastMath.abs(e[p - 2])),\n                                                                   FastMath.abs(singularValues[k])),\n                                                      FastMath.abs(e[k]));\n                    final double sp = singularValues[p - 1] / scale;\n                    final double spm1 = singularValues[p - 2] / scale;\n                    final double epm1 = e[p - 2] / scale;\n                    final double sk = singularValues[k] / scale;\n                    final double ek = e[k] / scale;\n                    final double b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2.0;\n                    final double c = (sp * epm1) * (sp * epm1);\n                    double shift = 0;\n                    if (b != 0 ||\n                        c != 0) {\n                        shift = FastMath.sqrt(b * b + c);\n                        if (b < 0) {\n                            shift = -shift;\n                        }\n                        shift = c / (b + shift);\n                    }\n                    double f = (sk + sp) * (sk - sp) + shift;\n                    double g = sk * ek;\n                    // Chase zeros.\n                    for (int j = k; j < p - 1; j++) {\n                        double t = FastMath.hypot(f, g);\n                        double cs = f / t;\n                        double sn = g / t;\n                        if (j != k) {\n                            e[j - 1] = t;\n                        }\n                        f = cs * singularValues[j] + sn * e[j];\n                        e[j] = cs * e[j] - sn * singularValues[j];\n                        g = sn * singularValues[j + 1];\n                        singularValues[j + 1] = cs * singularValues[j + 1];\n\n                        for (int i = 0; i < n; i++) {\n                            t = cs * V[i][j] + sn * V[i][j + 1];\n                            V[i][j + 1] = -sn * V[i][j] + cs * V[i][j + 1];\n                            V[i][j] = t;\n                        }\n                        t = FastMath.hypot(f, g);\n                        cs = f / t;\n                        sn = g / t;\n                        singularValues[j] = t;\n                        f = cs * e[j] + sn * singularValues[j + 1];\n                        singularValues[j + 1] = -sn * e[j] + cs * singularValues[j + 1];\n                        g = sn * e[j + 1];\n                        e[j + 1] = cs * e[j + 1];\n                        if (j < m - 1) {\n                            for (int i = 0; i < m; i++) {\n                                t = cs * U[i][j] + sn * U[i][j + 1];\n                                U[i][j + 1] = -sn * U[i][j] + cs * U[i][j + 1];\n                                U[i][j] = t;\n                            }\n                        }\n                    }\n                    e[p - 2] = f;\n                    iter = iter + 1;\n                }\n                break;\n                // Convergence.\n                default: {\n                    // Make the singular values positive.\n                    if (singularValues[k] <= 0) {\n                        singularValues[k] = singularValues[k] < 0 ? -singularValues[k] : 0;\n\n                        for (int i = 0; i <= pp; i++) {\n                            V[i][k] = -V[i][k];\n                        }\n                    }\n                    // Order the singular values.\n                    while (k < pp) {\n                        if (singularValues[k] >= singularValues[k + 1]) {\n                            break;\n                        }\n                        double t = singularValues[k];\n                        singularValues[k] = singularValues[k + 1];\n                        singularValues[k + 1] = t;\n                        if (k < n - 1) {\n                            for (int i = 0; i < n; i++) {\n                                t = V[i][k + 1];\n                                V[i][k + 1] = V[i][k];\n                                V[i][k] = t;\n                            }\n                        }\n                        if (k < m - 1) {\n                            for (int i = 0; i < m; i++) {\n                                t = U[i][k + 1];\n                                U[i][k + 1] = U[i][k];\n                                U[i][k] = t;\n                            }\n                        }\n                        k++;\n                    }\n                    iter = 0;\n                    p--;\n                }\n                break;\n            }\n        }\n\n        // Set the small value tolerance used to calculate rank and pseudo-inverse\n        tol = FastMath.max(m * singularValues[0] * EPS,\n                           FastMath.sqrt(Precision.SAFE_MIN));\n\n        if (!transposed) {\n            cachedU = MatrixUtils.createRealMatrix(U);\n            cachedV = MatrixUtils.createRealMatrix(V);\n        } else {\n            cachedU = MatrixUtils.createRealMatrix(V);\n            cachedV = MatrixUtils.createRealMatrix(U);\n        }\n    }",
          "30": "    public SingularValueDecomposition(final RealMatrix matrix) {\n        final double[][] A;\n\n         // \"m\" is always the largest dimension.\n        if (matrix.getRowDimension() < matrix.getColumnDimension()) {\n            transposed = true;\n            A = matrix.transpose().getData();\n            m = matrix.getColumnDimension();\n            n = matrix.getRowDimension();\n        } else {\n            transposed = false;\n            A = matrix.getData();\n            m = matrix.getRowDimension();\n            n = matrix.getColumnDimension();\n        }\n\n        singularValues = new double[n];\n        final double[][] U = new double[m][n];\n        final double[][] V = new double[n][n];\n        final double[] e = new double[n];\n        final double[] work = new double[m];\n        // Reduce A to bidiagonal form, storing the diagonal elements\n        // in s and the super-diagonal elements in e.\n        final int nct = FastMath.min(m - 1, n);\n        final int nrt = FastMath.max(0, n - 2);\n        for (int k = 0; k < FastMath.max(nct, nrt); k++) {\n            if (k < nct) {\n                // Compute the transformation for the k-th column and\n                // place the k-th diagonal in s[k].\n                // Compute 2-norm of k-th column without under/overflow.\n                singularValues[k] = 0;\n                for (int i = k; i < m; i++) {\n                    singularValues[k] = FastMath.hypot(singularValues[k], A[i][k]);\n                }\n                if (singularValues[k] != 0) {\n                    if (A[k][k] < 0) {\nsingularValues[k] = tol[i].[k];\n                    }\n                    for (int i = k; i < m; i++) {\n                        A[i][k] /= singularValues[k];\n                    }\n                    A[k][k] += 1;\n                }\n                singularValues[k] = -singularValues[k];\n            }\n            for (int j = k + 1; j < n; j++) {\n                if (k < nct &&\n                    singularValues[k] != 0) {\n                    // Apply the transformation.\n                    double t = 0;\n                    for (int i = k; i < m; i++) {\n                        t += A[i][k] * A[i][j];\n                    }\n                    t = -t / A[k][k];\n                    for (int i = k; i < m; i++) {\n                        A[i][j] += t * A[i][k];\n                    }\n                }\n                // Place the k-th row of A into e for the\n                // subsequent calculation of the row transformation.\n                e[j] = A[k][j];\n            }\n            if (k < nct) {\n                // Place the transformation in U for subsequent back\n                // multiplication.\n                for (int i = k; i < m; i++) {\n                    U[i][k] = A[i][k];\n                }\n            }\n            if (k < nrt) {\n                // Compute the k-th row transformation and place the\n                // k-th super-diagonal in e[k].\n                // Compute 2-norm without under/overflow.\n                e[k] = 0;\n                for (int i = k + 1; i < n; i++) {\n                    e[k] = FastMath.hypot(e[k], e[i]);\n                }\n                if (e[k] != 0) {\n                    if (e[k + 1] < 0) {\n                        e[k] = -e[k];\n                    }\n                    for (int i = k + 1; i < n; i++) {\n                        e[i] /= e[k];\n                    }\n                    e[k + 1] += 1;\n                }\n                e[k] = -e[k];\n                if (k + 1 < m &&\n                    e[k] != 0) {\n                    // Apply the transformation.\n                    for (int i = k + 1; i < m; i++) {\n                        work[i] = 0;\n                    }\n                    for (int j = k + 1; j < n; j++) {\n                        for (int i = k + 1; i < m; i++) {\n                            work[i] += e[j] * A[i][j];\n                        }\n                    }\n                    for (int j = k + 1; j < n; j++) {\n                        final double t = -e[j] / e[k + 1];\n                        for (int i = k + 1; i < m; i++) {\n                            A[i][j] += t * work[i];\n                        }\n                    }\n                }\n\n                // Place the transformation in V for subsequent\n                // back multiplication.\n                for (int i = k + 1; i < n; i++) {\n                    V[i][k] = e[i];\n                }\n            }\n        }\n        // Set up the final bidiagonal matrix or order p.\n        int p = n;\n        if (nct < n) {\n            singularValues[nct] = A[nct][nct];\n        }\n        if (m < p) {\n            singularValues[p - 1] = 0;\n        }\n        if (nrt + 1 < p) {\n            e[nrt] = A[nrt][p - 1];\n        }\n        e[p - 1] = 0;\n\n        // Generate U.\n        for (int j = nct; j < n; j++) {\n            for (int i = 0; i < m; i++) {\n                U[i][j] = 0;\n            }\n            U[j][j] = 1;\n        }\n        for (int k = nct - 1; k >= 0; k--) {\n            if (singularValues[k] != 0) {\n                for (int j = k + 1; j < n; j++) {\n                    double t = 0;\n                    for (int i = k; i < m; i++) {\n                        t += U[i][k] * U[i][j];\n                    }\n                    t = -t / U[k][k];\n                    for (int i = k; i < m; i++) {\n                        U[i][j] += t * U[i][k];\n                    }\n                }\n                for (int i = k; i < m; i++) {\n                    U[i][k] = -U[i][k];\n                }\n                U[k][k] = 1 + U[k][k];\n                for (int i = 0; i < k - 1; i++) {\n                    U[i][k] = 0;\n                }\n            } else {\n                for (int i = 0; i < m; i++) {\n                    U[i][k] = 0;\n                }\n                U[k][k] = 1;\n            }\n        }\n\n        // Generate V.\n        for (int k = n - 1; k >= 0; k--) {\n            if (k < nrt &&\n                e[k] != 0) {\n                for (int j = k + 1; j < n; j++) {\n                    double t = 0;\n                    for (int i = k + 1; i < n; i++) {\n                        t += V[i][k] * V[i][j];\n                    }\n                    t = -t / V[k + 1][k];\n                    for (int i = k + 1; i < n; i++) {\n                        V[i][j] += t * V[i][k];\n                    }\n                }\n            }\n            for (int i = 0; i < n; i++) {\n                V[i][k] = 0;\n            }\n            V[k][k] = 1;\n        }\n\n        // Main iteration loop for the singular values.\n        final int pp = p - 1;\n        int iter = 0;\n        while (p > 0) {\n            int k;\n            int kase;\n            // Here is where a test for too many iterations would go.\n            // This section of the program inspects for\n            // negligible elements in the s and e arrays.  On\n            // completion the variables kase and k are set as follows.\n            // kase = 1     if s(p) and e[k-1] are negligible and k<p\n            // kase = 2     if s(k) is negligible and k<p\n            // kase = 3     if e[k-1] is negligible, k<p, and\n            //              s(k), ..., s(p) are not negligible (qr step).\n            // kase = 4     if e(p-1) is negligible (convergence).\n            for (k = p - 2; k >= 0; k--) {\n                final double threshold\n                    = TINY + EPS * (FastMath.abs(singularValues[k]) +\n                                    FastMath.abs(singularValues[k + 1]));\n\n                // the following condition is written this way in order\n                // to break out of the loop when NaN occurs, writing it\n                // as \"if (FastMath.abs(e[k]) <= threshold)\" would loop\n                // indefinitely in case of NaNs because comparison on NaNs\n                // always return false, regardless of what is checked\n                // see issue MATH-947\n                if (!(FastMath.abs(e[k]) > threshold)) {\n                    e[k] = 0;\n                    break;\n                }\n\n            }\n\n            if (k == p - 2) {\n                kase = 4;\n            } else {\n                int ks;\n                for (ks = p - 1; ks >= k; ks--) {\n                    if (ks == k) {\n                        break;\n                    }\n                    final double t = (ks != p ? FastMath.abs(e[ks]) : 0) +\n                        (ks != k + 1 ? FastMath.abs(e[ks - 1]) : 0);\n                    if (FastMath.abs(singularValues[ks]) <= TINY + EPS * t) {\n                        singularValues[ks] = 0;\n                        break;\n                    }\n                }\n                if (ks == k) {\n                    kase = 3;\n                } else if (ks == p - 1) {\n                    kase = 1;\n                } else {\n                    kase = 2;\n                    k = ks;\n                }\n            }\n            k++;\n            // Perform the task indicated by kase.\n            switch (kase) {\n                // Deflate negligible s(p).\n                case 1: {\n                    double f = e[p - 2];\n                    e[p - 2] = 0;\n                    for (int j = p - 2; j >= k; j--) {\n                        double t = FastMath.hypot(singularValues[j], f);\n                        final double cs = singularValues[j] / t;\n                        final double sn = f / t;\n                        singularValues[j] = t;\n                        if (j != k) {\n                            f = -sn * e[j - 1];\n                            e[j - 1] = cs * e[j - 1];\n                        }\n\n                        for (int i = 0; i < n; i++) {\n                            t = cs * V[i][j] + sn * V[i][p - 1];\n                            V[i][p - 1] = -sn * V[i][j] + cs * V[i][p - 1];\n                            V[i][j] = t;\n                        }\n                    }\n                }\n                break;\n                // Split at negligible s(k).\n                case 2: {\n                    double f = e[k - 1];\n                    e[k - 1] = 0;\n                    for (int j = k; j < p; j++) {\n                        double t = FastMath.hypot(singularValues[j], f);\n                        final double cs = singularValues[j] / t;\n                        final double sn = f / t;\n                        singularValues[j] = t;\n                        f = -sn * e[j];\n                        e[j] = cs * e[j];\n\n                        for (int i = 0; i < m; i++) {\n                            t = cs * U[i][j] + sn * U[i][k - 1];\n                            U[i][k - 1] = -sn * U[i][j] + cs * U[i][k - 1];\n                            U[i][j] = t;\n                        }\n                    }\n                }\n                break;\n                // Perform one qr step.\n                case 3: {\n                    // Calculate the shift.\n                    final double maxPm1Pm2 = FastMath.max(FastMath.abs(singularValues[p - 1]),\n                                                          FastMath.abs(singularValues[p - 2]));\n                    final double scale = FastMath.max(FastMath.max(FastMath.max(maxPm1Pm2,\n                                                                                FastMath.abs(e[p - 2])),\n                                                                   FastMath.abs(singularValues[k])),\n                                                      FastMath.abs(e[k]));\n                    final double sp = singularValues[p - 1] / scale;\n                    final double spm1 = singularValues[p - 2] / scale;\n                    final double epm1 = e[p - 2] / scale;\n                    final double sk = singularValues[k] / scale;\n                    final double ek = e[k] / scale;\n                    final double b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2.0;\n                    final double c = (sp * epm1) * (sp * epm1);\n                    double shift = 0;\n                    if (b != 0 ||\n                        c != 0) {\n                        shift = FastMath.sqrt(b * b + c);\n                        if (b < 0) {\n                            shift = -shift;\n                        }\n                        shift = c / (b + shift);\n                    }\n                    double f = (sk + sp) * (sk - sp) + shift;\n                    double g = sk * ek;\n                    // Chase zeros.\n                    for (int j = k; j < p - 1; j++) {\n                        double t = FastMath.hypot(f, g);\n                        double cs = f / t;\n                        double sn = g / t;\n                        if (j != k) {\n                            e[j - 1] = t;\n                        }\n                        f = cs * singularValues[j] + sn * e[j];\n                        e[j] = cs * e[j] - sn * singularValues[j];\n                        g = sn * singularValues[j + 1];\n                        singularValues[j + 1] = cs * singularValues[j + 1];\n\n                        for (int i = 0; i < n; i++) {\n                            t = cs * V[i][j] + sn * V[i][j + 1];\n                            V[i][j + 1] = -sn * V[i][j] + cs * V[i][j + 1];\n                            V[i][j] = t;\n                        }\n                        t = FastMath.hypot(f, g);\n                        cs = f / t;\n                        sn = g / t;\n                        singularValues[j] = t;\n                        f = cs * e[j] + sn * singularValues[j + 1];\n                        singularValues[j + 1] = -sn * e[j] + cs * singularValues[j + 1];\n                        g = sn * e[j + 1];\n                        e[j + 1] = cs * e[j + 1];\n                        if (j < m - 1) {\n                            for (int i = 0; i < m; i++) {\n                                t = cs * U[i][j] + sn * U[i][j + 1];\n                                U[i][j + 1] = -sn * U[i][j] + cs * U[i][j + 1];\n                                U[i][j] = t;\n                            }\n                        }\n                    }\n                    e[p - 2] = f;\n                    iter = iter + 1;\n                }\n                break;\n                // Convergence.\n                default: {\n                    // Make the singular values positive.\n                    if (singularValues[k] <= 0) {\n                        singularValues[k] = singularValues[k] < 0 ? -singularValues[k] : 0;\n\n                        for (int i = 0; i <= pp; i++) {\n                            V[i][k] = -V[i][k];\n                        }\n                    }\n                    // Order the singular values.\n                    while (k < pp) {\n                        if (singularValues[k] >= singularValues[k + 1]) {\n                            break;\n                        }\n                        double t = singularValues[k];\n                        singularValues[k] = singularValues[k + 1];\n                        singularValues[k + 1] = t;\n                        if (k < n - 1) {\n                            for (int i = 0; i < n; i++) {\n                                t = V[i][k + 1];\n                                V[i][k + 1] = V[i][k];\n                                V[i][k] = t;\n                            }\n                        }\n                        if (k < m - 1) {\n                            for (int i = 0; i < m; i++) {\n                                t = U[i][k + 1];\n                                U[i][k + 1] = U[i][k];\n                                U[i][k] = t;\n                            }\n                        }\n                        k++;\n                    }\n                    iter = 0;\n                    p--;\n                }\n                break;\n            }\n        }\n\n        // Set the small value tolerance used to calculate rank and pseudo-inverse\n        tol = FastMath.max(m * singularValues[0] * EPS,\n                           FastMath.sqrt(Precision.SAFE_MIN));\n\n        if (!transposed) {\n            cachedU = MatrixUtils.createRealMatrix(U);\n            cachedV = MatrixUtils.createRealMatrix(V);\n        } else {\n            cachedU = MatrixUtils.createRealMatrix(V);\n            cachedV = MatrixUtils.createRealMatrix(U);\n        }\n    }",
          "31": "    public SingularValueDecomposition(final RealMatrix matrix) {\n        final double[][] A;\n\n         // \"m\" is always the largest dimension.\n        if (matrix.getRowDimension() < matrix.getColumnDimension()) {\n            transposed = true;\n            A = matrix.transpose().getData();\n            m = matrix.getColumnDimension();\n            n = matrix.getRowDimension();\n        } else {\n            transposed = false;\n            A = matrix.getData();\n            m = matrix.getRowDimension();\n            n = matrix.getColumnDimension();\n        }\n\n        singularValues = new double[n];\n        final double[][] U = new double[m][n];\n        final double[][] V = new double[n][n];\n        final double[] e = new double[n];\n        final double[] work = new double[m];\n        // Reduce A to bidiagonal form, storing the diagonal elements\n        // in s and the super-diagonal elements in e.\n        final int nct = FastMath.min(m - 1, n);\n        final int nrt = FastMath.max(0, n - 2);\n        for (int k = 0; k < FastMath.max(nct, nrt); k++) {\n            if (k < nct) {\n                // Compute the transformation for the k-th column and\n                // place the k-th diagonal in s[k].\n                // Compute 2-norm of k-th column without under/overflow.\n                singularValues[k] = 0;\n                for (int i = k; i < m; i++) {\n                    singularValues[k] = FastMath.hypot(singularValues[k], A[i][k]);\n                }\n                if (singularValues[k] != 0) {\n                    if (A[k][k] < 0) {\nsingularValues[k] = FastMath.hypot(singularValues[k], A[i].[k]);\n                        singularValues[k] = +singularValues[k];                    }\n                    for (int i = k; i < m; i++) {\n                        A[i][k] /= singularValues[k];\n                    }\n                    A[k][k] += 1;\n                }\n                singularValues[k] = -singularValues[k];\n            }\n            for (int j = k + 1; j < n; j++) {\n                if (k < nct &&\n                    singularValues[k] != 0) {\n                    // Apply the transformation.\n                    double t = 0;\n                    for (int i = k; i < m; i++) {\n                        t += A[i][k] * A[i][j];\n                    }\n                    t = -t / A[k][k];\n                    for (int i = k; i < m; i++) {\n                        A[i][j] += t * A[i][k];\n                    }\n                }\n                // Place the k-th row of A into e for the\n                // subsequent calculation of the row transformation.\n                e[j] = A[k][j];\n            }\n            if (k < nct) {\n                // Place the transformation in U for subsequent back\n                // multiplication.\n                for (int i = k; i < m; i++) {\n                    U[i][k] = A[i][k];\n                }\n            }\n            if (k < nrt) {\n                // Compute the k-th row transformation and place the\n                // k-th super-diagonal in e[k].\n                // Compute 2-norm without under/overflow.\n                e[k] = 0;\n                for (int i = k + 1; i < n; i++) {\n                    e[k] = FastMath.hypot(e[k], e[i]);\n                }\n                if (e[k] != 0) {\n                    if (e[k + 1] < 0) {\n                        e[k] = -e[k];\n                    }\n                    for (int i = k + 1; i < n; i++) {\n                        e[i] /= e[k];\n                    }\n                    e[k + 1] += 1;\n                }\n                e[k] = -e[k];\n                if (k + 1 < m &&\n                    e[k] != 0) {\n                    // Apply the transformation.\n                    for (int i = k + 1; i < m; i++) {\n                        work[i] = 0;\n                    }\n                    for (int j = k + 1; j < n; j++) {\n                        for (int i = k + 1; i < m; i++) {\n                            work[i] += e[j] * A[i][j];\n                        }\n                    }\n                    for (int j = k + 1; j < n; j++) {\n                        final double t = -e[j] / e[k + 1];\n                        for (int i = k + 1; i < m; i++) {\n                            A[i][j] += t * work[i];\n                        }\n                    }\n                }\n\n                // Place the transformation in V for subsequent\n                // back multiplication.\n                for (int i = k + 1; i < n; i++) {\n                    V[i][k] = e[i];\n                }\n            }\n        }\n        // Set up the final bidiagonal matrix or order p.\n        int p = n;\n        if (nct < n) {\n            singularValues[nct] = A[nct][nct];\n        }\n        if (m < p) {\n            singularValues[p - 1] = 0;\n        }\n        if (nrt + 1 < p) {\n            e[nrt] = A[nrt][p - 1];\n        }\n        e[p - 1] = 0;\n\n        // Generate U.\n        for (int j = nct; j < n; j++) {\n            for (int i = 0; i < m; i++) {\n                U[i][j] = 0;\n            }\n            U[j][j] = 1;\n        }\n        for (int k = nct - 1; k >= 0; k--) {\n            if (singularValues[k] != 0) {\n                for (int j = k + 1; j < n; j++) {\n                    double t = 0;\n                    for (int i = k; i < m; i++) {\n                        t += U[i][k] * U[i][j];\n                    }\n                    t = -t / U[k][k];\n                    for (int i = k; i < m; i++) {\n                        U[i][j] += t * U[i][k];\n                    }\n                }\n                for (int i = k; i < m; i++) {\n                    U[i][k] = -U[i][k];\n                }\n                U[k][k] = 1 + U[k][k];\n                for (int i = 0; i < k - 1; i++) {\n                    U[i][k] = 0;\n                }\n            } else {\n                for (int i = 0; i < m; i++) {\n                    U[i][k] = 0;\n                }\n                U[k][k] = 1;\n            }\n        }\n\n        // Generate V.\n        for (int k = n - 1; k >= 0; k--) {\n            if (k < nrt &&\n                e[k] != 0) {\n                for (int j = k + 1; j < n; j++) {\n                    double t = 0;\n                    for (int i = k + 1; i < n; i++) {\n                        t += V[i][k] * V[i][j];\n                    }\n                    t = -t / V[k + 1][k];\n                    for (int i = k + 1; i < n; i++) {\n                        V[i][j] += t * V[i][k];\n                    }\n                }\n            }\n            for (int i = 0; i < n; i++) {\n                V[i][k] = 0;\n            }\n            V[k][k] = 1;\n        }\n\n        // Main iteration loop for the singular values.\n        final int pp = p - 1;\n        int iter = 0;\n        while (p > 0) {\n            int k;\n            int kase;\n            // Here is where a test for too many iterations would go.\n            // This section of the program inspects for\n            // negligible elements in the s and e arrays.  On\n            // completion the variables kase and k are set as follows.\n            // kase = 1     if s(p) and e[k-1] are negligible and k<p\n            // kase = 2     if s(k) is negligible and k<p\n            // kase = 3     if e[k-1] is negligible, k<p, and\n            //              s(k), ..., s(p) are not negligible (qr step).\n            // kase = 4     if e(p-1) is negligible (convergence).\n            for (k = p - 2; k >= 0; k--) {\n                final double threshold\n                    = TINY + EPS * (FastMath.abs(singularValues[k]) +\n                                    FastMath.abs(singularValues[k + 1]));\n\n                // the following condition is written this way in order\n                // to break out of the loop when NaN occurs, writing it\n                // as \"if (FastMath.abs(e[k]) <= threshold)\" would loop\n                // indefinitely in case of NaNs because comparison on NaNs\n                // always return false, regardless of what is checked\n                // see issue MATH-947\n                if (!(FastMath.abs(e[k]) > threshold)) {\n                    e[k] = 0;\n                    break;\n                }\n\n            }\n\n            if (k == p - 2) {\n                kase = 4;\n            } else {\n                int ks;\n                for (ks = p - 1; ks >= k; ks--) {\n                    if (ks == k) {\n                        break;\n                    }\n                    final double t = (ks != p ? FastMath.abs(e[ks]) : 0) +\n                        (ks != k + 1 ? FastMath.abs(e[ks - 1]) : 0);\n                    if (FastMath.abs(singularValues[ks]) <= TINY + EPS * t) {\n                        singularValues[ks] = 0;\n                        break;\n                    }\n                }\n                if (ks == k) {\n                    kase = 3;\n                } else if (ks == p - 1) {\n                    kase = 1;\n                } else {\n                    kase = 2;\n                    k = ks;\n                }\n            }\n            k++;\n            // Perform the task indicated by kase.\n            switch (kase) {\n                // Deflate negligible s(p).\n                case 1: {\n                    double f = e[p - 2];\n                    e[p - 2] = 0;\n                    for (int j = p - 2; j >= k; j--) {\n                        double t = FastMath.hypot(singularValues[j], f);\n                        final double cs = singularValues[j] / t;\n                        final double sn = f / t;\n                        singularValues[j] = t;\n                        if (j != k) {\n                            f = -sn * e[j - 1];\n                            e[j - 1] = cs * e[j - 1];\n                        }\n\n                        for (int i = 0; i < n; i++) {\n                            t = cs * V[i][j] + sn * V[i][p - 1];\n                            V[i][p - 1] = -sn * V[i][j] + cs * V[i][p - 1];\n                            V[i][j] = t;\n                        }\n                    }\n                }\n                break;\n                // Split at negligible s(k).\n                case 2: {\n                    double f = e[k - 1];\n                    e[k - 1] = 0;\n                    for (int j = k; j < p; j++) {\n                        double t = FastMath.hypot(singularValues[j], f);\n                        final double cs = singularValues[j] / t;\n                        final double sn = f / t;\n                        singularValues[j] = t;\n                        f = -sn * e[j];\n                        e[j] = cs * e[j];\n\n                        for (int i = 0; i < m; i++) {\n                            t = cs * U[i][j] + sn * U[i][k - 1];\n                            U[i][k - 1] = -sn * U[i][j] + cs * U[i][k - 1];\n                            U[i][j] = t;\n                        }\n                    }\n                }\n                break;\n                // Perform one qr step.\n                case 3: {\n                    // Calculate the shift.\n                    final double maxPm1Pm2 = FastMath.max(FastMath.abs(singularValues[p - 1]),\n                                                          FastMath.abs(singularValues[p - 2]));\n                    final double scale = FastMath.max(FastMath.max(FastMath.max(maxPm1Pm2,\n                                                                                FastMath.abs(e[p - 2])),\n                                                                   FastMath.abs(singularValues[k])),\n                                                      FastMath.abs(e[k]));\n                    final double sp = singularValues[p - 1] / scale;\n                    final double spm1 = singularValues[p - 2] / scale;\n                    final double epm1 = e[p - 2] / scale;\n                    final double sk = singularValues[k] / scale;\n                    final double ek = e[k] / scale;\n                    final double b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2.0;\n                    final double c = (sp * epm1) * (sp * epm1);\n                    double shift = 0;\n                    if (b != 0 ||\n                        c != 0) {\n                        shift = FastMath.sqrt(b * b + c);\n                        if (b < 0) {\n                            shift = -shift;\n                        }\n                        shift = c / (b + shift);\n                    }\n                    double f = (sk + sp) * (sk - sp) + shift;\n                    double g = sk * ek;\n                    // Chase zeros.\n                    for (int j = k; j < p - 1; j++) {\n                        double t = FastMath.hypot(f, g);\n                        double cs = f / t;\n                        double sn = g / t;\n                        if (j != k) {\n                            e[j - 1] = t;\n                        }\n                        f = cs * singularValues[j] + sn * e[j];\n                        e[j] = cs * e[j] - sn * singularValues[j];\n                        g = sn * singularValues[j + 1];\n                        singularValues[j + 1] = cs * singularValues[j + 1];\n\n                        for (int i = 0; i < n; i++) {\n                            t = cs * V[i][j] + sn * V[i][j + 1];\n                            V[i][j + 1] = -sn * V[i][j] + cs * V[i][j + 1];\n                            V[i][j] = t;\n                        }\n                        t = FastMath.hypot(f, g);\n                        cs = f / t;\n                        sn = g / t;\n                        singularValues[j] = t;\n                        f = cs * e[j] + sn * singularValues[j + 1];\n                        singularValues[j + 1] = -sn * e[j] + cs * singularValues[j + 1];\n                        g = sn * e[j + 1];\n                        e[j + 1] = cs * e[j + 1];\n                        if (j < m - 1) {\n                            for (int i = 0; i < m; i++) {\n                                t = cs * U[i][j] + sn * U[i][j + 1];\n                                U[i][j + 1] = -sn * U[i][j] + cs * U[i][j + 1];\n                                U[i][j] = t;\n                            }\n                        }\n                    }\n                    e[p - 2] = f;\n                    iter = iter + 1;\n                }\n                break;\n                // Convergence.\n                default: {\n                    // Make the singular values positive.\n                    if (singularValues[k] <= 0) {\n                        singularValues[k] = singularValues[k] < 0 ? -singularValues[k] : 0;\n\n                        for (int i = 0; i <= pp; i++) {\n                            V[i][k] = -V[i][k];\n                        }\n                    }\n                    // Order the singular values.\n                    while (k < pp) {\n                        if (singularValues[k] >= singularValues[k + 1]) {\n                            break;\n                        }\n                        double t = singularValues[k];\n                        singularValues[k] = singularValues[k + 1];\n                        singularValues[k + 1] = t;\n                        if (k < n - 1) {\n                            for (int i = 0; i < n; i++) {\n                                t = V[i][k + 1];\n                                V[i][k + 1] = V[i][k];\n                                V[i][k] = t;\n                            }\n                        }\n                        if (k < m - 1) {\n                            for (int i = 0; i < m; i++) {\n                                t = U[i][k + 1];\n                                U[i][k + 1] = U[i][k];\n                                U[i][k] = t;\n                            }\n                        }\n                        k++;\n                    }\n                    iter = 0;\n                    p--;\n                }\n                break;\n            }\n        }\n\n        // Set the small value tolerance used to calculate rank and pseudo-inverse\n        tol = FastMath.max(m * singularValues[0] * EPS,\n                           FastMath.sqrt(Precision.SAFE_MIN));\n\n        if (!transposed) {\n            cachedU = MatrixUtils.createRealMatrix(U);\n            cachedV = MatrixUtils.createRealMatrix(V);\n        } else {\n            cachedU = MatrixUtils.createRealMatrix(V);\n            cachedV = MatrixUtils.createRealMatrix(U);\n        }\n    }",
          "32": "    public SingularValueDecomposition(final RealMatrix matrix) {\n        final double[][] A;\n\n         // \"m\" is always the largest dimension.\n        if (matrix.getRowDimension() < matrix.getColumnDimension()) {\n            transposed = true;\n            A = matrix.transpose().getData();\n            m = matrix.getColumnDimension();\n            n = matrix.getRowDimension();\n        } else {\n            transposed = false;\n            A = matrix.getData();\n            m = matrix.getRowDimension();\n            n = matrix.getColumnDimension();\n        }\n\n        singularValues = new double[n];\n        final double[][] U = new double[m][n];\n        final double[][] V = new double[n][n];\n        final double[] e = new double[n];\n        final double[] work = new double[m];\n        // Reduce A to bidiagonal form, storing the diagonal elements\n        // in s and the super-diagonal elements in e.\n        final int nct = FastMath.min(m - 1, n);\n        final int nrt = FastMath.max(0, n - 2);\n        for (int k = 0; k < FastMath.max(nct, nrt); k++) {\n            if (k < nct) {\n                // Compute the transformation for the k-th column and\n                // place the k-th diagonal in s[k].\n                // Compute 2-norm of k-th column without under/overflow.\n                singularValues[k] = 0;\n                for (int i = k; i < m; i++) {\n                    singularValues[k] = FastMath.hypot(singularValues[k], A[i][k]);\n                }\n                if (singularValues[k] != 0) {\n                    if (A[k][k] < 0) {\nif((A[k].[k] < 0)){\n}\n                        singularValues[k] = +singularValues[k];                    }\n                    for (int i = k; i < m; i++) {\n                        A[i][k] /= singularValues[k];\n                    }\n                    A[k][k] += 1;\n                }\n                singularValues[k] = -singularValues[k];\n            }\n            for (int j = k + 1; j < n; j++) {\n                if (k < nct &&\n                    singularValues[k] != 0) {\n                    // Apply the transformation.\n                    double t = 0;\n                    for (int i = k; i < m; i++) {\n                        t += A[i][k] * A[i][j];\n                    }\n                    t = -t / A[k][k];\n                    for (int i = k; i < m; i++) {\n                        A[i][j] += t * A[i][k];\n                    }\n                }\n                // Place the k-th row of A into e for the\n                // subsequent calculation of the row transformation.\n                e[j] = A[k][j];\n            }\n            if (k < nct) {\n                // Place the transformation in U for subsequent back\n                // multiplication.\n                for (int i = k; i < m; i++) {\n                    U[i][k] = A[i][k];\n                }\n            }\n            if (k < nrt) {\n                // Compute the k-th row transformation and place the\n                // k-th super-diagonal in e[k].\n                // Compute 2-norm without under/overflow.\n                e[k] = 0;\n                for (int i = k + 1; i < n; i++) {\n                    e[k] = FastMath.hypot(e[k], e[i]);\n                }\n                if (e[k] != 0) {\n                    if (e[k + 1] < 0) {\n                        e[k] = -e[k];\n                    }\n                    for (int i = k + 1; i < n; i++) {\n                        e[i] /= e[k];\n                    }\n                    e[k + 1] += 1;\n                }\n                e[k] = -e[k];\n                if (k + 1 < m &&\n                    e[k] != 0) {\n                    // Apply the transformation.\n                    for (int i = k + 1; i < m; i++) {\n                        work[i] = 0;\n                    }\n                    for (int j = k + 1; j < n; j++) {\n                        for (int i = k + 1; i < m; i++) {\n                            work[i] += e[j] * A[i][j];\n                        }\n                    }\n                    for (int j = k + 1; j < n; j++) {\n                        final double t = -e[j] / e[k + 1];\n                        for (int i = k + 1; i < m; i++) {\n                            A[i][j] += t * work[i];\n                        }\n                    }\n                }\n\n                // Place the transformation in V for subsequent\n                // back multiplication.\n                for (int i = k + 1; i < n; i++) {\n                    V[i][k] = e[i];\n                }\n            }\n        }\n        // Set up the final bidiagonal matrix or order p.\n        int p = n;\n        if (nct < n) {\n            singularValues[nct] = A[nct][nct];\n        }\n        if (m < p) {\n            singularValues[p - 1] = 0;\n        }\n        if (nrt + 1 < p) {\n            e[nrt] = A[nrt][p - 1];\n        }\n        e[p - 1] = 0;\n\n        // Generate U.\n        for (int j = nct; j < n; j++) {\n            for (int i = 0; i < m; i++) {\n                U[i][j] = 0;\n            }\n            U[j][j] = 1;\n        }\n        for (int k = nct - 1; k >= 0; k--) {\n            if (singularValues[k] != 0) {\n                for (int j = k + 1; j < n; j++) {\n                    double t = 0;\n                    for (int i = k; i < m; i++) {\n                        t += U[i][k] * U[i][j];\n                    }\n                    t = -t / U[k][k];\n                    for (int i = k; i < m; i++) {\n                        U[i][j] += t * U[i][k];\n                    }\n                }\n                for (int i = k; i < m; i++) {\n                    U[i][k] = -U[i][k];\n                }\n                U[k][k] = 1 + U[k][k];\n                for (int i = 0; i < k - 1; i++) {\n                    U[i][k] = 0;\n                }\n            } else {\n                for (int i = 0; i < m; i++) {\n                    U[i][k] = 0;\n                }\n                U[k][k] = 1;\n            }\n        }\n\n        // Generate V.\n        for (int k = n - 1; k >= 0; k--) {\n            if (k < nrt &&\n                e[k] != 0) {\n                for (int j = k + 1; j < n; j++) {\n                    double t = 0;\n                    for (int i = k + 1; i < n; i++) {\n                        t += V[i][k] * V[i][j];\n                    }\n                    t = -t / V[k + 1][k];\n                    for (int i = k + 1; i < n; i++) {\n                        V[i][j] += t * V[i][k];\n                    }\n                }\n            }\n            for (int i = 0; i < n; i++) {\n                V[i][k] = 0;\n            }\n            V[k][k] = 1;\n        }\n\n        // Main iteration loop for the singular values.\n        final int pp = p - 1;\n        int iter = 0;\n        while (p > 0) {\n            int k;\n            int kase;\n            // Here is where a test for too many iterations would go.\n            // This section of the program inspects for\n            // negligible elements in the s and e arrays.  On\n            // completion the variables kase and k are set as follows.\n            // kase = 1     if s(p) and e[k-1] are negligible and k<p\n            // kase = 2     if s(k) is negligible and k<p\n            // kase = 3     if e[k-1] is negligible, k<p, and\n            //              s(k), ..., s(p) are not negligible (qr step).\n            // kase = 4     if e(p-1) is negligible (convergence).\n            for (k = p - 2; k >= 0; k--) {\n                final double threshold\n                    = TINY + EPS * (FastMath.abs(singularValues[k]) +\n                                    FastMath.abs(singularValues[k + 1]));\n\n                // the following condition is written this way in order\n                // to break out of the loop when NaN occurs, writing it\n                // as \"if (FastMath.abs(e[k]) <= threshold)\" would loop\n                // indefinitely in case of NaNs because comparison on NaNs\n                // always return false, regardless of what is checked\n                // see issue MATH-947\n                if (!(FastMath.abs(e[k]) > threshold)) {\n                    e[k] = 0;\n                    break;\n                }\n\n            }\n\n            if (k == p - 2) {\n                kase = 4;\n            } else {\n                int ks;\n                for (ks = p - 1; ks >= k; ks--) {\n                    if (ks == k) {\n                        break;\n                    }\n                    final double t = (ks != p ? FastMath.abs(e[ks]) : 0) +\n                        (ks != k + 1 ? FastMath.abs(e[ks - 1]) : 0);\n                    if (FastMath.abs(singularValues[ks]) <= TINY + EPS * t) {\n                        singularValues[ks] = 0;\n                        break;\n                    }\n                }\n                if (ks == k) {\n                    kase = 3;\n                } else if (ks == p - 1) {\n                    kase = 1;\n                } else {\n                    kase = 2;\n                    k = ks;\n                }\n            }\n            k++;\n            // Perform the task indicated by kase.\n            switch (kase) {\n                // Deflate negligible s(p).\n                case 1: {\n                    double f = e[p - 2];\n                    e[p - 2] = 0;\n                    for (int j = p - 2; j >= k; j--) {\n                        double t = FastMath.hypot(singularValues[j], f);\n                        final double cs = singularValues[j] / t;\n                        final double sn = f / t;\n                        singularValues[j] = t;\n                        if (j != k) {\n                            f = -sn * e[j - 1];\n                            e[j - 1] = cs * e[j - 1];\n                        }\n\n                        for (int i = 0; i < n; i++) {\n                            t = cs * V[i][j] + sn * V[i][p - 1];\n                            V[i][p - 1] = -sn * V[i][j] + cs * V[i][p - 1];\n                            V[i][j] = t;\n                        }\n                    }\n                }\n                break;\n                // Split at negligible s(k).\n                case 2: {\n                    double f = e[k - 1];\n                    e[k - 1] = 0;\n                    for (int j = k; j < p; j++) {\n                        double t = FastMath.hypot(singularValues[j], f);\n                        final double cs = singularValues[j] / t;\n                        final double sn = f / t;\n                        singularValues[j] = t;\n                        f = -sn * e[j];\n                        e[j] = cs * e[j];\n\n                        for (int i = 0; i < m; i++) {\n                            t = cs * U[i][j] + sn * U[i][k - 1];\n                            U[i][k - 1] = -sn * U[i][j] + cs * U[i][k - 1];\n                            U[i][j] = t;\n                        }\n                    }\n                }\n                break;\n                // Perform one qr step.\n                case 3: {\n                    // Calculate the shift.\n                    final double maxPm1Pm2 = FastMath.max(FastMath.abs(singularValues[p - 1]),\n                                                          FastMath.abs(singularValues[p - 2]));\n                    final double scale = FastMath.max(FastMath.max(FastMath.max(maxPm1Pm2,\n                                                                                FastMath.abs(e[p - 2])),\n                                                                   FastMath.abs(singularValues[k])),\n                                                      FastMath.abs(e[k]));\n                    final double sp = singularValues[p - 1] / scale;\n                    final double spm1 = singularValues[p - 2] / scale;\n                    final double epm1 = e[p - 2] / scale;\n                    final double sk = singularValues[k] / scale;\n                    final double ek = e[k] / scale;\n                    final double b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2.0;\n                    final double c = (sp * epm1) * (sp * epm1);\n                    double shift = 0;\n                    if (b != 0 ||\n                        c != 0) {\n                        shift = FastMath.sqrt(b * b + c);\n                        if (b < 0) {\n                            shift = -shift;\n                        }\n                        shift = c / (b + shift);\n                    }\n                    double f = (sk + sp) * (sk - sp) + shift;\n                    double g = sk * ek;\n                    // Chase zeros.\n                    for (int j = k; j < p - 1; j++) {\n                        double t = FastMath.hypot(f, g);\n                        double cs = f / t;\n                        double sn = g / t;\n                        if (j != k) {\n                            e[j - 1] = t;\n                        }\n                        f = cs * singularValues[j] + sn * e[j];\n                        e[j] = cs * e[j] - sn * singularValues[j];\n                        g = sn * singularValues[j + 1];\n                        singularValues[j + 1] = cs * singularValues[j + 1];\n\n                        for (int i = 0; i < n; i++) {\n                            t = cs * V[i][j] + sn * V[i][j + 1];\n                            V[i][j + 1] = -sn * V[i][j] + cs * V[i][j + 1];\n                            V[i][j] = t;\n                        }\n                        t = FastMath.hypot(f, g);\n                        cs = f / t;\n                        sn = g / t;\n                        singularValues[j] = t;\n                        f = cs * e[j] + sn * singularValues[j + 1];\n                        singularValues[j + 1] = -sn * e[j] + cs * singularValues[j + 1];\n                        g = sn * e[j + 1];\n                        e[j + 1] = cs * e[j + 1];\n                        if (j < m - 1) {\n                            for (int i = 0; i < m; i++) {\n                                t = cs * U[i][j] + sn * U[i][j + 1];\n                                U[i][j + 1] = -sn * U[i][j] + cs * U[i][j + 1];\n                                U[i][j] = t;\n                            }\n                        }\n                    }\n                    e[p - 2] = f;\n                    iter = iter + 1;\n                }\n                break;\n                // Convergence.\n                default: {\n                    // Make the singular values positive.\n                    if (singularValues[k] <= 0) {\n                        singularValues[k] = singularValues[k] < 0 ? -singularValues[k] : 0;\n\n                        for (int i = 0; i <= pp; i++) {\n                            V[i][k] = -V[i][k];\n                        }\n                    }\n                    // Order the singular values.\n                    while (k < pp) {\n                        if (singularValues[k] >= singularValues[k + 1]) {\n                            break;\n                        }\n                        double t = singularValues[k];\n                        singularValues[k] = singularValues[k + 1];\n                        singularValues[k + 1] = t;\n                        if (k < n - 1) {\n                            for (int i = 0; i < n; i++) {\n                                t = V[i][k + 1];\n                                V[i][k + 1] = V[i][k];\n                                V[i][k] = t;\n                            }\n                        }\n                        if (k < m - 1) {\n                            for (int i = 0; i < m; i++) {\n                                t = U[i][k + 1];\n                                U[i][k + 1] = U[i][k];\n                                U[i][k] = t;\n                            }\n                        }\n                        k++;\n                    }\n                    iter = 0;\n                    p--;\n                }\n                break;\n            }\n        }\n\n        // Set the small value tolerance used to calculate rank and pseudo-inverse\n        tol = FastMath.max(m * singularValues[0] * EPS,\n                           FastMath.sqrt(Precision.SAFE_MIN));\n\n        if (!transposed) {\n            cachedU = MatrixUtils.createRealMatrix(U);\n            cachedV = MatrixUtils.createRealMatrix(V);\n        } else {\n            cachedU = MatrixUtils.createRealMatrix(V);\n            cachedV = MatrixUtils.createRealMatrix(U);\n        }\n    }",
          "33": "    public SingularValueDecomposition(final RealMatrix matrix) {\n        final double[][] A;\n\n         // \"m\" is always the largest dimension.\n        if (matrix.getRowDimension() < matrix.getColumnDimension()) {\n            transposed = true;\n            A = matrix.transpose().getData();\n            m = matrix.getColumnDimension();\n            n = matrix.getRowDimension();\n        } else {\n            transposed = false;\n            A = matrix.getData();\n            m = matrix.getRowDimension();\n            n = matrix.getColumnDimension();\n        }\n\n        singularValues = new double[n];\n        final double[][] U = new double[m][n];\n        final double[][] V = new double[n][n];\n        final double[] e = new double[n];\n        final double[] work = new double[m];\n        // Reduce A to bidiagonal form, storing the diagonal elements\n        // in s and the super-diagonal elements in e.\n        final int nct = FastMath.min(m - 1, n);\n        final int nrt = FastMath.max(0, n - 2);\n        for (int k = 0; k < FastMath.max(nct, nrt); k++) {\n            if (k < nct) {\n                // Compute the transformation for the k-th column and\n                // place the k-th diagonal in s[k].\n                // Compute 2-norm of k-th column without under/overflow.\n                singularValues[k] = 0;\n                for (int i = k; i < m; i++) {\n                    singularValues[k] = FastMath.hypot(singularValues[k], A[i][k]);\n                }\n                if (singularValues[k] != 0) {\n                    if (A[k][k] < 0) {\nsingularValues[k] = true;\n                    }\n                    for (int i = k; i < m; i++) {\n                        A[i][k] /= singularValues[k];\n                    }\n                    A[k][k] += 1;\n                }\n                singularValues[k] = -singularValues[k];\n            }\n            for (int j = k + 1; j < n; j++) {\n                if (k < nct &&\n                    singularValues[k] != 0) {\n                    // Apply the transformation.\n                    double t = 0;\n                    for (int i = k; i < m; i++) {\n                        t += A[i][k] * A[i][j];\n                    }\n                    t = -t / A[k][k];\n                    for (int i = k; i < m; i++) {\n                        A[i][j] += t * A[i][k];\n                    }\n                }\n                // Place the k-th row of A into e for the\n                // subsequent calculation of the row transformation.\n                e[j] = A[k][j];\n            }\n            if (k < nct) {\n                // Place the transformation in U for subsequent back\n                // multiplication.\n                for (int i = k; i < m; i++) {\n                    U[i][k] = A[i][k];\n                }\n            }\n            if (k < nrt) {\n                // Compute the k-th row transformation and place the\n                // k-th super-diagonal in e[k].\n                // Compute 2-norm without under/overflow.\n                e[k] = 0;\n                for (int i = k + 1; i < n; i++) {\n                    e[k] = FastMath.hypot(e[k], e[i]);\n                }\n                if (e[k] != 0) {\n                    if (e[k + 1] < 0) {\n                        e[k] = -e[k];\n                    }\n                    for (int i = k + 1; i < n; i++) {\n                        e[i] /= e[k];\n                    }\n                    e[k + 1] += 1;\n                }\n                e[k] = -e[k];\n                if (k + 1 < m &&\n                    e[k] != 0) {\n                    // Apply the transformation.\n                    for (int i = k + 1; i < m; i++) {\n                        work[i] = 0;\n                    }\n                    for (int j = k + 1; j < n; j++) {\n                        for (int i = k + 1; i < m; i++) {\n                            work[i] += e[j] * A[i][j];\n                        }\n                    }\n                    for (int j = k + 1; j < n; j++) {\n                        final double t = -e[j] / e[k + 1];\n                        for (int i = k + 1; i < m; i++) {\n                            A[i][j] += t * work[i];\n                        }\n                    }\n                }\n\n                // Place the transformation in V for subsequent\n                // back multiplication.\n                for (int i = k + 1; i < n; i++) {\n                    V[i][k] = e[i];\n                }\n            }\n        }\n        // Set up the final bidiagonal matrix or order p.\n        int p = n;\n        if (nct < n) {\n            singularValues[nct] = A[nct][nct];\n        }\n        if (m < p) {\n            singularValues[p - 1] = 0;\n        }\n        if (nrt + 1 < p) {\n            e[nrt] = A[nrt][p - 1];\n        }\n        e[p - 1] = 0;\n\n        // Generate U.\n        for (int j = nct; j < n; j++) {\n            for (int i = 0; i < m; i++) {\n                U[i][j] = 0;\n            }\n            U[j][j] = 1;\n        }\n        for (int k = nct - 1; k >= 0; k--) {\n            if (singularValues[k] != 0) {\n                for (int j = k + 1; j < n; j++) {\n                    double t = 0;\n                    for (int i = k; i < m; i++) {\n                        t += U[i][k] * U[i][j];\n                    }\n                    t = -t / U[k][k];\n                    for (int i = k; i < m; i++) {\n                        U[i][j] += t * U[i][k];\n                    }\n                }\n                for (int i = k; i < m; i++) {\n                    U[i][k] = -U[i][k];\n                }\n                U[k][k] = 1 + U[k][k];\n                for (int i = 0; i < k - 1; i++) {\n                    U[i][k] = 0;\n                }\n            } else {\n                for (int i = 0; i < m; i++) {\n                    U[i][k] = 0;\n                }\n                U[k][k] = 1;\n            }\n        }\n\n        // Generate V.\n        for (int k = n - 1; k >= 0; k--) {\n            if (k < nrt &&\n                e[k] != 0) {\n                for (int j = k + 1; j < n; j++) {\n                    double t = 0;\n                    for (int i = k + 1; i < n; i++) {\n                        t += V[i][k] * V[i][j];\n                    }\n                    t = -t / V[k + 1][k];\n                    for (int i = k + 1; i < n; i++) {\n                        V[i][j] += t * V[i][k];\n                    }\n                }\n            }\n            for (int i = 0; i < n; i++) {\n                V[i][k] = 0;\n            }\n            V[k][k] = 1;\n        }\n\n        // Main iteration loop for the singular values.\n        final int pp = p - 1;\n        int iter = 0;\n        while (p > 0) {\n            int k;\n            int kase;\n            // Here is where a test for too many iterations would go.\n            // This section of the program inspects for\n            // negligible elements in the s and e arrays.  On\n            // completion the variables kase and k are set as follows.\n            // kase = 1     if s(p) and e[k-1] are negligible and k<p\n            // kase = 2     if s(k) is negligible and k<p\n            // kase = 3     if e[k-1] is negligible, k<p, and\n            //              s(k), ..., s(p) are not negligible (qr step).\n            // kase = 4     if e(p-1) is negligible (convergence).\n            for (k = p - 2; k >= 0; k--) {\n                final double threshold\n                    = TINY + EPS * (FastMath.abs(singularValues[k]) +\n                                    FastMath.abs(singularValues[k + 1]));\n\n                // the following condition is written this way in order\n                // to break out of the loop when NaN occurs, writing it\n                // as \"if (FastMath.abs(e[k]) <= threshold)\" would loop\n                // indefinitely in case of NaNs because comparison on NaNs\n                // always return false, regardless of what is checked\n                // see issue MATH-947\n                if (!(FastMath.abs(e[k]) > threshold)) {\n                    e[k] = 0;\n                    break;\n                }\n\n            }\n\n            if (k == p - 2) {\n                kase = 4;\n            } else {\n                int ks;\n                for (ks = p - 1; ks >= k; ks--) {\n                    if (ks == k) {\n                        break;\n                    }\n                    final double t = (ks != p ? FastMath.abs(e[ks]) : 0) +\n                        (ks != k + 1 ? FastMath.abs(e[ks - 1]) : 0);\n                    if (FastMath.abs(singularValues[ks]) <= TINY + EPS * t) {\n                        singularValues[ks] = 0;\n                        break;\n                    }\n                }\n                if (ks == k) {\n                    kase = 3;\n                } else if (ks == p - 1) {\n                    kase = 1;\n                } else {\n                    kase = 2;\n                    k = ks;\n                }\n            }\n            k++;\n            // Perform the task indicated by kase.\n            switch (kase) {\n                // Deflate negligible s(p).\n                case 1: {\n                    double f = e[p - 2];\n                    e[p - 2] = 0;\n                    for (int j = p - 2; j >= k; j--) {\n                        double t = FastMath.hypot(singularValues[j], f);\n                        final double cs = singularValues[j] / t;\n                        final double sn = f / t;\n                        singularValues[j] = t;\n                        if (j != k) {\n                            f = -sn * e[j - 1];\n                            e[j - 1] = cs * e[j - 1];\n                        }\n\n                        for (int i = 0; i < n; i++) {\n                            t = cs * V[i][j] + sn * V[i][p - 1];\n                            V[i][p - 1] = -sn * V[i][j] + cs * V[i][p - 1];\n                            V[i][j] = t;\n                        }\n                    }\n                }\n                break;\n                // Split at negligible s(k).\n                case 2: {\n                    double f = e[k - 1];\n                    e[k - 1] = 0;\n                    for (int j = k; j < p; j++) {\n                        double t = FastMath.hypot(singularValues[j], f);\n                        final double cs = singularValues[j] / t;\n                        final double sn = f / t;\n                        singularValues[j] = t;\n                        f = -sn * e[j];\n                        e[j] = cs * e[j];\n\n                        for (int i = 0; i < m; i++) {\n                            t = cs * U[i][j] + sn * U[i][k - 1];\n                            U[i][k - 1] = -sn * U[i][j] + cs * U[i][k - 1];\n                            U[i][j] = t;\n                        }\n                    }\n                }\n                break;\n                // Perform one qr step.\n                case 3: {\n                    // Calculate the shift.\n                    final double maxPm1Pm2 = FastMath.max(FastMath.abs(singularValues[p - 1]),\n                                                          FastMath.abs(singularValues[p - 2]));\n                    final double scale = FastMath.max(FastMath.max(FastMath.max(maxPm1Pm2,\n                                                                                FastMath.abs(e[p - 2])),\n                                                                   FastMath.abs(singularValues[k])),\n                                                      FastMath.abs(e[k]));\n                    final double sp = singularValues[p - 1] / scale;\n                    final double spm1 = singularValues[p - 2] / scale;\n                    final double epm1 = e[p - 2] / scale;\n                    final double sk = singularValues[k] / scale;\n                    final double ek = e[k] / scale;\n                    final double b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2.0;\n                    final double c = (sp * epm1) * (sp * epm1);\n                    double shift = 0;\n                    if (b != 0 ||\n                        c != 0) {\n                        shift = FastMath.sqrt(b * b + c);\n                        if (b < 0) {\n                            shift = -shift;\n                        }\n                        shift = c / (b + shift);\n                    }\n                    double f = (sk + sp) * (sk - sp) + shift;\n                    double g = sk * ek;\n                    // Chase zeros.\n                    for (int j = k; j < p - 1; j++) {\n                        double t = FastMath.hypot(f, g);\n                        double cs = f / t;\n                        double sn = g / t;\n                        if (j != k) {\n                            e[j - 1] = t;\n                        }\n                        f = cs * singularValues[j] + sn * e[j];\n                        e[j] = cs * e[j] - sn * singularValues[j];\n                        g = sn * singularValues[j + 1];\n                        singularValues[j + 1] = cs * singularValues[j + 1];\n\n                        for (int i = 0; i < n; i++) {\n                            t = cs * V[i][j] + sn * V[i][j + 1];\n                            V[i][j + 1] = -sn * V[i][j] + cs * V[i][j + 1];\n                            V[i][j] = t;\n                        }\n                        t = FastMath.hypot(f, g);\n                        cs = f / t;\n                        sn = g / t;\n                        singularValues[j] = t;\n                        f = cs * e[j] + sn * singularValues[j + 1];\n                        singularValues[j + 1] = -sn * e[j] + cs * singularValues[j + 1];\n                        g = sn * e[j + 1];\n                        e[j + 1] = cs * e[j + 1];\n                        if (j < m - 1) {\n                            for (int i = 0; i < m; i++) {\n                                t = cs * U[i][j] + sn * U[i][j + 1];\n                                U[i][j + 1] = -sn * U[i][j] + cs * U[i][j + 1];\n                                U[i][j] = t;\n                            }\n                        }\n                    }\n                    e[p - 2] = f;\n                    iter = iter + 1;\n                }\n                break;\n                // Convergence.\n                default: {\n                    // Make the singular values positive.\n                    if (singularValues[k] <= 0) {\n                        singularValues[k] = singularValues[k] < 0 ? -singularValues[k] : 0;\n\n                        for (int i = 0; i <= pp; i++) {\n                            V[i][k] = -V[i][k];\n                        }\n                    }\n                    // Order the singular values.\n                    while (k < pp) {\n                        if (singularValues[k] >= singularValues[k + 1]) {\n                            break;\n                        }\n                        double t = singularValues[k];\n                        singularValues[k] = singularValues[k + 1];\n                        singularValues[k + 1] = t;\n                        if (k < n - 1) {\n                            for (int i = 0; i < n; i++) {\n                                t = V[i][k + 1];\n                                V[i][k + 1] = V[i][k];\n                                V[i][k] = t;\n                            }\n                        }\n                        if (k < m - 1) {\n                            for (int i = 0; i < m; i++) {\n                                t = U[i][k + 1];\n                                U[i][k + 1] = U[i][k];\n                                U[i][k] = t;\n                            }\n                        }\n                        k++;\n                    }\n                    iter = 0;\n                    p--;\n                }\n                break;\n            }\n        }\n\n        // Set the small value tolerance used to calculate rank and pseudo-inverse\n        tol = FastMath.max(m * singularValues[0] * EPS,\n                           FastMath.sqrt(Precision.SAFE_MIN));\n\n        if (!transposed) {\n            cachedU = MatrixUtils.createRealMatrix(U);\n            cachedV = MatrixUtils.createRealMatrix(V);\n        } else {\n            cachedU = MatrixUtils.createRealMatrix(V);\n            cachedV = MatrixUtils.createRealMatrix(U);\n        }\n    }",
          "34": "    public SingularValueDecomposition(final RealMatrix matrix) {\n        final double[][] A;\n\n         // \"m\" is always the largest dimension.\n        if (matrix.getRowDimension() < matrix.getColumnDimension()) {\n            transposed = true;\n            A = matrix.transpose().getData();\n            m = matrix.getColumnDimension();\n            n = matrix.getRowDimension();\n        } else {\n            transposed = false;\n            A = matrix.getData();\n            m = matrix.getRowDimension();\n            n = matrix.getColumnDimension();\n        }\n\n        singularValues = new double[n];\n        final double[][] U = new double[m][n];\n        final double[][] V = new double[n][n];\n        final double[] e = new double[n];\n        final double[] work = new double[m];\n        // Reduce A to bidiagonal form, storing the diagonal elements\n        // in s and the super-diagonal elements in e.\n        final int nct = FastMath.min(m - 1, n);\n        final int nrt = FastMath.max(0, n - 2);\n        for (int k = 0; k < FastMath.max(nct, nrt); k++) {\n            if (k < nct) {\n                // Compute the transformation for the k-th column and\n                // place the k-th diagonal in s[k].\n                // Compute 2-norm of k-th column without under/overflow.\n                singularValues[k] = 0;\n                for (int i = k; i < m; i++) {\n                    singularValues[k] = FastMath.hypot(singularValues[k], A[i][k]);\n                }\n                if (singularValues[k] != 0) {\n                    if (A[k][k] < 0) {\nA[k].[k] = 0;\n                    }\n                    for (int i = k; i < m; i++) {\n                        A[i][k] /= singularValues[k];\n                    }\n                    A[k][k] += 1;\n                }\n                singularValues[k] = -singularValues[k];\n            }\n            for (int j = k + 1; j < n; j++) {\n                if (k < nct &&\n                    singularValues[k] != 0) {\n                    // Apply the transformation.\n                    double t = 0;\n                    for (int i = k; i < m; i++) {\n                        t += A[i][k] * A[i][j];\n                    }\n                    t = -t / A[k][k];\n                    for (int i = k; i < m; i++) {\n                        A[i][j] += t * A[i][k];\n                    }\n                }\n                // Place the k-th row of A into e for the\n                // subsequent calculation of the row transformation.\n                e[j] = A[k][j];\n            }\n            if (k < nct) {\n                // Place the transformation in U for subsequent back\n                // multiplication.\n                for (int i = k; i < m; i++) {\n                    U[i][k] = A[i][k];\n                }\n            }\n            if (k < nrt) {\n                // Compute the k-th row transformation and place the\n                // k-th super-diagonal in e[k].\n                // Compute 2-norm without under/overflow.\n                e[k] = 0;\n                for (int i = k + 1; i < n; i++) {\n                    e[k] = FastMath.hypot(e[k], e[i]);\n                }\n                if (e[k] != 0) {\n                    if (e[k + 1] < 0) {\n                        e[k] = -e[k];\n                    }\n                    for (int i = k + 1; i < n; i++) {\n                        e[i] /= e[k];\n                    }\n                    e[k + 1] += 1;\n                }\n                e[k] = -e[k];\n                if (k + 1 < m &&\n                    e[k] != 0) {\n                    // Apply the transformation.\n                    for (int i = k + 1; i < m; i++) {\n                        work[i] = 0;\n                    }\n                    for (int j = k + 1; j < n; j++) {\n                        for (int i = k + 1; i < m; i++) {\n                            work[i] += e[j] * A[i][j];\n                        }\n                    }\n                    for (int j = k + 1; j < n; j++) {\n                        final double t = -e[j] / e[k + 1];\n                        for (int i = k + 1; i < m; i++) {\n                            A[i][j] += t * work[i];\n                        }\n                    }\n                }\n\n                // Place the transformation in V for subsequent\n                // back multiplication.\n                for (int i = k + 1; i < n; i++) {\n                    V[i][k] = e[i];\n                }\n            }\n        }\n        // Set up the final bidiagonal matrix or order p.\n        int p = n;\n        if (nct < n) {\n            singularValues[nct] = A[nct][nct];\n        }\n        if (m < p) {\n            singularValues[p - 1] = 0;\n        }\n        if (nrt + 1 < p) {\n            e[nrt] = A[nrt][p - 1];\n        }\n        e[p - 1] = 0;\n\n        // Generate U.\n        for (int j = nct; j < n; j++) {\n            for (int i = 0; i < m; i++) {\n                U[i][j] = 0;\n            }\n            U[j][j] = 1;\n        }\n        for (int k = nct - 1; k >= 0; k--) {\n            if (singularValues[k] != 0) {\n                for (int j = k + 1; j < n; j++) {\n                    double t = 0;\n                    for (int i = k; i < m; i++) {\n                        t += U[i][k] * U[i][j];\n                    }\n                    t = -t / U[k][k];\n                    for (int i = k; i < m; i++) {\n                        U[i][j] += t * U[i][k];\n                    }\n                }\n                for (int i = k; i < m; i++) {\n                    U[i][k] = -U[i][k];\n                }\n                U[k][k] = 1 + U[k][k];\n                for (int i = 0; i < k - 1; i++) {\n                    U[i][k] = 0;\n                }\n            } else {\n                for (int i = 0; i < m; i++) {\n                    U[i][k] = 0;\n                }\n                U[k][k] = 1;\n            }\n        }\n\n        // Generate V.\n        for (int k = n - 1; k >= 0; k--) {\n            if (k < nrt &&\n                e[k] != 0) {\n                for (int j = k + 1; j < n; j++) {\n                    double t = 0;\n                    for (int i = k + 1; i < n; i++) {\n                        t += V[i][k] * V[i][j];\n                    }\n                    t = -t / V[k + 1][k];\n                    for (int i = k + 1; i < n; i++) {\n                        V[i][j] += t * V[i][k];\n                    }\n                }\n            }\n            for (int i = 0; i < n; i++) {\n                V[i][k] = 0;\n            }\n            V[k][k] = 1;\n        }\n\n        // Main iteration loop for the singular values.\n        final int pp = p - 1;\n        int iter = 0;\n        while (p > 0) {\n            int k;\n            int kase;\n            // Here is where a test for too many iterations would go.\n            // This section of the program inspects for\n            // negligible elements in the s and e arrays.  On\n            // completion the variables kase and k are set as follows.\n            // kase = 1     if s(p) and e[k-1] are negligible and k<p\n            // kase = 2     if s(k) is negligible and k<p\n            // kase = 3     if e[k-1] is negligible, k<p, and\n            //              s(k), ..., s(p) are not negligible (qr step).\n            // kase = 4     if e(p-1) is negligible (convergence).\n            for (k = p - 2; k >= 0; k--) {\n                final double threshold\n                    = TINY + EPS * (FastMath.abs(singularValues[k]) +\n                                    FastMath.abs(singularValues[k + 1]));\n\n                // the following condition is written this way in order\n                // to break out of the loop when NaN occurs, writing it\n                // as \"if (FastMath.abs(e[k]) <= threshold)\" would loop\n                // indefinitely in case of NaNs because comparison on NaNs\n                // always return false, regardless of what is checked\n                // see issue MATH-947\n                if (!(FastMath.abs(e[k]) > threshold)) {\n                    e[k] = 0;\n                    break;\n                }\n\n            }\n\n            if (k == p - 2) {\n                kase = 4;\n            } else {\n                int ks;\n                for (ks = p - 1; ks >= k; ks--) {\n                    if (ks == k) {\n                        break;\n                    }\n                    final double t = (ks != p ? FastMath.abs(e[ks]) : 0) +\n                        (ks != k + 1 ? FastMath.abs(e[ks - 1]) : 0);\n                    if (FastMath.abs(singularValues[ks]) <= TINY + EPS * t) {\n                        singularValues[ks] = 0;\n                        break;\n                    }\n                }\n                if (ks == k) {\n                    kase = 3;\n                } else if (ks == p - 1) {\n                    kase = 1;\n                } else {\n                    kase = 2;\n                    k = ks;\n                }\n            }\n            k++;\n            // Perform the task indicated by kase.\n            switch (kase) {\n                // Deflate negligible s(p).\n                case 1: {\n                    double f = e[p - 2];\n                    e[p - 2] = 0;\n                    for (int j = p - 2; j >= k; j--) {\n                        double t = FastMath.hypot(singularValues[j], f);\n                        final double cs = singularValues[j] / t;\n                        final double sn = f / t;\n                        singularValues[j] = t;\n                        if (j != k) {\n                            f = -sn * e[j - 1];\n                            e[j - 1] = cs * e[j - 1];\n                        }\n\n                        for (int i = 0; i < n; i++) {\n                            t = cs * V[i][j] + sn * V[i][p - 1];\n                            V[i][p - 1] = -sn * V[i][j] + cs * V[i][p - 1];\n                            V[i][j] = t;\n                        }\n                    }\n                }\n                break;\n                // Split at negligible s(k).\n                case 2: {\n                    double f = e[k - 1];\n                    e[k - 1] = 0;\n                    for (int j = k; j < p; j++) {\n                        double t = FastMath.hypot(singularValues[j], f);\n                        final double cs = singularValues[j] / t;\n                        final double sn = f / t;\n                        singularValues[j] = t;\n                        f = -sn * e[j];\n                        e[j] = cs * e[j];\n\n                        for (int i = 0; i < m; i++) {\n                            t = cs * U[i][j] + sn * U[i][k - 1];\n                            U[i][k - 1] = -sn * U[i][j] + cs * U[i][k - 1];\n                            U[i][j] = t;\n                        }\n                    }\n                }\n                break;\n                // Perform one qr step.\n                case 3: {\n                    // Calculate the shift.\n                    final double maxPm1Pm2 = FastMath.max(FastMath.abs(singularValues[p - 1]),\n                                                          FastMath.abs(singularValues[p - 2]));\n                    final double scale = FastMath.max(FastMath.max(FastMath.max(maxPm1Pm2,\n                                                                                FastMath.abs(e[p - 2])),\n                                                                   FastMath.abs(singularValues[k])),\n                                                      FastMath.abs(e[k]));\n                    final double sp = singularValues[p - 1] / scale;\n                    final double spm1 = singularValues[p - 2] / scale;\n                    final double epm1 = e[p - 2] / scale;\n                    final double sk = singularValues[k] / scale;\n                    final double ek = e[k] / scale;\n                    final double b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2.0;\n                    final double c = (sp * epm1) * (sp * epm1);\n                    double shift = 0;\n                    if (b != 0 ||\n                        c != 0) {\n                        shift = FastMath.sqrt(b * b + c);\n                        if (b < 0) {\n                            shift = -shift;\n                        }\n                        shift = c / (b + shift);\n                    }\n                    double f = (sk + sp) * (sk - sp) + shift;\n                    double g = sk * ek;\n                    // Chase zeros.\n                    for (int j = k; j < p - 1; j++) {\n                        double t = FastMath.hypot(f, g);\n                        double cs = f / t;\n                        double sn = g / t;\n                        if (j != k) {\n                            e[j - 1] = t;\n                        }\n                        f = cs * singularValues[j] + sn * e[j];\n                        e[j] = cs * e[j] - sn * singularValues[j];\n                        g = sn * singularValues[j + 1];\n                        singularValues[j + 1] = cs * singularValues[j + 1];\n\n                        for (int i = 0; i < n; i++) {\n                            t = cs * V[i][j] + sn * V[i][j + 1];\n                            V[i][j + 1] = -sn * V[i][j] + cs * V[i][j + 1];\n                            V[i][j] = t;\n                        }\n                        t = FastMath.hypot(f, g);\n                        cs = f / t;\n                        sn = g / t;\n                        singularValues[j] = t;\n                        f = cs * e[j] + sn * singularValues[j + 1];\n                        singularValues[j + 1] = -sn * e[j] + cs * singularValues[j + 1];\n                        g = sn * e[j + 1];\n                        e[j + 1] = cs * e[j + 1];\n                        if (j < m - 1) {\n                            for (int i = 0; i < m; i++) {\n                                t = cs * U[i][j] + sn * U[i][j + 1];\n                                U[i][j + 1] = -sn * U[i][j] + cs * U[i][j + 1];\n                                U[i][j] = t;\n                            }\n                        }\n                    }\n                    e[p - 2] = f;\n                    iter = iter + 1;\n                }\n                break;\n                // Convergence.\n                default: {\n                    // Make the singular values positive.\n                    if (singularValues[k] <= 0) {\n                        singularValues[k] = singularValues[k] < 0 ? -singularValues[k] : 0;\n\n                        for (int i = 0; i <= pp; i++) {\n                            V[i][k] = -V[i][k];\n                        }\n                    }\n                    // Order the singular values.\n                    while (k < pp) {\n                        if (singularValues[k] >= singularValues[k + 1]) {\n                            break;\n                        }\n                        double t = singularValues[k];\n                        singularValues[k] = singularValues[k + 1];\n                        singularValues[k + 1] = t;\n                        if (k < n - 1) {\n                            for (int i = 0; i < n; i++) {\n                                t = V[i][k + 1];\n                                V[i][k + 1] = V[i][k];\n                                V[i][k] = t;\n                            }\n                        }\n                        if (k < m - 1) {\n                            for (int i = 0; i < m; i++) {\n                                t = U[i][k + 1];\n                                U[i][k + 1] = U[i][k];\n                                U[i][k] = t;\n                            }\n                        }\n                        k++;\n                    }\n                    iter = 0;\n                    p--;\n                }\n                break;\n            }\n        }\n\n        // Set the small value tolerance used to calculate rank and pseudo-inverse\n        tol = FastMath.max(m * singularValues[0] * EPS,\n                           FastMath.sqrt(Precision.SAFE_MIN));\n\n        if (!transposed) {\n            cachedU = MatrixUtils.createRealMatrix(U);\n            cachedV = MatrixUtils.createRealMatrix(V);\n        } else {\n            cachedU = MatrixUtils.createRealMatrix(V);\n            cachedV = MatrixUtils.createRealMatrix(U);\n        }\n    }",
          "35": "    public SingularValueDecomposition(final RealMatrix matrix) {\n        final double[][] A;\n\n         // \"m\" is always the largest dimension.\n        if (matrix.getRowDimension() < matrix.getColumnDimension()) {\n            transposed = true;\n            A = matrix.transpose().getData();\n            m = matrix.getColumnDimension();\n            n = matrix.getRowDimension();\n        } else {\n            transposed = false;\n            A = matrix.getData();\n            m = matrix.getRowDimension();\n            n = matrix.getColumnDimension();\n        }\n\n        singularValues = new double[n];\n        final double[][] U = new double[m][n];\n        final double[][] V = new double[n][n];\n        final double[] e = new double[n];\n        final double[] work = new double[m];\n        // Reduce A to bidiagonal form, storing the diagonal elements\n        // in s and the super-diagonal elements in e.\n        final int nct = FastMath.min(m - 1, n);\n        final int nrt = FastMath.max(0, n - 2);\n        for (int k = 0; k < FastMath.max(nct, nrt); k++) {\n            if (k < nct) {\n                // Compute the transformation for the k-th column and\n                // place the k-th diagonal in s[k].\n                // Compute 2-norm of k-th column without under/overflow.\n                singularValues[k] = 0;\n                for (int i = k; i < m; i++) {\n                    singularValues[k] = FastMath.hypot(singularValues[k], A[i][k]);\n                }\n                if (singularValues[k] != 0) {\n                    if (A[k][k] < 0) {\nEPS[k].[k] = +singularValues[k];\n                    }\n                    for (int i = k; i < m; i++) {\n                        A[i][k] /= singularValues[k];\n                    }\n                    A[k][k] += 1;\n                }\n                singularValues[k] = -singularValues[k];\n            }\n            for (int j = k + 1; j < n; j++) {\n                if (k < nct &&\n                    singularValues[k] != 0) {\n                    // Apply the transformation.\n                    double t = 0;\n                    for (int i = k; i < m; i++) {\n                        t += A[i][k] * A[i][j];\n                    }\n                    t = -t / A[k][k];\n                    for (int i = k; i < m; i++) {\n                        A[i][j] += t * A[i][k];\n                    }\n                }\n                // Place the k-th row of A into e for the\n                // subsequent calculation of the row transformation.\n                e[j] = A[k][j];\n            }\n            if (k < nct) {\n                // Place the transformation in U for subsequent back\n                // multiplication.\n                for (int i = k; i < m; i++) {\n                    U[i][k] = A[i][k];\n                }\n            }\n            if (k < nrt) {\n                // Compute the k-th row transformation and place the\n                // k-th super-diagonal in e[k].\n                // Compute 2-norm without under/overflow.\n                e[k] = 0;\n                for (int i = k + 1; i < n; i++) {\n                    e[k] = FastMath.hypot(e[k], e[i]);\n                }\n                if (e[k] != 0) {\n                    if (e[k + 1] < 0) {\n                        e[k] = -e[k];\n                    }\n                    for (int i = k + 1; i < n; i++) {\n                        e[i] /= e[k];\n                    }\n                    e[k + 1] += 1;\n                }\n                e[k] = -e[k];\n                if (k + 1 < m &&\n                    e[k] != 0) {\n                    // Apply the transformation.\n                    for (int i = k + 1; i < m; i++) {\n                        work[i] = 0;\n                    }\n                    for (int j = k + 1; j < n; j++) {\n                        for (int i = k + 1; i < m; i++) {\n                            work[i] += e[j] * A[i][j];\n                        }\n                    }\n                    for (int j = k + 1; j < n; j++) {\n                        final double t = -e[j] / e[k + 1];\n                        for (int i = k + 1; i < m; i++) {\n                            A[i][j] += t * work[i];\n                        }\n                    }\n                }\n\n                // Place the transformation in V for subsequent\n                // back multiplication.\n                for (int i = k + 1; i < n; i++) {\n                    V[i][k] = e[i];\n                }\n            }\n        }\n        // Set up the final bidiagonal matrix or order p.\n        int p = n;\n        if (nct < n) {\n            singularValues[nct] = A[nct][nct];\n        }\n        if (m < p) {\n            singularValues[p - 1] = 0;\n        }\n        if (nrt + 1 < p) {\n            e[nrt] = A[nrt][p - 1];\n        }\n        e[p - 1] = 0;\n\n        // Generate U.\n        for (int j = nct; j < n; j++) {\n            for (int i = 0; i < m; i++) {\n                U[i][j] = 0;\n            }\n            U[j][j] = 1;\n        }\n        for (int k = nct - 1; k >= 0; k--) {\n            if (singularValues[k] != 0) {\n                for (int j = k + 1; j < n; j++) {\n                    double t = 0;\n                    for (int i = k; i < m; i++) {\n                        t += U[i][k] * U[i][j];\n                    }\n                    t = -t / U[k][k];\n                    for (int i = k; i < m; i++) {\n                        U[i][j] += t * U[i][k];\n                    }\n                }\n                for (int i = k; i < m; i++) {\n                    U[i][k] = -U[i][k];\n                }\n                U[k][k] = 1 + U[k][k];\n                for (int i = 0; i < k - 1; i++) {\n                    U[i][k] = 0;\n                }\n            } else {\n                for (int i = 0; i < m; i++) {\n                    U[i][k] = 0;\n                }\n                U[k][k] = 1;\n            }\n        }\n\n        // Generate V.\n        for (int k = n - 1; k >= 0; k--) {\n            if (k < nrt &&\n                e[k] != 0) {\n                for (int j = k + 1; j < n; j++) {\n                    double t = 0;\n                    for (int i = k + 1; i < n; i++) {\n                        t += V[i][k] * V[i][j];\n                    }\n                    t = -t / V[k + 1][k];\n                    for (int i = k + 1; i < n; i++) {\n                        V[i][j] += t * V[i][k];\n                    }\n                }\n            }\n            for (int i = 0; i < n; i++) {\n                V[i][k] = 0;\n            }\n            V[k][k] = 1;\n        }\n\n        // Main iteration loop for the singular values.\n        final int pp = p - 1;\n        int iter = 0;\n        while (p > 0) {\n            int k;\n            int kase;\n            // Here is where a test for too many iterations would go.\n            // This section of the program inspects for\n            // negligible elements in the s and e arrays.  On\n            // completion the variables kase and k are set as follows.\n            // kase = 1     if s(p) and e[k-1] are negligible and k<p\n            // kase = 2     if s(k) is negligible and k<p\n            // kase = 3     if e[k-1] is negligible, k<p, and\n            //              s(k), ..., s(p) are not negligible (qr step).\n            // kase = 4     if e(p-1) is negligible (convergence).\n            for (k = p - 2; k >= 0; k--) {\n                final double threshold\n                    = TINY + EPS * (FastMath.abs(singularValues[k]) +\n                                    FastMath.abs(singularValues[k + 1]));\n\n                // the following condition is written this way in order\n                // to break out of the loop when NaN occurs, writing it\n                // as \"if (FastMath.abs(e[k]) <= threshold)\" would loop\n                // indefinitely in case of NaNs because comparison on NaNs\n                // always return false, regardless of what is checked\n                // see issue MATH-947\n                if (!(FastMath.abs(e[k]) > threshold)) {\n                    e[k] = 0;\n                    break;\n                }\n\n            }\n\n            if (k == p - 2) {\n                kase = 4;\n            } else {\n                int ks;\n                for (ks = p - 1; ks >= k; ks--) {\n                    if (ks == k) {\n                        break;\n                    }\n                    final double t = (ks != p ? FastMath.abs(e[ks]) : 0) +\n                        (ks != k + 1 ? FastMath.abs(e[ks - 1]) : 0);\n                    if (FastMath.abs(singularValues[ks]) <= TINY + EPS * t) {\n                        singularValues[ks] = 0;\n                        break;\n                    }\n                }\n                if (ks == k) {\n                    kase = 3;\n                } else if (ks == p - 1) {\n                    kase = 1;\n                } else {\n                    kase = 2;\n                    k = ks;\n                }\n            }\n            k++;\n            // Perform the task indicated by kase.\n            switch (kase) {\n                // Deflate negligible s(p).\n                case 1: {\n                    double f = e[p - 2];\n                    e[p - 2] = 0;\n                    for (int j = p - 2; j >= k; j--) {\n                        double t = FastMath.hypot(singularValues[j], f);\n                        final double cs = singularValues[j] / t;\n                        final double sn = f / t;\n                        singularValues[j] = t;\n                        if (j != k) {\n                            f = -sn * e[j - 1];\n                            e[j - 1] = cs * e[j - 1];\n                        }\n\n                        for (int i = 0; i < n; i++) {\n                            t = cs * V[i][j] + sn * V[i][p - 1];\n                            V[i][p - 1] = -sn * V[i][j] + cs * V[i][p - 1];\n                            V[i][j] = t;\n                        }\n                    }\n                }\n                break;\n                // Split at negligible s(k).\n                case 2: {\n                    double f = e[k - 1];\n                    e[k - 1] = 0;\n                    for (int j = k; j < p; j++) {\n                        double t = FastMath.hypot(singularValues[j], f);\n                        final double cs = singularValues[j] / t;\n                        final double sn = f / t;\n                        singularValues[j] = t;\n                        f = -sn * e[j];\n                        e[j] = cs * e[j];\n\n                        for (int i = 0; i < m; i++) {\n                            t = cs * U[i][j] + sn * U[i][k - 1];\n                            U[i][k - 1] = -sn * U[i][j] + cs * U[i][k - 1];\n                            U[i][j] = t;\n                        }\n                    }\n                }\n                break;\n                // Perform one qr step.\n                case 3: {\n                    // Calculate the shift.\n                    final double maxPm1Pm2 = FastMath.max(FastMath.abs(singularValues[p - 1]),\n                                                          FastMath.abs(singularValues[p - 2]));\n                    final double scale = FastMath.max(FastMath.max(FastMath.max(maxPm1Pm2,\n                                                                                FastMath.abs(e[p - 2])),\n                                                                   FastMath.abs(singularValues[k])),\n                                                      FastMath.abs(e[k]));\n                    final double sp = singularValues[p - 1] / scale;\n                    final double spm1 = singularValues[p - 2] / scale;\n                    final double epm1 = e[p - 2] / scale;\n                    final double sk = singularValues[k] / scale;\n                    final double ek = e[k] / scale;\n                    final double b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2.0;\n                    final double c = (sp * epm1) * (sp * epm1);\n                    double shift = 0;\n                    if (b != 0 ||\n                        c != 0) {\n                        shift = FastMath.sqrt(b * b + c);\n                        if (b < 0) {\n                            shift = -shift;\n                        }\n                        shift = c / (b + shift);\n                    }\n                    double f = (sk + sp) * (sk - sp) + shift;\n                    double g = sk * ek;\n                    // Chase zeros.\n                    for (int j = k; j < p - 1; j++) {\n                        double t = FastMath.hypot(f, g);\n                        double cs = f / t;\n                        double sn = g / t;\n                        if (j != k) {\n                            e[j - 1] = t;\n                        }\n                        f = cs * singularValues[j] + sn * e[j];\n                        e[j] = cs * e[j] - sn * singularValues[j];\n                        g = sn * singularValues[j + 1];\n                        singularValues[j + 1] = cs * singularValues[j + 1];\n\n                        for (int i = 0; i < n; i++) {\n                            t = cs * V[i][j] + sn * V[i][j + 1];\n                            V[i][j + 1] = -sn * V[i][j] + cs * V[i][j + 1];\n                            V[i][j] = t;\n                        }\n                        t = FastMath.hypot(f, g);\n                        cs = f / t;\n                        sn = g / t;\n                        singularValues[j] = t;\n                        f = cs * e[j] + sn * singularValues[j + 1];\n                        singularValues[j + 1] = -sn * e[j] + cs * singularValues[j + 1];\n                        g = sn * e[j + 1];\n                        e[j + 1] = cs * e[j + 1];\n                        if (j < m - 1) {\n                            for (int i = 0; i < m; i++) {\n                                t = cs * U[i][j] + sn * U[i][j + 1];\n                                U[i][j + 1] = -sn * U[i][j] + cs * U[i][j + 1];\n                                U[i][j] = t;\n                            }\n                        }\n                    }\n                    e[p - 2] = f;\n                    iter = iter + 1;\n                }\n                break;\n                // Convergence.\n                default: {\n                    // Make the singular values positive.\n                    if (singularValues[k] <= 0) {\n                        singularValues[k] = singularValues[k] < 0 ? -singularValues[k] : 0;\n\n                        for (int i = 0; i <= pp; i++) {\n                            V[i][k] = -V[i][k];\n                        }\n                    }\n                    // Order the singular values.\n                    while (k < pp) {\n                        if (singularValues[k] >= singularValues[k + 1]) {\n                            break;\n                        }\n                        double t = singularValues[k];\n                        singularValues[k] = singularValues[k + 1];\n                        singularValues[k + 1] = t;\n                        if (k < n - 1) {\n                            for (int i = 0; i < n; i++) {\n                                t = V[i][k + 1];\n                                V[i][k + 1] = V[i][k];\n                                V[i][k] = t;\n                            }\n                        }\n                        if (k < m - 1) {\n                            for (int i = 0; i < m; i++) {\n                                t = U[i][k + 1];\n                                U[i][k + 1] = U[i][k];\n                                U[i][k] = t;\n                            }\n                        }\n                        k++;\n                    }\n                    iter = 0;\n                    p--;\n                }\n                break;\n            }\n        }\n\n        // Set the small value tolerance used to calculate rank and pseudo-inverse\n        tol = FastMath.max(m * singularValues[0] * EPS,\n                           FastMath.sqrt(Precision.SAFE_MIN));\n\n        if (!transposed) {\n            cachedU = MatrixUtils.createRealMatrix(U);\n            cachedV = MatrixUtils.createRealMatrix(V);\n        } else {\n            cachedU = MatrixUtils.createRealMatrix(V);\n            cachedV = MatrixUtils.createRealMatrix(U);\n        }\n    }",
          "36": "    public SingularValueDecomposition(final RealMatrix matrix) {\n        final double[][] A;\n\n         // \"m\" is always the largest dimension.\n        if (matrix.getRowDimension() < matrix.getColumnDimension()) {\n            transposed = true;\n            A = matrix.transpose().getData();\n            m = matrix.getColumnDimension();\n            n = matrix.getRowDimension();\n        } else {\n            transposed = false;\n            A = matrix.getData();\n            m = matrix.getRowDimension();\n            n = matrix.getColumnDimension();\n        }\n\n        singularValues = new double[n];\n        final double[][] U = new double[m][n];\n        final double[][] V = new double[n][n];\n        final double[] e = new double[n];\n        final double[] work = new double[m];\n        // Reduce A to bidiagonal form, storing the diagonal elements\n        // in s and the super-diagonal elements in e.\n        final int nct = FastMath.min(m - 1, n);\n        final int nrt = FastMath.max(0, n - 2);\n        for (int k = 0; k < FastMath.max(nct, nrt); k++) {\n            if (k < nct) {\n                // Compute the transformation for the k-th column and\n                // place the k-th diagonal in s[k].\n                // Compute 2-norm of k-th column without under/overflow.\n                singularValues[k] = 0;\n                for (int i = k; i < m; i++) {\n                    singularValues[k] = FastMath.hypot(singularValues[k], A[i][k]);\n                }\n                if (singularValues[k] != 0) {\n                    if (A[k][k] < 0) {\nTINY[k].[k] = +singularValues[k];\n                    }\n                    for (int i = k; i < m; i++) {\n                        A[i][k] /= singularValues[k];\n                    }\n                    A[k][k] += 1;\n                }\n                singularValues[k] = -singularValues[k];\n            }\n            for (int j = k + 1; j < n; j++) {\n                if (k < nct &&\n                    singularValues[k] != 0) {\n                    // Apply the transformation.\n                    double t = 0;\n                    for (int i = k; i < m; i++) {\n                        t += A[i][k] * A[i][j];\n                    }\n                    t = -t / A[k][k];\n                    for (int i = k; i < m; i++) {\n                        A[i][j] += t * A[i][k];\n                    }\n                }\n                // Place the k-th row of A into e for the\n                // subsequent calculation of the row transformation.\n                e[j] = A[k][j];\n            }\n            if (k < nct) {\n                // Place the transformation in U for subsequent back\n                // multiplication.\n                for (int i = k; i < m; i++) {\n                    U[i][k] = A[i][k];\n                }\n            }\n            if (k < nrt) {\n                // Compute the k-th row transformation and place the\n                // k-th super-diagonal in e[k].\n                // Compute 2-norm without under/overflow.\n                e[k] = 0;\n                for (int i = k + 1; i < n; i++) {\n                    e[k] = FastMath.hypot(e[k], e[i]);\n                }\n                if (e[k] != 0) {\n                    if (e[k + 1] < 0) {\n                        e[k] = -e[k];\n                    }\n                    for (int i = k + 1; i < n; i++) {\n                        e[i] /= e[k];\n                    }\n                    e[k + 1] += 1;\n                }\n                e[k] = -e[k];\n                if (k + 1 < m &&\n                    e[k] != 0) {\n                    // Apply the transformation.\n                    for (int i = k + 1; i < m; i++) {\n                        work[i] = 0;\n                    }\n                    for (int j = k + 1; j < n; j++) {\n                        for (int i = k + 1; i < m; i++) {\n                            work[i] += e[j] * A[i][j];\n                        }\n                    }\n                    for (int j = k + 1; j < n; j++) {\n                        final double t = -e[j] / e[k + 1];\n                        for (int i = k + 1; i < m; i++) {\n                            A[i][j] += t * work[i];\n                        }\n                    }\n                }\n\n                // Place the transformation in V for subsequent\n                // back multiplication.\n                for (int i = k + 1; i < n; i++) {\n                    V[i][k] = e[i];\n                }\n            }\n        }\n        // Set up the final bidiagonal matrix or order p.\n        int p = n;\n        if (nct < n) {\n            singularValues[nct] = A[nct][nct];\n        }\n        if (m < p) {\n            singularValues[p - 1] = 0;\n        }\n        if (nrt + 1 < p) {\n            e[nrt] = A[nrt][p - 1];\n        }\n        e[p - 1] = 0;\n\n        // Generate U.\n        for (int j = nct; j < n; j++) {\n            for (int i = 0; i < m; i++) {\n                U[i][j] = 0;\n            }\n            U[j][j] = 1;\n        }\n        for (int k = nct - 1; k >= 0; k--) {\n            if (singularValues[k] != 0) {\n                for (int j = k + 1; j < n; j++) {\n                    double t = 0;\n                    for (int i = k; i < m; i++) {\n                        t += U[i][k] * U[i][j];\n                    }\n                    t = -t / U[k][k];\n                    for (int i = k; i < m; i++) {\n                        U[i][j] += t * U[i][k];\n                    }\n                }\n                for (int i = k; i < m; i++) {\n                    U[i][k] = -U[i][k];\n                }\n                U[k][k] = 1 + U[k][k];\n                for (int i = 0; i < k - 1; i++) {\n                    U[i][k] = 0;\n                }\n            } else {\n                for (int i = 0; i < m; i++) {\n                    U[i][k] = 0;\n                }\n                U[k][k] = 1;\n            }\n        }\n\n        // Generate V.\n        for (int k = n - 1; k >= 0; k--) {\n            if (k < nrt &&\n                e[k] != 0) {\n                for (int j = k + 1; j < n; j++) {\n                    double t = 0;\n                    for (int i = k + 1; i < n; i++) {\n                        t += V[i][k] * V[i][j];\n                    }\n                    t = -t / V[k + 1][k];\n                    for (int i = k + 1; i < n; i++) {\n                        V[i][j] += t * V[i][k];\n                    }\n                }\n            }\n            for (int i = 0; i < n; i++) {\n                V[i][k] = 0;\n            }\n            V[k][k] = 1;\n        }\n\n        // Main iteration loop for the singular values.\n        final int pp = p - 1;\n        int iter = 0;\n        while (p > 0) {\n            int k;\n            int kase;\n            // Here is where a test for too many iterations would go.\n            // This section of the program inspects for\n            // negligible elements in the s and e arrays.  On\n            // completion the variables kase and k are set as follows.\n            // kase = 1     if s(p) and e[k-1] are negligible and k<p\n            // kase = 2     if s(k) is negligible and k<p\n            // kase = 3     if e[k-1] is negligible, k<p, and\n            //              s(k), ..., s(p) are not negligible (qr step).\n            // kase = 4     if e(p-1) is negligible (convergence).\n            for (k = p - 2; k >= 0; k--) {\n                final double threshold\n                    = TINY + EPS * (FastMath.abs(singularValues[k]) +\n                                    FastMath.abs(singularValues[k + 1]));\n\n                // the following condition is written this way in order\n                // to break out of the loop when NaN occurs, writing it\n                // as \"if (FastMath.abs(e[k]) <= threshold)\" would loop\n                // indefinitely in case of NaNs because comparison on NaNs\n                // always return false, regardless of what is checked\n                // see issue MATH-947\n                if (!(FastMath.abs(e[k]) > threshold)) {\n                    e[k] = 0;\n                    break;\n                }\n\n            }\n\n            if (k == p - 2) {\n                kase = 4;\n            } else {\n                int ks;\n                for (ks = p - 1; ks >= k; ks--) {\n                    if (ks == k) {\n                        break;\n                    }\n                    final double t = (ks != p ? FastMath.abs(e[ks]) : 0) +\n                        (ks != k + 1 ? FastMath.abs(e[ks - 1]) : 0);\n                    if (FastMath.abs(singularValues[ks]) <= TINY + EPS * t) {\n                        singularValues[ks] = 0;\n                        break;\n                    }\n                }\n                if (ks == k) {\n                    kase = 3;\n                } else if (ks == p - 1) {\n                    kase = 1;\n                } else {\n                    kase = 2;\n                    k = ks;\n                }\n            }\n            k++;\n            // Perform the task indicated by kase.\n            switch (kase) {\n                // Deflate negligible s(p).\n                case 1: {\n                    double f = e[p - 2];\n                    e[p - 2] = 0;\n                    for (int j = p - 2; j >= k; j--) {\n                        double t = FastMath.hypot(singularValues[j], f);\n                        final double cs = singularValues[j] / t;\n                        final double sn = f / t;\n                        singularValues[j] = t;\n                        if (j != k) {\n                            f = -sn * e[j - 1];\n                            e[j - 1] = cs * e[j - 1];\n                        }\n\n                        for (int i = 0; i < n; i++) {\n                            t = cs * V[i][j] + sn * V[i][p - 1];\n                            V[i][p - 1] = -sn * V[i][j] + cs * V[i][p - 1];\n                            V[i][j] = t;\n                        }\n                    }\n                }\n                break;\n                // Split at negligible s(k).\n                case 2: {\n                    double f = e[k - 1];\n                    e[k - 1] = 0;\n                    for (int j = k; j < p; j++) {\n                        double t = FastMath.hypot(singularValues[j], f);\n                        final double cs = singularValues[j] / t;\n                        final double sn = f / t;\n                        singularValues[j] = t;\n                        f = -sn * e[j];\n                        e[j] = cs * e[j];\n\n                        for (int i = 0; i < m; i++) {\n                            t = cs * U[i][j] + sn * U[i][k - 1];\n                            U[i][k - 1] = -sn * U[i][j] + cs * U[i][k - 1];\n                            U[i][j] = t;\n                        }\n                    }\n                }\n                break;\n                // Perform one qr step.\n                case 3: {\n                    // Calculate the shift.\n                    final double maxPm1Pm2 = FastMath.max(FastMath.abs(singularValues[p - 1]),\n                                                          FastMath.abs(singularValues[p - 2]));\n                    final double scale = FastMath.max(FastMath.max(FastMath.max(maxPm1Pm2,\n                                                                                FastMath.abs(e[p - 2])),\n                                                                   FastMath.abs(singularValues[k])),\n                                                      FastMath.abs(e[k]));\n                    final double sp = singularValues[p - 1] / scale;\n                    final double spm1 = singularValues[p - 2] / scale;\n                    final double epm1 = e[p - 2] / scale;\n                    final double sk = singularValues[k] / scale;\n                    final double ek = e[k] / scale;\n                    final double b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2.0;\n                    final double c = (sp * epm1) * (sp * epm1);\n                    double shift = 0;\n                    if (b != 0 ||\n                        c != 0) {\n                        shift = FastMath.sqrt(b * b + c);\n                        if (b < 0) {\n                            shift = -shift;\n                        }\n                        shift = c / (b + shift);\n                    }\n                    double f = (sk + sp) * (sk - sp) + shift;\n                    double g = sk * ek;\n                    // Chase zeros.\n                    for (int j = k; j < p - 1; j++) {\n                        double t = FastMath.hypot(f, g);\n                        double cs = f / t;\n                        double sn = g / t;\n                        if (j != k) {\n                            e[j - 1] = t;\n                        }\n                        f = cs * singularValues[j] + sn * e[j];\n                        e[j] = cs * e[j] - sn * singularValues[j];\n                        g = sn * singularValues[j + 1];\n                        singularValues[j + 1] = cs * singularValues[j + 1];\n\n                        for (int i = 0; i < n; i++) {\n                            t = cs * V[i][j] + sn * V[i][j + 1];\n                            V[i][j + 1] = -sn * V[i][j] + cs * V[i][j + 1];\n                            V[i][j] = t;\n                        }\n                        t = FastMath.hypot(f, g);\n                        cs = f / t;\n                        sn = g / t;\n                        singularValues[j] = t;\n                        f = cs * e[j] + sn * singularValues[j + 1];\n                        singularValues[j + 1] = -sn * e[j] + cs * singularValues[j + 1];\n                        g = sn * e[j + 1];\n                        e[j + 1] = cs * e[j + 1];\n                        if (j < m - 1) {\n                            for (int i = 0; i < m; i++) {\n                                t = cs * U[i][j] + sn * U[i][j + 1];\n                                U[i][j + 1] = -sn * U[i][j] + cs * U[i][j + 1];\n                                U[i][j] = t;\n                            }\n                        }\n                    }\n                    e[p - 2] = f;\n                    iter = iter + 1;\n                }\n                break;\n                // Convergence.\n                default: {\n                    // Make the singular values positive.\n                    if (singularValues[k] <= 0) {\n                        singularValues[k] = singularValues[k] < 0 ? -singularValues[k] : 0;\n\n                        for (int i = 0; i <= pp; i++) {\n                            V[i][k] = -V[i][k];\n                        }\n                    }\n                    // Order the singular values.\n                    while (k < pp) {\n                        if (singularValues[k] >= singularValues[k + 1]) {\n                            break;\n                        }\n                        double t = singularValues[k];\n                        singularValues[k] = singularValues[k + 1];\n                        singularValues[k + 1] = t;\n                        if (k < n - 1) {\n                            for (int i = 0; i < n; i++) {\n                                t = V[i][k + 1];\n                                V[i][k + 1] = V[i][k];\n                                V[i][k] = t;\n                            }\n                        }\n                        if (k < m - 1) {\n                            for (int i = 0; i < m; i++) {\n                                t = U[i][k + 1];\n                                U[i][k + 1] = U[i][k];\n                                U[i][k] = t;\n                            }\n                        }\n                        k++;\n                    }\n                    iter = 0;\n                    p--;\n                }\n                break;\n            }\n        }\n\n        // Set the small value tolerance used to calculate rank and pseudo-inverse\n        tol = FastMath.max(m * singularValues[0] * EPS,\n                           FastMath.sqrt(Precision.SAFE_MIN));\n\n        if (!transposed) {\n            cachedU = MatrixUtils.createRealMatrix(U);\n            cachedV = MatrixUtils.createRealMatrix(V);\n        } else {\n            cachedU = MatrixUtils.createRealMatrix(V);\n            cachedV = MatrixUtils.createRealMatrix(U);\n        }\n    }",
          "37": "    public SingularValueDecomposition(final RealMatrix matrix) {\n        final double[][] A;\n\n         // \"m\" is always the largest dimension.\n        if (matrix.getRowDimension() < matrix.getColumnDimension()) {\n            transposed = true;\n            A = matrix.transpose().getData();\n            m = matrix.getColumnDimension();\n            n = matrix.getRowDimension();\n        } else {\n            transposed = false;\n            A = matrix.getData();\n            m = matrix.getRowDimension();\n            n = matrix.getColumnDimension();\n        }\n\n        singularValues = new double[n];\n        final double[][] U = new double[m][n];\n        final double[][] V = new double[n][n];\n        final double[] e = new double[n];\n        final double[] work = new double[m];\n        // Reduce A to bidiagonal form, storing the diagonal elements\n        // in s and the super-diagonal elements in e.\n        final int nct = FastMath.min(m - 1, n);\n        final int nrt = FastMath.max(0, n - 2);\n        for (int k = 0; k < FastMath.max(nct, nrt); k++) {\n            if (k < nct) {\n                // Compute the transformation for the k-th column and\n                // place the k-th diagonal in s[k].\n                // Compute 2-norm of k-th column without under/overflow.\n                singularValues[k] = 0;\n                for (int i = k; i < m; i++) {\n                    singularValues[k] = FastMath.hypot(singularValues[k], A[i][k]);\n                }\n                if (singularValues[k] != 0) {\n                    if (A[k][k] < 0) {\nsingularValues[k].[k] = +singularValues[k];\n                    }\n                    for (int i = k; i < m; i++) {\n                        A[i][k] /= singularValues[k];\n                    }\n                    A[k][k] += 1;\n                }\n                singularValues[k] = -singularValues[k];\n            }\n            for (int j = k + 1; j < n; j++) {\n                if (k < nct &&\n                    singularValues[k] != 0) {\n                    // Apply the transformation.\n                    double t = 0;\n                    for (int i = k; i < m; i++) {\n                        t += A[i][k] * A[i][j];\n                    }\n                    t = -t / A[k][k];\n                    for (int i = k; i < m; i++) {\n                        A[i][j] += t * A[i][k];\n                    }\n                }\n                // Place the k-th row of A into e for the\n                // subsequent calculation of the row transformation.\n                e[j] = A[k][j];\n            }\n            if (k < nct) {\n                // Place the transformation in U for subsequent back\n                // multiplication.\n                for (int i = k; i < m; i++) {\n                    U[i][k] = A[i][k];\n                }\n            }\n            if (k < nrt) {\n                // Compute the k-th row transformation and place the\n                // k-th super-diagonal in e[k].\n                // Compute 2-norm without under/overflow.\n                e[k] = 0;\n                for (int i = k + 1; i < n; i++) {\n                    e[k] = FastMath.hypot(e[k], e[i]);\n                }\n                if (e[k] != 0) {\n                    if (e[k + 1] < 0) {\n                        e[k] = -e[k];\n                    }\n                    for (int i = k + 1; i < n; i++) {\n                        e[i] /= e[k];\n                    }\n                    e[k + 1] += 1;\n                }\n                e[k] = -e[k];\n                if (k + 1 < m &&\n                    e[k] != 0) {\n                    // Apply the transformation.\n                    for (int i = k + 1; i < m; i++) {\n                        work[i] = 0;\n                    }\n                    for (int j = k + 1; j < n; j++) {\n                        for (int i = k + 1; i < m; i++) {\n                            work[i] += e[j] * A[i][j];\n                        }\n                    }\n                    for (int j = k + 1; j < n; j++) {\n                        final double t = -e[j] / e[k + 1];\n                        for (int i = k + 1; i < m; i++) {\n                            A[i][j] += t * work[i];\n                        }\n                    }\n                }\n\n                // Place the transformation in V for subsequent\n                // back multiplication.\n                for (int i = k + 1; i < n; i++) {\n                    V[i][k] = e[i];\n                }\n            }\n        }\n        // Set up the final bidiagonal matrix or order p.\n        int p = n;\n        if (nct < n) {\n            singularValues[nct] = A[nct][nct];\n        }\n        if (m < p) {\n            singularValues[p - 1] = 0;\n        }\n        if (nrt + 1 < p) {\n            e[nrt] = A[nrt][p - 1];\n        }\n        e[p - 1] = 0;\n\n        // Generate U.\n        for (int j = nct; j < n; j++) {\n            for (int i = 0; i < m; i++) {\n                U[i][j] = 0;\n            }\n            U[j][j] = 1;\n        }\n        for (int k = nct - 1; k >= 0; k--) {\n            if (singularValues[k] != 0) {\n                for (int j = k + 1; j < n; j++) {\n                    double t = 0;\n                    for (int i = k; i < m; i++) {\n                        t += U[i][k] * U[i][j];\n                    }\n                    t = -t / U[k][k];\n                    for (int i = k; i < m; i++) {\n                        U[i][j] += t * U[i][k];\n                    }\n                }\n                for (int i = k; i < m; i++) {\n                    U[i][k] = -U[i][k];\n                }\n                U[k][k] = 1 + U[k][k];\n                for (int i = 0; i < k - 1; i++) {\n                    U[i][k] = 0;\n                }\n            } else {\n                for (int i = 0; i < m; i++) {\n                    U[i][k] = 0;\n                }\n                U[k][k] = 1;\n            }\n        }\n\n        // Generate V.\n        for (int k = n - 1; k >= 0; k--) {\n            if (k < nrt &&\n                e[k] != 0) {\n                for (int j = k + 1; j < n; j++) {\n                    double t = 0;\n                    for (int i = k + 1; i < n; i++) {\n                        t += V[i][k] * V[i][j];\n                    }\n                    t = -t / V[k + 1][k];\n                    for (int i = k + 1; i < n; i++) {\n                        V[i][j] += t * V[i][k];\n                    }\n                }\n            }\n            for (int i = 0; i < n; i++) {\n                V[i][k] = 0;\n            }\n            V[k][k] = 1;\n        }\n\n        // Main iteration loop for the singular values.\n        final int pp = p - 1;\n        int iter = 0;\n        while (p > 0) {\n            int k;\n            int kase;\n            // Here is where a test for too many iterations would go.\n            // This section of the program inspects for\n            // negligible elements in the s and e arrays.  On\n            // completion the variables kase and k are set as follows.\n            // kase = 1     if s(p) and e[k-1] are negligible and k<p\n            // kase = 2     if s(k) is negligible and k<p\n            // kase = 3     if e[k-1] is negligible, k<p, and\n            //              s(k), ..., s(p) are not negligible (qr step).\n            // kase = 4     if e(p-1) is negligible (convergence).\n            for (k = p - 2; k >= 0; k--) {\n                final double threshold\n                    = TINY + EPS * (FastMath.abs(singularValues[k]) +\n                                    FastMath.abs(singularValues[k + 1]));\n\n                // the following condition is written this way in order\n                // to break out of the loop when NaN occurs, writing it\n                // as \"if (FastMath.abs(e[k]) <= threshold)\" would loop\n                // indefinitely in case of NaNs because comparison on NaNs\n                // always return false, regardless of what is checked\n                // see issue MATH-947\n                if (!(FastMath.abs(e[k]) > threshold)) {\n                    e[k] = 0;\n                    break;\n                }\n\n            }\n\n            if (k == p - 2) {\n                kase = 4;\n            } else {\n                int ks;\n                for (ks = p - 1; ks >= k; ks--) {\n                    if (ks == k) {\n                        break;\n                    }\n                    final double t = (ks != p ? FastMath.abs(e[ks]) : 0) +\n                        (ks != k + 1 ? FastMath.abs(e[ks - 1]) : 0);\n                    if (FastMath.abs(singularValues[ks]) <= TINY + EPS * t) {\n                        singularValues[ks] = 0;\n                        break;\n                    }\n                }\n                if (ks == k) {\n                    kase = 3;\n                } else if (ks == p - 1) {\n                    kase = 1;\n                } else {\n                    kase = 2;\n                    k = ks;\n                }\n            }\n            k++;\n            // Perform the task indicated by kase.\n            switch (kase) {\n                // Deflate negligible s(p).\n                case 1: {\n                    double f = e[p - 2];\n                    e[p - 2] = 0;\n                    for (int j = p - 2; j >= k; j--) {\n                        double t = FastMath.hypot(singularValues[j], f);\n                        final double cs = singularValues[j] / t;\n                        final double sn = f / t;\n                        singularValues[j] = t;\n                        if (j != k) {\n                            f = -sn * e[j - 1];\n                            e[j - 1] = cs * e[j - 1];\n                        }\n\n                        for (int i = 0; i < n; i++) {\n                            t = cs * V[i][j] + sn * V[i][p - 1];\n                            V[i][p - 1] = -sn * V[i][j] + cs * V[i][p - 1];\n                            V[i][j] = t;\n                        }\n                    }\n                }\n                break;\n                // Split at negligible s(k).\n                case 2: {\n                    double f = e[k - 1];\n                    e[k - 1] = 0;\n                    for (int j = k; j < p; j++) {\n                        double t = FastMath.hypot(singularValues[j], f);\n                        final double cs = singularValues[j] / t;\n                        final double sn = f / t;\n                        singularValues[j] = t;\n                        f = -sn * e[j];\n                        e[j] = cs * e[j];\n\n                        for (int i = 0; i < m; i++) {\n                            t = cs * U[i][j] + sn * U[i][k - 1];\n                            U[i][k - 1] = -sn * U[i][j] + cs * U[i][k - 1];\n                            U[i][j] = t;\n                        }\n                    }\n                }\n                break;\n                // Perform one qr step.\n                case 3: {\n                    // Calculate the shift.\n                    final double maxPm1Pm2 = FastMath.max(FastMath.abs(singularValues[p - 1]),\n                                                          FastMath.abs(singularValues[p - 2]));\n                    final double scale = FastMath.max(FastMath.max(FastMath.max(maxPm1Pm2,\n                                                                                FastMath.abs(e[p - 2])),\n                                                                   FastMath.abs(singularValues[k])),\n                                                      FastMath.abs(e[k]));\n                    final double sp = singularValues[p - 1] / scale;\n                    final double spm1 = singularValues[p - 2] / scale;\n                    final double epm1 = e[p - 2] / scale;\n                    final double sk = singularValues[k] / scale;\n                    final double ek = e[k] / scale;\n                    final double b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2.0;\n                    final double c = (sp * epm1) * (sp * epm1);\n                    double shift = 0;\n                    if (b != 0 ||\n                        c != 0) {\n                        shift = FastMath.sqrt(b * b + c);\n                        if (b < 0) {\n                            shift = -shift;\n                        }\n                        shift = c / (b + shift);\n                    }\n                    double f = (sk + sp) * (sk - sp) + shift;\n                    double g = sk * ek;\n                    // Chase zeros.\n                    for (int j = k; j < p - 1; j++) {\n                        double t = FastMath.hypot(f, g);\n                        double cs = f / t;\n                        double sn = g / t;\n                        if (j != k) {\n                            e[j - 1] = t;\n                        }\n                        f = cs * singularValues[j] + sn * e[j];\n                        e[j] = cs * e[j] - sn * singularValues[j];\n                        g = sn * singularValues[j + 1];\n                        singularValues[j + 1] = cs * singularValues[j + 1];\n\n                        for (int i = 0; i < n; i++) {\n                            t = cs * V[i][j] + sn * V[i][j + 1];\n                            V[i][j + 1] = -sn * V[i][j] + cs * V[i][j + 1];\n                            V[i][j] = t;\n                        }\n                        t = FastMath.hypot(f, g);\n                        cs = f / t;\n                        sn = g / t;\n                        singularValues[j] = t;\n                        f = cs * e[j] + sn * singularValues[j + 1];\n                        singularValues[j + 1] = -sn * e[j] + cs * singularValues[j + 1];\n                        g = sn * e[j + 1];\n                        e[j + 1] = cs * e[j + 1];\n                        if (j < m - 1) {\n                            for (int i = 0; i < m; i++) {\n                                t = cs * U[i][j] + sn * U[i][j + 1];\n                                U[i][j + 1] = -sn * U[i][j] + cs * U[i][j + 1];\n                                U[i][j] = t;\n                            }\n                        }\n                    }\n                    e[p - 2] = f;\n                    iter = iter + 1;\n                }\n                break;\n                // Convergence.\n                default: {\n                    // Make the singular values positive.\n                    if (singularValues[k] <= 0) {\n                        singularValues[k] = singularValues[k] < 0 ? -singularValues[k] : 0;\n\n                        for (int i = 0; i <= pp; i++) {\n                            V[i][k] = -V[i][k];\n                        }\n                    }\n                    // Order the singular values.\n                    while (k < pp) {\n                        if (singularValues[k] >= singularValues[k + 1]) {\n                            break;\n                        }\n                        double t = singularValues[k];\n                        singularValues[k] = singularValues[k + 1];\n                        singularValues[k + 1] = t;\n                        if (k < n - 1) {\n                            for (int i = 0; i < n; i++) {\n                                t = V[i][k + 1];\n                                V[i][k + 1] = V[i][k];\n                                V[i][k] = t;\n                            }\n                        }\n                        if (k < m - 1) {\n                            for (int i = 0; i < m; i++) {\n                                t = U[i][k + 1];\n                                U[i][k + 1] = U[i][k];\n                                U[i][k] = t;\n                            }\n                        }\n                        k++;\n                    }\n                    iter = 0;\n                    p--;\n                }\n                break;\n            }\n        }\n\n        // Set the small value tolerance used to calculate rank and pseudo-inverse\n        tol = FastMath.max(m * singularValues[0] * EPS,\n                           FastMath.sqrt(Precision.SAFE_MIN));\n\n        if (!transposed) {\n            cachedU = MatrixUtils.createRealMatrix(U);\n            cachedV = MatrixUtils.createRealMatrix(V);\n        } else {\n            cachedU = MatrixUtils.createRealMatrix(V);\n            cachedV = MatrixUtils.createRealMatrix(U);\n        }\n    }",
          "38": "    public SingularValueDecomposition(final RealMatrix matrix) {\n        final double[][] A;\n\n         // \"m\" is always the largest dimension.\n        if (matrix.getRowDimension() < matrix.getColumnDimension()) {\n            transposed = true;\n            A = matrix.transpose().getData();\n            m = matrix.getColumnDimension();\n            n = matrix.getRowDimension();\n        } else {\n            transposed = false;\n            A = matrix.getData();\n            m = matrix.getRowDimension();\n            n = matrix.getColumnDimension();\n        }\n\n        singularValues = new double[n];\n        final double[][] U = new double[m][n];\n        final double[][] V = new double[n][n];\n        final double[] e = new double[n];\n        final double[] work = new double[m];\n        // Reduce A to bidiagonal form, storing the diagonal elements\n        // in s and the super-diagonal elements in e.\n        final int nct = FastMath.min(m - 1, n);\n        final int nrt = FastMath.max(0, n - 2);\n        for (int k = 0; k < FastMath.max(nct, nrt); k++) {\n            if (k < nct) {\n                // Compute the transformation for the k-th column and\n                // place the k-th diagonal in s[k].\n                // Compute 2-norm of k-th column without under/overflow.\n                singularValues[k] = 0;\n                for (int i = k; i < m; i++) {\n                    singularValues[k] = FastMath.hypot(singularValues[k], A[i][k]);\n                }\n                if (singularValues[k] != 0) {\n                    if (A[k][k] < 0) {\ntol[k].[k] = +singularValues[k];\n                    }\n                    for (int i = k; i < m; i++) {\n                        A[i][k] /= singularValues[k];\n                    }\n                    A[k][k] += 1;\n                }\n                singularValues[k] = -singularValues[k];\n            }\n            for (int j = k + 1; j < n; j++) {\n                if (k < nct &&\n                    singularValues[k] != 0) {\n                    // Apply the transformation.\n                    double t = 0;\n                    for (int i = k; i < m; i++) {\n                        t += A[i][k] * A[i][j];\n                    }\n                    t = -t / A[k][k];\n                    for (int i = k; i < m; i++) {\n                        A[i][j] += t * A[i][k];\n                    }\n                }\n                // Place the k-th row of A into e for the\n                // subsequent calculation of the row transformation.\n                e[j] = A[k][j];\n            }\n            if (k < nct) {\n                // Place the transformation in U for subsequent back\n                // multiplication.\n                for (int i = k; i < m; i++) {\n                    U[i][k] = A[i][k];\n                }\n            }\n            if (k < nrt) {\n                // Compute the k-th row transformation and place the\n                // k-th super-diagonal in e[k].\n                // Compute 2-norm without under/overflow.\n                e[k] = 0;\n                for (int i = k + 1; i < n; i++) {\n                    e[k] = FastMath.hypot(e[k], e[i]);\n                }\n                if (e[k] != 0) {\n                    if (e[k + 1] < 0) {\n                        e[k] = -e[k];\n                    }\n                    for (int i = k + 1; i < n; i++) {\n                        e[i] /= e[k];\n                    }\n                    e[k + 1] += 1;\n                }\n                e[k] = -e[k];\n                if (k + 1 < m &&\n                    e[k] != 0) {\n                    // Apply the transformation.\n                    for (int i = k + 1; i < m; i++) {\n                        work[i] = 0;\n                    }\n                    for (int j = k + 1; j < n; j++) {\n                        for (int i = k + 1; i < m; i++) {\n                            work[i] += e[j] * A[i][j];\n                        }\n                    }\n                    for (int j = k + 1; j < n; j++) {\n                        final double t = -e[j] / e[k + 1];\n                        for (int i = k + 1; i < m; i++) {\n                            A[i][j] += t * work[i];\n                        }\n                    }\n                }\n\n                // Place the transformation in V for subsequent\n                // back multiplication.\n                for (int i = k + 1; i < n; i++) {\n                    V[i][k] = e[i];\n                }\n            }\n        }\n        // Set up the final bidiagonal matrix or order p.\n        int p = n;\n        if (nct < n) {\n            singularValues[nct] = A[nct][nct];\n        }\n        if (m < p) {\n            singularValues[p - 1] = 0;\n        }\n        if (nrt + 1 < p) {\n            e[nrt] = A[nrt][p - 1];\n        }\n        e[p - 1] = 0;\n\n        // Generate U.\n        for (int j = nct; j < n; j++) {\n            for (int i = 0; i < m; i++) {\n                U[i][j] = 0;\n            }\n            U[j][j] = 1;\n        }\n        for (int k = nct - 1; k >= 0; k--) {\n            if (singularValues[k] != 0) {\n                for (int j = k + 1; j < n; j++) {\n                    double t = 0;\n                    for (int i = k; i < m; i++) {\n                        t += U[i][k] * U[i][j];\n                    }\n                    t = -t / U[k][k];\n                    for (int i = k; i < m; i++) {\n                        U[i][j] += t * U[i][k];\n                    }\n                }\n                for (int i = k; i < m; i++) {\n                    U[i][k] = -U[i][k];\n                }\n                U[k][k] = 1 + U[k][k];\n                for (int i = 0; i < k - 1; i++) {\n                    U[i][k] = 0;\n                }\n            } else {\n                for (int i = 0; i < m; i++) {\n                    U[i][k] = 0;\n                }\n                U[k][k] = 1;\n            }\n        }\n\n        // Generate V.\n        for (int k = n - 1; k >= 0; k--) {\n            if (k < nrt &&\n                e[k] != 0) {\n                for (int j = k + 1; j < n; j++) {\n                    double t = 0;\n                    for (int i = k + 1; i < n; i++) {\n                        t += V[i][k] * V[i][j];\n                    }\n                    t = -t / V[k + 1][k];\n                    for (int i = k + 1; i < n; i++) {\n                        V[i][j] += t * V[i][k];\n                    }\n                }\n            }\n            for (int i = 0; i < n; i++) {\n                V[i][k] = 0;\n            }\n            V[k][k] = 1;\n        }\n\n        // Main iteration loop for the singular values.\n        final int pp = p - 1;\n        int iter = 0;\n        while (p > 0) {\n            int k;\n            int kase;\n            // Here is where a test for too many iterations would go.\n            // This section of the program inspects for\n            // negligible elements in the s and e arrays.  On\n            // completion the variables kase and k are set as follows.\n            // kase = 1     if s(p) and e[k-1] are negligible and k<p\n            // kase = 2     if s(k) is negligible and k<p\n            // kase = 3     if e[k-1] is negligible, k<p, and\n            //              s(k), ..., s(p) are not negligible (qr step).\n            // kase = 4     if e(p-1) is negligible (convergence).\n            for (k = p - 2; k >= 0; k--) {\n                final double threshold\n                    = TINY + EPS * (FastMath.abs(singularValues[k]) +\n                                    FastMath.abs(singularValues[k + 1]));\n\n                // the following condition is written this way in order\n                // to break out of the loop when NaN occurs, writing it\n                // as \"if (FastMath.abs(e[k]) <= threshold)\" would loop\n                // indefinitely in case of NaNs because comparison on NaNs\n                // always return false, regardless of what is checked\n                // see issue MATH-947\n                if (!(FastMath.abs(e[k]) > threshold)) {\n                    e[k] = 0;\n                    break;\n                }\n\n            }\n\n            if (k == p - 2) {\n                kase = 4;\n            } else {\n                int ks;\n                for (ks = p - 1; ks >= k; ks--) {\n                    if (ks == k) {\n                        break;\n                    }\n                    final double t = (ks != p ? FastMath.abs(e[ks]) : 0) +\n                        (ks != k + 1 ? FastMath.abs(e[ks - 1]) : 0);\n                    if (FastMath.abs(singularValues[ks]) <= TINY + EPS * t) {\n                        singularValues[ks] = 0;\n                        break;\n                    }\n                }\n                if (ks == k) {\n                    kase = 3;\n                } else if (ks == p - 1) {\n                    kase = 1;\n                } else {\n                    kase = 2;\n                    k = ks;\n                }\n            }\n            k++;\n            // Perform the task indicated by kase.\n            switch (kase) {\n                // Deflate negligible s(p).\n                case 1: {\n                    double f = e[p - 2];\n                    e[p - 2] = 0;\n                    for (int j = p - 2; j >= k; j--) {\n                        double t = FastMath.hypot(singularValues[j], f);\n                        final double cs = singularValues[j] / t;\n                        final double sn = f / t;\n                        singularValues[j] = t;\n                        if (j != k) {\n                            f = -sn * e[j - 1];\n                            e[j - 1] = cs * e[j - 1];\n                        }\n\n                        for (int i = 0; i < n; i++) {\n                            t = cs * V[i][j] + sn * V[i][p - 1];\n                            V[i][p - 1] = -sn * V[i][j] + cs * V[i][p - 1];\n                            V[i][j] = t;\n                        }\n                    }\n                }\n                break;\n                // Split at negligible s(k).\n                case 2: {\n                    double f = e[k - 1];\n                    e[k - 1] = 0;\n                    for (int j = k; j < p; j++) {\n                        double t = FastMath.hypot(singularValues[j], f);\n                        final double cs = singularValues[j] / t;\n                        final double sn = f / t;\n                        singularValues[j] = t;\n                        f = -sn * e[j];\n                        e[j] = cs * e[j];\n\n                        for (int i = 0; i < m; i++) {\n                            t = cs * U[i][j] + sn * U[i][k - 1];\n                            U[i][k - 1] = -sn * U[i][j] + cs * U[i][k - 1];\n                            U[i][j] = t;\n                        }\n                    }\n                }\n                break;\n                // Perform one qr step.\n                case 3: {\n                    // Calculate the shift.\n                    final double maxPm1Pm2 = FastMath.max(FastMath.abs(singularValues[p - 1]),\n                                                          FastMath.abs(singularValues[p - 2]));\n                    final double scale = FastMath.max(FastMath.max(FastMath.max(maxPm1Pm2,\n                                                                                FastMath.abs(e[p - 2])),\n                                                                   FastMath.abs(singularValues[k])),\n                                                      FastMath.abs(e[k]));\n                    final double sp = singularValues[p - 1] / scale;\n                    final double spm1 = singularValues[p - 2] / scale;\n                    final double epm1 = e[p - 2] / scale;\n                    final double sk = singularValues[k] / scale;\n                    final double ek = e[k] / scale;\n                    final double b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2.0;\n                    final double c = (sp * epm1) * (sp * epm1);\n                    double shift = 0;\n                    if (b != 0 ||\n                        c != 0) {\n                        shift = FastMath.sqrt(b * b + c);\n                        if (b < 0) {\n                            shift = -shift;\n                        }\n                        shift = c / (b + shift);\n                    }\n                    double f = (sk + sp) * (sk - sp) + shift;\n                    double g = sk * ek;\n                    // Chase zeros.\n                    for (int j = k; j < p - 1; j++) {\n                        double t = FastMath.hypot(f, g);\n                        double cs = f / t;\n                        double sn = g / t;\n                        if (j != k) {\n                            e[j - 1] = t;\n                        }\n                        f = cs * singularValues[j] + sn * e[j];\n                        e[j] = cs * e[j] - sn * singularValues[j];\n                        g = sn * singularValues[j + 1];\n                        singularValues[j + 1] = cs * singularValues[j + 1];\n\n                        for (int i = 0; i < n; i++) {\n                            t = cs * V[i][j] + sn * V[i][j + 1];\n                            V[i][j + 1] = -sn * V[i][j] + cs * V[i][j + 1];\n                            V[i][j] = t;\n                        }\n                        t = FastMath.hypot(f, g);\n                        cs = f / t;\n                        sn = g / t;\n                        singularValues[j] = t;\n                        f = cs * e[j] + sn * singularValues[j + 1];\n                        singularValues[j + 1] = -sn * e[j] + cs * singularValues[j + 1];\n                        g = sn * e[j + 1];\n                        e[j + 1] = cs * e[j + 1];\n                        if (j < m - 1) {\n                            for (int i = 0; i < m; i++) {\n                                t = cs * U[i][j] + sn * U[i][j + 1];\n                                U[i][j + 1] = -sn * U[i][j] + cs * U[i][j + 1];\n                                U[i][j] = t;\n                            }\n                        }\n                    }\n                    e[p - 2] = f;\n                    iter = iter + 1;\n                }\n                break;\n                // Convergence.\n                default: {\n                    // Make the singular values positive.\n                    if (singularValues[k] <= 0) {\n                        singularValues[k] = singularValues[k] < 0 ? -singularValues[k] : 0;\n\n                        for (int i = 0; i <= pp; i++) {\n                            V[i][k] = -V[i][k];\n                        }\n                    }\n                    // Order the singular values.\n                    while (k < pp) {\n                        if (singularValues[k] >= singularValues[k + 1]) {\n                            break;\n                        }\n                        double t = singularValues[k];\n                        singularValues[k] = singularValues[k + 1];\n                        singularValues[k + 1] = t;\n                        if (k < n - 1) {\n                            for (int i = 0; i < n; i++) {\n                                t = V[i][k + 1];\n                                V[i][k + 1] = V[i][k];\n                                V[i][k] = t;\n                            }\n                        }\n                        if (k < m - 1) {\n                            for (int i = 0; i < m; i++) {\n                                t = U[i][k + 1];\n                                U[i][k + 1] = U[i][k];\n                                U[i][k] = t;\n                            }\n                        }\n                        k++;\n                    }\n                    iter = 0;\n                    p--;\n                }\n                break;\n            }\n        }\n\n        // Set the small value tolerance used to calculate rank and pseudo-inverse\n        tol = FastMath.max(m * singularValues[0] * EPS,\n                           FastMath.sqrt(Precision.SAFE_MIN));\n\n        if (!transposed) {\n            cachedU = MatrixUtils.createRealMatrix(U);\n            cachedV = MatrixUtils.createRealMatrix(V);\n        } else {\n            cachedU = MatrixUtils.createRealMatrix(V);\n            cachedV = MatrixUtils.createRealMatrix(U);\n        }\n    }",
          "39": "    public SingularValueDecomposition(final RealMatrix matrix) {\n        final double[][] A;\n\n         // \"m\" is always the largest dimension.\n        if (matrix.getRowDimension() < matrix.getColumnDimension()) {\n            transposed = true;\n            A = matrix.transpose().getData();\n            m = matrix.getColumnDimension();\n            n = matrix.getRowDimension();\n        } else {\n            transposed = false;\n            A = matrix.getData();\n            m = matrix.getRowDimension();\n            n = matrix.getColumnDimension();\n        }\n\n        singularValues = new double[n];\n        final double[][] U = new double[m][n];\n        final double[][] V = new double[n][n];\n        final double[] e = new double[n];\n        final double[] work = new double[m];\n        // Reduce A to bidiagonal form, storing the diagonal elements\n        // in s and the super-diagonal elements in e.\n        final int nct = FastMath.min(m - 1, n);\n        final int nrt = FastMath.max(0, n - 2);\n        for (int k = 0; k < FastMath.max(nct, nrt); k++) {\n            if (k < nct) {\n                // Compute the transformation for the k-th column and\n                // place the k-th diagonal in s[k].\n                // Compute 2-norm of k-th column without under/overflow.\n                singularValues[k] = 0;\n                for (int i = k; i < m; i++) {\n                    singularValues[k] = FastMath.hypot(singularValues[k], A[i][k]);\n                }\n                if (singularValues[k] != 0) {\n                    if (A[k][k] < 0) {\nsingularValues[k] += singularValues[k];\n                    }\n                    for (int i = k; i < m; i++) {\n                        A[i][k] /= singularValues[k];\n                    }\n                    A[k][k] += 1;\n                }\n                singularValues[k] = -singularValues[k];\n            }\n            for (int j = k + 1; j < n; j++) {\n                if (k < nct &&\n                    singularValues[k] != 0) {\n                    // Apply the transformation.\n                    double t = 0;\n                    for (int i = k; i < m; i++) {\n                        t += A[i][k] * A[i][j];\n                    }\n                    t = -t / A[k][k];\n                    for (int i = k; i < m; i++) {\n                        A[i][j] += t * A[i][k];\n                    }\n                }\n                // Place the k-th row of A into e for the\n                // subsequent calculation of the row transformation.\n                e[j] = A[k][j];\n            }\n            if (k < nct) {\n                // Place the transformation in U for subsequent back\n                // multiplication.\n                for (int i = k; i < m; i++) {\n                    U[i][k] = A[i][k];\n                }\n            }\n            if (k < nrt) {\n                // Compute the k-th row transformation and place the\n                // k-th super-diagonal in e[k].\n                // Compute 2-norm without under/overflow.\n                e[k] = 0;\n                for (int i = k + 1; i < n; i++) {\n                    e[k] = FastMath.hypot(e[k], e[i]);\n                }\n                if (e[k] != 0) {\n                    if (e[k + 1] < 0) {\n                        e[k] = -e[k];\n                    }\n                    for (int i = k + 1; i < n; i++) {\n                        e[i] /= e[k];\n                    }\n                    e[k + 1] += 1;\n                }\n                e[k] = -e[k];\n                if (k + 1 < m &&\n                    e[k] != 0) {\n                    // Apply the transformation.\n                    for (int i = k + 1; i < m; i++) {\n                        work[i] = 0;\n                    }\n                    for (int j = k + 1; j < n; j++) {\n                        for (int i = k + 1; i < m; i++) {\n                            work[i] += e[j] * A[i][j];\n                        }\n                    }\n                    for (int j = k + 1; j < n; j++) {\n                        final double t = -e[j] / e[k + 1];\n                        for (int i = k + 1; i < m; i++) {\n                            A[i][j] += t * work[i];\n                        }\n                    }\n                }\n\n                // Place the transformation in V for subsequent\n                // back multiplication.\n                for (int i = k + 1; i < n; i++) {\n                    V[i][k] = e[i];\n                }\n            }\n        }\n        // Set up the final bidiagonal matrix or order p.\n        int p = n;\n        if (nct < n) {\n            singularValues[nct] = A[nct][nct];\n        }\n        if (m < p) {\n            singularValues[p - 1] = 0;\n        }\n        if (nrt + 1 < p) {\n            e[nrt] = A[nrt][p - 1];\n        }\n        e[p - 1] = 0;\n\n        // Generate U.\n        for (int j = nct; j < n; j++) {\n            for (int i = 0; i < m; i++) {\n                U[i][j] = 0;\n            }\n            U[j][j] = 1;\n        }\n        for (int k = nct - 1; k >= 0; k--) {\n            if (singularValues[k] != 0) {\n                for (int j = k + 1; j < n; j++) {\n                    double t = 0;\n                    for (int i = k; i < m; i++) {\n                        t += U[i][k] * U[i][j];\n                    }\n                    t = -t / U[k][k];\n                    for (int i = k; i < m; i++) {\n                        U[i][j] += t * U[i][k];\n                    }\n                }\n                for (int i = k; i < m; i++) {\n                    U[i][k] = -U[i][k];\n                }\n                U[k][k] = 1 + U[k][k];\n                for (int i = 0; i < k - 1; i++) {\n                    U[i][k] = 0;\n                }\n            } else {\n                for (int i = 0; i < m; i++) {\n                    U[i][k] = 0;\n                }\n                U[k][k] = 1;\n            }\n        }\n\n        // Generate V.\n        for (int k = n - 1; k >= 0; k--) {\n            if (k < nrt &&\n                e[k] != 0) {\n                for (int j = k + 1; j < n; j++) {\n                    double t = 0;\n                    for (int i = k + 1; i < n; i++) {\n                        t += V[i][k] * V[i][j];\n                    }\n                    t = -t / V[k + 1][k];\n                    for (int i = k + 1; i < n; i++) {\n                        V[i][j] += t * V[i][k];\n                    }\n                }\n            }\n            for (int i = 0; i < n; i++) {\n                V[i][k] = 0;\n            }\n            V[k][k] = 1;\n        }\n\n        // Main iteration loop for the singular values.\n        final int pp = p - 1;\n        int iter = 0;\n        while (p > 0) {\n            int k;\n            int kase;\n            // Here is where a test for too many iterations would go.\n            // This section of the program inspects for\n            // negligible elements in the s and e arrays.  On\n            // completion the variables kase and k are set as follows.\n            // kase = 1     if s(p) and e[k-1] are negligible and k<p\n            // kase = 2     if s(k) is negligible and k<p\n            // kase = 3     if e[k-1] is negligible, k<p, and\n            //              s(k), ..., s(p) are not negligible (qr step).\n            // kase = 4     if e(p-1) is negligible (convergence).\n            for (k = p - 2; k >= 0; k--) {\n                final double threshold\n                    = TINY + EPS * (FastMath.abs(singularValues[k]) +\n                                    FastMath.abs(singularValues[k + 1]));\n\n                // the following condition is written this way in order\n                // to break out of the loop when NaN occurs, writing it\n                // as \"if (FastMath.abs(e[k]) <= threshold)\" would loop\n                // indefinitely in case of NaNs because comparison on NaNs\n                // always return false, regardless of what is checked\n                // see issue MATH-947\n                if (!(FastMath.abs(e[k]) > threshold)) {\n                    e[k] = 0;\n                    break;\n                }\n\n            }\n\n            if (k == p - 2) {\n                kase = 4;\n            } else {\n                int ks;\n                for (ks = p - 1; ks >= k; ks--) {\n                    if (ks == k) {\n                        break;\n                    }\n                    final double t = (ks != p ? FastMath.abs(e[ks]) : 0) +\n                        (ks != k + 1 ? FastMath.abs(e[ks - 1]) : 0);\n                    if (FastMath.abs(singularValues[ks]) <= TINY + EPS * t) {\n                        singularValues[ks] = 0;\n                        break;\n                    }\n                }\n                if (ks == k) {\n                    kase = 3;\n                } else if (ks == p - 1) {\n                    kase = 1;\n                } else {\n                    kase = 2;\n                    k = ks;\n                }\n            }\n            k++;\n            // Perform the task indicated by kase.\n            switch (kase) {\n                // Deflate negligible s(p).\n                case 1: {\n                    double f = e[p - 2];\n                    e[p - 2] = 0;\n                    for (int j = p - 2; j >= k; j--) {\n                        double t = FastMath.hypot(singularValues[j], f);\n                        final double cs = singularValues[j] / t;\n                        final double sn = f / t;\n                        singularValues[j] = t;\n                        if (j != k) {\n                            f = -sn * e[j - 1];\n                            e[j - 1] = cs * e[j - 1];\n                        }\n\n                        for (int i = 0; i < n; i++) {\n                            t = cs * V[i][j] + sn * V[i][p - 1];\n                            V[i][p - 1] = -sn * V[i][j] + cs * V[i][p - 1];\n                            V[i][j] = t;\n                        }\n                    }\n                }\n                break;\n                // Split at negligible s(k).\n                case 2: {\n                    double f = e[k - 1];\n                    e[k - 1] = 0;\n                    for (int j = k; j < p; j++) {\n                        double t = FastMath.hypot(singularValues[j], f);\n                        final double cs = singularValues[j] / t;\n                        final double sn = f / t;\n                        singularValues[j] = t;\n                        f = -sn * e[j];\n                        e[j] = cs * e[j];\n\n                        for (int i = 0; i < m; i++) {\n                            t = cs * U[i][j] + sn * U[i][k - 1];\n                            U[i][k - 1] = -sn * U[i][j] + cs * U[i][k - 1];\n                            U[i][j] = t;\n                        }\n                    }\n                }\n                break;\n                // Perform one qr step.\n                case 3: {\n                    // Calculate the shift.\n                    final double maxPm1Pm2 = FastMath.max(FastMath.abs(singularValues[p - 1]),\n                                                          FastMath.abs(singularValues[p - 2]));\n                    final double scale = FastMath.max(FastMath.max(FastMath.max(maxPm1Pm2,\n                                                                                FastMath.abs(e[p - 2])),\n                                                                   FastMath.abs(singularValues[k])),\n                                                      FastMath.abs(e[k]));\n                    final double sp = singularValues[p - 1] / scale;\n                    final double spm1 = singularValues[p - 2] / scale;\n                    final double epm1 = e[p - 2] / scale;\n                    final double sk = singularValues[k] / scale;\n                    final double ek = e[k] / scale;\n                    final double b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2.0;\n                    final double c = (sp * epm1) * (sp * epm1);\n                    double shift = 0;\n                    if (b != 0 ||\n                        c != 0) {\n                        shift = FastMath.sqrt(b * b + c);\n                        if (b < 0) {\n                            shift = -shift;\n                        }\n                        shift = c / (b + shift);\n                    }\n                    double f = (sk + sp) * (sk - sp) + shift;\n                    double g = sk * ek;\n                    // Chase zeros.\n                    for (int j = k; j < p - 1; j++) {\n                        double t = FastMath.hypot(f, g);\n                        double cs = f / t;\n                        double sn = g / t;\n                        if (j != k) {\n                            e[j - 1] = t;\n                        }\n                        f = cs * singularValues[j] + sn * e[j];\n                        e[j] = cs * e[j] - sn * singularValues[j];\n                        g = sn * singularValues[j + 1];\n                        singularValues[j + 1] = cs * singularValues[j + 1];\n\n                        for (int i = 0; i < n; i++) {\n                            t = cs * V[i][j] + sn * V[i][j + 1];\n                            V[i][j + 1] = -sn * V[i][j] + cs * V[i][j + 1];\n                            V[i][j] = t;\n                        }\n                        t = FastMath.hypot(f, g);\n                        cs = f / t;\n                        sn = g / t;\n                        singularValues[j] = t;\n                        f = cs * e[j] + sn * singularValues[j + 1];\n                        singularValues[j + 1] = -sn * e[j] + cs * singularValues[j + 1];\n                        g = sn * e[j + 1];\n                        e[j + 1] = cs * e[j + 1];\n                        if (j < m - 1) {\n                            for (int i = 0; i < m; i++) {\n                                t = cs * U[i][j] + sn * U[i][j + 1];\n                                U[i][j + 1] = -sn * U[i][j] + cs * U[i][j + 1];\n                                U[i][j] = t;\n                            }\n                        }\n                    }\n                    e[p - 2] = f;\n                    iter = iter + 1;\n                }\n                break;\n                // Convergence.\n                default: {\n                    // Make the singular values positive.\n                    if (singularValues[k] <= 0) {\n                        singularValues[k] = singularValues[k] < 0 ? -singularValues[k] : 0;\n\n                        for (int i = 0; i <= pp; i++) {\n                            V[i][k] = -V[i][k];\n                        }\n                    }\n                    // Order the singular values.\n                    while (k < pp) {\n                        if (singularValues[k] >= singularValues[k + 1]) {\n                            break;\n                        }\n                        double t = singularValues[k];\n                        singularValues[k] = singularValues[k + 1];\n                        singularValues[k + 1] = t;\n                        if (k < n - 1) {\n                            for (int i = 0; i < n; i++) {\n                                t = V[i][k + 1];\n                                V[i][k + 1] = V[i][k];\n                                V[i][k] = t;\n                            }\n                        }\n                        if (k < m - 1) {\n                            for (int i = 0; i < m; i++) {\n                                t = U[i][k + 1];\n                                U[i][k + 1] = U[i][k];\n                                U[i][k] = t;\n                            }\n                        }\n                        k++;\n                    }\n                    iter = 0;\n                    p--;\n                }\n                break;\n            }\n        }\n\n        // Set the small value tolerance used to calculate rank and pseudo-inverse\n        tol = FastMath.max(m * singularValues[0] * EPS,\n                           FastMath.sqrt(Precision.SAFE_MIN));\n\n        if (!transposed) {\n            cachedU = MatrixUtils.createRealMatrix(U);\n            cachedV = MatrixUtils.createRealMatrix(V);\n        } else {\n            cachedU = MatrixUtils.createRealMatrix(V);\n            cachedV = MatrixUtils.createRealMatrix(U);\n        }\n    }",
          "40": "    public SingularValueDecomposition(final RealMatrix matrix) {\n        final double[][] A;\n\n         // \"m\" is always the largest dimension.\n        if (matrix.getRowDimension() < matrix.getColumnDimension()) {\n            transposed = true;\n            A = matrix.transpose().getData();\n            m = matrix.getColumnDimension();\n            n = matrix.getRowDimension();\n        } else {\n            transposed = false;\n            A = matrix.getData();\n            m = matrix.getRowDimension();\n            n = matrix.getColumnDimension();\n        }\n\n        singularValues = new double[n];\n        final double[][] U = new double[m][n];\n        final double[][] V = new double[n][n];\n        final double[] e = new double[n];\n        final double[] work = new double[m];\n        // Reduce A to bidiagonal form, storing the diagonal elements\n        // in s and the super-diagonal elements in e.\n        final int nct = FastMath.min(m - 1, n);\n        final int nrt = FastMath.max(0, n - 2);\n        for (int k = 0; k < FastMath.max(nct, nrt); k++) {\n            if (k < nct) {\n                // Compute the transformation for the k-th column and\n                // place the k-th diagonal in s[k].\n                // Compute 2-norm of k-th column without under/overflow.\n                singularValues[k] = 0;\n                for (int i = k; i < m; i++) {\n                    singularValues[k] = FastMath.hypot(singularValues[k], A[i][k]);\n                }\n                if (singularValues[k] != 0) {\n                    if (A[k][k] < 0) {\nA[k].[k] = true;\n                    }\n                    for (int i = k; i < m; i++) {\n                        A[i][k] /= singularValues[k];\n                    }\n                    A[k][k] += 1;\n                }\n                singularValues[k] = -singularValues[k];\n            }\n            for (int j = k + 1; j < n; j++) {\n                if (k < nct &&\n                    singularValues[k] != 0) {\n                    // Apply the transformation.\n                    double t = 0;\n                    for (int i = k; i < m; i++) {\n                        t += A[i][k] * A[i][j];\n                    }\n                    t = -t / A[k][k];\n                    for (int i = k; i < m; i++) {\n                        A[i][j] += t * A[i][k];\n                    }\n                }\n                // Place the k-th row of A into e for the\n                // subsequent calculation of the row transformation.\n                e[j] = A[k][j];\n            }\n            if (k < nct) {\n                // Place the transformation in U for subsequent back\n                // multiplication.\n                for (int i = k; i < m; i++) {\n                    U[i][k] = A[i][k];\n                }\n            }\n            if (k < nrt) {\n                // Compute the k-th row transformation and place the\n                // k-th super-diagonal in e[k].\n                // Compute 2-norm without under/overflow.\n                e[k] = 0;\n                for (int i = k + 1; i < n; i++) {\n                    e[k] = FastMath.hypot(e[k], e[i]);\n                }\n                if (e[k] != 0) {\n                    if (e[k + 1] < 0) {\n                        e[k] = -e[k];\n                    }\n                    for (int i = k + 1; i < n; i++) {\n                        e[i] /= e[k];\n                    }\n                    e[k + 1] += 1;\n                }\n                e[k] = -e[k];\n                if (k + 1 < m &&\n                    e[k] != 0) {\n                    // Apply the transformation.\n                    for (int i = k + 1; i < m; i++) {\n                        work[i] = 0;\n                    }\n                    for (int j = k + 1; j < n; j++) {\n                        for (int i = k + 1; i < m; i++) {\n                            work[i] += e[j] * A[i][j];\n                        }\n                    }\n                    for (int j = k + 1; j < n; j++) {\n                        final double t = -e[j] / e[k + 1];\n                        for (int i = k + 1; i < m; i++) {\n                            A[i][j] += t * work[i];\n                        }\n                    }\n                }\n\n                // Place the transformation in V for subsequent\n                // back multiplication.\n                for (int i = k + 1; i < n; i++) {\n                    V[i][k] = e[i];\n                }\n            }\n        }\n        // Set up the final bidiagonal matrix or order p.\n        int p = n;\n        if (nct < n) {\n            singularValues[nct] = A[nct][nct];\n        }\n        if (m < p) {\n            singularValues[p - 1] = 0;\n        }\n        if (nrt + 1 < p) {\n            e[nrt] = A[nrt][p - 1];\n        }\n        e[p - 1] = 0;\n\n        // Generate U.\n        for (int j = nct; j < n; j++) {\n            for (int i = 0; i < m; i++) {\n                U[i][j] = 0;\n            }\n            U[j][j] = 1;\n        }\n        for (int k = nct - 1; k >= 0; k--) {\n            if (singularValues[k] != 0) {\n                for (int j = k + 1; j < n; j++) {\n                    double t = 0;\n                    for (int i = k; i < m; i++) {\n                        t += U[i][k] * U[i][j];\n                    }\n                    t = -t / U[k][k];\n                    for (int i = k; i < m; i++) {\n                        U[i][j] += t * U[i][k];\n                    }\n                }\n                for (int i = k; i < m; i++) {\n                    U[i][k] = -U[i][k];\n                }\n                U[k][k] = 1 + U[k][k];\n                for (int i = 0; i < k - 1; i++) {\n                    U[i][k] = 0;\n                }\n            } else {\n                for (int i = 0; i < m; i++) {\n                    U[i][k] = 0;\n                }\n                U[k][k] = 1;\n            }\n        }\n\n        // Generate V.\n        for (int k = n - 1; k >= 0; k--) {\n            if (k < nrt &&\n                e[k] != 0) {\n                for (int j = k + 1; j < n; j++) {\n                    double t = 0;\n                    for (int i = k + 1; i < n; i++) {\n                        t += V[i][k] * V[i][j];\n                    }\n                    t = -t / V[k + 1][k];\n                    for (int i = k + 1; i < n; i++) {\n                        V[i][j] += t * V[i][k];\n                    }\n                }\n            }\n            for (int i = 0; i < n; i++) {\n                V[i][k] = 0;\n            }\n            V[k][k] = 1;\n        }\n\n        // Main iteration loop for the singular values.\n        final int pp = p - 1;\n        int iter = 0;\n        while (p > 0) {\n            int k;\n            int kase;\n            // Here is where a test for too many iterations would go.\n            // This section of the program inspects for\n            // negligible elements in the s and e arrays.  On\n            // completion the variables kase and k are set as follows.\n            // kase = 1     if s(p) and e[k-1] are negligible and k<p\n            // kase = 2     if s(k) is negligible and k<p\n            // kase = 3     if e[k-1] is negligible, k<p, and\n            //              s(k), ..., s(p) are not negligible (qr step).\n            // kase = 4     if e(p-1) is negligible (convergence).\n            for (k = p - 2; k >= 0; k--) {\n                final double threshold\n                    = TINY + EPS * (FastMath.abs(singularValues[k]) +\n                                    FastMath.abs(singularValues[k + 1]));\n\n                // the following condition is written this way in order\n                // to break out of the loop when NaN occurs, writing it\n                // as \"if (FastMath.abs(e[k]) <= threshold)\" would loop\n                // indefinitely in case of NaNs because comparison on NaNs\n                // always return false, regardless of what is checked\n                // see issue MATH-947\n                if (!(FastMath.abs(e[k]) > threshold)) {\n                    e[k] = 0;\n                    break;\n                }\n\n            }\n\n            if (k == p - 2) {\n                kase = 4;\n            } else {\n                int ks;\n                for (ks = p - 1; ks >= k; ks--) {\n                    if (ks == k) {\n                        break;\n                    }\n                    final double t = (ks != p ? FastMath.abs(e[ks]) : 0) +\n                        (ks != k + 1 ? FastMath.abs(e[ks - 1]) : 0);\n                    if (FastMath.abs(singularValues[ks]) <= TINY + EPS * t) {\n                        singularValues[ks] = 0;\n                        break;\n                    }\n                }\n                if (ks == k) {\n                    kase = 3;\n                } else if (ks == p - 1) {\n                    kase = 1;\n                } else {\n                    kase = 2;\n                    k = ks;\n                }\n            }\n            k++;\n            // Perform the task indicated by kase.\n            switch (kase) {\n                // Deflate negligible s(p).\n                case 1: {\n                    double f = e[p - 2];\n                    e[p - 2] = 0;\n                    for (int j = p - 2; j >= k; j--) {\n                        double t = FastMath.hypot(singularValues[j], f);\n                        final double cs = singularValues[j] / t;\n                        final double sn = f / t;\n                        singularValues[j] = t;\n                        if (j != k) {\n                            f = -sn * e[j - 1];\n                            e[j - 1] = cs * e[j - 1];\n                        }\n\n                        for (int i = 0; i < n; i++) {\n                            t = cs * V[i][j] + sn * V[i][p - 1];\n                            V[i][p - 1] = -sn * V[i][j] + cs * V[i][p - 1];\n                            V[i][j] = t;\n                        }\n                    }\n                }\n                break;\n                // Split at negligible s(k).\n                case 2: {\n                    double f = e[k - 1];\n                    e[k - 1] = 0;\n                    for (int j = k; j < p; j++) {\n                        double t = FastMath.hypot(singularValues[j], f);\n                        final double cs = singularValues[j] / t;\n                        final double sn = f / t;\n                        singularValues[j] = t;\n                        f = -sn * e[j];\n                        e[j] = cs * e[j];\n\n                        for (int i = 0; i < m; i++) {\n                            t = cs * U[i][j] + sn * U[i][k - 1];\n                            U[i][k - 1] = -sn * U[i][j] + cs * U[i][k - 1];\n                            U[i][j] = t;\n                        }\n                    }\n                }\n                break;\n                // Perform one qr step.\n                case 3: {\n                    // Calculate the shift.\n                    final double maxPm1Pm2 = FastMath.max(FastMath.abs(singularValues[p - 1]),\n                                                          FastMath.abs(singularValues[p - 2]));\n                    final double scale = FastMath.max(FastMath.max(FastMath.max(maxPm1Pm2,\n                                                                                FastMath.abs(e[p - 2])),\n                                                                   FastMath.abs(singularValues[k])),\n                                                      FastMath.abs(e[k]));\n                    final double sp = singularValues[p - 1] / scale;\n                    final double spm1 = singularValues[p - 2] / scale;\n                    final double epm1 = e[p - 2] / scale;\n                    final double sk = singularValues[k] / scale;\n                    final double ek = e[k] / scale;\n                    final double b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2.0;\n                    final double c = (sp * epm1) * (sp * epm1);\n                    double shift = 0;\n                    if (b != 0 ||\n                        c != 0) {\n                        shift = FastMath.sqrt(b * b + c);\n                        if (b < 0) {\n                            shift = -shift;\n                        }\n                        shift = c / (b + shift);\n                    }\n                    double f = (sk + sp) * (sk - sp) + shift;\n                    double g = sk * ek;\n                    // Chase zeros.\n                    for (int j = k; j < p - 1; j++) {\n                        double t = FastMath.hypot(f, g);\n                        double cs = f / t;\n                        double sn = g / t;\n                        if (j != k) {\n                            e[j - 1] = t;\n                        }\n                        f = cs * singularValues[j] + sn * e[j];\n                        e[j] = cs * e[j] - sn * singularValues[j];\n                        g = sn * singularValues[j + 1];\n                        singularValues[j + 1] = cs * singularValues[j + 1];\n\n                        for (int i = 0; i < n; i++) {\n                            t = cs * V[i][j] + sn * V[i][j + 1];\n                            V[i][j + 1] = -sn * V[i][j] + cs * V[i][j + 1];\n                            V[i][j] = t;\n                        }\n                        t = FastMath.hypot(f, g);\n                        cs = f / t;\n                        sn = g / t;\n                        singularValues[j] = t;\n                        f = cs * e[j] + sn * singularValues[j + 1];\n                        singularValues[j + 1] = -sn * e[j] + cs * singularValues[j + 1];\n                        g = sn * e[j + 1];\n                        e[j + 1] = cs * e[j + 1];\n                        if (j < m - 1) {\n                            for (int i = 0; i < m; i++) {\n                                t = cs * U[i][j] + sn * U[i][j + 1];\n                                U[i][j + 1] = -sn * U[i][j] + cs * U[i][j + 1];\n                                U[i][j] = t;\n                            }\n                        }\n                    }\n                    e[p - 2] = f;\n                    iter = iter + 1;\n                }\n                break;\n                // Convergence.\n                default: {\n                    // Make the singular values positive.\n                    if (singularValues[k] <= 0) {\n                        singularValues[k] = singularValues[k] < 0 ? -singularValues[k] : 0;\n\n                        for (int i = 0; i <= pp; i++) {\n                            V[i][k] = -V[i][k];\n                        }\n                    }\n                    // Order the singular values.\n                    while (k < pp) {\n                        if (singularValues[k] >= singularValues[k + 1]) {\n                            break;\n                        }\n                        double t = singularValues[k];\n                        singularValues[k] = singularValues[k + 1];\n                        singularValues[k + 1] = t;\n                        if (k < n - 1) {\n                            for (int i = 0; i < n; i++) {\n                                t = V[i][k + 1];\n                                V[i][k + 1] = V[i][k];\n                                V[i][k] = t;\n                            }\n                        }\n                        if (k < m - 1) {\n                            for (int i = 0; i < m; i++) {\n                                t = U[i][k + 1];\n                                U[i][k + 1] = U[i][k];\n                                U[i][k] = t;\n                            }\n                        }\n                        k++;\n                    }\n                    iter = 0;\n                    p--;\n                }\n                break;\n            }\n        }\n\n        // Set the small value tolerance used to calculate rank and pseudo-inverse\n        tol = FastMath.max(m * singularValues[0] * EPS,\n                           FastMath.sqrt(Precision.SAFE_MIN));\n\n        if (!transposed) {\n            cachedU = MatrixUtils.createRealMatrix(U);\n            cachedV = MatrixUtils.createRealMatrix(V);\n        } else {\n            cachedU = MatrixUtils.createRealMatrix(V);\n            cachedV = MatrixUtils.createRealMatrix(U);\n        }\n    }",
          "41": "    public SingularValueDecomposition(final RealMatrix matrix) {\n        final double[][] A;\n\n         // \"m\" is always the largest dimension.\n        if (matrix.getRowDimension() < matrix.getColumnDimension()) {\n            transposed = true;\n            A = matrix.transpose().getData();\n            m = matrix.getColumnDimension();\n            n = matrix.getRowDimension();\n        } else {\n            transposed = false;\n            A = matrix.getData();\n            m = matrix.getRowDimension();\n            n = matrix.getColumnDimension();\n        }\n\n        singularValues = new double[n];\n        final double[][] U = new double[m][n];\n        final double[][] V = new double[n][n];\n        final double[] e = new double[n];\n        final double[] work = new double[m];\n        // Reduce A to bidiagonal form, storing the diagonal elements\n        // in s and the super-diagonal elements in e.\n        final int nct = FastMath.min(m - 1, n);\n        final int nrt = FastMath.max(0, n - 2);\n        for (int k = 0; k < FastMath.max(nct, nrt); k++) {\n            if (k < nct) {\n                // Compute the transformation for the k-th column and\n                // place the k-th diagonal in s[k].\n                // Compute 2-norm of k-th column without under/overflow.\n                singularValues[k] = 0;\n                for (int i = k; i < m; i++) {\n                    singularValues[k] = FastMath.hypot(singularValues[k], A[i][k]);\n                }\n                if (singularValues[k] != 0) {\n                    if (A[k][k] < 0) {\nA[i].[k] = 0;\n                    }\n                    for (int i = k; i < m; i++) {\n                        A[i][k] /= singularValues[k];\n                    }\n                    A[k][k] += 1;\n                }\n                singularValues[k] = -singularValues[k];\n            }\n            for (int j = k + 1; j < n; j++) {\n                if (k < nct &&\n                    singularValues[k] != 0) {\n                    // Apply the transformation.\n                    double t = 0;\n                    for (int i = k; i < m; i++) {\n                        t += A[i][k] * A[i][j];\n                    }\n                    t = -t / A[k][k];\n                    for (int i = k; i < m; i++) {\n                        A[i][j] += t * A[i][k];\n                    }\n                }\n                // Place the k-th row of A into e for the\n                // subsequent calculation of the row transformation.\n                e[j] = A[k][j];\n            }\n            if (k < nct) {\n                // Place the transformation in U for subsequent back\n                // multiplication.\n                for (int i = k; i < m; i++) {\n                    U[i][k] = A[i][k];\n                }\n            }\n            if (k < nrt) {\n                // Compute the k-th row transformation and place the\n                // k-th super-diagonal in e[k].\n                // Compute 2-norm without under/overflow.\n                e[k] = 0;\n                for (int i = k + 1; i < n; i++) {\n                    e[k] = FastMath.hypot(e[k], e[i]);\n                }\n                if (e[k] != 0) {\n                    if (e[k + 1] < 0) {\n                        e[k] = -e[k];\n                    }\n                    for (int i = k + 1; i < n; i++) {\n                        e[i] /= e[k];\n                    }\n                    e[k + 1] += 1;\n                }\n                e[k] = -e[k];\n                if (k + 1 < m &&\n                    e[k] != 0) {\n                    // Apply the transformation.\n                    for (int i = k + 1; i < m; i++) {\n                        work[i] = 0;\n                    }\n                    for (int j = k + 1; j < n; j++) {\n                        for (int i = k + 1; i < m; i++) {\n                            work[i] += e[j] * A[i][j];\n                        }\n                    }\n                    for (int j = k + 1; j < n; j++) {\n                        final double t = -e[j] / e[k + 1];\n                        for (int i = k + 1; i < m; i++) {\n                            A[i][j] += t * work[i];\n                        }\n                    }\n                }\n\n                // Place the transformation in V for subsequent\n                // back multiplication.\n                for (int i = k + 1; i < n; i++) {\n                    V[i][k] = e[i];\n                }\n            }\n        }\n        // Set up the final bidiagonal matrix or order p.\n        int p = n;\n        if (nct < n) {\n            singularValues[nct] = A[nct][nct];\n        }\n        if (m < p) {\n            singularValues[p - 1] = 0;\n        }\n        if (nrt + 1 < p) {\n            e[nrt] = A[nrt][p - 1];\n        }\n        e[p - 1] = 0;\n\n        // Generate U.\n        for (int j = nct; j < n; j++) {\n            for (int i = 0; i < m; i++) {\n                U[i][j] = 0;\n            }\n            U[j][j] = 1;\n        }\n        for (int k = nct - 1; k >= 0; k--) {\n            if (singularValues[k] != 0) {\n                for (int j = k + 1; j < n; j++) {\n                    double t = 0;\n                    for (int i = k; i < m; i++) {\n                        t += U[i][k] * U[i][j];\n                    }\n                    t = -t / U[k][k];\n                    for (int i = k; i < m; i++) {\n                        U[i][j] += t * U[i][k];\n                    }\n                }\n                for (int i = k; i < m; i++) {\n                    U[i][k] = -U[i][k];\n                }\n                U[k][k] = 1 + U[k][k];\n                for (int i = 0; i < k - 1; i++) {\n                    U[i][k] = 0;\n                }\n            } else {\n                for (int i = 0; i < m; i++) {\n                    U[i][k] = 0;\n                }\n                U[k][k] = 1;\n            }\n        }\n\n        // Generate V.\n        for (int k = n - 1; k >= 0; k--) {\n            if (k < nrt &&\n                e[k] != 0) {\n                for (int j = k + 1; j < n; j++) {\n                    double t = 0;\n                    for (int i = k + 1; i < n; i++) {\n                        t += V[i][k] * V[i][j];\n                    }\n                    t = -t / V[k + 1][k];\n                    for (int i = k + 1; i < n; i++) {\n                        V[i][j] += t * V[i][k];\n                    }\n                }\n            }\n            for (int i = 0; i < n; i++) {\n                V[i][k] = 0;\n            }\n            V[k][k] = 1;\n        }\n\n        // Main iteration loop for the singular values.\n        final int pp = p - 1;\n        int iter = 0;\n        while (p > 0) {\n            int k;\n            int kase;\n            // Here is where a test for too many iterations would go.\n            // This section of the program inspects for\n            // negligible elements in the s and e arrays.  On\n            // completion the variables kase and k are set as follows.\n            // kase = 1     if s(p) and e[k-1] are negligible and k<p\n            // kase = 2     if s(k) is negligible and k<p\n            // kase = 3     if e[k-1] is negligible, k<p, and\n            //              s(k), ..., s(p) are not negligible (qr step).\n            // kase = 4     if e(p-1) is negligible (convergence).\n            for (k = p - 2; k >= 0; k--) {\n                final double threshold\n                    = TINY + EPS * (FastMath.abs(singularValues[k]) +\n                                    FastMath.abs(singularValues[k + 1]));\n\n                // the following condition is written this way in order\n                // to break out of the loop when NaN occurs, writing it\n                // as \"if (FastMath.abs(e[k]) <= threshold)\" would loop\n                // indefinitely in case of NaNs because comparison on NaNs\n                // always return false, regardless of what is checked\n                // see issue MATH-947\n                if (!(FastMath.abs(e[k]) > threshold)) {\n                    e[k] = 0;\n                    break;\n                }\n\n            }\n\n            if (k == p - 2) {\n                kase = 4;\n            } else {\n                int ks;\n                for (ks = p - 1; ks >= k; ks--) {\n                    if (ks == k) {\n                        break;\n                    }\n                    final double t = (ks != p ? FastMath.abs(e[ks]) : 0) +\n                        (ks != k + 1 ? FastMath.abs(e[ks - 1]) : 0);\n                    if (FastMath.abs(singularValues[ks]) <= TINY + EPS * t) {\n                        singularValues[ks] = 0;\n                        break;\n                    }\n                }\n                if (ks == k) {\n                    kase = 3;\n                } else if (ks == p - 1) {\n                    kase = 1;\n                } else {\n                    kase = 2;\n                    k = ks;\n                }\n            }\n            k++;\n            // Perform the task indicated by kase.\n            switch (kase) {\n                // Deflate negligible s(p).\n                case 1: {\n                    double f = e[p - 2];\n                    e[p - 2] = 0;\n                    for (int j = p - 2; j >= k; j--) {\n                        double t = FastMath.hypot(singularValues[j], f);\n                        final double cs = singularValues[j] / t;\n                        final double sn = f / t;\n                        singularValues[j] = t;\n                        if (j != k) {\n                            f = -sn * e[j - 1];\n                            e[j - 1] = cs * e[j - 1];\n                        }\n\n                        for (int i = 0; i < n; i++) {\n                            t = cs * V[i][j] + sn * V[i][p - 1];\n                            V[i][p - 1] = -sn * V[i][j] + cs * V[i][p - 1];\n                            V[i][j] = t;\n                        }\n                    }\n                }\n                break;\n                // Split at negligible s(k).\n                case 2: {\n                    double f = e[k - 1];\n                    e[k - 1] = 0;\n                    for (int j = k; j < p; j++) {\n                        double t = FastMath.hypot(singularValues[j], f);\n                        final double cs = singularValues[j] / t;\n                        final double sn = f / t;\n                        singularValues[j] = t;\n                        f = -sn * e[j];\n                        e[j] = cs * e[j];\n\n                        for (int i = 0; i < m; i++) {\n                            t = cs * U[i][j] + sn * U[i][k - 1];\n                            U[i][k - 1] = -sn * U[i][j] + cs * U[i][k - 1];\n                            U[i][j] = t;\n                        }\n                    }\n                }\n                break;\n                // Perform one qr step.\n                case 3: {\n                    // Calculate the shift.\n                    final double maxPm1Pm2 = FastMath.max(FastMath.abs(singularValues[p - 1]),\n                                                          FastMath.abs(singularValues[p - 2]));\n                    final double scale = FastMath.max(FastMath.max(FastMath.max(maxPm1Pm2,\n                                                                                FastMath.abs(e[p - 2])),\n                                                                   FastMath.abs(singularValues[k])),\n                                                      FastMath.abs(e[k]));\n                    final double sp = singularValues[p - 1] / scale;\n                    final double spm1 = singularValues[p - 2] / scale;\n                    final double epm1 = e[p - 2] / scale;\n                    final double sk = singularValues[k] / scale;\n                    final double ek = e[k] / scale;\n                    final double b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2.0;\n                    final double c = (sp * epm1) * (sp * epm1);\n                    double shift = 0;\n                    if (b != 0 ||\n                        c != 0) {\n                        shift = FastMath.sqrt(b * b + c);\n                        if (b < 0) {\n                            shift = -shift;\n                        }\n                        shift = c / (b + shift);\n                    }\n                    double f = (sk + sp) * (sk - sp) + shift;\n                    double g = sk * ek;\n                    // Chase zeros.\n                    for (int j = k; j < p - 1; j++) {\n                        double t = FastMath.hypot(f, g);\n                        double cs = f / t;\n                        double sn = g / t;\n                        if (j != k) {\n                            e[j - 1] = t;\n                        }\n                        f = cs * singularValues[j] + sn * e[j];\n                        e[j] = cs * e[j] - sn * singularValues[j];\n                        g = sn * singularValues[j + 1];\n                        singularValues[j + 1] = cs * singularValues[j + 1];\n\n                        for (int i = 0; i < n; i++) {\n                            t = cs * V[i][j] + sn * V[i][j + 1];\n                            V[i][j + 1] = -sn * V[i][j] + cs * V[i][j + 1];\n                            V[i][j] = t;\n                        }\n                        t = FastMath.hypot(f, g);\n                        cs = f / t;\n                        sn = g / t;\n                        singularValues[j] = t;\n                        f = cs * e[j] + sn * singularValues[j + 1];\n                        singularValues[j + 1] = -sn * e[j] + cs * singularValues[j + 1];\n                        g = sn * e[j + 1];\n                        e[j + 1] = cs * e[j + 1];\n                        if (j < m - 1) {\n                            for (int i = 0; i < m; i++) {\n                                t = cs * U[i][j] + sn * U[i][j + 1];\n                                U[i][j + 1] = -sn * U[i][j] + cs * U[i][j + 1];\n                                U[i][j] = t;\n                            }\n                        }\n                    }\n                    e[p - 2] = f;\n                    iter = iter + 1;\n                }\n                break;\n                // Convergence.\n                default: {\n                    // Make the singular values positive.\n                    if (singularValues[k] <= 0) {\n                        singularValues[k] = singularValues[k] < 0 ? -singularValues[k] : 0;\n\n                        for (int i = 0; i <= pp; i++) {\n                            V[i][k] = -V[i][k];\n                        }\n                    }\n                    // Order the singular values.\n                    while (k < pp) {\n                        if (singularValues[k] >= singularValues[k + 1]) {\n                            break;\n                        }\n                        double t = singularValues[k];\n                        singularValues[k] = singularValues[k + 1];\n                        singularValues[k + 1] = t;\n                        if (k < n - 1) {\n                            for (int i = 0; i < n; i++) {\n                                t = V[i][k + 1];\n                                V[i][k + 1] = V[i][k];\n                                V[i][k] = t;\n                            }\n                        }\n                        if (k < m - 1) {\n                            for (int i = 0; i < m; i++) {\n                                t = U[i][k + 1];\n                                U[i][k + 1] = U[i][k];\n                                U[i][k] = t;\n                            }\n                        }\n                        k++;\n                    }\n                    iter = 0;\n                    p--;\n                }\n                break;\n            }\n        }\n\n        // Set the small value tolerance used to calculate rank and pseudo-inverse\n        tol = FastMath.max(m * singularValues[0] * EPS,\n                           FastMath.sqrt(Precision.SAFE_MIN));\n\n        if (!transposed) {\n            cachedU = MatrixUtils.createRealMatrix(U);\n            cachedV = MatrixUtils.createRealMatrix(V);\n        } else {\n            cachedU = MatrixUtils.createRealMatrix(V);\n            cachedV = MatrixUtils.createRealMatrix(U);\n        }\n    }",
          "42": "    public SingularValueDecomposition(final RealMatrix matrix) {\n        final double[][] A;\n\n         // \"m\" is always the largest dimension.\n        if (matrix.getRowDimension() < matrix.getColumnDimension()) {\n            transposed = true;\n            A = matrix.transpose().getData();\n            m = matrix.getColumnDimension();\n            n = matrix.getRowDimension();\n        } else {\n            transposed = false;\n            A = matrix.getData();\n            m = matrix.getRowDimension();\n            n = matrix.getColumnDimension();\n        }\n\n        singularValues = new double[n];\n        final double[][] U = new double[m][n];\n        final double[][] V = new double[n][n];\n        final double[] e = new double[n];\n        final double[] work = new double[m];\n        // Reduce A to bidiagonal form, storing the diagonal elements\n        // in s and the super-diagonal elements in e.\n        final int nct = FastMath.min(m - 1, n);\n        final int nrt = FastMath.max(0, n - 2);\n        for (int k = 0; k < FastMath.max(nct, nrt); k++) {\n            if (k < nct) {\n                // Compute the transformation for the k-th column and\n                // place the k-th diagonal in s[k].\n                // Compute 2-norm of k-th column without under/overflow.\n                singularValues[k] = 0;\n                for (int i = k; i < m; i++) {\n                    singularValues[k] = FastMath.hypot(singularValues[k], A[i][k]);\n                }\n                if (singularValues[k] != 0) {\n                    if (A[k][k] < 0) {\nsingularValues[k] = A[k];\n                    }\n                    for (int i = k; i < m; i++) {\n                        A[i][k] /= singularValues[k];\n                    }\n                    A[k][k] += 1;\n                }\n                singularValues[k] = -singularValues[k];\n            }\n            for (int j = k + 1; j < n; j++) {\n                if (k < nct &&\n                    singularValues[k] != 0) {\n                    // Apply the transformation.\n                    double t = 0;\n                    for (int i = k; i < m; i++) {\n                        t += A[i][k] * A[i][j];\n                    }\n                    t = -t / A[k][k];\n                    for (int i = k; i < m; i++) {\n                        A[i][j] += t * A[i][k];\n                    }\n                }\n                // Place the k-th row of A into e for the\n                // subsequent calculation of the row transformation.\n                e[j] = A[k][j];\n            }\n            if (k < nct) {\n                // Place the transformation in U for subsequent back\n                // multiplication.\n                for (int i = k; i < m; i++) {\n                    U[i][k] = A[i][k];\n                }\n            }\n            if (k < nrt) {\n                // Compute the k-th row transformation and place the\n                // k-th super-diagonal in e[k].\n                // Compute 2-norm without under/overflow.\n                e[k] = 0;\n                for (int i = k + 1; i < n; i++) {\n                    e[k] = FastMath.hypot(e[k], e[i]);\n                }\n                if (e[k] != 0) {\n                    if (e[k + 1] < 0) {\n                        e[k] = -e[k];\n                    }\n                    for (int i = k + 1; i < n; i++) {\n                        e[i] /= e[k];\n                    }\n                    e[k + 1] += 1;\n                }\n                e[k] = -e[k];\n                if (k + 1 < m &&\n                    e[k] != 0) {\n                    // Apply the transformation.\n                    for (int i = k + 1; i < m; i++) {\n                        work[i] = 0;\n                    }\n                    for (int j = k + 1; j < n; j++) {\n                        for (int i = k + 1; i < m; i++) {\n                            work[i] += e[j] * A[i][j];\n                        }\n                    }\n                    for (int j = k + 1; j < n; j++) {\n                        final double t = -e[j] / e[k + 1];\n                        for (int i = k + 1; i < m; i++) {\n                            A[i][j] += t * work[i];\n                        }\n                    }\n                }\n\n                // Place the transformation in V for subsequent\n                // back multiplication.\n                for (int i = k + 1; i < n; i++) {\n                    V[i][k] = e[i];\n                }\n            }\n        }\n        // Set up the final bidiagonal matrix or order p.\n        int p = n;\n        if (nct < n) {\n            singularValues[nct] = A[nct][nct];\n        }\n        if (m < p) {\n            singularValues[p - 1] = 0;\n        }\n        if (nrt + 1 < p) {\n            e[nrt] = A[nrt][p - 1];\n        }\n        e[p - 1] = 0;\n\n        // Generate U.\n        for (int j = nct; j < n; j++) {\n            for (int i = 0; i < m; i++) {\n                U[i][j] = 0;\n            }\n            U[j][j] = 1;\n        }\n        for (int k = nct - 1; k >= 0; k--) {\n            if (singularValues[k] != 0) {\n                for (int j = k + 1; j < n; j++) {\n                    double t = 0;\n                    for (int i = k; i < m; i++) {\n                        t += U[i][k] * U[i][j];\n                    }\n                    t = -t / U[k][k];\n                    for (int i = k; i < m; i++) {\n                        U[i][j] += t * U[i][k];\n                    }\n                }\n                for (int i = k; i < m; i++) {\n                    U[i][k] = -U[i][k];\n                }\n                U[k][k] = 1 + U[k][k];\n                for (int i = 0; i < k - 1; i++) {\n                    U[i][k] = 0;\n                }\n            } else {\n                for (int i = 0; i < m; i++) {\n                    U[i][k] = 0;\n                }\n                U[k][k] = 1;\n            }\n        }\n\n        // Generate V.\n        for (int k = n - 1; k >= 0; k--) {\n            if (k < nrt &&\n                e[k] != 0) {\n                for (int j = k + 1; j < n; j++) {\n                    double t = 0;\n                    for (int i = k + 1; i < n; i++) {\n                        t += V[i][k] * V[i][j];\n                    }\n                    t = -t / V[k + 1][k];\n                    for (int i = k + 1; i < n; i++) {\n                        V[i][j] += t * V[i][k];\n                    }\n                }\n            }\n            for (int i = 0; i < n; i++) {\n                V[i][k] = 0;\n            }\n            V[k][k] = 1;\n        }\n\n        // Main iteration loop for the singular values.\n        final int pp = p - 1;\n        int iter = 0;\n        while (p > 0) {\n            int k;\n            int kase;\n            // Here is where a test for too many iterations would go.\n            // This section of the program inspects for\n            // negligible elements in the s and e arrays.  On\n            // completion the variables kase and k are set as follows.\n            // kase = 1     if s(p) and e[k-1] are negligible and k<p\n            // kase = 2     if s(k) is negligible and k<p\n            // kase = 3     if e[k-1] is negligible, k<p, and\n            //              s(k), ..., s(p) are not negligible (qr step).\n            // kase = 4     if e(p-1) is negligible (convergence).\n            for (k = p - 2; k >= 0; k--) {\n                final double threshold\n                    = TINY + EPS * (FastMath.abs(singularValues[k]) +\n                                    FastMath.abs(singularValues[k + 1]));\n\n                // the following condition is written this way in order\n                // to break out of the loop when NaN occurs, writing it\n                // as \"if (FastMath.abs(e[k]) <= threshold)\" would loop\n                // indefinitely in case of NaNs because comparison on NaNs\n                // always return false, regardless of what is checked\n                // see issue MATH-947\n                if (!(FastMath.abs(e[k]) > threshold)) {\n                    e[k] = 0;\n                    break;\n                }\n\n            }\n\n            if (k == p - 2) {\n                kase = 4;\n            } else {\n                int ks;\n                for (ks = p - 1; ks >= k; ks--) {\n                    if (ks == k) {\n                        break;\n                    }\n                    final double t = (ks != p ? FastMath.abs(e[ks]) : 0) +\n                        (ks != k + 1 ? FastMath.abs(e[ks - 1]) : 0);\n                    if (FastMath.abs(singularValues[ks]) <= TINY + EPS * t) {\n                        singularValues[ks] = 0;\n                        break;\n                    }\n                }\n                if (ks == k) {\n                    kase = 3;\n                } else if (ks == p - 1) {\n                    kase = 1;\n                } else {\n                    kase = 2;\n                    k = ks;\n                }\n            }\n            k++;\n            // Perform the task indicated by kase.\n            switch (kase) {\n                // Deflate negligible s(p).\n                case 1: {\n                    double f = e[p - 2];\n                    e[p - 2] = 0;\n                    for (int j = p - 2; j >= k; j--) {\n                        double t = FastMath.hypot(singularValues[j], f);\n                        final double cs = singularValues[j] / t;\n                        final double sn = f / t;\n                        singularValues[j] = t;\n                        if (j != k) {\n                            f = -sn * e[j - 1];\n                            e[j - 1] = cs * e[j - 1];\n                        }\n\n                        for (int i = 0; i < n; i++) {\n                            t = cs * V[i][j] + sn * V[i][p - 1];\n                            V[i][p - 1] = -sn * V[i][j] + cs * V[i][p - 1];\n                            V[i][j] = t;\n                        }\n                    }\n                }\n                break;\n                // Split at negligible s(k).\n                case 2: {\n                    double f = e[k - 1];\n                    e[k - 1] = 0;\n                    for (int j = k; j < p; j++) {\n                        double t = FastMath.hypot(singularValues[j], f);\n                        final double cs = singularValues[j] / t;\n                        final double sn = f / t;\n                        singularValues[j] = t;\n                        f = -sn * e[j];\n                        e[j] = cs * e[j];\n\n                        for (int i = 0; i < m; i++) {\n                            t = cs * U[i][j] + sn * U[i][k - 1];\n                            U[i][k - 1] = -sn * U[i][j] + cs * U[i][k - 1];\n                            U[i][j] = t;\n                        }\n                    }\n                }\n                break;\n                // Perform one qr step.\n                case 3: {\n                    // Calculate the shift.\n                    final double maxPm1Pm2 = FastMath.max(FastMath.abs(singularValues[p - 1]),\n                                                          FastMath.abs(singularValues[p - 2]));\n                    final double scale = FastMath.max(FastMath.max(FastMath.max(maxPm1Pm2,\n                                                                                FastMath.abs(e[p - 2])),\n                                                                   FastMath.abs(singularValues[k])),\n                                                      FastMath.abs(e[k]));\n                    final double sp = singularValues[p - 1] / scale;\n                    final double spm1 = singularValues[p - 2] / scale;\n                    final double epm1 = e[p - 2] / scale;\n                    final double sk = singularValues[k] / scale;\n                    final double ek = e[k] / scale;\n                    final double b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2.0;\n                    final double c = (sp * epm1) * (sp * epm1);\n                    double shift = 0;\n                    if (b != 0 ||\n                        c != 0) {\n                        shift = FastMath.sqrt(b * b + c);\n                        if (b < 0) {\n                            shift = -shift;\n                        }\n                        shift = c / (b + shift);\n                    }\n                    double f = (sk + sp) * (sk - sp) + shift;\n                    double g = sk * ek;\n                    // Chase zeros.\n                    for (int j = k; j < p - 1; j++) {\n                        double t = FastMath.hypot(f, g);\n                        double cs = f / t;\n                        double sn = g / t;\n                        if (j != k) {\n                            e[j - 1] = t;\n                        }\n                        f = cs * singularValues[j] + sn * e[j];\n                        e[j] = cs * e[j] - sn * singularValues[j];\n                        g = sn * singularValues[j + 1];\n                        singularValues[j + 1] = cs * singularValues[j + 1];\n\n                        for (int i = 0; i < n; i++) {\n                            t = cs * V[i][j] + sn * V[i][j + 1];\n                            V[i][j + 1] = -sn * V[i][j] + cs * V[i][j + 1];\n                            V[i][j] = t;\n                        }\n                        t = FastMath.hypot(f, g);\n                        cs = f / t;\n                        sn = g / t;\n                        singularValues[j] = t;\n                        f = cs * e[j] + sn * singularValues[j + 1];\n                        singularValues[j + 1] = -sn * e[j] + cs * singularValues[j + 1];\n                        g = sn * e[j + 1];\n                        e[j + 1] = cs * e[j + 1];\n                        if (j < m - 1) {\n                            for (int i = 0; i < m; i++) {\n                                t = cs * U[i][j] + sn * U[i][j + 1];\n                                U[i][j + 1] = -sn * U[i][j] + cs * U[i][j + 1];\n                                U[i][j] = t;\n                            }\n                        }\n                    }\n                    e[p - 2] = f;\n                    iter = iter + 1;\n                }\n                break;\n                // Convergence.\n                default: {\n                    // Make the singular values positive.\n                    if (singularValues[k] <= 0) {\n                        singularValues[k] = singularValues[k] < 0 ? -singularValues[k] : 0;\n\n                        for (int i = 0; i <= pp; i++) {\n                            V[i][k] = -V[i][k];\n                        }\n                    }\n                    // Order the singular values.\n                    while (k < pp) {\n                        if (singularValues[k] >= singularValues[k + 1]) {\n                            break;\n                        }\n                        double t = singularValues[k];\n                        singularValues[k] = singularValues[k + 1];\n                        singularValues[k + 1] = t;\n                        if (k < n - 1) {\n                            for (int i = 0; i < n; i++) {\n                                t = V[i][k + 1];\n                                V[i][k + 1] = V[i][k];\n                                V[i][k] = t;\n                            }\n                        }\n                        if (k < m - 1) {\n                            for (int i = 0; i < m; i++) {\n                                t = U[i][k + 1];\n                                U[i][k + 1] = U[i][k];\n                                U[i][k] = t;\n                            }\n                        }\n                        k++;\n                    }\n                    iter = 0;\n                    p--;\n                }\n                break;\n            }\n        }\n\n        // Set the small value tolerance used to calculate rank and pseudo-inverse\n        tol = FastMath.max(m * singularValues[0] * EPS,\n                           FastMath.sqrt(Precision.SAFE_MIN));\n\n        if (!transposed) {\n            cachedU = MatrixUtils.createRealMatrix(U);\n            cachedV = MatrixUtils.createRealMatrix(V);\n        } else {\n            cachedU = MatrixUtils.createRealMatrix(V);\n            cachedV = MatrixUtils.createRealMatrix(U);\n        }\n    }",
          "43": "    public SingularValueDecomposition(final RealMatrix matrix) {\n        final double[][] A;\n\n         // \"m\" is always the largest dimension.\n        if (matrix.getRowDimension() < matrix.getColumnDimension()) {\n            transposed = true;\n            A = matrix.transpose().getData();\n            m = matrix.getColumnDimension();\n            n = matrix.getRowDimension();\n        } else {\n            transposed = false;\n            A = matrix.getData();\n            m = matrix.getRowDimension();\n            n = matrix.getColumnDimension();\n        }\n\n        singularValues = new double[n];\n        final double[][] U = new double[m][n];\n        final double[][] V = new double[n][n];\n        final double[] e = new double[n];\n        final double[] work = new double[m];\n        // Reduce A to bidiagonal form, storing the diagonal elements\n        // in s and the super-diagonal elements in e.\n        final int nct = FastMath.min(m - 1, n);\n        final int nrt = FastMath.max(0, n - 2);\n        for (int k = 0; k < FastMath.max(nct, nrt); k++) {\n            if (k < nct) {\n                // Compute the transformation for the k-th column and\n                // place the k-th diagonal in s[k].\n                // Compute 2-norm of k-th column without under/overflow.\n                singularValues[k] = 0;\n                for (int i = k; i < m; i++) {\n                    singularValues[k] = FastMath.hypot(singularValues[k], A[i][k]);\n                }\n                if (singularValues[k] != 0) {\n                    if (A[k][k] < 0) {\nsingularValues[k] = 0;\n                        singularValues[k] = +singularValues[k];                    }\n                    for (int i = k; i < m; i++) {\n                        A[i][k] /= singularValues[k];\n                    }\n                    A[k][k] += 1;\n                }\n                singularValues[k] = -singularValues[k];\n            }\n            for (int j = k + 1; j < n; j++) {\n                if (k < nct &&\n                    singularValues[k] != 0) {\n                    // Apply the transformation.\n                    double t = 0;\n                    for (int i = k; i < m; i++) {\n                        t += A[i][k] * A[i][j];\n                    }\n                    t = -t / A[k][k];\n                    for (int i = k; i < m; i++) {\n                        A[i][j] += t * A[i][k];\n                    }\n                }\n                // Place the k-th row of A into e for the\n                // subsequent calculation of the row transformation.\n                e[j] = A[k][j];\n            }\n            if (k < nct) {\n                // Place the transformation in U for subsequent back\n                // multiplication.\n                for (int i = k; i < m; i++) {\n                    U[i][k] = A[i][k];\n                }\n            }\n            if (k < nrt) {\n                // Compute the k-th row transformation and place the\n                // k-th super-diagonal in e[k].\n                // Compute 2-norm without under/overflow.\n                e[k] = 0;\n                for (int i = k + 1; i < n; i++) {\n                    e[k] = FastMath.hypot(e[k], e[i]);\n                }\n                if (e[k] != 0) {\n                    if (e[k + 1] < 0) {\n                        e[k] = -e[k];\n                    }\n                    for (int i = k + 1; i < n; i++) {\n                        e[i] /= e[k];\n                    }\n                    e[k + 1] += 1;\n                }\n                e[k] = -e[k];\n                if (k + 1 < m &&\n                    e[k] != 0) {\n                    // Apply the transformation.\n                    for (int i = k + 1; i < m; i++) {\n                        work[i] = 0;\n                    }\n                    for (int j = k + 1; j < n; j++) {\n                        for (int i = k + 1; i < m; i++) {\n                            work[i] += e[j] * A[i][j];\n                        }\n                    }\n                    for (int j = k + 1; j < n; j++) {\n                        final double t = -e[j] / e[k + 1];\n                        for (int i = k + 1; i < m; i++) {\n                            A[i][j] += t * work[i];\n                        }\n                    }\n                }\n\n                // Place the transformation in V for subsequent\n                // back multiplication.\n                for (int i = k + 1; i < n; i++) {\n                    V[i][k] = e[i];\n                }\n            }\n        }\n        // Set up the final bidiagonal matrix or order p.\n        int p = n;\n        if (nct < n) {\n            singularValues[nct] = A[nct][nct];\n        }\n        if (m < p) {\n            singularValues[p - 1] = 0;\n        }\n        if (nrt + 1 < p) {\n            e[nrt] = A[nrt][p - 1];\n        }\n        e[p - 1] = 0;\n\n        // Generate U.\n        for (int j = nct; j < n; j++) {\n            for (int i = 0; i < m; i++) {\n                U[i][j] = 0;\n            }\n            U[j][j] = 1;\n        }\n        for (int k = nct - 1; k >= 0; k--) {\n            if (singularValues[k] != 0) {\n                for (int j = k + 1; j < n; j++) {\n                    double t = 0;\n                    for (int i = k; i < m; i++) {\n                        t += U[i][k] * U[i][j];\n                    }\n                    t = -t / U[k][k];\n                    for (int i = k; i < m; i++) {\n                        U[i][j] += t * U[i][k];\n                    }\n                }\n                for (int i = k; i < m; i++) {\n                    U[i][k] = -U[i][k];\n                }\n                U[k][k] = 1 + U[k][k];\n                for (int i = 0; i < k - 1; i++) {\n                    U[i][k] = 0;\n                }\n            } else {\n                for (int i = 0; i < m; i++) {\n                    U[i][k] = 0;\n                }\n                U[k][k] = 1;\n            }\n        }\n\n        // Generate V.\n        for (int k = n - 1; k >= 0; k--) {\n            if (k < nrt &&\n                e[k] != 0) {\n                for (int j = k + 1; j < n; j++) {\n                    double t = 0;\n                    for (int i = k + 1; i < n; i++) {\n                        t += V[i][k] * V[i][j];\n                    }\n                    t = -t / V[k + 1][k];\n                    for (int i = k + 1; i < n; i++) {\n                        V[i][j] += t * V[i][k];\n                    }\n                }\n            }\n            for (int i = 0; i < n; i++) {\n                V[i][k] = 0;\n            }\n            V[k][k] = 1;\n        }\n\n        // Main iteration loop for the singular values.\n        final int pp = p - 1;\n        int iter = 0;\n        while (p > 0) {\n            int k;\n            int kase;\n            // Here is where a test for too many iterations would go.\n            // This section of the program inspects for\n            // negligible elements in the s and e arrays.  On\n            // completion the variables kase and k are set as follows.\n            // kase = 1     if s(p) and e[k-1] are negligible and k<p\n            // kase = 2     if s(k) is negligible and k<p\n            // kase = 3     if e[k-1] is negligible, k<p, and\n            //              s(k), ..., s(p) are not negligible (qr step).\n            // kase = 4     if e(p-1) is negligible (convergence).\n            for (k = p - 2; k >= 0; k--) {\n                final double threshold\n                    = TINY + EPS * (FastMath.abs(singularValues[k]) +\n                                    FastMath.abs(singularValues[k + 1]));\n\n                // the following condition is written this way in order\n                // to break out of the loop when NaN occurs, writing it\n                // as \"if (FastMath.abs(e[k]) <= threshold)\" would loop\n                // indefinitely in case of NaNs because comparison on NaNs\n                // always return false, regardless of what is checked\n                // see issue MATH-947\n                if (!(FastMath.abs(e[k]) > threshold)) {\n                    e[k] = 0;\n                    break;\n                }\n\n            }\n\n            if (k == p - 2) {\n                kase = 4;\n            } else {\n                int ks;\n                for (ks = p - 1; ks >= k; ks--) {\n                    if (ks == k) {\n                        break;\n                    }\n                    final double t = (ks != p ? FastMath.abs(e[ks]) : 0) +\n                        (ks != k + 1 ? FastMath.abs(e[ks - 1]) : 0);\n                    if (FastMath.abs(singularValues[ks]) <= TINY + EPS * t) {\n                        singularValues[ks] = 0;\n                        break;\n                    }\n                }\n                if (ks == k) {\n                    kase = 3;\n                } else if (ks == p - 1) {\n                    kase = 1;\n                } else {\n                    kase = 2;\n                    k = ks;\n                }\n            }\n            k++;\n            // Perform the task indicated by kase.\n            switch (kase) {\n                // Deflate negligible s(p).\n                case 1: {\n                    double f = e[p - 2];\n                    e[p - 2] = 0;\n                    for (int j = p - 2; j >= k; j--) {\n                        double t = FastMath.hypot(singularValues[j], f);\n                        final double cs = singularValues[j] / t;\n                        final double sn = f / t;\n                        singularValues[j] = t;\n                        if (j != k) {\n                            f = -sn * e[j - 1];\n                            e[j - 1] = cs * e[j - 1];\n                        }\n\n                        for (int i = 0; i < n; i++) {\n                            t = cs * V[i][j] + sn * V[i][p - 1];\n                            V[i][p - 1] = -sn * V[i][j] + cs * V[i][p - 1];\n                            V[i][j] = t;\n                        }\n                    }\n                }\n                break;\n                // Split at negligible s(k).\n                case 2: {\n                    double f = e[k - 1];\n                    e[k - 1] = 0;\n                    for (int j = k; j < p; j++) {\n                        double t = FastMath.hypot(singularValues[j], f);\n                        final double cs = singularValues[j] / t;\n                        final double sn = f / t;\n                        singularValues[j] = t;\n                        f = -sn * e[j];\n                        e[j] = cs * e[j];\n\n                        for (int i = 0; i < m; i++) {\n                            t = cs * U[i][j] + sn * U[i][k - 1];\n                            U[i][k - 1] = -sn * U[i][j] + cs * U[i][k - 1];\n                            U[i][j] = t;\n                        }\n                    }\n                }\n                break;\n                // Perform one qr step.\n                case 3: {\n                    // Calculate the shift.\n                    final double maxPm1Pm2 = FastMath.max(FastMath.abs(singularValues[p - 1]),\n                                                          FastMath.abs(singularValues[p - 2]));\n                    final double scale = FastMath.max(FastMath.max(FastMath.max(maxPm1Pm2,\n                                                                                FastMath.abs(e[p - 2])),\n                                                                   FastMath.abs(singularValues[k])),\n                                                      FastMath.abs(e[k]));\n                    final double sp = singularValues[p - 1] / scale;\n                    final double spm1 = singularValues[p - 2] / scale;\n                    final double epm1 = e[p - 2] / scale;\n                    final double sk = singularValues[k] / scale;\n                    final double ek = e[k] / scale;\n                    final double b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2.0;\n                    final double c = (sp * epm1) * (sp * epm1);\n                    double shift = 0;\n                    if (b != 0 ||\n                        c != 0) {\n                        shift = FastMath.sqrt(b * b + c);\n                        if (b < 0) {\n                            shift = -shift;\n                        }\n                        shift = c / (b + shift);\n                    }\n                    double f = (sk + sp) * (sk - sp) + shift;\n                    double g = sk * ek;\n                    // Chase zeros.\n                    for (int j = k; j < p - 1; j++) {\n                        double t = FastMath.hypot(f, g);\n                        double cs = f / t;\n                        double sn = g / t;\n                        if (j != k) {\n                            e[j - 1] = t;\n                        }\n                        f = cs * singularValues[j] + sn * e[j];\n                        e[j] = cs * e[j] - sn * singularValues[j];\n                        g = sn * singularValues[j + 1];\n                        singularValues[j + 1] = cs * singularValues[j + 1];\n\n                        for (int i = 0; i < n; i++) {\n                            t = cs * V[i][j] + sn * V[i][j + 1];\n                            V[i][j + 1] = -sn * V[i][j] + cs * V[i][j + 1];\n                            V[i][j] = t;\n                        }\n                        t = FastMath.hypot(f, g);\n                        cs = f / t;\n                        sn = g / t;\n                        singularValues[j] = t;\n                        f = cs * e[j] + sn * singularValues[j + 1];\n                        singularValues[j + 1] = -sn * e[j] + cs * singularValues[j + 1];\n                        g = sn * e[j + 1];\n                        e[j + 1] = cs * e[j + 1];\n                        if (j < m - 1) {\n                            for (int i = 0; i < m; i++) {\n                                t = cs * U[i][j] + sn * U[i][j + 1];\n                                U[i][j + 1] = -sn * U[i][j] + cs * U[i][j + 1];\n                                U[i][j] = t;\n                            }\n                        }\n                    }\n                    e[p - 2] = f;\n                    iter = iter + 1;\n                }\n                break;\n                // Convergence.\n                default: {\n                    // Make the singular values positive.\n                    if (singularValues[k] <= 0) {\n                        singularValues[k] = singularValues[k] < 0 ? -singularValues[k] : 0;\n\n                        for (int i = 0; i <= pp; i++) {\n                            V[i][k] = -V[i][k];\n                        }\n                    }\n                    // Order the singular values.\n                    while (k < pp) {\n                        if (singularValues[k] >= singularValues[k + 1]) {\n                            break;\n                        }\n                        double t = singularValues[k];\n                        singularValues[k] = singularValues[k + 1];\n                        singularValues[k + 1] = t;\n                        if (k < n - 1) {\n                            for (int i = 0; i < n; i++) {\n                                t = V[i][k + 1];\n                                V[i][k + 1] = V[i][k];\n                                V[i][k] = t;\n                            }\n                        }\n                        if (k < m - 1) {\n                            for (int i = 0; i < m; i++) {\n                                t = U[i][k + 1];\n                                U[i][k + 1] = U[i][k];\n                                U[i][k] = t;\n                            }\n                        }\n                        k++;\n                    }\n                    iter = 0;\n                    p--;\n                }\n                break;\n            }\n        }\n\n        // Set the small value tolerance used to calculate rank and pseudo-inverse\n        tol = FastMath.max(m * singularValues[0] * EPS,\n                           FastMath.sqrt(Precision.SAFE_MIN));\n\n        if (!transposed) {\n            cachedU = MatrixUtils.createRealMatrix(U);\n            cachedV = MatrixUtils.createRealMatrix(V);\n        } else {\n            cachedU = MatrixUtils.createRealMatrix(V);\n            cachedV = MatrixUtils.createRealMatrix(U);\n        }\n    }",
          "44": "    public SingularValueDecomposition(final RealMatrix matrix) {\n        final double[][] A;\n\n         // \"m\" is always the largest dimension.\n        if (matrix.getRowDimension() < matrix.getColumnDimension()) {\n            transposed = true;\n            A = matrix.transpose().getData();\n            m = matrix.getColumnDimension();\n            n = matrix.getRowDimension();\n        } else {\n            transposed = false;\n            A = matrix.getData();\n            m = matrix.getRowDimension();\n            n = matrix.getColumnDimension();\n        }\n\n        singularValues = new double[n];\n        final double[][] U = new double[m][n];\n        final double[][] V = new double[n][n];\n        final double[] e = new double[n];\n        final double[] work = new double[m];\n        // Reduce A to bidiagonal form, storing the diagonal elements\n        // in s and the super-diagonal elements in e.\n        final int nct = FastMath.min(m - 1, n);\n        final int nrt = FastMath.max(0, n - 2);\n        for (int k = 0; k < FastMath.max(nct, nrt); k++) {\n            if (k < nct) {\n                // Compute the transformation for the k-th column and\n                // place the k-th diagonal in s[k].\n                // Compute 2-norm of k-th column without under/overflow.\n                singularValues[k] = 0;\n                for (int i = k; i < m; i++) {\n                    singularValues[k] = FastMath.hypot(singularValues[k], A[i][k]);\n                }\n                if (singularValues[k] != 0) {\n                    if (A[k][k] < 0) {\nsingularValues[k] = A[k].[k];\n                    }\n                    for (int i = k; i < m; i++) {\n                        A[i][k] /= singularValues[k];\n                    }\n                    A[k][k] += 1;\n                }\n                singularValues[k] = -singularValues[k];\n            }\n            for (int j = k + 1; j < n; j++) {\n                if (k < nct &&\n                    singularValues[k] != 0) {\n                    // Apply the transformation.\n                    double t = 0;\n                    for (int i = k; i < m; i++) {\n                        t += A[i][k] * A[i][j];\n                    }\n                    t = -t / A[k][k];\n                    for (int i = k; i < m; i++) {\n                        A[i][j] += t * A[i][k];\n                    }\n                }\n                // Place the k-th row of A into e for the\n                // subsequent calculation of the row transformation.\n                e[j] = A[k][j];\n            }\n            if (k < nct) {\n                // Place the transformation in U for subsequent back\n                // multiplication.\n                for (int i = k; i < m; i++) {\n                    U[i][k] = A[i][k];\n                }\n            }\n            if (k < nrt) {\n                // Compute the k-th row transformation and place the\n                // k-th super-diagonal in e[k].\n                // Compute 2-norm without under/overflow.\n                e[k] = 0;\n                for (int i = k + 1; i < n; i++) {\n                    e[k] = FastMath.hypot(e[k], e[i]);\n                }\n                if (e[k] != 0) {\n                    if (e[k + 1] < 0) {\n                        e[k] = -e[k];\n                    }\n                    for (int i = k + 1; i < n; i++) {\n                        e[i] /= e[k];\n                    }\n                    e[k + 1] += 1;\n                }\n                e[k] = -e[k];\n                if (k + 1 < m &&\n                    e[k] != 0) {\n                    // Apply the transformation.\n                    for (int i = k + 1; i < m; i++) {\n                        work[i] = 0;\n                    }\n                    for (int j = k + 1; j < n; j++) {\n                        for (int i = k + 1; i < m; i++) {\n                            work[i] += e[j] * A[i][j];\n                        }\n                    }\n                    for (int j = k + 1; j < n; j++) {\n                        final double t = -e[j] / e[k + 1];\n                        for (int i = k + 1; i < m; i++) {\n                            A[i][j] += t * work[i];\n                        }\n                    }\n                }\n\n                // Place the transformation in V for subsequent\n                // back multiplication.\n                for (int i = k + 1; i < n; i++) {\n                    V[i][k] = e[i];\n                }\n            }\n        }\n        // Set up the final bidiagonal matrix or order p.\n        int p = n;\n        if (nct < n) {\n            singularValues[nct] = A[nct][nct];\n        }\n        if (m < p) {\n            singularValues[p - 1] = 0;\n        }\n        if (nrt + 1 < p) {\n            e[nrt] = A[nrt][p - 1];\n        }\n        e[p - 1] = 0;\n\n        // Generate U.\n        for (int j = nct; j < n; j++) {\n            for (int i = 0; i < m; i++) {\n                U[i][j] = 0;\n            }\n            U[j][j] = 1;\n        }\n        for (int k = nct - 1; k >= 0; k--) {\n            if (singularValues[k] != 0) {\n                for (int j = k + 1; j < n; j++) {\n                    double t = 0;\n                    for (int i = k; i < m; i++) {\n                        t += U[i][k] * U[i][j];\n                    }\n                    t = -t / U[k][k];\n                    for (int i = k; i < m; i++) {\n                        U[i][j] += t * U[i][k];\n                    }\n                }\n                for (int i = k; i < m; i++) {\n                    U[i][k] = -U[i][k];\n                }\n                U[k][k] = 1 + U[k][k];\n                for (int i = 0; i < k - 1; i++) {\n                    U[i][k] = 0;\n                }\n            } else {\n                for (int i = 0; i < m; i++) {\n                    U[i][k] = 0;\n                }\n                U[k][k] = 1;\n            }\n        }\n\n        // Generate V.\n        for (int k = n - 1; k >= 0; k--) {\n            if (k < nrt &&\n                e[k] != 0) {\n                for (int j = k + 1; j < n; j++) {\n                    double t = 0;\n                    for (int i = k + 1; i < n; i++) {\n                        t += V[i][k] * V[i][j];\n                    }\n                    t = -t / V[k + 1][k];\n                    for (int i = k + 1; i < n; i++) {\n                        V[i][j] += t * V[i][k];\n                    }\n                }\n            }\n            for (int i = 0; i < n; i++) {\n                V[i][k] = 0;\n            }\n            V[k][k] = 1;\n        }\n\n        // Main iteration loop for the singular values.\n        final int pp = p - 1;\n        int iter = 0;\n        while (p > 0) {\n            int k;\n            int kase;\n            // Here is where a test for too many iterations would go.\n            // This section of the program inspects for\n            // negligible elements in the s and e arrays.  On\n            // completion the variables kase and k are set as follows.\n            // kase = 1     if s(p) and e[k-1] are negligible and k<p\n            // kase = 2     if s(k) is negligible and k<p\n            // kase = 3     if e[k-1] is negligible, k<p, and\n            //              s(k), ..., s(p) are not negligible (qr step).\n            // kase = 4     if e(p-1) is negligible (convergence).\n            for (k = p - 2; k >= 0; k--) {\n                final double threshold\n                    = TINY + EPS * (FastMath.abs(singularValues[k]) +\n                                    FastMath.abs(singularValues[k + 1]));\n\n                // the following condition is written this way in order\n                // to break out of the loop when NaN occurs, writing it\n                // as \"if (FastMath.abs(e[k]) <= threshold)\" would loop\n                // indefinitely in case of NaNs because comparison on NaNs\n                // always return false, regardless of what is checked\n                // see issue MATH-947\n                if (!(FastMath.abs(e[k]) > threshold)) {\n                    e[k] = 0;\n                    break;\n                }\n\n            }\n\n            if (k == p - 2) {\n                kase = 4;\n            } else {\n                int ks;\n                for (ks = p - 1; ks >= k; ks--) {\n                    if (ks == k) {\n                        break;\n                    }\n                    final double t = (ks != p ? FastMath.abs(e[ks]) : 0) +\n                        (ks != k + 1 ? FastMath.abs(e[ks - 1]) : 0);\n                    if (FastMath.abs(singularValues[ks]) <= TINY + EPS * t) {\n                        singularValues[ks] = 0;\n                        break;\n                    }\n                }\n                if (ks == k) {\n                    kase = 3;\n                } else if (ks == p - 1) {\n                    kase = 1;\n                } else {\n                    kase = 2;\n                    k = ks;\n                }\n            }\n            k++;\n            // Perform the task indicated by kase.\n            switch (kase) {\n                // Deflate negligible s(p).\n                case 1: {\n                    double f = e[p - 2];\n                    e[p - 2] = 0;\n                    for (int j = p - 2; j >= k; j--) {\n                        double t = FastMath.hypot(singularValues[j], f);\n                        final double cs = singularValues[j] / t;\n                        final double sn = f / t;\n                        singularValues[j] = t;\n                        if (j != k) {\n                            f = -sn * e[j - 1];\n                            e[j - 1] = cs * e[j - 1];\n                        }\n\n                        for (int i = 0; i < n; i++) {\n                            t = cs * V[i][j] + sn * V[i][p - 1];\n                            V[i][p - 1] = -sn * V[i][j] + cs * V[i][p - 1];\n                            V[i][j] = t;\n                        }\n                    }\n                }\n                break;\n                // Split at negligible s(k).\n                case 2: {\n                    double f = e[k - 1];\n                    e[k - 1] = 0;\n                    for (int j = k; j < p; j++) {\n                        double t = FastMath.hypot(singularValues[j], f);\n                        final double cs = singularValues[j] / t;\n                        final double sn = f / t;\n                        singularValues[j] = t;\n                        f = -sn * e[j];\n                        e[j] = cs * e[j];\n\n                        for (int i = 0; i < m; i++) {\n                            t = cs * U[i][j] + sn * U[i][k - 1];\n                            U[i][k - 1] = -sn * U[i][j] + cs * U[i][k - 1];\n                            U[i][j] = t;\n                        }\n                    }\n                }\n                break;\n                // Perform one qr step.\n                case 3: {\n                    // Calculate the shift.\n                    final double maxPm1Pm2 = FastMath.max(FastMath.abs(singularValues[p - 1]),\n                                                          FastMath.abs(singularValues[p - 2]));\n                    final double scale = FastMath.max(FastMath.max(FastMath.max(maxPm1Pm2,\n                                                                                FastMath.abs(e[p - 2])),\n                                                                   FastMath.abs(singularValues[k])),\n                                                      FastMath.abs(e[k]));\n                    final double sp = singularValues[p - 1] / scale;\n                    final double spm1 = singularValues[p - 2] / scale;\n                    final double epm1 = e[p - 2] / scale;\n                    final double sk = singularValues[k] / scale;\n                    final double ek = e[k] / scale;\n                    final double b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2.0;\n                    final double c = (sp * epm1) * (sp * epm1);\n                    double shift = 0;\n                    if (b != 0 ||\n                        c != 0) {\n                        shift = FastMath.sqrt(b * b + c);\n                        if (b < 0) {\n                            shift = -shift;\n                        }\n                        shift = c / (b + shift);\n                    }\n                    double f = (sk + sp) * (sk - sp) + shift;\n                    double g = sk * ek;\n                    // Chase zeros.\n                    for (int j = k; j < p - 1; j++) {\n                        double t = FastMath.hypot(f, g);\n                        double cs = f / t;\n                        double sn = g / t;\n                        if (j != k) {\n                            e[j - 1] = t;\n                        }\n                        f = cs * singularValues[j] + sn * e[j];\n                        e[j] = cs * e[j] - sn * singularValues[j];\n                        g = sn * singularValues[j + 1];\n                        singularValues[j + 1] = cs * singularValues[j + 1];\n\n                        for (int i = 0; i < n; i++) {\n                            t = cs * V[i][j] + sn * V[i][j + 1];\n                            V[i][j + 1] = -sn * V[i][j] + cs * V[i][j + 1];\n                            V[i][j] = t;\n                        }\n                        t = FastMath.hypot(f, g);\n                        cs = f / t;\n                        sn = g / t;\n                        singularValues[j] = t;\n                        f = cs * e[j] + sn * singularValues[j + 1];\n                        singularValues[j + 1] = -sn * e[j] + cs * singularValues[j + 1];\n                        g = sn * e[j + 1];\n                        e[j + 1] = cs * e[j + 1];\n                        if (j < m - 1) {\n                            for (int i = 0; i < m; i++) {\n                                t = cs * U[i][j] + sn * U[i][j + 1];\n                                U[i][j + 1] = -sn * U[i][j] + cs * U[i][j + 1];\n                                U[i][j] = t;\n                            }\n                        }\n                    }\n                    e[p - 2] = f;\n                    iter = iter + 1;\n                }\n                break;\n                // Convergence.\n                default: {\n                    // Make the singular values positive.\n                    if (singularValues[k] <= 0) {\n                        singularValues[k] = singularValues[k] < 0 ? -singularValues[k] : 0;\n\n                        for (int i = 0; i <= pp; i++) {\n                            V[i][k] = -V[i][k];\n                        }\n                    }\n                    // Order the singular values.\n                    while (k < pp) {\n                        if (singularValues[k] >= singularValues[k + 1]) {\n                            break;\n                        }\n                        double t = singularValues[k];\n                        singularValues[k] = singularValues[k + 1];\n                        singularValues[k + 1] = t;\n                        if (k < n - 1) {\n                            for (int i = 0; i < n; i++) {\n                                t = V[i][k + 1];\n                                V[i][k + 1] = V[i][k];\n                                V[i][k] = t;\n                            }\n                        }\n                        if (k < m - 1) {\n                            for (int i = 0; i < m; i++) {\n                                t = U[i][k + 1];\n                                U[i][k + 1] = U[i][k];\n                                U[i][k] = t;\n                            }\n                        }\n                        k++;\n                    }\n                    iter = 0;\n                    p--;\n                }\n                break;\n            }\n        }\n\n        // Set the small value tolerance used to calculate rank and pseudo-inverse\n        tol = FastMath.max(m * singularValues[0] * EPS,\n                           FastMath.sqrt(Precision.SAFE_MIN));\n\n        if (!transposed) {\n            cachedU = MatrixUtils.createRealMatrix(U);\n            cachedV = MatrixUtils.createRealMatrix(V);\n        } else {\n            cachedU = MatrixUtils.createRealMatrix(V);\n            cachedV = MatrixUtils.createRealMatrix(U);\n        }\n    }",
          "45": "    public SingularValueDecomposition(final RealMatrix matrix) {\n        final double[][] A;\n\n         // \"m\" is always the largest dimension.\n        if (matrix.getRowDimension() < matrix.getColumnDimension()) {\n            transposed = true;\n            A = matrix.transpose().getData();\n            m = matrix.getColumnDimension();\n            n = matrix.getRowDimension();\n        } else {\n            transposed = false;\n            A = matrix.getData();\n            m = matrix.getRowDimension();\n            n = matrix.getColumnDimension();\n        }\n\n        singularValues = new double[n];\n        final double[][] U = new double[m][n];\n        final double[][] V = new double[n][n];\n        final double[] e = new double[n];\n        final double[] work = new double[m];\n        // Reduce A to bidiagonal form, storing the diagonal elements\n        // in s and the super-diagonal elements in e.\n        final int nct = FastMath.min(m - 1, n);\n        final int nrt = FastMath.max(0, n - 2);\n        for (int k = 0; k < FastMath.max(nct, nrt); k++) {\n            if (k < nct) {\n                // Compute the transformation for the k-th column and\n                // place the k-th diagonal in s[k].\n                // Compute 2-norm of k-th column without under/overflow.\n                singularValues[k] = 0;\n                for (int i = k; i < m; i++) {\n                    singularValues[k] = FastMath.hypot(singularValues[k], A[i][k]);\n                }\n                if (singularValues[k] != 0) {\n                    if (A[k][k] < 0) {\nEPS[i].[k] = +singularValues[k];\n                    }\n                    for (int i = k; i < m; i++) {\n                        A[i][k] /= singularValues[k];\n                    }\n                    A[k][k] += 1;\n                }\n                singularValues[k] = -singularValues[k];\n            }\n            for (int j = k + 1; j < n; j++) {\n                if (k < nct &&\n                    singularValues[k] != 0) {\n                    // Apply the transformation.\n                    double t = 0;\n                    for (int i = k; i < m; i++) {\n                        t += A[i][k] * A[i][j];\n                    }\n                    t = -t / A[k][k];\n                    for (int i = k; i < m; i++) {\n                        A[i][j] += t * A[i][k];\n                    }\n                }\n                // Place the k-th row of A into e for the\n                // subsequent calculation of the row transformation.\n                e[j] = A[k][j];\n            }\n            if (k < nct) {\n                // Place the transformation in U for subsequent back\n                // multiplication.\n                for (int i = k; i < m; i++) {\n                    U[i][k] = A[i][k];\n                }\n            }\n            if (k < nrt) {\n                // Compute the k-th row transformation and place the\n                // k-th super-diagonal in e[k].\n                // Compute 2-norm without under/overflow.\n                e[k] = 0;\n                for (int i = k + 1; i < n; i++) {\n                    e[k] = FastMath.hypot(e[k], e[i]);\n                }\n                if (e[k] != 0) {\n                    if (e[k + 1] < 0) {\n                        e[k] = -e[k];\n                    }\n                    for (int i = k + 1; i < n; i++) {\n                        e[i] /= e[k];\n                    }\n                    e[k + 1] += 1;\n                }\n                e[k] = -e[k];\n                if (k + 1 < m &&\n                    e[k] != 0) {\n                    // Apply the transformation.\n                    for (int i = k + 1; i < m; i++) {\n                        work[i] = 0;\n                    }\n                    for (int j = k + 1; j < n; j++) {\n                        for (int i = k + 1; i < m; i++) {\n                            work[i] += e[j] * A[i][j];\n                        }\n                    }\n                    for (int j = k + 1; j < n; j++) {\n                        final double t = -e[j] / e[k + 1];\n                        for (int i = k + 1; i < m; i++) {\n                            A[i][j] += t * work[i];\n                        }\n                    }\n                }\n\n                // Place the transformation in V for subsequent\n                // back multiplication.\n                for (int i = k + 1; i < n; i++) {\n                    V[i][k] = e[i];\n                }\n            }\n        }\n        // Set up the final bidiagonal matrix or order p.\n        int p = n;\n        if (nct < n) {\n            singularValues[nct] = A[nct][nct];\n        }\n        if (m < p) {\n            singularValues[p - 1] = 0;\n        }\n        if (nrt + 1 < p) {\n            e[nrt] = A[nrt][p - 1];\n        }\n        e[p - 1] = 0;\n\n        // Generate U.\n        for (int j = nct; j < n; j++) {\n            for (int i = 0; i < m; i++) {\n                U[i][j] = 0;\n            }\n            U[j][j] = 1;\n        }\n        for (int k = nct - 1; k >= 0; k--) {\n            if (singularValues[k] != 0) {\n                for (int j = k + 1; j < n; j++) {\n                    double t = 0;\n                    for (int i = k; i < m; i++) {\n                        t += U[i][k] * U[i][j];\n                    }\n                    t = -t / U[k][k];\n                    for (int i = k; i < m; i++) {\n                        U[i][j] += t * U[i][k];\n                    }\n                }\n                for (int i = k; i < m; i++) {\n                    U[i][k] = -U[i][k];\n                }\n                U[k][k] = 1 + U[k][k];\n                for (int i = 0; i < k - 1; i++) {\n                    U[i][k] = 0;\n                }\n            } else {\n                for (int i = 0; i < m; i++) {\n                    U[i][k] = 0;\n                }\n                U[k][k] = 1;\n            }\n        }\n\n        // Generate V.\n        for (int k = n - 1; k >= 0; k--) {\n            if (k < nrt &&\n                e[k] != 0) {\n                for (int j = k + 1; j < n; j++) {\n                    double t = 0;\n                    for (int i = k + 1; i < n; i++) {\n                        t += V[i][k] * V[i][j];\n                    }\n                    t = -t / V[k + 1][k];\n                    for (int i = k + 1; i < n; i++) {\n                        V[i][j] += t * V[i][k];\n                    }\n                }\n            }\n            for (int i = 0; i < n; i++) {\n                V[i][k] = 0;\n            }\n            V[k][k] = 1;\n        }\n\n        // Main iteration loop for the singular values.\n        final int pp = p - 1;\n        int iter = 0;\n        while (p > 0) {\n            int k;\n            int kase;\n            // Here is where a test for too many iterations would go.\n            // This section of the program inspects for\n            // negligible elements in the s and e arrays.  On\n            // completion the variables kase and k are set as follows.\n            // kase = 1     if s(p) and e[k-1] are negligible and k<p\n            // kase = 2     if s(k) is negligible and k<p\n            // kase = 3     if e[k-1] is negligible, k<p, and\n            //              s(k), ..., s(p) are not negligible (qr step).\n            // kase = 4     if e(p-1) is negligible (convergence).\n            for (k = p - 2; k >= 0; k--) {\n                final double threshold\n                    = TINY + EPS * (FastMath.abs(singularValues[k]) +\n                                    FastMath.abs(singularValues[k + 1]));\n\n                // the following condition is written this way in order\n                // to break out of the loop when NaN occurs, writing it\n                // as \"if (FastMath.abs(e[k]) <= threshold)\" would loop\n                // indefinitely in case of NaNs because comparison on NaNs\n                // always return false, regardless of what is checked\n                // see issue MATH-947\n                if (!(FastMath.abs(e[k]) > threshold)) {\n                    e[k] = 0;\n                    break;\n                }\n\n            }\n\n            if (k == p - 2) {\n                kase = 4;\n            } else {\n                int ks;\n                for (ks = p - 1; ks >= k; ks--) {\n                    if (ks == k) {\n                        break;\n                    }\n                    final double t = (ks != p ? FastMath.abs(e[ks]) : 0) +\n                        (ks != k + 1 ? FastMath.abs(e[ks - 1]) : 0);\n                    if (FastMath.abs(singularValues[ks]) <= TINY + EPS * t) {\n                        singularValues[ks] = 0;\n                        break;\n                    }\n                }\n                if (ks == k) {\n                    kase = 3;\n                } else if (ks == p - 1) {\n                    kase = 1;\n                } else {\n                    kase = 2;\n                    k = ks;\n                }\n            }\n            k++;\n            // Perform the task indicated by kase.\n            switch (kase) {\n                // Deflate negligible s(p).\n                case 1: {\n                    double f = e[p - 2];\n                    e[p - 2] = 0;\n                    for (int j = p - 2; j >= k; j--) {\n                        double t = FastMath.hypot(singularValues[j], f);\n                        final double cs = singularValues[j] / t;\n                        final double sn = f / t;\n                        singularValues[j] = t;\n                        if (j != k) {\n                            f = -sn * e[j - 1];\n                            e[j - 1] = cs * e[j - 1];\n                        }\n\n                        for (int i = 0; i < n; i++) {\n                            t = cs * V[i][j] + sn * V[i][p - 1];\n                            V[i][p - 1] = -sn * V[i][j] + cs * V[i][p - 1];\n                            V[i][j] = t;\n                        }\n                    }\n                }\n                break;\n                // Split at negligible s(k).\n                case 2: {\n                    double f = e[k - 1];\n                    e[k - 1] = 0;\n                    for (int j = k; j < p; j++) {\n                        double t = FastMath.hypot(singularValues[j], f);\n                        final double cs = singularValues[j] / t;\n                        final double sn = f / t;\n                        singularValues[j] = t;\n                        f = -sn * e[j];\n                        e[j] = cs * e[j];\n\n                        for (int i = 0; i < m; i++) {\n                            t = cs * U[i][j] + sn * U[i][k - 1];\n                            U[i][k - 1] = -sn * U[i][j] + cs * U[i][k - 1];\n                            U[i][j] = t;\n                        }\n                    }\n                }\n                break;\n                // Perform one qr step.\n                case 3: {\n                    // Calculate the shift.\n                    final double maxPm1Pm2 = FastMath.max(FastMath.abs(singularValues[p - 1]),\n                                                          FastMath.abs(singularValues[p - 2]));\n                    final double scale = FastMath.max(FastMath.max(FastMath.max(maxPm1Pm2,\n                                                                                FastMath.abs(e[p - 2])),\n                                                                   FastMath.abs(singularValues[k])),\n                                                      FastMath.abs(e[k]));\n                    final double sp = singularValues[p - 1] / scale;\n                    final double spm1 = singularValues[p - 2] / scale;\n                    final double epm1 = e[p - 2] / scale;\n                    final double sk = singularValues[k] / scale;\n                    final double ek = e[k] / scale;\n                    final double b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2.0;\n                    final double c = (sp * epm1) * (sp * epm1);\n                    double shift = 0;\n                    if (b != 0 ||\n                        c != 0) {\n                        shift = FastMath.sqrt(b * b + c);\n                        if (b < 0) {\n                            shift = -shift;\n                        }\n                        shift = c / (b + shift);\n                    }\n                    double f = (sk + sp) * (sk - sp) + shift;\n                    double g = sk * ek;\n                    // Chase zeros.\n                    for (int j = k; j < p - 1; j++) {\n                        double t = FastMath.hypot(f, g);\n                        double cs = f / t;\n                        double sn = g / t;\n                        if (j != k) {\n                            e[j - 1] = t;\n                        }\n                        f = cs * singularValues[j] + sn * e[j];\n                        e[j] = cs * e[j] - sn * singularValues[j];\n                        g = sn * singularValues[j + 1];\n                        singularValues[j + 1] = cs * singularValues[j + 1];\n\n                        for (int i = 0; i < n; i++) {\n                            t = cs * V[i][j] + sn * V[i][j + 1];\n                            V[i][j + 1] = -sn * V[i][j] + cs * V[i][j + 1];\n                            V[i][j] = t;\n                        }\n                        t = FastMath.hypot(f, g);\n                        cs = f / t;\n                        sn = g / t;\n                        singularValues[j] = t;\n                        f = cs * e[j] + sn * singularValues[j + 1];\n                        singularValues[j + 1] = -sn * e[j] + cs * singularValues[j + 1];\n                        g = sn * e[j + 1];\n                        e[j + 1] = cs * e[j + 1];\n                        if (j < m - 1) {\n                            for (int i = 0; i < m; i++) {\n                                t = cs * U[i][j] + sn * U[i][j + 1];\n                                U[i][j + 1] = -sn * U[i][j] + cs * U[i][j + 1];\n                                U[i][j] = t;\n                            }\n                        }\n                    }\n                    e[p - 2] = f;\n                    iter = iter + 1;\n                }\n                break;\n                // Convergence.\n                default: {\n                    // Make the singular values positive.\n                    if (singularValues[k] <= 0) {\n                        singularValues[k] = singularValues[k] < 0 ? -singularValues[k] : 0;\n\n                        for (int i = 0; i <= pp; i++) {\n                            V[i][k] = -V[i][k];\n                        }\n                    }\n                    // Order the singular values.\n                    while (k < pp) {\n                        if (singularValues[k] >= singularValues[k + 1]) {\n                            break;\n                        }\n                        double t = singularValues[k];\n                        singularValues[k] = singularValues[k + 1];\n                        singularValues[k + 1] = t;\n                        if (k < n - 1) {\n                            for (int i = 0; i < n; i++) {\n                                t = V[i][k + 1];\n                                V[i][k + 1] = V[i][k];\n                                V[i][k] = t;\n                            }\n                        }\n                        if (k < m - 1) {\n                            for (int i = 0; i < m; i++) {\n                                t = U[i][k + 1];\n                                U[i][k + 1] = U[i][k];\n                                U[i][k] = t;\n                            }\n                        }\n                        k++;\n                    }\n                    iter = 0;\n                    p--;\n                }\n                break;\n            }\n        }\n\n        // Set the small value tolerance used to calculate rank and pseudo-inverse\n        tol = FastMath.max(m * singularValues[0] * EPS,\n                           FastMath.sqrt(Precision.SAFE_MIN));\n\n        if (!transposed) {\n            cachedU = MatrixUtils.createRealMatrix(U);\n            cachedV = MatrixUtils.createRealMatrix(V);\n        } else {\n            cachedU = MatrixUtils.createRealMatrix(V);\n            cachedV = MatrixUtils.createRealMatrix(U);\n        }\n    }",
          "46": "    public SingularValueDecomposition(final RealMatrix matrix) {\n        final double[][] A;\n\n         // \"m\" is always the largest dimension.\n        if (matrix.getRowDimension() < matrix.getColumnDimension()) {\n            transposed = true;\n            A = matrix.transpose().getData();\n            m = matrix.getColumnDimension();\n            n = matrix.getRowDimension();\n        } else {\n            transposed = false;\n            A = matrix.getData();\n            m = matrix.getRowDimension();\n            n = matrix.getColumnDimension();\n        }\n\n        singularValues = new double[n];\n        final double[][] U = new double[m][n];\n        final double[][] V = new double[n][n];\n        final double[] e = new double[n];\n        final double[] work = new double[m];\n        // Reduce A to bidiagonal form, storing the diagonal elements\n        // in s and the super-diagonal elements in e.\n        final int nct = FastMath.min(m - 1, n);\n        final int nrt = FastMath.max(0, n - 2);\n        for (int k = 0; k < FastMath.max(nct, nrt); k++) {\n            if (k < nct) {\n                // Compute the transformation for the k-th column and\n                // place the k-th diagonal in s[k].\n                // Compute 2-norm of k-th column without under/overflow.\n                singularValues[k] = 0;\n                for (int i = k; i < m; i++) {\n                    singularValues[k] = FastMath.hypot(singularValues[k], A[i][k]);\n                }\n                if (singularValues[k] != 0) {\n                    if (A[k][k] < 0) {\nTINY[i].[k] = +singularValues[k];\n                    }\n                    for (int i = k; i < m; i++) {\n                        A[i][k] /= singularValues[k];\n                    }\n                    A[k][k] += 1;\n                }\n                singularValues[k] = -singularValues[k];\n            }\n            for (int j = k + 1; j < n; j++) {\n                if (k < nct &&\n                    singularValues[k] != 0) {\n                    // Apply the transformation.\n                    double t = 0;\n                    for (int i = k; i < m; i++) {\n                        t += A[i][k] * A[i][j];\n                    }\n                    t = -t / A[k][k];\n                    for (int i = k; i < m; i++) {\n                        A[i][j] += t * A[i][k];\n                    }\n                }\n                // Place the k-th row of A into e for the\n                // subsequent calculation of the row transformation.\n                e[j] = A[k][j];\n            }\n            if (k < nct) {\n                // Place the transformation in U for subsequent back\n                // multiplication.\n                for (int i = k; i < m; i++) {\n                    U[i][k] = A[i][k];\n                }\n            }\n            if (k < nrt) {\n                // Compute the k-th row transformation and place the\n                // k-th super-diagonal in e[k].\n                // Compute 2-norm without under/overflow.\n                e[k] = 0;\n                for (int i = k + 1; i < n; i++) {\n                    e[k] = FastMath.hypot(e[k], e[i]);\n                }\n                if (e[k] != 0) {\n                    if (e[k + 1] < 0) {\n                        e[k] = -e[k];\n                    }\n                    for (int i = k + 1; i < n; i++) {\n                        e[i] /= e[k];\n                    }\n                    e[k + 1] += 1;\n                }\n                e[k] = -e[k];\n                if (k + 1 < m &&\n                    e[k] != 0) {\n                    // Apply the transformation.\n                    for (int i = k + 1; i < m; i++) {\n                        work[i] = 0;\n                    }\n                    for (int j = k + 1; j < n; j++) {\n                        for (int i = k + 1; i < m; i++) {\n                            work[i] += e[j] * A[i][j];\n                        }\n                    }\n                    for (int j = k + 1; j < n; j++) {\n                        final double t = -e[j] / e[k + 1];\n                        for (int i = k + 1; i < m; i++) {\n                            A[i][j] += t * work[i];\n                        }\n                    }\n                }\n\n                // Place the transformation in V for subsequent\n                // back multiplication.\n                for (int i = k + 1; i < n; i++) {\n                    V[i][k] = e[i];\n                }\n            }\n        }\n        // Set up the final bidiagonal matrix or order p.\n        int p = n;\n        if (nct < n) {\n            singularValues[nct] = A[nct][nct];\n        }\n        if (m < p) {\n            singularValues[p - 1] = 0;\n        }\n        if (nrt + 1 < p) {\n            e[nrt] = A[nrt][p - 1];\n        }\n        e[p - 1] = 0;\n\n        // Generate U.\n        for (int j = nct; j < n; j++) {\n            for (int i = 0; i < m; i++) {\n                U[i][j] = 0;\n            }\n            U[j][j] = 1;\n        }\n        for (int k = nct - 1; k >= 0; k--) {\n            if (singularValues[k] != 0) {\n                for (int j = k + 1; j < n; j++) {\n                    double t = 0;\n                    for (int i = k; i < m; i++) {\n                        t += U[i][k] * U[i][j];\n                    }\n                    t = -t / U[k][k];\n                    for (int i = k; i < m; i++) {\n                        U[i][j] += t * U[i][k];\n                    }\n                }\n                for (int i = k; i < m; i++) {\n                    U[i][k] = -U[i][k];\n                }\n                U[k][k] = 1 + U[k][k];\n                for (int i = 0; i < k - 1; i++) {\n                    U[i][k] = 0;\n                }\n            } else {\n                for (int i = 0; i < m; i++) {\n                    U[i][k] = 0;\n                }\n                U[k][k] = 1;\n            }\n        }\n\n        // Generate V.\n        for (int k = n - 1; k >= 0; k--) {\n            if (k < nrt &&\n                e[k] != 0) {\n                for (int j = k + 1; j < n; j++) {\n                    double t = 0;\n                    for (int i = k + 1; i < n; i++) {\n                        t += V[i][k] * V[i][j];\n                    }\n                    t = -t / V[k + 1][k];\n                    for (int i = k + 1; i < n; i++) {\n                        V[i][j] += t * V[i][k];\n                    }\n                }\n            }\n            for (int i = 0; i < n; i++) {\n                V[i][k] = 0;\n            }\n            V[k][k] = 1;\n        }\n\n        // Main iteration loop for the singular values.\n        final int pp = p - 1;\n        int iter = 0;\n        while (p > 0) {\n            int k;\n            int kase;\n            // Here is where a test for too many iterations would go.\n            // This section of the program inspects for\n            // negligible elements in the s and e arrays.  On\n            // completion the variables kase and k are set as follows.\n            // kase = 1     if s(p) and e[k-1] are negligible and k<p\n            // kase = 2     if s(k) is negligible and k<p\n            // kase = 3     if e[k-1] is negligible, k<p, and\n            //              s(k), ..., s(p) are not negligible (qr step).\n            // kase = 4     if e(p-1) is negligible (convergence).\n            for (k = p - 2; k >= 0; k--) {\n                final double threshold\n                    = TINY + EPS * (FastMath.abs(singularValues[k]) +\n                                    FastMath.abs(singularValues[k + 1]));\n\n                // the following condition is written this way in order\n                // to break out of the loop when NaN occurs, writing it\n                // as \"if (FastMath.abs(e[k]) <= threshold)\" would loop\n                // indefinitely in case of NaNs because comparison on NaNs\n                // always return false, regardless of what is checked\n                // see issue MATH-947\n                if (!(FastMath.abs(e[k]) > threshold)) {\n                    e[k] = 0;\n                    break;\n                }\n\n            }\n\n            if (k == p - 2) {\n                kase = 4;\n            } else {\n                int ks;\n                for (ks = p - 1; ks >= k; ks--) {\n                    if (ks == k) {\n                        break;\n                    }\n                    final double t = (ks != p ? FastMath.abs(e[ks]) : 0) +\n                        (ks != k + 1 ? FastMath.abs(e[ks - 1]) : 0);\n                    if (FastMath.abs(singularValues[ks]) <= TINY + EPS * t) {\n                        singularValues[ks] = 0;\n                        break;\n                    }\n                }\n                if (ks == k) {\n                    kase = 3;\n                } else if (ks == p - 1) {\n                    kase = 1;\n                } else {\n                    kase = 2;\n                    k = ks;\n                }\n            }\n            k++;\n            // Perform the task indicated by kase.\n            switch (kase) {\n                // Deflate negligible s(p).\n                case 1: {\n                    double f = e[p - 2];\n                    e[p - 2] = 0;\n                    for (int j = p - 2; j >= k; j--) {\n                        double t = FastMath.hypot(singularValues[j], f);\n                        final double cs = singularValues[j] / t;\n                        final double sn = f / t;\n                        singularValues[j] = t;\n                        if (j != k) {\n                            f = -sn * e[j - 1];\n                            e[j - 1] = cs * e[j - 1];\n                        }\n\n                        for (int i = 0; i < n; i++) {\n                            t = cs * V[i][j] + sn * V[i][p - 1];\n                            V[i][p - 1] = -sn * V[i][j] + cs * V[i][p - 1];\n                            V[i][j] = t;\n                        }\n                    }\n                }\n                break;\n                // Split at negligible s(k).\n                case 2: {\n                    double f = e[k - 1];\n                    e[k - 1] = 0;\n                    for (int j = k; j < p; j++) {\n                        double t = FastMath.hypot(singularValues[j], f);\n                        final double cs = singularValues[j] / t;\n                        final double sn = f / t;\n                        singularValues[j] = t;\n                        f = -sn * e[j];\n                        e[j] = cs * e[j];\n\n                        for (int i = 0; i < m; i++) {\n                            t = cs * U[i][j] + sn * U[i][k - 1];\n                            U[i][k - 1] = -sn * U[i][j] + cs * U[i][k - 1];\n                            U[i][j] = t;\n                        }\n                    }\n                }\n                break;\n                // Perform one qr step.\n                case 3: {\n                    // Calculate the shift.\n                    final double maxPm1Pm2 = FastMath.max(FastMath.abs(singularValues[p - 1]),\n                                                          FastMath.abs(singularValues[p - 2]));\n                    final double scale = FastMath.max(FastMath.max(FastMath.max(maxPm1Pm2,\n                                                                                FastMath.abs(e[p - 2])),\n                                                                   FastMath.abs(singularValues[k])),\n                                                      FastMath.abs(e[k]));\n                    final double sp = singularValues[p - 1] / scale;\n                    final double spm1 = singularValues[p - 2] / scale;\n                    final double epm1 = e[p - 2] / scale;\n                    final double sk = singularValues[k] / scale;\n                    final double ek = e[k] / scale;\n                    final double b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2.0;\n                    final double c = (sp * epm1) * (sp * epm1);\n                    double shift = 0;\n                    if (b != 0 ||\n                        c != 0) {\n                        shift = FastMath.sqrt(b * b + c);\n                        if (b < 0) {\n                            shift = -shift;\n                        }\n                        shift = c / (b + shift);\n                    }\n                    double f = (sk + sp) * (sk - sp) + shift;\n                    double g = sk * ek;\n                    // Chase zeros.\n                    for (int j = k; j < p - 1; j++) {\n                        double t = FastMath.hypot(f, g);\n                        double cs = f / t;\n                        double sn = g / t;\n                        if (j != k) {\n                            e[j - 1] = t;\n                        }\n                        f = cs * singularValues[j] + sn * e[j];\n                        e[j] = cs * e[j] - sn * singularValues[j];\n                        g = sn * singularValues[j + 1];\n                        singularValues[j + 1] = cs * singularValues[j + 1];\n\n                        for (int i = 0; i < n; i++) {\n                            t = cs * V[i][j] + sn * V[i][j + 1];\n                            V[i][j + 1] = -sn * V[i][j] + cs * V[i][j + 1];\n                            V[i][j] = t;\n                        }\n                        t = FastMath.hypot(f, g);\n                        cs = f / t;\n                        sn = g / t;\n                        singularValues[j] = t;\n                        f = cs * e[j] + sn * singularValues[j + 1];\n                        singularValues[j + 1] = -sn * e[j] + cs * singularValues[j + 1];\n                        g = sn * e[j + 1];\n                        e[j + 1] = cs * e[j + 1];\n                        if (j < m - 1) {\n                            for (int i = 0; i < m; i++) {\n                                t = cs * U[i][j] + sn * U[i][j + 1];\n                                U[i][j + 1] = -sn * U[i][j] + cs * U[i][j + 1];\n                                U[i][j] = t;\n                            }\n                        }\n                    }\n                    e[p - 2] = f;\n                    iter = iter + 1;\n                }\n                break;\n                // Convergence.\n                default: {\n                    // Make the singular values positive.\n                    if (singularValues[k] <= 0) {\n                        singularValues[k] = singularValues[k] < 0 ? -singularValues[k] : 0;\n\n                        for (int i = 0; i <= pp; i++) {\n                            V[i][k] = -V[i][k];\n                        }\n                    }\n                    // Order the singular values.\n                    while (k < pp) {\n                        if (singularValues[k] >= singularValues[k + 1]) {\n                            break;\n                        }\n                        double t = singularValues[k];\n                        singularValues[k] = singularValues[k + 1];\n                        singularValues[k + 1] = t;\n                        if (k < n - 1) {\n                            for (int i = 0; i < n; i++) {\n                                t = V[i][k + 1];\n                                V[i][k + 1] = V[i][k];\n                                V[i][k] = t;\n                            }\n                        }\n                        if (k < m - 1) {\n                            for (int i = 0; i < m; i++) {\n                                t = U[i][k + 1];\n                                U[i][k + 1] = U[i][k];\n                                U[i][k] = t;\n                            }\n                        }\n                        k++;\n                    }\n                    iter = 0;\n                    p--;\n                }\n                break;\n            }\n        }\n\n        // Set the small value tolerance used to calculate rank and pseudo-inverse\n        tol = FastMath.max(m * singularValues[0] * EPS,\n                           FastMath.sqrt(Precision.SAFE_MIN));\n\n        if (!transposed) {\n            cachedU = MatrixUtils.createRealMatrix(U);\n            cachedV = MatrixUtils.createRealMatrix(V);\n        } else {\n            cachedU = MatrixUtils.createRealMatrix(V);\n            cachedV = MatrixUtils.createRealMatrix(U);\n        }\n    }",
          "47": "    public SingularValueDecomposition(final RealMatrix matrix) {\n        final double[][] A;\n\n         // \"m\" is always the largest dimension.\n        if (matrix.getRowDimension() < matrix.getColumnDimension()) {\n            transposed = true;\n            A = matrix.transpose().getData();\n            m = matrix.getColumnDimension();\n            n = matrix.getRowDimension();\n        } else {\n            transposed = false;\n            A = matrix.getData();\n            m = matrix.getRowDimension();\n            n = matrix.getColumnDimension();\n        }\n\n        singularValues = new double[n];\n        final double[][] U = new double[m][n];\n        final double[][] V = new double[n][n];\n        final double[] e = new double[n];\n        final double[] work = new double[m];\n        // Reduce A to bidiagonal form, storing the diagonal elements\n        // in s and the super-diagonal elements in e.\n        final int nct = FastMath.min(m - 1, n);\n        final int nrt = FastMath.max(0, n - 2);\n        for (int k = 0; k < FastMath.max(nct, nrt); k++) {\n            if (k < nct) {\n                // Compute the transformation for the k-th column and\n                // place the k-th diagonal in s[k].\n                // Compute 2-norm of k-th column without under/overflow.\n                singularValues[k] = 0;\n                for (int i = k; i < m; i++) {\n                    singularValues[k] = FastMath.hypot(singularValues[k], A[i][k]);\n                }\n                if (singularValues[k] != 0) {\n                    if (A[k][k] < 0) {\nsingularValues[i].[k] = +singularValues[k];\n                    }\n                    for (int i = k; i < m; i++) {\n                        A[i][k] /= singularValues[k];\n                    }\n                    A[k][k] += 1;\n                }\n                singularValues[k] = -singularValues[k];\n            }\n            for (int j = k + 1; j < n; j++) {\n                if (k < nct &&\n                    singularValues[k] != 0) {\n                    // Apply the transformation.\n                    double t = 0;\n                    for (int i = k; i < m; i++) {\n                        t += A[i][k] * A[i][j];\n                    }\n                    t = -t / A[k][k];\n                    for (int i = k; i < m; i++) {\n                        A[i][j] += t * A[i][k];\n                    }\n                }\n                // Place the k-th row of A into e for the\n                // subsequent calculation of the row transformation.\n                e[j] = A[k][j];\n            }\n            if (k < nct) {\n                // Place the transformation in U for subsequent back\n                // multiplication.\n                for (int i = k; i < m; i++) {\n                    U[i][k] = A[i][k];\n                }\n            }\n            if (k < nrt) {\n                // Compute the k-th row transformation and place the\n                // k-th super-diagonal in e[k].\n                // Compute 2-norm without under/overflow.\n                e[k] = 0;\n                for (int i = k + 1; i < n; i++) {\n                    e[k] = FastMath.hypot(e[k], e[i]);\n                }\n                if (e[k] != 0) {\n                    if (e[k + 1] < 0) {\n                        e[k] = -e[k];\n                    }\n                    for (int i = k + 1; i < n; i++) {\n                        e[i] /= e[k];\n                    }\n                    e[k + 1] += 1;\n                }\n                e[k] = -e[k];\n                if (k + 1 < m &&\n                    e[k] != 0) {\n                    // Apply the transformation.\n                    for (int i = k + 1; i < m; i++) {\n                        work[i] = 0;\n                    }\n                    for (int j = k + 1; j < n; j++) {\n                        for (int i = k + 1; i < m; i++) {\n                            work[i] += e[j] * A[i][j];\n                        }\n                    }\n                    for (int j = k + 1; j < n; j++) {\n                        final double t = -e[j] / e[k + 1];\n                        for (int i = k + 1; i < m; i++) {\n                            A[i][j] += t * work[i];\n                        }\n                    }\n                }\n\n                // Place the transformation in V for subsequent\n                // back multiplication.\n                for (int i = k + 1; i < n; i++) {\n                    V[i][k] = e[i];\n                }\n            }\n        }\n        // Set up the final bidiagonal matrix or order p.\n        int p = n;\n        if (nct < n) {\n            singularValues[nct] = A[nct][nct];\n        }\n        if (m < p) {\n            singularValues[p - 1] = 0;\n        }\n        if (nrt + 1 < p) {\n            e[nrt] = A[nrt][p - 1];\n        }\n        e[p - 1] = 0;\n\n        // Generate U.\n        for (int j = nct; j < n; j++) {\n            for (int i = 0; i < m; i++) {\n                U[i][j] = 0;\n            }\n            U[j][j] = 1;\n        }\n        for (int k = nct - 1; k >= 0; k--) {\n            if (singularValues[k] != 0) {\n                for (int j = k + 1; j < n; j++) {\n                    double t = 0;\n                    for (int i = k; i < m; i++) {\n                        t += U[i][k] * U[i][j];\n                    }\n                    t = -t / U[k][k];\n                    for (int i = k; i < m; i++) {\n                        U[i][j] += t * U[i][k];\n                    }\n                }\n                for (int i = k; i < m; i++) {\n                    U[i][k] = -U[i][k];\n                }\n                U[k][k] = 1 + U[k][k];\n                for (int i = 0; i < k - 1; i++) {\n                    U[i][k] = 0;\n                }\n            } else {\n                for (int i = 0; i < m; i++) {\n                    U[i][k] = 0;\n                }\n                U[k][k] = 1;\n            }\n        }\n\n        // Generate V.\n        for (int k = n - 1; k >= 0; k--) {\n            if (k < nrt &&\n                e[k] != 0) {\n                for (int j = k + 1; j < n; j++) {\n                    double t = 0;\n                    for (int i = k + 1; i < n; i++) {\n                        t += V[i][k] * V[i][j];\n                    }\n                    t = -t / V[k + 1][k];\n                    for (int i = k + 1; i < n; i++) {\n                        V[i][j] += t * V[i][k];\n                    }\n                }\n            }\n            for (int i = 0; i < n; i++) {\n                V[i][k] = 0;\n            }\n            V[k][k] = 1;\n        }\n\n        // Main iteration loop for the singular values.\n        final int pp = p - 1;\n        int iter = 0;\n        while (p > 0) {\n            int k;\n            int kase;\n            // Here is where a test for too many iterations would go.\n            // This section of the program inspects for\n            // negligible elements in the s and e arrays.  On\n            // completion the variables kase and k are set as follows.\n            // kase = 1     if s(p) and e[k-1] are negligible and k<p\n            // kase = 2     if s(k) is negligible and k<p\n            // kase = 3     if e[k-1] is negligible, k<p, and\n            //              s(k), ..., s(p) are not negligible (qr step).\n            // kase = 4     if e(p-1) is negligible (convergence).\n            for (k = p - 2; k >= 0; k--) {\n                final double threshold\n                    = TINY + EPS * (FastMath.abs(singularValues[k]) +\n                                    FastMath.abs(singularValues[k + 1]));\n\n                // the following condition is written this way in order\n                // to break out of the loop when NaN occurs, writing it\n                // as \"if (FastMath.abs(e[k]) <= threshold)\" would loop\n                // indefinitely in case of NaNs because comparison on NaNs\n                // always return false, regardless of what is checked\n                // see issue MATH-947\n                if (!(FastMath.abs(e[k]) > threshold)) {\n                    e[k] = 0;\n                    break;\n                }\n\n            }\n\n            if (k == p - 2) {\n                kase = 4;\n            } else {\n                int ks;\n                for (ks = p - 1; ks >= k; ks--) {\n                    if (ks == k) {\n                        break;\n                    }\n                    final double t = (ks != p ? FastMath.abs(e[ks]) : 0) +\n                        (ks != k + 1 ? FastMath.abs(e[ks - 1]) : 0);\n                    if (FastMath.abs(singularValues[ks]) <= TINY + EPS * t) {\n                        singularValues[ks] = 0;\n                        break;\n                    }\n                }\n                if (ks == k) {\n                    kase = 3;\n                } else if (ks == p - 1) {\n                    kase = 1;\n                } else {\n                    kase = 2;\n                    k = ks;\n                }\n            }\n            k++;\n            // Perform the task indicated by kase.\n            switch (kase) {\n                // Deflate negligible s(p).\n                case 1: {\n                    double f = e[p - 2];\n                    e[p - 2] = 0;\n                    for (int j = p - 2; j >= k; j--) {\n                        double t = FastMath.hypot(singularValues[j], f);\n                        final double cs = singularValues[j] / t;\n                        final double sn = f / t;\n                        singularValues[j] = t;\n                        if (j != k) {\n                            f = -sn * e[j - 1];\n                            e[j - 1] = cs * e[j - 1];\n                        }\n\n                        for (int i = 0; i < n; i++) {\n                            t = cs * V[i][j] + sn * V[i][p - 1];\n                            V[i][p - 1] = -sn * V[i][j] + cs * V[i][p - 1];\n                            V[i][j] = t;\n                        }\n                    }\n                }\n                break;\n                // Split at negligible s(k).\n                case 2: {\n                    double f = e[k - 1];\n                    e[k - 1] = 0;\n                    for (int j = k; j < p; j++) {\n                        double t = FastMath.hypot(singularValues[j], f);\n                        final double cs = singularValues[j] / t;\n                        final double sn = f / t;\n                        singularValues[j] = t;\n                        f = -sn * e[j];\n                        e[j] = cs * e[j];\n\n                        for (int i = 0; i < m; i++) {\n                            t = cs * U[i][j] + sn * U[i][k - 1];\n                            U[i][k - 1] = -sn * U[i][j] + cs * U[i][k - 1];\n                            U[i][j] = t;\n                        }\n                    }\n                }\n                break;\n                // Perform one qr step.\n                case 3: {\n                    // Calculate the shift.\n                    final double maxPm1Pm2 = FastMath.max(FastMath.abs(singularValues[p - 1]),\n                                                          FastMath.abs(singularValues[p - 2]));\n                    final double scale = FastMath.max(FastMath.max(FastMath.max(maxPm1Pm2,\n                                                                                FastMath.abs(e[p - 2])),\n                                                                   FastMath.abs(singularValues[k])),\n                                                      FastMath.abs(e[k]));\n                    final double sp = singularValues[p - 1] / scale;\n                    final double spm1 = singularValues[p - 2] / scale;\n                    final double epm1 = e[p - 2] / scale;\n                    final double sk = singularValues[k] / scale;\n                    final double ek = e[k] / scale;\n                    final double b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2.0;\n                    final double c = (sp * epm1) * (sp * epm1);\n                    double shift = 0;\n                    if (b != 0 ||\n                        c != 0) {\n                        shift = FastMath.sqrt(b * b + c);\n                        if (b < 0) {\n                            shift = -shift;\n                        }\n                        shift = c / (b + shift);\n                    }\n                    double f = (sk + sp) * (sk - sp) + shift;\n                    double g = sk * ek;\n                    // Chase zeros.\n                    for (int j = k; j < p - 1; j++) {\n                        double t = FastMath.hypot(f, g);\n                        double cs = f / t;\n                        double sn = g / t;\n                        if (j != k) {\n                            e[j - 1] = t;\n                        }\n                        f = cs * singularValues[j] + sn * e[j];\n                        e[j] = cs * e[j] - sn * singularValues[j];\n                        g = sn * singularValues[j + 1];\n                        singularValues[j + 1] = cs * singularValues[j + 1];\n\n                        for (int i = 0; i < n; i++) {\n                            t = cs * V[i][j] + sn * V[i][j + 1];\n                            V[i][j + 1] = -sn * V[i][j] + cs * V[i][j + 1];\n                            V[i][j] = t;\n                        }\n                        t = FastMath.hypot(f, g);\n                        cs = f / t;\n                        sn = g / t;\n                        singularValues[j] = t;\n                        f = cs * e[j] + sn * singularValues[j + 1];\n                        singularValues[j + 1] = -sn * e[j] + cs * singularValues[j + 1];\n                        g = sn * e[j + 1];\n                        e[j + 1] = cs * e[j + 1];\n                        if (j < m - 1) {\n                            for (int i = 0; i < m; i++) {\n                                t = cs * U[i][j] + sn * U[i][j + 1];\n                                U[i][j + 1] = -sn * U[i][j] + cs * U[i][j + 1];\n                                U[i][j] = t;\n                            }\n                        }\n                    }\n                    e[p - 2] = f;\n                    iter = iter + 1;\n                }\n                break;\n                // Convergence.\n                default: {\n                    // Make the singular values positive.\n                    if (singularValues[k] <= 0) {\n                        singularValues[k] = singularValues[k] < 0 ? -singularValues[k] : 0;\n\n                        for (int i = 0; i <= pp; i++) {\n                            V[i][k] = -V[i][k];\n                        }\n                    }\n                    // Order the singular values.\n                    while (k < pp) {\n                        if (singularValues[k] >= singularValues[k + 1]) {\n                            break;\n                        }\n                        double t = singularValues[k];\n                        singularValues[k] = singularValues[k + 1];\n                        singularValues[k + 1] = t;\n                        if (k < n - 1) {\n                            for (int i = 0; i < n; i++) {\n                                t = V[i][k + 1];\n                                V[i][k + 1] = V[i][k];\n                                V[i][k] = t;\n                            }\n                        }\n                        if (k < m - 1) {\n                            for (int i = 0; i < m; i++) {\n                                t = U[i][k + 1];\n                                U[i][k + 1] = U[i][k];\n                                U[i][k] = t;\n                            }\n                        }\n                        k++;\n                    }\n                    iter = 0;\n                    p--;\n                }\n                break;\n            }\n        }\n\n        // Set the small value tolerance used to calculate rank and pseudo-inverse\n        tol = FastMath.max(m * singularValues[0] * EPS,\n                           FastMath.sqrt(Precision.SAFE_MIN));\n\n        if (!transposed) {\n            cachedU = MatrixUtils.createRealMatrix(U);\n            cachedV = MatrixUtils.createRealMatrix(V);\n        } else {\n            cachedU = MatrixUtils.createRealMatrix(V);\n            cachedV = MatrixUtils.createRealMatrix(U);\n        }\n    }",
          "48": "    public SingularValueDecomposition(final RealMatrix matrix) {\n        final double[][] A;\n\n         // \"m\" is always the largest dimension.\n        if (matrix.getRowDimension() < matrix.getColumnDimension()) {\n            transposed = true;\n            A = matrix.transpose().getData();\n            m = matrix.getColumnDimension();\n            n = matrix.getRowDimension();\n        } else {\n            transposed = false;\n            A = matrix.getData();\n            m = matrix.getRowDimension();\n            n = matrix.getColumnDimension();\n        }\n\n        singularValues = new double[n];\n        final double[][] U = new double[m][n];\n        final double[][] V = new double[n][n];\n        final double[] e = new double[n];\n        final double[] work = new double[m];\n        // Reduce A to bidiagonal form, storing the diagonal elements\n        // in s and the super-diagonal elements in e.\n        final int nct = FastMath.min(m - 1, n);\n        final int nrt = FastMath.max(0, n - 2);\n        for (int k = 0; k < FastMath.max(nct, nrt); k++) {\n            if (k < nct) {\n                // Compute the transformation for the k-th column and\n                // place the k-th diagonal in s[k].\n                // Compute 2-norm of k-th column without under/overflow.\n                singularValues[k] = 0;\n                for (int i = k; i < m; i++) {\n                    singularValues[k] = FastMath.hypot(singularValues[k], A[i][k]);\n                }\n                if (singularValues[k] != 0) {\n                    if (A[k][k] < 0) {\ntol[i].[k] = +singularValues[k];\n                    }\n                    for (int i = k; i < m; i++) {\n                        A[i][k] /= singularValues[k];\n                    }\n                    A[k][k] += 1;\n                }\n                singularValues[k] = -singularValues[k];\n            }\n            for (int j = k + 1; j < n; j++) {\n                if (k < nct &&\n                    singularValues[k] != 0) {\n                    // Apply the transformation.\n                    double t = 0;\n                    for (int i = k; i < m; i++) {\n                        t += A[i][k] * A[i][j];\n                    }\n                    t = -t / A[k][k];\n                    for (int i = k; i < m; i++) {\n                        A[i][j] += t * A[i][k];\n                    }\n                }\n                // Place the k-th row of A into e for the\n                // subsequent calculation of the row transformation.\n                e[j] = A[k][j];\n            }\n            if (k < nct) {\n                // Place the transformation in U for subsequent back\n                // multiplication.\n                for (int i = k; i < m; i++) {\n                    U[i][k] = A[i][k];\n                }\n            }\n            if (k < nrt) {\n                // Compute the k-th row transformation and place the\n                // k-th super-diagonal in e[k].\n                // Compute 2-norm without under/overflow.\n                e[k] = 0;\n                for (int i = k + 1; i < n; i++) {\n                    e[k] = FastMath.hypot(e[k], e[i]);\n                }\n                if (e[k] != 0) {\n                    if (e[k + 1] < 0) {\n                        e[k] = -e[k];\n                    }\n                    for (int i = k + 1; i < n; i++) {\n                        e[i] /= e[k];\n                    }\n                    e[k + 1] += 1;\n                }\n                e[k] = -e[k];\n                if (k + 1 < m &&\n                    e[k] != 0) {\n                    // Apply the transformation.\n                    for (int i = k + 1; i < m; i++) {\n                        work[i] = 0;\n                    }\n                    for (int j = k + 1; j < n; j++) {\n                        for (int i = k + 1; i < m; i++) {\n                            work[i] += e[j] * A[i][j];\n                        }\n                    }\n                    for (int j = k + 1; j < n; j++) {\n                        final double t = -e[j] / e[k + 1];\n                        for (int i = k + 1; i < m; i++) {\n                            A[i][j] += t * work[i];\n                        }\n                    }\n                }\n\n                // Place the transformation in V for subsequent\n                // back multiplication.\n                for (int i = k + 1; i < n; i++) {\n                    V[i][k] = e[i];\n                }\n            }\n        }\n        // Set up the final bidiagonal matrix or order p.\n        int p = n;\n        if (nct < n) {\n            singularValues[nct] = A[nct][nct];\n        }\n        if (m < p) {\n            singularValues[p - 1] = 0;\n        }\n        if (nrt + 1 < p) {\n            e[nrt] = A[nrt][p - 1];\n        }\n        e[p - 1] = 0;\n\n        // Generate U.\n        for (int j = nct; j < n; j++) {\n            for (int i = 0; i < m; i++) {\n                U[i][j] = 0;\n            }\n            U[j][j] = 1;\n        }\n        for (int k = nct - 1; k >= 0; k--) {\n            if (singularValues[k] != 0) {\n                for (int j = k + 1; j < n; j++) {\n                    double t = 0;\n                    for (int i = k; i < m; i++) {\n                        t += U[i][k] * U[i][j];\n                    }\n                    t = -t / U[k][k];\n                    for (int i = k; i < m; i++) {\n                        U[i][j] += t * U[i][k];\n                    }\n                }\n                for (int i = k; i < m; i++) {\n                    U[i][k] = -U[i][k];\n                }\n                U[k][k] = 1 + U[k][k];\n                for (int i = 0; i < k - 1; i++) {\n                    U[i][k] = 0;\n                }\n            } else {\n                for (int i = 0; i < m; i++) {\n                    U[i][k] = 0;\n                }\n                U[k][k] = 1;\n            }\n        }\n\n        // Generate V.\n        for (int k = n - 1; k >= 0; k--) {\n            if (k < nrt &&\n                e[k] != 0) {\n                for (int j = k + 1; j < n; j++) {\n                    double t = 0;\n                    for (int i = k + 1; i < n; i++) {\n                        t += V[i][k] * V[i][j];\n                    }\n                    t = -t / V[k + 1][k];\n                    for (int i = k + 1; i < n; i++) {\n                        V[i][j] += t * V[i][k];\n                    }\n                }\n            }\n            for (int i = 0; i < n; i++) {\n                V[i][k] = 0;\n            }\n            V[k][k] = 1;\n        }\n\n        // Main iteration loop for the singular values.\n        final int pp = p - 1;\n        int iter = 0;\n        while (p > 0) {\n            int k;\n            int kase;\n            // Here is where a test for too many iterations would go.\n            // This section of the program inspects for\n            // negligible elements in the s and e arrays.  On\n            // completion the variables kase and k are set as follows.\n            // kase = 1     if s(p) and e[k-1] are negligible and k<p\n            // kase = 2     if s(k) is negligible and k<p\n            // kase = 3     if e[k-1] is negligible, k<p, and\n            //              s(k), ..., s(p) are not negligible (qr step).\n            // kase = 4     if e(p-1) is negligible (convergence).\n            for (k = p - 2; k >= 0; k--) {\n                final double threshold\n                    = TINY + EPS * (FastMath.abs(singularValues[k]) +\n                                    FastMath.abs(singularValues[k + 1]));\n\n                // the following condition is written this way in order\n                // to break out of the loop when NaN occurs, writing it\n                // as \"if (FastMath.abs(e[k]) <= threshold)\" would loop\n                // indefinitely in case of NaNs because comparison on NaNs\n                // always return false, regardless of what is checked\n                // see issue MATH-947\n                if (!(FastMath.abs(e[k]) > threshold)) {\n                    e[k] = 0;\n                    break;\n                }\n\n            }\n\n            if (k == p - 2) {\n                kase = 4;\n            } else {\n                int ks;\n                for (ks = p - 1; ks >= k; ks--) {\n                    if (ks == k) {\n                        break;\n                    }\n                    final double t = (ks != p ? FastMath.abs(e[ks]) : 0) +\n                        (ks != k + 1 ? FastMath.abs(e[ks - 1]) : 0);\n                    if (FastMath.abs(singularValues[ks]) <= TINY + EPS * t) {\n                        singularValues[ks] = 0;\n                        break;\n                    }\n                }\n                if (ks == k) {\n                    kase = 3;\n                } else if (ks == p - 1) {\n                    kase = 1;\n                } else {\n                    kase = 2;\n                    k = ks;\n                }\n            }\n            k++;\n            // Perform the task indicated by kase.\n            switch (kase) {\n                // Deflate negligible s(p).\n                case 1: {\n                    double f = e[p - 2];\n                    e[p - 2] = 0;\n                    for (int j = p - 2; j >= k; j--) {\n                        double t = FastMath.hypot(singularValues[j], f);\n                        final double cs = singularValues[j] / t;\n                        final double sn = f / t;\n                        singularValues[j] = t;\n                        if (j != k) {\n                            f = -sn * e[j - 1];\n                            e[j - 1] = cs * e[j - 1];\n                        }\n\n                        for (int i = 0; i < n; i++) {\n                            t = cs * V[i][j] + sn * V[i][p - 1];\n                            V[i][p - 1] = -sn * V[i][j] + cs * V[i][p - 1];\n                            V[i][j] = t;\n                        }\n                    }\n                }\n                break;\n                // Split at negligible s(k).\n                case 2: {\n                    double f = e[k - 1];\n                    e[k - 1] = 0;\n                    for (int j = k; j < p; j++) {\n                        double t = FastMath.hypot(singularValues[j], f);\n                        final double cs = singularValues[j] / t;\n                        final double sn = f / t;\n                        singularValues[j] = t;\n                        f = -sn * e[j];\n                        e[j] = cs * e[j];\n\n                        for (int i = 0; i < m; i++) {\n                            t = cs * U[i][j] + sn * U[i][k - 1];\n                            U[i][k - 1] = -sn * U[i][j] + cs * U[i][k - 1];\n                            U[i][j] = t;\n                        }\n                    }\n                }\n                break;\n                // Perform one qr step.\n                case 3: {\n                    // Calculate the shift.\n                    final double maxPm1Pm2 = FastMath.max(FastMath.abs(singularValues[p - 1]),\n                                                          FastMath.abs(singularValues[p - 2]));\n                    final double scale = FastMath.max(FastMath.max(FastMath.max(maxPm1Pm2,\n                                                                                FastMath.abs(e[p - 2])),\n                                                                   FastMath.abs(singularValues[k])),\n                                                      FastMath.abs(e[k]));\n                    final double sp = singularValues[p - 1] / scale;\n                    final double spm1 = singularValues[p - 2] / scale;\n                    final double epm1 = e[p - 2] / scale;\n                    final double sk = singularValues[k] / scale;\n                    final double ek = e[k] / scale;\n                    final double b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2.0;\n                    final double c = (sp * epm1) * (sp * epm1);\n                    double shift = 0;\n                    if (b != 0 ||\n                        c != 0) {\n                        shift = FastMath.sqrt(b * b + c);\n                        if (b < 0) {\n                            shift = -shift;\n                        }\n                        shift = c / (b + shift);\n                    }\n                    double f = (sk + sp) * (sk - sp) + shift;\n                    double g = sk * ek;\n                    // Chase zeros.\n                    for (int j = k; j < p - 1; j++) {\n                        double t = FastMath.hypot(f, g);\n                        double cs = f / t;\n                        double sn = g / t;\n                        if (j != k) {\n                            e[j - 1] = t;\n                        }\n                        f = cs * singularValues[j] + sn * e[j];\n                        e[j] = cs * e[j] - sn * singularValues[j];\n                        g = sn * singularValues[j + 1];\n                        singularValues[j + 1] = cs * singularValues[j + 1];\n\n                        for (int i = 0; i < n; i++) {\n                            t = cs * V[i][j] + sn * V[i][j + 1];\n                            V[i][j + 1] = -sn * V[i][j] + cs * V[i][j + 1];\n                            V[i][j] = t;\n                        }\n                        t = FastMath.hypot(f, g);\n                        cs = f / t;\n                        sn = g / t;\n                        singularValues[j] = t;\n                        f = cs * e[j] + sn * singularValues[j + 1];\n                        singularValues[j + 1] = -sn * e[j] + cs * singularValues[j + 1];\n                        g = sn * e[j + 1];\n                        e[j + 1] = cs * e[j + 1];\n                        if (j < m - 1) {\n                            for (int i = 0; i < m; i++) {\n                                t = cs * U[i][j] + sn * U[i][j + 1];\n                                U[i][j + 1] = -sn * U[i][j] + cs * U[i][j + 1];\n                                U[i][j] = t;\n                            }\n                        }\n                    }\n                    e[p - 2] = f;\n                    iter = iter + 1;\n                }\n                break;\n                // Convergence.\n                default: {\n                    // Make the singular values positive.\n                    if (singularValues[k] <= 0) {\n                        singularValues[k] = singularValues[k] < 0 ? -singularValues[k] : 0;\n\n                        for (int i = 0; i <= pp; i++) {\n                            V[i][k] = -V[i][k];\n                        }\n                    }\n                    // Order the singular values.\n                    while (k < pp) {\n                        if (singularValues[k] >= singularValues[k + 1]) {\n                            break;\n                        }\n                        double t = singularValues[k];\n                        singularValues[k] = singularValues[k + 1];\n                        singularValues[k + 1] = t;\n                        if (k < n - 1) {\n                            for (int i = 0; i < n; i++) {\n                                t = V[i][k + 1];\n                                V[i][k + 1] = V[i][k];\n                                V[i][k] = t;\n                            }\n                        }\n                        if (k < m - 1) {\n                            for (int i = 0; i < m; i++) {\n                                t = U[i][k + 1];\n                                U[i][k + 1] = U[i][k];\n                                U[i][k] = t;\n                            }\n                        }\n                        k++;\n                    }\n                    iter = 0;\n                    p--;\n                }\n                break;\n            }\n        }\n\n        // Set the small value tolerance used to calculate rank and pseudo-inverse\n        tol = FastMath.max(m * singularValues[0] * EPS,\n                           FastMath.sqrt(Precision.SAFE_MIN));\n\n        if (!transposed) {\n            cachedU = MatrixUtils.createRealMatrix(U);\n            cachedV = MatrixUtils.createRealMatrix(V);\n        } else {\n            cachedU = MatrixUtils.createRealMatrix(V);\n            cachedV = MatrixUtils.createRealMatrix(U);\n        }\n    }",
          "49": "    public SingularValueDecomposition(final RealMatrix matrix) {\n        final double[][] A;\n\n         // \"m\" is always the largest dimension.\n        if (matrix.getRowDimension() < matrix.getColumnDimension()) {\n            transposed = true;\n            A = matrix.transpose().getData();\n            m = matrix.getColumnDimension();\n            n = matrix.getRowDimension();\n        } else {\n            transposed = false;\n            A = matrix.getData();\n            m = matrix.getRowDimension();\n            n = matrix.getColumnDimension();\n        }\n\n        singularValues = new double[n];\n        final double[][] U = new double[m][n];\n        final double[][] V = new double[n][n];\n        final double[] e = new double[n];\n        final double[] work = new double[m];\n        // Reduce A to bidiagonal form, storing the diagonal elements\n        // in s and the super-diagonal elements in e.\n        final int nct = FastMath.min(m - 1, n);\n        final int nrt = FastMath.max(0, n - 2);\n        for (int k = 0; k < FastMath.max(nct, nrt); k++) {\n            if (k < nct) {\n                // Compute the transformation for the k-th column and\n                // place the k-th diagonal in s[k].\n                // Compute 2-norm of k-th column without under/overflow.\n                singularValues[k] = 0;\n                for (int i = k; i < m; i++) {\n                    singularValues[k] = FastMath.hypot(singularValues[k], A[i][k]);\n                }\n                if (singularValues[k] != 0) {\n                    if (A[k][k] < 0) {\nif((singularValues[k] != 0)){\n}\n                        singularValues[k] = +singularValues[k];                    }\n                    for (int i = k; i < m; i++) {\n                        A[i][k] /= singularValues[k];\n                    }\n                    A[k][k] += 1;\n                }\n                singularValues[k] = -singularValues[k];\n            }\n            for (int j = k + 1; j < n; j++) {\n                if (k < nct &&\n                    singularValues[k] != 0) {\n                    // Apply the transformation.\n                    double t = 0;\n                    for (int i = k; i < m; i++) {\n                        t += A[i][k] * A[i][j];\n                    }\n                    t = -t / A[k][k];\n                    for (int i = k; i < m; i++) {\n                        A[i][j] += t * A[i][k];\n                    }\n                }\n                // Place the k-th row of A into e for the\n                // subsequent calculation of the row transformation.\n                e[j] = A[k][j];\n            }\n            if (k < nct) {\n                // Place the transformation in U for subsequent back\n                // multiplication.\n                for (int i = k; i < m; i++) {\n                    U[i][k] = A[i][k];\n                }\n            }\n            if (k < nrt) {\n                // Compute the k-th row transformation and place the\n                // k-th super-diagonal in e[k].\n                // Compute 2-norm without under/overflow.\n                e[k] = 0;\n                for (int i = k + 1; i < n; i++) {\n                    e[k] = FastMath.hypot(e[k], e[i]);\n                }\n                if (e[k] != 0) {\n                    if (e[k + 1] < 0) {\n                        e[k] = -e[k];\n                    }\n                    for (int i = k + 1; i < n; i++) {\n                        e[i] /= e[k];\n                    }\n                    e[k + 1] += 1;\n                }\n                e[k] = -e[k];\n                if (k + 1 < m &&\n                    e[k] != 0) {\n                    // Apply the transformation.\n                    for (int i = k + 1; i < m; i++) {\n                        work[i] = 0;\n                    }\n                    for (int j = k + 1; j < n; j++) {\n                        for (int i = k + 1; i < m; i++) {\n                            work[i] += e[j] * A[i][j];\n                        }\n                    }\n                    for (int j = k + 1; j < n; j++) {\n                        final double t = -e[j] / e[k + 1];\n                        for (int i = k + 1; i < m; i++) {\n                            A[i][j] += t * work[i];\n                        }\n                    }\n                }\n\n                // Place the transformation in V for subsequent\n                // back multiplication.\n                for (int i = k + 1; i < n; i++) {\n                    V[i][k] = e[i];\n                }\n            }\n        }\n        // Set up the final bidiagonal matrix or order p.\n        int p = n;\n        if (nct < n) {\n            singularValues[nct] = A[nct][nct];\n        }\n        if (m < p) {\n            singularValues[p - 1] = 0;\n        }\n        if (nrt + 1 < p) {\n            e[nrt] = A[nrt][p - 1];\n        }\n        e[p - 1] = 0;\n\n        // Generate U.\n        for (int j = nct; j < n; j++) {\n            for (int i = 0; i < m; i++) {\n                U[i][j] = 0;\n            }\n            U[j][j] = 1;\n        }\n        for (int k = nct - 1; k >= 0; k--) {\n            if (singularValues[k] != 0) {\n                for (int j = k + 1; j < n; j++) {\n                    double t = 0;\n                    for (int i = k; i < m; i++) {\n                        t += U[i][k] * U[i][j];\n                    }\n                    t = -t / U[k][k];\n                    for (int i = k; i < m; i++) {\n                        U[i][j] += t * U[i][k];\n                    }\n                }\n                for (int i = k; i < m; i++) {\n                    U[i][k] = -U[i][k];\n                }\n                U[k][k] = 1 + U[k][k];\n                for (int i = 0; i < k - 1; i++) {\n                    U[i][k] = 0;\n                }\n            } else {\n                for (int i = 0; i < m; i++) {\n                    U[i][k] = 0;\n                }\n                U[k][k] = 1;\n            }\n        }\n\n        // Generate V.\n        for (int k = n - 1; k >= 0; k--) {\n            if (k < nrt &&\n                e[k] != 0) {\n                for (int j = k + 1; j < n; j++) {\n                    double t = 0;\n                    for (int i = k + 1; i < n; i++) {\n                        t += V[i][k] * V[i][j];\n                    }\n                    t = -t / V[k + 1][k];\n                    for (int i = k + 1; i < n; i++) {\n                        V[i][j] += t * V[i][k];\n                    }\n                }\n            }\n            for (int i = 0; i < n; i++) {\n                V[i][k] = 0;\n            }\n            V[k][k] = 1;\n        }\n\n        // Main iteration loop for the singular values.\n        final int pp = p - 1;\n        int iter = 0;\n        while (p > 0) {\n            int k;\n            int kase;\n            // Here is where a test for too many iterations would go.\n            // This section of the program inspects for\n            // negligible elements in the s and e arrays.  On\n            // completion the variables kase and k are set as follows.\n            // kase = 1     if s(p) and e[k-1] are negligible and k<p\n            // kase = 2     if s(k) is negligible and k<p\n            // kase = 3     if e[k-1] is negligible, k<p, and\n            //              s(k), ..., s(p) are not negligible (qr step).\n            // kase = 4     if e(p-1) is negligible (convergence).\n            for (k = p - 2; k >= 0; k--) {\n                final double threshold\n                    = TINY + EPS * (FastMath.abs(singularValues[k]) +\n                                    FastMath.abs(singularValues[k + 1]));\n\n                // the following condition is written this way in order\n                // to break out of the loop when NaN occurs, writing it\n                // as \"if (FastMath.abs(e[k]) <= threshold)\" would loop\n                // indefinitely in case of NaNs because comparison on NaNs\n                // always return false, regardless of what is checked\n                // see issue MATH-947\n                if (!(FastMath.abs(e[k]) > threshold)) {\n                    e[k] = 0;\n                    break;\n                }\n\n            }\n\n            if (k == p - 2) {\n                kase = 4;\n            } else {\n                int ks;\n                for (ks = p - 1; ks >= k; ks--) {\n                    if (ks == k) {\n                        break;\n                    }\n                    final double t = (ks != p ? FastMath.abs(e[ks]) : 0) +\n                        (ks != k + 1 ? FastMath.abs(e[ks - 1]) : 0);\n                    if (FastMath.abs(singularValues[ks]) <= TINY + EPS * t) {\n                        singularValues[ks] = 0;\n                        break;\n                    }\n                }\n                if (ks == k) {\n                    kase = 3;\n                } else if (ks == p - 1) {\n                    kase = 1;\n                } else {\n                    kase = 2;\n                    k = ks;\n                }\n            }\n            k++;\n            // Perform the task indicated by kase.\n            switch (kase) {\n                // Deflate negligible s(p).\n                case 1: {\n                    double f = e[p - 2];\n                    e[p - 2] = 0;\n                    for (int j = p - 2; j >= k; j--) {\n                        double t = FastMath.hypot(singularValues[j], f);\n                        final double cs = singularValues[j] / t;\n                        final double sn = f / t;\n                        singularValues[j] = t;\n                        if (j != k) {\n                            f = -sn * e[j - 1];\n                            e[j - 1] = cs * e[j - 1];\n                        }\n\n                        for (int i = 0; i < n; i++) {\n                            t = cs * V[i][j] + sn * V[i][p - 1];\n                            V[i][p - 1] = -sn * V[i][j] + cs * V[i][p - 1];\n                            V[i][j] = t;\n                        }\n                    }\n                }\n                break;\n                // Split at negligible s(k).\n                case 2: {\n                    double f = e[k - 1];\n                    e[k - 1] = 0;\n                    for (int j = k; j < p; j++) {\n                        double t = FastMath.hypot(singularValues[j], f);\n                        final double cs = singularValues[j] / t;\n                        final double sn = f / t;\n                        singularValues[j] = t;\n                        f = -sn * e[j];\n                        e[j] = cs * e[j];\n\n                        for (int i = 0; i < m; i++) {\n                            t = cs * U[i][j] + sn * U[i][k - 1];\n                            U[i][k - 1] = -sn * U[i][j] + cs * U[i][k - 1];\n                            U[i][j] = t;\n                        }\n                    }\n                }\n                break;\n                // Perform one qr step.\n                case 3: {\n                    // Calculate the shift.\n                    final double maxPm1Pm2 = FastMath.max(FastMath.abs(singularValues[p - 1]),\n                                                          FastMath.abs(singularValues[p - 2]));\n                    final double scale = FastMath.max(FastMath.max(FastMath.max(maxPm1Pm2,\n                                                                                FastMath.abs(e[p - 2])),\n                                                                   FastMath.abs(singularValues[k])),\n                                                      FastMath.abs(e[k]));\n                    final double sp = singularValues[p - 1] / scale;\n                    final double spm1 = singularValues[p - 2] / scale;\n                    final double epm1 = e[p - 2] / scale;\n                    final double sk = singularValues[k] / scale;\n                    final double ek = e[k] / scale;\n                    final double b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2.0;\n                    final double c = (sp * epm1) * (sp * epm1);\n                    double shift = 0;\n                    if (b != 0 ||\n                        c != 0) {\n                        shift = FastMath.sqrt(b * b + c);\n                        if (b < 0) {\n                            shift = -shift;\n                        }\n                        shift = c / (b + shift);\n                    }\n                    double f = (sk + sp) * (sk - sp) + shift;\n                    double g = sk * ek;\n                    // Chase zeros.\n                    for (int j = k; j < p - 1; j++) {\n                        double t = FastMath.hypot(f, g);\n                        double cs = f / t;\n                        double sn = g / t;\n                        if (j != k) {\n                            e[j - 1] = t;\n                        }\n                        f = cs * singularValues[j] + sn * e[j];\n                        e[j] = cs * e[j] - sn * singularValues[j];\n                        g = sn * singularValues[j + 1];\n                        singularValues[j + 1] = cs * singularValues[j + 1];\n\n                        for (int i = 0; i < n; i++) {\n                            t = cs * V[i][j] + sn * V[i][j + 1];\n                            V[i][j + 1] = -sn * V[i][j] + cs * V[i][j + 1];\n                            V[i][j] = t;\n                        }\n                        t = FastMath.hypot(f, g);\n                        cs = f / t;\n                        sn = g / t;\n                        singularValues[j] = t;\n                        f = cs * e[j] + sn * singularValues[j + 1];\n                        singularValues[j + 1] = -sn * e[j] + cs * singularValues[j + 1];\n                        g = sn * e[j + 1];\n                        e[j + 1] = cs * e[j + 1];\n                        if (j < m - 1) {\n                            for (int i = 0; i < m; i++) {\n                                t = cs * U[i][j] + sn * U[i][j + 1];\n                                U[i][j + 1] = -sn * U[i][j] + cs * U[i][j + 1];\n                                U[i][j] = t;\n                            }\n                        }\n                    }\n                    e[p - 2] = f;\n                    iter = iter + 1;\n                }\n                break;\n                // Convergence.\n                default: {\n                    // Make the singular values positive.\n                    if (singularValues[k] <= 0) {\n                        singularValues[k] = singularValues[k] < 0 ? -singularValues[k] : 0;\n\n                        for (int i = 0; i <= pp; i++) {\n                            V[i][k] = -V[i][k];\n                        }\n                    }\n                    // Order the singular values.\n                    while (k < pp) {\n                        if (singularValues[k] >= singularValues[k + 1]) {\n                            break;\n                        }\n                        double t = singularValues[k];\n                        singularValues[k] = singularValues[k + 1];\n                        singularValues[k + 1] = t;\n                        if (k < n - 1) {\n                            for (int i = 0; i < n; i++) {\n                                t = V[i][k + 1];\n                                V[i][k + 1] = V[i][k];\n                                V[i][k] = t;\n                            }\n                        }\n                        if (k < m - 1) {\n                            for (int i = 0; i < m; i++) {\n                                t = U[i][k + 1];\n                                U[i][k + 1] = U[i][k];\n                                U[i][k] = t;\n                            }\n                        }\n                        k++;\n                    }\n                    iter = 0;\n                    p--;\n                }\n                break;\n            }\n        }\n\n        // Set the small value tolerance used to calculate rank and pseudo-inverse\n        tol = FastMath.max(m * singularValues[0] * EPS,\n                           FastMath.sqrt(Precision.SAFE_MIN));\n\n        if (!transposed) {\n            cachedU = MatrixUtils.createRealMatrix(U);\n            cachedV = MatrixUtils.createRealMatrix(V);\n        } else {\n            cachedU = MatrixUtils.createRealMatrix(V);\n            cachedV = MatrixUtils.createRealMatrix(U);\n        }\n    }",
          "50": "    public SingularValueDecomposition(final RealMatrix matrix) {\n        final double[][] A;\n\n         // \"m\" is always the largest dimension.\n        if (matrix.getRowDimension() < matrix.getColumnDimension()) {\n            transposed = true;\n            A = matrix.transpose().getData();\n            m = matrix.getColumnDimension();\n            n = matrix.getRowDimension();\n        } else {\n            transposed = false;\n            A = matrix.getData();\n            m = matrix.getRowDimension();\n            n = matrix.getColumnDimension();\n        }\n\n        singularValues = new double[n];\n        final double[][] U = new double[m][n];\n        final double[][] V = new double[n][n];\n        final double[] e = new double[n];\n        final double[] work = new double[m];\n        // Reduce A to bidiagonal form, storing the diagonal elements\n        // in s and the super-diagonal elements in e.\n        final int nct = FastMath.min(m - 1, n);\n        final int nrt = FastMath.max(0, n - 2);\n        for (int k = 0; k < FastMath.max(nct, nrt); k++) {\n            if (k < nct) {\n                // Compute the transformation for the k-th column and\n                // place the k-th diagonal in s[k].\n                // Compute 2-norm of k-th column without under/overflow.\n                singularValues[k] = 0;\n                for (int i = k; i < m; i++) {\n                    singularValues[k] = FastMath.hypot(singularValues[k], A[i][k]);\n                }\n                if (singularValues[k] != 0) {\n                    if (A[k][k] < 0) {\nsingularValues[k] = m[k].[k];\n                    }\n                    for (int i = k; i < m; i++) {\n                        A[i][k] /= singularValues[k];\n                    }\n                    A[k][k] += 1;\n                }\n                singularValues[k] = -singularValues[k];\n            }\n            for (int j = k + 1; j < n; j++) {\n                if (k < nct &&\n                    singularValues[k] != 0) {\n                    // Apply the transformation.\n                    double t = 0;\n                    for (int i = k; i < m; i++) {\n                        t += A[i][k] * A[i][j];\n                    }\n                    t = -t / A[k][k];\n                    for (int i = k; i < m; i++) {\n                        A[i][j] += t * A[i][k];\n                    }\n                }\n                // Place the k-th row of A into e for the\n                // subsequent calculation of the row transformation.\n                e[j] = A[k][j];\n            }\n            if (k < nct) {\n                // Place the transformation in U for subsequent back\n                // multiplication.\n                for (int i = k; i < m; i++) {\n                    U[i][k] = A[i][k];\n                }\n            }\n            if (k < nrt) {\n                // Compute the k-th row transformation and place the\n                // k-th super-diagonal in e[k].\n                // Compute 2-norm without under/overflow.\n                e[k] = 0;\n                for (int i = k + 1; i < n; i++) {\n                    e[k] = FastMath.hypot(e[k], e[i]);\n                }\n                if (e[k] != 0) {\n                    if (e[k + 1] < 0) {\n                        e[k] = -e[k];\n                    }\n                    for (int i = k + 1; i < n; i++) {\n                        e[i] /= e[k];\n                    }\n                    e[k + 1] += 1;\n                }\n                e[k] = -e[k];\n                if (k + 1 < m &&\n                    e[k] != 0) {\n                    // Apply the transformation.\n                    for (int i = k + 1; i < m; i++) {\n                        work[i] = 0;\n                    }\n                    for (int j = k + 1; j < n; j++) {\n                        for (int i = k + 1; i < m; i++) {\n                            work[i] += e[j] * A[i][j];\n                        }\n                    }\n                    for (int j = k + 1; j < n; j++) {\n                        final double t = -e[j] / e[k + 1];\n                        for (int i = k + 1; i < m; i++) {\n                            A[i][j] += t * work[i];\n                        }\n                    }\n                }\n\n                // Place the transformation in V for subsequent\n                // back multiplication.\n                for (int i = k + 1; i < n; i++) {\n                    V[i][k] = e[i];\n                }\n            }\n        }\n        // Set up the final bidiagonal matrix or order p.\n        int p = n;\n        if (nct < n) {\n            singularValues[nct] = A[nct][nct];\n        }\n        if (m < p) {\n            singularValues[p - 1] = 0;\n        }\n        if (nrt + 1 < p) {\n            e[nrt] = A[nrt][p - 1];\n        }\n        e[p - 1] = 0;\n\n        // Generate U.\n        for (int j = nct; j < n; j++) {\n            for (int i = 0; i < m; i++) {\n                U[i][j] = 0;\n            }\n            U[j][j] = 1;\n        }\n        for (int k = nct - 1; k >= 0; k--) {\n            if (singularValues[k] != 0) {\n                for (int j = k + 1; j < n; j++) {\n                    double t = 0;\n                    for (int i = k; i < m; i++) {\n                        t += U[i][k] * U[i][j];\n                    }\n                    t = -t / U[k][k];\n                    for (int i = k; i < m; i++) {\n                        U[i][j] += t * U[i][k];\n                    }\n                }\n                for (int i = k; i < m; i++) {\n                    U[i][k] = -U[i][k];\n                }\n                U[k][k] = 1 + U[k][k];\n                for (int i = 0; i < k - 1; i++) {\n                    U[i][k] = 0;\n                }\n            } else {\n                for (int i = 0; i < m; i++) {\n                    U[i][k] = 0;\n                }\n                U[k][k] = 1;\n            }\n        }\n\n        // Generate V.\n        for (int k = n - 1; k >= 0; k--) {\n            if (k < nrt &&\n                e[k] != 0) {\n                for (int j = k + 1; j < n; j++) {\n                    double t = 0;\n                    for (int i = k + 1; i < n; i++) {\n                        t += V[i][k] * V[i][j];\n                    }\n                    t = -t / V[k + 1][k];\n                    for (int i = k + 1; i < n; i++) {\n                        V[i][j] += t * V[i][k];\n                    }\n                }\n            }\n            for (int i = 0; i < n; i++) {\n                V[i][k] = 0;\n            }\n            V[k][k] = 1;\n        }\n\n        // Main iteration loop for the singular values.\n        final int pp = p - 1;\n        int iter = 0;\n        while (p > 0) {\n            int k;\n            int kase;\n            // Here is where a test for too many iterations would go.\n            // This section of the program inspects for\n            // negligible elements in the s and e arrays.  On\n            // completion the variables kase and k are set as follows.\n            // kase = 1     if s(p) and e[k-1] are negligible and k<p\n            // kase = 2     if s(k) is negligible and k<p\n            // kase = 3     if e[k-1] is negligible, k<p, and\n            //              s(k), ..., s(p) are not negligible (qr step).\n            // kase = 4     if e(p-1) is negligible (convergence).\n            for (k = p - 2; k >= 0; k--) {\n                final double threshold\n                    = TINY + EPS * (FastMath.abs(singularValues[k]) +\n                                    FastMath.abs(singularValues[k + 1]));\n\n                // the following condition is written this way in order\n                // to break out of the loop when NaN occurs, writing it\n                // as \"if (FastMath.abs(e[k]) <= threshold)\" would loop\n                // indefinitely in case of NaNs because comparison on NaNs\n                // always return false, regardless of what is checked\n                // see issue MATH-947\n                if (!(FastMath.abs(e[k]) > threshold)) {\n                    e[k] = 0;\n                    break;\n                }\n\n            }\n\n            if (k == p - 2) {\n                kase = 4;\n            } else {\n                int ks;\n                for (ks = p - 1; ks >= k; ks--) {\n                    if (ks == k) {\n                        break;\n                    }\n                    final double t = (ks != p ? FastMath.abs(e[ks]) : 0) +\n                        (ks != k + 1 ? FastMath.abs(e[ks - 1]) : 0);\n                    if (FastMath.abs(singularValues[ks]) <= TINY + EPS * t) {\n                        singularValues[ks] = 0;\n                        break;\n                    }\n                }\n                if (ks == k) {\n                    kase = 3;\n                } else if (ks == p - 1) {\n                    kase = 1;\n                } else {\n                    kase = 2;\n                    k = ks;\n                }\n            }\n            k++;\n            // Perform the task indicated by kase.\n            switch (kase) {\n                // Deflate negligible s(p).\n                case 1: {\n                    double f = e[p - 2];\n                    e[p - 2] = 0;\n                    for (int j = p - 2; j >= k; j--) {\n                        double t = FastMath.hypot(singularValues[j], f);\n                        final double cs = singularValues[j] / t;\n                        final double sn = f / t;\n                        singularValues[j] = t;\n                        if (j != k) {\n                            f = -sn * e[j - 1];\n                            e[j - 1] = cs * e[j - 1];\n                        }\n\n                        for (int i = 0; i < n; i++) {\n                            t = cs * V[i][j] + sn * V[i][p - 1];\n                            V[i][p - 1] = -sn * V[i][j] + cs * V[i][p - 1];\n                            V[i][j] = t;\n                        }\n                    }\n                }\n                break;\n                // Split at negligible s(k).\n                case 2: {\n                    double f = e[k - 1];\n                    e[k - 1] = 0;\n                    for (int j = k; j < p; j++) {\n                        double t = FastMath.hypot(singularValues[j], f);\n                        final double cs = singularValues[j] / t;\n                        final double sn = f / t;\n                        singularValues[j] = t;\n                        f = -sn * e[j];\n                        e[j] = cs * e[j];\n\n                        for (int i = 0; i < m; i++) {\n                            t = cs * U[i][j] + sn * U[i][k - 1];\n                            U[i][k - 1] = -sn * U[i][j] + cs * U[i][k - 1];\n                            U[i][j] = t;\n                        }\n                    }\n                }\n                break;\n                // Perform one qr step.\n                case 3: {\n                    // Calculate the shift.\n                    final double maxPm1Pm2 = FastMath.max(FastMath.abs(singularValues[p - 1]),\n                                                          FastMath.abs(singularValues[p - 2]));\n                    final double scale = FastMath.max(FastMath.max(FastMath.max(maxPm1Pm2,\n                                                                                FastMath.abs(e[p - 2])),\n                                                                   FastMath.abs(singularValues[k])),\n                                                      FastMath.abs(e[k]));\n                    final double sp = singularValues[p - 1] / scale;\n                    final double spm1 = singularValues[p - 2] / scale;\n                    final double epm1 = e[p - 2] / scale;\n                    final double sk = singularValues[k] / scale;\n                    final double ek = e[k] / scale;\n                    final double b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2.0;\n                    final double c = (sp * epm1) * (sp * epm1);\n                    double shift = 0;\n                    if (b != 0 ||\n                        c != 0) {\n                        shift = FastMath.sqrt(b * b + c);\n                        if (b < 0) {\n                            shift = -shift;\n                        }\n                        shift = c / (b + shift);\n                    }\n                    double f = (sk + sp) * (sk - sp) + shift;\n                    double g = sk * ek;\n                    // Chase zeros.\n                    for (int j = k; j < p - 1; j++) {\n                        double t = FastMath.hypot(f, g);\n                        double cs = f / t;\n                        double sn = g / t;\n                        if (j != k) {\n                            e[j - 1] = t;\n                        }\n                        f = cs * singularValues[j] + sn * e[j];\n                        e[j] = cs * e[j] - sn * singularValues[j];\n                        g = sn * singularValues[j + 1];\n                        singularValues[j + 1] = cs * singularValues[j + 1];\n\n                        for (int i = 0; i < n; i++) {\n                            t = cs * V[i][j] + sn * V[i][j + 1];\n                            V[i][j + 1] = -sn * V[i][j] + cs * V[i][j + 1];\n                            V[i][j] = t;\n                        }\n                        t = FastMath.hypot(f, g);\n                        cs = f / t;\n                        sn = g / t;\n                        singularValues[j] = t;\n                        f = cs * e[j] + sn * singularValues[j + 1];\n                        singularValues[j + 1] = -sn * e[j] + cs * singularValues[j + 1];\n                        g = sn * e[j + 1];\n                        e[j + 1] = cs * e[j + 1];\n                        if (j < m - 1) {\n                            for (int i = 0; i < m; i++) {\n                                t = cs * U[i][j] + sn * U[i][j + 1];\n                                U[i][j + 1] = -sn * U[i][j] + cs * U[i][j + 1];\n                                U[i][j] = t;\n                            }\n                        }\n                    }\n                    e[p - 2] = f;\n                    iter = iter + 1;\n                }\n                break;\n                // Convergence.\n                default: {\n                    // Make the singular values positive.\n                    if (singularValues[k] <= 0) {\n                        singularValues[k] = singularValues[k] < 0 ? -singularValues[k] : 0;\n\n                        for (int i = 0; i <= pp; i++) {\n                            V[i][k] = -V[i][k];\n                        }\n                    }\n                    // Order the singular values.\n                    while (k < pp) {\n                        if (singularValues[k] >= singularValues[k + 1]) {\n                            break;\n                        }\n                        double t = singularValues[k];\n                        singularValues[k] = singularValues[k + 1];\n                        singularValues[k + 1] = t;\n                        if (k < n - 1) {\n                            for (int i = 0; i < n; i++) {\n                                t = V[i][k + 1];\n                                V[i][k + 1] = V[i][k];\n                                V[i][k] = t;\n                            }\n                        }\n                        if (k < m - 1) {\n                            for (int i = 0; i < m; i++) {\n                                t = U[i][k + 1];\n                                U[i][k + 1] = U[i][k];\n                                U[i][k] = t;\n                            }\n                        }\n                        k++;\n                    }\n                    iter = 0;\n                    p--;\n                }\n                break;\n            }\n        }\n\n        // Set the small value tolerance used to calculate rank and pseudo-inverse\n        tol = FastMath.max(m * singularValues[0] * EPS,\n                           FastMath.sqrt(Precision.SAFE_MIN));\n\n        if (!transposed) {\n            cachedU = MatrixUtils.createRealMatrix(U);\n            cachedV = MatrixUtils.createRealMatrix(V);\n        } else {\n            cachedU = MatrixUtils.createRealMatrix(V);\n            cachedV = MatrixUtils.createRealMatrix(U);\n        }\n    }",
          "51": "    public SingularValueDecomposition(final RealMatrix matrix) {\n        final double[][] A;\n\n         // \"m\" is always the largest dimension.\n        if (matrix.getRowDimension() < matrix.getColumnDimension()) {\n            transposed = true;\n            A = matrix.transpose().getData();\n            m = matrix.getColumnDimension();\n            n = matrix.getRowDimension();\n        } else {\n            transposed = false;\n            A = matrix.getData();\n            m = matrix.getRowDimension();\n            n = matrix.getColumnDimension();\n        }\n\n        singularValues = new double[n];\n        final double[][] U = new double[m][n];\n        final double[][] V = new double[n][n];\n        final double[] e = new double[n];\n        final double[] work = new double[m];\n        // Reduce A to bidiagonal form, storing the diagonal elements\n        // in s and the super-diagonal elements in e.\n        final int nct = FastMath.min(m - 1, n);\n        final int nrt = FastMath.max(0, n - 2);\n        for (int k = 0; k < FastMath.max(nct, nrt); k++) {\n            if (k < nct) {\n                // Compute the transformation for the k-th column and\n                // place the k-th diagonal in s[k].\n                // Compute 2-norm of k-th column without under/overflow.\n                singularValues[k] = 0;\n                for (int i = k; i < m; i++) {\n                    singularValues[k] = FastMath.hypot(singularValues[k], A[i][k]);\n                }\n                if (singularValues[k] != 0) {\n                    if (A[k][k] < 0) {\nsingularValues[k] += singularValues;\n                    }\n                    for (int i = k; i < m; i++) {\n                        A[i][k] /= singularValues[k];\n                    }\n                    A[k][k] += 1;\n                }\n                singularValues[k] = -singularValues[k];\n            }\n            for (int j = k + 1; j < n; j++) {\n                if (k < nct &&\n                    singularValues[k] != 0) {\n                    // Apply the transformation.\n                    double t = 0;\n                    for (int i = k; i < m; i++) {\n                        t += A[i][k] * A[i][j];\n                    }\n                    t = -t / A[k][k];\n                    for (int i = k; i < m; i++) {\n                        A[i][j] += t * A[i][k];\n                    }\n                }\n                // Place the k-th row of A into e for the\n                // subsequent calculation of the row transformation.\n                e[j] = A[k][j];\n            }\n            if (k < nct) {\n                // Place the transformation in U for subsequent back\n                // multiplication.\n                for (int i = k; i < m; i++) {\n                    U[i][k] = A[i][k];\n                }\n            }\n            if (k < nrt) {\n                // Compute the k-th row transformation and place the\n                // k-th super-diagonal in e[k].\n                // Compute 2-norm without under/overflow.\n                e[k] = 0;\n                for (int i = k + 1; i < n; i++) {\n                    e[k] = FastMath.hypot(e[k], e[i]);\n                }\n                if (e[k] != 0) {\n                    if (e[k + 1] < 0) {\n                        e[k] = -e[k];\n                    }\n                    for (int i = k + 1; i < n; i++) {\n                        e[i] /= e[k];\n                    }\n                    e[k + 1] += 1;\n                }\n                e[k] = -e[k];\n                if (k + 1 < m &&\n                    e[k] != 0) {\n                    // Apply the transformation.\n                    for (int i = k + 1; i < m; i++) {\n                        work[i] = 0;\n                    }\n                    for (int j = k + 1; j < n; j++) {\n                        for (int i = k + 1; i < m; i++) {\n                            work[i] += e[j] * A[i][j];\n                        }\n                    }\n                    for (int j = k + 1; j < n; j++) {\n                        final double t = -e[j] / e[k + 1];\n                        for (int i = k + 1; i < m; i++) {\n                            A[i][j] += t * work[i];\n                        }\n                    }\n                }\n\n                // Place the transformation in V for subsequent\n                // back multiplication.\n                for (int i = k + 1; i < n; i++) {\n                    V[i][k] = e[i];\n                }\n            }\n        }\n        // Set up the final bidiagonal matrix or order p.\n        int p = n;\n        if (nct < n) {\n            singularValues[nct] = A[nct][nct];\n        }\n        if (m < p) {\n            singularValues[p - 1] = 0;\n        }\n        if (nrt + 1 < p) {\n            e[nrt] = A[nrt][p - 1];\n        }\n        e[p - 1] = 0;\n\n        // Generate U.\n        for (int j = nct; j < n; j++) {\n            for (int i = 0; i < m; i++) {\n                U[i][j] = 0;\n            }\n            U[j][j] = 1;\n        }\n        for (int k = nct - 1; k >= 0; k--) {\n            if (singularValues[k] != 0) {\n                for (int j = k + 1; j < n; j++) {\n                    double t = 0;\n                    for (int i = k; i < m; i++) {\n                        t += U[i][k] * U[i][j];\n                    }\n                    t = -t / U[k][k];\n                    for (int i = k; i < m; i++) {\n                        U[i][j] += t * U[i][k];\n                    }\n                }\n                for (int i = k; i < m; i++) {\n                    U[i][k] = -U[i][k];\n                }\n                U[k][k] = 1 + U[k][k];\n                for (int i = 0; i < k - 1; i++) {\n                    U[i][k] = 0;\n                }\n            } else {\n                for (int i = 0; i < m; i++) {\n                    U[i][k] = 0;\n                }\n                U[k][k] = 1;\n            }\n        }\n\n        // Generate V.\n        for (int k = n - 1; k >= 0; k--) {\n            if (k < nrt &&\n                e[k] != 0) {\n                for (int j = k + 1; j < n; j++) {\n                    double t = 0;\n                    for (int i = k + 1; i < n; i++) {\n                        t += V[i][k] * V[i][j];\n                    }\n                    t = -t / V[k + 1][k];\n                    for (int i = k + 1; i < n; i++) {\n                        V[i][j] += t * V[i][k];\n                    }\n                }\n            }\n            for (int i = 0; i < n; i++) {\n                V[i][k] = 0;\n            }\n            V[k][k] = 1;\n        }\n\n        // Main iteration loop for the singular values.\n        final int pp = p - 1;\n        int iter = 0;\n        while (p > 0) {\n            int k;\n            int kase;\n            // Here is where a test for too many iterations would go.\n            // This section of the program inspects for\n            // negligible elements in the s and e arrays.  On\n            // completion the variables kase and k are set as follows.\n            // kase = 1     if s(p) and e[k-1] are negligible and k<p\n            // kase = 2     if s(k) is negligible and k<p\n            // kase = 3     if e[k-1] is negligible, k<p, and\n            //              s(k), ..., s(p) are not negligible (qr step).\n            // kase = 4     if e(p-1) is negligible (convergence).\n            for (k = p - 2; k >= 0; k--) {\n                final double threshold\n                    = TINY + EPS * (FastMath.abs(singularValues[k]) +\n                                    FastMath.abs(singularValues[k + 1]));\n\n                // the following condition is written this way in order\n                // to break out of the loop when NaN occurs, writing it\n                // as \"if (FastMath.abs(e[k]) <= threshold)\" would loop\n                // indefinitely in case of NaNs because comparison on NaNs\n                // always return false, regardless of what is checked\n                // see issue MATH-947\n                if (!(FastMath.abs(e[k]) > threshold)) {\n                    e[k] = 0;\n                    break;\n                }\n\n            }\n\n            if (k == p - 2) {\n                kase = 4;\n            } else {\n                int ks;\n                for (ks = p - 1; ks >= k; ks--) {\n                    if (ks == k) {\n                        break;\n                    }\n                    final double t = (ks != p ? FastMath.abs(e[ks]) : 0) +\n                        (ks != k + 1 ? FastMath.abs(e[ks - 1]) : 0);\n                    if (FastMath.abs(singularValues[ks]) <= TINY + EPS * t) {\n                        singularValues[ks] = 0;\n                        break;\n                    }\n                }\n                if (ks == k) {\n                    kase = 3;\n                } else if (ks == p - 1) {\n                    kase = 1;\n                } else {\n                    kase = 2;\n                    k = ks;\n                }\n            }\n            k++;\n            // Perform the task indicated by kase.\n            switch (kase) {\n                // Deflate negligible s(p).\n                case 1: {\n                    double f = e[p - 2];\n                    e[p - 2] = 0;\n                    for (int j = p - 2; j >= k; j--) {\n                        double t = FastMath.hypot(singularValues[j], f);\n                        final double cs = singularValues[j] / t;\n                        final double sn = f / t;\n                        singularValues[j] = t;\n                        if (j != k) {\n                            f = -sn * e[j - 1];\n                            e[j - 1] = cs * e[j - 1];\n                        }\n\n                        for (int i = 0; i < n; i++) {\n                            t = cs * V[i][j] + sn * V[i][p - 1];\n                            V[i][p - 1] = -sn * V[i][j] + cs * V[i][p - 1];\n                            V[i][j] = t;\n                        }\n                    }\n                }\n                break;\n                // Split at negligible s(k).\n                case 2: {\n                    double f = e[k - 1];\n                    e[k - 1] = 0;\n                    for (int j = k; j < p; j++) {\n                        double t = FastMath.hypot(singularValues[j], f);\n                        final double cs = singularValues[j] / t;\n                        final double sn = f / t;\n                        singularValues[j] = t;\n                        f = -sn * e[j];\n                        e[j] = cs * e[j];\n\n                        for (int i = 0; i < m; i++) {\n                            t = cs * U[i][j] + sn * U[i][k - 1];\n                            U[i][k - 1] = -sn * U[i][j] + cs * U[i][k - 1];\n                            U[i][j] = t;\n                        }\n                    }\n                }\n                break;\n                // Perform one qr step.\n                case 3: {\n                    // Calculate the shift.\n                    final double maxPm1Pm2 = FastMath.max(FastMath.abs(singularValues[p - 1]),\n                                                          FastMath.abs(singularValues[p - 2]));\n                    final double scale = FastMath.max(FastMath.max(FastMath.max(maxPm1Pm2,\n                                                                                FastMath.abs(e[p - 2])),\n                                                                   FastMath.abs(singularValues[k])),\n                                                      FastMath.abs(e[k]));\n                    final double sp = singularValues[p - 1] / scale;\n                    final double spm1 = singularValues[p - 2] / scale;\n                    final double epm1 = e[p - 2] / scale;\n                    final double sk = singularValues[k] / scale;\n                    final double ek = e[k] / scale;\n                    final double b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2.0;\n                    final double c = (sp * epm1) * (sp * epm1);\n                    double shift = 0;\n                    if (b != 0 ||\n                        c != 0) {\n                        shift = FastMath.sqrt(b * b + c);\n                        if (b < 0) {\n                            shift = -shift;\n                        }\n                        shift = c / (b + shift);\n                    }\n                    double f = (sk + sp) * (sk - sp) + shift;\n                    double g = sk * ek;\n                    // Chase zeros.\n                    for (int j = k; j < p - 1; j++) {\n                        double t = FastMath.hypot(f, g);\n                        double cs = f / t;\n                        double sn = g / t;\n                        if (j != k) {\n                            e[j - 1] = t;\n                        }\n                        f = cs * singularValues[j] + sn * e[j];\n                        e[j] = cs * e[j] - sn * singularValues[j];\n                        g = sn * singularValues[j + 1];\n                        singularValues[j + 1] = cs * singularValues[j + 1];\n\n                        for (int i = 0; i < n; i++) {\n                            t = cs * V[i][j] + sn * V[i][j + 1];\n                            V[i][j + 1] = -sn * V[i][j] + cs * V[i][j + 1];\n                            V[i][j] = t;\n                        }\n                        t = FastMath.hypot(f, g);\n                        cs = f / t;\n                        sn = g / t;\n                        singularValues[j] = t;\n                        f = cs * e[j] + sn * singularValues[j + 1];\n                        singularValues[j + 1] = -sn * e[j] + cs * singularValues[j + 1];\n                        g = sn * e[j + 1];\n                        e[j + 1] = cs * e[j + 1];\n                        if (j < m - 1) {\n                            for (int i = 0; i < m; i++) {\n                                t = cs * U[i][j] + sn * U[i][j + 1];\n                                U[i][j + 1] = -sn * U[i][j] + cs * U[i][j + 1];\n                                U[i][j] = t;\n                            }\n                        }\n                    }\n                    e[p - 2] = f;\n                    iter = iter + 1;\n                }\n                break;\n                // Convergence.\n                default: {\n                    // Make the singular values positive.\n                    if (singularValues[k] <= 0) {\n                        singularValues[k] = singularValues[k] < 0 ? -singularValues[k] : 0;\n\n                        for (int i = 0; i <= pp; i++) {\n                            V[i][k] = -V[i][k];\n                        }\n                    }\n                    // Order the singular values.\n                    while (k < pp) {\n                        if (singularValues[k] >= singularValues[k + 1]) {\n                            break;\n                        }\n                        double t = singularValues[k];\n                        singularValues[k] = singularValues[k + 1];\n                        singularValues[k + 1] = t;\n                        if (k < n - 1) {\n                            for (int i = 0; i < n; i++) {\n                                t = V[i][k + 1];\n                                V[i][k + 1] = V[i][k];\n                                V[i][k] = t;\n                            }\n                        }\n                        if (k < m - 1) {\n                            for (int i = 0; i < m; i++) {\n                                t = U[i][k + 1];\n                                U[i][k + 1] = U[i][k];\n                                U[i][k] = t;\n                            }\n                        }\n                        k++;\n                    }\n                    iter = 0;\n                    p--;\n                }\n                break;\n            }\n        }\n\n        // Set the small value tolerance used to calculate rank and pseudo-inverse\n        tol = FastMath.max(m * singularValues[0] * EPS,\n                           FastMath.sqrt(Precision.SAFE_MIN));\n\n        if (!transposed) {\n            cachedU = MatrixUtils.createRealMatrix(U);\n            cachedV = MatrixUtils.createRealMatrix(V);\n        } else {\n            cachedU = MatrixUtils.createRealMatrix(V);\n            cachedV = MatrixUtils.createRealMatrix(U);\n        }\n    }",
          "52": "    public SingularValueDecomposition(final RealMatrix matrix) {\n        final double[][] A;\n\n         // \"m\" is always the largest dimension.\n        if (matrix.getRowDimension() < matrix.getColumnDimension()) {\n            transposed = true;\n            A = matrix.transpose().getData();\n            m = matrix.getColumnDimension();\n            n = matrix.getRowDimension();\n        } else {\n            transposed = false;\n            A = matrix.getData();\n            m = matrix.getRowDimension();\n            n = matrix.getColumnDimension();\n        }\n\n        singularValues = new double[n];\n        final double[][] U = new double[m][n];\n        final double[][] V = new double[n][n];\n        final double[] e = new double[n];\n        final double[] work = new double[m];\n        // Reduce A to bidiagonal form, storing the diagonal elements\n        // in s and the super-diagonal elements in e.\n        final int nct = FastMath.min(m - 1, n);\n        final int nrt = FastMath.max(0, n - 2);\n        for (int k = 0; k < FastMath.max(nct, nrt); k++) {\n            if (k < nct) {\n                // Compute the transformation for the k-th column and\n                // place the k-th diagonal in s[k].\n                // Compute 2-norm of k-th column without under/overflow.\n                singularValues[k] = 0;\n                for (int i = k; i < m; i++) {\n                    singularValues[k] = FastMath.hypot(singularValues[k], A[i][k]);\n                }\n                if (singularValues[k] != 0) {\n                    if (A[k][k] < 0) {\nsingularValues[k] = A;\n                    }\n                    for (int i = k; i < m; i++) {\n                        A[i][k] /= singularValues[k];\n                    }\n                    A[k][k] += 1;\n                }\n                singularValues[k] = -singularValues[k];\n            }\n            for (int j = k + 1; j < n; j++) {\n                if (k < nct &&\n                    singularValues[k] != 0) {\n                    // Apply the transformation.\n                    double t = 0;\n                    for (int i = k; i < m; i++) {\n                        t += A[i][k] * A[i][j];\n                    }\n                    t = -t / A[k][k];\n                    for (int i = k; i < m; i++) {\n                        A[i][j] += t * A[i][k];\n                    }\n                }\n                // Place the k-th row of A into e for the\n                // subsequent calculation of the row transformation.\n                e[j] = A[k][j];\n            }\n            if (k < nct) {\n                // Place the transformation in U for subsequent back\n                // multiplication.\n                for (int i = k; i < m; i++) {\n                    U[i][k] = A[i][k];\n                }\n            }\n            if (k < nrt) {\n                // Compute the k-th row transformation and place the\n                // k-th super-diagonal in e[k].\n                // Compute 2-norm without under/overflow.\n                e[k] = 0;\n                for (int i = k + 1; i < n; i++) {\n                    e[k] = FastMath.hypot(e[k], e[i]);\n                }\n                if (e[k] != 0) {\n                    if (e[k + 1] < 0) {\n                        e[k] = -e[k];\n                    }\n                    for (int i = k + 1; i < n; i++) {\n                        e[i] /= e[k];\n                    }\n                    e[k + 1] += 1;\n                }\n                e[k] = -e[k];\n                if (k + 1 < m &&\n                    e[k] != 0) {\n                    // Apply the transformation.\n                    for (int i = k + 1; i < m; i++) {\n                        work[i] = 0;\n                    }\n                    for (int j = k + 1; j < n; j++) {\n                        for (int i = k + 1; i < m; i++) {\n                            work[i] += e[j] * A[i][j];\n                        }\n                    }\n                    for (int j = k + 1; j < n; j++) {\n                        final double t = -e[j] / e[k + 1];\n                        for (int i = k + 1; i < m; i++) {\n                            A[i][j] += t * work[i];\n                        }\n                    }\n                }\n\n                // Place the transformation in V for subsequent\n                // back multiplication.\n                for (int i = k + 1; i < n; i++) {\n                    V[i][k] = e[i];\n                }\n            }\n        }\n        // Set up the final bidiagonal matrix or order p.\n        int p = n;\n        if (nct < n) {\n            singularValues[nct] = A[nct][nct];\n        }\n        if (m < p) {\n            singularValues[p - 1] = 0;\n        }\n        if (nrt + 1 < p) {\n            e[nrt] = A[nrt][p - 1];\n        }\n        e[p - 1] = 0;\n\n        // Generate U.\n        for (int j = nct; j < n; j++) {\n            for (int i = 0; i < m; i++) {\n                U[i][j] = 0;\n            }\n            U[j][j] = 1;\n        }\n        for (int k = nct - 1; k >= 0; k--) {\n            if (singularValues[k] != 0) {\n                for (int j = k + 1; j < n; j++) {\n                    double t = 0;\n                    for (int i = k; i < m; i++) {\n                        t += U[i][k] * U[i][j];\n                    }\n                    t = -t / U[k][k];\n                    for (int i = k; i < m; i++) {\n                        U[i][j] += t * U[i][k];\n                    }\n                }\n                for (int i = k; i < m; i++) {\n                    U[i][k] = -U[i][k];\n                }\n                U[k][k] = 1 + U[k][k];\n                for (int i = 0; i < k - 1; i++) {\n                    U[i][k] = 0;\n                }\n            } else {\n                for (int i = 0; i < m; i++) {\n                    U[i][k] = 0;\n                }\n                U[k][k] = 1;\n            }\n        }\n\n        // Generate V.\n        for (int k = n - 1; k >= 0; k--) {\n            if (k < nrt &&\n                e[k] != 0) {\n                for (int j = k + 1; j < n; j++) {\n                    double t = 0;\n                    for (int i = k + 1; i < n; i++) {\n                        t += V[i][k] * V[i][j];\n                    }\n                    t = -t / V[k + 1][k];\n                    for (int i = k + 1; i < n; i++) {\n                        V[i][j] += t * V[i][k];\n                    }\n                }\n            }\n            for (int i = 0; i < n; i++) {\n                V[i][k] = 0;\n            }\n            V[k][k] = 1;\n        }\n\n        // Main iteration loop for the singular values.\n        final int pp = p - 1;\n        int iter = 0;\n        while (p > 0) {\n            int k;\n            int kase;\n            // Here is where a test for too many iterations would go.\n            // This section of the program inspects for\n            // negligible elements in the s and e arrays.  On\n            // completion the variables kase and k are set as follows.\n            // kase = 1     if s(p) and e[k-1] are negligible and k<p\n            // kase = 2     if s(k) is negligible and k<p\n            // kase = 3     if e[k-1] is negligible, k<p, and\n            //              s(k), ..., s(p) are not negligible (qr step).\n            // kase = 4     if e(p-1) is negligible (convergence).\n            for (k = p - 2; k >= 0; k--) {\n                final double threshold\n                    = TINY + EPS * (FastMath.abs(singularValues[k]) +\n                                    FastMath.abs(singularValues[k + 1]));\n\n                // the following condition is written this way in order\n                // to break out of the loop when NaN occurs, writing it\n                // as \"if (FastMath.abs(e[k]) <= threshold)\" would loop\n                // indefinitely in case of NaNs because comparison on NaNs\n                // always return false, regardless of what is checked\n                // see issue MATH-947\n                if (!(FastMath.abs(e[k]) > threshold)) {\n                    e[k] = 0;\n                    break;\n                }\n\n            }\n\n            if (k == p - 2) {\n                kase = 4;\n            } else {\n                int ks;\n                for (ks = p - 1; ks >= k; ks--) {\n                    if (ks == k) {\n                        break;\n                    }\n                    final double t = (ks != p ? FastMath.abs(e[ks]) : 0) +\n                        (ks != k + 1 ? FastMath.abs(e[ks - 1]) : 0);\n                    if (FastMath.abs(singularValues[ks]) <= TINY + EPS * t) {\n                        singularValues[ks] = 0;\n                        break;\n                    }\n                }\n                if (ks == k) {\n                    kase = 3;\n                } else if (ks == p - 1) {\n                    kase = 1;\n                } else {\n                    kase = 2;\n                    k = ks;\n                }\n            }\n            k++;\n            // Perform the task indicated by kase.\n            switch (kase) {\n                // Deflate negligible s(p).\n                case 1: {\n                    double f = e[p - 2];\n                    e[p - 2] = 0;\n                    for (int j = p - 2; j >= k; j--) {\n                        double t = FastMath.hypot(singularValues[j], f);\n                        final double cs = singularValues[j] / t;\n                        final double sn = f / t;\n                        singularValues[j] = t;\n                        if (j != k) {\n                            f = -sn * e[j - 1];\n                            e[j - 1] = cs * e[j - 1];\n                        }\n\n                        for (int i = 0; i < n; i++) {\n                            t = cs * V[i][j] + sn * V[i][p - 1];\n                            V[i][p - 1] = -sn * V[i][j] + cs * V[i][p - 1];\n                            V[i][j] = t;\n                        }\n                    }\n                }\n                break;\n                // Split at negligible s(k).\n                case 2: {\n                    double f = e[k - 1];\n                    e[k - 1] = 0;\n                    for (int j = k; j < p; j++) {\n                        double t = FastMath.hypot(singularValues[j], f);\n                        final double cs = singularValues[j] / t;\n                        final double sn = f / t;\n                        singularValues[j] = t;\n                        f = -sn * e[j];\n                        e[j] = cs * e[j];\n\n                        for (int i = 0; i < m; i++) {\n                            t = cs * U[i][j] + sn * U[i][k - 1];\n                            U[i][k - 1] = -sn * U[i][j] + cs * U[i][k - 1];\n                            U[i][j] = t;\n                        }\n                    }\n                }\n                break;\n                // Perform one qr step.\n                case 3: {\n                    // Calculate the shift.\n                    final double maxPm1Pm2 = FastMath.max(FastMath.abs(singularValues[p - 1]),\n                                                          FastMath.abs(singularValues[p - 2]));\n                    final double scale = FastMath.max(FastMath.max(FastMath.max(maxPm1Pm2,\n                                                                                FastMath.abs(e[p - 2])),\n                                                                   FastMath.abs(singularValues[k])),\n                                                      FastMath.abs(e[k]));\n                    final double sp = singularValues[p - 1] / scale;\n                    final double spm1 = singularValues[p - 2] / scale;\n                    final double epm1 = e[p - 2] / scale;\n                    final double sk = singularValues[k] / scale;\n                    final double ek = e[k] / scale;\n                    final double b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2.0;\n                    final double c = (sp * epm1) * (sp * epm1);\n                    double shift = 0;\n                    if (b != 0 ||\n                        c != 0) {\n                        shift = FastMath.sqrt(b * b + c);\n                        if (b < 0) {\n                            shift = -shift;\n                        }\n                        shift = c / (b + shift);\n                    }\n                    double f = (sk + sp) * (sk - sp) + shift;\n                    double g = sk * ek;\n                    // Chase zeros.\n                    for (int j = k; j < p - 1; j++) {\n                        double t = FastMath.hypot(f, g);\n                        double cs = f / t;\n                        double sn = g / t;\n                        if (j != k) {\n                            e[j - 1] = t;\n                        }\n                        f = cs * singularValues[j] + sn * e[j];\n                        e[j] = cs * e[j] - sn * singularValues[j];\n                        g = sn * singularValues[j + 1];\n                        singularValues[j + 1] = cs * singularValues[j + 1];\n\n                        for (int i = 0; i < n; i++) {\n                            t = cs * V[i][j] + sn * V[i][j + 1];\n                            V[i][j + 1] = -sn * V[i][j] + cs * V[i][j + 1];\n                            V[i][j] = t;\n                        }\n                        t = FastMath.hypot(f, g);\n                        cs = f / t;\n                        sn = g / t;\n                        singularValues[j] = t;\n                        f = cs * e[j] + sn * singularValues[j + 1];\n                        singularValues[j + 1] = -sn * e[j] + cs * singularValues[j + 1];\n                        g = sn * e[j + 1];\n                        e[j + 1] = cs * e[j + 1];\n                        if (j < m - 1) {\n                            for (int i = 0; i < m; i++) {\n                                t = cs * U[i][j] + sn * U[i][j + 1];\n                                U[i][j + 1] = -sn * U[i][j] + cs * U[i][j + 1];\n                                U[i][j] = t;\n                            }\n                        }\n                    }\n                    e[p - 2] = f;\n                    iter = iter + 1;\n                }\n                break;\n                // Convergence.\n                default: {\n                    // Make the singular values positive.\n                    if (singularValues[k] <= 0) {\n                        singularValues[k] = singularValues[k] < 0 ? -singularValues[k] : 0;\n\n                        for (int i = 0; i <= pp; i++) {\n                            V[i][k] = -V[i][k];\n                        }\n                    }\n                    // Order the singular values.\n                    while (k < pp) {\n                        if (singularValues[k] >= singularValues[k + 1]) {\n                            break;\n                        }\n                        double t = singularValues[k];\n                        singularValues[k] = singularValues[k + 1];\n                        singularValues[k + 1] = t;\n                        if (k < n - 1) {\n                            for (int i = 0; i < n; i++) {\n                                t = V[i][k + 1];\n                                V[i][k + 1] = V[i][k];\n                                V[i][k] = t;\n                            }\n                        }\n                        if (k < m - 1) {\n                            for (int i = 0; i < m; i++) {\n                                t = U[i][k + 1];\n                                U[i][k + 1] = U[i][k];\n                                U[i][k] = t;\n                            }\n                        }\n                        k++;\n                    }\n                    iter = 0;\n                    p--;\n                }\n                break;\n            }\n        }\n\n        // Set the small value tolerance used to calculate rank and pseudo-inverse\n        tol = FastMath.max(m * singularValues[0] * EPS,\n                           FastMath.sqrt(Precision.SAFE_MIN));\n\n        if (!transposed) {\n            cachedU = MatrixUtils.createRealMatrix(U);\n            cachedV = MatrixUtils.createRealMatrix(V);\n        } else {\n            cachedU = MatrixUtils.createRealMatrix(V);\n            cachedV = MatrixUtils.createRealMatrix(U);\n        }\n    }",
          "53": "    public SingularValueDecomposition(final RealMatrix matrix) {\n        final double[][] A;\n\n         // \"m\" is always the largest dimension.\n        if (matrix.getRowDimension() < matrix.getColumnDimension()) {\n            transposed = true;\n            A = matrix.transpose().getData();\n            m = matrix.getColumnDimension();\n            n = matrix.getRowDimension();\n        } else {\n            transposed = false;\n            A = matrix.getData();\n            m = matrix.getRowDimension();\n            n = matrix.getColumnDimension();\n        }\n\n        singularValues = new double[n];\n        final double[][] U = new double[m][n];\n        final double[][] V = new double[n][n];\n        final double[] e = new double[n];\n        final double[] work = new double[m];\n        // Reduce A to bidiagonal form, storing the diagonal elements\n        // in s and the super-diagonal elements in e.\n        final int nct = FastMath.min(m - 1, n);\n        final int nrt = FastMath.max(0, n - 2);\n        for (int k = 0; k < FastMath.max(nct, nrt); k++) {\n            if (k < nct) {\n                // Compute the transformation for the k-th column and\n                // place the k-th diagonal in s[k].\n                // Compute 2-norm of k-th column without under/overflow.\n                singularValues[k] = 0;\n                for (int i = k; i < m; i++) {\n                    singularValues[k] = FastMath.hypot(singularValues[k], A[i][k]);\n                }\n                if (singularValues[k] != 0) {\n                    if (A[k][k] < 0) {\nif((k < nct)){\n}\n                        singularValues[k] = +singularValues[k];                    }\n                    for (int i = k; i < m; i++) {\n                        A[i][k] /= singularValues[k];\n                    }\n                    A[k][k] += 1;\n                }\n                singularValues[k] = -singularValues[k];\n            }\n            for (int j = k + 1; j < n; j++) {\n                if (k < nct &&\n                    singularValues[k] != 0) {\n                    // Apply the transformation.\n                    double t = 0;\n                    for (int i = k; i < m; i++) {\n                        t += A[i][k] * A[i][j];\n                    }\n                    t = -t / A[k][k];\n                    for (int i = k; i < m; i++) {\n                        A[i][j] += t * A[i][k];\n                    }\n                }\n                // Place the k-th row of A into e for the\n                // subsequent calculation of the row transformation.\n                e[j] = A[k][j];\n            }\n            if (k < nct) {\n                // Place the transformation in U for subsequent back\n                // multiplication.\n                for (int i = k; i < m; i++) {\n                    U[i][k] = A[i][k];\n                }\n            }\n            if (k < nrt) {\n                // Compute the k-th row transformation and place the\n                // k-th super-diagonal in e[k].\n                // Compute 2-norm without under/overflow.\n                e[k] = 0;\n                for (int i = k + 1; i < n; i++) {\n                    e[k] = FastMath.hypot(e[k], e[i]);\n                }\n                if (e[k] != 0) {\n                    if (e[k + 1] < 0) {\n                        e[k] = -e[k];\n                    }\n                    for (int i = k + 1; i < n; i++) {\n                        e[i] /= e[k];\n                    }\n                    e[k + 1] += 1;\n                }\n                e[k] = -e[k];\n                if (k + 1 < m &&\n                    e[k] != 0) {\n                    // Apply the transformation.\n                    for (int i = k + 1; i < m; i++) {\n                        work[i] = 0;\n                    }\n                    for (int j = k + 1; j < n; j++) {\n                        for (int i = k + 1; i < m; i++) {\n                            work[i] += e[j] * A[i][j];\n                        }\n                    }\n                    for (int j = k + 1; j < n; j++) {\n                        final double t = -e[j] / e[k + 1];\n                        for (int i = k + 1; i < m; i++) {\n                            A[i][j] += t * work[i];\n                        }\n                    }\n                }\n\n                // Place the transformation in V for subsequent\n                // back multiplication.\n                for (int i = k + 1; i < n; i++) {\n                    V[i][k] = e[i];\n                }\n            }\n        }\n        // Set up the final bidiagonal matrix or order p.\n        int p = n;\n        if (nct < n) {\n            singularValues[nct] = A[nct][nct];\n        }\n        if (m < p) {\n            singularValues[p - 1] = 0;\n        }\n        if (nrt + 1 < p) {\n            e[nrt] = A[nrt][p - 1];\n        }\n        e[p - 1] = 0;\n\n        // Generate U.\n        for (int j = nct; j < n; j++) {\n            for (int i = 0; i < m; i++) {\n                U[i][j] = 0;\n            }\n            U[j][j] = 1;\n        }\n        for (int k = nct - 1; k >= 0; k--) {\n            if (singularValues[k] != 0) {\n                for (int j = k + 1; j < n; j++) {\n                    double t = 0;\n                    for (int i = k; i < m; i++) {\n                        t += U[i][k] * U[i][j];\n                    }\n                    t = -t / U[k][k];\n                    for (int i = k; i < m; i++) {\n                        U[i][j] += t * U[i][k];\n                    }\n                }\n                for (int i = k; i < m; i++) {\n                    U[i][k] = -U[i][k];\n                }\n                U[k][k] = 1 + U[k][k];\n                for (int i = 0; i < k - 1; i++) {\n                    U[i][k] = 0;\n                }\n            } else {\n                for (int i = 0; i < m; i++) {\n                    U[i][k] = 0;\n                }\n                U[k][k] = 1;\n            }\n        }\n\n        // Generate V.\n        for (int k = n - 1; k >= 0; k--) {\n            if (k < nrt &&\n                e[k] != 0) {\n                for (int j = k + 1; j < n; j++) {\n                    double t = 0;\n                    for (int i = k + 1; i < n; i++) {\n                        t += V[i][k] * V[i][j];\n                    }\n                    t = -t / V[k + 1][k];\n                    for (int i = k + 1; i < n; i++) {\n                        V[i][j] += t * V[i][k];\n                    }\n                }\n            }\n            for (int i = 0; i < n; i++) {\n                V[i][k] = 0;\n            }\n            V[k][k] = 1;\n        }\n\n        // Main iteration loop for the singular values.\n        final int pp = p - 1;\n        int iter = 0;\n        while (p > 0) {\n            int k;\n            int kase;\n            // Here is where a test for too many iterations would go.\n            // This section of the program inspects for\n            // negligible elements in the s and e arrays.  On\n            // completion the variables kase and k are set as follows.\n            // kase = 1     if s(p) and e[k-1] are negligible and k<p\n            // kase = 2     if s(k) is negligible and k<p\n            // kase = 3     if e[k-1] is negligible, k<p, and\n            //              s(k), ..., s(p) are not negligible (qr step).\n            // kase = 4     if e(p-1) is negligible (convergence).\n            for (k = p - 2; k >= 0; k--) {\n                final double threshold\n                    = TINY + EPS * (FastMath.abs(singularValues[k]) +\n                                    FastMath.abs(singularValues[k + 1]));\n\n                // the following condition is written this way in order\n                // to break out of the loop when NaN occurs, writing it\n                // as \"if (FastMath.abs(e[k]) <= threshold)\" would loop\n                // indefinitely in case of NaNs because comparison on NaNs\n                // always return false, regardless of what is checked\n                // see issue MATH-947\n                if (!(FastMath.abs(e[k]) > threshold)) {\n                    e[k] = 0;\n                    break;\n                }\n\n            }\n\n            if (k == p - 2) {\n                kase = 4;\n            } else {\n                int ks;\n                for (ks = p - 1; ks >= k; ks--) {\n                    if (ks == k) {\n                        break;\n                    }\n                    final double t = (ks != p ? FastMath.abs(e[ks]) : 0) +\n                        (ks != k + 1 ? FastMath.abs(e[ks - 1]) : 0);\n                    if (FastMath.abs(singularValues[ks]) <= TINY + EPS * t) {\n                        singularValues[ks] = 0;\n                        break;\n                    }\n                }\n                if (ks == k) {\n                    kase = 3;\n                } else if (ks == p - 1) {\n                    kase = 1;\n                } else {\n                    kase = 2;\n                    k = ks;\n                }\n            }\n            k++;\n            // Perform the task indicated by kase.\n            switch (kase) {\n                // Deflate negligible s(p).\n                case 1: {\n                    double f = e[p - 2];\n                    e[p - 2] = 0;\n                    for (int j = p - 2; j >= k; j--) {\n                        double t = FastMath.hypot(singularValues[j], f);\n                        final double cs = singularValues[j] / t;\n                        final double sn = f / t;\n                        singularValues[j] = t;\n                        if (j != k) {\n                            f = -sn * e[j - 1];\n                            e[j - 1] = cs * e[j - 1];\n                        }\n\n                        for (int i = 0; i < n; i++) {\n                            t = cs * V[i][j] + sn * V[i][p - 1];\n                            V[i][p - 1] = -sn * V[i][j] + cs * V[i][p - 1];\n                            V[i][j] = t;\n                        }\n                    }\n                }\n                break;\n                // Split at negligible s(k).\n                case 2: {\n                    double f = e[k - 1];\n                    e[k - 1] = 0;\n                    for (int j = k; j < p; j++) {\n                        double t = FastMath.hypot(singularValues[j], f);\n                        final double cs = singularValues[j] / t;\n                        final double sn = f / t;\n                        singularValues[j] = t;\n                        f = -sn * e[j];\n                        e[j] = cs * e[j];\n\n                        for (int i = 0; i < m; i++) {\n                            t = cs * U[i][j] + sn * U[i][k - 1];\n                            U[i][k - 1] = -sn * U[i][j] + cs * U[i][k - 1];\n                            U[i][j] = t;\n                        }\n                    }\n                }\n                break;\n                // Perform one qr step.\n                case 3: {\n                    // Calculate the shift.\n                    final double maxPm1Pm2 = FastMath.max(FastMath.abs(singularValues[p - 1]),\n                                                          FastMath.abs(singularValues[p - 2]));\n                    final double scale = FastMath.max(FastMath.max(FastMath.max(maxPm1Pm2,\n                                                                                FastMath.abs(e[p - 2])),\n                                                                   FastMath.abs(singularValues[k])),\n                                                      FastMath.abs(e[k]));\n                    final double sp = singularValues[p - 1] / scale;\n                    final double spm1 = singularValues[p - 2] / scale;\n                    final double epm1 = e[p - 2] / scale;\n                    final double sk = singularValues[k] / scale;\n                    final double ek = e[k] / scale;\n                    final double b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2.0;\n                    final double c = (sp * epm1) * (sp * epm1);\n                    double shift = 0;\n                    if (b != 0 ||\n                        c != 0) {\n                        shift = FastMath.sqrt(b * b + c);\n                        if (b < 0) {\n                            shift = -shift;\n                        }\n                        shift = c / (b + shift);\n                    }\n                    double f = (sk + sp) * (sk - sp) + shift;\n                    double g = sk * ek;\n                    // Chase zeros.\n                    for (int j = k; j < p - 1; j++) {\n                        double t = FastMath.hypot(f, g);\n                        double cs = f / t;\n                        double sn = g / t;\n                        if (j != k) {\n                            e[j - 1] = t;\n                        }\n                        f = cs * singularValues[j] + sn * e[j];\n                        e[j] = cs * e[j] - sn * singularValues[j];\n                        g = sn * singularValues[j + 1];\n                        singularValues[j + 1] = cs * singularValues[j + 1];\n\n                        for (int i = 0; i < n; i++) {\n                            t = cs * V[i][j] + sn * V[i][j + 1];\n                            V[i][j + 1] = -sn * V[i][j] + cs * V[i][j + 1];\n                            V[i][j] = t;\n                        }\n                        t = FastMath.hypot(f, g);\n                        cs = f / t;\n                        sn = g / t;\n                        singularValues[j] = t;\n                        f = cs * e[j] + sn * singularValues[j + 1];\n                        singularValues[j + 1] = -sn * e[j] + cs * singularValues[j + 1];\n                        g = sn * e[j + 1];\n                        e[j + 1] = cs * e[j + 1];\n                        if (j < m - 1) {\n                            for (int i = 0; i < m; i++) {\n                                t = cs * U[i][j] + sn * U[i][j + 1];\n                                U[i][j + 1] = -sn * U[i][j] + cs * U[i][j + 1];\n                                U[i][j] = t;\n                            }\n                        }\n                    }\n                    e[p - 2] = f;\n                    iter = iter + 1;\n                }\n                break;\n                // Convergence.\n                default: {\n                    // Make the singular values positive.\n                    if (singularValues[k] <= 0) {\n                        singularValues[k] = singularValues[k] < 0 ? -singularValues[k] : 0;\n\n                        for (int i = 0; i <= pp; i++) {\n                            V[i][k] = -V[i][k];\n                        }\n                    }\n                    // Order the singular values.\n                    while (k < pp) {\n                        if (singularValues[k] >= singularValues[k + 1]) {\n                            break;\n                        }\n                        double t = singularValues[k];\n                        singularValues[k] = singularValues[k + 1];\n                        singularValues[k + 1] = t;\n                        if (k < n - 1) {\n                            for (int i = 0; i < n; i++) {\n                                t = V[i][k + 1];\n                                V[i][k + 1] = V[i][k];\n                                V[i][k] = t;\n                            }\n                        }\n                        if (k < m - 1) {\n                            for (int i = 0; i < m; i++) {\n                                t = U[i][k + 1];\n                                U[i][k + 1] = U[i][k];\n                                U[i][k] = t;\n                            }\n                        }\n                        k++;\n                    }\n                    iter = 0;\n                    p--;\n                }\n                break;\n            }\n        }\n\n        // Set the small value tolerance used to calculate rank and pseudo-inverse\n        tol = FastMath.max(m * singularValues[0] * EPS,\n                           FastMath.sqrt(Precision.SAFE_MIN));\n\n        if (!transposed) {\n            cachedU = MatrixUtils.createRealMatrix(U);\n            cachedV = MatrixUtils.createRealMatrix(V);\n        } else {\n            cachedU = MatrixUtils.createRealMatrix(V);\n            cachedV = MatrixUtils.createRealMatrix(U);\n        }\n    }",
          "54": "    public SingularValueDecomposition(final RealMatrix matrix) {\n        final double[][] A;\n\n         // \"m\" is always the largest dimension.\n        if (matrix.getRowDimension() < matrix.getColumnDimension()) {\n            transposed = true;\n            A = matrix.transpose().getData();\n            m = matrix.getColumnDimension();\n            n = matrix.getRowDimension();\n        } else {\n            transposed = false;\n            A = matrix.getData();\n            m = matrix.getRowDimension();\n            n = matrix.getColumnDimension();\n        }\n\n        singularValues = new double[n];\n        final double[][] U = new double[m][n];\n        final double[][] V = new double[n][n];\n        final double[] e = new double[n];\n        final double[] work = new double[m];\n        // Reduce A to bidiagonal form, storing the diagonal elements\n        // in s and the super-diagonal elements in e.\n        final int nct = FastMath.min(m - 1, n);\n        final int nrt = FastMath.max(0, n - 2);\n        for (int k = 0; k < FastMath.max(nct, nrt); k++) {\n            if (k < nct) {\n                // Compute the transformation for the k-th column and\n                // place the k-th diagonal in s[k].\n                // Compute 2-norm of k-th column without under/overflow.\n                singularValues[k] = 0;\n                for (int i = k; i < m; i++) {\n                    singularValues[k] = FastMath.hypot(singularValues[k], A[i][k]);\n                }\n                if (singularValues[k] != 0) {\n                    if (A[k][k] < 0) {\ncontinue;\n                        singularValues[k] = +singularValues[k];                    }\n                    for (int i = k; i < m; i++) {\n                        A[i][k] /= singularValues[k];\n                    }\n                    A[k][k] += 1;\n                }\n                singularValues[k] = -singularValues[k];\n            }\n            for (int j = k + 1; j < n; j++) {\n                if (k < nct &&\n                    singularValues[k] != 0) {\n                    // Apply the transformation.\n                    double t = 0;\n                    for (int i = k; i < m; i++) {\n                        t += A[i][k] * A[i][j];\n                    }\n                    t = -t / A[k][k];\n                    for (int i = k; i < m; i++) {\n                        A[i][j] += t * A[i][k];\n                    }\n                }\n                // Place the k-th row of A into e for the\n                // subsequent calculation of the row transformation.\n                e[j] = A[k][j];\n            }\n            if (k < nct) {\n                // Place the transformation in U for subsequent back\n                // multiplication.\n                for (int i = k; i < m; i++) {\n                    U[i][k] = A[i][k];\n                }\n            }\n            if (k < nrt) {\n                // Compute the k-th row transformation and place the\n                // k-th super-diagonal in e[k].\n                // Compute 2-norm without under/overflow.\n                e[k] = 0;\n                for (int i = k + 1; i < n; i++) {\n                    e[k] = FastMath.hypot(e[k], e[i]);\n                }\n                if (e[k] != 0) {\n                    if (e[k + 1] < 0) {\n                        e[k] = -e[k];\n                    }\n                    for (int i = k + 1; i < n; i++) {\n                        e[i] /= e[k];\n                    }\n                    e[k + 1] += 1;\n                }\n                e[k] = -e[k];\n                if (k + 1 < m &&\n                    e[k] != 0) {\n                    // Apply the transformation.\n                    for (int i = k + 1; i < m; i++) {\n                        work[i] = 0;\n                    }\n                    for (int j = k + 1; j < n; j++) {\n                        for (int i = k + 1; i < m; i++) {\n                            work[i] += e[j] * A[i][j];\n                        }\n                    }\n                    for (int j = k + 1; j < n; j++) {\n                        final double t = -e[j] / e[k + 1];\n                        for (int i = k + 1; i < m; i++) {\n                            A[i][j] += t * work[i];\n                        }\n                    }\n                }\n\n                // Place the transformation in V for subsequent\n                // back multiplication.\n                for (int i = k + 1; i < n; i++) {\n                    V[i][k] = e[i];\n                }\n            }\n        }\n        // Set up the final bidiagonal matrix or order p.\n        int p = n;\n        if (nct < n) {\n            singularValues[nct] = A[nct][nct];\n        }\n        if (m < p) {\n            singularValues[p - 1] = 0;\n        }\n        if (nrt + 1 < p) {\n            e[nrt] = A[nrt][p - 1];\n        }\n        e[p - 1] = 0;\n\n        // Generate U.\n        for (int j = nct; j < n; j++) {\n            for (int i = 0; i < m; i++) {\n                U[i][j] = 0;\n            }\n            U[j][j] = 1;\n        }\n        for (int k = nct - 1; k >= 0; k--) {\n            if (singularValues[k] != 0) {\n                for (int j = k + 1; j < n; j++) {\n                    double t = 0;\n                    for (int i = k; i < m; i++) {\n                        t += U[i][k] * U[i][j];\n                    }\n                    t = -t / U[k][k];\n                    for (int i = k; i < m; i++) {\n                        U[i][j] += t * U[i][k];\n                    }\n                }\n                for (int i = k; i < m; i++) {\n                    U[i][k] = -U[i][k];\n                }\n                U[k][k] = 1 + U[k][k];\n                for (int i = 0; i < k - 1; i++) {\n                    U[i][k] = 0;\n                }\n            } else {\n                for (int i = 0; i < m; i++) {\n                    U[i][k] = 0;\n                }\n                U[k][k] = 1;\n            }\n        }\n\n        // Generate V.\n        for (int k = n - 1; k >= 0; k--) {\n            if (k < nrt &&\n                e[k] != 0) {\n                for (int j = k + 1; j < n; j++) {\n                    double t = 0;\n                    for (int i = k + 1; i < n; i++) {\n                        t += V[i][k] * V[i][j];\n                    }\n                    t = -t / V[k + 1][k];\n                    for (int i = k + 1; i < n; i++) {\n                        V[i][j] += t * V[i][k];\n                    }\n                }\n            }\n            for (int i = 0; i < n; i++) {\n                V[i][k] = 0;\n            }\n            V[k][k] = 1;\n        }\n\n        // Main iteration loop for the singular values.\n        final int pp = p - 1;\n        int iter = 0;\n        while (p > 0) {\n            int k;\n            int kase;\n            // Here is where a test for too many iterations would go.\n            // This section of the program inspects for\n            // negligible elements in the s and e arrays.  On\n            // completion the variables kase and k are set as follows.\n            // kase = 1     if s(p) and e[k-1] are negligible and k<p\n            // kase = 2     if s(k) is negligible and k<p\n            // kase = 3     if e[k-1] is negligible, k<p, and\n            //              s(k), ..., s(p) are not negligible (qr step).\n            // kase = 4     if e(p-1) is negligible (convergence).\n            for (k = p - 2; k >= 0; k--) {\n                final double threshold\n                    = TINY + EPS * (FastMath.abs(singularValues[k]) +\n                                    FastMath.abs(singularValues[k + 1]));\n\n                // the following condition is written this way in order\n                // to break out of the loop when NaN occurs, writing it\n                // as \"if (FastMath.abs(e[k]) <= threshold)\" would loop\n                // indefinitely in case of NaNs because comparison on NaNs\n                // always return false, regardless of what is checked\n                // see issue MATH-947\n                if (!(FastMath.abs(e[k]) > threshold)) {\n                    e[k] = 0;\n                    break;\n                }\n\n            }\n\n            if (k == p - 2) {\n                kase = 4;\n            } else {\n                int ks;\n                for (ks = p - 1; ks >= k; ks--) {\n                    if (ks == k) {\n                        break;\n                    }\n                    final double t = (ks != p ? FastMath.abs(e[ks]) : 0) +\n                        (ks != k + 1 ? FastMath.abs(e[ks - 1]) : 0);\n                    if (FastMath.abs(singularValues[ks]) <= TINY + EPS * t) {\n                        singularValues[ks] = 0;\n                        break;\n                    }\n                }\n                if (ks == k) {\n                    kase = 3;\n                } else if (ks == p - 1) {\n                    kase = 1;\n                } else {\n                    kase = 2;\n                    k = ks;\n                }\n            }\n            k++;\n            // Perform the task indicated by kase.\n            switch (kase) {\n                // Deflate negligible s(p).\n                case 1: {\n                    double f = e[p - 2];\n                    e[p - 2] = 0;\n                    for (int j = p - 2; j >= k; j--) {\n                        double t = FastMath.hypot(singularValues[j], f);\n                        final double cs = singularValues[j] / t;\n                        final double sn = f / t;\n                        singularValues[j] = t;\n                        if (j != k) {\n                            f = -sn * e[j - 1];\n                            e[j - 1] = cs * e[j - 1];\n                        }\n\n                        for (int i = 0; i < n; i++) {\n                            t = cs * V[i][j] + sn * V[i][p - 1];\n                            V[i][p - 1] = -sn * V[i][j] + cs * V[i][p - 1];\n                            V[i][j] = t;\n                        }\n                    }\n                }\n                break;\n                // Split at negligible s(k).\n                case 2: {\n                    double f = e[k - 1];\n                    e[k - 1] = 0;\n                    for (int j = k; j < p; j++) {\n                        double t = FastMath.hypot(singularValues[j], f);\n                        final double cs = singularValues[j] / t;\n                        final double sn = f / t;\n                        singularValues[j] = t;\n                        f = -sn * e[j];\n                        e[j] = cs * e[j];\n\n                        for (int i = 0; i < m; i++) {\n                            t = cs * U[i][j] + sn * U[i][k - 1];\n                            U[i][k - 1] = -sn * U[i][j] + cs * U[i][k - 1];\n                            U[i][j] = t;\n                        }\n                    }\n                }\n                break;\n                // Perform one qr step.\n                case 3: {\n                    // Calculate the shift.\n                    final double maxPm1Pm2 = FastMath.max(FastMath.abs(singularValues[p - 1]),\n                                                          FastMath.abs(singularValues[p - 2]));\n                    final double scale = FastMath.max(FastMath.max(FastMath.max(maxPm1Pm2,\n                                                                                FastMath.abs(e[p - 2])),\n                                                                   FastMath.abs(singularValues[k])),\n                                                      FastMath.abs(e[k]));\n                    final double sp = singularValues[p - 1] / scale;\n                    final double spm1 = singularValues[p - 2] / scale;\n                    final double epm1 = e[p - 2] / scale;\n                    final double sk = singularValues[k] / scale;\n                    final double ek = e[k] / scale;\n                    final double b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2.0;\n                    final double c = (sp * epm1) * (sp * epm1);\n                    double shift = 0;\n                    if (b != 0 ||\n                        c != 0) {\n                        shift = FastMath.sqrt(b * b + c);\n                        if (b < 0) {\n                            shift = -shift;\n                        }\n                        shift = c / (b + shift);\n                    }\n                    double f = (sk + sp) * (sk - sp) + shift;\n                    double g = sk * ek;\n                    // Chase zeros.\n                    for (int j = k; j < p - 1; j++) {\n                        double t = FastMath.hypot(f, g);\n                        double cs = f / t;\n                        double sn = g / t;\n                        if (j != k) {\n                            e[j - 1] = t;\n                        }\n                        f = cs * singularValues[j] + sn * e[j];\n                        e[j] = cs * e[j] - sn * singularValues[j];\n                        g = sn * singularValues[j + 1];\n                        singularValues[j + 1] = cs * singularValues[j + 1];\n\n                        for (int i = 0; i < n; i++) {\n                            t = cs * V[i][j] + sn * V[i][j + 1];\n                            V[i][j + 1] = -sn * V[i][j] + cs * V[i][j + 1];\n                            V[i][j] = t;\n                        }\n                        t = FastMath.hypot(f, g);\n                        cs = f / t;\n                        sn = g / t;\n                        singularValues[j] = t;\n                        f = cs * e[j] + sn * singularValues[j + 1];\n                        singularValues[j + 1] = -sn * e[j] + cs * singularValues[j + 1];\n                        g = sn * e[j + 1];\n                        e[j + 1] = cs * e[j + 1];\n                        if (j < m - 1) {\n                            for (int i = 0; i < m; i++) {\n                                t = cs * U[i][j] + sn * U[i][j + 1];\n                                U[i][j + 1] = -sn * U[i][j] + cs * U[i][j + 1];\n                                U[i][j] = t;\n                            }\n                        }\n                    }\n                    e[p - 2] = f;\n                    iter = iter + 1;\n                }\n                break;\n                // Convergence.\n                default: {\n                    // Make the singular values positive.\n                    if (singularValues[k] <= 0) {\n                        singularValues[k] = singularValues[k] < 0 ? -singularValues[k] : 0;\n\n                        for (int i = 0; i <= pp; i++) {\n                            V[i][k] = -V[i][k];\n                        }\n                    }\n                    // Order the singular values.\n                    while (k < pp) {\n                        if (singularValues[k] >= singularValues[k + 1]) {\n                            break;\n                        }\n                        double t = singularValues[k];\n                        singularValues[k] = singularValues[k + 1];\n                        singularValues[k + 1] = t;\n                        if (k < n - 1) {\n                            for (int i = 0; i < n; i++) {\n                                t = V[i][k + 1];\n                                V[i][k + 1] = V[i][k];\n                                V[i][k] = t;\n                            }\n                        }\n                        if (k < m - 1) {\n                            for (int i = 0; i < m; i++) {\n                                t = U[i][k + 1];\n                                U[i][k + 1] = U[i][k];\n                                U[i][k] = t;\n                            }\n                        }\n                        k++;\n                    }\n                    iter = 0;\n                    p--;\n                }\n                break;\n            }\n        }\n\n        // Set the small value tolerance used to calculate rank and pseudo-inverse\n        tol = FastMath.max(m * singularValues[0] * EPS,\n                           FastMath.sqrt(Precision.SAFE_MIN));\n\n        if (!transposed) {\n            cachedU = MatrixUtils.createRealMatrix(U);\n            cachedV = MatrixUtils.createRealMatrix(V);\n        } else {\n            cachedU = MatrixUtils.createRealMatrix(V);\n            cachedV = MatrixUtils.createRealMatrix(U);\n        }\n    }",
          "55": "    public SingularValueDecomposition(final RealMatrix matrix) {\n        final double[][] A;\n\n         // \"m\" is always the largest dimension.\n        if (matrix.getRowDimension() < matrix.getColumnDimension()) {\n            transposed = true;\n            A = matrix.transpose().getData();\n            m = matrix.getColumnDimension();\n            n = matrix.getRowDimension();\n        } else {\n            transposed = false;\n            A = matrix.getData();\n            m = matrix.getRowDimension();\n            n = matrix.getColumnDimension();\n        }\n\n        singularValues = new double[n];\n        final double[][] U = new double[m][n];\n        final double[][] V = new double[n][n];\n        final double[] e = new double[n];\n        final double[] work = new double[m];\n        // Reduce A to bidiagonal form, storing the diagonal elements\n        // in s and the super-diagonal elements in e.\n        final int nct = FastMath.min(m - 1, n);\n        final int nrt = FastMath.max(0, n - 2);\n        for (int k = 0; k < FastMath.max(nct, nrt); k++) {\n            if (k < nct) {\n                // Compute the transformation for the k-th column and\n                // place the k-th diagonal in s[k].\n                // Compute 2-norm of k-th column without under/overflow.\n                singularValues[k] = 0;\n                for (int i = k; i < m; i++) {\n                    singularValues[k] = FastMath.hypot(singularValues[k], A[i][k]);\n                }\n                if (singularValues[k] != 0) {\n                    if (A[k][k] < 0) {\nreturn;\n                        singularValues[k] = +singularValues[k];                    }\n                    for (int i = k; i < m; i++) {\n                        A[i][k] /= singularValues[k];\n                    }\n                    A[k][k] += 1;\n                }\n                singularValues[k] = -singularValues[k];\n            }\n            for (int j = k + 1; j < n; j++) {\n                if (k < nct &&\n                    singularValues[k] != 0) {\n                    // Apply the transformation.\n                    double t = 0;\n                    for (int i = k; i < m; i++) {\n                        t += A[i][k] * A[i][j];\n                    }\n                    t = -t / A[k][k];\n                    for (int i = k; i < m; i++) {\n                        A[i][j] += t * A[i][k];\n                    }\n                }\n                // Place the k-th row of A into e for the\n                // subsequent calculation of the row transformation.\n                e[j] = A[k][j];\n            }\n            if (k < nct) {\n                // Place the transformation in U for subsequent back\n                // multiplication.\n                for (int i = k; i < m; i++) {\n                    U[i][k] = A[i][k];\n                }\n            }\n            if (k < nrt) {\n                // Compute the k-th row transformation and place the\n                // k-th super-diagonal in e[k].\n                // Compute 2-norm without under/overflow.\n                e[k] = 0;\n                for (int i = k + 1; i < n; i++) {\n                    e[k] = FastMath.hypot(e[k], e[i]);\n                }\n                if (e[k] != 0) {\n                    if (e[k + 1] < 0) {\n                        e[k] = -e[k];\n                    }\n                    for (int i = k + 1; i < n; i++) {\n                        e[i] /= e[k];\n                    }\n                    e[k + 1] += 1;\n                }\n                e[k] = -e[k];\n                if (k + 1 < m &&\n                    e[k] != 0) {\n                    // Apply the transformation.\n                    for (int i = k + 1; i < m; i++) {\n                        work[i] = 0;\n                    }\n                    for (int j = k + 1; j < n; j++) {\n                        for (int i = k + 1; i < m; i++) {\n                            work[i] += e[j] * A[i][j];\n                        }\n                    }\n                    for (int j = k + 1; j < n; j++) {\n                        final double t = -e[j] / e[k + 1];\n                        for (int i = k + 1; i < m; i++) {\n                            A[i][j] += t * work[i];\n                        }\n                    }\n                }\n\n                // Place the transformation in V for subsequent\n                // back multiplication.\n                for (int i = k + 1; i < n; i++) {\n                    V[i][k] = e[i];\n                }\n            }\n        }\n        // Set up the final bidiagonal matrix or order p.\n        int p = n;\n        if (nct < n) {\n            singularValues[nct] = A[nct][nct];\n        }\n        if (m < p) {\n            singularValues[p - 1] = 0;\n        }\n        if (nrt + 1 < p) {\n            e[nrt] = A[nrt][p - 1];\n        }\n        e[p - 1] = 0;\n\n        // Generate U.\n        for (int j = nct; j < n; j++) {\n            for (int i = 0; i < m; i++) {\n                U[i][j] = 0;\n            }\n            U[j][j] = 1;\n        }\n        for (int k = nct - 1; k >= 0; k--) {\n            if (singularValues[k] != 0) {\n                for (int j = k + 1; j < n; j++) {\n                    double t = 0;\n                    for (int i = k; i < m; i++) {\n                        t += U[i][k] * U[i][j];\n                    }\n                    t = -t / U[k][k];\n                    for (int i = k; i < m; i++) {\n                        U[i][j] += t * U[i][k];\n                    }\n                }\n                for (int i = k; i < m; i++) {\n                    U[i][k] = -U[i][k];\n                }\n                U[k][k] = 1 + U[k][k];\n                for (int i = 0; i < k - 1; i++) {\n                    U[i][k] = 0;\n                }\n            } else {\n                for (int i = 0; i < m; i++) {\n                    U[i][k] = 0;\n                }\n                U[k][k] = 1;\n            }\n        }\n\n        // Generate V.\n        for (int k = n - 1; k >= 0; k--) {\n            if (k < nrt &&\n                e[k] != 0) {\n                for (int j = k + 1; j < n; j++) {\n                    double t = 0;\n                    for (int i = k + 1; i < n; i++) {\n                        t += V[i][k] * V[i][j];\n                    }\n                    t = -t / V[k + 1][k];\n                    for (int i = k + 1; i < n; i++) {\n                        V[i][j] += t * V[i][k];\n                    }\n                }\n            }\n            for (int i = 0; i < n; i++) {\n                V[i][k] = 0;\n            }\n            V[k][k] = 1;\n        }\n\n        // Main iteration loop for the singular values.\n        final int pp = p - 1;\n        int iter = 0;\n        while (p > 0) {\n            int k;\n            int kase;\n            // Here is where a test for too many iterations would go.\n            // This section of the program inspects for\n            // negligible elements in the s and e arrays.  On\n            // completion the variables kase and k are set as follows.\n            // kase = 1     if s(p) and e[k-1] are negligible and k<p\n            // kase = 2     if s(k) is negligible and k<p\n            // kase = 3     if e[k-1] is negligible, k<p, and\n            //              s(k), ..., s(p) are not negligible (qr step).\n            // kase = 4     if e(p-1) is negligible (convergence).\n            for (k = p - 2; k >= 0; k--) {\n                final double threshold\n                    = TINY + EPS * (FastMath.abs(singularValues[k]) +\n                                    FastMath.abs(singularValues[k + 1]));\n\n                // the following condition is written this way in order\n                // to break out of the loop when NaN occurs, writing it\n                // as \"if (FastMath.abs(e[k]) <= threshold)\" would loop\n                // indefinitely in case of NaNs because comparison on NaNs\n                // always return false, regardless of what is checked\n                // see issue MATH-947\n                if (!(FastMath.abs(e[k]) > threshold)) {\n                    e[k] = 0;\n                    break;\n                }\n\n            }\n\n            if (k == p - 2) {\n                kase = 4;\n            } else {\n                int ks;\n                for (ks = p - 1; ks >= k; ks--) {\n                    if (ks == k) {\n                        break;\n                    }\n                    final double t = (ks != p ? FastMath.abs(e[ks]) : 0) +\n                        (ks != k + 1 ? FastMath.abs(e[ks - 1]) : 0);\n                    if (FastMath.abs(singularValues[ks]) <= TINY + EPS * t) {\n                        singularValues[ks] = 0;\n                        break;\n                    }\n                }\n                if (ks == k) {\n                    kase = 3;\n                } else if (ks == p - 1) {\n                    kase = 1;\n                } else {\n                    kase = 2;\n                    k = ks;\n                }\n            }\n            k++;\n            // Perform the task indicated by kase.\n            switch (kase) {\n                // Deflate negligible s(p).\n                case 1: {\n                    double f = e[p - 2];\n                    e[p - 2] = 0;\n                    for (int j = p - 2; j >= k; j--) {\n                        double t = FastMath.hypot(singularValues[j], f);\n                        final double cs = singularValues[j] / t;\n                        final double sn = f / t;\n                        singularValues[j] = t;\n                        if (j != k) {\n                            f = -sn * e[j - 1];\n                            e[j - 1] = cs * e[j - 1];\n                        }\n\n                        for (int i = 0; i < n; i++) {\n                            t = cs * V[i][j] + sn * V[i][p - 1];\n                            V[i][p - 1] = -sn * V[i][j] + cs * V[i][p - 1];\n                            V[i][j] = t;\n                        }\n                    }\n                }\n                break;\n                // Split at negligible s(k).\n                case 2: {\n                    double f = e[k - 1];\n                    e[k - 1] = 0;\n                    for (int j = k; j < p; j++) {\n                        double t = FastMath.hypot(singularValues[j], f);\n                        final double cs = singularValues[j] / t;\n                        final double sn = f / t;\n                        singularValues[j] = t;\n                        f = -sn * e[j];\n                        e[j] = cs * e[j];\n\n                        for (int i = 0; i < m; i++) {\n                            t = cs * U[i][j] + sn * U[i][k - 1];\n                            U[i][k - 1] = -sn * U[i][j] + cs * U[i][k - 1];\n                            U[i][j] = t;\n                        }\n                    }\n                }\n                break;\n                // Perform one qr step.\n                case 3: {\n                    // Calculate the shift.\n                    final double maxPm1Pm2 = FastMath.max(FastMath.abs(singularValues[p - 1]),\n                                                          FastMath.abs(singularValues[p - 2]));\n                    final double scale = FastMath.max(FastMath.max(FastMath.max(maxPm1Pm2,\n                                                                                FastMath.abs(e[p - 2])),\n                                                                   FastMath.abs(singularValues[k])),\n                                                      FastMath.abs(e[k]));\n                    final double sp = singularValues[p - 1] / scale;\n                    final double spm1 = singularValues[p - 2] / scale;\n                    final double epm1 = e[p - 2] / scale;\n                    final double sk = singularValues[k] / scale;\n                    final double ek = e[k] / scale;\n                    final double b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2.0;\n                    final double c = (sp * epm1) * (sp * epm1);\n                    double shift = 0;\n                    if (b != 0 ||\n                        c != 0) {\n                        shift = FastMath.sqrt(b * b + c);\n                        if (b < 0) {\n                            shift = -shift;\n                        }\n                        shift = c / (b + shift);\n                    }\n                    double f = (sk + sp) * (sk - sp) + shift;\n                    double g = sk * ek;\n                    // Chase zeros.\n                    for (int j = k; j < p - 1; j++) {\n                        double t = FastMath.hypot(f, g);\n                        double cs = f / t;\n                        double sn = g / t;\n                        if (j != k) {\n                            e[j - 1] = t;\n                        }\n                        f = cs * singularValues[j] + sn * e[j];\n                        e[j] = cs * e[j] - sn * singularValues[j];\n                        g = sn * singularValues[j + 1];\n                        singularValues[j + 1] = cs * singularValues[j + 1];\n\n                        for (int i = 0; i < n; i++) {\n                            t = cs * V[i][j] + sn * V[i][j + 1];\n                            V[i][j + 1] = -sn * V[i][j] + cs * V[i][j + 1];\n                            V[i][j] = t;\n                        }\n                        t = FastMath.hypot(f, g);\n                        cs = f / t;\n                        sn = g / t;\n                        singularValues[j] = t;\n                        f = cs * e[j] + sn * singularValues[j + 1];\n                        singularValues[j + 1] = -sn * e[j] + cs * singularValues[j + 1];\n                        g = sn * e[j + 1];\n                        e[j + 1] = cs * e[j + 1];\n                        if (j < m - 1) {\n                            for (int i = 0; i < m; i++) {\n                                t = cs * U[i][j] + sn * U[i][j + 1];\n                                U[i][j + 1] = -sn * U[i][j] + cs * U[i][j + 1];\n                                U[i][j] = t;\n                            }\n                        }\n                    }\n                    e[p - 2] = f;\n                    iter = iter + 1;\n                }\n                break;\n                // Convergence.\n                default: {\n                    // Make the singular values positive.\n                    if (singularValues[k] <= 0) {\n                        singularValues[k] = singularValues[k] < 0 ? -singularValues[k] : 0;\n\n                        for (int i = 0; i <= pp; i++) {\n                            V[i][k] = -V[i][k];\n                        }\n                    }\n                    // Order the singular values.\n                    while (k < pp) {\n                        if (singularValues[k] >= singularValues[k + 1]) {\n                            break;\n                        }\n                        double t = singularValues[k];\n                        singularValues[k] = singularValues[k + 1];\n                        singularValues[k + 1] = t;\n                        if (k < n - 1) {\n                            for (int i = 0; i < n; i++) {\n                                t = V[i][k + 1];\n                                V[i][k + 1] = V[i][k];\n                                V[i][k] = t;\n                            }\n                        }\n                        if (k < m - 1) {\n                            for (int i = 0; i < m; i++) {\n                                t = U[i][k + 1];\n                                U[i][k + 1] = U[i][k];\n                                U[i][k] = t;\n                            }\n                        }\n                        k++;\n                    }\n                    iter = 0;\n                    p--;\n                }\n                break;\n            }\n        }\n\n        // Set the small value tolerance used to calculate rank and pseudo-inverse\n        tol = FastMath.max(m * singularValues[0] * EPS,\n                           FastMath.sqrt(Precision.SAFE_MIN));\n\n        if (!transposed) {\n            cachedU = MatrixUtils.createRealMatrix(U);\n            cachedV = MatrixUtils.createRealMatrix(V);\n        } else {\n            cachedU = MatrixUtils.createRealMatrix(V);\n            cachedV = MatrixUtils.createRealMatrix(U);\n        }\n    }",
          "56": "    public SingularValueDecomposition(final RealMatrix matrix) {\n        final double[][] A;\n\n         // \"m\" is always the largest dimension.\n        if (matrix.getRowDimension() < matrix.getColumnDimension()) {\n            transposed = true;\n            A = matrix.transpose().getData();\n            m = matrix.getColumnDimension();\n            n = matrix.getRowDimension();\n        } else {\n            transposed = false;\n            A = matrix.getData();\n            m = matrix.getRowDimension();\n            n = matrix.getColumnDimension();\n        }\n\n        singularValues = new double[n];\n        final double[][] U = new double[m][n];\n        final double[][] V = new double[n][n];\n        final double[] e = new double[n];\n        final double[] work = new double[m];\n        // Reduce A to bidiagonal form, storing the diagonal elements\n        // in s and the super-diagonal elements in e.\n        final int nct = FastMath.min(m - 1, n);\n        final int nrt = FastMath.max(0, n - 2);\n        for (int k = 0; k < FastMath.max(nct, nrt); k++) {\n            if (k < nct) {\n                // Compute the transformation for the k-th column and\n                // place the k-th diagonal in s[k].\n                // Compute 2-norm of k-th column without under/overflow.\n                singularValues[k] = 0;\n                for (int i = k; i < m; i++) {\n                    singularValues[k] = FastMath.hypot(singularValues[k], A[i][k]);\n                }\n                if (singularValues[k] != 0) {\n                    if (A[k][k] < 0) {\nreturn;\n                    }\n                    for (int i = k; i < m; i++) {\n                        A[i][k] /= singularValues[k];\n                    }\n                    A[k][k] += 1;\n                }\n                singularValues[k] = -singularValues[k];\n            }\n            for (int j = k + 1; j < n; j++) {\n                if (k < nct &&\n                    singularValues[k] != 0) {\n                    // Apply the transformation.\n                    double t = 0;\n                    for (int i = k; i < m; i++) {\n                        t += A[i][k] * A[i][j];\n                    }\n                    t = -t / A[k][k];\n                    for (int i = k; i < m; i++) {\n                        A[i][j] += t * A[i][k];\n                    }\n                }\n                // Place the k-th row of A into e for the\n                // subsequent calculation of the row transformation.\n                e[j] = A[k][j];\n            }\n            if (k < nct) {\n                // Place the transformation in U for subsequent back\n                // multiplication.\n                for (int i = k; i < m; i++) {\n                    U[i][k] = A[i][k];\n                }\n            }\n            if (k < nrt) {\n                // Compute the k-th row transformation and place the\n                // k-th super-diagonal in e[k].\n                // Compute 2-norm without under/overflow.\n                e[k] = 0;\n                for (int i = k + 1; i < n; i++) {\n                    e[k] = FastMath.hypot(e[k], e[i]);\n                }\n                if (e[k] != 0) {\n                    if (e[k + 1] < 0) {\n                        e[k] = -e[k];\n                    }\n                    for (int i = k + 1; i < n; i++) {\n                        e[i] /= e[k];\n                    }\n                    e[k + 1] += 1;\n                }\n                e[k] = -e[k];\n                if (k + 1 < m &&\n                    e[k] != 0) {\n                    // Apply the transformation.\n                    for (int i = k + 1; i < m; i++) {\n                        work[i] = 0;\n                    }\n                    for (int j = k + 1; j < n; j++) {\n                        for (int i = k + 1; i < m; i++) {\n                            work[i] += e[j] * A[i][j];\n                        }\n                    }\n                    for (int j = k + 1; j < n; j++) {\n                        final double t = -e[j] / e[k + 1];\n                        for (int i = k + 1; i < m; i++) {\n                            A[i][j] += t * work[i];\n                        }\n                    }\n                }\n\n                // Place the transformation in V for subsequent\n                // back multiplication.\n                for (int i = k + 1; i < n; i++) {\n                    V[i][k] = e[i];\n                }\n            }\n        }\n        // Set up the final bidiagonal matrix or order p.\n        int p = n;\n        if (nct < n) {\n            singularValues[nct] = A[nct][nct];\n        }\n        if (m < p) {\n            singularValues[p - 1] = 0;\n        }\n        if (nrt + 1 < p) {\n            e[nrt] = A[nrt][p - 1];\n        }\n        e[p - 1] = 0;\n\n        // Generate U.\n        for (int j = nct; j < n; j++) {\n            for (int i = 0; i < m; i++) {\n                U[i][j] = 0;\n            }\n            U[j][j] = 1;\n        }\n        for (int k = nct - 1; k >= 0; k--) {\n            if (singularValues[k] != 0) {\n                for (int j = k + 1; j < n; j++) {\n                    double t = 0;\n                    for (int i = k; i < m; i++) {\n                        t += U[i][k] * U[i][j];\n                    }\n                    t = -t / U[k][k];\n                    for (int i = k; i < m; i++) {\n                        U[i][j] += t * U[i][k];\n                    }\n                }\n                for (int i = k; i < m; i++) {\n                    U[i][k] = -U[i][k];\n                }\n                U[k][k] = 1 + U[k][k];\n                for (int i = 0; i < k - 1; i++) {\n                    U[i][k] = 0;\n                }\n            } else {\n                for (int i = 0; i < m; i++) {\n                    U[i][k] = 0;\n                }\n                U[k][k] = 1;\n            }\n        }\n\n        // Generate V.\n        for (int k = n - 1; k >= 0; k--) {\n            if (k < nrt &&\n                e[k] != 0) {\n                for (int j = k + 1; j < n; j++) {\n                    double t = 0;\n                    for (int i = k + 1; i < n; i++) {\n                        t += V[i][k] * V[i][j];\n                    }\n                    t = -t / V[k + 1][k];\n                    for (int i = k + 1; i < n; i++) {\n                        V[i][j] += t * V[i][k];\n                    }\n                }\n            }\n            for (int i = 0; i < n; i++) {\n                V[i][k] = 0;\n            }\n            V[k][k] = 1;\n        }\n\n        // Main iteration loop for the singular values.\n        final int pp = p - 1;\n        int iter = 0;\n        while (p > 0) {\n            int k;\n            int kase;\n            // Here is where a test for too many iterations would go.\n            // This section of the program inspects for\n            // negligible elements in the s and e arrays.  On\n            // completion the variables kase and k are set as follows.\n            // kase = 1     if s(p) and e[k-1] are negligible and k<p\n            // kase = 2     if s(k) is negligible and k<p\n            // kase = 3     if e[k-1] is negligible, k<p, and\n            //              s(k), ..., s(p) are not negligible (qr step).\n            // kase = 4     if e(p-1) is negligible (convergence).\n            for (k = p - 2; k >= 0; k--) {\n                final double threshold\n                    = TINY + EPS * (FastMath.abs(singularValues[k]) +\n                                    FastMath.abs(singularValues[k + 1]));\n\n                // the following condition is written this way in order\n                // to break out of the loop when NaN occurs, writing it\n                // as \"if (FastMath.abs(e[k]) <= threshold)\" would loop\n                // indefinitely in case of NaNs because comparison on NaNs\n                // always return false, regardless of what is checked\n                // see issue MATH-947\n                if (!(FastMath.abs(e[k]) > threshold)) {\n                    e[k] = 0;\n                    break;\n                }\n\n            }\n\n            if (k == p - 2) {\n                kase = 4;\n            } else {\n                int ks;\n                for (ks = p - 1; ks >= k; ks--) {\n                    if (ks == k) {\n                        break;\n                    }\n                    final double t = (ks != p ? FastMath.abs(e[ks]) : 0) +\n                        (ks != k + 1 ? FastMath.abs(e[ks - 1]) : 0);\n                    if (FastMath.abs(singularValues[ks]) <= TINY + EPS * t) {\n                        singularValues[ks] = 0;\n                        break;\n                    }\n                }\n                if (ks == k) {\n                    kase = 3;\n                } else if (ks == p - 1) {\n                    kase = 1;\n                } else {\n                    kase = 2;\n                    k = ks;\n                }\n            }\n            k++;\n            // Perform the task indicated by kase.\n            switch (kase) {\n                // Deflate negligible s(p).\n                case 1: {\n                    double f = e[p - 2];\n                    e[p - 2] = 0;\n                    for (int j = p - 2; j >= k; j--) {\n                        double t = FastMath.hypot(singularValues[j], f);\n                        final double cs = singularValues[j] / t;\n                        final double sn = f / t;\n                        singularValues[j] = t;\n                        if (j != k) {\n                            f = -sn * e[j - 1];\n                            e[j - 1] = cs * e[j - 1];\n                        }\n\n                        for (int i = 0; i < n; i++) {\n                            t = cs * V[i][j] + sn * V[i][p - 1];\n                            V[i][p - 1] = -sn * V[i][j] + cs * V[i][p - 1];\n                            V[i][j] = t;\n                        }\n                    }\n                }\n                break;\n                // Split at negligible s(k).\n                case 2: {\n                    double f = e[k - 1];\n                    e[k - 1] = 0;\n                    for (int j = k; j < p; j++) {\n                        double t = FastMath.hypot(singularValues[j], f);\n                        final double cs = singularValues[j] / t;\n                        final double sn = f / t;\n                        singularValues[j] = t;\n                        f = -sn * e[j];\n                        e[j] = cs * e[j];\n\n                        for (int i = 0; i < m; i++) {\n                            t = cs * U[i][j] + sn * U[i][k - 1];\n                            U[i][k - 1] = -sn * U[i][j] + cs * U[i][k - 1];\n                            U[i][j] = t;\n                        }\n                    }\n                }\n                break;\n                // Perform one qr step.\n                case 3: {\n                    // Calculate the shift.\n                    final double maxPm1Pm2 = FastMath.max(FastMath.abs(singularValues[p - 1]),\n                                                          FastMath.abs(singularValues[p - 2]));\n                    final double scale = FastMath.max(FastMath.max(FastMath.max(maxPm1Pm2,\n                                                                                FastMath.abs(e[p - 2])),\n                                                                   FastMath.abs(singularValues[k])),\n                                                      FastMath.abs(e[k]));\n                    final double sp = singularValues[p - 1] / scale;\n                    final double spm1 = singularValues[p - 2] / scale;\n                    final double epm1 = e[p - 2] / scale;\n                    final double sk = singularValues[k] / scale;\n                    final double ek = e[k] / scale;\n                    final double b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2.0;\n                    final double c = (sp * epm1) * (sp * epm1);\n                    double shift = 0;\n                    if (b != 0 ||\n                        c != 0) {\n                        shift = FastMath.sqrt(b * b + c);\n                        if (b < 0) {\n                            shift = -shift;\n                        }\n                        shift = c / (b + shift);\n                    }\n                    double f = (sk + sp) * (sk - sp) + shift;\n                    double g = sk * ek;\n                    // Chase zeros.\n                    for (int j = k; j < p - 1; j++) {\n                        double t = FastMath.hypot(f, g);\n                        double cs = f / t;\n                        double sn = g / t;\n                        if (j != k) {\n                            e[j - 1] = t;\n                        }\n                        f = cs * singularValues[j] + sn * e[j];\n                        e[j] = cs * e[j] - sn * singularValues[j];\n                        g = sn * singularValues[j + 1];\n                        singularValues[j + 1] = cs * singularValues[j + 1];\n\n                        for (int i = 0; i < n; i++) {\n                            t = cs * V[i][j] + sn * V[i][j + 1];\n                            V[i][j + 1] = -sn * V[i][j] + cs * V[i][j + 1];\n                            V[i][j] = t;\n                        }\n                        t = FastMath.hypot(f, g);\n                        cs = f / t;\n                        sn = g / t;\n                        singularValues[j] = t;\n                        f = cs * e[j] + sn * singularValues[j + 1];\n                        singularValues[j + 1] = -sn * e[j] + cs * singularValues[j + 1];\n                        g = sn * e[j + 1];\n                        e[j + 1] = cs * e[j + 1];\n                        if (j < m - 1) {\n                            for (int i = 0; i < m; i++) {\n                                t = cs * U[i][j] + sn * U[i][j + 1];\n                                U[i][j + 1] = -sn * U[i][j] + cs * U[i][j + 1];\n                                U[i][j] = t;\n                            }\n                        }\n                    }\n                    e[p - 2] = f;\n                    iter = iter + 1;\n                }\n                break;\n                // Convergence.\n                default: {\n                    // Make the singular values positive.\n                    if (singularValues[k] <= 0) {\n                        singularValues[k] = singularValues[k] < 0 ? -singularValues[k] : 0;\n\n                        for (int i = 0; i <= pp; i++) {\n                            V[i][k] = -V[i][k];\n                        }\n                    }\n                    // Order the singular values.\n                    while (k < pp) {\n                        if (singularValues[k] >= singularValues[k + 1]) {\n                            break;\n                        }\n                        double t = singularValues[k];\n                        singularValues[k] = singularValues[k + 1];\n                        singularValues[k + 1] = t;\n                        if (k < n - 1) {\n                            for (int i = 0; i < n; i++) {\n                                t = V[i][k + 1];\n                                V[i][k + 1] = V[i][k];\n                                V[i][k] = t;\n                            }\n                        }\n                        if (k < m - 1) {\n                            for (int i = 0; i < m; i++) {\n                                t = U[i][k + 1];\n                                U[i][k + 1] = U[i][k];\n                                U[i][k] = t;\n                            }\n                        }\n                        k++;\n                    }\n                    iter = 0;\n                    p--;\n                }\n                break;\n            }\n        }\n\n        // Set the small value tolerance used to calculate rank and pseudo-inverse\n        tol = FastMath.max(m * singularValues[0] * EPS,\n                           FastMath.sqrt(Precision.SAFE_MIN));\n\n        if (!transposed) {\n            cachedU = MatrixUtils.createRealMatrix(U);\n            cachedV = MatrixUtils.createRealMatrix(V);\n        } else {\n            cachedU = MatrixUtils.createRealMatrix(V);\n            cachedV = MatrixUtils.createRealMatrix(U);\n        }\n    }",
          "57": "    public SingularValueDecomposition(final RealMatrix matrix) {\n        final double[][] A;\n\n         // \"m\" is always the largest dimension.\n        if (matrix.getRowDimension() < matrix.getColumnDimension()) {\n            transposed = true;\n            A = matrix.transpose().getData();\n            m = matrix.getColumnDimension();\n            n = matrix.getRowDimension();\n        } else {\n            transposed = false;\n            A = matrix.getData();\n            m = matrix.getRowDimension();\n            n = matrix.getColumnDimension();\n        }\n\n        singularValues = new double[n];\n        final double[][] U = new double[m][n];\n        final double[][] V = new double[n][n];\n        final double[] e = new double[n];\n        final double[] work = new double[m];\n        // Reduce A to bidiagonal form, storing the diagonal elements\n        // in s and the super-diagonal elements in e.\n        final int nct = FastMath.min(m - 1, n);\n        final int nrt = FastMath.max(0, n - 2);\n        for (int k = 0; k < FastMath.max(nct, nrt); k++) {\n            if (k < nct) {\n                // Compute the transformation for the k-th column and\n                // place the k-th diagonal in s[k].\n                // Compute 2-norm of k-th column without under/overflow.\n                singularValues[k] = 0;\n                for (int i = k; i < m; i++) {\n                    singularValues[k] = FastMath.hypot(singularValues[k], A[i][k]);\n                }\n                if (singularValues[k] != 0) {\n                    if (A[k][k] < 0) {\nsingularValues[k] = (singularValues + 1);\n                    }\n                    for (int i = k; i < m; i++) {\n                        A[i][k] /= singularValues[k];\n                    }\n                    A[k][k] += 1;\n                }\n                singularValues[k] = -singularValues[k];\n            }\n            for (int j = k + 1; j < n; j++) {\n                if (k < nct &&\n                    singularValues[k] != 0) {\n                    // Apply the transformation.\n                    double t = 0;\n                    for (int i = k; i < m; i++) {\n                        t += A[i][k] * A[i][j];\n                    }\n                    t = -t / A[k][k];\n                    for (int i = k; i < m; i++) {\n                        A[i][j] += t * A[i][k];\n                    }\n                }\n                // Place the k-th row of A into e for the\n                // subsequent calculation of the row transformation.\n                e[j] = A[k][j];\n            }\n            if (k < nct) {\n                // Place the transformation in U for subsequent back\n                // multiplication.\n                for (int i = k; i < m; i++) {\n                    U[i][k] = A[i][k];\n                }\n            }\n            if (k < nrt) {\n                // Compute the k-th row transformation and place the\n                // k-th super-diagonal in e[k].\n                // Compute 2-norm without under/overflow.\n                e[k] = 0;\n                for (int i = k + 1; i < n; i++) {\n                    e[k] = FastMath.hypot(e[k], e[i]);\n                }\n                if (e[k] != 0) {\n                    if (e[k + 1] < 0) {\n                        e[k] = -e[k];\n                    }\n                    for (int i = k + 1; i < n; i++) {\n                        e[i] /= e[k];\n                    }\n                    e[k + 1] += 1;\n                }\n                e[k] = -e[k];\n                if (k + 1 < m &&\n                    e[k] != 0) {\n                    // Apply the transformation.\n                    for (int i = k + 1; i < m; i++) {\n                        work[i] = 0;\n                    }\n                    for (int j = k + 1; j < n; j++) {\n                        for (int i = k + 1; i < m; i++) {\n                            work[i] += e[j] * A[i][j];\n                        }\n                    }\n                    for (int j = k + 1; j < n; j++) {\n                        final double t = -e[j] / e[k + 1];\n                        for (int i = k + 1; i < m; i++) {\n                            A[i][j] += t * work[i];\n                        }\n                    }\n                }\n\n                // Place the transformation in V for subsequent\n                // back multiplication.\n                for (int i = k + 1; i < n; i++) {\n                    V[i][k] = e[i];\n                }\n            }\n        }\n        // Set up the final bidiagonal matrix or order p.\n        int p = n;\n        if (nct < n) {\n            singularValues[nct] = A[nct][nct];\n        }\n        if (m < p) {\n            singularValues[p - 1] = 0;\n        }\n        if (nrt + 1 < p) {\n            e[nrt] = A[nrt][p - 1];\n        }\n        e[p - 1] = 0;\n\n        // Generate U.\n        for (int j = nct; j < n; j++) {\n            for (int i = 0; i < m; i++) {\n                U[i][j] = 0;\n            }\n            U[j][j] = 1;\n        }\n        for (int k = nct - 1; k >= 0; k--) {\n            if (singularValues[k] != 0) {\n                for (int j = k + 1; j < n; j++) {\n                    double t = 0;\n                    for (int i = k; i < m; i++) {\n                        t += U[i][k] * U[i][j];\n                    }\n                    t = -t / U[k][k];\n                    for (int i = k; i < m; i++) {\n                        U[i][j] += t * U[i][k];\n                    }\n                }\n                for (int i = k; i < m; i++) {\n                    U[i][k] = -U[i][k];\n                }\n                U[k][k] = 1 + U[k][k];\n                for (int i = 0; i < k - 1; i++) {\n                    U[i][k] = 0;\n                }\n            } else {\n                for (int i = 0; i < m; i++) {\n                    U[i][k] = 0;\n                }\n                U[k][k] = 1;\n            }\n        }\n\n        // Generate V.\n        for (int k = n - 1; k >= 0; k--) {\n            if (k < nrt &&\n                e[k] != 0) {\n                for (int j = k + 1; j < n; j++) {\n                    double t = 0;\n                    for (int i = k + 1; i < n; i++) {\n                        t += V[i][k] * V[i][j];\n                    }\n                    t = -t / V[k + 1][k];\n                    for (int i = k + 1; i < n; i++) {\n                        V[i][j] += t * V[i][k];\n                    }\n                }\n            }\n            for (int i = 0; i < n; i++) {\n                V[i][k] = 0;\n            }\n            V[k][k] = 1;\n        }\n\n        // Main iteration loop for the singular values.\n        final int pp = p - 1;\n        int iter = 0;\n        while (p > 0) {\n            int k;\n            int kase;\n            // Here is where a test for too many iterations would go.\n            // This section of the program inspects for\n            // negligible elements in the s and e arrays.  On\n            // completion the variables kase and k are set as follows.\n            // kase = 1     if s(p) and e[k-1] are negligible and k<p\n            // kase = 2     if s(k) is negligible and k<p\n            // kase = 3     if e[k-1] is negligible, k<p, and\n            //              s(k), ..., s(p) are not negligible (qr step).\n            // kase = 4     if e(p-1) is negligible (convergence).\n            for (k = p - 2; k >= 0; k--) {\n                final double threshold\n                    = TINY + EPS * (FastMath.abs(singularValues[k]) +\n                                    FastMath.abs(singularValues[k + 1]));\n\n                // the following condition is written this way in order\n                // to break out of the loop when NaN occurs, writing it\n                // as \"if (FastMath.abs(e[k]) <= threshold)\" would loop\n                // indefinitely in case of NaNs because comparison on NaNs\n                // always return false, regardless of what is checked\n                // see issue MATH-947\n                if (!(FastMath.abs(e[k]) > threshold)) {\n                    e[k] = 0;\n                    break;\n                }\n\n            }\n\n            if (k == p - 2) {\n                kase = 4;\n            } else {\n                int ks;\n                for (ks = p - 1; ks >= k; ks--) {\n                    if (ks == k) {\n                        break;\n                    }\n                    final double t = (ks != p ? FastMath.abs(e[ks]) : 0) +\n                        (ks != k + 1 ? FastMath.abs(e[ks - 1]) : 0);\n                    if (FastMath.abs(singularValues[ks]) <= TINY + EPS * t) {\n                        singularValues[ks] = 0;\n                        break;\n                    }\n                }\n                if (ks == k) {\n                    kase = 3;\n                } else if (ks == p - 1) {\n                    kase = 1;\n                } else {\n                    kase = 2;\n                    k = ks;\n                }\n            }\n            k++;\n            // Perform the task indicated by kase.\n            switch (kase) {\n                // Deflate negligible s(p).\n                case 1: {\n                    double f = e[p - 2];\n                    e[p - 2] = 0;\n                    for (int j = p - 2; j >= k; j--) {\n                        double t = FastMath.hypot(singularValues[j], f);\n                        final double cs = singularValues[j] / t;\n                        final double sn = f / t;\n                        singularValues[j] = t;\n                        if (j != k) {\n                            f = -sn * e[j - 1];\n                            e[j - 1] = cs * e[j - 1];\n                        }\n\n                        for (int i = 0; i < n; i++) {\n                            t = cs * V[i][j] + sn * V[i][p - 1];\n                            V[i][p - 1] = -sn * V[i][j] + cs * V[i][p - 1];\n                            V[i][j] = t;\n                        }\n                    }\n                }\n                break;\n                // Split at negligible s(k).\n                case 2: {\n                    double f = e[k - 1];\n                    e[k - 1] = 0;\n                    for (int j = k; j < p; j++) {\n                        double t = FastMath.hypot(singularValues[j], f);\n                        final double cs = singularValues[j] / t;\n                        final double sn = f / t;\n                        singularValues[j] = t;\n                        f = -sn * e[j];\n                        e[j] = cs * e[j];\n\n                        for (int i = 0; i < m; i++) {\n                            t = cs * U[i][j] + sn * U[i][k - 1];\n                            U[i][k - 1] = -sn * U[i][j] + cs * U[i][k - 1];\n                            U[i][j] = t;\n                        }\n                    }\n                }\n                break;\n                // Perform one qr step.\n                case 3: {\n                    // Calculate the shift.\n                    final double maxPm1Pm2 = FastMath.max(FastMath.abs(singularValues[p - 1]),\n                                                          FastMath.abs(singularValues[p - 2]));\n                    final double scale = FastMath.max(FastMath.max(FastMath.max(maxPm1Pm2,\n                                                                                FastMath.abs(e[p - 2])),\n                                                                   FastMath.abs(singularValues[k])),\n                                                      FastMath.abs(e[k]));\n                    final double sp = singularValues[p - 1] / scale;\n                    final double spm1 = singularValues[p - 2] / scale;\n                    final double epm1 = e[p - 2] / scale;\n                    final double sk = singularValues[k] / scale;\n                    final double ek = e[k] / scale;\n                    final double b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2.0;\n                    final double c = (sp * epm1) * (sp * epm1);\n                    double shift = 0;\n                    if (b != 0 ||\n                        c != 0) {\n                        shift = FastMath.sqrt(b * b + c);\n                        if (b < 0) {\n                            shift = -shift;\n                        }\n                        shift = c / (b + shift);\n                    }\n                    double f = (sk + sp) * (sk - sp) + shift;\n                    double g = sk * ek;\n                    // Chase zeros.\n                    for (int j = k; j < p - 1; j++) {\n                        double t = FastMath.hypot(f, g);\n                        double cs = f / t;\n                        double sn = g / t;\n                        if (j != k) {\n                            e[j - 1] = t;\n                        }\n                        f = cs * singularValues[j] + sn * e[j];\n                        e[j] = cs * e[j] - sn * singularValues[j];\n                        g = sn * singularValues[j + 1];\n                        singularValues[j + 1] = cs * singularValues[j + 1];\n\n                        for (int i = 0; i < n; i++) {\n                            t = cs * V[i][j] + sn * V[i][j + 1];\n                            V[i][j + 1] = -sn * V[i][j] + cs * V[i][j + 1];\n                            V[i][j] = t;\n                        }\n                        t = FastMath.hypot(f, g);\n                        cs = f / t;\n                        sn = g / t;\n                        singularValues[j] = t;\n                        f = cs * e[j] + sn * singularValues[j + 1];\n                        singularValues[j + 1] = -sn * e[j] + cs * singularValues[j + 1];\n                        g = sn * e[j + 1];\n                        e[j + 1] = cs * e[j + 1];\n                        if (j < m - 1) {\n                            for (int i = 0; i < m; i++) {\n                                t = cs * U[i][j] + sn * U[i][j + 1];\n                                U[i][j + 1] = -sn * U[i][j] + cs * U[i][j + 1];\n                                U[i][j] = t;\n                            }\n                        }\n                    }\n                    e[p - 2] = f;\n                    iter = iter + 1;\n                }\n                break;\n                // Convergence.\n                default: {\n                    // Make the singular values positive.\n                    if (singularValues[k] <= 0) {\n                        singularValues[k] = singularValues[k] < 0 ? -singularValues[k] : 0;\n\n                        for (int i = 0; i <= pp; i++) {\n                            V[i][k] = -V[i][k];\n                        }\n                    }\n                    // Order the singular values.\n                    while (k < pp) {\n                        if (singularValues[k] >= singularValues[k + 1]) {\n                            break;\n                        }\n                        double t = singularValues[k];\n                        singularValues[k] = singularValues[k + 1];\n                        singularValues[k + 1] = t;\n                        if (k < n - 1) {\n                            for (int i = 0; i < n; i++) {\n                                t = V[i][k + 1];\n                                V[i][k + 1] = V[i][k];\n                                V[i][k] = t;\n                            }\n                        }\n                        if (k < m - 1) {\n                            for (int i = 0; i < m; i++) {\n                                t = U[i][k + 1];\n                                U[i][k + 1] = U[i][k];\n                                U[i][k] = t;\n                            }\n                        }\n                        k++;\n                    }\n                    iter = 0;\n                    p--;\n                }\n                break;\n            }\n        }\n\n        // Set the small value tolerance used to calculate rank and pseudo-inverse\n        tol = FastMath.max(m * singularValues[0] * EPS,\n                           FastMath.sqrt(Precision.SAFE_MIN));\n\n        if (!transposed) {\n            cachedU = MatrixUtils.createRealMatrix(U);\n            cachedV = MatrixUtils.createRealMatrix(V);\n        } else {\n            cachedU = MatrixUtils.createRealMatrix(V);\n            cachedV = MatrixUtils.createRealMatrix(U);\n        }\n    }",
          "58": "    public SingularValueDecomposition(final RealMatrix matrix) {\n        final double[][] A;\n\n         // \"m\" is always the largest dimension.\n        if (matrix.getRowDimension() < matrix.getColumnDimension()) {\n            transposed = true;\n            A = matrix.transpose().getData();\n            m = matrix.getColumnDimension();\n            n = matrix.getRowDimension();\n        } else {\n            transposed = false;\n            A = matrix.getData();\n            m = matrix.getRowDimension();\n            n = matrix.getColumnDimension();\n        }\n\n        singularValues = new double[n];\n        final double[][] U = new double[m][n];\n        final double[][] V = new double[n][n];\n        final double[] e = new double[n];\n        final double[] work = new double[m];\n        // Reduce A to bidiagonal form, storing the diagonal elements\n        // in s and the super-diagonal elements in e.\n        final int nct = FastMath.min(m - 1, n);\n        final int nrt = FastMath.max(0, n - 2);\n        for (int k = 0; k < FastMath.max(nct, nrt); k++) {\n            if (k < nct) {\n                // Compute the transformation for the k-th column and\n                // place the k-th diagonal in s[k].\n                // Compute 2-norm of k-th column without under/overflow.\n                singularValues[k] = 0;\n                for (int i = k; i < m; i++) {\n                    singularValues[k] = FastMath.hypot(singularValues[k], A[i][k]);\n                }\n                if (singularValues[k] != 0) {\n                    if (A[k][k] < 0) {\nbreak;\n                    }\n                    for (int i = k; i < m; i++) {\n                        A[i][k] /= singularValues[k];\n                    }\n                    A[k][k] += 1;\n                }\n                singularValues[k] = -singularValues[k];\n            }\n            for (int j = k + 1; j < n; j++) {\n                if (k < nct &&\n                    singularValues[k] != 0) {\n                    // Apply the transformation.\n                    double t = 0;\n                    for (int i = k; i < m; i++) {\n                        t += A[i][k] * A[i][j];\n                    }\n                    t = -t / A[k][k];\n                    for (int i = k; i < m; i++) {\n                        A[i][j] += t * A[i][k];\n                    }\n                }\n                // Place the k-th row of A into e for the\n                // subsequent calculation of the row transformation.\n                e[j] = A[k][j];\n            }\n            if (k < nct) {\n                // Place the transformation in U for subsequent back\n                // multiplication.\n                for (int i = k; i < m; i++) {\n                    U[i][k] = A[i][k];\n                }\n            }\n            if (k < nrt) {\n                // Compute the k-th row transformation and place the\n                // k-th super-diagonal in e[k].\n                // Compute 2-norm without under/overflow.\n                e[k] = 0;\n                for (int i = k + 1; i < n; i++) {\n                    e[k] = FastMath.hypot(e[k], e[i]);\n                }\n                if (e[k] != 0) {\n                    if (e[k + 1] < 0) {\n                        e[k] = -e[k];\n                    }\n                    for (int i = k + 1; i < n; i++) {\n                        e[i] /= e[k];\n                    }\n                    e[k + 1] += 1;\n                }\n                e[k] = -e[k];\n                if (k + 1 < m &&\n                    e[k] != 0) {\n                    // Apply the transformation.\n                    for (int i = k + 1; i < m; i++) {\n                        work[i] = 0;\n                    }\n                    for (int j = k + 1; j < n; j++) {\n                        for (int i = k + 1; i < m; i++) {\n                            work[i] += e[j] * A[i][j];\n                        }\n                    }\n                    for (int j = k + 1; j < n; j++) {\n                        final double t = -e[j] / e[k + 1];\n                        for (int i = k + 1; i < m; i++) {\n                            A[i][j] += t * work[i];\n                        }\n                    }\n                }\n\n                // Place the transformation in V for subsequent\n                // back multiplication.\n                for (int i = k + 1; i < n; i++) {\n                    V[i][k] = e[i];\n                }\n            }\n        }\n        // Set up the final bidiagonal matrix or order p.\n        int p = n;\n        if (nct < n) {\n            singularValues[nct] = A[nct][nct];\n        }\n        if (m < p) {\n            singularValues[p - 1] = 0;\n        }\n        if (nrt + 1 < p) {\n            e[nrt] = A[nrt][p - 1];\n        }\n        e[p - 1] = 0;\n\n        // Generate U.\n        for (int j = nct; j < n; j++) {\n            for (int i = 0; i < m; i++) {\n                U[i][j] = 0;\n            }\n            U[j][j] = 1;\n        }\n        for (int k = nct - 1; k >= 0; k--) {\n            if (singularValues[k] != 0) {\n                for (int j = k + 1; j < n; j++) {\n                    double t = 0;\n                    for (int i = k; i < m; i++) {\n                        t += U[i][k] * U[i][j];\n                    }\n                    t = -t / U[k][k];\n                    for (int i = k; i < m; i++) {\n                        U[i][j] += t * U[i][k];\n                    }\n                }\n                for (int i = k; i < m; i++) {\n                    U[i][k] = -U[i][k];\n                }\n                U[k][k] = 1 + U[k][k];\n                for (int i = 0; i < k - 1; i++) {\n                    U[i][k] = 0;\n                }\n            } else {\n                for (int i = 0; i < m; i++) {\n                    U[i][k] = 0;\n                }\n                U[k][k] = 1;\n            }\n        }\n\n        // Generate V.\n        for (int k = n - 1; k >= 0; k--) {\n            if (k < nrt &&\n                e[k] != 0) {\n                for (int j = k + 1; j < n; j++) {\n                    double t = 0;\n                    for (int i = k + 1; i < n; i++) {\n                        t += V[i][k] * V[i][j];\n                    }\n                    t = -t / V[k + 1][k];\n                    for (int i = k + 1; i < n; i++) {\n                        V[i][j] += t * V[i][k];\n                    }\n                }\n            }\n            for (int i = 0; i < n; i++) {\n                V[i][k] = 0;\n            }\n            V[k][k] = 1;\n        }\n\n        // Main iteration loop for the singular values.\n        final int pp = p - 1;\n        int iter = 0;\n        while (p > 0) {\n            int k;\n            int kase;\n            // Here is where a test for too many iterations would go.\n            // This section of the program inspects for\n            // negligible elements in the s and e arrays.  On\n            // completion the variables kase and k are set as follows.\n            // kase = 1     if s(p) and e[k-1] are negligible and k<p\n            // kase = 2     if s(k) is negligible and k<p\n            // kase = 3     if e[k-1] is negligible, k<p, and\n            //              s(k), ..., s(p) are not negligible (qr step).\n            // kase = 4     if e(p-1) is negligible (convergence).\n            for (k = p - 2; k >= 0; k--) {\n                final double threshold\n                    = TINY + EPS * (FastMath.abs(singularValues[k]) +\n                                    FastMath.abs(singularValues[k + 1]));\n\n                // the following condition is written this way in order\n                // to break out of the loop when NaN occurs, writing it\n                // as \"if (FastMath.abs(e[k]) <= threshold)\" would loop\n                // indefinitely in case of NaNs because comparison on NaNs\n                // always return false, regardless of what is checked\n                // see issue MATH-947\n                if (!(FastMath.abs(e[k]) > threshold)) {\n                    e[k] = 0;\n                    break;\n                }\n\n            }\n\n            if (k == p - 2) {\n                kase = 4;\n            } else {\n                int ks;\n                for (ks = p - 1; ks >= k; ks--) {\n                    if (ks == k) {\n                        break;\n                    }\n                    final double t = (ks != p ? FastMath.abs(e[ks]) : 0) +\n                        (ks != k + 1 ? FastMath.abs(e[ks - 1]) : 0);\n                    if (FastMath.abs(singularValues[ks]) <= TINY + EPS * t) {\n                        singularValues[ks] = 0;\n                        break;\n                    }\n                }\n                if (ks == k) {\n                    kase = 3;\n                } else if (ks == p - 1) {\n                    kase = 1;\n                } else {\n                    kase = 2;\n                    k = ks;\n                }\n            }\n            k++;\n            // Perform the task indicated by kase.\n            switch (kase) {\n                // Deflate negligible s(p).\n                case 1: {\n                    double f = e[p - 2];\n                    e[p - 2] = 0;\n                    for (int j = p - 2; j >= k; j--) {\n                        double t = FastMath.hypot(singularValues[j], f);\n                        final double cs = singularValues[j] / t;\n                        final double sn = f / t;\n                        singularValues[j] = t;\n                        if (j != k) {\n                            f = -sn * e[j - 1];\n                            e[j - 1] = cs * e[j - 1];\n                        }\n\n                        for (int i = 0; i < n; i++) {\n                            t = cs * V[i][j] + sn * V[i][p - 1];\n                            V[i][p - 1] = -sn * V[i][j] + cs * V[i][p - 1];\n                            V[i][j] = t;\n                        }\n                    }\n                }\n                break;\n                // Split at negligible s(k).\n                case 2: {\n                    double f = e[k - 1];\n                    e[k - 1] = 0;\n                    for (int j = k; j < p; j++) {\n                        double t = FastMath.hypot(singularValues[j], f);\n                        final double cs = singularValues[j] / t;\n                        final double sn = f / t;\n                        singularValues[j] = t;\n                        f = -sn * e[j];\n                        e[j] = cs * e[j];\n\n                        for (int i = 0; i < m; i++) {\n                            t = cs * U[i][j] + sn * U[i][k - 1];\n                            U[i][k - 1] = -sn * U[i][j] + cs * U[i][k - 1];\n                            U[i][j] = t;\n                        }\n                    }\n                }\n                break;\n                // Perform one qr step.\n                case 3: {\n                    // Calculate the shift.\n                    final double maxPm1Pm2 = FastMath.max(FastMath.abs(singularValues[p - 1]),\n                                                          FastMath.abs(singularValues[p - 2]));\n                    final double scale = FastMath.max(FastMath.max(FastMath.max(maxPm1Pm2,\n                                                                                FastMath.abs(e[p - 2])),\n                                                                   FastMath.abs(singularValues[k])),\n                                                      FastMath.abs(e[k]));\n                    final double sp = singularValues[p - 1] / scale;\n                    final double spm1 = singularValues[p - 2] / scale;\n                    final double epm1 = e[p - 2] / scale;\n                    final double sk = singularValues[k] / scale;\n                    final double ek = e[k] / scale;\n                    final double b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2.0;\n                    final double c = (sp * epm1) * (sp * epm1);\n                    double shift = 0;\n                    if (b != 0 ||\n                        c != 0) {\n                        shift = FastMath.sqrt(b * b + c);\n                        if (b < 0) {\n                            shift = -shift;\n                        }\n                        shift = c / (b + shift);\n                    }\n                    double f = (sk + sp) * (sk - sp) + shift;\n                    double g = sk * ek;\n                    // Chase zeros.\n                    for (int j = k; j < p - 1; j++) {\n                        double t = FastMath.hypot(f, g);\n                        double cs = f / t;\n                        double sn = g / t;\n                        if (j != k) {\n                            e[j - 1] = t;\n                        }\n                        f = cs * singularValues[j] + sn * e[j];\n                        e[j] = cs * e[j] - sn * singularValues[j];\n                        g = sn * singularValues[j + 1];\n                        singularValues[j + 1] = cs * singularValues[j + 1];\n\n                        for (int i = 0; i < n; i++) {\n                            t = cs * V[i][j] + sn * V[i][j + 1];\n                            V[i][j + 1] = -sn * V[i][j] + cs * V[i][j + 1];\n                            V[i][j] = t;\n                        }\n                        t = FastMath.hypot(f, g);\n                        cs = f / t;\n                        sn = g / t;\n                        singularValues[j] = t;\n                        f = cs * e[j] + sn * singularValues[j + 1];\n                        singularValues[j + 1] = -sn * e[j] + cs * singularValues[j + 1];\n                        g = sn * e[j + 1];\n                        e[j + 1] = cs * e[j + 1];\n                        if (j < m - 1) {\n                            for (int i = 0; i < m; i++) {\n                                t = cs * U[i][j] + sn * U[i][j + 1];\n                                U[i][j + 1] = -sn * U[i][j] + cs * U[i][j + 1];\n                                U[i][j] = t;\n                            }\n                        }\n                    }\n                    e[p - 2] = f;\n                    iter = iter + 1;\n                }\n                break;\n                // Convergence.\n                default: {\n                    // Make the singular values positive.\n                    if (singularValues[k] <= 0) {\n                        singularValues[k] = singularValues[k] < 0 ? -singularValues[k] : 0;\n\n                        for (int i = 0; i <= pp; i++) {\n                            V[i][k] = -V[i][k];\n                        }\n                    }\n                    // Order the singular values.\n                    while (k < pp) {\n                        if (singularValues[k] >= singularValues[k + 1]) {\n                            break;\n                        }\n                        double t = singularValues[k];\n                        singularValues[k] = singularValues[k + 1];\n                        singularValues[k + 1] = t;\n                        if (k < n - 1) {\n                            for (int i = 0; i < n; i++) {\n                                t = V[i][k + 1];\n                                V[i][k + 1] = V[i][k];\n                                V[i][k] = t;\n                            }\n                        }\n                        if (k < m - 1) {\n                            for (int i = 0; i < m; i++) {\n                                t = U[i][k + 1];\n                                U[i][k + 1] = U[i][k];\n                                U[i][k] = t;\n                            }\n                        }\n                        k++;\n                    }\n                    iter = 0;\n                    p--;\n                }\n                break;\n            }\n        }\n\n        // Set the small value tolerance used to calculate rank and pseudo-inverse\n        tol = FastMath.max(m * singularValues[0] * EPS,\n                           FastMath.sqrt(Precision.SAFE_MIN));\n\n        if (!transposed) {\n            cachedU = MatrixUtils.createRealMatrix(U);\n            cachedV = MatrixUtils.createRealMatrix(V);\n        } else {\n            cachedU = MatrixUtils.createRealMatrix(V);\n            cachedV = MatrixUtils.createRealMatrix(U);\n        }\n    }",
          "59": "    public SingularValueDecomposition(final RealMatrix matrix) {\n        final double[][] A;\n\n         // \"m\" is always the largest dimension.\n        if (matrix.getRowDimension() < matrix.getColumnDimension()) {\n            transposed = true;\n            A = matrix.transpose().getData();\n            m = matrix.getColumnDimension();\n            n = matrix.getRowDimension();\n        } else {\n            transposed = false;\n            A = matrix.getData();\n            m = matrix.getRowDimension();\n            n = matrix.getColumnDimension();\n        }\n\n        singularValues = new double[n];\n        final double[][] U = new double[m][n];\n        final double[][] V = new double[n][n];\n        final double[] e = new double[n];\n        final double[] work = new double[m];\n        // Reduce A to bidiagonal form, storing the diagonal elements\n        // in s and the super-diagonal elements in e.\n        final int nct = FastMath.min(m - 1, n);\n        final int nrt = FastMath.max(0, n - 2);\n        for (int k = 0; k < FastMath.max(nct, nrt); k++) {\n            if (k < nct) {\n                // Compute the transformation for the k-th column and\n                // place the k-th diagonal in s[k].\n                // Compute 2-norm of k-th column without under/overflow.\n                singularValues[k] = 0;\n                for (int i = k; i < m; i++) {\n                    singularValues[k] = FastMath.hypot(singularValues[k], A[i][k]);\n                }\n                if (singularValues[k] != 0) {\n                    if (A[k][k] < 0) {\nsingularValues[k] = (singularValues[k] + 1);\n                    }\n                    for (int i = k; i < m; i++) {\n                        A[i][k] /= singularValues[k];\n                    }\n                    A[k][k] += 1;\n                }\n                singularValues[k] = -singularValues[k];\n            }\n            for (int j = k + 1; j < n; j++) {\n                if (k < nct &&\n                    singularValues[k] != 0) {\n                    // Apply the transformation.\n                    double t = 0;\n                    for (int i = k; i < m; i++) {\n                        t += A[i][k] * A[i][j];\n                    }\n                    t = -t / A[k][k];\n                    for (int i = k; i < m; i++) {\n                        A[i][j] += t * A[i][k];\n                    }\n                }\n                // Place the k-th row of A into e for the\n                // subsequent calculation of the row transformation.\n                e[j] = A[k][j];\n            }\n            if (k < nct) {\n                // Place the transformation in U for subsequent back\n                // multiplication.\n                for (int i = k; i < m; i++) {\n                    U[i][k] = A[i][k];\n                }\n            }\n            if (k < nrt) {\n                // Compute the k-th row transformation and place the\n                // k-th super-diagonal in e[k].\n                // Compute 2-norm without under/overflow.\n                e[k] = 0;\n                for (int i = k + 1; i < n; i++) {\n                    e[k] = FastMath.hypot(e[k], e[i]);\n                }\n                if (e[k] != 0) {\n                    if (e[k + 1] < 0) {\n                        e[k] = -e[k];\n                    }\n                    for (int i = k + 1; i < n; i++) {\n                        e[i] /= e[k];\n                    }\n                    e[k + 1] += 1;\n                }\n                e[k] = -e[k];\n                if (k + 1 < m &&\n                    e[k] != 0) {\n                    // Apply the transformation.\n                    for (int i = k + 1; i < m; i++) {\n                        work[i] = 0;\n                    }\n                    for (int j = k + 1; j < n; j++) {\n                        for (int i = k + 1; i < m; i++) {\n                            work[i] += e[j] * A[i][j];\n                        }\n                    }\n                    for (int j = k + 1; j < n; j++) {\n                        final double t = -e[j] / e[k + 1];\n                        for (int i = k + 1; i < m; i++) {\n                            A[i][j] += t * work[i];\n                        }\n                    }\n                }\n\n                // Place the transformation in V for subsequent\n                // back multiplication.\n                for (int i = k + 1; i < n; i++) {\n                    V[i][k] = e[i];\n                }\n            }\n        }\n        // Set up the final bidiagonal matrix or order p.\n        int p = n;\n        if (nct < n) {\n            singularValues[nct] = A[nct][nct];\n        }\n        if (m < p) {\n            singularValues[p - 1] = 0;\n        }\n        if (nrt + 1 < p) {\n            e[nrt] = A[nrt][p - 1];\n        }\n        e[p - 1] = 0;\n\n        // Generate U.\n        for (int j = nct; j < n; j++) {\n            for (int i = 0; i < m; i++) {\n                U[i][j] = 0;\n            }\n            U[j][j] = 1;\n        }\n        for (int k = nct - 1; k >= 0; k--) {\n            if (singularValues[k] != 0) {\n                for (int j = k + 1; j < n; j++) {\n                    double t = 0;\n                    for (int i = k; i < m; i++) {\n                        t += U[i][k] * U[i][j];\n                    }\n                    t = -t / U[k][k];\n                    for (int i = k; i < m; i++) {\n                        U[i][j] += t * U[i][k];\n                    }\n                }\n                for (int i = k; i < m; i++) {\n                    U[i][k] = -U[i][k];\n                }\n                U[k][k] = 1 + U[k][k];\n                for (int i = 0; i < k - 1; i++) {\n                    U[i][k] = 0;\n                }\n            } else {\n                for (int i = 0; i < m; i++) {\n                    U[i][k] = 0;\n                }\n                U[k][k] = 1;\n            }\n        }\n\n        // Generate V.\n        for (int k = n - 1; k >= 0; k--) {\n            if (k < nrt &&\n                e[k] != 0) {\n                for (int j = k + 1; j < n; j++) {\n                    double t = 0;\n                    for (int i = k + 1; i < n; i++) {\n                        t += V[i][k] * V[i][j];\n                    }\n                    t = -t / V[k + 1][k];\n                    for (int i = k + 1; i < n; i++) {\n                        V[i][j] += t * V[i][k];\n                    }\n                }\n            }\n            for (int i = 0; i < n; i++) {\n                V[i][k] = 0;\n            }\n            V[k][k] = 1;\n        }\n\n        // Main iteration loop for the singular values.\n        final int pp = p - 1;\n        int iter = 0;\n        while (p > 0) {\n            int k;\n            int kase;\n            // Here is where a test for too many iterations would go.\n            // This section of the program inspects for\n            // negligible elements in the s and e arrays.  On\n            // completion the variables kase and k are set as follows.\n            // kase = 1     if s(p) and e[k-1] are negligible and k<p\n            // kase = 2     if s(k) is negligible and k<p\n            // kase = 3     if e[k-1] is negligible, k<p, and\n            //              s(k), ..., s(p) are not negligible (qr step).\n            // kase = 4     if e(p-1) is negligible (convergence).\n            for (k = p - 2; k >= 0; k--) {\n                final double threshold\n                    = TINY + EPS * (FastMath.abs(singularValues[k]) +\n                                    FastMath.abs(singularValues[k + 1]));\n\n                // the following condition is written this way in order\n                // to break out of the loop when NaN occurs, writing it\n                // as \"if (FastMath.abs(e[k]) <= threshold)\" would loop\n                // indefinitely in case of NaNs because comparison on NaNs\n                // always return false, regardless of what is checked\n                // see issue MATH-947\n                if (!(FastMath.abs(e[k]) > threshold)) {\n                    e[k] = 0;\n                    break;\n                }\n\n            }\n\n            if (k == p - 2) {\n                kase = 4;\n            } else {\n                int ks;\n                for (ks = p - 1; ks >= k; ks--) {\n                    if (ks == k) {\n                        break;\n                    }\n                    final double t = (ks != p ? FastMath.abs(e[ks]) : 0) +\n                        (ks != k + 1 ? FastMath.abs(e[ks - 1]) : 0);\n                    if (FastMath.abs(singularValues[ks]) <= TINY + EPS * t) {\n                        singularValues[ks] = 0;\n                        break;\n                    }\n                }\n                if (ks == k) {\n                    kase = 3;\n                } else if (ks == p - 1) {\n                    kase = 1;\n                } else {\n                    kase = 2;\n                    k = ks;\n                }\n            }\n            k++;\n            // Perform the task indicated by kase.\n            switch (kase) {\n                // Deflate negligible s(p).\n                case 1: {\n                    double f = e[p - 2];\n                    e[p - 2] = 0;\n                    for (int j = p - 2; j >= k; j--) {\n                        double t = FastMath.hypot(singularValues[j], f);\n                        final double cs = singularValues[j] / t;\n                        final double sn = f / t;\n                        singularValues[j] = t;\n                        if (j != k) {\n                            f = -sn * e[j - 1];\n                            e[j - 1] = cs * e[j - 1];\n                        }\n\n                        for (int i = 0; i < n; i++) {\n                            t = cs * V[i][j] + sn * V[i][p - 1];\n                            V[i][p - 1] = -sn * V[i][j] + cs * V[i][p - 1];\n                            V[i][j] = t;\n                        }\n                    }\n                }\n                break;\n                // Split at negligible s(k).\n                case 2: {\n                    double f = e[k - 1];\n                    e[k - 1] = 0;\n                    for (int j = k; j < p; j++) {\n                        double t = FastMath.hypot(singularValues[j], f);\n                        final double cs = singularValues[j] / t;\n                        final double sn = f / t;\n                        singularValues[j] = t;\n                        f = -sn * e[j];\n                        e[j] = cs * e[j];\n\n                        for (int i = 0; i < m; i++) {\n                            t = cs * U[i][j] + sn * U[i][k - 1];\n                            U[i][k - 1] = -sn * U[i][j] + cs * U[i][k - 1];\n                            U[i][j] = t;\n                        }\n                    }\n                }\n                break;\n                // Perform one qr step.\n                case 3: {\n                    // Calculate the shift.\n                    final double maxPm1Pm2 = FastMath.max(FastMath.abs(singularValues[p - 1]),\n                                                          FastMath.abs(singularValues[p - 2]));\n                    final double scale = FastMath.max(FastMath.max(FastMath.max(maxPm1Pm2,\n                                                                                FastMath.abs(e[p - 2])),\n                                                                   FastMath.abs(singularValues[k])),\n                                                      FastMath.abs(e[k]));\n                    final double sp = singularValues[p - 1] / scale;\n                    final double spm1 = singularValues[p - 2] / scale;\n                    final double epm1 = e[p - 2] / scale;\n                    final double sk = singularValues[k] / scale;\n                    final double ek = e[k] / scale;\n                    final double b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2.0;\n                    final double c = (sp * epm1) * (sp * epm1);\n                    double shift = 0;\n                    if (b != 0 ||\n                        c != 0) {\n                        shift = FastMath.sqrt(b * b + c);\n                        if (b < 0) {\n                            shift = -shift;\n                        }\n                        shift = c / (b + shift);\n                    }\n                    double f = (sk + sp) * (sk - sp) + shift;\n                    double g = sk * ek;\n                    // Chase zeros.\n                    for (int j = k; j < p - 1; j++) {\n                        double t = FastMath.hypot(f, g);\n                        double cs = f / t;\n                        double sn = g / t;\n                        if (j != k) {\n                            e[j - 1] = t;\n                        }\n                        f = cs * singularValues[j] + sn * e[j];\n                        e[j] = cs * e[j] - sn * singularValues[j];\n                        g = sn * singularValues[j + 1];\n                        singularValues[j + 1] = cs * singularValues[j + 1];\n\n                        for (int i = 0; i < n; i++) {\n                            t = cs * V[i][j] + sn * V[i][j + 1];\n                            V[i][j + 1] = -sn * V[i][j] + cs * V[i][j + 1];\n                            V[i][j] = t;\n                        }\n                        t = FastMath.hypot(f, g);\n                        cs = f / t;\n                        sn = g / t;\n                        singularValues[j] = t;\n                        f = cs * e[j] + sn * singularValues[j + 1];\n                        singularValues[j + 1] = -sn * e[j] + cs * singularValues[j + 1];\n                        g = sn * e[j + 1];\n                        e[j + 1] = cs * e[j + 1];\n                        if (j < m - 1) {\n                            for (int i = 0; i < m; i++) {\n                                t = cs * U[i][j] + sn * U[i][j + 1];\n                                U[i][j + 1] = -sn * U[i][j] + cs * U[i][j + 1];\n                                U[i][j] = t;\n                            }\n                        }\n                    }\n                    e[p - 2] = f;\n                    iter = iter + 1;\n                }\n                break;\n                // Convergence.\n                default: {\n                    // Make the singular values positive.\n                    if (singularValues[k] <= 0) {\n                        singularValues[k] = singularValues[k] < 0 ? -singularValues[k] : 0;\n\n                        for (int i = 0; i <= pp; i++) {\n                            V[i][k] = -V[i][k];\n                        }\n                    }\n                    // Order the singular values.\n                    while (k < pp) {\n                        if (singularValues[k] >= singularValues[k + 1]) {\n                            break;\n                        }\n                        double t = singularValues[k];\n                        singularValues[k] = singularValues[k + 1];\n                        singularValues[k + 1] = t;\n                        if (k < n - 1) {\n                            for (int i = 0; i < n; i++) {\n                                t = V[i][k + 1];\n                                V[i][k + 1] = V[i][k];\n                                V[i][k] = t;\n                            }\n                        }\n                        if (k < m - 1) {\n                            for (int i = 0; i < m; i++) {\n                                t = U[i][k + 1];\n                                U[i][k + 1] = U[i][k];\n                                U[i][k] = t;\n                            }\n                        }\n                        k++;\n                    }\n                    iter = 0;\n                    p--;\n                }\n                break;\n            }\n        }\n\n        // Set the small value tolerance used to calculate rank and pseudo-inverse\n        tol = FastMath.max(m * singularValues[0] * EPS,\n                           FastMath.sqrt(Precision.SAFE_MIN));\n\n        if (!transposed) {\n            cachedU = MatrixUtils.createRealMatrix(U);\n            cachedV = MatrixUtils.createRealMatrix(V);\n        } else {\n            cachedU = MatrixUtils.createRealMatrix(V);\n            cachedV = MatrixUtils.createRealMatrix(U);\n        }\n    }",
          "60": "    public SingularValueDecomposition(final RealMatrix matrix) {\n        final double[][] A;\n\n         // \"m\" is always the largest dimension.\n        if (matrix.getRowDimension() < matrix.getColumnDimension()) {\n            transposed = true;\n            A = matrix.transpose().getData();\n            m = matrix.getColumnDimension();\n            n = matrix.getRowDimension();\n        } else {\n            transposed = false;\n            A = matrix.getData();\n            m = matrix.getRowDimension();\n            n = matrix.getColumnDimension();\n        }\n\n        singularValues = new double[n];\n        final double[][] U = new double[m][n];\n        final double[][] V = new double[n][n];\n        final double[] e = new double[n];\n        final double[] work = new double[m];\n        // Reduce A to bidiagonal form, storing the diagonal elements\n        // in s and the super-diagonal elements in e.\n        final int nct = FastMath.min(m - 1, n);\n        final int nrt = FastMath.max(0, n - 2);\n        for (int k = 0; k < FastMath.max(nct, nrt); k++) {\n            if (k < nct) {\n                // Compute the transformation for the k-th column and\n                // place the k-th diagonal in s[k].\n                // Compute 2-norm of k-th column without under/overflow.\n                singularValues[k] = 0;\n                for (int i = k; i < m; i++) {\n                    singularValues[k] = FastMath.hypot(singularValues[k], A[i][k]);\n                }\n                if (singularValues[k] != 0) {\n                    if (A[k][k] < 0) {\nsingularValues[k] = (singularValues[k] + 0);\n                    }\n                    for (int i = k; i < m; i++) {\n                        A[i][k] /= singularValues[k];\n                    }\n                    A[k][k] += 1;\n                }\n                singularValues[k] = -singularValues[k];\n            }\n            for (int j = k + 1; j < n; j++) {\n                if (k < nct &&\n                    singularValues[k] != 0) {\n                    // Apply the transformation.\n                    double t = 0;\n                    for (int i = k; i < m; i++) {\n                        t += A[i][k] * A[i][j];\n                    }\n                    t = -t / A[k][k];\n                    for (int i = k; i < m; i++) {\n                        A[i][j] += t * A[i][k];\n                    }\n                }\n                // Place the k-th row of A into e for the\n                // subsequent calculation of the row transformation.\n                e[j] = A[k][j];\n            }\n            if (k < nct) {\n                // Place the transformation in U for subsequent back\n                // multiplication.\n                for (int i = k; i < m; i++) {\n                    U[i][k] = A[i][k];\n                }\n            }\n            if (k < nrt) {\n                // Compute the k-th row transformation and place the\n                // k-th super-diagonal in e[k].\n                // Compute 2-norm without under/overflow.\n                e[k] = 0;\n                for (int i = k + 1; i < n; i++) {\n                    e[k] = FastMath.hypot(e[k], e[i]);\n                }\n                if (e[k] != 0) {\n                    if (e[k + 1] < 0) {\n                        e[k] = -e[k];\n                    }\n                    for (int i = k + 1; i < n; i++) {\n                        e[i] /= e[k];\n                    }\n                    e[k + 1] += 1;\n                }\n                e[k] = -e[k];\n                if (k + 1 < m &&\n                    e[k] != 0) {\n                    // Apply the transformation.\n                    for (int i = k + 1; i < m; i++) {\n                        work[i] = 0;\n                    }\n                    for (int j = k + 1; j < n; j++) {\n                        for (int i = k + 1; i < m; i++) {\n                            work[i] += e[j] * A[i][j];\n                        }\n                    }\n                    for (int j = k + 1; j < n; j++) {\n                        final double t = -e[j] / e[k + 1];\n                        for (int i = k + 1; i < m; i++) {\n                            A[i][j] += t * work[i];\n                        }\n                    }\n                }\n\n                // Place the transformation in V for subsequent\n                // back multiplication.\n                for (int i = k + 1; i < n; i++) {\n                    V[i][k] = e[i];\n                }\n            }\n        }\n        // Set up the final bidiagonal matrix or order p.\n        int p = n;\n        if (nct < n) {\n            singularValues[nct] = A[nct][nct];\n        }\n        if (m < p) {\n            singularValues[p - 1] = 0;\n        }\n        if (nrt + 1 < p) {\n            e[nrt] = A[nrt][p - 1];\n        }\n        e[p - 1] = 0;\n\n        // Generate U.\n        for (int j = nct; j < n; j++) {\n            for (int i = 0; i < m; i++) {\n                U[i][j] = 0;\n            }\n            U[j][j] = 1;\n        }\n        for (int k = nct - 1; k >= 0; k--) {\n            if (singularValues[k] != 0) {\n                for (int j = k + 1; j < n; j++) {\n                    double t = 0;\n                    for (int i = k; i < m; i++) {\n                        t += U[i][k] * U[i][j];\n                    }\n                    t = -t / U[k][k];\n                    for (int i = k; i < m; i++) {\n                        U[i][j] += t * U[i][k];\n                    }\n                }\n                for (int i = k; i < m; i++) {\n                    U[i][k] = -U[i][k];\n                }\n                U[k][k] = 1 + U[k][k];\n                for (int i = 0; i < k - 1; i++) {\n                    U[i][k] = 0;\n                }\n            } else {\n                for (int i = 0; i < m; i++) {\n                    U[i][k] = 0;\n                }\n                U[k][k] = 1;\n            }\n        }\n\n        // Generate V.\n        for (int k = n - 1; k >= 0; k--) {\n            if (k < nrt &&\n                e[k] != 0) {\n                for (int j = k + 1; j < n; j++) {\n                    double t = 0;\n                    for (int i = k + 1; i < n; i++) {\n                        t += V[i][k] * V[i][j];\n                    }\n                    t = -t / V[k + 1][k];\n                    for (int i = k + 1; i < n; i++) {\n                        V[i][j] += t * V[i][k];\n                    }\n                }\n            }\n            for (int i = 0; i < n; i++) {\n                V[i][k] = 0;\n            }\n            V[k][k] = 1;\n        }\n\n        // Main iteration loop for the singular values.\n        final int pp = p - 1;\n        int iter = 0;\n        while (p > 0) {\n            int k;\n            int kase;\n            // Here is where a test for too many iterations would go.\n            // This section of the program inspects for\n            // negligible elements in the s and e arrays.  On\n            // completion the variables kase and k are set as follows.\n            // kase = 1     if s(p) and e[k-1] are negligible and k<p\n            // kase = 2     if s(k) is negligible and k<p\n            // kase = 3     if e[k-1] is negligible, k<p, and\n            //              s(k), ..., s(p) are not negligible (qr step).\n            // kase = 4     if e(p-1) is negligible (convergence).\n            for (k = p - 2; k >= 0; k--) {\n                final double threshold\n                    = TINY + EPS * (FastMath.abs(singularValues[k]) +\n                                    FastMath.abs(singularValues[k + 1]));\n\n                // the following condition is written this way in order\n                // to break out of the loop when NaN occurs, writing it\n                // as \"if (FastMath.abs(e[k]) <= threshold)\" would loop\n                // indefinitely in case of NaNs because comparison on NaNs\n                // always return false, regardless of what is checked\n                // see issue MATH-947\n                if (!(FastMath.abs(e[k]) > threshold)) {\n                    e[k] = 0;\n                    break;\n                }\n\n            }\n\n            if (k == p - 2) {\n                kase = 4;\n            } else {\n                int ks;\n                for (ks = p - 1; ks >= k; ks--) {\n                    if (ks == k) {\n                        break;\n                    }\n                    final double t = (ks != p ? FastMath.abs(e[ks]) : 0) +\n                        (ks != k + 1 ? FastMath.abs(e[ks - 1]) : 0);\n                    if (FastMath.abs(singularValues[ks]) <= TINY + EPS * t) {\n                        singularValues[ks] = 0;\n                        break;\n                    }\n                }\n                if (ks == k) {\n                    kase = 3;\n                } else if (ks == p - 1) {\n                    kase = 1;\n                } else {\n                    kase = 2;\n                    k = ks;\n                }\n            }\n            k++;\n            // Perform the task indicated by kase.\n            switch (kase) {\n                // Deflate negligible s(p).\n                case 1: {\n                    double f = e[p - 2];\n                    e[p - 2] = 0;\n                    for (int j = p - 2; j >= k; j--) {\n                        double t = FastMath.hypot(singularValues[j], f);\n                        final double cs = singularValues[j] / t;\n                        final double sn = f / t;\n                        singularValues[j] = t;\n                        if (j != k) {\n                            f = -sn * e[j - 1];\n                            e[j - 1] = cs * e[j - 1];\n                        }\n\n                        for (int i = 0; i < n; i++) {\n                            t = cs * V[i][j] + sn * V[i][p - 1];\n                            V[i][p - 1] = -sn * V[i][j] + cs * V[i][p - 1];\n                            V[i][j] = t;\n                        }\n                    }\n                }\n                break;\n                // Split at negligible s(k).\n                case 2: {\n                    double f = e[k - 1];\n                    e[k - 1] = 0;\n                    for (int j = k; j < p; j++) {\n                        double t = FastMath.hypot(singularValues[j], f);\n                        final double cs = singularValues[j] / t;\n                        final double sn = f / t;\n                        singularValues[j] = t;\n                        f = -sn * e[j];\n                        e[j] = cs * e[j];\n\n                        for (int i = 0; i < m; i++) {\n                            t = cs * U[i][j] + sn * U[i][k - 1];\n                            U[i][k - 1] = -sn * U[i][j] + cs * U[i][k - 1];\n                            U[i][j] = t;\n                        }\n                    }\n                }\n                break;\n                // Perform one qr step.\n                case 3: {\n                    // Calculate the shift.\n                    final double maxPm1Pm2 = FastMath.max(FastMath.abs(singularValues[p - 1]),\n                                                          FastMath.abs(singularValues[p - 2]));\n                    final double scale = FastMath.max(FastMath.max(FastMath.max(maxPm1Pm2,\n                                                                                FastMath.abs(e[p - 2])),\n                                                                   FastMath.abs(singularValues[k])),\n                                                      FastMath.abs(e[k]));\n                    final double sp = singularValues[p - 1] / scale;\n                    final double spm1 = singularValues[p - 2] / scale;\n                    final double epm1 = e[p - 2] / scale;\n                    final double sk = singularValues[k] / scale;\n                    final double ek = e[k] / scale;\n                    final double b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2.0;\n                    final double c = (sp * epm1) * (sp * epm1);\n                    double shift = 0;\n                    if (b != 0 ||\n                        c != 0) {\n                        shift = FastMath.sqrt(b * b + c);\n                        if (b < 0) {\n                            shift = -shift;\n                        }\n                        shift = c / (b + shift);\n                    }\n                    double f = (sk + sp) * (sk - sp) + shift;\n                    double g = sk * ek;\n                    // Chase zeros.\n                    for (int j = k; j < p - 1; j++) {\n                        double t = FastMath.hypot(f, g);\n                        double cs = f / t;\n                        double sn = g / t;\n                        if (j != k) {\n                            e[j - 1] = t;\n                        }\n                        f = cs * singularValues[j] + sn * e[j];\n                        e[j] = cs * e[j] - sn * singularValues[j];\n                        g = sn * singularValues[j + 1];\n                        singularValues[j + 1] = cs * singularValues[j + 1];\n\n                        for (int i = 0; i < n; i++) {\n                            t = cs * V[i][j] + sn * V[i][j + 1];\n                            V[i][j + 1] = -sn * V[i][j] + cs * V[i][j + 1];\n                            V[i][j] = t;\n                        }\n                        t = FastMath.hypot(f, g);\n                        cs = f / t;\n                        sn = g / t;\n                        singularValues[j] = t;\n                        f = cs * e[j] + sn * singularValues[j + 1];\n                        singularValues[j + 1] = -sn * e[j] + cs * singularValues[j + 1];\n                        g = sn * e[j + 1];\n                        e[j + 1] = cs * e[j + 1];\n                        if (j < m - 1) {\n                            for (int i = 0; i < m; i++) {\n                                t = cs * U[i][j] + sn * U[i][j + 1];\n                                U[i][j + 1] = -sn * U[i][j] + cs * U[i][j + 1];\n                                U[i][j] = t;\n                            }\n                        }\n                    }\n                    e[p - 2] = f;\n                    iter = iter + 1;\n                }\n                break;\n                // Convergence.\n                default: {\n                    // Make the singular values positive.\n                    if (singularValues[k] <= 0) {\n                        singularValues[k] = singularValues[k] < 0 ? -singularValues[k] : 0;\n\n                        for (int i = 0; i <= pp; i++) {\n                            V[i][k] = -V[i][k];\n                        }\n                    }\n                    // Order the singular values.\n                    while (k < pp) {\n                        if (singularValues[k] >= singularValues[k + 1]) {\n                            break;\n                        }\n                        double t = singularValues[k];\n                        singularValues[k] = singularValues[k + 1];\n                        singularValues[k + 1] = t;\n                        if (k < n - 1) {\n                            for (int i = 0; i < n; i++) {\n                                t = V[i][k + 1];\n                                V[i][k + 1] = V[i][k];\n                                V[i][k] = t;\n                            }\n                        }\n                        if (k < m - 1) {\n                            for (int i = 0; i < m; i++) {\n                                t = U[i][k + 1];\n                                U[i][k + 1] = U[i][k];\n                                U[i][k] = t;\n                            }\n                        }\n                        k++;\n                    }\n                    iter = 0;\n                    p--;\n                }\n                break;\n            }\n        }\n\n        // Set the small value tolerance used to calculate rank and pseudo-inverse\n        tol = FastMath.max(m * singularValues[0] * EPS,\n                           FastMath.sqrt(Precision.SAFE_MIN));\n\n        if (!transposed) {\n            cachedU = MatrixUtils.createRealMatrix(U);\n            cachedV = MatrixUtils.createRealMatrix(V);\n        } else {\n            cachedU = MatrixUtils.createRealMatrix(V);\n            cachedV = MatrixUtils.createRealMatrix(U);\n        }\n    }",
          "61": "    public SingularValueDecomposition(final RealMatrix matrix) {\n        final double[][] A;\n\n         // \"m\" is always the largest dimension.\n        if (matrix.getRowDimension() < matrix.getColumnDimension()) {\n            transposed = true;\n            A = matrix.transpose().getData();\n            m = matrix.getColumnDimension();\n            n = matrix.getRowDimension();\n        } else {\n            transposed = false;\n            A = matrix.getData();\n            m = matrix.getRowDimension();\n            n = matrix.getColumnDimension();\n        }\n\n        singularValues = new double[n];\n        final double[][] U = new double[m][n];\n        final double[][] V = new double[n][n];\n        final double[] e = new double[n];\n        final double[] work = new double[m];\n        // Reduce A to bidiagonal form, storing the diagonal elements\n        // in s and the super-diagonal elements in e.\n        final int nct = FastMath.min(m - 1, n);\n        final int nrt = FastMath.max(0, n - 2);\n        for (int k = 0; k < FastMath.max(nct, nrt); k++) {\n            if (k < nct) {\n                // Compute the transformation for the k-th column and\n                // place the k-th diagonal in s[k].\n                // Compute 2-norm of k-th column without under/overflow.\n                singularValues[k] = 0;\n                for (int i = k; i < m; i++) {\n                    singularValues[k] = FastMath.hypot(singularValues[k], A[i][k]);\n                }\n                if (singularValues[k] != 0) {\n                    if (A[k][k] < 0) {\nsingularValues[k] = ((singularValues[k] == null))?0:singularValues[k];\n                    }\n                    for (int i = k; i < m; i++) {\n                        A[i][k] /= singularValues[k];\n                    }\n                    A[k][k] += 1;\n                }\n                singularValues[k] = -singularValues[k];\n            }\n            for (int j = k + 1; j < n; j++) {\n                if (k < nct &&\n                    singularValues[k] != 0) {\n                    // Apply the transformation.\n                    double t = 0;\n                    for (int i = k; i < m; i++) {\n                        t += A[i][k] * A[i][j];\n                    }\n                    t = -t / A[k][k];\n                    for (int i = k; i < m; i++) {\n                        A[i][j] += t * A[i][k];\n                    }\n                }\n                // Place the k-th row of A into e for the\n                // subsequent calculation of the row transformation.\n                e[j] = A[k][j];\n            }\n            if (k < nct) {\n                // Place the transformation in U for subsequent back\n                // multiplication.\n                for (int i = k; i < m; i++) {\n                    U[i][k] = A[i][k];\n                }\n            }\n            if (k < nrt) {\n                // Compute the k-th row transformation and place the\n                // k-th super-diagonal in e[k].\n                // Compute 2-norm without under/overflow.\n                e[k] = 0;\n                for (int i = k + 1; i < n; i++) {\n                    e[k] = FastMath.hypot(e[k], e[i]);\n                }\n                if (e[k] != 0) {\n                    if (e[k + 1] < 0) {\n                        e[k] = -e[k];\n                    }\n                    for (int i = k + 1; i < n; i++) {\n                        e[i] /= e[k];\n                    }\n                    e[k + 1] += 1;\n                }\n                e[k] = -e[k];\n                if (k + 1 < m &&\n                    e[k] != 0) {\n                    // Apply the transformation.\n                    for (int i = k + 1; i < m; i++) {\n                        work[i] = 0;\n                    }\n                    for (int j = k + 1; j < n; j++) {\n                        for (int i = k + 1; i < m; i++) {\n                            work[i] += e[j] * A[i][j];\n                        }\n                    }\n                    for (int j = k + 1; j < n; j++) {\n                        final double t = -e[j] / e[k + 1];\n                        for (int i = k + 1; i < m; i++) {\n                            A[i][j] += t * work[i];\n                        }\n                    }\n                }\n\n                // Place the transformation in V for subsequent\n                // back multiplication.\n                for (int i = k + 1; i < n; i++) {\n                    V[i][k] = e[i];\n                }\n            }\n        }\n        // Set up the final bidiagonal matrix or order p.\n        int p = n;\n        if (nct < n) {\n            singularValues[nct] = A[nct][nct];\n        }\n        if (m < p) {\n            singularValues[p - 1] = 0;\n        }\n        if (nrt + 1 < p) {\n            e[nrt] = A[nrt][p - 1];\n        }\n        e[p - 1] = 0;\n\n        // Generate U.\n        for (int j = nct; j < n; j++) {\n            for (int i = 0; i < m; i++) {\n                U[i][j] = 0;\n            }\n            U[j][j] = 1;\n        }\n        for (int k = nct - 1; k >= 0; k--) {\n            if (singularValues[k] != 0) {\n                for (int j = k + 1; j < n; j++) {\n                    double t = 0;\n                    for (int i = k; i < m; i++) {\n                        t += U[i][k] * U[i][j];\n                    }\n                    t = -t / U[k][k];\n                    for (int i = k; i < m; i++) {\n                        U[i][j] += t * U[i][k];\n                    }\n                }\n                for (int i = k; i < m; i++) {\n                    U[i][k] = -U[i][k];\n                }\n                U[k][k] = 1 + U[k][k];\n                for (int i = 0; i < k - 1; i++) {\n                    U[i][k] = 0;\n                }\n            } else {\n                for (int i = 0; i < m; i++) {\n                    U[i][k] = 0;\n                }\n                U[k][k] = 1;\n            }\n        }\n\n        // Generate V.\n        for (int k = n - 1; k >= 0; k--) {\n            if (k < nrt &&\n                e[k] != 0) {\n                for (int j = k + 1; j < n; j++) {\n                    double t = 0;\n                    for (int i = k + 1; i < n; i++) {\n                        t += V[i][k] * V[i][j];\n                    }\n                    t = -t / V[k + 1][k];\n                    for (int i = k + 1; i < n; i++) {\n                        V[i][j] += t * V[i][k];\n                    }\n                }\n            }\n            for (int i = 0; i < n; i++) {\n                V[i][k] = 0;\n            }\n            V[k][k] = 1;\n        }\n\n        // Main iteration loop for the singular values.\n        final int pp = p - 1;\n        int iter = 0;\n        while (p > 0) {\n            int k;\n            int kase;\n            // Here is where a test for too many iterations would go.\n            // This section of the program inspects for\n            // negligible elements in the s and e arrays.  On\n            // completion the variables kase and k are set as follows.\n            // kase = 1     if s(p) and e[k-1] are negligible and k<p\n            // kase = 2     if s(k) is negligible and k<p\n            // kase = 3     if e[k-1] is negligible, k<p, and\n            //              s(k), ..., s(p) are not negligible (qr step).\n            // kase = 4     if e(p-1) is negligible (convergence).\n            for (k = p - 2; k >= 0; k--) {\n                final double threshold\n                    = TINY + EPS * (FastMath.abs(singularValues[k]) +\n                                    FastMath.abs(singularValues[k + 1]));\n\n                // the following condition is written this way in order\n                // to break out of the loop when NaN occurs, writing it\n                // as \"if (FastMath.abs(e[k]) <= threshold)\" would loop\n                // indefinitely in case of NaNs because comparison on NaNs\n                // always return false, regardless of what is checked\n                // see issue MATH-947\n                if (!(FastMath.abs(e[k]) > threshold)) {\n                    e[k] = 0;\n                    break;\n                }\n\n            }\n\n            if (k == p - 2) {\n                kase = 4;\n            } else {\n                int ks;\n                for (ks = p - 1; ks >= k; ks--) {\n                    if (ks == k) {\n                        break;\n                    }\n                    final double t = (ks != p ? FastMath.abs(e[ks]) : 0) +\n                        (ks != k + 1 ? FastMath.abs(e[ks - 1]) : 0);\n                    if (FastMath.abs(singularValues[ks]) <= TINY + EPS * t) {\n                        singularValues[ks] = 0;\n                        break;\n                    }\n                }\n                if (ks == k) {\n                    kase = 3;\n                } else if (ks == p - 1) {\n                    kase = 1;\n                } else {\n                    kase = 2;\n                    k = ks;\n                }\n            }\n            k++;\n            // Perform the task indicated by kase.\n            switch (kase) {\n                // Deflate negligible s(p).\n                case 1: {\n                    double f = e[p - 2];\n                    e[p - 2] = 0;\n                    for (int j = p - 2; j >= k; j--) {\n                        double t = FastMath.hypot(singularValues[j], f);\n                        final double cs = singularValues[j] / t;\n                        final double sn = f / t;\n                        singularValues[j] = t;\n                        if (j != k) {\n                            f = -sn * e[j - 1];\n                            e[j - 1] = cs * e[j - 1];\n                        }\n\n                        for (int i = 0; i < n; i++) {\n                            t = cs * V[i][j] + sn * V[i][p - 1];\n                            V[i][p - 1] = -sn * V[i][j] + cs * V[i][p - 1];\n                            V[i][j] = t;\n                        }\n                    }\n                }\n                break;\n                // Split at negligible s(k).\n                case 2: {\n                    double f = e[k - 1];\n                    e[k - 1] = 0;\n                    for (int j = k; j < p; j++) {\n                        double t = FastMath.hypot(singularValues[j], f);\n                        final double cs = singularValues[j] / t;\n                        final double sn = f / t;\n                        singularValues[j] = t;\n                        f = -sn * e[j];\n                        e[j] = cs * e[j];\n\n                        for (int i = 0; i < m; i++) {\n                            t = cs * U[i][j] + sn * U[i][k - 1];\n                            U[i][k - 1] = -sn * U[i][j] + cs * U[i][k - 1];\n                            U[i][j] = t;\n                        }\n                    }\n                }\n                break;\n                // Perform one qr step.\n                case 3: {\n                    // Calculate the shift.\n                    final double maxPm1Pm2 = FastMath.max(FastMath.abs(singularValues[p - 1]),\n                                                          FastMath.abs(singularValues[p - 2]));\n                    final double scale = FastMath.max(FastMath.max(FastMath.max(maxPm1Pm2,\n                                                                                FastMath.abs(e[p - 2])),\n                                                                   FastMath.abs(singularValues[k])),\n                                                      FastMath.abs(e[k]));\n                    final double sp = singularValues[p - 1] / scale;\n                    final double spm1 = singularValues[p - 2] / scale;\n                    final double epm1 = e[p - 2] / scale;\n                    final double sk = singularValues[k] / scale;\n                    final double ek = e[k] / scale;\n                    final double b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2.0;\n                    final double c = (sp * epm1) * (sp * epm1);\n                    double shift = 0;\n                    if (b != 0 ||\n                        c != 0) {\n                        shift = FastMath.sqrt(b * b + c);\n                        if (b < 0) {\n                            shift = -shift;\n                        }\n                        shift = c / (b + shift);\n                    }\n                    double f = (sk + sp) * (sk - sp) + shift;\n                    double g = sk * ek;\n                    // Chase zeros.\n                    for (int j = k; j < p - 1; j++) {\n                        double t = FastMath.hypot(f, g);\n                        double cs = f / t;\n                        double sn = g / t;\n                        if (j != k) {\n                            e[j - 1] = t;\n                        }\n                        f = cs * singularValues[j] + sn * e[j];\n                        e[j] = cs * e[j] - sn * singularValues[j];\n                        g = sn * singularValues[j + 1];\n                        singularValues[j + 1] = cs * singularValues[j + 1];\n\n                        for (int i = 0; i < n; i++) {\n                            t = cs * V[i][j] + sn * V[i][j + 1];\n                            V[i][j + 1] = -sn * V[i][j] + cs * V[i][j + 1];\n                            V[i][j] = t;\n                        }\n                        t = FastMath.hypot(f, g);\n                        cs = f / t;\n                        sn = g / t;\n                        singularValues[j] = t;\n                        f = cs * e[j] + sn * singularValues[j + 1];\n                        singularValues[j + 1] = -sn * e[j] + cs * singularValues[j + 1];\n                        g = sn * e[j + 1];\n                        e[j + 1] = cs * e[j + 1];\n                        if (j < m - 1) {\n                            for (int i = 0; i < m; i++) {\n                                t = cs * U[i][j] + sn * U[i][j + 1];\n                                U[i][j + 1] = -sn * U[i][j] + cs * U[i][j + 1];\n                                U[i][j] = t;\n                            }\n                        }\n                    }\n                    e[p - 2] = f;\n                    iter = iter + 1;\n                }\n                break;\n                // Convergence.\n                default: {\n                    // Make the singular values positive.\n                    if (singularValues[k] <= 0) {\n                        singularValues[k] = singularValues[k] < 0 ? -singularValues[k] : 0;\n\n                        for (int i = 0; i <= pp; i++) {\n                            V[i][k] = -V[i][k];\n                        }\n                    }\n                    // Order the singular values.\n                    while (k < pp) {\n                        if (singularValues[k] >= singularValues[k + 1]) {\n                            break;\n                        }\n                        double t = singularValues[k];\n                        singularValues[k] = singularValues[k + 1];\n                        singularValues[k + 1] = t;\n                        if (k < n - 1) {\n                            for (int i = 0; i < n; i++) {\n                                t = V[i][k + 1];\n                                V[i][k + 1] = V[i][k];\n                                V[i][k] = t;\n                            }\n                        }\n                        if (k < m - 1) {\n                            for (int i = 0; i < m; i++) {\n                                t = U[i][k + 1];\n                                U[i][k + 1] = U[i][k];\n                                U[i][k] = t;\n                            }\n                        }\n                        k++;\n                    }\n                    iter = 0;\n                    p--;\n                }\n                break;\n            }\n        }\n\n        // Set the small value tolerance used to calculate rank and pseudo-inverse\n        tol = FastMath.max(m * singularValues[0] * EPS,\n                           FastMath.sqrt(Precision.SAFE_MIN));\n\n        if (!transposed) {\n            cachedU = MatrixUtils.createRealMatrix(U);\n            cachedV = MatrixUtils.createRealMatrix(V);\n        } else {\n            cachedU = MatrixUtils.createRealMatrix(V);\n            cachedV = MatrixUtils.createRealMatrix(U);\n        }\n    }",
          "62": "    public SingularValueDecomposition(final RealMatrix matrix) {\n        final double[][] A;\n\n         // \"m\" is always the largest dimension.\n        if (matrix.getRowDimension() < matrix.getColumnDimension()) {\n            transposed = true;\n            A = matrix.transpose().getData();\n            m = matrix.getColumnDimension();\n            n = matrix.getRowDimension();\n        } else {\n            transposed = false;\n            A = matrix.getData();\n            m = matrix.getRowDimension();\n            n = matrix.getColumnDimension();\n        }\n\n        singularValues = new double[n];\n        final double[][] U = new double[m][n];\n        final double[][] V = new double[n][n];\n        final double[] e = new double[n];\n        final double[] work = new double[m];\n        // Reduce A to bidiagonal form, storing the diagonal elements\n        // in s and the super-diagonal elements in e.\n        final int nct = FastMath.min(m - 1, n);\n        final int nrt = FastMath.max(0, n - 2);\n        for (int k = 0; k < FastMath.max(nct, nrt); k++) {\n            if (k < nct) {\n                // Compute the transformation for the k-th column and\n                // place the k-th diagonal in s[k].\n                // Compute 2-norm of k-th column without under/overflow.\n                singularValues[k] = 0;\n                for (int i = k; i < m; i++) {\n                    singularValues[k] = FastMath.hypot(singularValues[k], A[i][k]);\n                }\n                if (singularValues[k] != 0) {\n                    if (A[k][k] < 0) {\nsingularValues[k] = ((singularValues[k] != null))?0:singularValues[k];\n                    }\n                    for (int i = k; i < m; i++) {\n                        A[i][k] /= singularValues[k];\n                    }\n                    A[k][k] += 1;\n                }\n                singularValues[k] = -singularValues[k];\n            }\n            for (int j = k + 1; j < n; j++) {\n                if (k < nct &&\n                    singularValues[k] != 0) {\n                    // Apply the transformation.\n                    double t = 0;\n                    for (int i = k; i < m; i++) {\n                        t += A[i][k] * A[i][j];\n                    }\n                    t = -t / A[k][k];\n                    for (int i = k; i < m; i++) {\n                        A[i][j] += t * A[i][k];\n                    }\n                }\n                // Place the k-th row of A into e for the\n                // subsequent calculation of the row transformation.\n                e[j] = A[k][j];\n            }\n            if (k < nct) {\n                // Place the transformation in U for subsequent back\n                // multiplication.\n                for (int i = k; i < m; i++) {\n                    U[i][k] = A[i][k];\n                }\n            }\n            if (k < nrt) {\n                // Compute the k-th row transformation and place the\n                // k-th super-diagonal in e[k].\n                // Compute 2-norm without under/overflow.\n                e[k] = 0;\n                for (int i = k + 1; i < n; i++) {\n                    e[k] = FastMath.hypot(e[k], e[i]);\n                }\n                if (e[k] != 0) {\n                    if (e[k + 1] < 0) {\n                        e[k] = -e[k];\n                    }\n                    for (int i = k + 1; i < n; i++) {\n                        e[i] /= e[k];\n                    }\n                    e[k + 1] += 1;\n                }\n                e[k] = -e[k];\n                if (k + 1 < m &&\n                    e[k] != 0) {\n                    // Apply the transformation.\n                    for (int i = k + 1; i < m; i++) {\n                        work[i] = 0;\n                    }\n                    for (int j = k + 1; j < n; j++) {\n                        for (int i = k + 1; i < m; i++) {\n                            work[i] += e[j] * A[i][j];\n                        }\n                    }\n                    for (int j = k + 1; j < n; j++) {\n                        final double t = -e[j] / e[k + 1];\n                        for (int i = k + 1; i < m; i++) {\n                            A[i][j] += t * work[i];\n                        }\n                    }\n                }\n\n                // Place the transformation in V for subsequent\n                // back multiplication.\n                for (int i = k + 1; i < n; i++) {\n                    V[i][k] = e[i];\n                }\n            }\n        }\n        // Set up the final bidiagonal matrix or order p.\n        int p = n;\n        if (nct < n) {\n            singularValues[nct] = A[nct][nct];\n        }\n        if (m < p) {\n            singularValues[p - 1] = 0;\n        }\n        if (nrt + 1 < p) {\n            e[nrt] = A[nrt][p - 1];\n        }\n        e[p - 1] = 0;\n\n        // Generate U.\n        for (int j = nct; j < n; j++) {\n            for (int i = 0; i < m; i++) {\n                U[i][j] = 0;\n            }\n            U[j][j] = 1;\n        }\n        for (int k = nct - 1; k >= 0; k--) {\n            if (singularValues[k] != 0) {\n                for (int j = k + 1; j < n; j++) {\n                    double t = 0;\n                    for (int i = k; i < m; i++) {\n                        t += U[i][k] * U[i][j];\n                    }\n                    t = -t / U[k][k];\n                    for (int i = k; i < m; i++) {\n                        U[i][j] += t * U[i][k];\n                    }\n                }\n                for (int i = k; i < m; i++) {\n                    U[i][k] = -U[i][k];\n                }\n                U[k][k] = 1 + U[k][k];\n                for (int i = 0; i < k - 1; i++) {\n                    U[i][k] = 0;\n                }\n            } else {\n                for (int i = 0; i < m; i++) {\n                    U[i][k] = 0;\n                }\n                U[k][k] = 1;\n            }\n        }\n\n        // Generate V.\n        for (int k = n - 1; k >= 0; k--) {\n            if (k < nrt &&\n                e[k] != 0) {\n                for (int j = k + 1; j < n; j++) {\n                    double t = 0;\n                    for (int i = k + 1; i < n; i++) {\n                        t += V[i][k] * V[i][j];\n                    }\n                    t = -t / V[k + 1][k];\n                    for (int i = k + 1; i < n; i++) {\n                        V[i][j] += t * V[i][k];\n                    }\n                }\n            }\n            for (int i = 0; i < n; i++) {\n                V[i][k] = 0;\n            }\n            V[k][k] = 1;\n        }\n\n        // Main iteration loop for the singular values.\n        final int pp = p - 1;\n        int iter = 0;\n        while (p > 0) {\n            int k;\n            int kase;\n            // Here is where a test for too many iterations would go.\n            // This section of the program inspects for\n            // negligible elements in the s and e arrays.  On\n            // completion the variables kase and k are set as follows.\n            // kase = 1     if s(p) and e[k-1] are negligible and k<p\n            // kase = 2     if s(k) is negligible and k<p\n            // kase = 3     if e[k-1] is negligible, k<p, and\n            //              s(k), ..., s(p) are not negligible (qr step).\n            // kase = 4     if e(p-1) is negligible (convergence).\n            for (k = p - 2; k >= 0; k--) {\n                final double threshold\n                    = TINY + EPS * (FastMath.abs(singularValues[k]) +\n                                    FastMath.abs(singularValues[k + 1]));\n\n                // the following condition is written this way in order\n                // to break out of the loop when NaN occurs, writing it\n                // as \"if (FastMath.abs(e[k]) <= threshold)\" would loop\n                // indefinitely in case of NaNs because comparison on NaNs\n                // always return false, regardless of what is checked\n                // see issue MATH-947\n                if (!(FastMath.abs(e[k]) > threshold)) {\n                    e[k] = 0;\n                    break;\n                }\n\n            }\n\n            if (k == p - 2) {\n                kase = 4;\n            } else {\n                int ks;\n                for (ks = p - 1; ks >= k; ks--) {\n                    if (ks == k) {\n                        break;\n                    }\n                    final double t = (ks != p ? FastMath.abs(e[ks]) : 0) +\n                        (ks != k + 1 ? FastMath.abs(e[ks - 1]) : 0);\n                    if (FastMath.abs(singularValues[ks]) <= TINY + EPS * t) {\n                        singularValues[ks] = 0;\n                        break;\n                    }\n                }\n                if (ks == k) {\n                    kase = 3;\n                } else if (ks == p - 1) {\n                    kase = 1;\n                } else {\n                    kase = 2;\n                    k = ks;\n                }\n            }\n            k++;\n            // Perform the task indicated by kase.\n            switch (kase) {\n                // Deflate negligible s(p).\n                case 1: {\n                    double f = e[p - 2];\n                    e[p - 2] = 0;\n                    for (int j = p - 2; j >= k; j--) {\n                        double t = FastMath.hypot(singularValues[j], f);\n                        final double cs = singularValues[j] / t;\n                        final double sn = f / t;\n                        singularValues[j] = t;\n                        if (j != k) {\n                            f = -sn * e[j - 1];\n                            e[j - 1] = cs * e[j - 1];\n                        }\n\n                        for (int i = 0; i < n; i++) {\n                            t = cs * V[i][j] + sn * V[i][p - 1];\n                            V[i][p - 1] = -sn * V[i][j] + cs * V[i][p - 1];\n                            V[i][j] = t;\n                        }\n                    }\n                }\n                break;\n                // Split at negligible s(k).\n                case 2: {\n                    double f = e[k - 1];\n                    e[k - 1] = 0;\n                    for (int j = k; j < p; j++) {\n                        double t = FastMath.hypot(singularValues[j], f);\n                        final double cs = singularValues[j] / t;\n                        final double sn = f / t;\n                        singularValues[j] = t;\n                        f = -sn * e[j];\n                        e[j] = cs * e[j];\n\n                        for (int i = 0; i < m; i++) {\n                            t = cs * U[i][j] + sn * U[i][k - 1];\n                            U[i][k - 1] = -sn * U[i][j] + cs * U[i][k - 1];\n                            U[i][j] = t;\n                        }\n                    }\n                }\n                break;\n                // Perform one qr step.\n                case 3: {\n                    // Calculate the shift.\n                    final double maxPm1Pm2 = FastMath.max(FastMath.abs(singularValues[p - 1]),\n                                                          FastMath.abs(singularValues[p - 2]));\n                    final double scale = FastMath.max(FastMath.max(FastMath.max(maxPm1Pm2,\n                                                                                FastMath.abs(e[p - 2])),\n                                                                   FastMath.abs(singularValues[k])),\n                                                      FastMath.abs(e[k]));\n                    final double sp = singularValues[p - 1] / scale;\n                    final double spm1 = singularValues[p - 2] / scale;\n                    final double epm1 = e[p - 2] / scale;\n                    final double sk = singularValues[k] / scale;\n                    final double ek = e[k] / scale;\n                    final double b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2.0;\n                    final double c = (sp * epm1) * (sp * epm1);\n                    double shift = 0;\n                    if (b != 0 ||\n                        c != 0) {\n                        shift = FastMath.sqrt(b * b + c);\n                        if (b < 0) {\n                            shift = -shift;\n                        }\n                        shift = c / (b + shift);\n                    }\n                    double f = (sk + sp) * (sk - sp) + shift;\n                    double g = sk * ek;\n                    // Chase zeros.\n                    for (int j = k; j < p - 1; j++) {\n                        double t = FastMath.hypot(f, g);\n                        double cs = f / t;\n                        double sn = g / t;\n                        if (j != k) {\n                            e[j - 1] = t;\n                        }\n                        f = cs * singularValues[j] + sn * e[j];\n                        e[j] = cs * e[j] - sn * singularValues[j];\n                        g = sn * singularValues[j + 1];\n                        singularValues[j + 1] = cs * singularValues[j + 1];\n\n                        for (int i = 0; i < n; i++) {\n                            t = cs * V[i][j] + sn * V[i][j + 1];\n                            V[i][j + 1] = -sn * V[i][j] + cs * V[i][j + 1];\n                            V[i][j] = t;\n                        }\n                        t = FastMath.hypot(f, g);\n                        cs = f / t;\n                        sn = g / t;\n                        singularValues[j] = t;\n                        f = cs * e[j] + sn * singularValues[j + 1];\n                        singularValues[j + 1] = -sn * e[j] + cs * singularValues[j + 1];\n                        g = sn * e[j + 1];\n                        e[j + 1] = cs * e[j + 1];\n                        if (j < m - 1) {\n                            for (int i = 0; i < m; i++) {\n                                t = cs * U[i][j] + sn * U[i][j + 1];\n                                U[i][j + 1] = -sn * U[i][j] + cs * U[i][j + 1];\n                                U[i][j] = t;\n                            }\n                        }\n                    }\n                    e[p - 2] = f;\n                    iter = iter + 1;\n                }\n                break;\n                // Convergence.\n                default: {\n                    // Make the singular values positive.\n                    if (singularValues[k] <= 0) {\n                        singularValues[k] = singularValues[k] < 0 ? -singularValues[k] : 0;\n\n                        for (int i = 0; i <= pp; i++) {\n                            V[i][k] = -V[i][k];\n                        }\n                    }\n                    // Order the singular values.\n                    while (k < pp) {\n                        if (singularValues[k] >= singularValues[k + 1]) {\n                            break;\n                        }\n                        double t = singularValues[k];\n                        singularValues[k] = singularValues[k + 1];\n                        singularValues[k + 1] = t;\n                        if (k < n - 1) {\n                            for (int i = 0; i < n; i++) {\n                                t = V[i][k + 1];\n                                V[i][k + 1] = V[i][k];\n                                V[i][k] = t;\n                            }\n                        }\n                        if (k < m - 1) {\n                            for (int i = 0; i < m; i++) {\n                                t = U[i][k + 1];\n                                U[i][k + 1] = U[i][k];\n                                U[i][k] = t;\n                            }\n                        }\n                        k++;\n                    }\n                    iter = 0;\n                    p--;\n                }\n                break;\n            }\n        }\n\n        // Set the small value tolerance used to calculate rank and pseudo-inverse\n        tol = FastMath.max(m * singularValues[0] * EPS,\n                           FastMath.sqrt(Precision.SAFE_MIN));\n\n        if (!transposed) {\n            cachedU = MatrixUtils.createRealMatrix(U);\n            cachedV = MatrixUtils.createRealMatrix(V);\n        } else {\n            cachedU = MatrixUtils.createRealMatrix(V);\n            cachedV = MatrixUtils.createRealMatrix(U);\n        }\n    }",
          "63": "    public SingularValueDecomposition(final RealMatrix matrix) {\n        final double[][] A;\n\n         // \"m\" is always the largest dimension.\n        if (matrix.getRowDimension() < matrix.getColumnDimension()) {\n            transposed = true;\n            A = matrix.transpose().getData();\n            m = matrix.getColumnDimension();\n            n = matrix.getRowDimension();\n        } else {\n            transposed = false;\n            A = matrix.getData();\n            m = matrix.getRowDimension();\n            n = matrix.getColumnDimension();\n        }\n\n        singularValues = new double[n];\n        final double[][] U = new double[m][n];\n        final double[][] V = new double[n][n];\n        final double[] e = new double[n];\n        final double[] work = new double[m];\n        // Reduce A to bidiagonal form, storing the diagonal elements\n        // in s and the super-diagonal elements in e.\n        final int nct = FastMath.min(m - 1, n);\n        final int nrt = FastMath.max(0, n - 2);\n        for (int k = 0; k < FastMath.max(nct, nrt); k++) {\n            if (k < nct) {\n                // Compute the transformation for the k-th column and\n                // place the k-th diagonal in s[k].\n                // Compute 2-norm of k-th column without under/overflow.\n                singularValues[k] = 0;\n                for (int i = k; i < m; i++) {\n                    singularValues[k] = FastMath.hypot(singularValues[k], A[i][k]);\n                }\n                if (singularValues[k] != 0) {\n                    if (A[k][k] < 0) {\nsingularValues[k] = ((singularValues[k] == null))?singularValues[k]:singularValues[k];\n                    }\n                    for (int i = k; i < m; i++) {\n                        A[i][k] /= singularValues[k];\n                    }\n                    A[k][k] += 1;\n                }\n                singularValues[k] = -singularValues[k];\n            }\n            for (int j = k + 1; j < n; j++) {\n                if (k < nct &&\n                    singularValues[k] != 0) {\n                    // Apply the transformation.\n                    double t = 0;\n                    for (int i = k; i < m; i++) {\n                        t += A[i][k] * A[i][j];\n                    }\n                    t = -t / A[k][k];\n                    for (int i = k; i < m; i++) {\n                        A[i][j] += t * A[i][k];\n                    }\n                }\n                // Place the k-th row of A into e for the\n                // subsequent calculation of the row transformation.\n                e[j] = A[k][j];\n            }\n            if (k < nct) {\n                // Place the transformation in U for subsequent back\n                // multiplication.\n                for (int i = k; i < m; i++) {\n                    U[i][k] = A[i][k];\n                }\n            }\n            if (k < nrt) {\n                // Compute the k-th row transformation and place the\n                // k-th super-diagonal in e[k].\n                // Compute 2-norm without under/overflow.\n                e[k] = 0;\n                for (int i = k + 1; i < n; i++) {\n                    e[k] = FastMath.hypot(e[k], e[i]);\n                }\n                if (e[k] != 0) {\n                    if (e[k + 1] < 0) {\n                        e[k] = -e[k];\n                    }\n                    for (int i = k + 1; i < n; i++) {\n                        e[i] /= e[k];\n                    }\n                    e[k + 1] += 1;\n                }\n                e[k] = -e[k];\n                if (k + 1 < m &&\n                    e[k] != 0) {\n                    // Apply the transformation.\n                    for (int i = k + 1; i < m; i++) {\n                        work[i] = 0;\n                    }\n                    for (int j = k + 1; j < n; j++) {\n                        for (int i = k + 1; i < m; i++) {\n                            work[i] += e[j] * A[i][j];\n                        }\n                    }\n                    for (int j = k + 1; j < n; j++) {\n                        final double t = -e[j] / e[k + 1];\n                        for (int i = k + 1; i < m; i++) {\n                            A[i][j] += t * work[i];\n                        }\n                    }\n                }\n\n                // Place the transformation in V for subsequent\n                // back multiplication.\n                for (int i = k + 1; i < n; i++) {\n                    V[i][k] = e[i];\n                }\n            }\n        }\n        // Set up the final bidiagonal matrix or order p.\n        int p = n;\n        if (nct < n) {\n            singularValues[nct] = A[nct][nct];\n        }\n        if (m < p) {\n            singularValues[p - 1] = 0;\n        }\n        if (nrt + 1 < p) {\n            e[nrt] = A[nrt][p - 1];\n        }\n        e[p - 1] = 0;\n\n        // Generate U.\n        for (int j = nct; j < n; j++) {\n            for (int i = 0; i < m; i++) {\n                U[i][j] = 0;\n            }\n            U[j][j] = 1;\n        }\n        for (int k = nct - 1; k >= 0; k--) {\n            if (singularValues[k] != 0) {\n                for (int j = k + 1; j < n; j++) {\n                    double t = 0;\n                    for (int i = k; i < m; i++) {\n                        t += U[i][k] * U[i][j];\n                    }\n                    t = -t / U[k][k];\n                    for (int i = k; i < m; i++) {\n                        U[i][j] += t * U[i][k];\n                    }\n                }\n                for (int i = k; i < m; i++) {\n                    U[i][k] = -U[i][k];\n                }\n                U[k][k] = 1 + U[k][k];\n                for (int i = 0; i < k - 1; i++) {\n                    U[i][k] = 0;\n                }\n            } else {\n                for (int i = 0; i < m; i++) {\n                    U[i][k] = 0;\n                }\n                U[k][k] = 1;\n            }\n        }\n\n        // Generate V.\n        for (int k = n - 1; k >= 0; k--) {\n            if (k < nrt &&\n                e[k] != 0) {\n                for (int j = k + 1; j < n; j++) {\n                    double t = 0;\n                    for (int i = k + 1; i < n; i++) {\n                        t += V[i][k] * V[i][j];\n                    }\n                    t = -t / V[k + 1][k];\n                    for (int i = k + 1; i < n; i++) {\n                        V[i][j] += t * V[i][k];\n                    }\n                }\n            }\n            for (int i = 0; i < n; i++) {\n                V[i][k] = 0;\n            }\n            V[k][k] = 1;\n        }\n\n        // Main iteration loop for the singular values.\n        final int pp = p - 1;\n        int iter = 0;\n        while (p > 0) {\n            int k;\n            int kase;\n            // Here is where a test for too many iterations would go.\n            // This section of the program inspects for\n            // negligible elements in the s and e arrays.  On\n            // completion the variables kase and k are set as follows.\n            // kase = 1     if s(p) and e[k-1] are negligible and k<p\n            // kase = 2     if s(k) is negligible and k<p\n            // kase = 3     if e[k-1] is negligible, k<p, and\n            //              s(k), ..., s(p) are not negligible (qr step).\n            // kase = 4     if e(p-1) is negligible (convergence).\n            for (k = p - 2; k >= 0; k--) {\n                final double threshold\n                    = TINY + EPS * (FastMath.abs(singularValues[k]) +\n                                    FastMath.abs(singularValues[k + 1]));\n\n                // the following condition is written this way in order\n                // to break out of the loop when NaN occurs, writing it\n                // as \"if (FastMath.abs(e[k]) <= threshold)\" would loop\n                // indefinitely in case of NaNs because comparison on NaNs\n                // always return false, regardless of what is checked\n                // see issue MATH-947\n                if (!(FastMath.abs(e[k]) > threshold)) {\n                    e[k] = 0;\n                    break;\n                }\n\n            }\n\n            if (k == p - 2) {\n                kase = 4;\n            } else {\n                int ks;\n                for (ks = p - 1; ks >= k; ks--) {\n                    if (ks == k) {\n                        break;\n                    }\n                    final double t = (ks != p ? FastMath.abs(e[ks]) : 0) +\n                        (ks != k + 1 ? FastMath.abs(e[ks - 1]) : 0);\n                    if (FastMath.abs(singularValues[ks]) <= TINY + EPS * t) {\n                        singularValues[ks] = 0;\n                        break;\n                    }\n                }\n                if (ks == k) {\n                    kase = 3;\n                } else if (ks == p - 1) {\n                    kase = 1;\n                } else {\n                    kase = 2;\n                    k = ks;\n                }\n            }\n            k++;\n            // Perform the task indicated by kase.\n            switch (kase) {\n                // Deflate negligible s(p).\n                case 1: {\n                    double f = e[p - 2];\n                    e[p - 2] = 0;\n                    for (int j = p - 2; j >= k; j--) {\n                        double t = FastMath.hypot(singularValues[j], f);\n                        final double cs = singularValues[j] / t;\n                        final double sn = f / t;\n                        singularValues[j] = t;\n                        if (j != k) {\n                            f = -sn * e[j - 1];\n                            e[j - 1] = cs * e[j - 1];\n                        }\n\n                        for (int i = 0; i < n; i++) {\n                            t = cs * V[i][j] + sn * V[i][p - 1];\n                            V[i][p - 1] = -sn * V[i][j] + cs * V[i][p - 1];\n                            V[i][j] = t;\n                        }\n                    }\n                }\n                break;\n                // Split at negligible s(k).\n                case 2: {\n                    double f = e[k - 1];\n                    e[k - 1] = 0;\n                    for (int j = k; j < p; j++) {\n                        double t = FastMath.hypot(singularValues[j], f);\n                        final double cs = singularValues[j] / t;\n                        final double sn = f / t;\n                        singularValues[j] = t;\n                        f = -sn * e[j];\n                        e[j] = cs * e[j];\n\n                        for (int i = 0; i < m; i++) {\n                            t = cs * U[i][j] + sn * U[i][k - 1];\n                            U[i][k - 1] = -sn * U[i][j] + cs * U[i][k - 1];\n                            U[i][j] = t;\n                        }\n                    }\n                }\n                break;\n                // Perform one qr step.\n                case 3: {\n                    // Calculate the shift.\n                    final double maxPm1Pm2 = FastMath.max(FastMath.abs(singularValues[p - 1]),\n                                                          FastMath.abs(singularValues[p - 2]));\n                    final double scale = FastMath.max(FastMath.max(FastMath.max(maxPm1Pm2,\n                                                                                FastMath.abs(e[p - 2])),\n                                                                   FastMath.abs(singularValues[k])),\n                                                      FastMath.abs(e[k]));\n                    final double sp = singularValues[p - 1] / scale;\n                    final double spm1 = singularValues[p - 2] / scale;\n                    final double epm1 = e[p - 2] / scale;\n                    final double sk = singularValues[k] / scale;\n                    final double ek = e[k] / scale;\n                    final double b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2.0;\n                    final double c = (sp * epm1) * (sp * epm1);\n                    double shift = 0;\n                    if (b != 0 ||\n                        c != 0) {\n                        shift = FastMath.sqrt(b * b + c);\n                        if (b < 0) {\n                            shift = -shift;\n                        }\n                        shift = c / (b + shift);\n                    }\n                    double f = (sk + sp) * (sk - sp) + shift;\n                    double g = sk * ek;\n                    // Chase zeros.\n                    for (int j = k; j < p - 1; j++) {\n                        double t = FastMath.hypot(f, g);\n                        double cs = f / t;\n                        double sn = g / t;\n                        if (j != k) {\n                            e[j - 1] = t;\n                        }\n                        f = cs * singularValues[j] + sn * e[j];\n                        e[j] = cs * e[j] - sn * singularValues[j];\n                        g = sn * singularValues[j + 1];\n                        singularValues[j + 1] = cs * singularValues[j + 1];\n\n                        for (int i = 0; i < n; i++) {\n                            t = cs * V[i][j] + sn * V[i][j + 1];\n                            V[i][j + 1] = -sn * V[i][j] + cs * V[i][j + 1];\n                            V[i][j] = t;\n                        }\n                        t = FastMath.hypot(f, g);\n                        cs = f / t;\n                        sn = g / t;\n                        singularValues[j] = t;\n                        f = cs * e[j] + sn * singularValues[j + 1];\n                        singularValues[j + 1] = -sn * e[j] + cs * singularValues[j + 1];\n                        g = sn * e[j + 1];\n                        e[j + 1] = cs * e[j + 1];\n                        if (j < m - 1) {\n                            for (int i = 0; i < m; i++) {\n                                t = cs * U[i][j] + sn * U[i][j + 1];\n                                U[i][j + 1] = -sn * U[i][j] + cs * U[i][j + 1];\n                                U[i][j] = t;\n                            }\n                        }\n                    }\n                    e[p - 2] = f;\n                    iter = iter + 1;\n                }\n                break;\n                // Convergence.\n                default: {\n                    // Make the singular values positive.\n                    if (singularValues[k] <= 0) {\n                        singularValues[k] = singularValues[k] < 0 ? -singularValues[k] : 0;\n\n                        for (int i = 0; i <= pp; i++) {\n                            V[i][k] = -V[i][k];\n                        }\n                    }\n                    // Order the singular values.\n                    while (k < pp) {\n                        if (singularValues[k] >= singularValues[k + 1]) {\n                            break;\n                        }\n                        double t = singularValues[k];\n                        singularValues[k] = singularValues[k + 1];\n                        singularValues[k + 1] = t;\n                        if (k < n - 1) {\n                            for (int i = 0; i < n; i++) {\n                                t = V[i][k + 1];\n                                V[i][k + 1] = V[i][k];\n                                V[i][k] = t;\n                            }\n                        }\n                        if (k < m - 1) {\n                            for (int i = 0; i < m; i++) {\n                                t = U[i][k + 1];\n                                U[i][k + 1] = U[i][k];\n                                U[i][k] = t;\n                            }\n                        }\n                        k++;\n                    }\n                    iter = 0;\n                    p--;\n                }\n                break;\n            }\n        }\n\n        // Set the small value tolerance used to calculate rank and pseudo-inverse\n        tol = FastMath.max(m * singularValues[0] * EPS,\n                           FastMath.sqrt(Precision.SAFE_MIN));\n\n        if (!transposed) {\n            cachedU = MatrixUtils.createRealMatrix(U);\n            cachedV = MatrixUtils.createRealMatrix(V);\n        } else {\n            cachedU = MatrixUtils.createRealMatrix(V);\n            cachedV = MatrixUtils.createRealMatrix(U);\n        }\n    }",
          "64": "    public SingularValueDecomposition(final RealMatrix matrix) {\n        final double[][] A;\n\n         // \"m\" is always the largest dimension.\n        if (matrix.getRowDimension() < matrix.getColumnDimension()) {\n            transposed = true;\n            A = matrix.transpose().getData();\n            m = matrix.getColumnDimension();\n            n = matrix.getRowDimension();\n        } else {\n            transposed = false;\n            A = matrix.getData();\n            m = matrix.getRowDimension();\n            n = matrix.getColumnDimension();\n        }\n\n        singularValues = new double[n];\n        final double[][] U = new double[m][n];\n        final double[][] V = new double[n][n];\n        final double[] e = new double[n];\n        final double[] work = new double[m];\n        // Reduce A to bidiagonal form, storing the diagonal elements\n        // in s and the super-diagonal elements in e.\n        final int nct = FastMath.min(m - 1, n);\n        final int nrt = FastMath.max(0, n - 2);\n        for (int k = 0; k < FastMath.max(nct, nrt); k++) {\n            if (k < nct) {\n                // Compute the transformation for the k-th column and\n                // place the k-th diagonal in s[k].\n                // Compute 2-norm of k-th column without under/overflow.\n                singularValues[k] = 0;\n                for (int i = k; i < m; i++) {\n                    singularValues[k] = FastMath.hypot(singularValues[k], A[i][k]);\n                }\n                if (singularValues[k] != 0) {\n                    if (A[k][k] < 0) {\nsingularValues[k] = ((singularValues[k] != null))?singularValues[k]:singularValues[k];\n                    }\n                    for (int i = k; i < m; i++) {\n                        A[i][k] /= singularValues[k];\n                    }\n                    A[k][k] += 1;\n                }\n                singularValues[k] = -singularValues[k];\n            }\n            for (int j = k + 1; j < n; j++) {\n                if (k < nct &&\n                    singularValues[k] != 0) {\n                    // Apply the transformation.\n                    double t = 0;\n                    for (int i = k; i < m; i++) {\n                        t += A[i][k] * A[i][j];\n                    }\n                    t = -t / A[k][k];\n                    for (int i = k; i < m; i++) {\n                        A[i][j] += t * A[i][k];\n                    }\n                }\n                // Place the k-th row of A into e for the\n                // subsequent calculation of the row transformation.\n                e[j] = A[k][j];\n            }\n            if (k < nct) {\n                // Place the transformation in U for subsequent back\n                // multiplication.\n                for (int i = k; i < m; i++) {\n                    U[i][k] = A[i][k];\n                }\n            }\n            if (k < nrt) {\n                // Compute the k-th row transformation and place the\n                // k-th super-diagonal in e[k].\n                // Compute 2-norm without under/overflow.\n                e[k] = 0;\n                for (int i = k + 1; i < n; i++) {\n                    e[k] = FastMath.hypot(e[k], e[i]);\n                }\n                if (e[k] != 0) {\n                    if (e[k + 1] < 0) {\n                        e[k] = -e[k];\n                    }\n                    for (int i = k + 1; i < n; i++) {\n                        e[i] /= e[k];\n                    }\n                    e[k + 1] += 1;\n                }\n                e[k] = -e[k];\n                if (k + 1 < m &&\n                    e[k] != 0) {\n                    // Apply the transformation.\n                    for (int i = k + 1; i < m; i++) {\n                        work[i] = 0;\n                    }\n                    for (int j = k + 1; j < n; j++) {\n                        for (int i = k + 1; i < m; i++) {\n                            work[i] += e[j] * A[i][j];\n                        }\n                    }\n                    for (int j = k + 1; j < n; j++) {\n                        final double t = -e[j] / e[k + 1];\n                        for (int i = k + 1; i < m; i++) {\n                            A[i][j] += t * work[i];\n                        }\n                    }\n                }\n\n                // Place the transformation in V for subsequent\n                // back multiplication.\n                for (int i = k + 1; i < n; i++) {\n                    V[i][k] = e[i];\n                }\n            }\n        }\n        // Set up the final bidiagonal matrix or order p.\n        int p = n;\n        if (nct < n) {\n            singularValues[nct] = A[nct][nct];\n        }\n        if (m < p) {\n            singularValues[p - 1] = 0;\n        }\n        if (nrt + 1 < p) {\n            e[nrt] = A[nrt][p - 1];\n        }\n        e[p - 1] = 0;\n\n        // Generate U.\n        for (int j = nct; j < n; j++) {\n            for (int i = 0; i < m; i++) {\n                U[i][j] = 0;\n            }\n            U[j][j] = 1;\n        }\n        for (int k = nct - 1; k >= 0; k--) {\n            if (singularValues[k] != 0) {\n                for (int j = k + 1; j < n; j++) {\n                    double t = 0;\n                    for (int i = k; i < m; i++) {\n                        t += U[i][k] * U[i][j];\n                    }\n                    t = -t / U[k][k];\n                    for (int i = k; i < m; i++) {\n                        U[i][j] += t * U[i][k];\n                    }\n                }\n                for (int i = k; i < m; i++) {\n                    U[i][k] = -U[i][k];\n                }\n                U[k][k] = 1 + U[k][k];\n                for (int i = 0; i < k - 1; i++) {\n                    U[i][k] = 0;\n                }\n            } else {\n                for (int i = 0; i < m; i++) {\n                    U[i][k] = 0;\n                }\n                U[k][k] = 1;\n            }\n        }\n\n        // Generate V.\n        for (int k = n - 1; k >= 0; k--) {\n            if (k < nrt &&\n                e[k] != 0) {\n                for (int j = k + 1; j < n; j++) {\n                    double t = 0;\n                    for (int i = k + 1; i < n; i++) {\n                        t += V[i][k] * V[i][j];\n                    }\n                    t = -t / V[k + 1][k];\n                    for (int i = k + 1; i < n; i++) {\n                        V[i][j] += t * V[i][k];\n                    }\n                }\n            }\n            for (int i = 0; i < n; i++) {\n                V[i][k] = 0;\n            }\n            V[k][k] = 1;\n        }\n\n        // Main iteration loop for the singular values.\n        final int pp = p - 1;\n        int iter = 0;\n        while (p > 0) {\n            int k;\n            int kase;\n            // Here is where a test for too many iterations would go.\n            // This section of the program inspects for\n            // negligible elements in the s and e arrays.  On\n            // completion the variables kase and k are set as follows.\n            // kase = 1     if s(p) and e[k-1] are negligible and k<p\n            // kase = 2     if s(k) is negligible and k<p\n            // kase = 3     if e[k-1] is negligible, k<p, and\n            //              s(k), ..., s(p) are not negligible (qr step).\n            // kase = 4     if e(p-1) is negligible (convergence).\n            for (k = p - 2; k >= 0; k--) {\n                final double threshold\n                    = TINY + EPS * (FastMath.abs(singularValues[k]) +\n                                    FastMath.abs(singularValues[k + 1]));\n\n                // the following condition is written this way in order\n                // to break out of the loop when NaN occurs, writing it\n                // as \"if (FastMath.abs(e[k]) <= threshold)\" would loop\n                // indefinitely in case of NaNs because comparison on NaNs\n                // always return false, regardless of what is checked\n                // see issue MATH-947\n                if (!(FastMath.abs(e[k]) > threshold)) {\n                    e[k] = 0;\n                    break;\n                }\n\n            }\n\n            if (k == p - 2) {\n                kase = 4;\n            } else {\n                int ks;\n                for (ks = p - 1; ks >= k; ks--) {\n                    if (ks == k) {\n                        break;\n                    }\n                    final double t = (ks != p ? FastMath.abs(e[ks]) : 0) +\n                        (ks != k + 1 ? FastMath.abs(e[ks - 1]) : 0);\n                    if (FastMath.abs(singularValues[ks]) <= TINY + EPS * t) {\n                        singularValues[ks] = 0;\n                        break;\n                    }\n                }\n                if (ks == k) {\n                    kase = 3;\n                } else if (ks == p - 1) {\n                    kase = 1;\n                } else {\n                    kase = 2;\n                    k = ks;\n                }\n            }\n            k++;\n            // Perform the task indicated by kase.\n            switch (kase) {\n                // Deflate negligible s(p).\n                case 1: {\n                    double f = e[p - 2];\n                    e[p - 2] = 0;\n                    for (int j = p - 2; j >= k; j--) {\n                        double t = FastMath.hypot(singularValues[j], f);\n                        final double cs = singularValues[j] / t;\n                        final double sn = f / t;\n                        singularValues[j] = t;\n                        if (j != k) {\n                            f = -sn * e[j - 1];\n                            e[j - 1] = cs * e[j - 1];\n                        }\n\n                        for (int i = 0; i < n; i++) {\n                            t = cs * V[i][j] + sn * V[i][p - 1];\n                            V[i][p - 1] = -sn * V[i][j] + cs * V[i][p - 1];\n                            V[i][j] = t;\n                        }\n                    }\n                }\n                break;\n                // Split at negligible s(k).\n                case 2: {\n                    double f = e[k - 1];\n                    e[k - 1] = 0;\n                    for (int j = k; j < p; j++) {\n                        double t = FastMath.hypot(singularValues[j], f);\n                        final double cs = singularValues[j] / t;\n                        final double sn = f / t;\n                        singularValues[j] = t;\n                        f = -sn * e[j];\n                        e[j] = cs * e[j];\n\n                        for (int i = 0; i < m; i++) {\n                            t = cs * U[i][j] + sn * U[i][k - 1];\n                            U[i][k - 1] = -sn * U[i][j] + cs * U[i][k - 1];\n                            U[i][j] = t;\n                        }\n                    }\n                }\n                break;\n                // Perform one qr step.\n                case 3: {\n                    // Calculate the shift.\n                    final double maxPm1Pm2 = FastMath.max(FastMath.abs(singularValues[p - 1]),\n                                                          FastMath.abs(singularValues[p - 2]));\n                    final double scale = FastMath.max(FastMath.max(FastMath.max(maxPm1Pm2,\n                                                                                FastMath.abs(e[p - 2])),\n                                                                   FastMath.abs(singularValues[k])),\n                                                      FastMath.abs(e[k]));\n                    final double sp = singularValues[p - 1] / scale;\n                    final double spm1 = singularValues[p - 2] / scale;\n                    final double epm1 = e[p - 2] / scale;\n                    final double sk = singularValues[k] / scale;\n                    final double ek = e[k] / scale;\n                    final double b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2.0;\n                    final double c = (sp * epm1) * (sp * epm1);\n                    double shift = 0;\n                    if (b != 0 ||\n                        c != 0) {\n                        shift = FastMath.sqrt(b * b + c);\n                        if (b < 0) {\n                            shift = -shift;\n                        }\n                        shift = c / (b + shift);\n                    }\n                    double f = (sk + sp) * (sk - sp) + shift;\n                    double g = sk * ek;\n                    // Chase zeros.\n                    for (int j = k; j < p - 1; j++) {\n                        double t = FastMath.hypot(f, g);\n                        double cs = f / t;\n                        double sn = g / t;\n                        if (j != k) {\n                            e[j - 1] = t;\n                        }\n                        f = cs * singularValues[j] + sn * e[j];\n                        e[j] = cs * e[j] - sn * singularValues[j];\n                        g = sn * singularValues[j + 1];\n                        singularValues[j + 1] = cs * singularValues[j + 1];\n\n                        for (int i = 0; i < n; i++) {\n                            t = cs * V[i][j] + sn * V[i][j + 1];\n                            V[i][j + 1] = -sn * V[i][j] + cs * V[i][j + 1];\n                            V[i][j] = t;\n                        }\n                        t = FastMath.hypot(f, g);\n                        cs = f / t;\n                        sn = g / t;\n                        singularValues[j] = t;\n                        f = cs * e[j] + sn * singularValues[j + 1];\n                        singularValues[j + 1] = -sn * e[j] + cs * singularValues[j + 1];\n                        g = sn * e[j + 1];\n                        e[j + 1] = cs * e[j + 1];\n                        if (j < m - 1) {\n                            for (int i = 0; i < m; i++) {\n                                t = cs * U[i][j] + sn * U[i][j + 1];\n                                U[i][j + 1] = -sn * U[i][j] + cs * U[i][j + 1];\n                                U[i][j] = t;\n                            }\n                        }\n                    }\n                    e[p - 2] = f;\n                    iter = iter + 1;\n                }\n                break;\n                // Convergence.\n                default: {\n                    // Make the singular values positive.\n                    if (singularValues[k] <= 0) {\n                        singularValues[k] = singularValues[k] < 0 ? -singularValues[k] : 0;\n\n                        for (int i = 0; i <= pp; i++) {\n                            V[i][k] = -V[i][k];\n                        }\n                    }\n                    // Order the singular values.\n                    while (k < pp) {\n                        if (singularValues[k] >= singularValues[k + 1]) {\n                            break;\n                        }\n                        double t = singularValues[k];\n                        singularValues[k] = singularValues[k + 1];\n                        singularValues[k + 1] = t;\n                        if (k < n - 1) {\n                            for (int i = 0; i < n; i++) {\n                                t = V[i][k + 1];\n                                V[i][k + 1] = V[i][k];\n                                V[i][k] = t;\n                            }\n                        }\n                        if (k < m - 1) {\n                            for (int i = 0; i < m; i++) {\n                                t = U[i][k + 1];\n                                U[i][k + 1] = U[i][k];\n                                U[i][k] = t;\n                            }\n                        }\n                        k++;\n                    }\n                    iter = 0;\n                    p--;\n                }\n                break;\n            }\n        }\n\n        // Set the small value tolerance used to calculate rank and pseudo-inverse\n        tol = FastMath.max(m * singularValues[0] * EPS,\n                           FastMath.sqrt(Precision.SAFE_MIN));\n\n        if (!transposed) {\n            cachedU = MatrixUtils.createRealMatrix(U);\n            cachedV = MatrixUtils.createRealMatrix(V);\n        } else {\n            cachedU = MatrixUtils.createRealMatrix(V);\n            cachedV = MatrixUtils.createRealMatrix(U);\n        }\n    }"
}