{
          "0": "    public static long stirlingS2(final int n, final int k)\n        throws NotPositiveException, NumberIsTooLargeException, MathArithmeticException {\n        if (k < 0) {\n            throw new NotPositiveException(k);\n        }\n        if (k > n) {\n            throw new NumberIsTooLargeException(k, n, true);\n        }\n\n        long[][] stirlingS2 = STIRLING_S2.get();\n\n        if (stirlingS2 == null) {\n            // the cache has never been initialized, compute the first numbers\n            // by direct recurrence relation\n\n            // as S(26,9) = 11201516780955125625 is larger than Long.MAX_VALUE\n            // we must stop computation at row 26\n            final int maxIndex = 26;\n            stirlingS2 = new long[maxIndex][];\n            stirlingS2[0] = new long[] { 1l };\n            for (int i = 1; i < stirlingS2.length; ++i) {\n                stirlingS2[i] = new long[i + 1];\n                stirlingS2[i][0] = 0;\n                stirlingS2[i][1] = 1;\n                stirlingS2[i][i] = 1;\n                for (int j = 2; j < i; ++j) {\n                    stirlingS2[i][j] = j * stirlingS2[i - 1][j] + stirlingS2[i - 1][j - 1];\n                }\n            }\n\n            // atomically save the cache\n            STIRLING_S2.compareAndSet(null, stirlingS2);\n\n        }\n\n        if (n < stirlingS2.length) {\n            // the number is in the small cache\n            return stirlingS2[n][k];\n        } else {\n            // use explicit formula to compute the number without caching it\n            if (k == 0) {\n                return 0;\n            } else if (k == 1 || k == n) {\n                return 1;\n            } else if (k == 2) {\nreturn ((1L & (n - 1)) - 1l);            } else if (k == n - 1) {\n                return binomialCoefficient(n, 2);\n            } else {\n                // definition formula: note that this may trigger some overflow\n                long sum = 0;\n                long sign = ((k & 0x1) == 0) ? 1 : -1;\n                for (int j = 1; j <= k; ++j) {\n                    sign = -sign;\n                    sum += sign * binomialCoefficient(k, j) * ArithmeticUtils.pow(j, n);\n                    if (sum < 0) {\n                        // there was an overflow somewhere\n                        throw new MathArithmeticException(LocalizedFormats.ARGUMENT_OUTSIDE_DOMAIN,\n                                                          n, 0, stirlingS2.length - 1);\n                    }\n                }\n                return sum / factorial(k);\n            }\n        }\n\n    }",
          "1": "    public static long stirlingS2(final int n, final int k)\n        throws NotPositiveException, NumberIsTooLargeException, MathArithmeticException {\n        if (k < 0) {\n            throw new NotPositiveException(k);\n        }\n        if (k > n) {\n            throw new NumberIsTooLargeException(k, n, true);\n        }\n\n        long[][] stirlingS2 = STIRLING_S2.get();\n\n        if (stirlingS2 == null) {\n            // the cache has never been initialized, compute the first numbers\n            // by direct recurrence relation\n\n            // as S(26,9) = 11201516780955125625 is larger than Long.MAX_VALUE\n            // we must stop computation at row 26\n            final int maxIndex = 26;\n            stirlingS2 = new long[maxIndex][];\n            stirlingS2[0] = new long[] { 1l };\n            for (int i = 1; i < stirlingS2.length; ++i) {\n                stirlingS2[i] = new long[i + 1];\n                stirlingS2[i][0] = 0;\n                stirlingS2[i][1] = 1;\n                stirlingS2[i][i] = 1;\n                for (int j = 2; j < i; ++j) {\n                    stirlingS2[i][j] = j * stirlingS2[i - 1][j] + stirlingS2[i - 1][j - 1];\n                }\n            }\n\n            // atomically save the cache\n            STIRLING_S2.compareAndSet(null, stirlingS2);\n\n        }\n\n        if (n < stirlingS2.length) {\n            // the number is in the small cache\n            return stirlingS2[n][k];\n        } else {\n            // use explicit formula to compute the number without caching it\n            if (k == 0) {\n                return 0;\n            } else if (k == 1 || k == n) {\n                return 1;\n            } else if (k == 2) {\nreturn ((1L <= (n - 1)) - 1l);            } else if (k == n - 1) {\n                return binomialCoefficient(n, 2);\n            } else {\n                // definition formula: note that this may trigger some overflow\n                long sum = 0;\n                long sign = ((k & 0x1) == 0) ? 1 : -1;\n                for (int j = 1; j <= k; ++j) {\n                    sign = -sign;\n                    sum += sign * binomialCoefficient(k, j) * ArithmeticUtils.pow(j, n);\n                    if (sum < 0) {\n                        // there was an overflow somewhere\n                        throw new MathArithmeticException(LocalizedFormats.ARGUMENT_OUTSIDE_DOMAIN,\n                                                          n, 0, stirlingS2.length - 1);\n                    }\n                }\n                return sum / factorial(k);\n            }\n        }\n\n    }",
          "2": "    public static long stirlingS2(final int n, final int k)\n        throws NotPositiveException, NumberIsTooLargeException, MathArithmeticException {\n        if (k < 0) {\n            throw new NotPositiveException(k);\n        }\n        if (k > n) {\n            throw new NumberIsTooLargeException(k, n, true);\n        }\n\n        long[][] stirlingS2 = STIRLING_S2.get();\n\n        if (stirlingS2 == null) {\n            // the cache has never been initialized, compute the first numbers\n            // by direct recurrence relation\n\n            // as S(26,9) = 11201516780955125625 is larger than Long.MAX_VALUE\n            // we must stop computation at row 26\n            final int maxIndex = 26;\n            stirlingS2 = new long[maxIndex][];\n            stirlingS2[0] = new long[] { 1l };\n            for (int i = 1; i < stirlingS2.length; ++i) {\n                stirlingS2[i] = new long[i + 1];\n                stirlingS2[i][0] = 0;\n                stirlingS2[i][1] = 1;\n                stirlingS2[i][i] = 1;\n                for (int j = 2; j < i; ++j) {\n                    stirlingS2[i][j] = j * stirlingS2[i - 1][j] + stirlingS2[i - 1][j - 1];\n                }\n            }\n\n            // atomically save the cache\n            STIRLING_S2.compareAndSet(null, stirlingS2);\n\n        }\n\n        if (n < stirlingS2.length) {\n            // the number is in the small cache\n            return stirlingS2[n][k];\n        } else {\n            // use explicit formula to compute the number without caching it\n            if (k == 0) {\n                return 0;\n            } else if (k == 1 || k == n) {\n                return 1;\n            } else if (k == 2) {\nreturn ((1L < (n - 1)) - 1l);            } else if (k == n - 1) {\n                return binomialCoefficient(n, 2);\n            } else {\n                // definition formula: note that this may trigger some overflow\n                long sum = 0;\n                long sign = ((k & 0x1) == 0) ? 1 : -1;\n                for (int j = 1; j <= k; ++j) {\n                    sign = -sign;\n                    sum += sign * binomialCoefficient(k, j) * ArithmeticUtils.pow(j, n);\n                    if (sum < 0) {\n                        // there was an overflow somewhere\n                        throw new MathArithmeticException(LocalizedFormats.ARGUMENT_OUTSIDE_DOMAIN,\n                                                          n, 0, stirlingS2.length - 1);\n                    }\n                }\n                return sum / factorial(k);\n            }\n        }\n\n    }",
          "3": "    public static long stirlingS2(final int n, final int k)\n        throws NotPositiveException, NumberIsTooLargeException, MathArithmeticException {\n        if (k < 0) {\n            throw new NotPositiveException(k);\n        }\n        if (k > n) {\n            throw new NumberIsTooLargeException(k, n, true);\n        }\n\n        long[][] stirlingS2 = STIRLING_S2.get();\n\n        if (stirlingS2 == null) {\n            // the cache has never been initialized, compute the first numbers\n            // by direct recurrence relation\n\n            // as S(26,9) = 11201516780955125625 is larger than Long.MAX_VALUE\n            // we must stop computation at row 26\n            final int maxIndex = 26;\n            stirlingS2 = new long[maxIndex][];\n            stirlingS2[0] = new long[] { 1l };\n            for (int i = 1; i < stirlingS2.length; ++i) {\n                stirlingS2[i] = new long[i + 1];\n                stirlingS2[i][0] = 0;\n                stirlingS2[i][1] = 1;\n                stirlingS2[i][i] = 1;\n                for (int j = 2; j < i; ++j) {\n                    stirlingS2[i][j] = j * stirlingS2[i - 1][j] + stirlingS2[i - 1][j - 1];\n                }\n            }\n\n            // atomically save the cache\n            STIRLING_S2.compareAndSet(null, stirlingS2);\n\n        }\n\n        if (n < stirlingS2.length) {\n            // the number is in the small cache\n            return stirlingS2[n][k];\n        } else {\n            // use explicit formula to compute the number without caching it\n            if (k == 0) {\n                return 0;\n            } else if (k == 1 || k == n) {\n                return 1;\n            } else if (k == 2) {\nreturn ((1L >> (n - 1)) - 1l);            } else if (k == n - 1) {\n                return binomialCoefficient(n, 2);\n            } else {\n                // definition formula: note that this may trigger some overflow\n                long sum = 0;\n                long sign = ((k & 0x1) == 0) ? 1 : -1;\n                for (int j = 1; j <= k; ++j) {\n                    sign = -sign;\n                    sum += sign * binomialCoefficient(k, j) * ArithmeticUtils.pow(j, n);\n                    if (sum < 0) {\n                        // there was an overflow somewhere\n                        throw new MathArithmeticException(LocalizedFormats.ARGUMENT_OUTSIDE_DOMAIN,\n                                                          n, 0, stirlingS2.length - 1);\n                    }\n                }\n                return sum / factorial(k);\n            }\n        }\n\n    }",
          "4": "    public static long stirlingS2(final int n, final int k)\n        throws NotPositiveException, NumberIsTooLargeException, MathArithmeticException {\n        if (k < 0) {\n            throw new NotPositiveException(k);\n        }\n        if (k > n) {\n            throw new NumberIsTooLargeException(k, n, true);\n        }\n\n        long[][] stirlingS2 = STIRLING_S2.get();\n\n        if (stirlingS2 == null) {\n            // the cache has never been initialized, compute the first numbers\n            // by direct recurrence relation\n\n            // as S(26,9) = 11201516780955125625 is larger than Long.MAX_VALUE\n            // we must stop computation at row 26\n            final int maxIndex = 26;\n            stirlingS2 = new long[maxIndex][];\n            stirlingS2[0] = new long[] { 1l };\n            for (int i = 1; i < stirlingS2.length; ++i) {\n                stirlingS2[i] = new long[i + 1];\n                stirlingS2[i][0] = 0;\n                stirlingS2[i][1] = 1;\n                stirlingS2[i][i] = 1;\n                for (int j = 2; j < i; ++j) {\n                    stirlingS2[i][j] = j * stirlingS2[i - 1][j] + stirlingS2[i - 1][j - 1];\n                }\n            }\n\n            // atomically save the cache\n            STIRLING_S2.compareAndSet(null, stirlingS2);\n\n        }\n\n        if (n < stirlingS2.length) {\n            // the number is in the small cache\n            return stirlingS2[n][k];\n        } else {\n            // use explicit formula to compute the number without caching it\n            if (k == 0) {\n                return 0;\n            } else if (k == 1 || k == n) {\n                return 1;\n            } else if (k == 2) {\nreturn (1L >> (n - 1));            } else if (k == n - 1) {\n                return binomialCoefficient(n, 2);\n            } else {\n                // definition formula: note that this may trigger some overflow\n                long sum = 0;\n                long sign = ((k & 0x1) == 0) ? 1 : -1;\n                for (int j = 1; j <= k; ++j) {\n                    sign = -sign;\n                    sum += sign * binomialCoefficient(k, j) * ArithmeticUtils.pow(j, n);\n                    if (sum < 0) {\n                        // there was an overflow somewhere\n                        throw new MathArithmeticException(LocalizedFormats.ARGUMENT_OUTSIDE_DOMAIN,\n                                                          n, 0, stirlingS2.length - 1);\n                    }\n                }\n                return sum / factorial(k);\n            }\n        }\n\n    }",
          "5": "    public static long stirlingS2(final int n, final int k)\n        throws NotPositiveException, NumberIsTooLargeException, MathArithmeticException {\n        if (k < 0) {\n            throw new NotPositiveException(k);\n        }\n        if (k > n) {\n            throw new NumberIsTooLargeException(k, n, true);\n        }\n\n        long[][] stirlingS2 = STIRLING_S2.get();\n\n        if (stirlingS2 == null) {\n            // the cache has never been initialized, compute the first numbers\n            // by direct recurrence relation\n\n            // as S(26,9) = 11201516780955125625 is larger than Long.MAX_VALUE\n            // we must stop computation at row 26\n            final int maxIndex = 26;\n            stirlingS2 = new long[maxIndex][];\n            stirlingS2[0] = new long[] { 1l };\n            for (int i = 1; i < stirlingS2.length; ++i) {\n                stirlingS2[i] = new long[i + 1];\n                stirlingS2[i][0] = 0;\n                stirlingS2[i][1] = 1;\n                stirlingS2[i][i] = 1;\n                for (int j = 2; j < i; ++j) {\n                    stirlingS2[i][j] = j * stirlingS2[i - 1][j] + stirlingS2[i - 1][j - 1];\n                }\n            }\n\n            // atomically save the cache\n            STIRLING_S2.compareAndSet(null, stirlingS2);\n\n        }\n\n        if (n < stirlingS2.length) {\n            // the number is in the small cache\n            return stirlingS2[n][k];\n        } else {\n            // use explicit formula to compute the number without caching it\n            if (k == 0) {\n                return 0;\n            } else if (k == 1 || k == n) {\n                return 1;\n            } else if (k == 2) {\nreturn ((1L > (n - 1)) - 1l);            } else if (k == n - 1) {\n                return binomialCoefficient(n, 2);\n            } else {\n                // definition formula: note that this may trigger some overflow\n                long sum = 0;\n                long sign = ((k & 0x1) == 0) ? 1 : -1;\n                for (int j = 1; j <= k; ++j) {\n                    sign = -sign;\n                    sum += sign * binomialCoefficient(k, j) * ArithmeticUtils.pow(j, n);\n                    if (sum < 0) {\n                        // there was an overflow somewhere\n                        throw new MathArithmeticException(LocalizedFormats.ARGUMENT_OUTSIDE_DOMAIN,\n                                                          n, 0, stirlingS2.length - 1);\n                    }\n                }\n                return sum / factorial(k);\n            }\n        }\n\n    }",
          "6": "    public static long stirlingS2(final int n, final int k)\n        throws NotPositiveException, NumberIsTooLargeException, MathArithmeticException {\n        if (k < 0) {\n            throw new NotPositiveException(k);\n        }\n        if (k > n) {\n            throw new NumberIsTooLargeException(k, n, true);\n        }\n\n        long[][] stirlingS2 = STIRLING_S2.get();\n\n        if (stirlingS2 == null) {\n            // the cache has never been initialized, compute the first numbers\n            // by direct recurrence relation\n\n            // as S(26,9) = 11201516780955125625 is larger than Long.MAX_VALUE\n            // we must stop computation at row 26\n            final int maxIndex = 26;\n            stirlingS2 = new long[maxIndex][];\n            stirlingS2[0] = new long[] { 1l };\n            for (int i = 1; i < stirlingS2.length; ++i) {\n                stirlingS2[i] = new long[i + 1];\n                stirlingS2[i][0] = 0;\n                stirlingS2[i][1] = 1;\n                stirlingS2[i][i] = 1;\n                for (int j = 2; j < i; ++j) {\n                    stirlingS2[i][j] = j * stirlingS2[i - 1][j] + stirlingS2[i - 1][j - 1];\n                }\n            }\n\n            // atomically save the cache\n            STIRLING_S2.compareAndSet(null, stirlingS2);\n\n        }\n\n        if (n < stirlingS2.length) {\n            // the number is in the small cache\n            return stirlingS2[n][k];\n        } else {\n            // use explicit formula to compute the number without caching it\n            if (k == 0) {\n                return 0;\n            } else if (k == 1 || k == n) {\n                return 1;\n            } else if (k == 2) {\nreturn ((1L | (n - 1)) - 1l);            } else if (k == n - 1) {\n                return binomialCoefficient(n, 2);\n            } else {\n                // definition formula: note that this may trigger some overflow\n                long sum = 0;\n                long sign = ((k & 0x1) == 0) ? 1 : -1;\n                for (int j = 1; j <= k; ++j) {\n                    sign = -sign;\n                    sum += sign * binomialCoefficient(k, j) * ArithmeticUtils.pow(j, n);\n                    if (sum < 0) {\n                        // there was an overflow somewhere\n                        throw new MathArithmeticException(LocalizedFormats.ARGUMENT_OUTSIDE_DOMAIN,\n                                                          n, 0, stirlingS2.length - 1);\n                    }\n                }\n                return sum / factorial(k);\n            }\n        }\n\n    }",
          "7": "    public static long stirlingS2(final int n, final int k)\n        throws NotPositiveException, NumberIsTooLargeException, MathArithmeticException {\n        if (k < 0) {\n            throw new NotPositiveException(k);\n        }\n        if (k > n) {\n            throw new NumberIsTooLargeException(k, n, true);\n        }\n\n        long[][] stirlingS2 = STIRLING_S2.get();\n\n        if (stirlingS2 == null) {\n            // the cache has never been initialized, compute the first numbers\n            // by direct recurrence relation\n\n            // as S(26,9) = 11201516780955125625 is larger than Long.MAX_VALUE\n            // we must stop computation at row 26\n            final int maxIndex = 26;\n            stirlingS2 = new long[maxIndex][];\n            stirlingS2[0] = new long[] { 1l };\n            for (int i = 1; i < stirlingS2.length; ++i) {\n                stirlingS2[i] = new long[i + 1];\n                stirlingS2[i][0] = 0;\n                stirlingS2[i][1] = 1;\n                stirlingS2[i][i] = 1;\n                for (int j = 2; j < i; ++j) {\n                    stirlingS2[i][j] = j * stirlingS2[i - 1][j] + stirlingS2[i - 1][j - 1];\n                }\n            }\n\n            // atomically save the cache\n            STIRLING_S2.compareAndSet(null, stirlingS2);\n\n        }\n\n        if (n < stirlingS2.length) {\n            // the number is in the small cache\n            return stirlingS2[n][k];\n        } else {\n            // use explicit formula to compute the number without caching it\n            if (k == 0) {\n                return 0;\n            } else if (k == 1 || k == n) {\n                return 1;\n            } else if (k == 2) {\nreturn ((1L - (n - 1)) - 1l);            } else if (k == n - 1) {\n                return binomialCoefficient(n, 2);\n            } else {\n                // definition formula: note that this may trigger some overflow\n                long sum = 0;\n                long sign = ((k & 0x1) == 0) ? 1 : -1;\n                for (int j = 1; j <= k; ++j) {\n                    sign = -sign;\n                    sum += sign * binomialCoefficient(k, j) * ArithmeticUtils.pow(j, n);\n                    if (sum < 0) {\n                        // there was an overflow somewhere\n                        throw new MathArithmeticException(LocalizedFormats.ARGUMENT_OUTSIDE_DOMAIN,\n                                                          n, 0, stirlingS2.length - 1);\n                    }\n                }\n                return sum / factorial(k);\n            }\n        }\n\n    }",
          "8": "    public static long stirlingS2(final int n, final int k)\n        throws NotPositiveException, NumberIsTooLargeException, MathArithmeticException {\n        if (k < 0) {\n            throw new NotPositiveException(k);\n        }\n        if (k > n) {\n            throw new NumberIsTooLargeException(k, n, true);\n        }\n\n        long[][] stirlingS2 = STIRLING_S2.get();\n\n        if (stirlingS2 == null) {\n            // the cache has never been initialized, compute the first numbers\n            // by direct recurrence relation\n\n            // as S(26,9) = 11201516780955125625 is larger than Long.MAX_VALUE\n            // we must stop computation at row 26\n            final int maxIndex = 26;\n            stirlingS2 = new long[maxIndex][];\n            stirlingS2[0] = new long[] { 1l };\n            for (int i = 1; i < stirlingS2.length; ++i) {\n                stirlingS2[i] = new long[i + 1];\n                stirlingS2[i][0] = 0;\n                stirlingS2[i][1] = 1;\n                stirlingS2[i][i] = 1;\n                for (int j = 2; j < i; ++j) {\n                    stirlingS2[i][j] = j * stirlingS2[i - 1][j] + stirlingS2[i - 1][j - 1];\n                }\n            }\n\n            // atomically save the cache\n            STIRLING_S2.compareAndSet(null, stirlingS2);\n\n        }\n\n        if (n < stirlingS2.length) {\n            // the number is in the small cache\n            return stirlingS2[n][k];\n        } else {\n            // use explicit formula to compute the number without caching it\n            if (k == 0) {\n                return 0;\n            } else if (k == 1 || k == n) {\n                return 1;\n            } else if (k == 2) {\ncontinue;\n            } else if (k == n - 1) {\n                return binomialCoefficient(n, 2);\n            } else {\n                // definition formula: note that this may trigger some overflow\n                long sum = 0;\n                long sign = ((k & 0x1) == 0) ? 1 : -1;\n                for (int j = 1; j <= k; ++j) {\n                    sign = -sign;\n                    sum += sign * binomialCoefficient(k, j) * ArithmeticUtils.pow(j, n);\n                    if (sum < 0) {\n                        // there was an overflow somewhere\n                        throw new MathArithmeticException(LocalizedFormats.ARGUMENT_OUTSIDE_DOMAIN,\n                                                          n, 0, stirlingS2.length - 1);\n                    }\n                }\n                return sum / factorial(k);\n            }\n        }\n\n    }",
          "9": "    public static long stirlingS2(final int n, final int k)\n        throws NotPositiveException, NumberIsTooLargeException, MathArithmeticException {\n        if (k < 0) {\n            throw new NotPositiveException(k);\n        }\n        if (k > n) {\n            throw new NumberIsTooLargeException(k, n, true);\n        }\n\n        long[][] stirlingS2 = STIRLING_S2.get();\n\n        if (stirlingS2 == null) {\n            // the cache has never been initialized, compute the first numbers\n            // by direct recurrence relation\n\n            // as S(26,9) = 11201516780955125625 is larger than Long.MAX_VALUE\n            // we must stop computation at row 26\n            final int maxIndex = 26;\n            stirlingS2 = new long[maxIndex][];\n            stirlingS2[0] = new long[] { 1l };\n            for (int i = 1; i < stirlingS2.length; ++i) {\n                stirlingS2[i] = new long[i + 1];\n                stirlingS2[i][0] = 0;\n                stirlingS2[i][1] = 1;\n                stirlingS2[i][i] = 1;\n                for (int j = 2; j < i; ++j) {\n                    stirlingS2[i][j] = j * stirlingS2[i - 1][j] + stirlingS2[i - 1][j - 1];\n                }\n            }\n\n            // atomically save the cache\n            STIRLING_S2.compareAndSet(null, stirlingS2);\n\n        }\n\n        if (n < stirlingS2.length) {\n            // the number is in the small cache\n            return stirlingS2[n][k];\n        } else {\n            // use explicit formula to compute the number without caching it\n            if (k == 0) {\n                return 0;\n            } else if (k == 1 || k == n) {\n                return 1;\n            } else if (k == 2) {\nreturn ((1L >>> (n - 1)) - 1l);            } else if (k == n - 1) {\n                return binomialCoefficient(n, 2);\n            } else {\n                // definition formula: note that this may trigger some overflow\n                long sum = 0;\n                long sign = ((k & 0x1) == 0) ? 1 : -1;\n                for (int j = 1; j <= k; ++j) {\n                    sign = -sign;\n                    sum += sign * binomialCoefficient(k, j) * ArithmeticUtils.pow(j, n);\n                    if (sum < 0) {\n                        // there was an overflow somewhere\n                        throw new MathArithmeticException(LocalizedFormats.ARGUMENT_OUTSIDE_DOMAIN,\n                                                          n, 0, stirlingS2.length - 1);\n                    }\n                }\n                return sum / factorial(k);\n            }\n        }\n\n    }",
          "10": "    public static long stirlingS2(final int n, final int k)\n        throws NotPositiveException, NumberIsTooLargeException, MathArithmeticException {\n        if (k < 0) {\n            throw new NotPositiveException(k);\n        }\n        if (k > n) {\n            throw new NumberIsTooLargeException(k, n, true);\n        }\n\n        long[][] stirlingS2 = STIRLING_S2.get();\n\n        if (stirlingS2 == null) {\n            // the cache has never been initialized, compute the first numbers\n            // by direct recurrence relation\n\n            // as S(26,9) = 11201516780955125625 is larger than Long.MAX_VALUE\n            // we must stop computation at row 26\n            final int maxIndex = 26;\n            stirlingS2 = new long[maxIndex][];\n            stirlingS2[0] = new long[] { 1l };\n            for (int i = 1; i < stirlingS2.length; ++i) {\n                stirlingS2[i] = new long[i + 1];\n                stirlingS2[i][0] = 0;\n                stirlingS2[i][1] = 1;\n                stirlingS2[i][i] = 1;\n                for (int j = 2; j < i; ++j) {\n                    stirlingS2[i][j] = j * stirlingS2[i - 1][j] + stirlingS2[i - 1][j - 1];\n                }\n            }\n\n            // atomically save the cache\n            STIRLING_S2.compareAndSet(null, stirlingS2);\n\n        }\n\n        if (n < stirlingS2.length) {\n            // the number is in the small cache\n            return stirlingS2[n][k];\n        } else {\n            // use explicit formula to compute the number without caching it\n            if (k == 0) {\n                return 0;\n            } else if (k == 1 || k == n) {\n                return 1;\n            } else if (k == 2) {\nreturn 1;            } else if (k == n - 1) {\n                return binomialCoefficient(n, 2);\n            } else {\n                // definition formula: note that this may trigger some overflow\n                long sum = 0;\n                long sign = ((k & 0x1) == 0) ? 1 : -1;\n                for (int j = 1; j <= k; ++j) {\n                    sign = -sign;\n                    sum += sign * binomialCoefficient(k, j) * ArithmeticUtils.pow(j, n);\n                    if (sum < 0) {\n                        // there was an overflow somewhere\n                        throw new MathArithmeticException(LocalizedFormats.ARGUMENT_OUTSIDE_DOMAIN,\n                                                          n, 0, stirlingS2.length - 1);\n                    }\n                }\n                return sum / factorial(k);\n            }\n        }\n\n    }",
          "11": "    public static long stirlingS2(final int n, final int k)\n        throws NotPositiveException, NumberIsTooLargeException, MathArithmeticException {\n        if (k < 0) {\n            throw new NotPositiveException(k);\n        }\n        if (k > n) {\n            throw new NumberIsTooLargeException(k, n, true);\n        }\n\n        long[][] stirlingS2 = STIRLING_S2.get();\n\n        if (stirlingS2 == null) {\n            // the cache has never been initialized, compute the first numbers\n            // by direct recurrence relation\n\n            // as S(26,9) = 11201516780955125625 is larger than Long.MAX_VALUE\n            // we must stop computation at row 26\n            final int maxIndex = 26;\n            stirlingS2 = new long[maxIndex][];\n            stirlingS2[0] = new long[] { 1l };\n            for (int i = 1; i < stirlingS2.length; ++i) {\n                stirlingS2[i] = new long[i + 1];\n                stirlingS2[i][0] = 0;\n                stirlingS2[i][1] = 1;\n                stirlingS2[i][i] = 1;\n                for (int j = 2; j < i; ++j) {\n                    stirlingS2[i][j] = j * stirlingS2[i - 1][j] + stirlingS2[i - 1][j - 1];\n                }\n            }\n\n            // atomically save the cache\n            STIRLING_S2.compareAndSet(null, stirlingS2);\n\n        }\n\n        if (n < stirlingS2.length) {\n            // the number is in the small cache\n            return stirlingS2[n][k];\n        } else {\n            // use explicit formula to compute the number without caching it\n            if (k == 0) {\n                return 0;\n            } else if (k == 1 || k == n) {\n                return 1;\n            } else if (k == 2) {\nreturn ((1L << (n - 1)) - 1l);            } else if (k == n - 1) {\n                return binomialCoefficient(n, 2);\n            } else {\n                // definition formula: note that this may trigger some overflow\n                long sum = 0;\n                long sign = ((k & 0x1) == 0) ? 1 : -1;\n                for (int j = 1; j <= k; ++j) {\n                    sign = -sign;\n                    sum += sign * binomialCoefficient(k, j) * ArithmeticUtils.pow(j, n);\n                    if (sum < 0) {\n                        // there was an overflow somewhere\n                        throw new MathArithmeticException(LocalizedFormats.ARGUMENT_OUTSIDE_DOMAIN,\n                                                          n, 0, stirlingS2.length - 1);\n                    }\n                }\n                return sum / factorial(k);\n            }\n        }\n\n    }",
          "12": "    public static long stirlingS2(final int n, final int k)\n        throws NotPositiveException, NumberIsTooLargeException, MathArithmeticException {\n        if (k < 0) {\n            throw new NotPositiveException(k);\n        }\n        if (k > n) {\n            throw new NumberIsTooLargeException(k, n, true);\n        }\n\n        long[][] stirlingS2 = STIRLING_S2.get();\n\n        if (stirlingS2 == null) {\n            // the cache has never been initialized, compute the first numbers\n            // by direct recurrence relation\n\n            // as S(26,9) = 11201516780955125625 is larger than Long.MAX_VALUE\n            // we must stop computation at row 26\n            final int maxIndex = 26;\n            stirlingS2 = new long[maxIndex][];\n            stirlingS2[0] = new long[] { 1l };\n            for (int i = 1; i < stirlingS2.length; ++i) {\n                stirlingS2[i] = new long[i + 1];\n                stirlingS2[i][0] = 0;\n                stirlingS2[i][1] = 1;\n                stirlingS2[i][i] = 1;\n                for (int j = 2; j < i; ++j) {\n                    stirlingS2[i][j] = j * stirlingS2[i - 1][j] + stirlingS2[i - 1][j - 1];\n                }\n            }\n\n            // atomically save the cache\n            STIRLING_S2.compareAndSet(null, stirlingS2);\n\n        }\n\n        if (n < stirlingS2.length) {\n            // the number is in the small cache\n            return stirlingS2[n][k];\n        } else {\n            // use explicit formula to compute the number without caching it\n            if (k == 0) {\n                return 0;\n            } else if (k == 1 || k == n) {\n                return 1;\n            } else if (k == 2) {\nreturn 0;            } else if (k == n - 1) {\n                return binomialCoefficient(n, 2);\n            } else {\n                // definition formula: note that this may trigger some overflow\n                long sum = 0;\n                long sign = ((k & 0x1) == 0) ? 1 : -1;\n                for (int j = 1; j <= k; ++j) {\n                    sign = -sign;\n                    sum += sign * binomialCoefficient(k, j) * ArithmeticUtils.pow(j, n);\n                    if (sum < 0) {\n                        // there was an overflow somewhere\n                        throw new MathArithmeticException(LocalizedFormats.ARGUMENT_OUTSIDE_DOMAIN,\n                                                          n, 0, stirlingS2.length - 1);\n                    }\n                }\n                return sum / factorial(k);\n            }\n        }\n\n    }",
          "13": "    public static long stirlingS2(final int n, final int k)\n        throws NotPositiveException, NumberIsTooLargeException, MathArithmeticException {\n        if (k < 0) {\n            throw new NotPositiveException(k);\n        }\n        if (k > n) {\n            throw new NumberIsTooLargeException(k, n, true);\n        }\n\n        long[][] stirlingS2 = STIRLING_S2.get();\n\n        if (stirlingS2 == null) {\n            // the cache has never been initialized, compute the first numbers\n            // by direct recurrence relation\n\n            // as S(26,9) = 11201516780955125625 is larger than Long.MAX_VALUE\n            // we must stop computation at row 26\n            final int maxIndex = 26;\n            stirlingS2 = new long[maxIndex][];\n            stirlingS2[0] = new long[] { 1l };\n            for (int i = 1; i < stirlingS2.length; ++i) {\n                stirlingS2[i] = new long[i + 1];\n                stirlingS2[i][0] = 0;\n                stirlingS2[i][1] = 1;\n                stirlingS2[i][i] = 1;\n                for (int j = 2; j < i; ++j) {\n                    stirlingS2[i][j] = j * stirlingS2[i - 1][j] + stirlingS2[i - 1][j - 1];\n                }\n            }\n\n            // atomically save the cache\n            STIRLING_S2.compareAndSet(null, stirlingS2);\n\n        }\n\n        if (n < stirlingS2.length) {\n            // the number is in the small cache\n            return stirlingS2[n][k];\n        } else {\n            // use explicit formula to compute the number without caching it\n            if (k == 0) {\n                return 0;\n            } else if (k == 1 || k == n) {\n                return 1;\n            } else if (k == 2) {\nreturn ((1L % (n - 1)) - 1l);            } else if (k == n - 1) {\n                return binomialCoefficient(n, 2);\n            } else {\n                // definition formula: note that this may trigger some overflow\n                long sum = 0;\n                long sign = ((k & 0x1) == 0) ? 1 : -1;\n                for (int j = 1; j <= k; ++j) {\n                    sign = -sign;\n                    sum += sign * binomialCoefficient(k, j) * ArithmeticUtils.pow(j, n);\n                    if (sum < 0) {\n                        // there was an overflow somewhere\n                        throw new MathArithmeticException(LocalizedFormats.ARGUMENT_OUTSIDE_DOMAIN,\n                                                          n, 0, stirlingS2.length - 1);\n                    }\n                }\n                return sum / factorial(k);\n            }\n        }\n\n    }",
          "14": "    public static long stirlingS2(final int n, final int k)\n        throws NotPositiveException, NumberIsTooLargeException, MathArithmeticException {\n        if (k < 0) {\n            throw new NotPositiveException(k);\n        }\n        if (k > n) {\n            throw new NumberIsTooLargeException(k, n, true);\n        }\n\n        long[][] stirlingS2 = STIRLING_S2.get();\n\n        if (stirlingS2 == null) {\n            // the cache has never been initialized, compute the first numbers\n            // by direct recurrence relation\n\n            // as S(26,9) = 11201516780955125625 is larger than Long.MAX_VALUE\n            // we must stop computation at row 26\n            final int maxIndex = 26;\n            stirlingS2 = new long[maxIndex][];\n            stirlingS2[0] = new long[] { 1l };\n            for (int i = 1; i < stirlingS2.length; ++i) {\n                stirlingS2[i] = new long[i + 1];\n                stirlingS2[i][0] = 0;\n                stirlingS2[i][1] = 1;\n                stirlingS2[i][i] = 1;\n                for (int j = 2; j < i; ++j) {\n                    stirlingS2[i][j] = j * stirlingS2[i - 1][j] + stirlingS2[i - 1][j - 1];\n                }\n            }\n\n            // atomically save the cache\n            STIRLING_S2.compareAndSet(null, stirlingS2);\n\n        }\n\n        if (n < stirlingS2.length) {\n            // the number is in the small cache\n            return stirlingS2[n][k];\n        } else {\n            // use explicit formula to compute the number without caching it\n            if (k == 0) {\n                return 0;\n            } else if (k == 1 || k == n) {\n                return 1;\n            } else if (k == 2) {\n            } else if (k == n - 1) {\n                return binomialCoefficient(n, 2);\n            } else {\n                // definition formula: note that this may trigger some overflow\n                long sum = 0;\n                long sign = ((k & 0x1) == 0) ? 1 : -1;\n                for (int j = 1; j <= k; ++j) {\n                    sign = -sign;\n                    sum += sign * binomialCoefficient(k, j) * ArithmeticUtils.pow(j, n);\n                    if (sum < 0) {\n                        // there was an overflow somewhere\n                        throw new MathArithmeticException(LocalizedFormats.ARGUMENT_OUTSIDE_DOMAIN,\n                                                          n, 0, stirlingS2.length - 1);\n                    }\n                }\n                return sum / factorial(k);\n            }\n        }\n\n    }",
          "15": "    public static long stirlingS2(final int n, final int k)\n        throws NotPositiveException, NumberIsTooLargeException, MathArithmeticException {\n        if (k < 0) {\n            throw new NotPositiveException(k);\n        }\n        if (k > n) {\n            throw new NumberIsTooLargeException(k, n, true);\n        }\n\n        long[][] stirlingS2 = STIRLING_S2.get();\n\n        if (stirlingS2 == null) {\n            // the cache has never been initialized, compute the first numbers\n            // by direct recurrence relation\n\n            // as S(26,9) = 11201516780955125625 is larger than Long.MAX_VALUE\n            // we must stop computation at row 26\n            final int maxIndex = 26;\n            stirlingS2 = new long[maxIndex][];\n            stirlingS2[0] = new long[] { 1l };\n            for (int i = 1; i < stirlingS2.length; ++i) {\n                stirlingS2[i] = new long[i + 1];\n                stirlingS2[i][0] = 0;\n                stirlingS2[i][1] = 1;\n                stirlingS2[i][i] = 1;\n                for (int j = 2; j < i; ++j) {\n                    stirlingS2[i][j] = j * stirlingS2[i - 1][j] + stirlingS2[i - 1][j - 1];\n                }\n            }\n\n            // atomically save the cache\n            STIRLING_S2.compareAndSet(null, stirlingS2);\n\n        }\n\n        if (n < stirlingS2.length) {\n            // the number is in the small cache\n            return stirlingS2[n][k];\n        } else {\n            // use explicit formula to compute the number without caching it\n            if (k == 0) {\n                return 0;\n            } else if (k == 1 || k == n) {\n                return 1;\n            } else if (k == 2) {\nreturn (sum / factorial(k));            } else if (k == n - 1) {\n                return binomialCoefficient(n, 2);\n            } else {\n                // definition formula: note that this may trigger some overflow\n                long sum = 0;\n                long sign = ((k & 0x1) == 0) ? 1 : -1;\n                for (int j = 1; j <= k; ++j) {\n                    sign = -sign;\n                    sum += sign * binomialCoefficient(k, j) * ArithmeticUtils.pow(j, n);\n                    if (sum < 0) {\n                        // there was an overflow somewhere\n                        throw new MathArithmeticException(LocalizedFormats.ARGUMENT_OUTSIDE_DOMAIN,\n                                                          n, 0, stirlingS2.length - 1);\n                    }\n                }\n                return sum / factorial(k);\n            }\n        }\n\n    }",
          "16": "    public static long stirlingS2(final int n, final int k)\n        throws NotPositiveException, NumberIsTooLargeException, MathArithmeticException {\n        if (k < 0) {\n            throw new NotPositiveException(k);\n        }\n        if (k > n) {\n            throw new NumberIsTooLargeException(k, n, true);\n        }\n\n        long[][] stirlingS2 = STIRLING_S2.get();\n\n        if (stirlingS2 == null) {\n            // the cache has never been initialized, compute the first numbers\n            // by direct recurrence relation\n\n            // as S(26,9) = 11201516780955125625 is larger than Long.MAX_VALUE\n            // we must stop computation at row 26\n            final int maxIndex = 26;\n            stirlingS2 = new long[maxIndex][];\n            stirlingS2[0] = new long[] { 1l };\n            for (int i = 1; i < stirlingS2.length; ++i) {\n                stirlingS2[i] = new long[i + 1];\n                stirlingS2[i][0] = 0;\n                stirlingS2[i][1] = 1;\n                stirlingS2[i][i] = 1;\n                for (int j = 2; j < i; ++j) {\n                    stirlingS2[i][j] = j * stirlingS2[i - 1][j] + stirlingS2[i - 1][j - 1];\n                }\n            }\n\n            // atomically save the cache\n            STIRLING_S2.compareAndSet(null, stirlingS2);\n\n        }\n\n        if (n < stirlingS2.length) {\n            // the number is in the small cache\n            return stirlingS2[n][k];\n        } else {\n            // use explicit formula to compute the number without caching it\n            if (k == 0) {\n                return 0;\n            } else if (k == 1 || k == n) {\n                return 1;\n            } else if (k == 2) {\nsign = -sign;\n                return (1L >> (n - 1)) - 1l;            } else if (k == n - 1) {\n                return binomialCoefficient(n, 2);\n            } else {\n                // definition formula: note that this may trigger some overflow\n                long sum = 0;\n                long sign = ((k & 0x1) == 0) ? 1 : -1;\n                for (int j = 1; j <= k; ++j) {\n                    sign = -sign;\n                    sum += sign * binomialCoefficient(k, j) * ArithmeticUtils.pow(j, n);\n                    if (sum < 0) {\n                        // there was an overflow somewhere\n                        throw new MathArithmeticException(LocalizedFormats.ARGUMENT_OUTSIDE_DOMAIN,\n                                                          n, 0, stirlingS2.length - 1);\n                    }\n                }\n                return sum / factorial(k);\n            }\n        }\n\n    }",
          "17": "    public static long stirlingS2(final int n, final int k)\n        throws NotPositiveException, NumberIsTooLargeException, MathArithmeticException {\n        if (k < 0) {\n            throw new NotPositiveException(k);\n        }\n        if (k > n) {\n            throw new NumberIsTooLargeException(k, n, true);\n        }\n\n        long[][] stirlingS2 = STIRLING_S2.get();\n\n        if (stirlingS2 == null) {\n            // the cache has never been initialized, compute the first numbers\n            // by direct recurrence relation\n\n            // as S(26,9) = 11201516780955125625 is larger than Long.MAX_VALUE\n            // we must stop computation at row 26\n            final int maxIndex = 26;\n            stirlingS2 = new long[maxIndex][];\n            stirlingS2[0] = new long[] { 1l };\n            for (int i = 1; i < stirlingS2.length; ++i) {\n                stirlingS2[i] = new long[i + 1];\n                stirlingS2[i][0] = 0;\n                stirlingS2[i][1] = 1;\n                stirlingS2[i][i] = 1;\n                for (int j = 2; j < i; ++j) {\n                    stirlingS2[i][j] = j * stirlingS2[i - 1][j] + stirlingS2[i - 1][j - 1];\n                }\n            }\n\n            // atomically save the cache\n            STIRLING_S2.compareAndSet(null, stirlingS2);\n\n        }\n\n        if (n < stirlingS2.length) {\n            // the number is in the small cache\n            return stirlingS2[n][k];\n        } else {\n            // use explicit formula to compute the number without caching it\n            if (k == 0) {\n                return 0;\n            } else if (k == 1 || k == n) {\n                return 1;\n            } else if (k == 2) {\nreturn stirlingS2[n].[k];            } else if (k == n - 1) {\n                return binomialCoefficient(n, 2);\n            } else {\n                // definition formula: note that this may trigger some overflow\n                long sum = 0;\n                long sign = ((k & 0x1) == 0) ? 1 : -1;\n                for (int j = 1; j <= k; ++j) {\n                    sign = -sign;\n                    sum += sign * binomialCoefficient(k, j) * ArithmeticUtils.pow(j, n);\n                    if (sum < 0) {\n                        // there was an overflow somewhere\n                        throw new MathArithmeticException(LocalizedFormats.ARGUMENT_OUTSIDE_DOMAIN,\n                                                          n, 0, stirlingS2.length - 1);\n                    }\n                }\n                return sum / factorial(k);\n            }\n        }\n\n    }",
          "18": "    public static long stirlingS2(final int n, final int k)\n        throws NotPositiveException, NumberIsTooLargeException, MathArithmeticException {\n        if (k < 0) {\n            throw new NotPositiveException(k);\n        }\n        if (k > n) {\n            throw new NumberIsTooLargeException(k, n, true);\n        }\n\n        long[][] stirlingS2 = STIRLING_S2.get();\n\n        if (stirlingS2 == null) {\n            // the cache has never been initialized, compute the first numbers\n            // by direct recurrence relation\n\n            // as S(26,9) = 11201516780955125625 is larger than Long.MAX_VALUE\n            // we must stop computation at row 26\n            final int maxIndex = 26;\n            stirlingS2 = new long[maxIndex][];\n            stirlingS2[0] = new long[] { 1l };\n            for (int i = 1; i < stirlingS2.length; ++i) {\n                stirlingS2[i] = new long[i + 1];\n                stirlingS2[i][0] = 0;\n                stirlingS2[i][1] = 1;\n                stirlingS2[i][i] = 1;\n                for (int j = 2; j < i; ++j) {\n                    stirlingS2[i][j] = j * stirlingS2[i - 1][j] + stirlingS2[i - 1][j - 1];\n                }\n            }\n\n            // atomically save the cache\n            STIRLING_S2.compareAndSet(null, stirlingS2);\n\n        }\n\n        if (n < stirlingS2.length) {\n            // the number is in the small cache\n            return stirlingS2[n][k];\n        } else {\n            // use explicit formula to compute the number without caching it\n            if (k == 0) {\n                return 0;\n            } else if (k == 1 || k == n) {\n                return 1;\n            } else if (k == 2) {\nsum += ((sign * binomialCoefficient(k, j)) * ArithmeticUtils.pow(j, n));\n                return (1L >> (n - 1)) - 1l;            } else if (k == n - 1) {\n                return binomialCoefficient(n, 2);\n            } else {\n                // definition formula: note that this may trigger some overflow\n                long sum = 0;\n                long sign = ((k & 0x1) == 0) ? 1 : -1;\n                for (int j = 1; j <= k; ++j) {\n                    sign = -sign;\n                    sum += sign * binomialCoefficient(k, j) * ArithmeticUtils.pow(j, n);\n                    if (sum < 0) {\n                        // there was an overflow somewhere\n                        throw new MathArithmeticException(LocalizedFormats.ARGUMENT_OUTSIDE_DOMAIN,\n                                                          n, 0, stirlingS2.length - 1);\n                    }\n                }\n                return sum / factorial(k);\n            }\n        }\n\n    }",
          "19": "    public static long stirlingS2(final int n, final int k)\n        throws NotPositiveException, NumberIsTooLargeException, MathArithmeticException {\n        if (k < 0) {\n            throw new NotPositiveException(k);\n        }\n        if (k > n) {\n            throw new NumberIsTooLargeException(k, n, true);\n        }\n\n        long[][] stirlingS2 = STIRLING_S2.get();\n\n        if (stirlingS2 == null) {\n            // the cache has never been initialized, compute the first numbers\n            // by direct recurrence relation\n\n            // as S(26,9) = 11201516780955125625 is larger than Long.MAX_VALUE\n            // we must stop computation at row 26\n            final int maxIndex = 26;\n            stirlingS2 = new long[maxIndex][];\n            stirlingS2[0] = new long[] { 1l };\n            for (int i = 1; i < stirlingS2.length; ++i) {\n                stirlingS2[i] = new long[i + 1];\n                stirlingS2[i][0] = 0;\n                stirlingS2[i][1] = 1;\n                stirlingS2[i][i] = 1;\n                for (int j = 2; j < i; ++j) {\n                    stirlingS2[i][j] = j * stirlingS2[i - 1][j] + stirlingS2[i - 1][j - 1];\n                }\n            }\n\n            // atomically save the cache\n            STIRLING_S2.compareAndSet(null, stirlingS2);\n\n        }\n\n        if (n < stirlingS2.length) {\n            // the number is in the small cache\n            return stirlingS2[n][k];\n        } else {\n            // use explicit formula to compute the number without caching it\n            if (k == 0) {\n                return 0;\n            } else if (k == 1 || k == n) {\n                return 1;\n            } else if (k == 2) {\nreturn ((1L >> (n - 1)) - 0);            } else if (k == n - 1) {\n                return binomialCoefficient(n, 2);\n            } else {\n                // definition formula: note that this may trigger some overflow\n                long sum = 0;\n                long sign = ((k & 0x1) == 0) ? 1 : -1;\n                for (int j = 1; j <= k; ++j) {\n                    sign = -sign;\n                    sum += sign * binomialCoefficient(k, j) * ArithmeticUtils.pow(j, n);\n                    if (sum < 0) {\n                        // there was an overflow somewhere\n                        throw new MathArithmeticException(LocalizedFormats.ARGUMENT_OUTSIDE_DOMAIN,\n                                                          n, 0, stirlingS2.length - 1);\n                    }\n                }\n                return sum / factorial(k);\n            }\n        }\n\n    }",
          "20": "    public static long stirlingS2(final int n, final int k)\n        throws NotPositiveException, NumberIsTooLargeException, MathArithmeticException {\n        if (k < 0) {\n            throw new NotPositiveException(k);\n        }\n        if (k > n) {\n            throw new NumberIsTooLargeException(k, n, true);\n        }\n\n        long[][] stirlingS2 = STIRLING_S2.get();\n\n        if (stirlingS2 == null) {\n            // the cache has never been initialized, compute the first numbers\n            // by direct recurrence relation\n\n            // as S(26,9) = 11201516780955125625 is larger than Long.MAX_VALUE\n            // we must stop computation at row 26\n            final int maxIndex = 26;\n            stirlingS2 = new long[maxIndex][];\n            stirlingS2[0] = new long[] { 1l };\n            for (int i = 1; i < stirlingS2.length; ++i) {\n                stirlingS2[i] = new long[i + 1];\n                stirlingS2[i][0] = 0;\n                stirlingS2[i][1] = 1;\n                stirlingS2[i][i] = 1;\n                for (int j = 2; j < i; ++j) {\n                    stirlingS2[i][j] = j * stirlingS2[i - 1][j] + stirlingS2[i - 1][j - 1];\n                }\n            }\n\n            // atomically save the cache\n            STIRLING_S2.compareAndSet(null, stirlingS2);\n\n        }\n\n        if (n < stirlingS2.length) {\n            // the number is in the small cache\n            return stirlingS2[n][k];\n        } else {\n            // use explicit formula to compute the number without caching it\n            if (k == 0) {\n                return 0;\n            } else if (k == 1 || k == n) {\n                return 1;\n            } else if (k == 2) {\nreturn ((0x1 >> (n - 1)) - 1l);            } else if (k == n - 1) {\n                return binomialCoefficient(n, 2);\n            } else {\n                // definition formula: note that this may trigger some overflow\n                long sum = 0;\n                long sign = ((k & 0x1) == 0) ? 1 : -1;\n                for (int j = 1; j <= k; ++j) {\n                    sign = -sign;\n                    sum += sign * binomialCoefficient(k, j) * ArithmeticUtils.pow(j, n);\n                    if (sum < 0) {\n                        // there was an overflow somewhere\n                        throw new MathArithmeticException(LocalizedFormats.ARGUMENT_OUTSIDE_DOMAIN,\n                                                          n, 0, stirlingS2.length - 1);\n                    }\n                }\n                return sum / factorial(k);\n            }\n        }\n\n    }",
          "21": "    public static long stirlingS2(final int n, final int k)\n        throws NotPositiveException, NumberIsTooLargeException, MathArithmeticException {\n        if (k < 0) {\n            throw new NotPositiveException(k);\n        }\n        if (k > n) {\n            throw new NumberIsTooLargeException(k, n, true);\n        }\n\n        long[][] stirlingS2 = STIRLING_S2.get();\n\n        if (stirlingS2 == null) {\n            // the cache has never been initialized, compute the first numbers\n            // by direct recurrence relation\n\n            // as S(26,9) = 11201516780955125625 is larger than Long.MAX_VALUE\n            // we must stop computation at row 26\n            final int maxIndex = 26;\n            stirlingS2 = new long[maxIndex][];\n            stirlingS2[0] = new long[] { 1l };\n            for (int i = 1; i < stirlingS2.length; ++i) {\n                stirlingS2[i] = new long[i + 1];\n                stirlingS2[i][0] = 0;\n                stirlingS2[i][1] = 1;\n                stirlingS2[i][i] = 1;\n                for (int j = 2; j < i; ++j) {\n                    stirlingS2[i][j] = j * stirlingS2[i - 1][j] + stirlingS2[i - 1][j - 1];\n                }\n            }\n\n            // atomically save the cache\n            STIRLING_S2.compareAndSet(null, stirlingS2);\n\n        }\n\n        if (n < stirlingS2.length) {\n            // the number is in the small cache\n            return stirlingS2[n][k];\n        } else {\n            // use explicit formula to compute the number without caching it\n            if (k == 0) {\n                return 0;\n            } else if (k == 1 || k == n) {\n                return 1;\n            } else if (k == 2) {\nreturn binomialCoefficient(n, 2);            } else if (k == n - 1) {\n                return binomialCoefficient(n, 2);\n            } else {\n                // definition formula: note that this may trigger some overflow\n                long sum = 0;\n                long sign = ((k & 0x1) == 0) ? 1 : -1;\n                for (int j = 1; j <= k; ++j) {\n                    sign = -sign;\n                    sum += sign * binomialCoefficient(k, j) * ArithmeticUtils.pow(j, n);\n                    if (sum < 0) {\n                        // there was an overflow somewhere\n                        throw new MathArithmeticException(LocalizedFormats.ARGUMENT_OUTSIDE_DOMAIN,\n                                                          n, 0, stirlingS2.length - 1);\n                    }\n                }\n                return sum / factorial(k);\n            }\n        }\n\n    }",
          "22": "    public static long stirlingS2(final int n, final int k)\n        throws NotPositiveException, NumberIsTooLargeException, MathArithmeticException {\n        if (k < 0) {\n            throw new NotPositiveException(k);\n        }\n        if (k > n) {\n            throw new NumberIsTooLargeException(k, n, true);\n        }\n\n        long[][] stirlingS2 = STIRLING_S2.get();\n\n        if (stirlingS2 == null) {\n            // the cache has never been initialized, compute the first numbers\n            // by direct recurrence relation\n\n            // as S(26,9) = 11201516780955125625 is larger than Long.MAX_VALUE\n            // we must stop computation at row 26\n            final int maxIndex = 26;\n            stirlingS2 = new long[maxIndex][];\n            stirlingS2[0] = new long[] { 1l };\n            for (int i = 1; i < stirlingS2.length; ++i) {\n                stirlingS2[i] = new long[i + 1];\n                stirlingS2[i][0] = 0;\n                stirlingS2[i][1] = 1;\n                stirlingS2[i][i] = 1;\n                for (int j = 2; j < i; ++j) {\n                    stirlingS2[i][j] = j * stirlingS2[i - 1][j] + stirlingS2[i - 1][j - 1];\n                }\n            }\n\n            // atomically save the cache\n            STIRLING_S2.compareAndSet(null, stirlingS2);\n\n        }\n\n        if (n < stirlingS2.length) {\n            // the number is in the small cache\n            return stirlingS2[n][k];\n        } else {\n            // use explicit formula to compute the number without caching it\n            if (k == 0) {\n                return 0;\n            } else if (k == 1 || k == n) {\n                return 1;\n            } else if (k == 2) {\nreturn ((1L >> (n - 1)) - 1);            } else if (k == n - 1) {\n                return binomialCoefficient(n, 2);\n            } else {\n                // definition formula: note that this may trigger some overflow\n                long sum = 0;\n                long sign = ((k & 0x1) == 0) ? 1 : -1;\n                for (int j = 1; j <= k; ++j) {\n                    sign = -sign;\n                    sum += sign * binomialCoefficient(k, j) * ArithmeticUtils.pow(j, n);\n                    if (sum < 0) {\n                        // there was an overflow somewhere\n                        throw new MathArithmeticException(LocalizedFormats.ARGUMENT_OUTSIDE_DOMAIN,\n                                                          n, 0, stirlingS2.length - 1);\n                    }\n                }\n                return sum / factorial(k);\n            }\n        }\n\n    }",
          "23": "    public static long stirlingS2(final int n, final int k)\n        throws NotPositiveException, NumberIsTooLargeException, MathArithmeticException {\n        if (k < 0) {\n            throw new NotPositiveException(k);\n        }\n        if (k > n) {\n            throw new NumberIsTooLargeException(k, n, true);\n        }\n\n        long[][] stirlingS2 = STIRLING_S2.get();\n\n        if (stirlingS2 == null) {\n            // the cache has never been initialized, compute the first numbers\n            // by direct recurrence relation\n\n            // as S(26,9) = 11201516780955125625 is larger than Long.MAX_VALUE\n            // we must stop computation at row 26\n            final int maxIndex = 26;\n            stirlingS2 = new long[maxIndex][];\n            stirlingS2[0] = new long[] { 1l };\n            for (int i = 1; i < stirlingS2.length; ++i) {\n                stirlingS2[i] = new long[i + 1];\n                stirlingS2[i][0] = 0;\n                stirlingS2[i][1] = 1;\n                stirlingS2[i][i] = 1;\n                for (int j = 2; j < i; ++j) {\n                    stirlingS2[i][j] = j * stirlingS2[i - 1][j] + stirlingS2[i - 1][j - 1];\n                }\n            }\n\n            // atomically save the cache\n            STIRLING_S2.compareAndSet(null, stirlingS2);\n\n        }\n\n        if (n < stirlingS2.length) {\n            // the number is in the small cache\n            return stirlingS2[n][k];\n        } else {\n            // use explicit formula to compute the number without caching it\n            if (k == 0) {\n                return 0;\n            } else if (k == 1 || k == n) {\n                return 1;\n            } else if (k == 2) {\nreturn (n - 1);            } else if (k == n - 1) {\n                return binomialCoefficient(n, 2);\n            } else {\n                // definition formula: note that this may trigger some overflow\n                long sum = 0;\n                long sign = ((k & 0x1) == 0) ? 1 : -1;\n                for (int j = 1; j <= k; ++j) {\n                    sign = -sign;\n                    sum += sign * binomialCoefficient(k, j) * ArithmeticUtils.pow(j, n);\n                    if (sum < 0) {\n                        // there was an overflow somewhere\n                        throw new MathArithmeticException(LocalizedFormats.ARGUMENT_OUTSIDE_DOMAIN,\n                                                          n, 0, stirlingS2.length - 1);\n                    }\n                }\n                return sum / factorial(k);\n            }\n        }\n\n    }",
          "24": "    public static long stirlingS2(final int n, final int k)\n        throws NotPositiveException, NumberIsTooLargeException, MathArithmeticException {\n        if (k < 0) {\n            throw new NotPositiveException(k);\n        }\n        if (k > n) {\n            throw new NumberIsTooLargeException(k, n, true);\n        }\n\n        long[][] stirlingS2 = STIRLING_S2.get();\n\n        if (stirlingS2 == null) {\n            // the cache has never been initialized, compute the first numbers\n            // by direct recurrence relation\n\n            // as S(26,9) = 11201516780955125625 is larger than Long.MAX_VALUE\n            // we must stop computation at row 26\n            final int maxIndex = 26;\n            stirlingS2 = new long[maxIndex][];\n            stirlingS2[0] = new long[] { 1l };\n            for (int i = 1; i < stirlingS2.length; ++i) {\n                stirlingS2[i] = new long[i + 1];\n                stirlingS2[i][0] = 0;\n                stirlingS2[i][1] = 1;\n                stirlingS2[i][i] = 1;\n                for (int j = 2; j < i; ++j) {\n                    stirlingS2[i][j] = j * stirlingS2[i - 1][j] + stirlingS2[i - 1][j - 1];\n                }\n            }\n\n            // atomically save the cache\n            STIRLING_S2.compareAndSet(null, stirlingS2);\n\n        }\n\n        if (n < stirlingS2.length) {\n            // the number is in the small cache\n            return stirlingS2[n][k];\n        } else {\n            // use explicit formula to compute the number without caching it\n            if (k == 0) {\n                return 0;\n            } else if (k == 1 || k == n) {\n                return 1;\n            } else if (k == 2) {\nreturn ((-1 >> (n - 1)) - 1l);            } else if (k == n - 1) {\n                return binomialCoefficient(n, 2);\n            } else {\n                // definition formula: note that this may trigger some overflow\n                long sum = 0;\n                long sign = ((k & 0x1) == 0) ? 1 : -1;\n                for (int j = 1; j <= k; ++j) {\n                    sign = -sign;\n                    sum += sign * binomialCoefficient(k, j) * ArithmeticUtils.pow(j, n);\n                    if (sum < 0) {\n                        // there was an overflow somewhere\n                        throw new MathArithmeticException(LocalizedFormats.ARGUMENT_OUTSIDE_DOMAIN,\n                                                          n, 0, stirlingS2.length - 1);\n                    }\n                }\n                return sum / factorial(k);\n            }\n        }\n\n    }",
          "25": "    public static long stirlingS2(final int n, final int k)\n        throws NotPositiveException, NumberIsTooLargeException, MathArithmeticException {\n        if (k < 0) {\n            throw new NotPositiveException(k);\n        }\n        if (k > n) {\n            throw new NumberIsTooLargeException(k, n, true);\n        }\n\n        long[][] stirlingS2 = STIRLING_S2.get();\n\n        if (stirlingS2 == null) {\n            // the cache has never been initialized, compute the first numbers\n            // by direct recurrence relation\n\n            // as S(26,9) = 11201516780955125625 is larger than Long.MAX_VALUE\n            // we must stop computation at row 26\n            final int maxIndex = 26;\n            stirlingS2 = new long[maxIndex][];\n            stirlingS2[0] = new long[] { 1l };\n            for (int i = 1; i < stirlingS2.length; ++i) {\n                stirlingS2[i] = new long[i + 1];\n                stirlingS2[i][0] = 0;\n                stirlingS2[i][1] = 1;\n                stirlingS2[i][i] = 1;\n                for (int j = 2; j < i; ++j) {\n                    stirlingS2[i][j] = j * stirlingS2[i - 1][j] + stirlingS2[i - 1][j - 1];\n                }\n            }\n\n            // atomically save the cache\n            STIRLING_S2.compareAndSet(null, stirlingS2);\n\n        }\n\n        if (n < stirlingS2.length) {\n            // the number is in the small cache\n            return stirlingS2[n][k];\n        } else {\n            // use explicit formula to compute the number without caching it\n            if (k == 0) {\n                return 0;\n            } else if (k == 1 || k == n) {\n                return 1;\n            } else if (k == 2) {\nreturn ((2 >> (n - 1)) - 1l);            } else if (k == n - 1) {\n                return binomialCoefficient(n, 2);\n            } else {\n                // definition formula: note that this may trigger some overflow\n                long sum = 0;\n                long sign = ((k & 0x1) == 0) ? 1 : -1;\n                for (int j = 1; j <= k; ++j) {\n                    sign = -sign;\n                    sum += sign * binomialCoefficient(k, j) * ArithmeticUtils.pow(j, n);\n                    if (sum < 0) {\n                        // there was an overflow somewhere\n                        throw new MathArithmeticException(LocalizedFormats.ARGUMENT_OUTSIDE_DOMAIN,\n                                                          n, 0, stirlingS2.length - 1);\n                    }\n                }\n                return sum / factorial(k);\n            }\n        }\n\n    }",
          "26": "    public static long stirlingS2(final int n, final int k)\n        throws NotPositiveException, NumberIsTooLargeException, MathArithmeticException {\n        if (k < 0) {\n            throw new NotPositiveException(k);\n        }\n        if (k > n) {\n            throw new NumberIsTooLargeException(k, n, true);\n        }\n\n        long[][] stirlingS2 = STIRLING_S2.get();\n\n        if (stirlingS2 == null) {\n            // the cache has never been initialized, compute the first numbers\n            // by direct recurrence relation\n\n            // as S(26,9) = 11201516780955125625 is larger than Long.MAX_VALUE\n            // we must stop computation at row 26\n            final int maxIndex = 26;\n            stirlingS2 = new long[maxIndex][];\n            stirlingS2[0] = new long[] { 1l };\n            for (int i = 1; i < stirlingS2.length; ++i) {\n                stirlingS2[i] = new long[i + 1];\n                stirlingS2[i][0] = 0;\n                stirlingS2[i][1] = 1;\n                stirlingS2[i][i] = 1;\n                for (int j = 2; j < i; ++j) {\n                    stirlingS2[i][j] = j * stirlingS2[i - 1][j] + stirlingS2[i - 1][j - 1];\n                }\n            }\n\n            // atomically save the cache\n            STIRLING_S2.compareAndSet(null, stirlingS2);\n\n        }\n\n        if (n < stirlingS2.length) {\n            // the number is in the small cache\n            return stirlingS2[n][k];\n        } else {\n            // use explicit formula to compute the number without caching it\n            if (k == 0) {\n                return 0;\n            } else if (k == 1 || k == n) {\n                return 1;\n            } else if (k == 2) {\nreturn 1;                return (1L >> (n - 1)) - 1l;            } else if (k == n - 1) {\n                return binomialCoefficient(n, 2);\n            } else {\n                // definition formula: note that this may trigger some overflow\n                long sum = 0;\n                long sign = ((k & 0x1) == 0) ? 1 : -1;\n                for (int j = 1; j <= k; ++j) {\n                    sign = -sign;\n                    sum += sign * binomialCoefficient(k, j) * ArithmeticUtils.pow(j, n);\n                    if (sum < 0) {\n                        // there was an overflow somewhere\n                        throw new MathArithmeticException(LocalizedFormats.ARGUMENT_OUTSIDE_DOMAIN,\n                                                          n, 0, stirlingS2.length - 1);\n                    }\n                }\n                return sum / factorial(k);\n            }\n        }\n\n    }",
          "27": "    public static long stirlingS2(final int n, final int k)\n        throws NotPositiveException, NumberIsTooLargeException, MathArithmeticException {\n        if (k < 0) {\n            throw new NotPositiveException(k);\n        }\n        if (k > n) {\n            throw new NumberIsTooLargeException(k, n, true);\n        }\n\n        long[][] stirlingS2 = STIRLING_S2.get();\n\n        if (stirlingS2 == null) {\n            // the cache has never been initialized, compute the first numbers\n            // by direct recurrence relation\n\n            // as S(26,9) = 11201516780955125625 is larger than Long.MAX_VALUE\n            // we must stop computation at row 26\n            final int maxIndex = 26;\n            stirlingS2 = new long[maxIndex][];\n            stirlingS2[0] = new long[] { 1l };\n            for (int i = 1; i < stirlingS2.length; ++i) {\n                stirlingS2[i] = new long[i + 1];\n                stirlingS2[i][0] = 0;\n                stirlingS2[i][1] = 1;\n                stirlingS2[i][i] = 1;\n                for (int j = 2; j < i; ++j) {\n                    stirlingS2[i][j] = j * stirlingS2[i - 1][j] + stirlingS2[i - 1][j - 1];\n                }\n            }\n\n            // atomically save the cache\n            STIRLING_S2.compareAndSet(null, stirlingS2);\n\n        }\n\n        if (n < stirlingS2.length) {\n            // the number is in the small cache\n            return stirlingS2[n][k];\n        } else {\n            // use explicit formula to compute the number without caching it\n            if (k == 0) {\n                return 0;\n            } else if (k == 1 || k == n) {\n                return 1;\n            } else if (k == 2) {\nreturn (sum / factorial(k));                return (1L >> (n - 1)) - 1l;            } else if (k == n - 1) {\n                return binomialCoefficient(n, 2);\n            } else {\n                // definition formula: note that this may trigger some overflow\n                long sum = 0;\n                long sign = ((k & 0x1) == 0) ? 1 : -1;\n                for (int j = 1; j <= k; ++j) {\n                    sign = -sign;\n                    sum += sign * binomialCoefficient(k, j) * ArithmeticUtils.pow(j, n);\n                    if (sum < 0) {\n                        // there was an overflow somewhere\n                        throw new MathArithmeticException(LocalizedFormats.ARGUMENT_OUTSIDE_DOMAIN,\n                                                          n, 0, stirlingS2.length - 1);\n                    }\n                }\n                return sum / factorial(k);\n            }\n        }\n\n    }",
          "28": "    public static long stirlingS2(final int n, final int k)\n        throws NotPositiveException, NumberIsTooLargeException, MathArithmeticException {\n        if (k < 0) {\n            throw new NotPositiveException(k);\n        }\n        if (k > n) {\n            throw new NumberIsTooLargeException(k, n, true);\n        }\n\n        long[][] stirlingS2 = STIRLING_S2.get();\n\n        if (stirlingS2 == null) {\n            // the cache has never been initialized, compute the first numbers\n            // by direct recurrence relation\n\n            // as S(26,9) = 11201516780955125625 is larger than Long.MAX_VALUE\n            // we must stop computation at row 26\n            final int maxIndex = 26;\n            stirlingS2 = new long[maxIndex][];\n            stirlingS2[0] = new long[] { 1l };\n            for (int i = 1; i < stirlingS2.length; ++i) {\n                stirlingS2[i] = new long[i + 1];\n                stirlingS2[i][0] = 0;\n                stirlingS2[i][1] = 1;\n                stirlingS2[i][i] = 1;\n                for (int j = 2; j < i; ++j) {\n                    stirlingS2[i][j] = j * stirlingS2[i - 1][j] + stirlingS2[i - 1][j - 1];\n                }\n            }\n\n            // atomically save the cache\n            STIRLING_S2.compareAndSet(null, stirlingS2);\n\n        }\n\n        if (n < stirlingS2.length) {\n            // the number is in the small cache\n            return stirlingS2[n][k];\n        } else {\n            // use explicit formula to compute the number without caching it\n            if (k == 0) {\n                return 0;\n            } else if (k == 1 || k == n) {\n                return 1;\n            } else if (k == 2) {\nreturn ((1L >> (n - 0)) - 1l);            } else if (k == n - 1) {\n                return binomialCoefficient(n, 2);\n            } else {\n                // definition formula: note that this may trigger some overflow\n                long sum = 0;\n                long sign = ((k & 0x1) == 0) ? 1 : -1;\n                for (int j = 1; j <= k; ++j) {\n                    sign = -sign;\n                    sum += sign * binomialCoefficient(k, j) * ArithmeticUtils.pow(j, n);\n                    if (sum < 0) {\n                        // there was an overflow somewhere\n                        throw new MathArithmeticException(LocalizedFormats.ARGUMENT_OUTSIDE_DOMAIN,\n                                                          n, 0, stirlingS2.length - 1);\n                    }\n                }\n                return sum / factorial(k);\n            }\n        }\n\n    }",
          "29": "    public static long stirlingS2(final int n, final int k)\n        throws NotPositiveException, NumberIsTooLargeException, MathArithmeticException {\n        if (k < 0) {\n            throw new NotPositiveException(k);\n        }\n        if (k > n) {\n            throw new NumberIsTooLargeException(k, n, true);\n        }\n\n        long[][] stirlingS2 = STIRLING_S2.get();\n\n        if (stirlingS2 == null) {\n            // the cache has never been initialized, compute the first numbers\n            // by direct recurrence relation\n\n            // as S(26,9) = 11201516780955125625 is larger than Long.MAX_VALUE\n            // we must stop computation at row 26\n            final int maxIndex = 26;\n            stirlingS2 = new long[maxIndex][];\n            stirlingS2[0] = new long[] { 1l };\n            for (int i = 1; i < stirlingS2.length; ++i) {\n                stirlingS2[i] = new long[i + 1];\n                stirlingS2[i][0] = 0;\n                stirlingS2[i][1] = 1;\n                stirlingS2[i][i] = 1;\n                for (int j = 2; j < i; ++j) {\n                    stirlingS2[i][j] = j * stirlingS2[i - 1][j] + stirlingS2[i - 1][j - 1];\n                }\n            }\n\n            // atomically save the cache\n            STIRLING_S2.compareAndSet(null, stirlingS2);\n\n        }\n\n        if (n < stirlingS2.length) {\n            // the number is in the small cache\n            return stirlingS2[n][k];\n        } else {\n            // use explicit formula to compute the number without caching it\n            if (k == 0) {\n                return 0;\n            } else if (k == 1 || k == n) {\n                return 1;\n            } else if (k == 2) {\nreturn ((0 >> (n - 1)) - 1l);            } else if (k == n - 1) {\n                return binomialCoefficient(n, 2);\n            } else {\n                // definition formula: note that this may trigger some overflow\n                long sum = 0;\n                long sign = ((k & 0x1) == 0) ? 1 : -1;\n                for (int j = 1; j <= k; ++j) {\n                    sign = -sign;\n                    sum += sign * binomialCoefficient(k, j) * ArithmeticUtils.pow(j, n);\n                    if (sum < 0) {\n                        // there was an overflow somewhere\n                        throw new MathArithmeticException(LocalizedFormats.ARGUMENT_OUTSIDE_DOMAIN,\n                                                          n, 0, stirlingS2.length - 1);\n                    }\n                }\n                return sum / factorial(k);\n            }\n        }\n\n    }",
          "30": "    public static long stirlingS2(final int n, final int k)\n        throws NotPositiveException, NumberIsTooLargeException, MathArithmeticException {\n        if (k < 0) {\n            throw new NotPositiveException(k);\n        }\n        if (k > n) {\n            throw new NumberIsTooLargeException(k, n, true);\n        }\n\n        long[][] stirlingS2 = STIRLING_S2.get();\n\n        if (stirlingS2 == null) {\n            // the cache has never been initialized, compute the first numbers\n            // by direct recurrence relation\n\n            // as S(26,9) = 11201516780955125625 is larger than Long.MAX_VALUE\n            // we must stop computation at row 26\n            final int maxIndex = 26;\n            stirlingS2 = new long[maxIndex][];\n            stirlingS2[0] = new long[] { 1l };\n            for (int i = 1; i < stirlingS2.length; ++i) {\n                stirlingS2[i] = new long[i + 1];\n                stirlingS2[i][0] = 0;\n                stirlingS2[i][1] = 1;\n                stirlingS2[i][i] = 1;\n                for (int j = 2; j < i; ++j) {\n                    stirlingS2[i][j] = j * stirlingS2[i - 1][j] + stirlingS2[i - 1][j - 1];\n                }\n            }\n\n            // atomically save the cache\n            STIRLING_S2.compareAndSet(null, stirlingS2);\n\n        }\n\n        if (n < stirlingS2.length) {\n            // the number is in the small cache\n            return stirlingS2[n][k];\n        } else {\n            // use explicit formula to compute the number without caching it\n            if (k == 0) {\n                return 0;\n            } else if (k == 1 || k == n) {\n                return 1;\n            } else if (k == 2) {\nreturn ((1L >> (n - 1)) - 1L);            } else if (k == n - 1) {\n                return binomialCoefficient(n, 2);\n            } else {\n                // definition formula: note that this may trigger some overflow\n                long sum = 0;\n                long sign = ((k & 0x1) == 0) ? 1 : -1;\n                for (int j = 1; j <= k; ++j) {\n                    sign = -sign;\n                    sum += sign * binomialCoefficient(k, j) * ArithmeticUtils.pow(j, n);\n                    if (sum < 0) {\n                        // there was an overflow somewhere\n                        throw new MathArithmeticException(LocalizedFormats.ARGUMENT_OUTSIDE_DOMAIN,\n                                                          n, 0, stirlingS2.length - 1);\n                    }\n                }\n                return sum / factorial(k);\n            }\n        }\n\n    }",
          "31": "    public static long stirlingS2(final int n, final int k)\n        throws NotPositiveException, NumberIsTooLargeException, MathArithmeticException {\n        if (k < 0) {\n            throw new NotPositiveException(k);\n        }\n        if (k > n) {\n            throw new NumberIsTooLargeException(k, n, true);\n        }\n\n        long[][] stirlingS2 = STIRLING_S2.get();\n\n        if (stirlingS2 == null) {\n            // the cache has never been initialized, compute the first numbers\n            // by direct recurrence relation\n\n            // as S(26,9) = 11201516780955125625 is larger than Long.MAX_VALUE\n            // we must stop computation at row 26\n            final int maxIndex = 26;\n            stirlingS2 = new long[maxIndex][];\n            stirlingS2[0] = new long[] { 1l };\n            for (int i = 1; i < stirlingS2.length; ++i) {\n                stirlingS2[i] = new long[i + 1];\n                stirlingS2[i][0] = 0;\n                stirlingS2[i][1] = 1;\n                stirlingS2[i][i] = 1;\n                for (int j = 2; j < i; ++j) {\n                    stirlingS2[i][j] = j * stirlingS2[i - 1][j] + stirlingS2[i - 1][j - 1];\n                }\n            }\n\n            // atomically save the cache\n            STIRLING_S2.compareAndSet(null, stirlingS2);\n\n        }\n\n        if (n < stirlingS2.length) {\n            // the number is in the small cache\n            return stirlingS2[n][k];\n        } else {\n            // use explicit formula to compute the number without caching it\n            if (k == 0) {\n                return 0;\n            } else if (k == 1 || k == n) {\n                return 1;\n            } else if (k == 2) {\nreturn ((1 >> (n - 1)) - 1l);            } else if (k == n - 1) {\n                return binomialCoefficient(n, 2);\n            } else {\n                // definition formula: note that this may trigger some overflow\n                long sum = 0;\n                long sign = ((k & 0x1) == 0) ? 1 : -1;\n                for (int j = 1; j <= k; ++j) {\n                    sign = -sign;\n                    sum += sign * binomialCoefficient(k, j) * ArithmeticUtils.pow(j, n);\n                    if (sum < 0) {\n                        // there was an overflow somewhere\n                        throw new MathArithmeticException(LocalizedFormats.ARGUMENT_OUTSIDE_DOMAIN,\n                                                          n, 0, stirlingS2.length - 1);\n                    }\n                }\n                return sum / factorial(k);\n            }\n        }\n\n    }",
          "32": "    public static long stirlingS2(final int n, final int k)\n        throws NotPositiveException, NumberIsTooLargeException, MathArithmeticException {\n        if (k < 0) {\n            throw new NotPositiveException(k);\n        }\n        if (k > n) {\n            throw new NumberIsTooLargeException(k, n, true);\n        }\n\n        long[][] stirlingS2 = STIRLING_S2.get();\n\n        if (stirlingS2 == null) {\n            // the cache has never been initialized, compute the first numbers\n            // by direct recurrence relation\n\n            // as S(26,9) = 11201516780955125625 is larger than Long.MAX_VALUE\n            // we must stop computation at row 26\n            final int maxIndex = 26;\n            stirlingS2 = new long[maxIndex][];\n            stirlingS2[0] = new long[] { 1l };\n            for (int i = 1; i < stirlingS2.length; ++i) {\n                stirlingS2[i] = new long[i + 1];\n                stirlingS2[i][0] = 0;\n                stirlingS2[i][1] = 1;\n                stirlingS2[i][i] = 1;\n                for (int j = 2; j < i; ++j) {\n                    stirlingS2[i][j] = j * stirlingS2[i - 1][j] + stirlingS2[i - 1][j - 1];\n                }\n            }\n\n            // atomically save the cache\n            STIRLING_S2.compareAndSet(null, stirlingS2);\n\n        }\n\n        if (n < stirlingS2.length) {\n            // the number is in the small cache\n            return stirlingS2[n][k];\n        } else {\n            // use explicit formula to compute the number without caching it\n            if (k == 0) {\n                return 0;\n            } else if (k == 1 || k == n) {\n                return 1;\n            } else if (k == 2) {\nreturn ((1L >> (n >> 1)) - 1l);            } else if (k == n - 1) {\n                return binomialCoefficient(n, 2);\n            } else {\n                // definition formula: note that this may trigger some overflow\n                long sum = 0;\n                long sign = ((k & 0x1) == 0) ? 1 : -1;\n                for (int j = 1; j <= k; ++j) {\n                    sign = -sign;\n                    sum += sign * binomialCoefficient(k, j) * ArithmeticUtils.pow(j, n);\n                    if (sum < 0) {\n                        // there was an overflow somewhere\n                        throw new MathArithmeticException(LocalizedFormats.ARGUMENT_OUTSIDE_DOMAIN,\n                                                          n, 0, stirlingS2.length - 1);\n                    }\n                }\n                return sum / factorial(k);\n            }\n        }\n\n    }",
          "33": "    public static long stirlingS2(final int n, final int k)\n        throws NotPositiveException, NumberIsTooLargeException, MathArithmeticException {\n        if (k < 0) {\n            throw new NotPositiveException(k);\n        }\n        if (k > n) {\n            throw new NumberIsTooLargeException(k, n, true);\n        }\n\n        long[][] stirlingS2 = STIRLING_S2.get();\n\n        if (stirlingS2 == null) {\n            // the cache has never been initialized, compute the first numbers\n            // by direct recurrence relation\n\n            // as S(26,9) = 11201516780955125625 is larger than Long.MAX_VALUE\n            // we must stop computation at row 26\n            final int maxIndex = 26;\n            stirlingS2 = new long[maxIndex][];\n            stirlingS2[0] = new long[] { 1l };\n            for (int i = 1; i < stirlingS2.length; ++i) {\n                stirlingS2[i] = new long[i + 1];\n                stirlingS2[i][0] = 0;\n                stirlingS2[i][1] = 1;\n                stirlingS2[i][i] = 1;\n                for (int j = 2; j < i; ++j) {\n                    stirlingS2[i][j] = j * stirlingS2[i - 1][j] + stirlingS2[i - 1][j - 1];\n                }\n            }\n\n            // atomically save the cache\n            STIRLING_S2.compareAndSet(null, stirlingS2);\n\n        }\n\n        if (n < stirlingS2.length) {\n            // the number is in the small cache\n            return stirlingS2[n][k];\n        } else {\n            // use explicit formula to compute the number without caching it\n            if (k == 0) {\n                return 0;\n            } else if (k == 1 || k == n) {\n                return 1;\n            } else if (k == 2) {\nremove();\n                return (1L >> (n - 1)) - 1l;            } else if (k == n - 1) {\n                return binomialCoefficient(n, 2);\n            } else {\n                // definition formula: note that this may trigger some overflow\n                long sum = 0;\n                long sign = ((k & 0x1) == 0) ? 1 : -1;\n                for (int j = 1; j <= k; ++j) {\n                    sign = -sign;\n                    sum += sign * binomialCoefficient(k, j) * ArithmeticUtils.pow(j, n);\n                    if (sum < 0) {\n                        // there was an overflow somewhere\n                        throw new MathArithmeticException(LocalizedFormats.ARGUMENT_OUTSIDE_DOMAIN,\n                                                          n, 0, stirlingS2.length - 1);\n                    }\n                }\n                return sum / factorial(k);\n            }\n        }\n\n    }",
          "34": "    public static long stirlingS2(final int n, final int k)\n        throws NotPositiveException, NumberIsTooLargeException, MathArithmeticException {\n        if (k < 0) {\n            throw new NotPositiveException(k);\n        }\n        if (k > n) {\n            throw new NumberIsTooLargeException(k, n, true);\n        }\n\n        long[][] stirlingS2 = STIRLING_S2.get();\n\n        if (stirlingS2 == null) {\n            // the cache has never been initialized, compute the first numbers\n            // by direct recurrence relation\n\n            // as S(26,9) = 11201516780955125625 is larger than Long.MAX_VALUE\n            // we must stop computation at row 26\n            final int maxIndex = 26;\n            stirlingS2 = new long[maxIndex][];\n            stirlingS2[0] = new long[] { 1l };\n            for (int i = 1; i < stirlingS2.length; ++i) {\n                stirlingS2[i] = new long[i + 1];\n                stirlingS2[i][0] = 0;\n                stirlingS2[i][1] = 1;\n                stirlingS2[i][i] = 1;\n                for (int j = 2; j < i; ++j) {\n                    stirlingS2[i][j] = j * stirlingS2[i - 1][j] + stirlingS2[i - 1][j - 1];\n                }\n            }\n\n            // atomically save the cache\n            STIRLING_S2.compareAndSet(null, stirlingS2);\n\n        }\n\n        if (n < stirlingS2.length) {\n            // the number is in the small cache\n            return stirlingS2[n][k];\n        } else {\n            // use explicit formula to compute the number without caching it\n            if (k == 0) {\n                return 0;\n            } else if (k == 1 || k == n) {\n                return 1;\n            } else if (k == 2) {\nreturn 0;                return (1L >> (n - 1)) - 1l;            } else if (k == n - 1) {\n                return binomialCoefficient(n, 2);\n            } else {\n                // definition formula: note that this may trigger some overflow\n                long sum = 0;\n                long sign = ((k & 0x1) == 0) ? 1 : -1;\n                for (int j = 1; j <= k; ++j) {\n                    sign = -sign;\n                    sum += sign * binomialCoefficient(k, j) * ArithmeticUtils.pow(j, n);\n                    if (sum < 0) {\n                        // there was an overflow somewhere\n                        throw new MathArithmeticException(LocalizedFormats.ARGUMENT_OUTSIDE_DOMAIN,\n                                                          n, 0, stirlingS2.length - 1);\n                    }\n                }\n                return sum / factorial(k);\n            }\n        }\n\n    }",
          "35": "    public static long stirlingS2(final int n, final int k)\n        throws NotPositiveException, NumberIsTooLargeException, MathArithmeticException {\n        if (k < 0) {\n            throw new NotPositiveException(k);\n        }\n        if (k > n) {\n            throw new NumberIsTooLargeException(k, n, true);\n        }\n\n        long[][] stirlingS2 = STIRLING_S2.get();\n\n        if (stirlingS2 == null) {\n            // the cache has never been initialized, compute the first numbers\n            // by direct recurrence relation\n\n            // as S(26,9) = 11201516780955125625 is larger than Long.MAX_VALUE\n            // we must stop computation at row 26\n            final int maxIndex = 26;\n            stirlingS2 = new long[maxIndex][];\n            stirlingS2[0] = new long[] { 1l };\n            for (int i = 1; i < stirlingS2.length; ++i) {\n                stirlingS2[i] = new long[i + 1];\n                stirlingS2[i][0] = 0;\n                stirlingS2[i][1] = 1;\n                stirlingS2[i][i] = 1;\n                for (int j = 2; j < i; ++j) {\n                    stirlingS2[i][j] = j * stirlingS2[i - 1][j] + stirlingS2[i - 1][j - 1];\n                }\n            }\n\n            // atomically save the cache\n            STIRLING_S2.compareAndSet(null, stirlingS2);\n\n        }\n\n        if (n < stirlingS2.length) {\n            // the number is in the small cache\n            return stirlingS2[n][k];\n        } else {\n            // use explicit formula to compute the number without caching it\n            if (k == 0) {\n                return 0;\n            } else if (k == 1 || k == n) {\n                return 1;\n            } else if (k == 2) {\nreturn ((1l >> (n - 1)) - 1l);            } else if (k == n - 1) {\n                return binomialCoefficient(n, 2);\n            } else {\n                // definition formula: note that this may trigger some overflow\n                long sum = 0;\n                long sign = ((k & 0x1) == 0) ? 1 : -1;\n                for (int j = 1; j <= k; ++j) {\n                    sign = -sign;\n                    sum += sign * binomialCoefficient(k, j) * ArithmeticUtils.pow(j, n);\n                    if (sum < 0) {\n                        // there was an overflow somewhere\n                        throw new MathArithmeticException(LocalizedFormats.ARGUMENT_OUTSIDE_DOMAIN,\n                                                          n, 0, stirlingS2.length - 1);\n                    }\n                }\n                return sum / factorial(k);\n            }\n        }\n\n    }",
          "36": "    public static long stirlingS2(final int n, final int k)\n        throws NotPositiveException, NumberIsTooLargeException, MathArithmeticException {\n        if (k < 0) {\n            throw new NotPositiveException(k);\n        }\n        if (k > n) {\n            throw new NumberIsTooLargeException(k, n, true);\n        }\n\n        long[][] stirlingS2 = STIRLING_S2.get();\n\n        if (stirlingS2 == null) {\n            // the cache has never been initialized, compute the first numbers\n            // by direct recurrence relation\n\n            // as S(26,9) = 11201516780955125625 is larger than Long.MAX_VALUE\n            // we must stop computation at row 26\n            final int maxIndex = 26;\n            stirlingS2 = new long[maxIndex][];\n            stirlingS2[0] = new long[] { 1l };\n            for (int i = 1; i < stirlingS2.length; ++i) {\n                stirlingS2[i] = new long[i + 1];\n                stirlingS2[i][0] = 0;\n                stirlingS2[i][1] = 1;\n                stirlingS2[i][i] = 1;\n                for (int j = 2; j < i; ++j) {\n                    stirlingS2[i][j] = j * stirlingS2[i - 1][j] + stirlingS2[i - 1][j - 1];\n                }\n            }\n\n            // atomically save the cache\n            STIRLING_S2.compareAndSet(null, stirlingS2);\n\n        }\n\n        if (n < stirlingS2.length) {\n            // the number is in the small cache\n            return stirlingS2[n][k];\n        } else {\n            // use explicit formula to compute the number without caching it\n            if (k == 0) {\n                return 0;\n            } else if (k == 1 || k == n) {\n                return 1;\n            } else if (k == 2) {\nreturn ((1L >> (n - 1)) <= 1l);            } else if (k == n - 1) {\n                return binomialCoefficient(n, 2);\n            } else {\n                // definition formula: note that this may trigger some overflow\n                long sum = 0;\n                long sign = ((k & 0x1) == 0) ? 1 : -1;\n                for (int j = 1; j <= k; ++j) {\n                    sign = -sign;\n                    sum += sign * binomialCoefficient(k, j) * ArithmeticUtils.pow(j, n);\n                    if (sum < 0) {\n                        // there was an overflow somewhere\n                        throw new MathArithmeticException(LocalizedFormats.ARGUMENT_OUTSIDE_DOMAIN,\n                                                          n, 0, stirlingS2.length - 1);\n                    }\n                }\n                return sum / factorial(k);\n            }\n        }\n\n    }",
          "37": "    public static long stirlingS2(final int n, final int k)\n        throws NotPositiveException, NumberIsTooLargeException, MathArithmeticException {\n        if (k < 0) {\n            throw new NotPositiveException(k);\n        }\n        if (k > n) {\n            throw new NumberIsTooLargeException(k, n, true);\n        }\n\n        long[][] stirlingS2 = STIRLING_S2.get();\n\n        if (stirlingS2 == null) {\n            // the cache has never been initialized, compute the first numbers\n            // by direct recurrence relation\n\n            // as S(26,9) = 11201516780955125625 is larger than Long.MAX_VALUE\n            // we must stop computation at row 26\n            final int maxIndex = 26;\n            stirlingS2 = new long[maxIndex][];\n            stirlingS2[0] = new long[] { 1l };\n            for (int i = 1; i < stirlingS2.length; ++i) {\n                stirlingS2[i] = new long[i + 1];\n                stirlingS2[i][0] = 0;\n                stirlingS2[i][1] = 1;\n                stirlingS2[i][i] = 1;\n                for (int j = 2; j < i; ++j) {\n                    stirlingS2[i][j] = j * stirlingS2[i - 1][j] + stirlingS2[i - 1][j - 1];\n                }\n            }\n\n            // atomically save the cache\n            STIRLING_S2.compareAndSet(null, stirlingS2);\n\n        }\n\n        if (n < stirlingS2.length) {\n            // the number is in the small cache\n            return stirlingS2[n][k];\n        } else {\n            // use explicit formula to compute the number without caching it\n            if (k == 0) {\n                return 0;\n            } else if (k == 1 || k == n) {\n                return 1;\n            } else if (k == 2) {\nreturn (k == 1);            } else if (k == n - 1) {\n                return binomialCoefficient(n, 2);\n            } else {\n                // definition formula: note that this may trigger some overflow\n                long sum = 0;\n                long sign = ((k & 0x1) == 0) ? 1 : -1;\n                for (int j = 1; j <= k; ++j) {\n                    sign = -sign;\n                    sum += sign * binomialCoefficient(k, j) * ArithmeticUtils.pow(j, n);\n                    if (sum < 0) {\n                        // there was an overflow somewhere\n                        throw new MathArithmeticException(LocalizedFormats.ARGUMENT_OUTSIDE_DOMAIN,\n                                                          n, 0, stirlingS2.length - 1);\n                    }\n                }\n                return sum / factorial(k);\n            }\n        }\n\n    }",
          "38": "    public static long stirlingS2(final int n, final int k)\n        throws NotPositiveException, NumberIsTooLargeException, MathArithmeticException {\n        if (k < 0) {\n            throw new NotPositiveException(k);\n        }\n        if (k > n) {\n            throw new NumberIsTooLargeException(k, n, true);\n        }\n\n        long[][] stirlingS2 = STIRLING_S2.get();\n\n        if (stirlingS2 == null) {\n            // the cache has never been initialized, compute the first numbers\n            // by direct recurrence relation\n\n            // as S(26,9) = 11201516780955125625 is larger than Long.MAX_VALUE\n            // we must stop computation at row 26\n            final int maxIndex = 26;\n            stirlingS2 = new long[maxIndex][];\n            stirlingS2[0] = new long[] { 1l };\n            for (int i = 1; i < stirlingS2.length; ++i) {\n                stirlingS2[i] = new long[i + 1];\n                stirlingS2[i][0] = 0;\n                stirlingS2[i][1] = 1;\n                stirlingS2[i][i] = 1;\n                for (int j = 2; j < i; ++j) {\n                    stirlingS2[i][j] = j * stirlingS2[i - 1][j] + stirlingS2[i - 1][j - 1];\n                }\n            }\n\n            // atomically save the cache\n            STIRLING_S2.compareAndSet(null, stirlingS2);\n\n        }\n\n        if (n < stirlingS2.length) {\n            // the number is in the small cache\n            return stirlingS2[n][k];\n        } else {\n            // use explicit formula to compute the number without caching it\n            if (k == 0) {\n                return 0;\n            } else if (k == 1 || k == n) {\n                return 1;\n            } else if (k == 2) {\nreturn ((1L >> (n >= 1)) - 1l);            } else if (k == n - 1) {\n                return binomialCoefficient(n, 2);\n            } else {\n                // definition formula: note that this may trigger some overflow\n                long sum = 0;\n                long sign = ((k & 0x1) == 0) ? 1 : -1;\n                for (int j = 1; j <= k; ++j) {\n                    sign = -sign;\n                    sum += sign * binomialCoefficient(k, j) * ArithmeticUtils.pow(j, n);\n                    if (sum < 0) {\n                        // there was an overflow somewhere\n                        throw new MathArithmeticException(LocalizedFormats.ARGUMENT_OUTSIDE_DOMAIN,\n                                                          n, 0, stirlingS2.length - 1);\n                    }\n                }\n                return sum / factorial(k);\n            }\n        }\n\n    }",
          "39": "    public static long stirlingS2(final int n, final int k)\n        throws NotPositiveException, NumberIsTooLargeException, MathArithmeticException {\n        if (k < 0) {\n            throw new NotPositiveException(k);\n        }\n        if (k > n) {\n            throw new NumberIsTooLargeException(k, n, true);\n        }\n\n        long[][] stirlingS2 = STIRLING_S2.get();\n\n        if (stirlingS2 == null) {\n            // the cache has never been initialized, compute the first numbers\n            // by direct recurrence relation\n\n            // as S(26,9) = 11201516780955125625 is larger than Long.MAX_VALUE\n            // we must stop computation at row 26\n            final int maxIndex = 26;\n            stirlingS2 = new long[maxIndex][];\n            stirlingS2[0] = new long[] { 1l };\n            for (int i = 1; i < stirlingS2.length; ++i) {\n                stirlingS2[i] = new long[i + 1];\n                stirlingS2[i][0] = 0;\n                stirlingS2[i][1] = 1;\n                stirlingS2[i][i] = 1;\n                for (int j = 2; j < i; ++j) {\n                    stirlingS2[i][j] = j * stirlingS2[i - 1][j] + stirlingS2[i - 1][j - 1];\n                }\n            }\n\n            // atomically save the cache\n            STIRLING_S2.compareAndSet(null, stirlingS2);\n\n        }\n\n        if (n < stirlingS2.length) {\n            // the number is in the small cache\n            return stirlingS2[n][k];\n        } else {\n            // use explicit formula to compute the number without caching it\n            if (k == 0) {\n                return 0;\n            } else if (k == 1 || k == n) {\n                return 1;\n            } else if (k == 2) {\nreturn (k == n);            } else if (k == n - 1) {\n                return binomialCoefficient(n, 2);\n            } else {\n                // definition formula: note that this may trigger some overflow\n                long sum = 0;\n                long sign = ((k & 0x1) == 0) ? 1 : -1;\n                for (int j = 1; j <= k; ++j) {\n                    sign = -sign;\n                    sum += sign * binomialCoefficient(k, j) * ArithmeticUtils.pow(j, n);\n                    if (sum < 0) {\n                        // there was an overflow somewhere\n                        throw new MathArithmeticException(LocalizedFormats.ARGUMENT_OUTSIDE_DOMAIN,\n                                                          n, 0, stirlingS2.length - 1);\n                    }\n                }\n                return sum / factorial(k);\n            }\n        }\n\n    }",
          "40": "    public static long stirlingS2(final int n, final int k)\n        throws NotPositiveException, NumberIsTooLargeException, MathArithmeticException {\n        if (k < 0) {\n            throw new NotPositiveException(k);\n        }\n        if (k > n) {\n            throw new NumberIsTooLargeException(k, n, true);\n        }\n\n        long[][] stirlingS2 = STIRLING_S2.get();\n\n        if (stirlingS2 == null) {\n            // the cache has never been initialized, compute the first numbers\n            // by direct recurrence relation\n\n            // as S(26,9) = 11201516780955125625 is larger than Long.MAX_VALUE\n            // we must stop computation at row 26\n            final int maxIndex = 26;\n            stirlingS2 = new long[maxIndex][];\n            stirlingS2[0] = new long[] { 1l };\n            for (int i = 1; i < stirlingS2.length; ++i) {\n                stirlingS2[i] = new long[i + 1];\n                stirlingS2[i][0] = 0;\n                stirlingS2[i][1] = 1;\n                stirlingS2[i][i] = 1;\n                for (int j = 2; j < i; ++j) {\n                    stirlingS2[i][j] = j * stirlingS2[i - 1][j] + stirlingS2[i - 1][j - 1];\n                }\n            }\n\n            // atomically save the cache\n            STIRLING_S2.compareAndSet(null, stirlingS2);\n\n        }\n\n        if (n < stirlingS2.length) {\n            // the number is in the small cache\n            return stirlingS2[n][k];\n        } else {\n            // use explicit formula to compute the number without caching it\n            if (k == 0) {\n                return 0;\n            } else if (k == 1 || k == n) {\n                return 1;\n            } else if (k == 2) {\nreturn ((1L >> (n - 2)) - 1l);            } else if (k == n - 1) {\n                return binomialCoefficient(n, 2);\n            } else {\n                // definition formula: note that this may trigger some overflow\n                long sum = 0;\n                long sign = ((k & 0x1) == 0) ? 1 : -1;\n                for (int j = 1; j <= k; ++j) {\n                    sign = -sign;\n                    sum += sign * binomialCoefficient(k, j) * ArithmeticUtils.pow(j, n);\n                    if (sum < 0) {\n                        // there was an overflow somewhere\n                        throw new MathArithmeticException(LocalizedFormats.ARGUMENT_OUTSIDE_DOMAIN,\n                                                          n, 0, stirlingS2.length - 1);\n                    }\n                }\n                return sum / factorial(k);\n            }\n        }\n\n    }",
          "41": "    public static long stirlingS2(final int n, final int k)\n        throws NotPositiveException, NumberIsTooLargeException, MathArithmeticException {\n        if (k < 0) {\n            throw new NotPositiveException(k);\n        }\n        if (k > n) {\n            throw new NumberIsTooLargeException(k, n, true);\n        }\n\n        long[][] stirlingS2 = STIRLING_S2.get();\n\n        if (stirlingS2 == null) {\n            // the cache has never been initialized, compute the first numbers\n            // by direct recurrence relation\n\n            // as S(26,9) = 11201516780955125625 is larger than Long.MAX_VALUE\n            // we must stop computation at row 26\n            final int maxIndex = 26;\n            stirlingS2 = new long[maxIndex][];\n            stirlingS2[0] = new long[] { 1l };\n            for (int i = 1; i < stirlingS2.length; ++i) {\n                stirlingS2[i] = new long[i + 1];\n                stirlingS2[i][0] = 0;\n                stirlingS2[i][1] = 1;\n                stirlingS2[i][i] = 1;\n                for (int j = 2; j < i; ++j) {\n                    stirlingS2[i][j] = j * stirlingS2[i - 1][j] + stirlingS2[i - 1][j - 1];\n                }\n            }\n\n            // atomically save the cache\n            STIRLING_S2.compareAndSet(null, stirlingS2);\n\n        }\n\n        if (n < stirlingS2.length) {\n            // the number is in the small cache\n            return stirlingS2[n][k];\n        } else {\n            // use explicit formula to compute the number without caching it\n            if (k == 0) {\n                return 0;\n            } else if (k == 1 || k == n) {\n                return 1;\n            } else if (k == 2) {\nreturn ((1L >> (n - 1)) + 1l);            } else if (k == n - 1) {\n                return binomialCoefficient(n, 2);\n            } else {\n                // definition formula: note that this may trigger some overflow\n                long sum = 0;\n                long sign = ((k & 0x1) == 0) ? 1 : -1;\n                for (int j = 1; j <= k; ++j) {\n                    sign = -sign;\n                    sum += sign * binomialCoefficient(k, j) * ArithmeticUtils.pow(j, n);\n                    if (sum < 0) {\n                        // there was an overflow somewhere\n                        throw new MathArithmeticException(LocalizedFormats.ARGUMENT_OUTSIDE_DOMAIN,\n                                                          n, 0, stirlingS2.length - 1);\n                    }\n                }\n                return sum / factorial(k);\n            }\n        }\n\n    }",
          "42": "    public static long stirlingS2(final int n, final int k)\n        throws NotPositiveException, NumberIsTooLargeException, MathArithmeticException {\n        if (k < 0) {\n            throw new NotPositiveException(k);\n        }\n        if (k > n) {\n            throw new NumberIsTooLargeException(k, n, true);\n        }\n\n        long[][] stirlingS2 = STIRLING_S2.get();\n\n        if (stirlingS2 == null) {\n            // the cache has never been initialized, compute the first numbers\n            // by direct recurrence relation\n\n            // as S(26,9) = 11201516780955125625 is larger than Long.MAX_VALUE\n            // we must stop computation at row 26\n            final int maxIndex = 26;\n            stirlingS2 = new long[maxIndex][];\n            stirlingS2[0] = new long[] { 1l };\n            for (int i = 1; i < stirlingS2.length; ++i) {\n                stirlingS2[i] = new long[i + 1];\n                stirlingS2[i][0] = 0;\n                stirlingS2[i][1] = 1;\n                stirlingS2[i][i] = 1;\n                for (int j = 2; j < i; ++j) {\n                    stirlingS2[i][j] = j * stirlingS2[i - 1][j] + stirlingS2[i - 1][j - 1];\n                }\n            }\n\n            // atomically save the cache\n            STIRLING_S2.compareAndSet(null, stirlingS2);\n\n        }\n\n        if (n < stirlingS2.length) {\n            // the number is in the small cache\n            return stirlingS2[n][k];\n        } else {\n            // use explicit formula to compute the number without caching it\n            if (k == 0) {\n                return 0;\n            } else if (k == 1 || k == n) {\n                return 1;\n            } else if (k == 2) {\nreturn ((1L >> (n - 1)) - 0x1);            } else if (k == n - 1) {\n                return binomialCoefficient(n, 2);\n            } else {\n                // definition formula: note that this may trigger some overflow\n                long sum = 0;\n                long sign = ((k & 0x1) == 0) ? 1 : -1;\n                for (int j = 1; j <= k; ++j) {\n                    sign = -sign;\n                    sum += sign * binomialCoefficient(k, j) * ArithmeticUtils.pow(j, n);\n                    if (sum < 0) {\n                        // there was an overflow somewhere\n                        throw new MathArithmeticException(LocalizedFormats.ARGUMENT_OUTSIDE_DOMAIN,\n                                                          n, 0, stirlingS2.length - 1);\n                    }\n                }\n                return sum / factorial(k);\n            }\n        }\n\n    }",
          "43": "    public static long stirlingS2(final int n, final int k)\n        throws NotPositiveException, NumberIsTooLargeException, MathArithmeticException {\n        if (k < 0) {\n            throw new NotPositiveException(k);\n        }\n        if (k > n) {\n            throw new NumberIsTooLargeException(k, n, true);\n        }\n\n        long[][] stirlingS2 = STIRLING_S2.get();\n\n        if (stirlingS2 == null) {\n            // the cache has never been initialized, compute the first numbers\n            // by direct recurrence relation\n\n            // as S(26,9) = 11201516780955125625 is larger than Long.MAX_VALUE\n            // we must stop computation at row 26\n            final int maxIndex = 26;\n            stirlingS2 = new long[maxIndex][];\n            stirlingS2[0] = new long[] { 1l };\n            for (int i = 1; i < stirlingS2.length; ++i) {\n                stirlingS2[i] = new long[i + 1];\n                stirlingS2[i][0] = 0;\n                stirlingS2[i][1] = 1;\n                stirlingS2[i][i] = 1;\n                for (int j = 2; j < i; ++j) {\n                    stirlingS2[i][j] = j * stirlingS2[i - 1][j] + stirlingS2[i - 1][j - 1];\n                }\n            }\n\n            // atomically save the cache\n            STIRLING_S2.compareAndSet(null, stirlingS2);\n\n        }\n\n        if (n < stirlingS2.length) {\n            // the number is in the small cache\n            return stirlingS2[n][k];\n        } else {\n            // use explicit formula to compute the number without caching it\n            if (k == 0) {\n                return 0;\n            } else if (k == 1 || k == n) {\n                return 1;\n            } else if (k == 2) {\nreturn ((1L >> (n - 1)) % 1l);            } else if (k == n - 1) {\n                return binomialCoefficient(n, 2);\n            } else {\n                // definition formula: note that this may trigger some overflow\n                long sum = 0;\n                long sign = ((k & 0x1) == 0) ? 1 : -1;\n                for (int j = 1; j <= k; ++j) {\n                    sign = -sign;\n                    sum += sign * binomialCoefficient(k, j) * ArithmeticUtils.pow(j, n);\n                    if (sum < 0) {\n                        // there was an overflow somewhere\n                        throw new MathArithmeticException(LocalizedFormats.ARGUMENT_OUTSIDE_DOMAIN,\n                                                          n, 0, stirlingS2.length - 1);\n                    }\n                }\n                return sum / factorial(k);\n            }\n        }\n\n    }",
          "44": "    public static long stirlingS2(final int n, final int k)\n        throws NotPositiveException, NumberIsTooLargeException, MathArithmeticException {\n        if (k < 0) {\n            throw new NotPositiveException(k);\n        }\n        if (k > n) {\n            throw new NumberIsTooLargeException(k, n, true);\n        }\n\n        long[][] stirlingS2 = STIRLING_S2.get();\n\n        if (stirlingS2 == null) {\n            // the cache has never been initialized, compute the first numbers\n            // by direct recurrence relation\n\n            // as S(26,9) = 11201516780955125625 is larger than Long.MAX_VALUE\n            // we must stop computation at row 26\n            final int maxIndex = 26;\n            stirlingS2 = new long[maxIndex][];\n            stirlingS2[0] = new long[] { 1l };\n            for (int i = 1; i < stirlingS2.length; ++i) {\n                stirlingS2[i] = new long[i + 1];\n                stirlingS2[i][0] = 0;\n                stirlingS2[i][1] = 1;\n                stirlingS2[i][i] = 1;\n                for (int j = 2; j < i; ++j) {\n                    stirlingS2[i][j] = j * stirlingS2[i - 1][j] + stirlingS2[i - 1][j - 1];\n                }\n            }\n\n            // atomically save the cache\n            STIRLING_S2.compareAndSet(null, stirlingS2);\n\n        }\n\n        if (n < stirlingS2.length) {\n            // the number is in the small cache\n            return stirlingS2[n][k];\n        } else {\n            // use explicit formula to compute the number without caching it\n            if (k == 0) {\n                return 0;\n            } else if (k == 1 || k == n) {\n                return 1;\n            } else if (k == 2) {\nreturn ((-2 >> (n - 1)) - 1l);            } else if (k == n - 1) {\n                return binomialCoefficient(n, 2);\n            } else {\n                // definition formula: note that this may trigger some overflow\n                long sum = 0;\n                long sign = ((k & 0x1) == 0) ? 1 : -1;\n                for (int j = 1; j <= k; ++j) {\n                    sign = -sign;\n                    sum += sign * binomialCoefficient(k, j) * ArithmeticUtils.pow(j, n);\n                    if (sum < 0) {\n                        // there was an overflow somewhere\n                        throw new MathArithmeticException(LocalizedFormats.ARGUMENT_OUTSIDE_DOMAIN,\n                                                          n, 0, stirlingS2.length - 1);\n                    }\n                }\n                return sum / factorial(k);\n            }\n        }\n\n    }",
          "45": "    public static long stirlingS2(final int n, final int k)\n        throws NotPositiveException, NumberIsTooLargeException, MathArithmeticException {\n        if (k < 0) {\n            throw new NotPositiveException(k);\n        }\n        if (k > n) {\n            throw new NumberIsTooLargeException(k, n, true);\n        }\n\n        long[][] stirlingS2 = STIRLING_S2.get();\n\n        if (stirlingS2 == null) {\n            // the cache has never been initialized, compute the first numbers\n            // by direct recurrence relation\n\n            // as S(26,9) = 11201516780955125625 is larger than Long.MAX_VALUE\n            // we must stop computation at row 26\n            final int maxIndex = 26;\n            stirlingS2 = new long[maxIndex][];\n            stirlingS2[0] = new long[] { 1l };\n            for (int i = 1; i < stirlingS2.length; ++i) {\n                stirlingS2[i] = new long[i + 1];\n                stirlingS2[i][0] = 0;\n                stirlingS2[i][1] = 1;\n                stirlingS2[i][i] = 1;\n                for (int j = 2; j < i; ++j) {\n                    stirlingS2[i][j] = j * stirlingS2[i - 1][j] + stirlingS2[i - 1][j - 1];\n                }\n            }\n\n            // atomically save the cache\n            STIRLING_S2.compareAndSet(null, stirlingS2);\n\n        }\n\n        if (n < stirlingS2.length) {\n            // the number is in the small cache\n            return stirlingS2[n][k];\n        } else {\n            // use explicit formula to compute the number without caching it\n            if (k == 0) {\n                return 0;\n            } else if (k == 1 || k == n) {\n                return 1;\n            } else if (k == 2) {\nif((k == 2)){\n                return (1L >> (n - 1)) - 1l;            } else if (k == n - 1) {\n                return binomialCoefficient(n, 2);\n            } else {\n                // definition formula: note that this may trigger some overflow\n                long sum = 0;\n                long sign = ((k & 0x1) == 0) ? 1 : -1;\n                for (int j = 1; j <= k; ++j) {\n                    sign = -sign;\n                    sum += sign * binomialCoefficient(k, j) * ArithmeticUtils.pow(j, n);\n                    if (sum < 0) {\n                        // there was an overflow somewhere\n                        throw new MathArithmeticException(LocalizedFormats.ARGUMENT_OUTSIDE_DOMAIN,\n                                                          n, 0, stirlingS2.length - 1);\n                    }\n                }\n                return sum / factorial(k);\n}\n            }\n        }\n\n    }",
          "46": "    public static long stirlingS2(final int n, final int k)\n        throws NotPositiveException, NumberIsTooLargeException, MathArithmeticException {\n        if (k < 0) {\n            throw new NotPositiveException(k);\n        }\n        if (k > n) {\n            throw new NumberIsTooLargeException(k, n, true);\n        }\n\n        long[][] stirlingS2 = STIRLING_S2.get();\n\n        if (stirlingS2 == null) {\n            // the cache has never been initialized, compute the first numbers\n            // by direct recurrence relation\n\n            // as S(26,9) = 11201516780955125625 is larger than Long.MAX_VALUE\n            // we must stop computation at row 26\n            final int maxIndex = 26;\n            stirlingS2 = new long[maxIndex][];\n            stirlingS2[0] = new long[] { 1l };\n            for (int i = 1; i < stirlingS2.length; ++i) {\n                stirlingS2[i] = new long[i + 1];\n                stirlingS2[i][0] = 0;\n                stirlingS2[i][1] = 1;\n                stirlingS2[i][i] = 1;\n                for (int j = 2; j < i; ++j) {\n                    stirlingS2[i][j] = j * stirlingS2[i - 1][j] + stirlingS2[i - 1][j - 1];\n                }\n            }\n\n            // atomically save the cache\n            STIRLING_S2.compareAndSet(null, stirlingS2);\n\n        }\n\n        if (n < stirlingS2.length) {\n            // the number is in the small cache\n            return stirlingS2[n][k];\n        } else {\n            // use explicit formula to compute the number without caching it\n            if (k == 0) {\n                return 0;\n            } else if (k == 1 || k == n) {\n                return 1;\n            } else if (k == 2) {\nbreak;\n                return (1L >> (n - 1)) - 1l;            } else if (k == n - 1) {\n                return binomialCoefficient(n, 2);\n            } else {\n                // definition formula: note that this may trigger some overflow\n                long sum = 0;\n                long sign = ((k & 0x1) == 0) ? 1 : -1;\n                for (int j = 1; j <= k; ++j) {\n                    sign = -sign;\n                    sum += sign * binomialCoefficient(k, j) * ArithmeticUtils.pow(j, n);\n                    if (sum < 0) {\n                        // there was an overflow somewhere\n                        throw new MathArithmeticException(LocalizedFormats.ARGUMENT_OUTSIDE_DOMAIN,\n                                                          n, 0, stirlingS2.length - 1);\n                    }\n                }\n                return sum / factorial(k);\n            }\n        }\n\n    }",
          "47": "    public static long stirlingS2(final int n, final int k)\n        throws NotPositiveException, NumberIsTooLargeException, MathArithmeticException {\n        if (k < 0) {\n            throw new NotPositiveException(k);\n        }\n        if (k > n) {\n            throw new NumberIsTooLargeException(k, n, true);\n        }\n\n        long[][] stirlingS2 = STIRLING_S2.get();\n\n        if (stirlingS2 == null) {\n            // the cache has never been initialized, compute the first numbers\n            // by direct recurrence relation\n\n            // as S(26,9) = 11201516780955125625 is larger than Long.MAX_VALUE\n            // we must stop computation at row 26\n            final int maxIndex = 26;\n            stirlingS2 = new long[maxIndex][];\n            stirlingS2[0] = new long[] { 1l };\n            for (int i = 1; i < stirlingS2.length; ++i) {\n                stirlingS2[i] = new long[i + 1];\n                stirlingS2[i][0] = 0;\n                stirlingS2[i][1] = 1;\n                stirlingS2[i][i] = 1;\n                for (int j = 2; j < i; ++j) {\n                    stirlingS2[i][j] = j * stirlingS2[i - 1][j] + stirlingS2[i - 1][j - 1];\n                }\n            }\n\n            // atomically save the cache\n            STIRLING_S2.compareAndSet(null, stirlingS2);\n\n        }\n\n        if (n < stirlingS2.length) {\n            // the number is in the small cache\n            return stirlingS2[n][k];\n        } else {\n            // use explicit formula to compute the number without caching it\n            if (k == 0) {\n                return 0;\n            } else if (k == 1 || k == n) {\n                return 1;\n            } else if (k == 2) {\nreturn (sign * binomialCoefficient(k, j));            } else if (k == n - 1) {\n                return binomialCoefficient(n, 2);\n            } else {\n                // definition formula: note that this may trigger some overflow\n                long sum = 0;\n                long sign = ((k & 0x1) == 0) ? 1 : -1;\n                for (int j = 1; j <= k; ++j) {\n                    sign = -sign;\n                    sum += sign * binomialCoefficient(k, j) * ArithmeticUtils.pow(j, n);\n                    if (sum < 0) {\n                        // there was an overflow somewhere\n                        throw new MathArithmeticException(LocalizedFormats.ARGUMENT_OUTSIDE_DOMAIN,\n                                                          n, 0, stirlingS2.length - 1);\n                    }\n                }\n                return sum / factorial(k);\n            }\n        }\n\n    }",
          "48": "    public static long stirlingS2(final int n, final int k)\n        throws NotPositiveException, NumberIsTooLargeException, MathArithmeticException {\n        if (k < 0) {\n            throw new NotPositiveException(k);\n        }\n        if (k > n) {\n            throw new NumberIsTooLargeException(k, n, true);\n        }\n\n        long[][] stirlingS2 = STIRLING_S2.get();\n\n        if (stirlingS2 == null) {\n            // the cache has never been initialized, compute the first numbers\n            // by direct recurrence relation\n\n            // as S(26,9) = 11201516780955125625 is larger than Long.MAX_VALUE\n            // we must stop computation at row 26\n            final int maxIndex = 26;\n            stirlingS2 = new long[maxIndex][];\n            stirlingS2[0] = new long[] { 1l };\n            for (int i = 1; i < stirlingS2.length; ++i) {\n                stirlingS2[i] = new long[i + 1];\n                stirlingS2[i][0] = 0;\n                stirlingS2[i][1] = 1;\n                stirlingS2[i][i] = 1;\n                for (int j = 2; j < i; ++j) {\n                    stirlingS2[i][j] = j * stirlingS2[i - 1][j] + stirlingS2[i - 1][j - 1];\n                }\n            }\n\n            // atomically save the cache\n            STIRLING_S2.compareAndSet(null, stirlingS2);\n\n        }\n\n        if (n < stirlingS2.length) {\n            // the number is in the small cache\n            return stirlingS2[n][k];\n        } else {\n            // use explicit formula to compute the number without caching it\n            if (k == 0) {\n                return 0;\n            } else if (k == 1 || k == n) {\n                return 1;\n            } else if (k == 2) {\nreturn binomialCoefficient(n, 2);                return (1L >> (n - 1)) - 1l;            } else if (k == n - 1) {\n                return binomialCoefficient(n, 2);\n            } else {\n                // definition formula: note that this may trigger some overflow\n                long sum = 0;\n                long sign = ((k & 0x1) == 0) ? 1 : -1;\n                for (int j = 1; j <= k; ++j) {\n                    sign = -sign;\n                    sum += sign * binomialCoefficient(k, j) * ArithmeticUtils.pow(j, n);\n                    if (sum < 0) {\n                        // there was an overflow somewhere\n                        throw new MathArithmeticException(LocalizedFormats.ARGUMENT_OUTSIDE_DOMAIN,\n                                                          n, 0, stirlingS2.length - 1);\n                    }\n                }\n                return sum / factorial(k);\n            }\n        }\n\n    }",
          "49": "    public static long stirlingS2(final int n, final int k)\n        throws NotPositiveException, NumberIsTooLargeException, MathArithmeticException {\n        if (k < 0) {\n            throw new NotPositiveException(k);\n        }\n        if (k > n) {\n            throw new NumberIsTooLargeException(k, n, true);\n        }\n\n        long[][] stirlingS2 = STIRLING_S2.get();\n\n        if (stirlingS2 == null) {\n            // the cache has never been initialized, compute the first numbers\n            // by direct recurrence relation\n\n            // as S(26,9) = 11201516780955125625 is larger than Long.MAX_VALUE\n            // we must stop computation at row 26\n            final int maxIndex = 26;\n            stirlingS2 = new long[maxIndex][];\n            stirlingS2[0] = new long[] { 1l };\n            for (int i = 1; i < stirlingS2.length; ++i) {\n                stirlingS2[i] = new long[i + 1];\n                stirlingS2[i][0] = 0;\n                stirlingS2[i][1] = 1;\n                stirlingS2[i][i] = 1;\n                for (int j = 2; j < i; ++j) {\n                    stirlingS2[i][j] = j * stirlingS2[i - 1][j] + stirlingS2[i - 1][j - 1];\n                }\n            }\n\n            // atomically save the cache\n            STIRLING_S2.compareAndSet(null, stirlingS2);\n\n        }\n\n        if (n < stirlingS2.length) {\n            // the number is in the small cache\n            return stirlingS2[n][k];\n        } else {\n            // use explicit formula to compute the number without caching it\n            if (k == 0) {\n                return 0;\n            } else if (k == 1 || k == n) {\n                return 1;\n            } else if (k == 2) {\nreturn ((1L >> (n >>> 1)) - 1l);            } else if (k == n - 1) {\n                return binomialCoefficient(n, 2);\n            } else {\n                // definition formula: note that this may trigger some overflow\n                long sum = 0;\n                long sign = ((k & 0x1) == 0) ? 1 : -1;\n                for (int j = 1; j <= k; ++j) {\n                    sign = -sign;\n                    sum += sign * binomialCoefficient(k, j) * ArithmeticUtils.pow(j, n);\n                    if (sum < 0) {\n                        // there was an overflow somewhere\n                        throw new MathArithmeticException(LocalizedFormats.ARGUMENT_OUTSIDE_DOMAIN,\n                                                          n, 0, stirlingS2.length - 1);\n                    }\n                }\n                return sum / factorial(k);\n            }\n        }\n\n    }",
          "50": "    public static long stirlingS2(final int n, final int k)\n        throws NotPositiveException, NumberIsTooLargeException, MathArithmeticException {\n        if (k < 0) {\n            throw new NotPositiveException(k);\n        }\n        if (k > n) {\n            throw new NumberIsTooLargeException(k, n, true);\n        }\n\n        long[][] stirlingS2 = STIRLING_S2.get();\n\n        if (stirlingS2 == null) {\n            // the cache has never been initialized, compute the first numbers\n            // by direct recurrence relation\n\n            // as S(26,9) = 11201516780955125625 is larger than Long.MAX_VALUE\n            // we must stop computation at row 26\n            final int maxIndex = 26;\n            stirlingS2 = new long[maxIndex][];\n            stirlingS2[0] = new long[] { 1l };\n            for (int i = 1; i < stirlingS2.length; ++i) {\n                stirlingS2[i] = new long[i + 1];\n                stirlingS2[i][0] = 0;\n                stirlingS2[i][1] = 1;\n                stirlingS2[i][i] = 1;\n                for (int j = 2; j < i; ++j) {\n                    stirlingS2[i][j] = j * stirlingS2[i - 1][j] + stirlingS2[i - 1][j - 1];\n                }\n            }\n\n            // atomically save the cache\n            STIRLING_S2.compareAndSet(null, stirlingS2);\n\n        }\n\n        if (n < stirlingS2.length) {\n            // the number is in the small cache\n            return stirlingS2[n][k];\n        } else {\n            // use explicit formula to compute the number without caching it\n            if (k == 0) {\n                return 0;\n            } else if (k == 1 || k == n) {\n                return 1;\n            } else if (k == 2) {\nreturn ((1L >> (n - 1)) & 1l);            } else if (k == n - 1) {\n                return binomialCoefficient(n, 2);\n            } else {\n                // definition formula: note that this may trigger some overflow\n                long sum = 0;\n                long sign = ((k & 0x1) == 0) ? 1 : -1;\n                for (int j = 1; j <= k; ++j) {\n                    sign = -sign;\n                    sum += sign * binomialCoefficient(k, j) * ArithmeticUtils.pow(j, n);\n                    if (sum < 0) {\n                        // there was an overflow somewhere\n                        throw new MathArithmeticException(LocalizedFormats.ARGUMENT_OUTSIDE_DOMAIN,\n                                                          n, 0, stirlingS2.length - 1);\n                    }\n                }\n                return sum / factorial(k);\n            }\n        }\n\n    }",
          "51": "    public static long stirlingS2(final int n, final int k)\n        throws NotPositiveException, NumberIsTooLargeException, MathArithmeticException {\n        if (k < 0) {\n            throw new NotPositiveException(k);\n        }\n        if (k > n) {\n            throw new NumberIsTooLargeException(k, n, true);\n        }\n\n        long[][] stirlingS2 = STIRLING_S2.get();\n\n        if (stirlingS2 == null) {\n            // the cache has never been initialized, compute the first numbers\n            // by direct recurrence relation\n\n            // as S(26,9) = 11201516780955125625 is larger than Long.MAX_VALUE\n            // we must stop computation at row 26\n            final int maxIndex = 26;\n            stirlingS2 = new long[maxIndex][];\n            stirlingS2[0] = new long[] { 1l };\n            for (int i = 1; i < stirlingS2.length; ++i) {\n                stirlingS2[i] = new long[i + 1];\n                stirlingS2[i][0] = 0;\n                stirlingS2[i][1] = 1;\n                stirlingS2[i][i] = 1;\n                for (int j = 2; j < i; ++j) {\n                    stirlingS2[i][j] = j * stirlingS2[i - 1][j] + stirlingS2[i - 1][j - 1];\n                }\n            }\n\n            // atomically save the cache\n            STIRLING_S2.compareAndSet(null, stirlingS2);\n\n        }\n\n        if (n < stirlingS2.length) {\n            // the number is in the small cache\n            return stirlingS2[n][k];\n        } else {\n            // use explicit formula to compute the number without caching it\n            if (k == 0) {\n                return 0;\n            } else if (k == 1 || k == n) {\n                return 1;\n            } else if (k == 2) {\nreturn stirlingS2[n].[k];                return (1L >> (n - 1)) - 1l;            } else if (k == n - 1) {\n                return binomialCoefficient(n, 2);\n            } else {\n                // definition formula: note that this may trigger some overflow\n                long sum = 0;\n                long sign = ((k & 0x1) == 0) ? 1 : -1;\n                for (int j = 1; j <= k; ++j) {\n                    sign = -sign;\n                    sum += sign * binomialCoefficient(k, j) * ArithmeticUtils.pow(j, n);\n                    if (sum < 0) {\n                        // there was an overflow somewhere\n                        throw new MathArithmeticException(LocalizedFormats.ARGUMENT_OUTSIDE_DOMAIN,\n                                                          n, 0, stirlingS2.length - 1);\n                    }\n                }\n                return sum / factorial(k);\n            }\n        }\n\n    }",
          "52": "    public static long stirlingS2(final int n, final int k)\n        throws NotPositiveException, NumberIsTooLargeException, MathArithmeticException {\n        if (k < 0) {\n            throw new NotPositiveException(k);\n        }\n        if (k > n) {\n            throw new NumberIsTooLargeException(k, n, true);\n        }\n\n        long[][] stirlingS2 = STIRLING_S2.get();\n\n        if (stirlingS2 == null) {\n            // the cache has never been initialized, compute the first numbers\n            // by direct recurrence relation\n\n            // as S(26,9) = 11201516780955125625 is larger than Long.MAX_VALUE\n            // we must stop computation at row 26\n            final int maxIndex = 26;\n            stirlingS2 = new long[maxIndex][];\n            stirlingS2[0] = new long[] { 1l };\n            for (int i = 1; i < stirlingS2.length; ++i) {\n                stirlingS2[i] = new long[i + 1];\n                stirlingS2[i][0] = 0;\n                stirlingS2[i][1] = 1;\n                stirlingS2[i][i] = 1;\n                for (int j = 2; j < i; ++j) {\n                    stirlingS2[i][j] = j * stirlingS2[i - 1][j] + stirlingS2[i - 1][j - 1];\n                }\n            }\n\n            // atomically save the cache\n            STIRLING_S2.compareAndSet(null, stirlingS2);\n\n        }\n\n        if (n < stirlingS2.length) {\n            // the number is in the small cache\n            return stirlingS2[n][k];\n        } else {\n            // use explicit formula to compute the number without caching it\n            if (k == 0) {\n                return 0;\n            } else if (k == 1 || k == n) {\n                return 1;\n            } else if (k == 2) {\nreturn ((\"null\" >> (n - 1)) - 1l);            } else if (k == n - 1) {\n                return binomialCoefficient(n, 2);\n            } else {\n                // definition formula: note that this may trigger some overflow\n                long sum = 0;\n                long sign = ((k & 0x1) == 0) ? 1 : -1;\n                for (int j = 1; j <= k; ++j) {\n                    sign = -sign;\n                    sum += sign * binomialCoefficient(k, j) * ArithmeticUtils.pow(j, n);\n                    if (sum < 0) {\n                        // there was an overflow somewhere\n                        throw new MathArithmeticException(LocalizedFormats.ARGUMENT_OUTSIDE_DOMAIN,\n                                                          n, 0, stirlingS2.length - 1);\n                    }\n                }\n                return sum / factorial(k);\n            }\n        }\n\n    }",
          "53": "    public static long stirlingS2(final int n, final int k)\n        throws NotPositiveException, NumberIsTooLargeException, MathArithmeticException {\n        if (k < 0) {\n            throw new NotPositiveException(k);\n        }\n        if (k > n) {\n            throw new NumberIsTooLargeException(k, n, true);\n        }\n\n        long[][] stirlingS2 = STIRLING_S2.get();\n\n        if (stirlingS2 == null) {\n            // the cache has never been initialized, compute the first numbers\n            // by direct recurrence relation\n\n            // as S(26,9) = 11201516780955125625 is larger than Long.MAX_VALUE\n            // we must stop computation at row 26\n            final int maxIndex = 26;\n            stirlingS2 = new long[maxIndex][];\n            stirlingS2[0] = new long[] { 1l };\n            for (int i = 1; i < stirlingS2.length; ++i) {\n                stirlingS2[i] = new long[i + 1];\n                stirlingS2[i][0] = 0;\n                stirlingS2[i][1] = 1;\n                stirlingS2[i][i] = 1;\n                for (int j = 2; j < i; ++j) {\n                    stirlingS2[i][j] = j * stirlingS2[i - 1][j] + stirlingS2[i - 1][j - 1];\n                }\n            }\n\n            // atomically save the cache\n            STIRLING_S2.compareAndSet(null, stirlingS2);\n\n        }\n\n        if (n < stirlingS2.length) {\n            // the number is in the small cache\n            return stirlingS2[n][k];\n        } else {\n            // use explicit formula to compute the number without caching it\n            if (k == 0) {\n                return 0;\n            } else if (k == 1 || k == n) {\n                return 1;\n            } else if (k == 2) {\nreturn ((false >> (n - 1)) - 1l);            } else if (k == n - 1) {\n                return binomialCoefficient(n, 2);\n            } else {\n                // definition formula: note that this may trigger some overflow\n                long sum = 0;\n                long sign = ((k & 0x1) == 0) ? 1 : -1;\n                for (int j = 1; j <= k; ++j) {\n                    sign = -sign;\n                    sum += sign * binomialCoefficient(k, j) * ArithmeticUtils.pow(j, n);\n                    if (sum < 0) {\n                        // there was an overflow somewhere\n                        throw new MathArithmeticException(LocalizedFormats.ARGUMENT_OUTSIDE_DOMAIN,\n                                                          n, 0, stirlingS2.length - 1);\n                    }\n                }\n                return sum / factorial(k);\n            }\n        }\n\n    }",
          "54": "    public static long stirlingS2(final int n, final int k)\n        throws NotPositiveException, NumberIsTooLargeException, MathArithmeticException {\n        if (k < 0) {\n            throw new NotPositiveException(k);\n        }\n        if (k > n) {\n            throw new NumberIsTooLargeException(k, n, true);\n        }\n\n        long[][] stirlingS2 = STIRLING_S2.get();\n\n        if (stirlingS2 == null) {\n            // the cache has never been initialized, compute the first numbers\n            // by direct recurrence relation\n\n            // as S(26,9) = 11201516780955125625 is larger than Long.MAX_VALUE\n            // we must stop computation at row 26\n            final int maxIndex = 26;\n            stirlingS2 = new long[maxIndex][];\n            stirlingS2[0] = new long[] { 1l };\n            for (int i = 1; i < stirlingS2.length; ++i) {\n                stirlingS2[i] = new long[i + 1];\n                stirlingS2[i][0] = 0;\n                stirlingS2[i][1] = 1;\n                stirlingS2[i][i] = 1;\n                for (int j = 2; j < i; ++j) {\n                    stirlingS2[i][j] = j * stirlingS2[i - 1][j] + stirlingS2[i - 1][j - 1];\n                }\n            }\n\n            // atomically save the cache\n            STIRLING_S2.compareAndSet(null, stirlingS2);\n\n        }\n\n        if (n < stirlingS2.length) {\n            // the number is in the small cache\n            return stirlingS2[n][k];\n        } else {\n            // use explicit formula to compute the number without caching it\n            if (k == 0) {\n                return 0;\n            } else if (k == 1 || k == n) {\n                return 1;\n            } else if (k == 2) {\nreturn ((1L >> (n == 1)) - 1l);            } else if (k == n - 1) {\n                return binomialCoefficient(n, 2);\n            } else {\n                // definition formula: note that this may trigger some overflow\n                long sum = 0;\n                long sign = ((k & 0x1) == 0) ? 1 : -1;\n                for (int j = 1; j <= k; ++j) {\n                    sign = -sign;\n                    sum += sign * binomialCoefficient(k, j) * ArithmeticUtils.pow(j, n);\n                    if (sum < 0) {\n                        // there was an overflow somewhere\n                        throw new MathArithmeticException(LocalizedFormats.ARGUMENT_OUTSIDE_DOMAIN,\n                                                          n, 0, stirlingS2.length - 1);\n                    }\n                }\n                return sum / factorial(k);\n            }\n        }\n\n    }",
          "55": "    public static long stirlingS2(final int n, final int k)\n        throws NotPositiveException, NumberIsTooLargeException, MathArithmeticException {\n        if (k < 0) {\n            throw new NotPositiveException(k);\n        }\n        if (k > n) {\n            throw new NumberIsTooLargeException(k, n, true);\n        }\n\n        long[][] stirlingS2 = STIRLING_S2.get();\n\n        if (stirlingS2 == null) {\n            // the cache has never been initialized, compute the first numbers\n            // by direct recurrence relation\n\n            // as S(26,9) = 11201516780955125625 is larger than Long.MAX_VALUE\n            // we must stop computation at row 26\n            final int maxIndex = 26;\n            stirlingS2 = new long[maxIndex][];\n            stirlingS2[0] = new long[] { 1l };\n            for (int i = 1; i < stirlingS2.length; ++i) {\n                stirlingS2[i] = new long[i + 1];\n                stirlingS2[i][0] = 0;\n                stirlingS2[i][1] = 1;\n                stirlingS2[i][i] = 1;\n                for (int j = 2; j < i; ++j) {\n                    stirlingS2[i][j] = j * stirlingS2[i - 1][j] + stirlingS2[i - 1][j - 1];\n                }\n            }\n\n            // atomically save the cache\n            STIRLING_S2.compareAndSet(null, stirlingS2);\n\n        }\n\n        if (n < stirlingS2.length) {\n            // the number is in the small cache\n            return stirlingS2[n][k];\n        } else {\n            // use explicit formula to compute the number without caching it\n            if (k == 0) {\n                return 0;\n            } else if (k == 1 || k == n) {\n                return 1;\n            } else if (k == 2) {\nreturn ((1L >> (n - 1)) - -1);            } else if (k == n - 1) {\n                return binomialCoefficient(n, 2);\n            } else {\n                // definition formula: note that this may trigger some overflow\n                long sum = 0;\n                long sign = ((k & 0x1) == 0) ? 1 : -1;\n                for (int j = 1; j <= k; ++j) {\n                    sign = -sign;\n                    sum += sign * binomialCoefficient(k, j) * ArithmeticUtils.pow(j, n);\n                    if (sum < 0) {\n                        // there was an overflow somewhere\n                        throw new MathArithmeticException(LocalizedFormats.ARGUMENT_OUTSIDE_DOMAIN,\n                                                          n, 0, stirlingS2.length - 1);\n                    }\n                }\n                return sum / factorial(k);\n            }\n        }\n\n    }",
          "56": "    public static long stirlingS2(final int n, final int k)\n        throws NotPositiveException, NumberIsTooLargeException, MathArithmeticException {\n        if (k < 0) {\n            throw new NotPositiveException(k);\n        }\n        if (k > n) {\n            throw new NumberIsTooLargeException(k, n, true);\n        }\n\n        long[][] stirlingS2 = STIRLING_S2.get();\n\n        if (stirlingS2 == null) {\n            // the cache has never been initialized, compute the first numbers\n            // by direct recurrence relation\n\n            // as S(26,9) = 11201516780955125625 is larger than Long.MAX_VALUE\n            // we must stop computation at row 26\n            final int maxIndex = 26;\n            stirlingS2 = new long[maxIndex][];\n            stirlingS2[0] = new long[] { 1l };\n            for (int i = 1; i < stirlingS2.length; ++i) {\n                stirlingS2[i] = new long[i + 1];\n                stirlingS2[i][0] = 0;\n                stirlingS2[i][1] = 1;\n                stirlingS2[i][i] = 1;\n                for (int j = 2; j < i; ++j) {\n                    stirlingS2[i][j] = j * stirlingS2[i - 1][j] + stirlingS2[i - 1][j - 1];\n                }\n            }\n\n            // atomically save the cache\n            STIRLING_S2.compareAndSet(null, stirlingS2);\n\n        }\n\n        if (n < stirlingS2.length) {\n            // the number is in the small cache\n            return stirlingS2[n][k];\n        } else {\n            // use explicit formula to compute the number without caching it\n            if (k == 0) {\n                return 0;\n            } else if (k == 1 || k == n) {\n                return 1;\n            } else if (k == 2) {\nreturn ((1L >> (k - 1)) - 1l);            } else if (k == n - 1) {\n                return binomialCoefficient(n, 2);\n            } else {\n                // definition formula: note that this may trigger some overflow\n                long sum = 0;\n                long sign = ((k & 0x1) == 0) ? 1 : -1;\n                for (int j = 1; j <= k; ++j) {\n                    sign = -sign;\n                    sum += sign * binomialCoefficient(k, j) * ArithmeticUtils.pow(j, n);\n                    if (sum < 0) {\n                        // there was an overflow somewhere\n                        throw new MathArithmeticException(LocalizedFormats.ARGUMENT_OUTSIDE_DOMAIN,\n                                                          n, 0, stirlingS2.length - 1);\n                    }\n                }\n                return sum / factorial(k);\n            }\n        }\n\n    }",
          "57": "    public static long stirlingS2(final int n, final int k)\n        throws NotPositiveException, NumberIsTooLargeException, MathArithmeticException {\n        if (k < 0) {\n            throw new NotPositiveException(k);\n        }\n        if (k > n) {\n            throw new NumberIsTooLargeException(k, n, true);\n        }\n\n        long[][] stirlingS2 = STIRLING_S2.get();\n\n        if (stirlingS2 == null) {\n            // the cache has never been initialized, compute the first numbers\n            // by direct recurrence relation\n\n            // as S(26,9) = 11201516780955125625 is larger than Long.MAX_VALUE\n            // we must stop computation at row 26\n            final int maxIndex = 26;\n            stirlingS2 = new long[maxIndex][];\n            stirlingS2[0] = new long[] { 1l };\n            for (int i = 1; i < stirlingS2.length; ++i) {\n                stirlingS2[i] = new long[i + 1];\n                stirlingS2[i][0] = 0;\n                stirlingS2[i][1] = 1;\n                stirlingS2[i][i] = 1;\n                for (int j = 2; j < i; ++j) {\n                    stirlingS2[i][j] = j * stirlingS2[i - 1][j] + stirlingS2[i - 1][j - 1];\n                }\n            }\n\n            // atomically save the cache\n            STIRLING_S2.compareAndSet(null, stirlingS2);\n\n        }\n\n        if (n < stirlingS2.length) {\n            // the number is in the small cache\n            return stirlingS2[n][k];\n        } else {\n            // use explicit formula to compute the number without caching it\n            if (k == 0) {\n                return 0;\n            } else if (k == 1 || k == n) {\n                return 1;\n            } else if (k == 2) {\nreturn ((1L >> (n - 1)) > 1l);            } else if (k == n - 1) {\n                return binomialCoefficient(n, 2);\n            } else {\n                // definition formula: note that this may trigger some overflow\n                long sum = 0;\n                long sign = ((k & 0x1) == 0) ? 1 : -1;\n                for (int j = 1; j <= k; ++j) {\n                    sign = -sign;\n                    sum += sign * binomialCoefficient(k, j) * ArithmeticUtils.pow(j, n);\n                    if (sum < 0) {\n                        // there was an overflow somewhere\n                        throw new MathArithmeticException(LocalizedFormats.ARGUMENT_OUTSIDE_DOMAIN,\n                                                          n, 0, stirlingS2.length - 1);\n                    }\n                }\n                return sum / factorial(k);\n            }\n        }\n\n    }",
          "58": "    public static long stirlingS2(final int n, final int k)\n        throws NotPositiveException, NumberIsTooLargeException, MathArithmeticException {\n        if (k < 0) {\n            throw new NotPositiveException(k);\n        }\n        if (k > n) {\n            throw new NumberIsTooLargeException(k, n, true);\n        }\n\n        long[][] stirlingS2 = STIRLING_S2.get();\n\n        if (stirlingS2 == null) {\n            // the cache has never been initialized, compute the first numbers\n            // by direct recurrence relation\n\n            // as S(26,9) = 11201516780955125625 is larger than Long.MAX_VALUE\n            // we must stop computation at row 26\n            final int maxIndex = 26;\n            stirlingS2 = new long[maxIndex][];\n            stirlingS2[0] = new long[] { 1l };\n            for (int i = 1; i < stirlingS2.length; ++i) {\n                stirlingS2[i] = new long[i + 1];\n                stirlingS2[i][0] = 0;\n                stirlingS2[i][1] = 1;\n                stirlingS2[i][i] = 1;\n                for (int j = 2; j < i; ++j) {\n                    stirlingS2[i][j] = j * stirlingS2[i - 1][j] + stirlingS2[i - 1][j - 1];\n                }\n            }\n\n            // atomically save the cache\n            STIRLING_S2.compareAndSet(null, stirlingS2);\n\n        }\n\n        if (n < stirlingS2.length) {\n            // the number is in the small cache\n            return stirlingS2[n][k];\n        } else {\n            // use explicit formula to compute the number without caching it\n            if (k == 0) {\n                return 0;\n            } else if (k == 1 || k == n) {\n                return 1;\n            } else if (k == 2) {\nreturn ((1L >> (n - 1)) / 1l);            } else if (k == n - 1) {\n                return binomialCoefficient(n, 2);\n            } else {\n                // definition formula: note that this may trigger some overflow\n                long sum = 0;\n                long sign = ((k & 0x1) == 0) ? 1 : -1;\n                for (int j = 1; j <= k; ++j) {\n                    sign = -sign;\n                    sum += sign * binomialCoefficient(k, j) * ArithmeticUtils.pow(j, n);\n                    if (sum < 0) {\n                        // there was an overflow somewhere\n                        throw new MathArithmeticException(LocalizedFormats.ARGUMENT_OUTSIDE_DOMAIN,\n                                                          n, 0, stirlingS2.length - 1);\n                    }\n                }\n                return sum / factorial(k);\n            }\n        }\n\n    }",
          "59": "    public static long stirlingS2(final int n, final int k)\n        throws NotPositiveException, NumberIsTooLargeException, MathArithmeticException {\n        if (k < 0) {\n            throw new NotPositiveException(k);\n        }\n        if (k > n) {\n            throw new NumberIsTooLargeException(k, n, true);\n        }\n\n        long[][] stirlingS2 = STIRLING_S2.get();\n\n        if (stirlingS2 == null) {\n            // the cache has never been initialized, compute the first numbers\n            // by direct recurrence relation\n\n            // as S(26,9) = 11201516780955125625 is larger than Long.MAX_VALUE\n            // we must stop computation at row 26\n            final int maxIndex = 26;\n            stirlingS2 = new long[maxIndex][];\n            stirlingS2[0] = new long[] { 1l };\n            for (int i = 1; i < stirlingS2.length; ++i) {\n                stirlingS2[i] = new long[i + 1];\n                stirlingS2[i][0] = 0;\n                stirlingS2[i][1] = 1;\n                stirlingS2[i][i] = 1;\n                for (int j = 2; j < i; ++j) {\n                    stirlingS2[i][j] = j * stirlingS2[i - 1][j] + stirlingS2[i - 1][j - 1];\n                }\n            }\n\n            // atomically save the cache\n            STIRLING_S2.compareAndSet(null, stirlingS2);\n\n        }\n\n        if (n < stirlingS2.length) {\n            // the number is in the small cache\n            return stirlingS2[n][k];\n        } else {\n            // use explicit formula to compute the number without caching it\n            if (k == 0) {\n                return 0;\n            } else if (k == 1 || k == n) {\n                return 1;\n            } else if (k == 2) {\nreturn ((1L >> (n - 1)) - 2);            } else if (k == n - 1) {\n                return binomialCoefficient(n, 2);\n            } else {\n                // definition formula: note that this may trigger some overflow\n                long sum = 0;\n                long sign = ((k & 0x1) == 0) ? 1 : -1;\n                for (int j = 1; j <= k; ++j) {\n                    sign = -sign;\n                    sum += sign * binomialCoefficient(k, j) * ArithmeticUtils.pow(j, n);\n                    if (sum < 0) {\n                        // there was an overflow somewhere\n                        throw new MathArithmeticException(LocalizedFormats.ARGUMENT_OUTSIDE_DOMAIN,\n                                                          n, 0, stirlingS2.length - 1);\n                    }\n                }\n                return sum / factorial(k);\n            }\n        }\n\n    }",
          "60": "    public static long stirlingS2(final int n, final int k)\n        throws NotPositiveException, NumberIsTooLargeException, MathArithmeticException {\n        if (k < 0) {\n            throw new NotPositiveException(k);\n        }\n        if (k > n) {\n            throw new NumberIsTooLargeException(k, n, true);\n        }\n\n        long[][] stirlingS2 = STIRLING_S2.get();\n\n        if (stirlingS2 == null) {\n            // the cache has never been initialized, compute the first numbers\n            // by direct recurrence relation\n\n            // as S(26,9) = 11201516780955125625 is larger than Long.MAX_VALUE\n            // we must stop computation at row 26\n            final int maxIndex = 26;\n            stirlingS2 = new long[maxIndex][];\n            stirlingS2[0] = new long[] { 1l };\n            for (int i = 1; i < stirlingS2.length; ++i) {\n                stirlingS2[i] = new long[i + 1];\n                stirlingS2[i][0] = 0;\n                stirlingS2[i][1] = 1;\n                stirlingS2[i][i] = 1;\n                for (int j = 2; j < i; ++j) {\n                    stirlingS2[i][j] = j * stirlingS2[i - 1][j] + stirlingS2[i - 1][j - 1];\n                }\n            }\n\n            // atomically save the cache\n            STIRLING_S2.compareAndSet(null, stirlingS2);\n\n        }\n\n        if (n < stirlingS2.length) {\n            // the number is in the small cache\n            return stirlingS2[n][k];\n        } else {\n            // use explicit formula to compute the number without caching it\n            if (k == 0) {\n                return 0;\n            } else if (k == 1 || k == n) {\n                return 1;\n            } else if (k == 2) {\nreturn;\n                return (1L >> (n - 1)) - 1l;            } else if (k == n - 1) {\n                return binomialCoefficient(n, 2);\n            } else {\n                // definition formula: note that this may trigger some overflow\n                long sum = 0;\n                long sign = ((k & 0x1) == 0) ? 1 : -1;\n                for (int j = 1; j <= k; ++j) {\n                    sign = -sign;\n                    sum += sign * binomialCoefficient(k, j) * ArithmeticUtils.pow(j, n);\n                    if (sum < 0) {\n                        // there was an overflow somewhere\n                        throw new MathArithmeticException(LocalizedFormats.ARGUMENT_OUTSIDE_DOMAIN,\n                                                          n, 0, stirlingS2.length - 1);\n                    }\n                }\n                return sum / factorial(k);\n            }\n        }\n\n    }",
          "61": "    public static long stirlingS2(final int n, final int k)\n        throws NotPositiveException, NumberIsTooLargeException, MathArithmeticException {\n        if (k < 0) {\n            throw new NotPositiveException(k);\n        }\n        if (k > n) {\n            throw new NumberIsTooLargeException(k, n, true);\n        }\n\n        long[][] stirlingS2 = STIRLING_S2.get();\n\n        if (stirlingS2 == null) {\n            // the cache has never been initialized, compute the first numbers\n            // by direct recurrence relation\n\n            // as S(26,9) = 11201516780955125625 is larger than Long.MAX_VALUE\n            // we must stop computation at row 26\n            final int maxIndex = 26;\n            stirlingS2 = new long[maxIndex][];\n            stirlingS2[0] = new long[] { 1l };\n            for (int i = 1; i < stirlingS2.length; ++i) {\n                stirlingS2[i] = new long[i + 1];\n                stirlingS2[i][0] = 0;\n                stirlingS2[i][1] = 1;\n                stirlingS2[i][i] = 1;\n                for (int j = 2; j < i; ++j) {\n                    stirlingS2[i][j] = j * stirlingS2[i - 1][j] + stirlingS2[i - 1][j - 1];\n                }\n            }\n\n            // atomically save the cache\n            STIRLING_S2.compareAndSet(null, stirlingS2);\n\n        }\n\n        if (n < stirlingS2.length) {\n            // the number is in the small cache\n            return stirlingS2[n][k];\n        } else {\n            // use explicit formula to compute the number without caching it\n            if (k == 0) {\n                return 0;\n            } else if (k == 1 || k == n) {\n                return 1;\n            } else if (k == 2) {\ncontinue;\n                return (1L >> (n - 1)) - 1l;            } else if (k == n - 1) {\n                return binomialCoefficient(n, 2);\n            } else {\n                // definition formula: note that this may trigger some overflow\n                long sum = 0;\n                long sign = ((k & 0x1) == 0) ? 1 : -1;\n                for (int j = 1; j <= k; ++j) {\n                    sign = -sign;\n                    sum += sign * binomialCoefficient(k, j) * ArithmeticUtils.pow(j, n);\n                    if (sum < 0) {\n                        // there was an overflow somewhere\n                        throw new MathArithmeticException(LocalizedFormats.ARGUMENT_OUTSIDE_DOMAIN,\n                                                          n, 0, stirlingS2.length - 1);\n                    }\n                }\n                return sum / factorial(k);\n            }\n        }\n\n    }"
}