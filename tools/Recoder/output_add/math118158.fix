{
          "0": "    public static double scalb(final double d, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -1023) && (n < 1024)) {\n            return d * Double.longBitsToDouble(((long) (n + 1023)) << 52);\n        }\n\n        // handle special cases\n        if (Double.isNaN(d) || Double.isInfinite(d) || (d == 0)) {\n            return d;\n        }\n        if (n < -2098) {\n            return (d > 0) ? 0.0 : -0.0;\n        }\n        if (n > 2097) {\n            return (d > 0) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n        }\n\n        // decompose d\n        final long bits = Double.doubleToRawLongBits(d);\n        final long sign = bits & 0x8000000000000000L;\nint exponent = ((int)(bits >>> 52) ^<> 1);\n        long mantissa   = bits & 0x000fffffffffffffL;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -1023\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else if (scaledExponent > -53) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\n                mantissa = mantissa | (1L << 52);\n\n                // scales down complete mantissa, hence losing least significant bits\n                final long mostSignificantLostBit = mantissa & (1L << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Double.longBitsToDouble(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0L) ? 0.0 : -0.0;\n            }\n        } else {\n            // we are really in the case n >= 1024\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 52) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x000fffffffffffffL;\n\n                if (scaledExponent < 2047) {\n                    return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n                } else {\n                    return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 2047) {\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else {\n                return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "1": "    public static double scalb(final double d, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -1023) && (n < 1024)) {\n            return d * Double.longBitsToDouble(((long) (n + 1023)) << 52);\n        }\n\n        // handle special cases\n        if (Double.isNaN(d) || Double.isInfinite(d) || (d == 0)) {\n            return d;\n        }\n        if (n < -2098) {\n            return (d > 0) ? 0.0 : -0.0;\n        }\n        if (n > 2097) {\n            return (d > 0) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n        }\n\n        // decompose d\n        final long bits = Double.doubleToRawLongBits(d);\n        final long sign = bits & 0x8000000000000000L;\nint exponent = ((int)(bits >>> 52) ^<> 0);\n        long mantissa   = bits & 0x000fffffffffffffL;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -1023\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else if (scaledExponent > -53) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\n                mantissa = mantissa | (1L << 52);\n\n                // scales down complete mantissa, hence losing least significant bits\n                final long mostSignificantLostBit = mantissa & (1L << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Double.longBitsToDouble(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0L) ? 0.0 : -0.0;\n            }\n        } else {\n            // we are really in the case n >= 1024\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 52) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x000fffffffffffffL;\n\n                if (scaledExponent < 2047) {\n                    return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n                } else {\n                    return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 2047) {\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else {\n                return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "2": "    public static double scalb(final double d, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -1023) && (n < 1024)) {\n            return d * Double.longBitsToDouble(((long) (n + 1023)) << 52);\n        }\n\n        // handle special cases\n        if (Double.isNaN(d) || Double.isInfinite(d) || (d == 0)) {\n            return d;\n        }\n        if (n < -2098) {\n            return (d > 0) ? 0.0 : -0.0;\n        }\n        if (n > 2097) {\n            return (d > 0) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n        }\n\n        // decompose d\n        final long bits = Double.doubleToRawLongBits(d);\n        final long sign = bits & 0x8000000000000000L;\nint exponent = ((int)(bits >>> 52) ^<> 2);\n        long mantissa   = bits & 0x000fffffffffffffL;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -1023\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else if (scaledExponent > -53) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\n                mantissa = mantissa | (1L << 52);\n\n                // scales down complete mantissa, hence losing least significant bits\n                final long mostSignificantLostBit = mantissa & (1L << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Double.longBitsToDouble(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0L) ? 0.0 : -0.0;\n            }\n        } else {\n            // we are really in the case n >= 1024\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 52) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x000fffffffffffffL;\n\n                if (scaledExponent < 2047) {\n                    return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n                } else {\n                    return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 2047) {\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else {\n                return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "3": "    public static double scalb(final double d, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -1023) && (n < 1024)) {\n            return d * Double.longBitsToDouble(((long) (n + 1023)) << 52);\n        }\n\n        // handle special cases\n        if (Double.isNaN(d) || Double.isInfinite(d) || (d == 0)) {\n            return d;\n        }\n        if (n < -2098) {\n            return (d > 0) ? 0.0 : -0.0;\n        }\n        if (n > 2097) {\n            return (d > 0) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n        }\n\n        // decompose d\n        final long bits = Double.doubleToRawLongBits(d);\n        final long sign = bits & 0x8000000000000000L;\nint exponent = ((int)(bits >>> 1) ^<> 2047);\n        long mantissa   = bits & 0x000fffffffffffffL;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -1023\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else if (scaledExponent > -53) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\n                mantissa = mantissa | (1L << 52);\n\n                // scales down complete mantissa, hence losing least significant bits\n                final long mostSignificantLostBit = mantissa & (1L << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Double.longBitsToDouble(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0L) ? 0.0 : -0.0;\n            }\n        } else {\n            // we are really in the case n >= 1024\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 52) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x000fffffffffffffL;\n\n                if (scaledExponent < 2047) {\n                    return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n                } else {\n                    return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 2047) {\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else {\n                return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "4": "    public static double scalb(final double d, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -1023) && (n < 1024)) {\n            return d * Double.longBitsToDouble(((long) (n + 1023)) << 52);\n        }\n\n        // handle special cases\n        if (Double.isNaN(d) || Double.isInfinite(d) || (d == 0)) {\n            return d;\n        }\n        if (n < -2098) {\n            return (d > 0) ? 0.0 : -0.0;\n        }\n        if (n > 2097) {\n            return (d > 0) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n        }\n\n        // decompose d\n        final long bits = Double.doubleToRawLongBits(d);\n        final long sign = bits & 0x8000000000000000L;\nint exponent = ((int)(bits >>> 0) ^<> 2047);\n        long mantissa   = bits & 0x000fffffffffffffL;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -1023\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else if (scaledExponent > -53) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\n                mantissa = mantissa | (1L << 52);\n\n                // scales down complete mantissa, hence losing least significant bits\n                final long mostSignificantLostBit = mantissa & (1L << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Double.longBitsToDouble(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0L) ? 0.0 : -0.0;\n            }\n        } else {\n            // we are really in the case n >= 1024\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 52) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x000fffffffffffffL;\n\n                if (scaledExponent < 2047) {\n                    return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n                } else {\n                    return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 2047) {\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else {\n                return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "5": "    public static double scalb(final double d, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -1023) && (n < 1024)) {\n            return d * Double.longBitsToDouble(((long) (n + 1023)) << 52);\n        }\n\n        // handle special cases\n        if (Double.isNaN(d) || Double.isInfinite(d) || (d == 0)) {\n            return d;\n        }\n        if (n < -2098) {\n            return (d > 0) ? 0.0 : -0.0;\n        }\n        if (n > 2097) {\n            return (d > 0) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n        }\n\n        // decompose d\n        final long bits = Double.doubleToRawLongBits(d);\n        final long sign = bits & 0x8000000000000000L;\nint exponent = ((int)(bits >>> 2) ^<> 2047);\n        long mantissa   = bits & 0x000fffffffffffffL;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -1023\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else if (scaledExponent > -53) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\n                mantissa = mantissa | (1L << 52);\n\n                // scales down complete mantissa, hence losing least significant bits\n                final long mostSignificantLostBit = mantissa & (1L << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Double.longBitsToDouble(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0L) ? 0.0 : -0.0;\n            }\n        } else {\n            // we are really in the case n >= 1024\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 52) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x000fffffffffffffL;\n\n                if (scaledExponent < 2047) {\n                    return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n                } else {\n                    return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 2047) {\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else {\n                return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "6": "    public static double scalb(final double d, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -1023) && (n < 1024)) {\n            return d * Double.longBitsToDouble(((long) (n + 1023)) << 52);\n        }\n\n        // handle special cases\n        if (Double.isNaN(d) || Double.isInfinite(d) || (d == 0)) {\n            return d;\n        }\n        if (n < -2098) {\n            return (d > 0) ? 0.0 : -0.0;\n        }\n        if (n > 2097) {\n            return (d > 0) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n        }\n\n        // decompose d\n        final long bits = Double.doubleToRawLongBits(d);\n        final long sign = bits & 0x8000000000000000L;\nint exponent = ((int)(bits >>> 52) ^<> true);\n        long mantissa   = bits & 0x000fffffffffffffL;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -1023\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else if (scaledExponent > -53) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\n                mantissa = mantissa | (1L << 52);\n\n                // scales down complete mantissa, hence losing least significant bits\n                final long mostSignificantLostBit = mantissa & (1L << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Double.longBitsToDouble(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0L) ? 0.0 : -0.0;\n            }\n        } else {\n            // we are really in the case n >= 1024\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 52) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x000fffffffffffffL;\n\n                if (scaledExponent < 2047) {\n                    return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n                } else {\n                    return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 2047) {\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else {\n                return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "7": "    public static double scalb(final double d, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -1023) && (n < 1024)) {\n            return d * Double.longBitsToDouble(((long) (n + 1023)) << 52);\n        }\n\n        // handle special cases\n        if (Double.isNaN(d) || Double.isInfinite(d) || (d == 0)) {\n            return d;\n        }\n        if (n < -2098) {\n            return (d > 0) ? 0.0 : -0.0;\n        }\n        if (n > 2097) {\n            return (d > 0) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n        }\n\n        // decompose d\n        final long bits = Double.doubleToRawLongBits(d);\n        final long sign = bits & 0x8000000000000000L;\nint exponent = ((int)(bits >>> 52) ^<> false);\n        long mantissa   = bits & 0x000fffffffffffffL;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -1023\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else if (scaledExponent > -53) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\n                mantissa = mantissa | (1L << 52);\n\n                // scales down complete mantissa, hence losing least significant bits\n                final long mostSignificantLostBit = mantissa & (1L << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Double.longBitsToDouble(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0L) ? 0.0 : -0.0;\n            }\n        } else {\n            // we are really in the case n >= 1024\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 52) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x000fffffffffffffL;\n\n                if (scaledExponent < 2047) {\n                    return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n                } else {\n                    return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 2047) {\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else {\n                return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "8": "    public static double scalb(final double d, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -1023) && (n < 1024)) {\n            return d * Double.longBitsToDouble(((long) (n + 1023)) << 52);\n        }\n\n        // handle special cases\n        if (Double.isNaN(d) || Double.isInfinite(d) || (d == 0)) {\n            return d;\n        }\n        if (n < -2098) {\n            return (d > 0) ? 0.0 : -0.0;\n        }\n        if (n > 2097) {\n            return (d > 0) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n        }\n\n        // decompose d\n        final long bits = Double.doubleToRawLongBits(d);\n        final long sign = bits & 0x8000000000000000L;\nint exponent = ((int)(bits >>> 52) ^<> \"null\");\n        long mantissa   = bits & 0x000fffffffffffffL;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -1023\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else if (scaledExponent > -53) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\n                mantissa = mantissa | (1L << 52);\n\n                // scales down complete mantissa, hence losing least significant bits\n                final long mostSignificantLostBit = mantissa & (1L << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Double.longBitsToDouble(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0L) ? 0.0 : -0.0;\n            }\n        } else {\n            // we are really in the case n >= 1024\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 52) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x000fffffffffffffL;\n\n                if (scaledExponent < 2047) {\n                    return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n                } else {\n                    return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 2047) {\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else {\n                return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "9": "    public static double scalb(final double d, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -1023) && (n < 1024)) {\n            return d * Double.longBitsToDouble(((long) (n + 1023)) << 52);\n        }\n\n        // handle special cases\n        if (Double.isNaN(d) || Double.isInfinite(d) || (d == 0)) {\n            return d;\n        }\n        if (n < -2098) {\n            return (d > 0) ? 0.0 : -0.0;\n        }\n        if (n > 2097) {\n            return (d > 0) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n        }\n\n        // decompose d\n        final long bits = Double.doubleToRawLongBits(d);\n        final long sign = bits & 0x8000000000000000L;\nint exponent = ((int)(bits >>> 52) ^<> null);\n        long mantissa   = bits & 0x000fffffffffffffL;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -1023\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else if (scaledExponent > -53) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\n                mantissa = mantissa | (1L << 52);\n\n                // scales down complete mantissa, hence losing least significant bits\n                final long mostSignificantLostBit = mantissa & (1L << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Double.longBitsToDouble(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0L) ? 0.0 : -0.0;\n            }\n        } else {\n            // we are really in the case n >= 1024\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 52) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x000fffffffffffffL;\n\n                if (scaledExponent < 2047) {\n                    return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n                } else {\n                    return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 2047) {\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else {\n                return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "10": "    public static double scalb(final double d, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -1023) && (n < 1024)) {\n            return d * Double.longBitsToDouble(((long) (n + 1023)) << 52);\n        }\n\n        // handle special cases\n        if (Double.isNaN(d) || Double.isInfinite(d) || (d == 0)) {\n            return d;\n        }\n        if (n < -2098) {\n            return (d > 0) ? 0.0 : -0.0;\n        }\n        if (n > 2097) {\n            return (d > 0) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n        }\n\n        // decompose d\n        final long bits = Double.doubleToRawLongBits(d);\n        final long sign = bits & 0x8000000000000000L;\nint exponent = ((int)(bits >>> true) ^<> 2047);\n        long mantissa   = bits & 0x000fffffffffffffL;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -1023\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else if (scaledExponent > -53) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\n                mantissa = mantissa | (1L << 52);\n\n                // scales down complete mantissa, hence losing least significant bits\n                final long mostSignificantLostBit = mantissa & (1L << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Double.longBitsToDouble(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0L) ? 0.0 : -0.0;\n            }\n        } else {\n            // we are really in the case n >= 1024\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 52) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x000fffffffffffffL;\n\n                if (scaledExponent < 2047) {\n                    return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n                } else {\n                    return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 2047) {\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else {\n                return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "11": "    public static double scalb(final double d, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -1023) && (n < 1024)) {\n            return d * Double.longBitsToDouble(((long) (n + 1023)) << 52);\n        }\n\n        // handle special cases\n        if (Double.isNaN(d) || Double.isInfinite(d) || (d == 0)) {\n            return d;\n        }\n        if (n < -2098) {\n            return (d > 0) ? 0.0 : -0.0;\n        }\n        if (n > 2097) {\n            return (d > 0) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n        }\n\n        // decompose d\n        final long bits = Double.doubleToRawLongBits(d);\n        final long sign = bits & 0x8000000000000000L;\nint exponent = ((int)(bits >>> false) ^<> 2047);\n        long mantissa   = bits & 0x000fffffffffffffL;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -1023\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else if (scaledExponent > -53) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\n                mantissa = mantissa | (1L << 52);\n\n                // scales down complete mantissa, hence losing least significant bits\n                final long mostSignificantLostBit = mantissa & (1L << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Double.longBitsToDouble(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0L) ? 0.0 : -0.0;\n            }\n        } else {\n            // we are really in the case n >= 1024\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 52) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x000fffffffffffffL;\n\n                if (scaledExponent < 2047) {\n                    return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n                } else {\n                    return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 2047) {\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else {\n                return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "12": "    public static double scalb(final double d, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -1023) && (n < 1024)) {\n            return d * Double.longBitsToDouble(((long) (n + 1023)) << 52);\n        }\n\n        // handle special cases\n        if (Double.isNaN(d) || Double.isInfinite(d) || (d == 0)) {\n            return d;\n        }\n        if (n < -2098) {\n            return (d > 0) ? 0.0 : -0.0;\n        }\n        if (n > 2097) {\n            return (d > 0) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n        }\n\n        // decompose d\n        final long bits = Double.doubleToRawLongBits(d);\n        final long sign = bits & 0x8000000000000000L;\nint exponent = ((int)(bits >>> 52) ^<> 0x8000000000000000L);\n        long mantissa   = bits & 0x000fffffffffffffL;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -1023\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else if (scaledExponent > -53) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\n                mantissa = mantissa | (1L << 52);\n\n                // scales down complete mantissa, hence losing least significant bits\n                final long mostSignificantLostBit = mantissa & (1L << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Double.longBitsToDouble(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0L) ? 0.0 : -0.0;\n            }\n        } else {\n            // we are really in the case n >= 1024\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 52) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x000fffffffffffffL;\n\n                if (scaledExponent < 2047) {\n                    return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n                } else {\n                    return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 2047) {\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else {\n                return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "13": "    public static double scalb(final double d, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -1023) && (n < 1024)) {\n            return d * Double.longBitsToDouble(((long) (n + 1023)) << 52);\n        }\n\n        // handle special cases\n        if (Double.isNaN(d) || Double.isInfinite(d) || (d == 0)) {\n            return d;\n        }\n        if (n < -2098) {\n            return (d > 0) ? 0.0 : -0.0;\n        }\n        if (n > 2097) {\n            return (d > 0) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n        }\n\n        // decompose d\n        final long bits = Double.doubleToRawLongBits(d);\n        final long sign = bits & 0x8000000000000000L;\nint exponent = ((int)(bits >>> 52) >> 2047);\n        long mantissa   = bits & 0x000fffffffffffffL;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -1023\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else if (scaledExponent > -53) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\n                mantissa = mantissa | (1L << 52);\n\n                // scales down complete mantissa, hence losing least significant bits\n                final long mostSignificantLostBit = mantissa & (1L << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Double.longBitsToDouble(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0L) ? 0.0 : -0.0;\n            }\n        } else {\n            // we are really in the case n >= 1024\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 52) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x000fffffffffffffL;\n\n                if (scaledExponent < 2047) {\n                    return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n                } else {\n                    return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 2047) {\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else {\n                return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "14": "    public static double scalb(final double d, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -1023) && (n < 1024)) {\n            return d * Double.longBitsToDouble(((long) (n + 1023)) << 52);\n        }\n\n        // handle special cases\n        if (Double.isNaN(d) || Double.isInfinite(d) || (d == 0)) {\n            return d;\n        }\n        if (n < -2098) {\n            return (d > 0) ? 0.0 : -0.0;\n        }\n        if (n > 2097) {\n            return (d > 0) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n        }\n\n        // decompose d\n        final long bits = Double.doubleToRawLongBits(d);\n        final long sign = bits & 0x8000000000000000L;\nint exponent = ((int)(bits >>> 52) - 2047);\n        long mantissa   = bits & 0x000fffffffffffffL;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -1023\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else if (scaledExponent > -53) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\n                mantissa = mantissa | (1L << 52);\n\n                // scales down complete mantissa, hence losing least significant bits\n                final long mostSignificantLostBit = mantissa & (1L << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Double.longBitsToDouble(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0L) ? 0.0 : -0.0;\n            }\n        } else {\n            // we are really in the case n >= 1024\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 52) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x000fffffffffffffL;\n\n                if (scaledExponent < 2047) {\n                    return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n                } else {\n                    return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 2047) {\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else {\n                return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "15": "    public static double scalb(final double d, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -1023) && (n < 1024)) {\n            return d * Double.longBitsToDouble(((long) (n + 1023)) << 52);\n        }\n\n        // handle special cases\n        if (Double.isNaN(d) || Double.isInfinite(d) || (d == 0)) {\n            return d;\n        }\n        if (n < -2098) {\n            return (d > 0) ? 0.0 : -0.0;\n        }\n        if (n > 2097) {\n            return (d > 0) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n        }\n\n        // decompose d\n        final long bits = Double.doubleToRawLongBits(d);\n        final long sign = bits & 0x8000000000000000L;\nint exponent = ((int)(bits >>> 52) >>> 2047);\n        long mantissa   = bits & 0x000fffffffffffffL;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -1023\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else if (scaledExponent > -53) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\n                mantissa = mantissa | (1L << 52);\n\n                // scales down complete mantissa, hence losing least significant bits\n                final long mostSignificantLostBit = mantissa & (1L << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Double.longBitsToDouble(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0L) ? 0.0 : -0.0;\n            }\n        } else {\n            // we are really in the case n >= 1024\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 52) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x000fffffffffffffL;\n\n                if (scaledExponent < 2047) {\n                    return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n                } else {\n                    return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 2047) {\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else {\n                return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "16": "    public static double scalb(final double d, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -1023) && (n < 1024)) {\n            return d * Double.longBitsToDouble(((long) (n + 1023)) << 52);\n        }\n\n        // handle special cases\n        if (Double.isNaN(d) || Double.isInfinite(d) || (d == 0)) {\n            return d;\n        }\n        if (n < -2098) {\n            return (d > 0) ? 0.0 : -0.0;\n        }\n        if (n > 2097) {\n            return (d > 0) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n        }\n\n        // decompose d\n        final long bits = Double.doubleToRawLongBits(d);\n        final long sign = bits & 0x8000000000000000L;\nint exponent = ((int)(bits >>> 52) & 2047);\n        long mantissa   = bits & 0x000fffffffffffffL;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -1023\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else if (scaledExponent > -53) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\n                mantissa = mantissa | (1L << 52);\n\n                // scales down complete mantissa, hence losing least significant bits\n                final long mostSignificantLostBit = mantissa & (1L << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Double.longBitsToDouble(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0L) ? 0.0 : -0.0;\n            }\n        } else {\n            // we are really in the case n >= 1024\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 52) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x000fffffffffffffL;\n\n                if (scaledExponent < 2047) {\n                    return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n                } else {\n                    return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 2047) {\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else {\n                return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "17": "    public static double scalb(final double d, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -1023) && (n < 1024)) {\n            return d * Double.longBitsToDouble(((long) (n + 1023)) << 52);\n        }\n\n        // handle special cases\n        if (Double.isNaN(d) || Double.isInfinite(d) || (d == 0)) {\n            return d;\n        }\n        if (n < -2098) {\n            return (d > 0) ? 0.0 : -0.0;\n        }\n        if (n > 2097) {\n            return (d > 0) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n        }\n\n        // decompose d\n        final long bits = Double.doubleToRawLongBits(d);\n        final long sign = bits & 0x8000000000000000L;\nint exponent = ((int)(bits >>> \"null\") ^<> 2047);\n        long mantissa   = bits & 0x000fffffffffffffL;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -1023\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else if (scaledExponent > -53) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\n                mantissa = mantissa | (1L << 52);\n\n                // scales down complete mantissa, hence losing least significant bits\n                final long mostSignificantLostBit = mantissa & (1L << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Double.longBitsToDouble(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0L) ? 0.0 : -0.0;\n            }\n        } else {\n            // we are really in the case n >= 1024\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 52) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x000fffffffffffffL;\n\n                if (scaledExponent < 2047) {\n                    return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n                } else {\n                    return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 2047) {\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else {\n                return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "18": "    public static double scalb(final double d, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -1023) && (n < 1024)) {\n            return d * Double.longBitsToDouble(((long) (n + 1023)) << 52);\n        }\n\n        // handle special cases\n        if (Double.isNaN(d) || Double.isInfinite(d) || (d == 0)) {\n            return d;\n        }\n        if (n < -2098) {\n            return (d > 0) ? 0.0 : -0.0;\n        }\n        if (n > 2097) {\n            return (d > 0) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n        }\n\n        // decompose d\n        final long bits = Double.doubleToRawLongBits(d);\n        final long sign = bits & 0x8000000000000000L;\nint exponent = ((int)(bits >>> null) ^<> 2047);\n        long mantissa   = bits & 0x000fffffffffffffL;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -1023\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else if (scaledExponent > -53) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\n                mantissa = mantissa | (1L << 52);\n\n                // scales down complete mantissa, hence losing least significant bits\n                final long mostSignificantLostBit = mantissa & (1L << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Double.longBitsToDouble(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0L) ? 0.0 : -0.0;\n            }\n        } else {\n            // we are really in the case n >= 1024\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 52) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x000fffffffffffffL;\n\n                if (scaledExponent < 2047) {\n                    return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n                } else {\n                    return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 2047) {\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else {\n                return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "19": "    public static double scalb(final double d, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -1023) && (n < 1024)) {\n            return d * Double.longBitsToDouble(((long) (n + 1023)) << 52);\n        }\n\n        // handle special cases\n        if (Double.isNaN(d) || Double.isInfinite(d) || (d == 0)) {\n            return d;\n        }\n        if (n < -2098) {\n            return (d > 0) ? 0.0 : -0.0;\n        }\n        if (n > 2097) {\n            return (d > 0) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n        }\n\n        // decompose d\n        final long bits = Double.doubleToRawLongBits(d);\n        final long sign = bits & 0x8000000000000000L;\nint exponent = ((int)(bits >>> 52) % 2047);\n        long mantissa   = bits & 0x000fffffffffffffL;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -1023\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else if (scaledExponent > -53) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\n                mantissa = mantissa | (1L << 52);\n\n                // scales down complete mantissa, hence losing least significant bits\n                final long mostSignificantLostBit = mantissa & (1L << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Double.longBitsToDouble(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0L) ? 0.0 : -0.0;\n            }\n        } else {\n            // we are really in the case n >= 1024\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 52) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x000fffffffffffffL;\n\n                if (scaledExponent < 2047) {\n                    return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n                } else {\n                    return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 2047) {\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else {\n                return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "20": "    public static double scalb(final double d, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -1023) && (n < 1024)) {\n            return d * Double.longBitsToDouble(((long) (n + 1023)) << 52);\n        }\n\n        // handle special cases\n        if (Double.isNaN(d) || Double.isInfinite(d) || (d == 0)) {\n            return d;\n        }\n        if (n < -2098) {\n            return (d > 0) ? 0.0 : -0.0;\n        }\n        if (n > 2097) {\n            return (d > 0) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n        }\n\n        // decompose d\n        final long bits = Double.doubleToRawLongBits(d);\n        final long sign = bits & 0x8000000000000000L;\nint exponent = ((int)(bits - 52) ^<> 2047);\n        long mantissa   = bits & 0x000fffffffffffffL;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -1023\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else if (scaledExponent > -53) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\n                mantissa = mantissa | (1L << 52);\n\n                // scales down complete mantissa, hence losing least significant bits\n                final long mostSignificantLostBit = mantissa & (1L << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Double.longBitsToDouble(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0L) ? 0.0 : -0.0;\n            }\n        } else {\n            // we are really in the case n >= 1024\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 52) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x000fffffffffffffL;\n\n                if (scaledExponent < 2047) {\n                    return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n                } else {\n                    return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 2047) {\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else {\n                return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "21": "    public static double scalb(final double d, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -1023) && (n < 1024)) {\n            return d * Double.longBitsToDouble(((long) (n + 1023)) << 52);\n        }\n\n        // handle special cases\n        if (Double.isNaN(d) || Double.isInfinite(d) || (d == 0)) {\n            return d;\n        }\n        if (n < -2098) {\n            return (d > 0) ? 0.0 : -0.0;\n        }\n        if (n > 2097) {\n            return (d > 0) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n        }\n\n        // decompose d\n        final long bits = Double.doubleToRawLongBits(d);\n        final long sign = bits & 0x8000000000000000L;\nint exponent = ((int)(bits >>> 52) ^<> 52);\n        long mantissa   = bits & 0x000fffffffffffffL;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -1023\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else if (scaledExponent > -53) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\n                mantissa = mantissa | (1L << 52);\n\n                // scales down complete mantissa, hence losing least significant bits\n                final long mostSignificantLostBit = mantissa & (1L << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Double.longBitsToDouble(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0L) ? 0.0 : -0.0;\n            }\n        } else {\n            // we are really in the case n >= 1024\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 52) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x000fffffffffffffL;\n\n                if (scaledExponent < 2047) {\n                    return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n                } else {\n                    return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 2047) {\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else {\n                return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "22": "    public static double scalb(final double d, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -1023) && (n < 1024)) {\n            return d * Double.longBitsToDouble(((long) (n + 1023)) << 52);\n        }\n\n        // handle special cases\n        if (Double.isNaN(d) || Double.isInfinite(d) || (d == 0)) {\n            return d;\n        }\n        if (n < -2098) {\n            return (d > 0) ? 0.0 : -0.0;\n        }\n        if (n > 2097) {\n            return (d > 0) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n        }\n\n        // decompose d\n        final long bits = Double.doubleToRawLongBits(d);\n        final long sign = bits & 0x8000000000000000L;\nint exponent = ((int)(bits >> 52) ^<> 2047);\n        long mantissa   = bits & 0x000fffffffffffffL;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -1023\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else if (scaledExponent > -53) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\n                mantissa = mantissa | (1L << 52);\n\n                // scales down complete mantissa, hence losing least significant bits\n                final long mostSignificantLostBit = mantissa & (1L << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Double.longBitsToDouble(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0L) ? 0.0 : -0.0;\n            }\n        } else {\n            // we are really in the case n >= 1024\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 52) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x000fffffffffffffL;\n\n                if (scaledExponent < 2047) {\n                    return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n                } else {\n                    return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 2047) {\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else {\n                return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "23": "    public static double scalb(final double d, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -1023) && (n < 1024)) {\n            return d * Double.longBitsToDouble(((long) (n + 1023)) << 52);\n        }\n\n        // handle special cases\n        if (Double.isNaN(d) || Double.isInfinite(d) || (d == 0)) {\n            return d;\n        }\n        if (n < -2098) {\n            return (d > 0) ? 0.0 : -0.0;\n        }\n        if (n > 2097) {\n            return (d > 0) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n        }\n\n        // decompose d\n        final long bits = Double.doubleToRawLongBits(d);\n        final long sign = bits & 0x8000000000000000L;\nint exponent = ((int)(bits >>> 52) ^<> -1);\n        long mantissa   = bits & 0x000fffffffffffffL;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -1023\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else if (scaledExponent > -53) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\n                mantissa = mantissa | (1L << 52);\n\n                // scales down complete mantissa, hence losing least significant bits\n                final long mostSignificantLostBit = mantissa & (1L << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Double.longBitsToDouble(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0L) ? 0.0 : -0.0;\n            }\n        } else {\n            // we are really in the case n >= 1024\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 52) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x000fffffffffffffL;\n\n                if (scaledExponent < 2047) {\n                    return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n                } else {\n                    return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 2047) {\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else {\n                return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "24": "    public static double scalb(final double d, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -1023) && (n < 1024)) {\n            return d * Double.longBitsToDouble(((long) (n + 1023)) << 52);\n        }\n\n        // handle special cases\n        if (Double.isNaN(d) || Double.isInfinite(d) || (d == 0)) {\n            return d;\n        }\n        if (n < -2098) {\n            return (d > 0) ? 0.0 : -0.0;\n        }\n        if (n > 2097) {\n            return (d > 0) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n        }\n\n        // decompose d\n        final long bits = Double.doubleToRawLongBits(d);\n        final long sign = bits & 0x8000000000000000L;\nint exponent = ((int)(bits >>> 52) / 2047);\n        long mantissa   = bits & 0x000fffffffffffffL;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -1023\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else if (scaledExponent > -53) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\n                mantissa = mantissa | (1L << 52);\n\n                // scales down complete mantissa, hence losing least significant bits\n                final long mostSignificantLostBit = mantissa & (1L << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Double.longBitsToDouble(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0L) ? 0.0 : -0.0;\n            }\n        } else {\n            // we are really in the case n >= 1024\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 52) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x000fffffffffffffL;\n\n                if (scaledExponent < 2047) {\n                    return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n                } else {\n                    return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 2047) {\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else {\n                return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "25": "    public static double scalb(final double d, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -1023) && (n < 1024)) {\n            return d * Double.longBitsToDouble(((long) (n + 1023)) << 52);\n        }\n\n        // handle special cases\n        if (Double.isNaN(d) || Double.isInfinite(d) || (d == 0)) {\n            return d;\n        }\n        if (n < -2098) {\n            return (d > 0) ? 0.0 : -0.0;\n        }\n        if (n > 2097) {\n            return (d > 0) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n        }\n\n        // decompose d\n        final long bits = Double.doubleToRawLongBits(d);\n        final long sign = bits & 0x8000000000000000L;\nint exponent = ((int)(bits >>> 52) <= 2047);\n        long mantissa   = bits & 0x000fffffffffffffL;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -1023\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else if (scaledExponent > -53) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\n                mantissa = mantissa | (1L << 52);\n\n                // scales down complete mantissa, hence losing least significant bits\n                final long mostSignificantLostBit = mantissa & (1L << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Double.longBitsToDouble(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0L) ? 0.0 : -0.0;\n            }\n        } else {\n            // we are really in the case n >= 1024\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 52) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x000fffffffffffffL;\n\n                if (scaledExponent < 2047) {\n                    return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n                } else {\n                    return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 2047) {\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else {\n                return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "26": "    public static double scalb(final double d, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -1023) && (n < 1024)) {\n            return d * Double.longBitsToDouble(((long) (n + 1023)) << 52);\n        }\n\n        // handle special cases\n        if (Double.isNaN(d) || Double.isInfinite(d) || (d == 0)) {\n            return d;\n        }\n        if (n < -2098) {\n            return (d > 0) ? 0.0 : -0.0;\n        }\n        if (n > 2097) {\n            return (d > 0) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n        }\n\n        // decompose d\n        final long bits = Double.doubleToRawLongBits(d);\n        final long sign = bits & 0x8000000000000000L;\nint exponent = ((int)(bits >>> 52) ^<> 2047);\n        long mantissa   = bits & 0x000fffffffffffffL;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -1023\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else if (scaledExponent > -53) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\n                mantissa = mantissa | (1L << 52);\n\n                // scales down complete mantissa, hence losing least significant bits\n                final long mostSignificantLostBit = mantissa & (1L << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Double.longBitsToDouble(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0L) ? 0.0 : -0.0;\n            }\n        } else {\n            // we are really in the case n >= 1024\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 52) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x000fffffffffffffL;\n\n                if (scaledExponent < 2047) {\n                    return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n                } else {\n                    return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 2047) {\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else {\n                return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "27": "    public static double scalb(final double d, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -1023) && (n < 1024)) {\n            return d * Double.longBitsToDouble(((long) (n + 1023)) << 52);\n        }\n\n        // handle special cases\n        if (Double.isNaN(d) || Double.isInfinite(d) || (d == 0)) {\n            return d;\n        }\n        if (n < -2098) {\n            return (d > 0) ? 0.0 : -0.0;\n        }\n        if (n > 2097) {\n            return (d > 0) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n        }\n\n        // decompose d\n        final long bits = Double.doubleToRawLongBits(d);\n        final long sign = bits & 0x8000000000000000L;\nint exponent = ((int)(bits >>> 0x8000000000000000L) ^<> 2047);\n        long mantissa   = bits & 0x000fffffffffffffL;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -1023\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else if (scaledExponent > -53) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\n                mantissa = mantissa | (1L << 52);\n\n                // scales down complete mantissa, hence losing least significant bits\n                final long mostSignificantLostBit = mantissa & (1L << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Double.longBitsToDouble(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0L) ? 0.0 : -0.0;\n            }\n        } else {\n            // we are really in the case n >= 1024\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 52) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x000fffffffffffffL;\n\n                if (scaledExponent < 2047) {\n                    return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n                } else {\n                    return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 2047) {\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else {\n                return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "28": "    public static double scalb(final double d, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -1023) && (n < 1024)) {\n            return d * Double.longBitsToDouble(((long) (n + 1023)) << 52);\n        }\n\n        // handle special cases\n        if (Double.isNaN(d) || Double.isInfinite(d) || (d == 0)) {\n            return d;\n        }\n        if (n < -2098) {\n            return (d > 0) ? 0.0 : -0.0;\n        }\n        if (n > 2097) {\n            return (d > 0) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n        }\n\n        // decompose d\n        final long bits = Double.doubleToRawLongBits(d);\n        final long sign = bits & 0x8000000000000000L;\nint exponent = ((int)(bits >>> 52) << 2047);\n        long mantissa   = bits & 0x000fffffffffffffL;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -1023\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else if (scaledExponent > -53) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\n                mantissa = mantissa | (1L << 52);\n\n                // scales down complete mantissa, hence losing least significant bits\n                final long mostSignificantLostBit = mantissa & (1L << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Double.longBitsToDouble(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0L) ? 0.0 : -0.0;\n            }\n        } else {\n            // we are really in the case n >= 1024\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 52) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x000fffffffffffffL;\n\n                if (scaledExponent < 2047) {\n                    return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n                } else {\n                    return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 2047) {\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else {\n                return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "29": "    public static double scalb(final double d, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -1023) && (n < 1024)) {\n            return d * Double.longBitsToDouble(((long) (n + 1023)) << 52);\n        }\n\n        // handle special cases\n        if (Double.isNaN(d) || Double.isInfinite(d) || (d == 0)) {\n            return d;\n        }\n        if (n < -2098) {\n            return (d > 0) ? 0.0 : -0.0;\n        }\n        if (n > 2097) {\n            return (d > 0) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n        }\n\n        // decompose d\n        final long bits = Double.doubleToRawLongBits(d);\n        final long sign = bits & 0x8000000000000000L;\nint exponent = ((int)(bits >>> 52) * 2047);\n        long mantissa   = bits & 0x000fffffffffffffL;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -1023\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else if (scaledExponent > -53) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\n                mantissa = mantissa | (1L << 52);\n\n                // scales down complete mantissa, hence losing least significant bits\n                final long mostSignificantLostBit = mantissa & (1L << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Double.longBitsToDouble(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0L) ? 0.0 : -0.0;\n            }\n        } else {\n            // we are really in the case n >= 1024\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 52) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x000fffffffffffffL;\n\n                if (scaledExponent < 2047) {\n                    return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n                } else {\n                    return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 2047) {\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else {\n                return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "30": "    public static double scalb(final double d, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -1023) && (n < 1024)) {\n            return d * Double.longBitsToDouble(((long) (n + 1023)) << 52);\n        }\n\n        // handle special cases\n        if (Double.isNaN(d) || Double.isInfinite(d) || (d == 0)) {\n            return d;\n        }\n        if (n < -2098) {\n            return (d > 0) ? 0.0 : -0.0;\n        }\n        if (n > 2097) {\n            return (d > 0) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n        }\n\n        // decompose d\n        final long bits = Double.doubleToRawLongBits(d);\n        final long sign = bits & 0x8000000000000000L;\nint exponent = ((int)(bits % 52) ^<> 2047);\n        long mantissa   = bits & 0x000fffffffffffffL;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -1023\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else if (scaledExponent > -53) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\n                mantissa = mantissa | (1L << 52);\n\n                // scales down complete mantissa, hence losing least significant bits\n                final long mostSignificantLostBit = mantissa & (1L << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Double.longBitsToDouble(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0L) ? 0.0 : -0.0;\n            }\n        } else {\n            // we are really in the case n >= 1024\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 52) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x000fffffffffffffL;\n\n                if (scaledExponent < 2047) {\n                    return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n                } else {\n                    return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 2047) {\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else {\n                return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "31": "    public static double scalb(final double d, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -1023) && (n < 1024)) {\n            return d * Double.longBitsToDouble(((long) (n + 1023)) << 52);\n        }\n\n        // handle special cases\n        if (Double.isNaN(d) || Double.isInfinite(d) || (d == 0)) {\n            return d;\n        }\n        if (n < -2098) {\n            return (d > 0) ? 0.0 : -0.0;\n        }\n        if (n > 2097) {\n            return (d > 0) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n        }\n\n        // decompose d\n        final long bits = Double.doubleToRawLongBits(d);\n        final long sign = bits & 0x8000000000000000L;\nint exponent = ((int)(bits & 52) ^<> 2047);\n        long mantissa   = bits & 0x000fffffffffffffL;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -1023\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else if (scaledExponent > -53) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\n                mantissa = mantissa | (1L << 52);\n\n                // scales down complete mantissa, hence losing least significant bits\n                final long mostSignificantLostBit = mantissa & (1L << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Double.longBitsToDouble(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0L) ? 0.0 : -0.0;\n            }\n        } else {\n            // we are really in the case n >= 1024\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 52) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x000fffffffffffffL;\n\n                if (scaledExponent < 2047) {\n                    return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n                } else {\n                    return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 2047) {\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else {\n                return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "32": "    public static double scalb(final double d, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -1023) && (n < 1024)) {\n            return d * Double.longBitsToDouble(((long) (n + 1023)) << 52);\n        }\n\n        // handle special cases\n        if (Double.isNaN(d) || Double.isInfinite(d) || (d == 0)) {\n            return d;\n        }\n        if (n < -2098) {\n            return (d > 0) ? 0.0 : -0.0;\n        }\n        if (n > 2097) {\n            return (d > 0) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n        }\n\n        // decompose d\n        final long bits = Double.doubleToRawLongBits(d);\n        final long sign = bits & 0x8000000000000000L;\nint exponent = ((int)(bits >>> 52) >= 2047);\n        long mantissa   = bits & 0x000fffffffffffffL;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -1023\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else if (scaledExponent > -53) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\n                mantissa = mantissa | (1L << 52);\n\n                // scales down complete mantissa, hence losing least significant bits\n                final long mostSignificantLostBit = mantissa & (1L << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Double.longBitsToDouble(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0L) ? 0.0 : -0.0;\n            }\n        } else {\n            // we are really in the case n >= 1024\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 52) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x000fffffffffffffL;\n\n                if (scaledExponent < 2047) {\n                    return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n                } else {\n                    return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 2047) {\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else {\n                return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "33": "    public static double scalb(final double d, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -1023) && (n < 1024)) {\n            return d * Double.longBitsToDouble(((long) (n + 1023)) << 52);\n        }\n\n        // handle special cases\n        if (Double.isNaN(d) || Double.isInfinite(d) || (d == 0)) {\n            return d;\n        }\n        if (n < -2098) {\n            return (d > 0) ? 0.0 : -0.0;\n        }\n        if (n > 2097) {\n            return (d > 0) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n        }\n\n        // decompose d\n        final long bits = Double.doubleToRawLongBits(d);\n        final long sign = bits & 0x8000000000000000L;\nint exponent = ((int)(bits / 52) ^<> 2047);\n        long mantissa   = bits & 0x000fffffffffffffL;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -1023\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else if (scaledExponent > -53) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\n                mantissa = mantissa | (1L << 52);\n\n                // scales down complete mantissa, hence losing least significant bits\n                final long mostSignificantLostBit = mantissa & (1L << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Double.longBitsToDouble(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0L) ? 0.0 : -0.0;\n            }\n        } else {\n            // we are really in the case n >= 1024\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 52) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x000fffffffffffffL;\n\n                if (scaledExponent < 2047) {\n                    return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n                } else {\n                    return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 2047) {\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else {\n                return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "34": "    public static double scalb(final double d, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -1023) && (n < 1024)) {\n            return d * Double.longBitsToDouble(((long) (n + 1023)) << 52);\n        }\n\n        // handle special cases\n        if (Double.isNaN(d) || Double.isInfinite(d) || (d == 0)) {\n            return d;\n        }\n        if (n < -2098) {\n            return (d > 0) ? 0.0 : -0.0;\n        }\n        if (n > 2097) {\n            return (d > 0) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n        }\n\n        // decompose d\n        final long bits = Double.doubleToRawLongBits(d);\n        final long sign = bits & 0x8000000000000000L;\nint exponent = ((int)(bits <= 52) ^<> 2047);\n        long mantissa   = bits & 0x000fffffffffffffL;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -1023\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else if (scaledExponent > -53) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\n                mantissa = mantissa | (1L << 52);\n\n                // scales down complete mantissa, hence losing least significant bits\n                final long mostSignificantLostBit = mantissa & (1L << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Double.longBitsToDouble(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0L) ? 0.0 : -0.0;\n            }\n        } else {\n            // we are really in the case n >= 1024\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 52) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x000fffffffffffffL;\n\n                if (scaledExponent < 2047) {\n                    return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n                } else {\n                    return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 2047) {\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else {\n                return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "35": "    public static double scalb(final double d, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -1023) && (n < 1024)) {\n            return d * Double.longBitsToDouble(((long) (n + 1023)) << 52);\n        }\n\n        // handle special cases\n        if (Double.isNaN(d) || Double.isInfinite(d) || (d == 0)) {\n            return d;\n        }\n        if (n < -2098) {\n            return (d > 0) ? 0.0 : -0.0;\n        }\n        if (n > 2097) {\n            return (d > 0) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n        }\n\n        // decompose d\n        final long bits = Double.doubleToRawLongBits(d);\n        final long sign = bits & 0x8000000000000000L;\nint exponent = ((int)(bits * 52) ^<> 2047);\n        long mantissa   = bits & 0x000fffffffffffffL;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -1023\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else if (scaledExponent > -53) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\n                mantissa = mantissa | (1L << 52);\n\n                // scales down complete mantissa, hence losing least significant bits\n                final long mostSignificantLostBit = mantissa & (1L << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Double.longBitsToDouble(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0L) ? 0.0 : -0.0;\n            }\n        } else {\n            // we are really in the case n >= 1024\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 52) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x000fffffffffffffL;\n\n                if (scaledExponent < 2047) {\n                    return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n                } else {\n                    return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 2047) {\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else {\n                return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "36": "    public static double scalb(final double d, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -1023) && (n < 1024)) {\n            return d * Double.longBitsToDouble(((long) (n + 1023)) << 52);\n        }\n\n        // handle special cases\n        if (Double.isNaN(d) || Double.isInfinite(d) || (d == 0)) {\n            return d;\n        }\n        if (n < -2098) {\n            return (d > 0) ? 0.0 : -0.0;\n        }\n        if (n > 2097) {\n            return (d > 0) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n        }\n\n        // decompose d\n        final long bits = Double.doubleToRawLongBits(d);\n        final long sign = bits & 0x8000000000000000L;\nint exponent = ((int)(bits << 52) ^<> 2047);\n        long mantissa   = bits & 0x000fffffffffffffL;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -1023\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else if (scaledExponent > -53) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\n                mantissa = mantissa | (1L << 52);\n\n                // scales down complete mantissa, hence losing least significant bits\n                final long mostSignificantLostBit = mantissa & (1L << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Double.longBitsToDouble(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0L) ? 0.0 : -0.0;\n            }\n        } else {\n            // we are really in the case n >= 1024\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 52) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x000fffffffffffffL;\n\n                if (scaledExponent < 2047) {\n                    return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n                } else {\n                    return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 2047) {\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else {\n                return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "37": "    public static double scalb(final double d, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -1023) && (n < 1024)) {\n            return d * Double.longBitsToDouble(((long) (n + 1023)) << 52);\n        }\n\n        // handle special cases\n        if (Double.isNaN(d) || Double.isInfinite(d) || (d == 0)) {\n            return d;\n        }\n        if (n < -2098) {\n            return (d > 0) ? 0.0 : -0.0;\n        }\n        if (n > 2097) {\n            return (d > 0) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n        }\n\n        // decompose d\n        final long bits = Double.doubleToRawLongBits(d);\n        final long sign = bits & 0x8000000000000000L;\nint exponent = ((int)(bits >>> -1) ^<> 2047);\n        long mantissa   = bits & 0x000fffffffffffffL;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -1023\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else if (scaledExponent > -53) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\n                mantissa = mantissa | (1L << 52);\n\n                // scales down complete mantissa, hence losing least significant bits\n                final long mostSignificantLostBit = mantissa & (1L << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Double.longBitsToDouble(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0L) ? 0.0 : -0.0;\n            }\n        } else {\n            // we are really in the case n >= 1024\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 52) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x000fffffffffffffL;\n\n                if (scaledExponent < 2047) {\n                    return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n                } else {\n                    return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 2047) {\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else {\n                return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "38": "    public static double scalb(final double d, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -1023) && (n < 1024)) {\n            return d * Double.longBitsToDouble(((long) (n + 1023)) << 52);\n        }\n\n        // handle special cases\n        if (Double.isNaN(d) || Double.isInfinite(d) || (d == 0)) {\n            return d;\n        }\n        if (n < -2098) {\n            return (d > 0) ? 0.0 : -0.0;\n        }\n        if (n > 2097) {\n            return (d > 0) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n        }\n\n        // decompose d\n        final long bits = Double.doubleToRawLongBits(d);\n        final long sign = bits & 0x8000000000000000L;\nlong exponent = ((int)(bits >>> 52) ^<> 2047);\n        long mantissa   = bits & 0x000fffffffffffffL;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -1023\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else if (scaledExponent > -53) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\n                mantissa = mantissa | (1L << 52);\n\n                // scales down complete mantissa, hence losing least significant bits\n                final long mostSignificantLostBit = mantissa & (1L << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Double.longBitsToDouble(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0L) ? 0.0 : -0.0;\n            }\n        } else {\n            // we are really in the case n >= 1024\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 52) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x000fffffffffffffL;\n\n                if (scaledExponent < 2047) {\n                    return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n                } else {\n                    return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 2047) {\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else {\n                return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "39": "    public static double scalb(final double d, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -1023) && (n < 1024)) {\n            return d * Double.longBitsToDouble(((long) (n + 1023)) << 52);\n        }\n\n        // handle special cases\n        if (Double.isNaN(d) || Double.isInfinite(d) || (d == 0)) {\n            return d;\n        }\n        if (n < -2098) {\n            return (d > 0) ? 0.0 : -0.0;\n        }\n        if (n > 2097) {\n            return (d > 0) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n        }\n\n        // decompose d\n        final long bits = Double.doubleToRawLongBits(d);\n        final long sign = bits & 0x8000000000000000L;\nint exponent = ((int)(bits >= 52) ^<> 2047);\n        long mantissa   = bits & 0x000fffffffffffffL;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -1023\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else if (scaledExponent > -53) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\n                mantissa = mantissa | (1L << 52);\n\n                // scales down complete mantissa, hence losing least significant bits\n                final long mostSignificantLostBit = mantissa & (1L << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Double.longBitsToDouble(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0L) ? 0.0 : -0.0;\n            }\n        } else {\n            // we are really in the case n >= 1024\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 52) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x000fffffffffffffL;\n\n                if (scaledExponent < 2047) {\n                    return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n                } else {\n                    return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 2047) {\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else {\n                return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "40": "    public static double scalb(final double d, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -1023) && (n < 1024)) {\n            return d * Double.longBitsToDouble(((long) (n + 1023)) << 52);\n        }\n\n        // handle special cases\n        if (Double.isNaN(d) || Double.isInfinite(d) || (d == 0)) {\n            return d;\n        }\n        if (n < -2098) {\n            return (d > 0) ? 0.0 : -0.0;\n        }\n        if (n > 2097) {\n            return (d > 0) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n        }\n\n        // decompose d\n        final long bits = Double.doubleToRawLongBits(d);\n        final long sign = bits & 0x8000000000000000L;\nint exponent = ((int)(bits >>> 2047) ^<> 2047);\n        long mantissa   = bits & 0x000fffffffffffffL;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -1023\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else if (scaledExponent > -53) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\n                mantissa = mantissa | (1L << 52);\n\n                // scales down complete mantissa, hence losing least significant bits\n                final long mostSignificantLostBit = mantissa & (1L << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Double.longBitsToDouble(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0L) ? 0.0 : -0.0;\n            }\n        } else {\n            // we are really in the case n >= 1024\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 52) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x000fffffffffffffL;\n\n                if (scaledExponent < 2047) {\n                    return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n                } else {\n                    return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 2047) {\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else {\n                return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "41": "    public static double scalb(final double d, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -1023) && (n < 1024)) {\n            return d * Double.longBitsToDouble(((long) (n + 1023)) << 52);\n        }\n\n        // handle special cases\n        if (Double.isNaN(d) || Double.isInfinite(d) || (d == 0)) {\n            return d;\n        }\n        if (n < -2098) {\n            return (d > 0) ? 0.0 : -0.0;\n        }\n        if (n > 2097) {\n            return (d > 0) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n        }\n\n        // decompose d\n        final long bits = Double.doubleToRawLongBits(d);\n        final long sign = bits & 0x8000000000000000L;\nfinal int exponent = ((int)(bits >>> 52) ^<> 2047);\n        long mantissa   = bits & 0x000fffffffffffffL;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -1023\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else if (scaledExponent > -53) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\n                mantissa = mantissa | (1L << 52);\n\n                // scales down complete mantissa, hence losing least significant bits\n                final long mostSignificantLostBit = mantissa & (1L << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Double.longBitsToDouble(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0L) ? 0.0 : -0.0;\n            }\n        } else {\n            // we are really in the case n >= 1024\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 52) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x000fffffffffffffL;\n\n                if (scaledExponent < 2047) {\n                    return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n                } else {\n                    return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 2047) {\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else {\n                return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "42": "    public static double scalb(final double d, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -1023) && (n < 1024)) {\n            return d * Double.longBitsToDouble(((long) (n + 1023)) << 52);\n        }\n\n        // handle special cases\n        if (Double.isNaN(d) || Double.isInfinite(d) || (d == 0)) {\n            return d;\n        }\n        if (n < -2098) {\n            return (d > 0) ? 0.0 : -0.0;\n        }\n        if (n > 2097) {\n            return (d > 0) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n        }\n\n        // decompose d\n        final long bits = Double.doubleToRawLongBits(d);\n        final long sign = bits & 0x8000000000000000L;\nint  = bits;\n        long mantissa   = bits & 0x000fffffffffffffL;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -1023\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else if (scaledExponent > -53) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\n                mantissa = mantissa | (1L << 52);\n\n                // scales down complete mantissa, hence losing least significant bits\n                final long mostSignificantLostBit = mantissa & (1L << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Double.longBitsToDouble(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0L) ? 0.0 : -0.0;\n            }\n        } else {\n            // we are really in the case n >= 1024\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 52) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x000fffffffffffffL;\n\n                if (scaledExponent < 2047) {\n                    return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n                } else {\n                    return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 2047) {\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else {\n                return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "43": "    public static double scalb(final double d, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -1023) && (n < 1024)) {\n            return d * Double.longBitsToDouble(((long) (n + 1023)) << 52);\n        }\n\n        // handle special cases\n        if (Double.isNaN(d) || Double.isInfinite(d) || (d == 0)) {\n            return d;\n        }\n        if (n < -2098) {\n            return (d > 0) ? 0.0 : -0.0;\n        }\n        if (n > 2097) {\n            return (d > 0) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n        }\n\n        // decompose d\n        final long bits = Double.doubleToRawLongBits(d);\n        final long sign = bits & 0x8000000000000000L;\nint  = this.bits;\n        long mantissa   = bits & 0x000fffffffffffffL;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -1023\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else if (scaledExponent > -53) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\n                mantissa = mantissa | (1L << 52);\n\n                // scales down complete mantissa, hence losing least significant bits\n                final long mostSignificantLostBit = mantissa & (1L << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Double.longBitsToDouble(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0L) ? 0.0 : -0.0;\n            }\n        } else {\n            // we are really in the case n >= 1024\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 52) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x000fffffffffffffL;\n\n                if (scaledExponent < 2047) {\n                    return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n                } else {\n                    return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 2047) {\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else {\n                return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "44": "    public static double scalb(final double d, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -1023) && (n < 1024)) {\n            return d * Double.longBitsToDouble(((long) (n + 1023)) << 52);\n        }\n\n        // handle special cases\n        if (Double.isNaN(d) || Double.isInfinite(d) || (d == 0)) {\n            return d;\n        }\n        if (n < -2098) {\n            return (d > 0) ? 0.0 : -0.0;\n        }\n        if (n > 2097) {\n            return (d > 0) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n        }\n\n        // decompose d\n        final long bits = Double.doubleToRawLongBits(d);\n        final long sign = bits & 0x8000000000000000L;\nreturn;\n        int  exponent   = ((int)(bits >>> 52)) ^ 2047;        long mantissa   = bits & 0x000fffffffffffffL;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -1023\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else if (scaledExponent > -53) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\n                mantissa = mantissa | (1L << 52);\n\n                // scales down complete mantissa, hence losing least significant bits\n                final long mostSignificantLostBit = mantissa & (1L << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Double.longBitsToDouble(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0L) ? 0.0 : -0.0;\n            }\n        } else {\n            // we are really in the case n >= 1024\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 52) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x000fffffffffffffL;\n\n                if (scaledExponent < 2047) {\n                    return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n                } else {\n                    return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 2047) {\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else {\n                return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "45": "    public static double scalb(final double d, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -1023) && (n < 1024)) {\n            return d * Double.longBitsToDouble(((long) (n + 1023)) << 52);\n        }\n\n        // handle special cases\n        if (Double.isNaN(d) || Double.isInfinite(d) || (d == 0)) {\n            return d;\n        }\n        if (n < -2098) {\n            return (d > 0) ? 0.0 : -0.0;\n        }\n        if (n > 2097) {\n            return (d > 0) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n        }\n\n        // decompose d\n        final long bits = Double.doubleToRawLongBits(d);\n        final long sign = bits & 0x8000000000000000L;\nint  = (bits + 2047);\n        long mantissa   = bits & 0x000fffffffffffffL;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -1023\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else if (scaledExponent > -53) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\n                mantissa = mantissa | (1L << 52);\n\n                // scales down complete mantissa, hence losing least significant bits\n                final long mostSignificantLostBit = mantissa & (1L << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Double.longBitsToDouble(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0L) ? 0.0 : -0.0;\n            }\n        } else {\n            // we are really in the case n >= 1024\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 52) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x000fffffffffffffL;\n\n                if (scaledExponent < 2047) {\n                    return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n                } else {\n                    return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 2047) {\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else {\n                return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "46": "    public static double scalb(final double d, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -1023) && (n < 1024)) {\n            return d * Double.longBitsToDouble(((long) (n + 1023)) << 52);\n        }\n\n        // handle special cases\n        if (Double.isNaN(d) || Double.isInfinite(d) || (d == 0)) {\n            return d;\n        }\n        if (n < -2098) {\n            return (d > 0) ? 0.0 : -0.0;\n        }\n        if (n > 2097) {\n            return (d > 0) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n        }\n\n        // decompose d\n        final long bits = Double.doubleToRawLongBits(d);\n        final long sign = bits & 0x8000000000000000L;\n        int  exponent   = ((int)(bits >>> 52)) ^ 2047;        long mantissa   = bits & 0x000fffffffffffffL;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -1023\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else if (scaledExponent > -53) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\n                mantissa = mantissa | (1L << 52);\n\n                // scales down complete mantissa, hence losing least significant bits\n                final long mostSignificantLostBit = mantissa & (1L << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Double.longBitsToDouble(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0L) ? 0.0 : -0.0;\n            }\n        } else {\n            // we are really in the case n >= 1024\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 52) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x000fffffffffffffL;\n\n                if (scaledExponent < 2047) {\n                    return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n                } else {\n                    return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 2047) {\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else {\n                return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "47": "    public static double scalb(final double d, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -1023) && (n < 1024)) {\n            return d * Double.longBitsToDouble(((long) (n + 1023)) << 52);\n        }\n\n        // handle special cases\n        if (Double.isNaN(d) || Double.isInfinite(d) || (d == 0)) {\n            return d;\n        }\n        if (n < -2098) {\n            return (d > 0) ? 0.0 : -0.0;\n        }\n        if (n > 2097) {\n            return (d > 0) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n        }\n\n        // decompose d\n        final long bits = Double.doubleToRawLongBits(d);\n        final long sign = bits & 0x8000000000000000L;\nint  = (bits * 2047);\n        long mantissa   = bits & 0x000fffffffffffffL;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -1023\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else if (scaledExponent > -53) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\n                mantissa = mantissa | (1L << 52);\n\n                // scales down complete mantissa, hence losing least significant bits\n                final long mostSignificantLostBit = mantissa & (1L << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Double.longBitsToDouble(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0L) ? 0.0 : -0.0;\n            }\n        } else {\n            // we are really in the case n >= 1024\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 52) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x000fffffffffffffL;\n\n                if (scaledExponent < 2047) {\n                    return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n                } else {\n                    return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 2047) {\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else {\n                return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "48": "    public static double scalb(final double d, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -1023) && (n < 1024)) {\n            return d * Double.longBitsToDouble(((long) (n + 1023)) << 52);\n        }\n\n        // handle special cases\n        if (Double.isNaN(d) || Double.isInfinite(d) || (d == 0)) {\n            return d;\n        }\n        if (n < -2098) {\n            return (d > 0) ? 0.0 : -0.0;\n        }\n        if (n > 2097) {\n            return (d > 0) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n        }\n\n        // decompose d\n        final long bits = Double.doubleToRawLongBits(d);\n        final long sign = bits & 0x8000000000000000L;\nint  = (int)(bits * 2047);\n        long mantissa   = bits & 0x000fffffffffffffL;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -1023\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else if (scaledExponent > -53) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\n                mantissa = mantissa | (1L << 52);\n\n                // scales down complete mantissa, hence losing least significant bits\n                final long mostSignificantLostBit = mantissa & (1L << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Double.longBitsToDouble(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0L) ? 0.0 : -0.0;\n            }\n        } else {\n            // we are really in the case n >= 1024\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 52) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x000fffffffffffffL;\n\n                if (scaledExponent < 2047) {\n                    return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n                } else {\n                    return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 2047) {\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else {\n                return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "49": "    public static double scalb(final double d, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -1023) && (n < 1024)) {\n            return d * Double.longBitsToDouble(((long) (n + 1023)) << 52);\n        }\n\n        // handle special cases\n        if (Double.isNaN(d) || Double.isInfinite(d) || (d == 0)) {\n            return d;\n        }\n        if (n < -2098) {\n            return (d > 0) ? 0.0 : -0.0;\n        }\n        if (n > 2097) {\n            return (d > 0) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n        }\n\n        // decompose d\n        final long bits = Double.doubleToRawLongBits(d);\n        final long sign = bits & 0x8000000000000000L;\nint  = ((((int)(bits >>> 52) ^<> 2047) && (bits != null)))?bits:((int)(bits >>> 52) ^<> 2047);\n        long mantissa   = bits & 0x000fffffffffffffL;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -1023\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else if (scaledExponent > -53) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\n                mantissa = mantissa | (1L << 52);\n\n                // scales down complete mantissa, hence losing least significant bits\n                final long mostSignificantLostBit = mantissa & (1L << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Double.longBitsToDouble(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0L) ? 0.0 : -0.0;\n            }\n        } else {\n            // we are really in the case n >= 1024\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 52) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x000fffffffffffffL;\n\n                if (scaledExponent < 2047) {\n                    return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n                } else {\n                    return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 2047) {\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else {\n                return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "50": "    public static double scalb(final double d, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -1023) && (n < 1024)) {\n            return d * Double.longBitsToDouble(((long) (n + 1023)) << 52);\n        }\n\n        // handle special cases\n        if (Double.isNaN(d) || Double.isInfinite(d) || (d == 0)) {\n            return d;\n        }\n        if (n < -2098) {\n            return (d > 0) ? 0.0 : -0.0;\n        }\n        if (n > 2097) {\n            return (d > 0) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n        }\n\n        // decompose d\n        final long bits = Double.doubleToRawLongBits(d);\n        final long sign = bits & 0x8000000000000000L;\nint  = ((((int)(bits >>> 52) ^<> 2047) && (bits == bits)))?bits:((int)(bits >>> 52) ^<> 2047);\n        long mantissa   = bits & 0x000fffffffffffffL;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -1023\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else if (scaledExponent > -53) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\n                mantissa = mantissa | (1L << 52);\n\n                // scales down complete mantissa, hence losing least significant bits\n                final long mostSignificantLostBit = mantissa & (1L << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Double.longBitsToDouble(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0L) ? 0.0 : -0.0;\n            }\n        } else {\n            // we are really in the case n >= 1024\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 52) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x000fffffffffffffL;\n\n                if (scaledExponent < 2047) {\n                    return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n                } else {\n                    return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 2047) {\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else {\n                return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "51": "    public static double scalb(final double d, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -1023) && (n < 1024)) {\n            return d * Double.longBitsToDouble(((long) (n + 1023)) << 52);\n        }\n\n        // handle special cases\n        if (Double.isNaN(d) || Double.isInfinite(d) || (d == 0)) {\n            return d;\n        }\n        if (n < -2098) {\n            return (d > 0) ? 0.0 : -0.0;\n        }\n        if (n > 2097) {\n            return (d > 0) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n        }\n\n        // decompose d\n        final long bits = Double.doubleToRawLongBits(d);\n        final long sign = bits & 0x8000000000000000L;\nint  = ((((int)(bits >>> 52) ^<> 2047) && (bits != null)))?bits:0;\n        long mantissa   = bits & 0x000fffffffffffffL;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -1023\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else if (scaledExponent > -53) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\n                mantissa = mantissa | (1L << 52);\n\n                // scales down complete mantissa, hence losing least significant bits\n                final long mostSignificantLostBit = mantissa & (1L << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Double.longBitsToDouble(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0L) ? 0.0 : -0.0;\n            }\n        } else {\n            // we are really in the case n >= 1024\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 52) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x000fffffffffffffL;\n\n                if (scaledExponent < 2047) {\n                    return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n                } else {\n                    return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 2047) {\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else {\n                return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "52": "    public static double scalb(final double d, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -1023) && (n < 1024)) {\n            return d * Double.longBitsToDouble(((long) (n + 1023)) << 52);\n        }\n\n        // handle special cases\n        if (Double.isNaN(d) || Double.isInfinite(d) || (d == 0)) {\n            return d;\n        }\n        if (n < -2098) {\n            return (d > 0) ? 0.0 : -0.0;\n        }\n        if (n > 2097) {\n            return (d > 0) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n        }\n\n        // decompose d\n        final long bits = Double.doubleToRawLongBits(d);\n        final long sign = bits & 0x8000000000000000L;\nint  = ((((int)(bits >>> 52) ^<> 2047) && (bits == bits)))?bits:0;\n        long mantissa   = bits & 0x000fffffffffffffL;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -1023\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else if (scaledExponent > -53) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\n                mantissa = mantissa | (1L << 52);\n\n                // scales down complete mantissa, hence losing least significant bits\n                final long mostSignificantLostBit = mantissa & (1L << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Double.longBitsToDouble(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0L) ? 0.0 : -0.0;\n            }\n        } else {\n            // we are really in the case n >= 1024\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 52) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x000fffffffffffffL;\n\n                if (scaledExponent < 2047) {\n                    return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n                } else {\n                    return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 2047) {\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else {\n                return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "53": "    public static double scalb(final double d, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -1023) && (n < 1024)) {\n            return d * Double.longBitsToDouble(((long) (n + 1023)) << 52);\n        }\n\n        // handle special cases\n        if (Double.isNaN(d) || Double.isInfinite(d) || (d == 0)) {\n            return d;\n        }\n        if (n < -2098) {\n            return (d > 0) ? 0.0 : -0.0;\n        }\n        if (n > 2097) {\n            return (d > 0) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n        }\n\n        // decompose d\n        final long bits = Double.doubleToRawLongBits(d);\n        final long sign = bits & 0x8000000000000000L;\nint  = ((((int)(bits >>> 52) ^<> 2047) && (bits == bits)))?bits:bits;\n        long mantissa   = bits & 0x000fffffffffffffL;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -1023\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else if (scaledExponent > -53) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\n                mantissa = mantissa | (1L << 52);\n\n                // scales down complete mantissa, hence losing least significant bits\n                final long mostSignificantLostBit = mantissa & (1L << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Double.longBitsToDouble(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0L) ? 0.0 : -0.0;\n            }\n        } else {\n            // we are really in the case n >= 1024\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 52) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x000fffffffffffffL;\n\n                if (scaledExponent < 2047) {\n                    return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n                } else {\n                    return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 2047) {\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else {\n                return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "54": "    public static double scalb(final double d, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -1023) && (n < 1024)) {\n            return d * Double.longBitsToDouble(((long) (n + 1023)) << 52);\n        }\n\n        // handle special cases\n        if (Double.isNaN(d) || Double.isInfinite(d) || (d == 0)) {\n            return d;\n        }\n        if (n < -2098) {\n            return (d > 0) ? 0.0 : -0.0;\n        }\n        if (n > 2097) {\n            return (d > 0) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n        }\n\n        // decompose d\n        final long bits = Double.doubleToRawLongBits(d);\n        final long sign = bits & 0x8000000000000000L;\nint  = ((((int)(bits >>> 52) ^<> 2047) && (bits == 0)))?bits:0;\n        long mantissa   = bits & 0x000fffffffffffffL;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -1023\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else if (scaledExponent > -53) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\n                mantissa = mantissa | (1L << 52);\n\n                // scales down complete mantissa, hence losing least significant bits\n                final long mostSignificantLostBit = mantissa & (1L << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Double.longBitsToDouble(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0L) ? 0.0 : -0.0;\n            }\n        } else {\n            // we are really in the case n >= 1024\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 52) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x000fffffffffffffL;\n\n                if (scaledExponent < 2047) {\n                    return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n                } else {\n                    return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 2047) {\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else {\n                return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "55": "    public static double scalb(final double d, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -1023) && (n < 1024)) {\n            return d * Double.longBitsToDouble(((long) (n + 1023)) << 52);\n        }\n\n        // handle special cases\n        if (Double.isNaN(d) || Double.isInfinite(d) || (d == 0)) {\n            return d;\n        }\n        if (n < -2098) {\n            return (d > 0) ? 0.0 : -0.0;\n        }\n        if (n > 2097) {\n            return (d > 0) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n        }\n\n        // decompose d\n        final long bits = Double.doubleToRawLongBits(d);\n        final long sign = bits & 0x8000000000000000L;\nint  = ((((int)(bits >>> 52) ^<> 2047) && (bits != null)))?bits:bits;\n        long mantissa   = bits & 0x000fffffffffffffL;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -1023\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else if (scaledExponent > -53) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\n                mantissa = mantissa | (1L << 52);\n\n                // scales down complete mantissa, hence losing least significant bits\n                final long mostSignificantLostBit = mantissa & (1L << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Double.longBitsToDouble(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0L) ? 0.0 : -0.0;\n            }\n        } else {\n            // we are really in the case n >= 1024\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 52) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x000fffffffffffffL;\n\n                if (scaledExponent < 2047) {\n                    return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n                } else {\n                    return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 2047) {\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else {\n                return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "56": "    public static double scalb(final double d, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -1023) && (n < 1024)) {\n            return d * Double.longBitsToDouble(((long) (n + 1023)) << 52);\n        }\n\n        // handle special cases\n        if (Double.isNaN(d) || Double.isInfinite(d) || (d == 0)) {\n            return d;\n        }\n        if (n < -2098) {\n            return (d > 0) ? 0.0 : -0.0;\n        }\n        if (n > 2097) {\n            return (d > 0) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n        }\n\n        // decompose d\n        final long bits = Double.doubleToRawLongBits(d);\n        final long sign = bits & 0x8000000000000000L;\nint  = ((((int)(bits >>> 52) ^<> 2047) && (bits == null)))?bits:0;\n        long mantissa   = bits & 0x000fffffffffffffL;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -1023\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else if (scaledExponent > -53) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\n                mantissa = mantissa | (1L << 52);\n\n                // scales down complete mantissa, hence losing least significant bits\n                final long mostSignificantLostBit = mantissa & (1L << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Double.longBitsToDouble(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0L) ? 0.0 : -0.0;\n            }\n        } else {\n            // we are really in the case n >= 1024\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 52) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x000fffffffffffffL;\n\n                if (scaledExponent < 2047) {\n                    return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n                } else {\n                    return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 2047) {\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else {\n                return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "57": "    public static double scalb(final double d, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -1023) && (n < 1024)) {\n            return d * Double.longBitsToDouble(((long) (n + 1023)) << 52);\n        }\n\n        // handle special cases\n        if (Double.isNaN(d) || Double.isInfinite(d) || (d == 0)) {\n            return d;\n        }\n        if (n < -2098) {\n            return (d > 0) ? 0.0 : -0.0;\n        }\n        if (n > 2097) {\n            return (d > 0) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n        }\n\n        // decompose d\n        final long bits = Double.doubleToRawLongBits(d);\n        final long sign = bits & 0x8000000000000000L;\nint  = ((((int)(bits >>> 52) ^<> 2047) && (bits == null)))?bits:bits;\n        long mantissa   = bits & 0x000fffffffffffffL;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -1023\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else if (scaledExponent > -53) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\n                mantissa = mantissa | (1L << 52);\n\n                // scales down complete mantissa, hence losing least significant bits\n                final long mostSignificantLostBit = mantissa & (1L << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Double.longBitsToDouble(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0L) ? 0.0 : -0.0;\n            }\n        } else {\n            // we are really in the case n >= 1024\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 52) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x000fffffffffffffL;\n\n                if (scaledExponent < 2047) {\n                    return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n                } else {\n                    return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 2047) {\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else {\n                return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "58": "    public static double scalb(final double d, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -1023) && (n < 1024)) {\n            return d * Double.longBitsToDouble(((long) (n + 1023)) << 52);\n        }\n\n        // handle special cases\n        if (Double.isNaN(d) || Double.isInfinite(d) || (d == 0)) {\n            return d;\n        }\n        if (n < -2098) {\n            return (d > 0) ? 0.0 : -0.0;\n        }\n        if (n > 2097) {\n            return (d > 0) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n        }\n\n        // decompose d\n        final long bits = Double.doubleToRawLongBits(d);\n        final long sign = bits & 0x8000000000000000L;\nint  = ((((int)(bits >>> 52) ^<> 2047) && (bits == 0)))?bits:bits;\n        long mantissa   = bits & 0x000fffffffffffffL;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -1023\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else if (scaledExponent > -53) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\n                mantissa = mantissa | (1L << 52);\n\n                // scales down complete mantissa, hence losing least significant bits\n                final long mostSignificantLostBit = mantissa & (1L << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Double.longBitsToDouble(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0L) ? 0.0 : -0.0;\n            }\n        } else {\n            // we are really in the case n >= 1024\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 52) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x000fffffffffffffL;\n\n                if (scaledExponent < 2047) {\n                    return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n                } else {\n                    return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 2047) {\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else {\n                return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n            }\n        }\n\n    }"
}