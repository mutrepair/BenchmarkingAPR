{
          "0": "    public static double acos(double x) {\n      if (x != x) {\n          return Double.NaN;\n      }\n\n      if (x > 1.0 || x < -1.0) {\n          return Double.NaN;\n      }\n\n      if (x == -1.0) {\n          return Math.PI;\n      }\n\n      if (x == 1.0) {\n          return 0.0;\n      }\n\n      if (x == 0) {\n          return Math.PI/2.0;\n      }\n\n      /* Compute acos(x) = atan(sqrt(1-x*x)/x) */\n\n      /* Split x */\n      double temp = x * HEX_40000000;\n      final double xa = x + temp - temp;\n      final double xb = x - xa;\n\n      /* Square it */\n      double ya = xa*xa;\n      double yb = xa*xb*2.0 + xb*xb;\n\n      /* Subtract from 1 */\n      ya = -ya;\n      yb = -yb;\n\n      double za = 1.0 + ya;\n      double zb = -(za - 1.0 - ya);\n\n      temp = za + yb;\nzb += (temp - za);\n      za = temp;\n\n      /* Square root */\n      double y = sqrt(za);\n      temp = y * HEX_40000000;\n      ya = y + temp - temp;\n      yb = y - ya;\n\n      /* Extend precision of sqrt */\n      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      /* Contribution of zb to sqrt */\n      yb += zb / (2.0*y);\n      y = ya+yb;\n      yb = -(y - ya - yb);\n\n      // Compute ratio r = y/x\n      double r = y/x;\n\n      // Did r overflow?\n      if (Double.isInfinite(r)) { // x is effectively zero\n          return Math.PI/2; // so return the appropriate value\n      }\n\n      double ra = doubleHighPart(r);\n      double rb = r - ra;\n\n      rb += (y - ra*xa - ra*xb - rb*xa - rb*xb) / x;  // Correct for rounding in division\n      rb += yb / x;  // Add in effect additional bits of sqrt.\n\n      temp = ra + rb;\n      rb = -(temp - ra - rb);\n      ra = temp;\n\n      return atan(ra, rb, x<0);\n    }",
          "1": "    public static double acos(double x) {\n      if (x != x) {\n          return Double.NaN;\n      }\n\n      if (x > 1.0 || x < -1.0) {\n          return Double.NaN;\n      }\n\n      if (x == -1.0) {\n          return Math.PI;\n      }\n\n      if (x == 1.0) {\n          return 0.0;\n      }\n\n      if (x == 0) {\n          return Math.PI/2.0;\n      }\n\n      /* Compute acos(x) = atan(sqrt(1-x*x)/x) */\n\n      /* Split x */\n      double temp = x * HEX_40000000;\n      final double xa = x + temp - temp;\n      final double xb = x - xa;\n\n      /* Square it */\n      double ya = xa*xa;\n      double yb = xa*xb*2.0 + xb*xb;\n\n      /* Subtract from 1 */\n      ya = -ya;\n      yb = -yb;\n\n      double za = 1.0 + ya;\n      double zb = -(za - 1.0 - ya);\n\n      temp = za + yb;\nzb += ((temp - za) >= yb);\n      za = temp;\n\n      /* Square root */\n      double y = sqrt(za);\n      temp = y * HEX_40000000;\n      ya = y + temp - temp;\n      yb = y - ya;\n\n      /* Extend precision of sqrt */\n      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      /* Contribution of zb to sqrt */\n      yb += zb / (2.0*y);\n      y = ya+yb;\n      yb = -(y - ya - yb);\n\n      // Compute ratio r = y/x\n      double r = y/x;\n\n      // Did r overflow?\n      if (Double.isInfinite(r)) { // x is effectively zero\n          return Math.PI/2; // so return the appropriate value\n      }\n\n      double ra = doubleHighPart(r);\n      double rb = r - ra;\n\n      rb += (y - ra*xa - ra*xb - rb*xa - rb*xb) / x;  // Correct for rounding in division\n      rb += yb / x;  // Add in effect additional bits of sqrt.\n\n      temp = ra + rb;\n      rb = -(temp - ra - rb);\n      ra = temp;\n\n      return atan(ra, rb, x<0);\n    }",
          "2": "    public static double acos(double x) {\n      if (x != x) {\n          return Double.NaN;\n      }\n\n      if (x > 1.0 || x < -1.0) {\n          return Double.NaN;\n      }\n\n      if (x == -1.0) {\n          return Math.PI;\n      }\n\n      if (x == 1.0) {\n          return 0.0;\n      }\n\n      if (x == 0) {\n          return Math.PI/2.0;\n      }\n\n      /* Compute acos(x) = atan(sqrt(1-x*x)/x) */\n\n      /* Split x */\n      double temp = x * HEX_40000000;\n      final double xa = x + temp - temp;\n      final double xb = x - xa;\n\n      /* Square it */\n      double ya = xa*xa;\n      double yb = xa*xb*2.0 + xb*xb;\n\n      /* Subtract from 1 */\n      ya = -ya;\n      yb = -yb;\n\n      double za = 1.0 + ya;\n      double zb = -(za - 1.0 - ya);\n\n      temp = za + yb;\nzb += ((temp - za) <= yb);\n      za = temp;\n\n      /* Square root */\n      double y = sqrt(za);\n      temp = y * HEX_40000000;\n      ya = y + temp - temp;\n      yb = y - ya;\n\n      /* Extend precision of sqrt */\n      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      /* Contribution of zb to sqrt */\n      yb += zb / (2.0*y);\n      y = ya+yb;\n      yb = -(y - ya - yb);\n\n      // Compute ratio r = y/x\n      double r = y/x;\n\n      // Did r overflow?\n      if (Double.isInfinite(r)) { // x is effectively zero\n          return Math.PI/2; // so return the appropriate value\n      }\n\n      double ra = doubleHighPart(r);\n      double rb = r - ra;\n\n      rb += (y - ra*xa - ra*xb - rb*xa - rb*xb) / x;  // Correct for rounding in division\n      rb += yb / x;  // Add in effect additional bits of sqrt.\n\n      temp = ra + rb;\n      rb = -(temp - ra - rb);\n      ra = temp;\n\n      return atan(ra, rb, x<0);\n    }",
          "3": "    public static double acos(double x) {\n      if (x != x) {\n          return Double.NaN;\n      }\n\n      if (x > 1.0 || x < -1.0) {\n          return Double.NaN;\n      }\n\n      if (x == -1.0) {\n          return Math.PI;\n      }\n\n      if (x == 1.0) {\n          return 0.0;\n      }\n\n      if (x == 0) {\n          return Math.PI/2.0;\n      }\n\n      /* Compute acos(x) = atan(sqrt(1-x*x)/x) */\n\n      /* Split x */\n      double temp = x * HEX_40000000;\n      final double xa = x + temp - temp;\n      final double xb = x - xa;\n\n      /* Square it */\n      double ya = xa*xa;\n      double yb = xa*xb*2.0 + xb*xb;\n\n      /* Subtract from 1 */\n      ya = -ya;\n      yb = -yb;\n\n      double za = 1.0 + ya;\n      double zb = -(za - 1.0 - ya);\n\n      temp = za + yb;\nzb += ((temp - za) > yb);\n      za = temp;\n\n      /* Square root */\n      double y = sqrt(za);\n      temp = y * HEX_40000000;\n      ya = y + temp - temp;\n      yb = y - ya;\n\n      /* Extend precision of sqrt */\n      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      /* Contribution of zb to sqrt */\n      yb += zb / (2.0*y);\n      y = ya+yb;\n      yb = -(y - ya - yb);\n\n      // Compute ratio r = y/x\n      double r = y/x;\n\n      // Did r overflow?\n      if (Double.isInfinite(r)) { // x is effectively zero\n          return Math.PI/2; // so return the appropriate value\n      }\n\n      double ra = doubleHighPart(r);\n      double rb = r - ra;\n\n      rb += (y - ra*xa - ra*xb - rb*xa - rb*xb) / x;  // Correct for rounding in division\n      rb += yb / x;  // Add in effect additional bits of sqrt.\n\n      temp = ra + rb;\n      rb = -(temp - ra - rb);\n      ra = temp;\n\n      return atan(ra, rb, x<0);\n    }",
          "4": "    public static double acos(double x) {\n      if (x != x) {\n          return Double.NaN;\n      }\n\n      if (x > 1.0 || x < -1.0) {\n          return Double.NaN;\n      }\n\n      if (x == -1.0) {\n          return Math.PI;\n      }\n\n      if (x == 1.0) {\n          return 0.0;\n      }\n\n      if (x == 0) {\n          return Math.PI/2.0;\n      }\n\n      /* Compute acos(x) = atan(sqrt(1-x*x)/x) */\n\n      /* Split x */\n      double temp = x * HEX_40000000;\n      final double xa = x + temp - temp;\n      final double xb = x - xa;\n\n      /* Square it */\n      double ya = xa*xa;\n      double yb = xa*xb*2.0 + xb*xb;\n\n      /* Subtract from 1 */\n      ya = -ya;\n      yb = -yb;\n\n      double za = 1.0 + ya;\n      double zb = -(za - 1.0 - ya);\n\n      temp = za + yb;\nzb += ((temp - za) - yb);\n      za = temp;\n\n      /* Square root */\n      double y = sqrt(za);\n      temp = y * HEX_40000000;\n      ya = y + temp - temp;\n      yb = y - ya;\n\n      /* Extend precision of sqrt */\n      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      /* Contribution of zb to sqrt */\n      yb += zb / (2.0*y);\n      y = ya+yb;\n      yb = -(y - ya - yb);\n\n      // Compute ratio r = y/x\n      double r = y/x;\n\n      // Did r overflow?\n      if (Double.isInfinite(r)) { // x is effectively zero\n          return Math.PI/2; // so return the appropriate value\n      }\n\n      double ra = doubleHighPart(r);\n      double rb = r - ra;\n\n      rb += (y - ra*xa - ra*xb - rb*xa - rb*xb) / x;  // Correct for rounding in division\n      rb += yb / x;  // Add in effect additional bits of sqrt.\n\n      temp = ra + rb;\n      rb = -(temp - ra - rb);\n      ra = temp;\n\n      return atan(ra, rb, x<0);\n    }",
          "5": "    public static double acos(double x) {\n      if (x != x) {\n          return Double.NaN;\n      }\n\n      if (x > 1.0 || x < -1.0) {\n          return Double.NaN;\n      }\n\n      if (x == -1.0) {\n          return Math.PI;\n      }\n\n      if (x == 1.0) {\n          return 0.0;\n      }\n\n      if (x == 0) {\n          return Math.PI/2.0;\n      }\n\n      /* Compute acos(x) = atan(sqrt(1-x*x)/x) */\n\n      /* Split x */\n      double temp = x * HEX_40000000;\n      final double xa = x + temp - temp;\n      final double xb = x - xa;\n\n      /* Square it */\n      double ya = xa*xa;\n      double yb = xa*xb*2.0 + xb*xb;\n\n      /* Subtract from 1 */\n      ya = -ya;\n      yb = -yb;\n\n      double za = 1.0 + ya;\n      double zb = -(za - 1.0 - ya);\n\n      temp = za + yb;\nzb = (temp - za);\n      za = temp;\n\n      /* Square root */\n      double y = sqrt(za);\n      temp = y * HEX_40000000;\n      ya = y + temp - temp;\n      yb = y - ya;\n\n      /* Extend precision of sqrt */\n      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      /* Contribution of zb to sqrt */\n      yb += zb / (2.0*y);\n      y = ya+yb;\n      yb = -(y - ya - yb);\n\n      // Compute ratio r = y/x\n      double r = y/x;\n\n      // Did r overflow?\n      if (Double.isInfinite(r)) { // x is effectively zero\n          return Math.PI/2; // so return the appropriate value\n      }\n\n      double ra = doubleHighPart(r);\n      double rb = r - ra;\n\n      rb += (y - ra*xa - ra*xb - rb*xa - rb*xb) / x;  // Correct for rounding in division\n      rb += yb / x;  // Add in effect additional bits of sqrt.\n\n      temp = ra + rb;\n      rb = -(temp - ra - rb);\n      ra = temp;\n\n      return atan(ra, rb, x<0);\n    }",
          "6": "    public static double acos(double x) {\n      if (x != x) {\n          return Double.NaN;\n      }\n\n      if (x > 1.0 || x < -1.0) {\n          return Double.NaN;\n      }\n\n      if (x == -1.0) {\n          return Math.PI;\n      }\n\n      if (x == 1.0) {\n          return 0.0;\n      }\n\n      if (x == 0) {\n          return Math.PI/2.0;\n      }\n\n      /* Compute acos(x) = atan(sqrt(1-x*x)/x) */\n\n      /* Split x */\n      double temp = x * HEX_40000000;\n      final double xa = x + temp - temp;\n      final double xb = x - xa;\n\n      /* Square it */\n      double ya = xa*xa;\n      double yb = xa*xb*2.0 + xb*xb;\n\n      /* Subtract from 1 */\n      ya = -ya;\n      yb = -yb;\n\n      double za = 1.0 + ya;\n      double zb = -(za - 1.0 - ya);\n\n      temp = za + yb;\n      za = temp;\n\n      /* Square root */\n      double y = sqrt(za);\n      temp = y * HEX_40000000;\n      ya = y + temp - temp;\n      yb = y - ya;\n\n      /* Extend precision of sqrt */\n      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      /* Contribution of zb to sqrt */\n      yb += zb / (2.0*y);\n      y = ya+yb;\n      yb = -(y - ya - yb);\n\n      // Compute ratio r = y/x\n      double r = y/x;\n\n      // Did r overflow?\n      if (Double.isInfinite(r)) { // x is effectively zero\n          return Math.PI/2; // so return the appropriate value\n      }\n\n      double ra = doubleHighPart(r);\n      double rb = r - ra;\n\n      rb += (y - ra*xa - ra*xb - rb*xa - rb*xb) / x;  // Correct for rounding in division\n      rb += yb / x;  // Add in effect additional bits of sqrt.\n\n      temp = ra + rb;\n      rb = -(temp - ra - rb);\n      ra = temp;\n\n      return atan(ra, rb, x<0);\n    }",
          "7": "    public static double acos(double x) {\n      if (x != x) {\n          return Double.NaN;\n      }\n\n      if (x > 1.0 || x < -1.0) {\n          return Double.NaN;\n      }\n\n      if (x == -1.0) {\n          return Math.PI;\n      }\n\n      if (x == 1.0) {\n          return 0.0;\n      }\n\n      if (x == 0) {\n          return Math.PI/2.0;\n      }\n\n      /* Compute acos(x) = atan(sqrt(1-x*x)/x) */\n\n      /* Split x */\n      double temp = x * HEX_40000000;\n      final double xa = x + temp - temp;\n      final double xb = x - xa;\n\n      /* Square it */\n      double ya = xa*xa;\n      double yb = xa*xb*2.0 + xb*xb;\n\n      /* Subtract from 1 */\n      ya = -ya;\n      yb = -yb;\n\n      double za = 1.0 + ya;\n      double zb = -(za - 1.0 - ya);\n\n      temp = za + yb;\nzb += ((temp - za) == yb);\n      za = temp;\n\n      /* Square root */\n      double y = sqrt(za);\n      temp = y * HEX_40000000;\n      ya = y + temp - temp;\n      yb = y - ya;\n\n      /* Extend precision of sqrt */\n      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      /* Contribution of zb to sqrt */\n      yb += zb / (2.0*y);\n      y = ya+yb;\n      yb = -(y - ya - yb);\n\n      // Compute ratio r = y/x\n      double r = y/x;\n\n      // Did r overflow?\n      if (Double.isInfinite(r)) { // x is effectively zero\n          return Math.PI/2; // so return the appropriate value\n      }\n\n      double ra = doubleHighPart(r);\n      double rb = r - ra;\n\n      rb += (y - ra*xa - ra*xb - rb*xa - rb*xb) / x;  // Correct for rounding in division\n      rb += yb / x;  // Add in effect additional bits of sqrt.\n\n      temp = ra + rb;\n      rb = -(temp - ra - rb);\n      ra = temp;\n\n      return atan(ra, rb, x<0);\n    }",
          "8": "    public static double acos(double x) {\n      if (x != x) {\n          return Double.NaN;\n      }\n\n      if (x > 1.0 || x < -1.0) {\n          return Double.NaN;\n      }\n\n      if (x == -1.0) {\n          return Math.PI;\n      }\n\n      if (x == 1.0) {\n          return 0.0;\n      }\n\n      if (x == 0) {\n          return Math.PI/2.0;\n      }\n\n      /* Compute acos(x) = atan(sqrt(1-x*x)/x) */\n\n      /* Split x */\n      double temp = x * HEX_40000000;\n      final double xa = x + temp - temp;\n      final double xb = x - xa;\n\n      /* Square it */\n      double ya = xa*xa;\n      double yb = xa*xb*2.0 + xb*xb;\n\n      /* Subtract from 1 */\n      ya = -ya;\n      yb = -yb;\n\n      double za = 1.0 + ya;\n      double zb = -(za - 1.0 - ya);\n\n      temp = za + yb;\nzb = ((temp - za) - yb);\n      za = temp;\n\n      /* Square root */\n      double y = sqrt(za);\n      temp = y * HEX_40000000;\n      ya = y + temp - temp;\n      yb = y - ya;\n\n      /* Extend precision of sqrt */\n      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      /* Contribution of zb to sqrt */\n      yb += zb / (2.0*y);\n      y = ya+yb;\n      yb = -(y - ya - yb);\n\n      // Compute ratio r = y/x\n      double r = y/x;\n\n      // Did r overflow?\n      if (Double.isInfinite(r)) { // x is effectively zero\n          return Math.PI/2; // so return the appropriate value\n      }\n\n      double ra = doubleHighPart(r);\n      double rb = r - ra;\n\n      rb += (y - ra*xa - ra*xb - rb*xa - rb*xb) / x;  // Correct for rounding in division\n      rb += yb / x;  // Add in effect additional bits of sqrt.\n\n      temp = ra + rb;\n      rb = -(temp - ra - rb);\n      ra = temp;\n\n      return atan(ra, rb, x<0);\n    }",
          "9": "    public static double acos(double x) {\n      if (x != x) {\n          return Double.NaN;\n      }\n\n      if (x > 1.0 || x < -1.0) {\n          return Double.NaN;\n      }\n\n      if (x == -1.0) {\n          return Math.PI;\n      }\n\n      if (x == 1.0) {\n          return 0.0;\n      }\n\n      if (x == 0) {\n          return Math.PI/2.0;\n      }\n\n      /* Compute acos(x) = atan(sqrt(1-x*x)/x) */\n\n      /* Split x */\n      double temp = x * HEX_40000000;\n      final double xa = x + temp - temp;\n      final double xb = x - xa;\n\n      /* Square it */\n      double ya = xa*xa;\n      double yb = xa*xb*2.0 + xb*xb;\n\n      /* Subtract from 1 */\n      ya = -ya;\n      yb = -yb;\n\n      double za = 1.0 + ya;\n      double zb = -(za - 1.0 - ya);\n\n      temp = za + yb;\nzb -= (temp - za);\n      za = temp;\n\n      /* Square root */\n      double y = sqrt(za);\n      temp = y * HEX_40000000;\n      ya = y + temp - temp;\n      yb = y - ya;\n\n      /* Extend precision of sqrt */\n      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      /* Contribution of zb to sqrt */\n      yb += zb / (2.0*y);\n      y = ya+yb;\n      yb = -(y - ya - yb);\n\n      // Compute ratio r = y/x\n      double r = y/x;\n\n      // Did r overflow?\n      if (Double.isInfinite(r)) { // x is effectively zero\n          return Math.PI/2; // so return the appropriate value\n      }\n\n      double ra = doubleHighPart(r);\n      double rb = r - ra;\n\n      rb += (y - ra*xa - ra*xb - rb*xa - rb*xb) / x;  // Correct for rounding in division\n      rb += yb / x;  // Add in effect additional bits of sqrt.\n\n      temp = ra + rb;\n      rb = -(temp - ra - rb);\n      ra = temp;\n\n      return atan(ra, rb, x<0);\n    }",
          "10": "    public static double acos(double x) {\n      if (x != x) {\n          return Double.NaN;\n      }\n\n      if (x > 1.0 || x < -1.0) {\n          return Double.NaN;\n      }\n\n      if (x == -1.0) {\n          return Math.PI;\n      }\n\n      if (x == 1.0) {\n          return 0.0;\n      }\n\n      if (x == 0) {\n          return Math.PI/2.0;\n      }\n\n      /* Compute acos(x) = atan(sqrt(1-x*x)/x) */\n\n      /* Split x */\n      double temp = x * HEX_40000000;\n      final double xa = x + temp - temp;\n      final double xb = x - xa;\n\n      /* Square it */\n      double ya = xa*xa;\n      double yb = xa*xb*2.0 + xb*xb;\n\n      /* Subtract from 1 */\n      ya = -ya;\n      yb = -yb;\n\n      double za = 1.0 + ya;\n      double zb = -(za - 1.0 - ya);\n\n      temp = za + yb;\nzb += ((temp - za) != yb);\n      za = temp;\n\n      /* Square root */\n      double y = sqrt(za);\n      temp = y * HEX_40000000;\n      ya = y + temp - temp;\n      yb = y - ya;\n\n      /* Extend precision of sqrt */\n      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      /* Contribution of zb to sqrt */\n      yb += zb / (2.0*y);\n      y = ya+yb;\n      yb = -(y - ya - yb);\n\n      // Compute ratio r = y/x\n      double r = y/x;\n\n      // Did r overflow?\n      if (Double.isInfinite(r)) { // x is effectively zero\n          return Math.PI/2; // so return the appropriate value\n      }\n\n      double ra = doubleHighPart(r);\n      double rb = r - ra;\n\n      rb += (y - ra*xa - ra*xb - rb*xa - rb*xb) / x;  // Correct for rounding in division\n      rb += yb / x;  // Add in effect additional bits of sqrt.\n\n      temp = ra + rb;\n      rb = -(temp - ra - rb);\n      ra = temp;\n\n      return atan(ra, rb, x<0);\n    }",
          "11": "    public static double acos(double x) {\n      if (x != x) {\n          return Double.NaN;\n      }\n\n      if (x > 1.0 || x < -1.0) {\n          return Double.NaN;\n      }\n\n      if (x == -1.0) {\n          return Math.PI;\n      }\n\n      if (x == 1.0) {\n          return 0.0;\n      }\n\n      if (x == 0) {\n          return Math.PI/2.0;\n      }\n\n      /* Compute acos(x) = atan(sqrt(1-x*x)/x) */\n\n      /* Split x */\n      double temp = x * HEX_40000000;\n      final double xa = x + temp - temp;\n      final double xb = x - xa;\n\n      /* Square it */\n      double ya = xa*xa;\n      double yb = xa*xb*2.0 + xb*xb;\n\n      /* Subtract from 1 */\n      ya = -ya;\n      yb = -yb;\n\n      double za = 1.0 + ya;\n      double zb = -(za - 1.0 - ya);\n\n      temp = za + yb;\nzb += ((temp - za) + yb);\n      za = temp;\n\n      /* Square root */\n      double y = sqrt(za);\n      temp = y * HEX_40000000;\n      ya = y + temp - temp;\n      yb = y - ya;\n\n      /* Extend precision of sqrt */\n      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      /* Contribution of zb to sqrt */\n      yb += zb / (2.0*y);\n      y = ya+yb;\n      yb = -(y - ya - yb);\n\n      // Compute ratio r = y/x\n      double r = y/x;\n\n      // Did r overflow?\n      if (Double.isInfinite(r)) { // x is effectively zero\n          return Math.PI/2; // so return the appropriate value\n      }\n\n      double ra = doubleHighPart(r);\n      double rb = r - ra;\n\n      rb += (y - ra*xa - ra*xb - rb*xa - rb*xb) / x;  // Correct for rounding in division\n      rb += yb / x;  // Add in effect additional bits of sqrt.\n\n      temp = ra + rb;\n      rb = -(temp - ra - rb);\n      ra = temp;\n\n      return atan(ra, rb, x<0);\n    }",
          "12": "    public static double acos(double x) {\n      if (x != x) {\n          return Double.NaN;\n      }\n\n      if (x > 1.0 || x < -1.0) {\n          return Double.NaN;\n      }\n\n      if (x == -1.0) {\n          return Math.PI;\n      }\n\n      if (x == 1.0) {\n          return 0.0;\n      }\n\n      if (x == 0) {\n          return Math.PI/2.0;\n      }\n\n      /* Compute acos(x) = atan(sqrt(1-x*x)/x) */\n\n      /* Split x */\n      double temp = x * HEX_40000000;\n      final double xa = x + temp - temp;\n      final double xb = x - xa;\n\n      /* Square it */\n      double ya = xa*xa;\n      double yb = xa*xb*2.0 + xb*xb;\n\n      /* Subtract from 1 */\n      ya = -ya;\n      yb = -yb;\n\n      double za = 1.0 + ya;\n      double zb = -(za - 1.0 - ya);\n\n      temp = za + yb;\nzb *= (temp - za);\n      za = temp;\n\n      /* Square root */\n      double y = sqrt(za);\n      temp = y * HEX_40000000;\n      ya = y + temp - temp;\n      yb = y - ya;\n\n      /* Extend precision of sqrt */\n      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      /* Contribution of zb to sqrt */\n      yb += zb / (2.0*y);\n      y = ya+yb;\n      yb = -(y - ya - yb);\n\n      // Compute ratio r = y/x\n      double r = y/x;\n\n      // Did r overflow?\n      if (Double.isInfinite(r)) { // x is effectively zero\n          return Math.PI/2; // so return the appropriate value\n      }\n\n      double ra = doubleHighPart(r);\n      double rb = r - ra;\n\n      rb += (y - ra*xa - ra*xb - rb*xa - rb*xb) / x;  // Correct for rounding in division\n      rb += yb / x;  // Add in effect additional bits of sqrt.\n\n      temp = ra + rb;\n      rb = -(temp - ra - rb);\n      ra = temp;\n\n      return atan(ra, rb, x<0);\n    }",
          "13": "    public static double acos(double x) {\n      if (x != x) {\n          return Double.NaN;\n      }\n\n      if (x > 1.0 || x < -1.0) {\n          return Double.NaN;\n      }\n\n      if (x == -1.0) {\n          return Math.PI;\n      }\n\n      if (x == 1.0) {\n          return 0.0;\n      }\n\n      if (x == 0) {\n          return Math.PI/2.0;\n      }\n\n      /* Compute acos(x) = atan(sqrt(1-x*x)/x) */\n\n      /* Split x */\n      double temp = x * HEX_40000000;\n      final double xa = x + temp - temp;\n      final double xb = x - xa;\n\n      /* Square it */\n      double ya = xa*xa;\n      double yb = xa*xb*2.0 + xb*xb;\n\n      /* Subtract from 1 */\n      ya = -ya;\n      yb = -yb;\n\n      double za = 1.0 + ya;\n      double zb = -(za - 1.0 - ya);\n\n      temp = za + yb;\nzb -= ((temp - za) - yb);\n      za = temp;\n\n      /* Square root */\n      double y = sqrt(za);\n      temp = y * HEX_40000000;\n      ya = y + temp - temp;\n      yb = y - ya;\n\n      /* Extend precision of sqrt */\n      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      /* Contribution of zb to sqrt */\n      yb += zb / (2.0*y);\n      y = ya+yb;\n      yb = -(y - ya - yb);\n\n      // Compute ratio r = y/x\n      double r = y/x;\n\n      // Did r overflow?\n      if (Double.isInfinite(r)) { // x is effectively zero\n          return Math.PI/2; // so return the appropriate value\n      }\n\n      double ra = doubleHighPart(r);\n      double rb = r - ra;\n\n      rb += (y - ra*xa - ra*xb - rb*xa - rb*xb) / x;  // Correct for rounding in division\n      rb += yb / x;  // Add in effect additional bits of sqrt.\n\n      temp = ra + rb;\n      rb = -(temp - ra - rb);\n      ra = temp;\n\n      return atan(ra, rb, x<0);\n    }",
          "14": "    public static double acos(double x) {\n      if (x != x) {\n          return Double.NaN;\n      }\n\n      if (x > 1.0 || x < -1.0) {\n          return Double.NaN;\n      }\n\n      if (x == -1.0) {\n          return Math.PI;\n      }\n\n      if (x == 1.0) {\n          return 0.0;\n      }\n\n      if (x == 0) {\n          return Math.PI/2.0;\n      }\n\n      /* Compute acos(x) = atan(sqrt(1-x*x)/x) */\n\n      /* Split x */\n      double temp = x * HEX_40000000;\n      final double xa = x + temp - temp;\n      final double xb = x - xa;\n\n      /* Square it */\n      double ya = xa*xa;\n      double yb = xa*xb*2.0 + xb*xb;\n\n      /* Subtract from 1 */\n      ya = -ya;\n      yb = -yb;\n\n      double za = 1.0 + ya;\n      double zb = -(za - 1.0 - ya);\n\n      temp = za + yb;\nzb += ((temp - za) < yb);\n      za = temp;\n\n      /* Square root */\n      double y = sqrt(za);\n      temp = y * HEX_40000000;\n      ya = y + temp - temp;\n      yb = y - ya;\n\n      /* Extend precision of sqrt */\n      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      /* Contribution of zb to sqrt */\n      yb += zb / (2.0*y);\n      y = ya+yb;\n      yb = -(y - ya - yb);\n\n      // Compute ratio r = y/x\n      double r = y/x;\n\n      // Did r overflow?\n      if (Double.isInfinite(r)) { // x is effectively zero\n          return Math.PI/2; // so return the appropriate value\n      }\n\n      double ra = doubleHighPart(r);\n      double rb = r - ra;\n\n      rb += (y - ra*xa - ra*xb - rb*xa - rb*xb) / x;  // Correct for rounding in division\n      rb += yb / x;  // Add in effect additional bits of sqrt.\n\n      temp = ra + rb;\n      rb = -(temp - ra - rb);\n      ra = temp;\n\n      return atan(ra, rb, x<0);\n    }",
          "15": "    public static double acos(double x) {\n      if (x != x) {\n          return Double.NaN;\n      }\n\n      if (x > 1.0 || x < -1.0) {\n          return Double.NaN;\n      }\n\n      if (x == -1.0) {\n          return Math.PI;\n      }\n\n      if (x == 1.0) {\n          return 0.0;\n      }\n\n      if (x == 0) {\n          return Math.PI/2.0;\n      }\n\n      /* Compute acos(x) = atan(sqrt(1-x*x)/x) */\n\n      /* Split x */\n      double temp = x * HEX_40000000;\n      final double xa = x + temp - temp;\n      final double xb = x - xa;\n\n      /* Square it */\n      double ya = xa*xa;\n      double yb = xa*xb*2.0 + xb*xb;\n\n      /* Subtract from 1 */\n      ya = -ya;\n      yb = -yb;\n\n      double za = 1.0 + ya;\n      double zb = -(za - 1.0 - ya);\n\n      temp = za + yb;\nzb;\n      za = temp;\n\n      /* Square root */\n      double y = sqrt(za);\n      temp = y * HEX_40000000;\n      ya = y + temp - temp;\n      yb = y - ya;\n\n      /* Extend precision of sqrt */\n      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      /* Contribution of zb to sqrt */\n      yb += zb / (2.0*y);\n      y = ya+yb;\n      yb = -(y - ya - yb);\n\n      // Compute ratio r = y/x\n      double r = y/x;\n\n      // Did r overflow?\n      if (Double.isInfinite(r)) { // x is effectively zero\n          return Math.PI/2; // so return the appropriate value\n      }\n\n      double ra = doubleHighPart(r);\n      double rb = r - ra;\n\n      rb += (y - ra*xa - ra*xb - rb*xa - rb*xb) / x;  // Correct for rounding in division\n      rb += yb / x;  // Add in effect additional bits of sqrt.\n\n      temp = ra + rb;\n      rb = -(temp - ra - rb);\n      ra = temp;\n\n      return atan(ra, rb, x<0);\n    }",
          "16": "    public static double acos(double x) {\n      if (x != x) {\n          return Double.NaN;\n      }\n\n      if (x > 1.0 || x < -1.0) {\n          return Double.NaN;\n      }\n\n      if (x == -1.0) {\n          return Math.PI;\n      }\n\n      if (x == 1.0) {\n          return 0.0;\n      }\n\n      if (x == 0) {\n          return Math.PI/2.0;\n      }\n\n      /* Compute acos(x) = atan(sqrt(1-x*x)/x) */\n\n      /* Split x */\n      double temp = x * HEX_40000000;\n      final double xa = x + temp - temp;\n      final double xb = x - xa;\n\n      /* Square it */\n      double ya = xa*xa;\n      double yb = xa*xb*2.0 + xb*xb;\n\n      /* Subtract from 1 */\n      ya = -ya;\n      yb = -yb;\n\n      double za = 1.0 + ya;\n      double zb = -(za - 1.0 - ya);\n\n      temp = za + yb;\nzb += ((temp - temp) - yb);\n      za = temp;\n\n      /* Square root */\n      double y = sqrt(za);\n      temp = y * HEX_40000000;\n      ya = y + temp - temp;\n      yb = y - ya;\n\n      /* Extend precision of sqrt */\n      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      /* Contribution of zb to sqrt */\n      yb += zb / (2.0*y);\n      y = ya+yb;\n      yb = -(y - ya - yb);\n\n      // Compute ratio r = y/x\n      double r = y/x;\n\n      // Did r overflow?\n      if (Double.isInfinite(r)) { // x is effectively zero\n          return Math.PI/2; // so return the appropriate value\n      }\n\n      double ra = doubleHighPart(r);\n      double rb = r - ra;\n\n      rb += (y - ra*xa - ra*xb - rb*xa - rb*xb) / x;  // Correct for rounding in division\n      rb += yb / x;  // Add in effect additional bits of sqrt.\n\n      temp = ra + rb;\n      rb = -(temp - ra - rb);\n      ra = temp;\n\n      return atan(ra, rb, x<0);\n    }",
          "17": "    public static double acos(double x) {\n      if (x != x) {\n          return Double.NaN;\n      }\n\n      if (x > 1.0 || x < -1.0) {\n          return Double.NaN;\n      }\n\n      if (x == -1.0) {\n          return Math.PI;\n      }\n\n      if (x == 1.0) {\n          return 0.0;\n      }\n\n      if (x == 0) {\n          return Math.PI/2.0;\n      }\n\n      /* Compute acos(x) = atan(sqrt(1-x*x)/x) */\n\n      /* Split x */\n      double temp = x * HEX_40000000;\n      final double xa = x + temp - temp;\n      final double xb = x - xa;\n\n      /* Square it */\n      double ya = xa*xa;\n      double yb = xa*xb*2.0 + xb*xb;\n\n      /* Subtract from 1 */\n      ya = -ya;\n      yb = -yb;\n\n      double za = 1.0 + ya;\n      double zb = -(za - 1.0 - ya);\n\n      temp = za + yb;\nzb += ((temp - za) - temp);\n      za = temp;\n\n      /* Square root */\n      double y = sqrt(za);\n      temp = y * HEX_40000000;\n      ya = y + temp - temp;\n      yb = y - ya;\n\n      /* Extend precision of sqrt */\n      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      /* Contribution of zb to sqrt */\n      yb += zb / (2.0*y);\n      y = ya+yb;\n      yb = -(y - ya - yb);\n\n      // Compute ratio r = y/x\n      double r = y/x;\n\n      // Did r overflow?\n      if (Double.isInfinite(r)) { // x is effectively zero\n          return Math.PI/2; // so return the appropriate value\n      }\n\n      double ra = doubleHighPart(r);\n      double rb = r - ra;\n\n      rb += (y - ra*xa - ra*xb - rb*xa - rb*xb) / x;  // Correct for rounding in division\n      rb += yb / x;  // Add in effect additional bits of sqrt.\n\n      temp = ra + rb;\n      rb = -(temp - ra - rb);\n      ra = temp;\n\n      return atan(ra, rb, x<0);\n    }",
          "18": "    public static double acos(double x) {\n      if (x != x) {\n          return Double.NaN;\n      }\n\n      if (x > 1.0 || x < -1.0) {\n          return Double.NaN;\n      }\n\n      if (x == -1.0) {\n          return Math.PI;\n      }\n\n      if (x == 1.0) {\n          return 0.0;\n      }\n\n      if (x == 0) {\n          return Math.PI/2.0;\n      }\n\n      /* Compute acos(x) = atan(sqrt(1-x*x)/x) */\n\n      /* Split x */\n      double temp = x * HEX_40000000;\n      final double xa = x + temp - temp;\n      final double xb = x - xa;\n\n      /* Square it */\n      double ya = xa*xa;\n      double yb = xa*xb*2.0 + xb*xb;\n\n      /* Subtract from 1 */\n      ya = -ya;\n      yb = -yb;\n\n      double za = 1.0 + ya;\n      double zb = -(za - 1.0 - ya);\n\n      temp = za + yb;\nyb;\n      za = temp;\n\n      /* Square root */\n      double y = sqrt(za);\n      temp = y * HEX_40000000;\n      ya = y + temp - temp;\n      yb = y - ya;\n\n      /* Extend precision of sqrt */\n      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      /* Contribution of zb to sqrt */\n      yb += zb / (2.0*y);\n      y = ya+yb;\n      yb = -(y - ya - yb);\n\n      // Compute ratio r = y/x\n      double r = y/x;\n\n      // Did r overflow?\n      if (Double.isInfinite(r)) { // x is effectively zero\n          return Math.PI/2; // so return the appropriate value\n      }\n\n      double ra = doubleHighPart(r);\n      double rb = r - ra;\n\n      rb += (y - ra*xa - ra*xb - rb*xa - rb*xb) / x;  // Correct for rounding in division\n      rb += yb / x;  // Add in effect additional bits of sqrt.\n\n      temp = ra + rb;\n      rb = -(temp - ra - rb);\n      ra = temp;\n\n      return atan(ra, rb, x<0);\n    }",
          "19": "    public static double acos(double x) {\n      if (x != x) {\n          return Double.NaN;\n      }\n\n      if (x > 1.0 || x < -1.0) {\n          return Double.NaN;\n      }\n\n      if (x == -1.0) {\n          return Math.PI;\n      }\n\n      if (x == 1.0) {\n          return 0.0;\n      }\n\n      if (x == 0) {\n          return Math.PI/2.0;\n      }\n\n      /* Compute acos(x) = atan(sqrt(1-x*x)/x) */\n\n      /* Split x */\n      double temp = x * HEX_40000000;\n      final double xa = x + temp - temp;\n      final double xb = x - xa;\n\n      /* Square it */\n      double ya = xa*xa;\n      double yb = xa*xb*2.0 + xb*xb;\n\n      /* Subtract from 1 */\n      ya = -ya;\n      yb = -yb;\n\n      double za = 1.0 + ya;\n      double zb = -(za - 1.0 - ya);\n\n      temp = za + yb;\nza = temp;\n      za = temp;\n\n      /* Square root */\n      double y = sqrt(za);\n      temp = y * HEX_40000000;\n      ya = y + temp - temp;\n      yb = y - ya;\n\n      /* Extend precision of sqrt */\n      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      /* Contribution of zb to sqrt */\n      yb += zb / (2.0*y);\n      y = ya+yb;\n      yb = -(y - ya - yb);\n\n      // Compute ratio r = y/x\n      double r = y/x;\n\n      // Did r overflow?\n      if (Double.isInfinite(r)) { // x is effectively zero\n          return Math.PI/2; // so return the appropriate value\n      }\n\n      double ra = doubleHighPart(r);\n      double rb = r - ra;\n\n      rb += (y - ra*xa - ra*xb - rb*xa - rb*xb) / x;  // Correct for rounding in division\n      rb += yb / x;  // Add in effect additional bits of sqrt.\n\n      temp = ra + rb;\n      rb = -(temp - ra - rb);\n      ra = temp;\n\n      return atan(ra, rb, x<0);\n    }",
          "20": "    public static double acos(double x) {\n      if (x != x) {\n          return Double.NaN;\n      }\n\n      if (x > 1.0 || x < -1.0) {\n          return Double.NaN;\n      }\n\n      if (x == -1.0) {\n          return Math.PI;\n      }\n\n      if (x == 1.0) {\n          return 0.0;\n      }\n\n      if (x == 0) {\n          return Math.PI/2.0;\n      }\n\n      /* Compute acos(x) = atan(sqrt(1-x*x)/x) */\n\n      /* Split x */\n      double temp = x * HEX_40000000;\n      final double xa = x + temp - temp;\n      final double xb = x - xa;\n\n      /* Square it */\n      double ya = xa*xa;\n      double yb = xa*xb*2.0 + xb*xb;\n\n      /* Subtract from 1 */\n      ya = -ya;\n      yb = -yb;\n\n      double za = 1.0 + ya;\n      double zb = -(za - 1.0 - ya);\n\n      temp = za + yb;\nzb += ((temp - za) - za);\n      za = temp;\n\n      /* Square root */\n      double y = sqrt(za);\n      temp = y * HEX_40000000;\n      ya = y + temp - temp;\n      yb = y - ya;\n\n      /* Extend precision of sqrt */\n      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      /* Contribution of zb to sqrt */\n      yb += zb / (2.0*y);\n      y = ya+yb;\n      yb = -(y - ya - yb);\n\n      // Compute ratio r = y/x\n      double r = y/x;\n\n      // Did r overflow?\n      if (Double.isInfinite(r)) { // x is effectively zero\n          return Math.PI/2; // so return the appropriate value\n      }\n\n      double ra = doubleHighPart(r);\n      double rb = r - ra;\n\n      rb += (y - ra*xa - ra*xb - rb*xa - rb*xb) / x;  // Correct for rounding in division\n      rb += yb / x;  // Add in effect additional bits of sqrt.\n\n      temp = ra + rb;\n      rb = -(temp - ra - rb);\n      ra = temp;\n\n      return atan(ra, rb, x<0);\n    }",
          "21": "    public static double acos(double x) {\n      if (x != x) {\n          return Double.NaN;\n      }\n\n      if (x > 1.0 || x < -1.0) {\n          return Double.NaN;\n      }\n\n      if (x == -1.0) {\n          return Math.PI;\n      }\n\n      if (x == 1.0) {\n          return 0.0;\n      }\n\n      if (x == 0) {\n          return Math.PI/2.0;\n      }\n\n      /* Compute acos(x) = atan(sqrt(1-x*x)/x) */\n\n      /* Split x */\n      double temp = x * HEX_40000000;\n      final double xa = x + temp - temp;\n      final double xb = x - xa;\n\n      /* Square it */\n      double ya = xa*xa;\n      double yb = xa*xb*2.0 + xb*xb;\n\n      /* Subtract from 1 */\n      ya = -ya;\n      yb = -yb;\n\n      double za = 1.0 + ya;\n      double zb = -(za - 1.0 - ya);\n\n      temp = za + yb;\ntemp = (za + yb);\n      za = temp;\n\n      /* Square root */\n      double y = sqrt(za);\n      temp = y * HEX_40000000;\n      ya = y + temp - temp;\n      yb = y - ya;\n\n      /* Extend precision of sqrt */\n      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      /* Contribution of zb to sqrt */\n      yb += zb / (2.0*y);\n      y = ya+yb;\n      yb = -(y - ya - yb);\n\n      // Compute ratio r = y/x\n      double r = y/x;\n\n      // Did r overflow?\n      if (Double.isInfinite(r)) { // x is effectively zero\n          return Math.PI/2; // so return the appropriate value\n      }\n\n      double ra = doubleHighPart(r);\n      double rb = r - ra;\n\n      rb += (y - ra*xa - ra*xb - rb*xa - rb*xb) / x;  // Correct for rounding in division\n      rb += yb / x;  // Add in effect additional bits of sqrt.\n\n      temp = ra + rb;\n      rb = -(temp - ra - rb);\n      ra = temp;\n\n      return atan(ra, rb, x<0);\n    }",
          "22": "    public static double acos(double x) {\n      if (x != x) {\n          return Double.NaN;\n      }\n\n      if (x > 1.0 || x < -1.0) {\n          return Double.NaN;\n      }\n\n      if (x == -1.0) {\n          return Math.PI;\n      }\n\n      if (x == 1.0) {\n          return 0.0;\n      }\n\n      if (x == 0) {\n          return Math.PI/2.0;\n      }\n\n      /* Compute acos(x) = atan(sqrt(1-x*x)/x) */\n\n      /* Split x */\n      double temp = x * HEX_40000000;\n      final double xa = x + temp - temp;\n      final double xb = x - xa;\n\n      /* Square it */\n      double ya = xa*xa;\n      double yb = xa*xb*2.0 + xb*xb;\n\n      /* Subtract from 1 */\n      ya = -ya;\n      yb = -yb;\n\n      double za = 1.0 + ya;\n      double zb = -(za - 1.0 - ya);\n\n      temp = za + yb;\nzb += ((temp - yb) - yb);\n      za = temp;\n\n      /* Square root */\n      double y = sqrt(za);\n      temp = y * HEX_40000000;\n      ya = y + temp - temp;\n      yb = y - ya;\n\n      /* Extend precision of sqrt */\n      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      /* Contribution of zb to sqrt */\n      yb += zb / (2.0*y);\n      y = ya+yb;\n      yb = -(y - ya - yb);\n\n      // Compute ratio r = y/x\n      double r = y/x;\n\n      // Did r overflow?\n      if (Double.isInfinite(r)) { // x is effectively zero\n          return Math.PI/2; // so return the appropriate value\n      }\n\n      double ra = doubleHighPart(r);\n      double rb = r - ra;\n\n      rb += (y - ra*xa - ra*xb - rb*xa - rb*xb) / x;  // Correct for rounding in division\n      rb += yb / x;  // Add in effect additional bits of sqrt.\n\n      temp = ra + rb;\n      rb = -(temp - ra - rb);\n      ra = temp;\n\n      return atan(ra, rb, x<0);\n    }",
          "23": "    public static double acos(double x) {\n      if (x != x) {\n          return Double.NaN;\n      }\n\n      if (x > 1.0 || x < -1.0) {\n          return Double.NaN;\n      }\n\n      if (x == -1.0) {\n          return Math.PI;\n      }\n\n      if (x == 1.0) {\n          return 0.0;\n      }\n\n      if (x == 0) {\n          return Math.PI/2.0;\n      }\n\n      /* Compute acos(x) = atan(sqrt(1-x*x)/x) */\n\n      /* Split x */\n      double temp = x * HEX_40000000;\n      final double xa = x + temp - temp;\n      final double xb = x - xa;\n\n      /* Square it */\n      double ya = xa*xa;\n      double yb = xa*xb*2.0 + xb*xb;\n\n      /* Subtract from 1 */\n      ya = -ya;\n      yb = -yb;\n\n      double za = 1.0 + ya;\n      double zb = -(za - 1.0 - ya);\n\n      temp = za + yb;\nza;\n      za = temp;\n\n      /* Square root */\n      double y = sqrt(za);\n      temp = y * HEX_40000000;\n      ya = y + temp - temp;\n      yb = y - ya;\n\n      /* Extend precision of sqrt */\n      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      /* Contribution of zb to sqrt */\n      yb += zb / (2.0*y);\n      y = ya+yb;\n      yb = -(y - ya - yb);\n\n      // Compute ratio r = y/x\n      double r = y/x;\n\n      // Did r overflow?\n      if (Double.isInfinite(r)) { // x is effectively zero\n          return Math.PI/2; // so return the appropriate value\n      }\n\n      double ra = doubleHighPart(r);\n      double rb = r - ra;\n\n      rb += (y - ra*xa - ra*xb - rb*xa - rb*xb) / x;  // Correct for rounding in division\n      rb += yb / x;  // Add in effect additional bits of sqrt.\n\n      temp = ra + rb;\n      rb = -(temp - ra - rb);\n      ra = temp;\n\n      return atan(ra, rb, x<0);\n    }",
          "24": "    public static double acos(double x) {\n      if (x != x) {\n          return Double.NaN;\n      }\n\n      if (x > 1.0 || x < -1.0) {\n          return Double.NaN;\n      }\n\n      if (x == -1.0) {\n          return Math.PI;\n      }\n\n      if (x == 1.0) {\n          return 0.0;\n      }\n\n      if (x == 0) {\n          return Math.PI/2.0;\n      }\n\n      /* Compute acos(x) = atan(sqrt(1-x*x)/x) */\n\n      /* Split x */\n      double temp = x * HEX_40000000;\n      final double xa = x + temp - temp;\n      final double xb = x - xa;\n\n      /* Square it */\n      double ya = xa*xa;\n      double yb = xa*xb*2.0 + xb*xb;\n\n      /* Subtract from 1 */\n      ya = -ya;\n      yb = -yb;\n\n      double za = 1.0 + ya;\n      double zb = -(za - 1.0 - ya);\n\n      temp = za + yb;\ntemp += ((temp - za) - yb);\n      za = temp;\n\n      /* Square root */\n      double y = sqrt(za);\n      temp = y * HEX_40000000;\n      ya = y + temp - temp;\n      yb = y - ya;\n\n      /* Extend precision of sqrt */\n      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      /* Contribution of zb to sqrt */\n      yb += zb / (2.0*y);\n      y = ya+yb;\n      yb = -(y - ya - yb);\n\n      // Compute ratio r = y/x\n      double r = y/x;\n\n      // Did r overflow?\n      if (Double.isInfinite(r)) { // x is effectively zero\n          return Math.PI/2; // so return the appropriate value\n      }\n\n      double ra = doubleHighPart(r);\n      double rb = r - ra;\n\n      rb += (y - ra*xa - ra*xb - rb*xa - rb*xb) / x;  // Correct for rounding in division\n      rb += yb / x;  // Add in effect additional bits of sqrt.\n\n      temp = ra + rb;\n      rb = -(temp - ra - rb);\n      ra = temp;\n\n      return atan(ra, rb, x<0);\n    }",
          "25": "    public static double acos(double x) {\n      if (x != x) {\n          return Double.NaN;\n      }\n\n      if (x > 1.0 || x < -1.0) {\n          return Double.NaN;\n      }\n\n      if (x == -1.0) {\n          return Math.PI;\n      }\n\n      if (x == 1.0) {\n          return 0.0;\n      }\n\n      if (x == 0) {\n          return Math.PI/2.0;\n      }\n\n      /* Compute acos(x) = atan(sqrt(1-x*x)/x) */\n\n      /* Split x */\n      double temp = x * HEX_40000000;\n      final double xa = x + temp - temp;\n      final double xb = x - xa;\n\n      /* Square it */\n      double ya = xa*xa;\n      double yb = xa*xb*2.0 + xb*xb;\n\n      /* Subtract from 1 */\n      ya = -ya;\n      yb = -yb;\n\n      double za = 1.0 + ya;\n      double zb = -(za - 1.0 - ya);\n\n      temp = za + yb;\nzb += ((temp - za) / yb);\n      za = temp;\n\n      /* Square root */\n      double y = sqrt(za);\n      temp = y * HEX_40000000;\n      ya = y + temp - temp;\n      yb = y - ya;\n\n      /* Extend precision of sqrt */\n      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      /* Contribution of zb to sqrt */\n      yb += zb / (2.0*y);\n      y = ya+yb;\n      yb = -(y - ya - yb);\n\n      // Compute ratio r = y/x\n      double r = y/x;\n\n      // Did r overflow?\n      if (Double.isInfinite(r)) { // x is effectively zero\n          return Math.PI/2; // so return the appropriate value\n      }\n\n      double ra = doubleHighPart(r);\n      double rb = r - ra;\n\n      rb += (y - ra*xa - ra*xb - rb*xa - rb*xb) / x;  // Correct for rounding in division\n      rb += yb / x;  // Add in effect additional bits of sqrt.\n\n      temp = ra + rb;\n      rb = -(temp - ra - rb);\n      ra = temp;\n\n      return atan(ra, rb, x<0);\n    }",
          "26": "    public static double acos(double x) {\n      if (x != x) {\n          return Double.NaN;\n      }\n\n      if (x > 1.0 || x < -1.0) {\n          return Double.NaN;\n      }\n\n      if (x == -1.0) {\n          return Math.PI;\n      }\n\n      if (x == 1.0) {\n          return 0.0;\n      }\n\n      if (x == 0) {\n          return Math.PI/2.0;\n      }\n\n      /* Compute acos(x) = atan(sqrt(1-x*x)/x) */\n\n      /* Split x */\n      double temp = x * HEX_40000000;\n      final double xa = x + temp - temp;\n      final double xb = x - xa;\n\n      /* Square it */\n      double ya = xa*xa;\n      double yb = xa*xb*2.0 + xb*xb;\n\n      /* Subtract from 1 */\n      ya = -ya;\n      yb = -yb;\n\n      double za = 1.0 + ya;\n      double zb = -(za - 1.0 - ya);\n\n      temp = za + yb;\nzb += (za - za);\n      za = temp;\n\n      /* Square root */\n      double y = sqrt(za);\n      temp = y * HEX_40000000;\n      ya = y + temp - temp;\n      yb = y - ya;\n\n      /* Extend precision of sqrt */\n      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      /* Contribution of zb to sqrt */\n      yb += zb / (2.0*y);\n      y = ya+yb;\n      yb = -(y - ya - yb);\n\n      // Compute ratio r = y/x\n      double r = y/x;\n\n      // Did r overflow?\n      if (Double.isInfinite(r)) { // x is effectively zero\n          return Math.PI/2; // so return the appropriate value\n      }\n\n      double ra = doubleHighPart(r);\n      double rb = r - ra;\n\n      rb += (y - ra*xa - ra*xb - rb*xa - rb*xb) / x;  // Correct for rounding in division\n      rb += yb / x;  // Add in effect additional bits of sqrt.\n\n      temp = ra + rb;\n      rb = -(temp - ra - rb);\n      ra = temp;\n\n      return atan(ra, rb, x<0);\n    }",
          "27": "    public static double acos(double x) {\n      if (x != x) {\n          return Double.NaN;\n      }\n\n      if (x > 1.0 || x < -1.0) {\n          return Double.NaN;\n      }\n\n      if (x == -1.0) {\n          return Math.PI;\n      }\n\n      if (x == 1.0) {\n          return 0.0;\n      }\n\n      if (x == 0) {\n          return Math.PI/2.0;\n      }\n\n      /* Compute acos(x) = atan(sqrt(1-x*x)/x) */\n\n      /* Split x */\n      double temp = x * HEX_40000000;\n      final double xa = x + temp - temp;\n      final double xb = x - xa;\n\n      /* Square it */\n      double ya = xa*xa;\n      double yb = xa*xb*2.0 + xb*xb;\n\n      /* Subtract from 1 */\n      ya = -ya;\n      yb = -yb;\n\n      double za = 1.0 + ya;\n      double zb = -(za - 1.0 - ya);\n\n      temp = za + yb;\nzb += (zb - za);\n      za = temp;\n\n      /* Square root */\n      double y = sqrt(za);\n      temp = y * HEX_40000000;\n      ya = y + temp - temp;\n      yb = y - ya;\n\n      /* Extend precision of sqrt */\n      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      /* Contribution of zb to sqrt */\n      yb += zb / (2.0*y);\n      y = ya+yb;\n      yb = -(y - ya - yb);\n\n      // Compute ratio r = y/x\n      double r = y/x;\n\n      // Did r overflow?\n      if (Double.isInfinite(r)) { // x is effectively zero\n          return Math.PI/2; // so return the appropriate value\n      }\n\n      double ra = doubleHighPart(r);\n      double rb = r - ra;\n\n      rb += (y - ra*xa - ra*xb - rb*xa - rb*xb) / x;  // Correct for rounding in division\n      rb += yb / x;  // Add in effect additional bits of sqrt.\n\n      temp = ra + rb;\n      rb = -(temp - ra - rb);\n      ra = temp;\n\n      return atan(ra, rb, x<0);\n    }",
          "28": "    public static double acos(double x) {\n      if (x != x) {\n          return Double.NaN;\n      }\n\n      if (x > 1.0 || x < -1.0) {\n          return Double.NaN;\n      }\n\n      if (x == -1.0) {\n          return Math.PI;\n      }\n\n      if (x == 1.0) {\n          return 0.0;\n      }\n\n      if (x == 0) {\n          return Math.PI/2.0;\n      }\n\n      /* Compute acos(x) = atan(sqrt(1-x*x)/x) */\n\n      /* Split x */\n      double temp = x * HEX_40000000;\n      final double xa = x + temp - temp;\n      final double xb = x - xa;\n\n      /* Square it */\n      double ya = xa*xa;\n      double yb = xa*xb*2.0 + xb*xb;\n\n      /* Subtract from 1 */\n      ya = -ya;\n      yb = -yb;\n\n      double za = 1.0 + ya;\n      double zb = -(za - 1.0 - ya);\n\n      temp = za + yb;\nzb += ((temp - za) >> yb);\n      za = temp;\n\n      /* Square root */\n      double y = sqrt(za);\n      temp = y * HEX_40000000;\n      ya = y + temp - temp;\n      yb = y - ya;\n\n      /* Extend precision of sqrt */\n      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      /* Contribution of zb to sqrt */\n      yb += zb / (2.0*y);\n      y = ya+yb;\n      yb = -(y - ya - yb);\n\n      // Compute ratio r = y/x\n      double r = y/x;\n\n      // Did r overflow?\n      if (Double.isInfinite(r)) { // x is effectively zero\n          return Math.PI/2; // so return the appropriate value\n      }\n\n      double ra = doubleHighPart(r);\n      double rb = r - ra;\n\n      rb += (y - ra*xa - ra*xb - rb*xa - rb*xb) / x;  // Correct for rounding in division\n      rb += yb / x;  // Add in effect additional bits of sqrt.\n\n      temp = ra + rb;\n      rb = -(temp - ra - rb);\n      ra = temp;\n\n      return atan(ra, rb, x<0);\n    }",
          "29": "    public static double acos(double x) {\n      if (x != x) {\n          return Double.NaN;\n      }\n\n      if (x > 1.0 || x < -1.0) {\n          return Double.NaN;\n      }\n\n      if (x == -1.0) {\n          return Math.PI;\n      }\n\n      if (x == 1.0) {\n          return 0.0;\n      }\n\n      if (x == 0) {\n          return Math.PI/2.0;\n      }\n\n      /* Compute acos(x) = atan(sqrt(1-x*x)/x) */\n\n      /* Split x */\n      double temp = x * HEX_40000000;\n      final double xa = x + temp - temp;\n      final double xb = x - xa;\n\n      /* Square it */\n      double ya = xa*xa;\n      double yb = xa*xb*2.0 + xb*xb;\n\n      /* Subtract from 1 */\n      ya = -ya;\n      yb = -yb;\n\n      double za = 1.0 + ya;\n      double zb = -(za - 1.0 - ya);\n\n      temp = za + yb;\nzb += (yb - za);\n      za = temp;\n\n      /* Square root */\n      double y = sqrt(za);\n      temp = y * HEX_40000000;\n      ya = y + temp - temp;\n      yb = y - ya;\n\n      /* Extend precision of sqrt */\n      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      /* Contribution of zb to sqrt */\n      yb += zb / (2.0*y);\n      y = ya+yb;\n      yb = -(y - ya - yb);\n\n      // Compute ratio r = y/x\n      double r = y/x;\n\n      // Did r overflow?\n      if (Double.isInfinite(r)) { // x is effectively zero\n          return Math.PI/2; // so return the appropriate value\n      }\n\n      double ra = doubleHighPart(r);\n      double rb = r - ra;\n\n      rb += (y - ra*xa - ra*xb - rb*xa - rb*xb) / x;  // Correct for rounding in division\n      rb += yb / x;  // Add in effect additional bits of sqrt.\n\n      temp = ra + rb;\n      rb = -(temp - ra - rb);\n      ra = temp;\n\n      return atan(ra, rb, x<0);\n    }",
          "30": "    public static double acos(double x) {\n      if (x != x) {\n          return Double.NaN;\n      }\n\n      if (x > 1.0 || x < -1.0) {\n          return Double.NaN;\n      }\n\n      if (x == -1.0) {\n          return Math.PI;\n      }\n\n      if (x == 1.0) {\n          return 0.0;\n      }\n\n      if (x == 0) {\n          return Math.PI/2.0;\n      }\n\n      /* Compute acos(x) = atan(sqrt(1-x*x)/x) */\n\n      /* Split x */\n      double temp = x * HEX_40000000;\n      final double xa = x + temp - temp;\n      final double xb = x - xa;\n\n      /* Square it */\n      double ya = xa*xa;\n      double yb = xa*xb*2.0 + xb*xb;\n\n      /* Subtract from 1 */\n      ya = -ya;\n      yb = -yb;\n\n      double za = 1.0 + ya;\n      double zb = -(za - 1.0 - ya);\n\n      temp = za + yb;\nyb += ((temp - za) - yb);\n      za = temp;\n\n      /* Square root */\n      double y = sqrt(za);\n      temp = y * HEX_40000000;\n      ya = y + temp - temp;\n      yb = y - ya;\n\n      /* Extend precision of sqrt */\n      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      /* Contribution of zb to sqrt */\n      yb += zb / (2.0*y);\n      y = ya+yb;\n      yb = -(y - ya - yb);\n\n      // Compute ratio r = y/x\n      double r = y/x;\n\n      // Did r overflow?\n      if (Double.isInfinite(r)) { // x is effectively zero\n          return Math.PI/2; // so return the appropriate value\n      }\n\n      double ra = doubleHighPart(r);\n      double rb = r - ra;\n\n      rb += (y - ra*xa - ra*xb - rb*xa - rb*xb) / x;  // Correct for rounding in division\n      rb += yb / x;  // Add in effect additional bits of sqrt.\n\n      temp = ra + rb;\n      rb = -(temp - ra - rb);\n      ra = temp;\n\n      return atan(ra, rb, x<0);\n    }",
          "31": "    public static double acos(double x) {\n      if (x != x) {\n          return Double.NaN;\n      }\n\n      if (x > 1.0 || x < -1.0) {\n          return Double.NaN;\n      }\n\n      if (x == -1.0) {\n          return Math.PI;\n      }\n\n      if (x == 1.0) {\n          return 0.0;\n      }\n\n      if (x == 0) {\n          return Math.PI/2.0;\n      }\n\n      /* Compute acos(x) = atan(sqrt(1-x*x)/x) */\n\n      /* Split x */\n      double temp = x * HEX_40000000;\n      final double xa = x + temp - temp;\n      final double xb = x - xa;\n\n      /* Square it */\n      double ya = xa*xa;\n      double yb = xa*xb*2.0 + xb*xb;\n\n      /* Subtract from 1 */\n      ya = -ya;\n      yb = -yb;\n\n      double za = 1.0 + ya;\n      double zb = -(za - 1.0 - ya);\n\n      temp = za + yb;\nzb += (za - yb);\n      za = temp;\n\n      /* Square root */\n      double y = sqrt(za);\n      temp = y * HEX_40000000;\n      ya = y + temp - temp;\n      yb = y - ya;\n\n      /* Extend precision of sqrt */\n      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      /* Contribution of zb to sqrt */\n      yb += zb / (2.0*y);\n      y = ya+yb;\n      yb = -(y - ya - yb);\n\n      // Compute ratio r = y/x\n      double r = y/x;\n\n      // Did r overflow?\n      if (Double.isInfinite(r)) { // x is effectively zero\n          return Math.PI/2; // so return the appropriate value\n      }\n\n      double ra = doubleHighPart(r);\n      double rb = r - ra;\n\n      rb += (y - ra*xa - ra*xb - rb*xa - rb*xb) / x;  // Correct for rounding in division\n      rb += yb / x;  // Add in effect additional bits of sqrt.\n\n      temp = ra + rb;\n      rb = -(temp - ra - rb);\n      ra = temp;\n\n      return atan(ra, rb, x<0);\n    }",
          "32": "    public static double acos(double x) {\n      if (x != x) {\n          return Double.NaN;\n      }\n\n      if (x > 1.0 || x < -1.0) {\n          return Double.NaN;\n      }\n\n      if (x == -1.0) {\n          return Math.PI;\n      }\n\n      if (x == 1.0) {\n          return 0.0;\n      }\n\n      if (x == 0) {\n          return Math.PI/2.0;\n      }\n\n      /* Compute acos(x) = atan(sqrt(1-x*x)/x) */\n\n      /* Split x */\n      double temp = x * HEX_40000000;\n      final double xa = x + temp - temp;\n      final double xb = x - xa;\n\n      /* Square it */\n      double ya = xa*xa;\n      double yb = xa*xb*2.0 + xb*xb;\n\n      /* Subtract from 1 */\n      ya = -ya;\n      yb = -yb;\n\n      double za = 1.0 + ya;\n      double zb = -(za - 1.0 - ya);\n\n      temp = za + yb;\nza += ((temp - za) - yb);\n      za = temp;\n\n      /* Square root */\n      double y = sqrt(za);\n      temp = y * HEX_40000000;\n      ya = y + temp - temp;\n      yb = y - ya;\n\n      /* Extend precision of sqrt */\n      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      /* Contribution of zb to sqrt */\n      yb += zb / (2.0*y);\n      y = ya+yb;\n      yb = -(y - ya - yb);\n\n      // Compute ratio r = y/x\n      double r = y/x;\n\n      // Did r overflow?\n      if (Double.isInfinite(r)) { // x is effectively zero\n          return Math.PI/2; // so return the appropriate value\n      }\n\n      double ra = doubleHighPart(r);\n      double rb = r - ra;\n\n      rb += (y - ra*xa - ra*xb - rb*xa - rb*xb) / x;  // Correct for rounding in division\n      rb += yb / x;  // Add in effect additional bits of sqrt.\n\n      temp = ra + rb;\n      rb = -(temp - ra - rb);\n      ra = temp;\n\n      return atan(ra, rb, x<0);\n    }",
          "33": "    public static double acos(double x) {\n      if (x != x) {\n          return Double.NaN;\n      }\n\n      if (x > 1.0 || x < -1.0) {\n          return Double.NaN;\n      }\n\n      if (x == -1.0) {\n          return Math.PI;\n      }\n\n      if (x == 1.0) {\n          return 0.0;\n      }\n\n      if (x == 0) {\n          return Math.PI/2.0;\n      }\n\n      /* Compute acos(x) = atan(sqrt(1-x*x)/x) */\n\n      /* Split x */\n      double temp = x * HEX_40000000;\n      final double xa = x + temp - temp;\n      final double xb = x - xa;\n\n      /* Square it */\n      double ya = xa*xa;\n      double yb = xa*xb*2.0 + xb*xb;\n\n      /* Subtract from 1 */\n      ya = -ya;\n      yb = -yb;\n\n      double za = 1.0 + ya;\n      double zb = -(za - 1.0 - ya);\n\n      temp = za + yb;\nzb += (za + za);\n      za = temp;\n\n      /* Square root */\n      double y = sqrt(za);\n      temp = y * HEX_40000000;\n      ya = y + temp - temp;\n      yb = y - ya;\n\n      /* Extend precision of sqrt */\n      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      /* Contribution of zb to sqrt */\n      yb += zb / (2.0*y);\n      y = ya+yb;\n      yb = -(y - ya - yb);\n\n      // Compute ratio r = y/x\n      double r = y/x;\n\n      // Did r overflow?\n      if (Double.isInfinite(r)) { // x is effectively zero\n          return Math.PI/2; // so return the appropriate value\n      }\n\n      double ra = doubleHighPart(r);\n      double rb = r - ra;\n\n      rb += (y - ra*xa - ra*xb - rb*xa - rb*xb) / x;  // Correct for rounding in division\n      rb += yb / x;  // Add in effect additional bits of sqrt.\n\n      temp = ra + rb;\n      rb = -(temp - ra - rb);\n      ra = temp;\n\n      return atan(ra, rb, x<0);\n    }",
          "34": "    public static double acos(double x) {\n      if (x != x) {\n          return Double.NaN;\n      }\n\n      if (x > 1.0 || x < -1.0) {\n          return Double.NaN;\n      }\n\n      if (x == -1.0) {\n          return Math.PI;\n      }\n\n      if (x == 1.0) {\n          return 0.0;\n      }\n\n      if (x == 0) {\n          return Math.PI/2.0;\n      }\n\n      /* Compute acos(x) = atan(sqrt(1-x*x)/x) */\n\n      /* Split x */\n      double temp = x * HEX_40000000;\n      final double xa = x + temp - temp;\n      final double xb = x - xa;\n\n      /* Square it */\n      double ya = xa*xa;\n      double yb = xa*xb*2.0 + xb*xb;\n\n      /* Subtract from 1 */\n      ya = -ya;\n      yb = -yb;\n\n      double za = 1.0 + ya;\n      double zb = -(za - 1.0 - ya);\n\n      temp = za + yb;\nzb += (zb - yb);\n      za = temp;\n\n      /* Square root */\n      double y = sqrt(za);\n      temp = y * HEX_40000000;\n      ya = y + temp - temp;\n      yb = y - ya;\n\n      /* Extend precision of sqrt */\n      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      /* Contribution of zb to sqrt */\n      yb += zb / (2.0*y);\n      y = ya+yb;\n      yb = -(y - ya - yb);\n\n      // Compute ratio r = y/x\n      double r = y/x;\n\n      // Did r overflow?\n      if (Double.isInfinite(r)) { // x is effectively zero\n          return Math.PI/2; // so return the appropriate value\n      }\n\n      double ra = doubleHighPart(r);\n      double rb = r - ra;\n\n      rb += (y - ra*xa - ra*xb - rb*xa - rb*xb) / x;  // Correct for rounding in division\n      rb += yb / x;  // Add in effect additional bits of sqrt.\n\n      temp = ra + rb;\n      rb = -(temp - ra - rb);\n      ra = temp;\n\n      return atan(ra, rb, x<0);\n    }",
          "35": "    public static double acos(double x) {\n      if (x != x) {\n          return Double.NaN;\n      }\n\n      if (x > 1.0 || x < -1.0) {\n          return Double.NaN;\n      }\n\n      if (x == -1.0) {\n          return Math.PI;\n      }\n\n      if (x == 1.0) {\n          return 0.0;\n      }\n\n      if (x == 0) {\n          return Math.PI/2.0;\n      }\n\n      /* Compute acos(x) = atan(sqrt(1-x*x)/x) */\n\n      /* Split x */\n      double temp = x * HEX_40000000;\n      final double xa = x + temp - temp;\n      final double xb = x - xa;\n\n      /* Square it */\n      double ya = xa*xa;\n      double yb = xa*xb*2.0 + xb*xb;\n\n      /* Subtract from 1 */\n      ya = -ya;\n      yb = -yb;\n\n      double za = 1.0 + ya;\n      double zb = -(za - 1.0 - ya);\n\n      temp = za + yb;\nzb += (zb + za);\n      za = temp;\n\n      /* Square root */\n      double y = sqrt(za);\n      temp = y * HEX_40000000;\n      ya = y + temp - temp;\n      yb = y - ya;\n\n      /* Extend precision of sqrt */\n      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      /* Contribution of zb to sqrt */\n      yb += zb / (2.0*y);\n      y = ya+yb;\n      yb = -(y - ya - yb);\n\n      // Compute ratio r = y/x\n      double r = y/x;\n\n      // Did r overflow?\n      if (Double.isInfinite(r)) { // x is effectively zero\n          return Math.PI/2; // so return the appropriate value\n      }\n\n      double ra = doubleHighPart(r);\n      double rb = r - ra;\n\n      rb += (y - ra*xa - ra*xb - rb*xa - rb*xb) / x;  // Correct for rounding in division\n      rb += yb / x;  // Add in effect additional bits of sqrt.\n\n      temp = ra + rb;\n      rb = -(temp - ra - rb);\n      ra = temp;\n\n      return atan(ra, rb, x<0);\n    }",
          "36": "    public static double acos(double x) {\n      if (x != x) {\n          return Double.NaN;\n      }\n\n      if (x > 1.0 || x < -1.0) {\n          return Double.NaN;\n      }\n\n      if (x == -1.0) {\n          return Math.PI;\n      }\n\n      if (x == 1.0) {\n          return 0.0;\n      }\n\n      if (x == 0) {\n          return Math.PI/2.0;\n      }\n\n      /* Compute acos(x) = atan(sqrt(1-x*x)/x) */\n\n      /* Split x */\n      double temp = x * HEX_40000000;\n      final double xa = x + temp - temp;\n      final double xb = x - xa;\n\n      /* Square it */\n      double ya = xa*xa;\n      double yb = xa*xb*2.0 + xb*xb;\n\n      /* Subtract from 1 */\n      ya = -ya;\n      yb = -yb;\n\n      double za = 1.0 + ya;\n      double zb = -(za - 1.0 - ya);\n\n      temp = za + yb;\nzb += (yb - yb);\n      za = temp;\n\n      /* Square root */\n      double y = sqrt(za);\n      temp = y * HEX_40000000;\n      ya = y + temp - temp;\n      yb = y - ya;\n\n      /* Extend precision of sqrt */\n      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      /* Contribution of zb to sqrt */\n      yb += zb / (2.0*y);\n      y = ya+yb;\n      yb = -(y - ya - yb);\n\n      // Compute ratio r = y/x\n      double r = y/x;\n\n      // Did r overflow?\n      if (Double.isInfinite(r)) { // x is effectively zero\n          return Math.PI/2; // so return the appropriate value\n      }\n\n      double ra = doubleHighPart(r);\n      double rb = r - ra;\n\n      rb += (y - ra*xa - ra*xb - rb*xa - rb*xb) / x;  // Correct for rounding in division\n      rb += yb / x;  // Add in effect additional bits of sqrt.\n\n      temp = ra + rb;\n      rb = -(temp - ra - rb);\n      ra = temp;\n\n      return atan(ra, rb, x<0);\n    }",
          "37": "    public static double acos(double x) {\n      if (x != x) {\n          return Double.NaN;\n      }\n\n      if (x > 1.0 || x < -1.0) {\n          return Double.NaN;\n      }\n\n      if (x == -1.0) {\n          return Math.PI;\n      }\n\n      if (x == 1.0) {\n          return 0.0;\n      }\n\n      if (x == 0) {\n          return Math.PI/2.0;\n      }\n\n      /* Compute acos(x) = atan(sqrt(1-x*x)/x) */\n\n      /* Split x */\n      double temp = x * HEX_40000000;\n      final double xa = x + temp - temp;\n      final double xb = x - xa;\n\n      /* Square it */\n      double ya = xa*xa;\n      double yb = xa*xb*2.0 + xb*xb;\n\n      /* Subtract from 1 */\n      ya = -ya;\n      yb = -yb;\n\n      double za = 1.0 + ya;\n      double zb = -(za - 1.0 - ya);\n\n      temp = za + yb;\nzb += (yb + za);\n      za = temp;\n\n      /* Square root */\n      double y = sqrt(za);\n      temp = y * HEX_40000000;\n      ya = y + temp - temp;\n      yb = y - ya;\n\n      /* Extend precision of sqrt */\n      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      /* Contribution of zb to sqrt */\n      yb += zb / (2.0*y);\n      y = ya+yb;\n      yb = -(y - ya - yb);\n\n      // Compute ratio r = y/x\n      double r = y/x;\n\n      // Did r overflow?\n      if (Double.isInfinite(r)) { // x is effectively zero\n          return Math.PI/2; // so return the appropriate value\n      }\n\n      double ra = doubleHighPart(r);\n      double rb = r - ra;\n\n      rb += (y - ra*xa - ra*xb - rb*xa - rb*xb) / x;  // Correct for rounding in division\n      rb += yb / x;  // Add in effect additional bits of sqrt.\n\n      temp = ra + rb;\n      rb = -(temp - ra - rb);\n      ra = temp;\n\n      return atan(ra, rb, x<0);\n    }",
          "38": "    public static double acos(double x) {\n      if (x != x) {\n          return Double.NaN;\n      }\n\n      if (x > 1.0 || x < -1.0) {\n          return Double.NaN;\n      }\n\n      if (x == -1.0) {\n          return Math.PI;\n      }\n\n      if (x == 1.0) {\n          return 0.0;\n      }\n\n      if (x == 0) {\n          return Math.PI/2.0;\n      }\n\n      /* Compute acos(x) = atan(sqrt(1-x*x)/x) */\n\n      /* Split x */\n      double temp = x * HEX_40000000;\n      final double xa = x + temp - temp;\n      final double xb = x - xa;\n\n      /* Square it */\n      double ya = xa*xa;\n      double yb = xa*xb*2.0 + xb*xb;\n\n      /* Subtract from 1 */\n      ya = -ya;\n      yb = -yb;\n\n      double za = 1.0 + ya;\n      double zb = -(za - 1.0 - ya);\n\n      temp = za + yb;\nzb += (za + yb);\n      za = temp;\n\n      /* Square root */\n      double y = sqrt(za);\n      temp = y * HEX_40000000;\n      ya = y + temp - temp;\n      yb = y - ya;\n\n      /* Extend precision of sqrt */\n      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      /* Contribution of zb to sqrt */\n      yb += zb / (2.0*y);\n      y = ya+yb;\n      yb = -(y - ya - yb);\n\n      // Compute ratio r = y/x\n      double r = y/x;\n\n      // Did r overflow?\n      if (Double.isInfinite(r)) { // x is effectively zero\n          return Math.PI/2; // so return the appropriate value\n      }\n\n      double ra = doubleHighPart(r);\n      double rb = r - ra;\n\n      rb += (y - ra*xa - ra*xb - rb*xa - rb*xb) / x;  // Correct for rounding in division\n      rb += yb / x;  // Add in effect additional bits of sqrt.\n\n      temp = ra + rb;\n      rb = -(temp - ra - rb);\n      ra = temp;\n\n      return atan(ra, rb, x<0);\n    }",
          "39": "    public static double acos(double x) {\n      if (x != x) {\n          return Double.NaN;\n      }\n\n      if (x > 1.0 || x < -1.0) {\n          return Double.NaN;\n      }\n\n      if (x == -1.0) {\n          return Math.PI;\n      }\n\n      if (x == 1.0) {\n          return 0.0;\n      }\n\n      if (x == 0) {\n          return Math.PI/2.0;\n      }\n\n      /* Compute acos(x) = atan(sqrt(1-x*x)/x) */\n\n      /* Split x */\n      double temp = x * HEX_40000000;\n      final double xa = x + temp - temp;\n      final double xb = x - xa;\n\n      /* Square it */\n      double ya = xa*xa;\n      double yb = xa*xb*2.0 + xb*xb;\n\n      /* Subtract from 1 */\n      ya = -ya;\n      yb = -yb;\n\n      double za = 1.0 + ya;\n      double zb = -(za - 1.0 - ya);\n\n      temp = za + yb;\nzb += (zb + yb);\n      za = temp;\n\n      /* Square root */\n      double y = sqrt(za);\n      temp = y * HEX_40000000;\n      ya = y + temp - temp;\n      yb = y - ya;\n\n      /* Extend precision of sqrt */\n      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      /* Contribution of zb to sqrt */\n      yb += zb / (2.0*y);\n      y = ya+yb;\n      yb = -(y - ya - yb);\n\n      // Compute ratio r = y/x\n      double r = y/x;\n\n      // Did r overflow?\n      if (Double.isInfinite(r)) { // x is effectively zero\n          return Math.PI/2; // so return the appropriate value\n      }\n\n      double ra = doubleHighPart(r);\n      double rb = r - ra;\n\n      rb += (y - ra*xa - ra*xb - rb*xa - rb*xb) / x;  // Correct for rounding in division\n      rb += yb / x;  // Add in effect additional bits of sqrt.\n\n      temp = ra + rb;\n      rb = -(temp - ra - rb);\n      ra = temp;\n\n      return atan(ra, rb, x<0);\n    }",
          "40": "    public static double acos(double x) {\n      if (x != x) {\n          return Double.NaN;\n      }\n\n      if (x > 1.0 || x < -1.0) {\n          return Double.NaN;\n      }\n\n      if (x == -1.0) {\n          return Math.PI;\n      }\n\n      if (x == 1.0) {\n          return 0.0;\n      }\n\n      if (x == 0) {\n          return Math.PI/2.0;\n      }\n\n      /* Compute acos(x) = atan(sqrt(1-x*x)/x) */\n\n      /* Split x */\n      double temp = x * HEX_40000000;\n      final double xa = x + temp - temp;\n      final double xb = x - xa;\n\n      /* Square it */\n      double ya = xa*xa;\n      double yb = xa*xb*2.0 + xb*xb;\n\n      /* Subtract from 1 */\n      ya = -ya;\n      yb = -yb;\n\n      double za = 1.0 + ya;\n      double zb = -(za - 1.0 - ya);\n\n      temp = za + yb;\nzb += ((za - za) - yb);\n      za = temp;\n\n      /* Square root */\n      double y = sqrt(za);\n      temp = y * HEX_40000000;\n      ya = y + temp - temp;\n      yb = y - ya;\n\n      /* Extend precision of sqrt */\n      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      /* Contribution of zb to sqrt */\n      yb += zb / (2.0*y);\n      y = ya+yb;\n      yb = -(y - ya - yb);\n\n      // Compute ratio r = y/x\n      double r = y/x;\n\n      // Did r overflow?\n      if (Double.isInfinite(r)) { // x is effectively zero\n          return Math.PI/2; // so return the appropriate value\n      }\n\n      double ra = doubleHighPart(r);\n      double rb = r - ra;\n\n      rb += (y - ra*xa - ra*xb - rb*xa - rb*xb) / x;  // Correct for rounding in division\n      rb += yb / x;  // Add in effect additional bits of sqrt.\n\n      temp = ra + rb;\n      rb = -(temp - ra - rb);\n      ra = temp;\n\n      return atan(ra, rb, x<0);\n    }",
          "41": "    public static double acos(double x) {\n      if (x != x) {\n          return Double.NaN;\n      }\n\n      if (x > 1.0 || x < -1.0) {\n          return Double.NaN;\n      }\n\n      if (x == -1.0) {\n          return Math.PI;\n      }\n\n      if (x == 1.0) {\n          return 0.0;\n      }\n\n      if (x == 0) {\n          return Math.PI/2.0;\n      }\n\n      /* Compute acos(x) = atan(sqrt(1-x*x)/x) */\n\n      /* Split x */\n      double temp = x * HEX_40000000;\n      final double xa = x + temp - temp;\n      final double xb = x - xa;\n\n      /* Square it */\n      double ya = xa*xa;\n      double yb = xa*xb*2.0 + xb*xb;\n\n      /* Subtract from 1 */\n      ya = -ya;\n      yb = -yb;\n\n      double za = 1.0 + ya;\n      double zb = -(za - 1.0 - ya);\n\n      temp = za + yb;\nzb += ((yb - za) - yb);\n      za = temp;\n\n      /* Square root */\n      double y = sqrt(za);\n      temp = y * HEX_40000000;\n      ya = y + temp - temp;\n      yb = y - ya;\n\n      /* Extend precision of sqrt */\n      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      /* Contribution of zb to sqrt */\n      yb += zb / (2.0*y);\n      y = ya+yb;\n      yb = -(y - ya - yb);\n\n      // Compute ratio r = y/x\n      double r = y/x;\n\n      // Did r overflow?\n      if (Double.isInfinite(r)) { // x is effectively zero\n          return Math.PI/2; // so return the appropriate value\n      }\n\n      double ra = doubleHighPart(r);\n      double rb = r - ra;\n\n      rb += (y - ra*xa - ra*xb - rb*xa - rb*xb) / x;  // Correct for rounding in division\n      rb += yb / x;  // Add in effect additional bits of sqrt.\n\n      temp = ra + rb;\n      rb = -(temp - ra - rb);\n      ra = temp;\n\n      return atan(ra, rb, x<0);\n    }",
          "42": "    public static double acos(double x) {\n      if (x != x) {\n          return Double.NaN;\n      }\n\n      if (x > 1.0 || x < -1.0) {\n          return Double.NaN;\n      }\n\n      if (x == -1.0) {\n          return Math.PI;\n      }\n\n      if (x == 1.0) {\n          return 0.0;\n      }\n\n      if (x == 0) {\n          return Math.PI/2.0;\n      }\n\n      /* Compute acos(x) = atan(sqrt(1-x*x)/x) */\n\n      /* Split x */\n      double temp = x * HEX_40000000;\n      final double xa = x + temp - temp;\n      final double xb = x - xa;\n\n      /* Square it */\n      double ya = xa*xa;\n      double yb = xa*xb*2.0 + xb*xb;\n\n      /* Subtract from 1 */\n      ya = -ya;\n      yb = -yb;\n\n      double za = 1.0 + ya;\n      double zb = -(za - 1.0 - ya);\n\n      temp = za + yb;\nzb += ((za - za) + za);\n      za = temp;\n\n      /* Square root */\n      double y = sqrt(za);\n      temp = y * HEX_40000000;\n      ya = y + temp - temp;\n      yb = y - ya;\n\n      /* Extend precision of sqrt */\n      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      /* Contribution of zb to sqrt */\n      yb += zb / (2.0*y);\n      y = ya+yb;\n      yb = -(y - ya - yb);\n\n      // Compute ratio r = y/x\n      double r = y/x;\n\n      // Did r overflow?\n      if (Double.isInfinite(r)) { // x is effectively zero\n          return Math.PI/2; // so return the appropriate value\n      }\n\n      double ra = doubleHighPart(r);\n      double rb = r - ra;\n\n      rb += (y - ra*xa - ra*xb - rb*xa - rb*xb) / x;  // Correct for rounding in division\n      rb += yb / x;  // Add in effect additional bits of sqrt.\n\n      temp = ra + rb;\n      rb = -(temp - ra - rb);\n      ra = temp;\n\n      return atan(ra, rb, x<0);\n    }",
          "43": "    public static double acos(double x) {\n      if (x != x) {\n          return Double.NaN;\n      }\n\n      if (x > 1.0 || x < -1.0) {\n          return Double.NaN;\n      }\n\n      if (x == -1.0) {\n          return Math.PI;\n      }\n\n      if (x == 1.0) {\n          return 0.0;\n      }\n\n      if (x == 0) {\n          return Math.PI/2.0;\n      }\n\n      /* Compute acos(x) = atan(sqrt(1-x*x)/x) */\n\n      /* Split x */\n      double temp = x * HEX_40000000;\n      final double xa = x + temp - temp;\n      final double xb = x - xa;\n\n      /* Square it */\n      double ya = xa*xa;\n      double yb = xa*xb*2.0 + xb*xb;\n\n      /* Subtract from 1 */\n      ya = -ya;\n      yb = -yb;\n\n      double za = 1.0 + ya;\n      double zb = -(za - 1.0 - ya);\n\n      temp = za + yb;\nzb += ((yb - za) + za);\n      za = temp;\n\n      /* Square root */\n      double y = sqrt(za);\n      temp = y * HEX_40000000;\n      ya = y + temp - temp;\n      yb = y - ya;\n\n      /* Extend precision of sqrt */\n      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      /* Contribution of zb to sqrt */\n      yb += zb / (2.0*y);\n      y = ya+yb;\n      yb = -(y - ya - yb);\n\n      // Compute ratio r = y/x\n      double r = y/x;\n\n      // Did r overflow?\n      if (Double.isInfinite(r)) { // x is effectively zero\n          return Math.PI/2; // so return the appropriate value\n      }\n\n      double ra = doubleHighPart(r);\n      double rb = r - ra;\n\n      rb += (y - ra*xa - ra*xb - rb*xa - rb*xb) / x;  // Correct for rounding in division\n      rb += yb / x;  // Add in effect additional bits of sqrt.\n\n      temp = ra + rb;\n      rb = -(temp - ra - rb);\n      ra = temp;\n\n      return atan(ra, rb, x<0);\n    }",
          "44": "    public static double acos(double x) {\n      if (x != x) {\n          return Double.NaN;\n      }\n\n      if (x > 1.0 || x < -1.0) {\n          return Double.NaN;\n      }\n\n      if (x == -1.0) {\n          return Math.PI;\n      }\n\n      if (x == 1.0) {\n          return 0.0;\n      }\n\n      if (x == 0) {\n          return Math.PI/2.0;\n      }\n\n      /* Compute acos(x) = atan(sqrt(1-x*x)/x) */\n\n      /* Split x */\n      double temp = x * HEX_40000000;\n      final double xa = x + temp - temp;\n      final double xb = x - xa;\n\n      /* Square it */\n      double ya = xa*xa;\n      double yb = xa*xb*2.0 + xb*xb;\n\n      /* Subtract from 1 */\n      ya = -ya;\n      yb = -yb;\n\n      double za = 1.0 + ya;\n      double zb = -(za - 1.0 - ya);\n\n      temp = za + yb;\nzb += ((zb - za) + za);\n      za = temp;\n\n      /* Square root */\n      double y = sqrt(za);\n      temp = y * HEX_40000000;\n      ya = y + temp - temp;\n      yb = y - ya;\n\n      /* Extend precision of sqrt */\n      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      /* Contribution of zb to sqrt */\n      yb += zb / (2.0*y);\n      y = ya+yb;\n      yb = -(y - ya - yb);\n\n      // Compute ratio r = y/x\n      double r = y/x;\n\n      // Did r overflow?\n      if (Double.isInfinite(r)) { // x is effectively zero\n          return Math.PI/2; // so return the appropriate value\n      }\n\n      double ra = doubleHighPart(r);\n      double rb = r - ra;\n\n      rb += (y - ra*xa - ra*xb - rb*xa - rb*xb) / x;  // Correct for rounding in division\n      rb += yb / x;  // Add in effect additional bits of sqrt.\n\n      temp = ra + rb;\n      rb = -(temp - ra - rb);\n      ra = temp;\n\n      return atan(ra, rb, x<0);\n    }",
          "45": "    public static double acos(double x) {\n      if (x != x) {\n          return Double.NaN;\n      }\n\n      if (x > 1.0 || x < -1.0) {\n          return Double.NaN;\n      }\n\n      if (x == -1.0) {\n          return Math.PI;\n      }\n\n      if (x == 1.0) {\n          return 0.0;\n      }\n\n      if (x == 0) {\n          return Math.PI/2.0;\n      }\n\n      /* Compute acos(x) = atan(sqrt(1-x*x)/x) */\n\n      /* Split x */\n      double temp = x * HEX_40000000;\n      final double xa = x + temp - temp;\n      final double xb = x - xa;\n\n      /* Square it */\n      double ya = xa*xa;\n      double yb = xa*xb*2.0 + xb*xb;\n\n      /* Subtract from 1 */\n      ya = -ya;\n      yb = -yb;\n\n      double za = 1.0 + ya;\n      double zb = -(za - 1.0 - ya);\n\n      temp = za + yb;\nzb += ((za - yb) + za);\n      za = temp;\n\n      /* Square root */\n      double y = sqrt(za);\n      temp = y * HEX_40000000;\n      ya = y + temp - temp;\n      yb = y - ya;\n\n      /* Extend precision of sqrt */\n      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      /* Contribution of zb to sqrt */\n      yb += zb / (2.0*y);\n      y = ya+yb;\n      yb = -(y - ya - yb);\n\n      // Compute ratio r = y/x\n      double r = y/x;\n\n      // Did r overflow?\n      if (Double.isInfinite(r)) { // x is effectively zero\n          return Math.PI/2; // so return the appropriate value\n      }\n\n      double ra = doubleHighPart(r);\n      double rb = r - ra;\n\n      rb += (y - ra*xa - ra*xb - rb*xa - rb*xb) / x;  // Correct for rounding in division\n      rb += yb / x;  // Add in effect additional bits of sqrt.\n\n      temp = ra + rb;\n      rb = -(temp - ra - rb);\n      ra = temp;\n\n      return atan(ra, rb, x<0);\n    }",
          "46": "    public static double acos(double x) {\n      if (x != x) {\n          return Double.NaN;\n      }\n\n      if (x > 1.0 || x < -1.0) {\n          return Double.NaN;\n      }\n\n      if (x == -1.0) {\n          return Math.PI;\n      }\n\n      if (x == 1.0) {\n          return 0.0;\n      }\n\n      if (x == 0) {\n          return Math.PI/2.0;\n      }\n\n      /* Compute acos(x) = atan(sqrt(1-x*x)/x) */\n\n      /* Split x */\n      double temp = x * HEX_40000000;\n      final double xa = x + temp - temp;\n      final double xb = x - xa;\n\n      /* Square it */\n      double ya = xa*xa;\n      double yb = xa*xb*2.0 + xb*xb;\n\n      /* Subtract from 1 */\n      ya = -ya;\n      yb = -yb;\n\n      double za = 1.0 + ya;\n      double zb = -(za - 1.0 - ya);\n\n      temp = za + yb;\nzb += ((za + za) + za);\n      za = temp;\n\n      /* Square root */\n      double y = sqrt(za);\n      temp = y * HEX_40000000;\n      ya = y + temp - temp;\n      yb = y - ya;\n\n      /* Extend precision of sqrt */\n      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      /* Contribution of zb to sqrt */\n      yb += zb / (2.0*y);\n      y = ya+yb;\n      yb = -(y - ya - yb);\n\n      // Compute ratio r = y/x\n      double r = y/x;\n\n      // Did r overflow?\n      if (Double.isInfinite(r)) { // x is effectively zero\n          return Math.PI/2; // so return the appropriate value\n      }\n\n      double ra = doubleHighPart(r);\n      double rb = r - ra;\n\n      rb += (y - ra*xa - ra*xb - rb*xa - rb*xb) / x;  // Correct for rounding in division\n      rb += yb / x;  // Add in effect additional bits of sqrt.\n\n      temp = ra + rb;\n      rb = -(temp - ra - rb);\n      ra = temp;\n\n      return atan(ra, rb, x<0);\n    }",
          "47": "    public static double acos(double x) {\n      if (x != x) {\n          return Double.NaN;\n      }\n\n      if (x > 1.0 || x < -1.0) {\n          return Double.NaN;\n      }\n\n      if (x == -1.0) {\n          return Math.PI;\n      }\n\n      if (x == 1.0) {\n          return 0.0;\n      }\n\n      if (x == 0) {\n          return Math.PI/2.0;\n      }\n\n      /* Compute acos(x) = atan(sqrt(1-x*x)/x) */\n\n      /* Split x */\n      double temp = x * HEX_40000000;\n      final double xa = x + temp - temp;\n      final double xb = x - xa;\n\n      /* Square it */\n      double ya = xa*xa;\n      double yb = xa*xb*2.0 + xb*xb;\n\n      /* Subtract from 1 */\n      ya = -ya;\n      yb = -yb;\n\n      double za = 1.0 + ya;\n      double zb = -(za - 1.0 - ya);\n\n      temp = za + yb;\nzb += ((yb - yb) + za);\n      za = temp;\n\n      /* Square root */\n      double y = sqrt(za);\n      temp = y * HEX_40000000;\n      ya = y + temp - temp;\n      yb = y - ya;\n\n      /* Extend precision of sqrt */\n      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      /* Contribution of zb to sqrt */\n      yb += zb / (2.0*y);\n      y = ya+yb;\n      yb = -(y - ya - yb);\n\n      // Compute ratio r = y/x\n      double r = y/x;\n\n      // Did r overflow?\n      if (Double.isInfinite(r)) { // x is effectively zero\n          return Math.PI/2; // so return the appropriate value\n      }\n\n      double ra = doubleHighPart(r);\n      double rb = r - ra;\n\n      rb += (y - ra*xa - ra*xb - rb*xa - rb*xb) / x;  // Correct for rounding in division\n      rb += yb / x;  // Add in effect additional bits of sqrt.\n\n      temp = ra + rb;\n      rb = -(temp - ra - rb);\n      ra = temp;\n\n      return atan(ra, rb, x<0);\n    }",
          "48": "    public static double acos(double x) {\n      if (x != x) {\n          return Double.NaN;\n      }\n\n      if (x > 1.0 || x < -1.0) {\n          return Double.NaN;\n      }\n\n      if (x == -1.0) {\n          return Math.PI;\n      }\n\n      if (x == 1.0) {\n          return 0.0;\n      }\n\n      if (x == 0) {\n          return Math.PI/2.0;\n      }\n\n      /* Compute acos(x) = atan(sqrt(1-x*x)/x) */\n\n      /* Split x */\n      double temp = x * HEX_40000000;\n      final double xa = x + temp - temp;\n      final double xb = x - xa;\n\n      /* Square it */\n      double ya = xa*xa;\n      double yb = xa*xb*2.0 + xb*xb;\n\n      /* Subtract from 1 */\n      ya = -ya;\n      yb = -yb;\n\n      double za = 1.0 + ya;\n      double zb = -(za - 1.0 - ya);\n\n      temp = za + yb;\nzb += ((za - za) + yb);\n      za = temp;\n\n      /* Square root */\n      double y = sqrt(za);\n      temp = y * HEX_40000000;\n      ya = y + temp - temp;\n      yb = y - ya;\n\n      /* Extend precision of sqrt */\n      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      /* Contribution of zb to sqrt */\n      yb += zb / (2.0*y);\n      y = ya+yb;\n      yb = -(y - ya - yb);\n\n      // Compute ratio r = y/x\n      double r = y/x;\n\n      // Did r overflow?\n      if (Double.isInfinite(r)) { // x is effectively zero\n          return Math.PI/2; // so return the appropriate value\n      }\n\n      double ra = doubleHighPart(r);\n      double rb = r - ra;\n\n      rb += (y - ra*xa - ra*xb - rb*xa - rb*xb) / x;  // Correct for rounding in division\n      rb += yb / x;  // Add in effect additional bits of sqrt.\n\n      temp = ra + rb;\n      rb = -(temp - ra - rb);\n      ra = temp;\n\n      return atan(ra, rb, x<0);\n    }",
          "49": "    public static double acos(double x) {\n      if (x != x) {\n          return Double.NaN;\n      }\n\n      if (x > 1.0 || x < -1.0) {\n          return Double.NaN;\n      }\n\n      if (x == -1.0) {\n          return Math.PI;\n      }\n\n      if (x == 1.0) {\n          return 0.0;\n      }\n\n      if (x == 0) {\n          return Math.PI/2.0;\n      }\n\n      /* Compute acos(x) = atan(sqrt(1-x*x)/x) */\n\n      /* Split x */\n      double temp = x * HEX_40000000;\n      final double xa = x + temp - temp;\n      final double xb = x - xa;\n\n      /* Square it */\n      double ya = xa*xa;\n      double yb = xa*xb*2.0 + xb*xb;\n\n      /* Subtract from 1 */\n      ya = -ya;\n      yb = -yb;\n\n      double za = 1.0 + ya;\n      double zb = -(za - 1.0 - ya);\n\n      temp = za + yb;\nzb += ((zb - yb) + za);\n      za = temp;\n\n      /* Square root */\n      double y = sqrt(za);\n      temp = y * HEX_40000000;\n      ya = y + temp - temp;\n      yb = y - ya;\n\n      /* Extend precision of sqrt */\n      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      /* Contribution of zb to sqrt */\n      yb += zb / (2.0*y);\n      y = ya+yb;\n      yb = -(y - ya - yb);\n\n      // Compute ratio r = y/x\n      double r = y/x;\n\n      // Did r overflow?\n      if (Double.isInfinite(r)) { // x is effectively zero\n          return Math.PI/2; // so return the appropriate value\n      }\n\n      double ra = doubleHighPart(r);\n      double rb = r - ra;\n\n      rb += (y - ra*xa - ra*xb - rb*xa - rb*xb) / x;  // Correct for rounding in division\n      rb += yb / x;  // Add in effect additional bits of sqrt.\n\n      temp = ra + rb;\n      rb = -(temp - ra - rb);\n      ra = temp;\n\n      return atan(ra, rb, x<0);\n    }",
          "50": "    public static double acos(double x) {\n      if (x != x) {\n          return Double.NaN;\n      }\n\n      if (x > 1.0 || x < -1.0) {\n          return Double.NaN;\n      }\n\n      if (x == -1.0) {\n          return Math.PI;\n      }\n\n      if (x == 1.0) {\n          return 0.0;\n      }\n\n      if (x == 0) {\n          return Math.PI/2.0;\n      }\n\n      /* Compute acos(x) = atan(sqrt(1-x*x)/x) */\n\n      /* Split x */\n      double temp = x * HEX_40000000;\n      final double xa = x + temp - temp;\n      final double xb = x - xa;\n\n      /* Square it */\n      double ya = xa*xa;\n      double yb = xa*xb*2.0 + xb*xb;\n\n      /* Subtract from 1 */\n      ya = -ya;\n      yb = -yb;\n\n      double za = 1.0 + ya;\n      double zb = -(za - 1.0 - ya);\n\n      temp = za + yb;\nzb += ((yb - za) + yb);\n      za = temp;\n\n      /* Square root */\n      double y = sqrt(za);\n      temp = y * HEX_40000000;\n      ya = y + temp - temp;\n      yb = y - ya;\n\n      /* Extend precision of sqrt */\n      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      /* Contribution of zb to sqrt */\n      yb += zb / (2.0*y);\n      y = ya+yb;\n      yb = -(y - ya - yb);\n\n      // Compute ratio r = y/x\n      double r = y/x;\n\n      // Did r overflow?\n      if (Double.isInfinite(r)) { // x is effectively zero\n          return Math.PI/2; // so return the appropriate value\n      }\n\n      double ra = doubleHighPart(r);\n      double rb = r - ra;\n\n      rb += (y - ra*xa - ra*xb - rb*xa - rb*xb) / x;  // Correct for rounding in division\n      rb += yb / x;  // Add in effect additional bits of sqrt.\n\n      temp = ra + rb;\n      rb = -(temp - ra - rb);\n      ra = temp;\n\n      return atan(ra, rb, x<0);\n    }",
          "51": "    public static double acos(double x) {\n      if (x != x) {\n          return Double.NaN;\n      }\n\n      if (x > 1.0 || x < -1.0) {\n          return Double.NaN;\n      }\n\n      if (x == -1.0) {\n          return Math.PI;\n      }\n\n      if (x == 1.0) {\n          return 0.0;\n      }\n\n      if (x == 0) {\n          return Math.PI/2.0;\n      }\n\n      /* Compute acos(x) = atan(sqrt(1-x*x)/x) */\n\n      /* Split x */\n      double temp = x * HEX_40000000;\n      final double xa = x + temp - temp;\n      final double xb = x - xa;\n\n      /* Square it */\n      double ya = xa*xa;\n      double yb = xa*xb*2.0 + xb*xb;\n\n      /* Subtract from 1 */\n      ya = -ya;\n      yb = -yb;\n\n      double za = 1.0 + ya;\n      double zb = -(za - 1.0 - ya);\n\n      temp = za + yb;\nzb += ((yb + za) + za);\n      za = temp;\n\n      /* Square root */\n      double y = sqrt(za);\n      temp = y * HEX_40000000;\n      ya = y + temp - temp;\n      yb = y - ya;\n\n      /* Extend precision of sqrt */\n      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      /* Contribution of zb to sqrt */\n      yb += zb / (2.0*y);\n      y = ya+yb;\n      yb = -(y - ya - yb);\n\n      // Compute ratio r = y/x\n      double r = y/x;\n\n      // Did r overflow?\n      if (Double.isInfinite(r)) { // x is effectively zero\n          return Math.PI/2; // so return the appropriate value\n      }\n\n      double ra = doubleHighPart(r);\n      double rb = r - ra;\n\n      rb += (y - ra*xa - ra*xb - rb*xa - rb*xb) / x;  // Correct for rounding in division\n      rb += yb / x;  // Add in effect additional bits of sqrt.\n\n      temp = ra + rb;\n      rb = -(temp - ra - rb);\n      ra = temp;\n\n      return atan(ra, rb, x<0);\n    }",
          "52": "    public static double acos(double x) {\n      if (x != x) {\n          return Double.NaN;\n      }\n\n      if (x > 1.0 || x < -1.0) {\n          return Double.NaN;\n      }\n\n      if (x == -1.0) {\n          return Math.PI;\n      }\n\n      if (x == 1.0) {\n          return 0.0;\n      }\n\n      if (x == 0) {\n          return Math.PI/2.0;\n      }\n\n      /* Compute acos(x) = atan(sqrt(1-x*x)/x) */\n\n      /* Split x */\n      double temp = x * HEX_40000000;\n      final double xa = x + temp - temp;\n      final double xb = x - xa;\n\n      /* Square it */\n      double ya = xa*xa;\n      double yb = xa*xb*2.0 + xb*xb;\n\n      /* Subtract from 1 */\n      ya = -ya;\n      yb = -yb;\n\n      double za = 1.0 + ya;\n      double zb = -(za - 1.0 - ya);\n\n      temp = za + yb;\nzb += ((zb + za) + za);\n      za = temp;\n\n      /* Square root */\n      double y = sqrt(za);\n      temp = y * HEX_40000000;\n      ya = y + temp - temp;\n      yb = y - ya;\n\n      /* Extend precision of sqrt */\n      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      /* Contribution of zb to sqrt */\n      yb += zb / (2.0*y);\n      y = ya+yb;\n      yb = -(y - ya - yb);\n\n      // Compute ratio r = y/x\n      double r = y/x;\n\n      // Did r overflow?\n      if (Double.isInfinite(r)) { // x is effectively zero\n          return Math.PI/2; // so return the appropriate value\n      }\n\n      double ra = doubleHighPart(r);\n      double rb = r - ra;\n\n      rb += (y - ra*xa - ra*xb - rb*xa - rb*xb) / x;  // Correct for rounding in division\n      rb += yb / x;  // Add in effect additional bits of sqrt.\n\n      temp = ra + rb;\n      rb = -(temp - ra - rb);\n      ra = temp;\n\n      return atan(ra, rb, x<0);\n    }",
          "53": "    public static double acos(double x) {\n      if (x != x) {\n          return Double.NaN;\n      }\n\n      if (x > 1.0 || x < -1.0) {\n          return Double.NaN;\n      }\n\n      if (x == -1.0) {\n          return Math.PI;\n      }\n\n      if (x == 1.0) {\n          return 0.0;\n      }\n\n      if (x == 0) {\n          return Math.PI/2.0;\n      }\n\n      /* Compute acos(x) = atan(sqrt(1-x*x)/x) */\n\n      /* Split x */\n      double temp = x * HEX_40000000;\n      final double xa = x + temp - temp;\n      final double xb = x - xa;\n\n      /* Square it */\n      double ya = xa*xa;\n      double yb = xa*xb*2.0 + xb*xb;\n\n      /* Subtract from 1 */\n      ya = -ya;\n      yb = -yb;\n\n      double za = 1.0 + ya;\n      double zb = -(za - 1.0 - ya);\n\n      temp = za + yb;\nzb += ((zb - za) + yb);\n      za = temp;\n\n      /* Square root */\n      double y = sqrt(za);\n      temp = y * HEX_40000000;\n      ya = y + temp - temp;\n      yb = y - ya;\n\n      /* Extend precision of sqrt */\n      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      /* Contribution of zb to sqrt */\n      yb += zb / (2.0*y);\n      y = ya+yb;\n      yb = -(y - ya - yb);\n\n      // Compute ratio r = y/x\n      double r = y/x;\n\n      // Did r overflow?\n      if (Double.isInfinite(r)) { // x is effectively zero\n          return Math.PI/2; // so return the appropriate value\n      }\n\n      double ra = doubleHighPart(r);\n      double rb = r - ra;\n\n      rb += (y - ra*xa - ra*xb - rb*xa - rb*xb) / x;  // Correct for rounding in division\n      rb += yb / x;  // Add in effect additional bits of sqrt.\n\n      temp = ra + rb;\n      rb = -(temp - ra - rb);\n      ra = temp;\n\n      return atan(ra, rb, x<0);\n    }",
          "54": "    public static double acos(double x) {\n      if (x != x) {\n          return Double.NaN;\n      }\n\n      if (x > 1.0 || x < -1.0) {\n          return Double.NaN;\n      }\n\n      if (x == -1.0) {\n          return Math.PI;\n      }\n\n      if (x == 1.0) {\n          return 0.0;\n      }\n\n      if (x == 0) {\n          return Math.PI/2.0;\n      }\n\n      /* Compute acos(x) = atan(sqrt(1-x*x)/x) */\n\n      /* Split x */\n      double temp = x * HEX_40000000;\n      final double xa = x + temp - temp;\n      final double xb = x - xa;\n\n      /* Square it */\n      double ya = xa*xa;\n      double yb = xa*xb*2.0 + xb*xb;\n\n      /* Subtract from 1 */\n      ya = -ya;\n      yb = -yb;\n\n      double za = 1.0 + ya;\n      double zb = -(za - 1.0 - ya);\n\n      temp = za + yb;\nzb += ((za + yb) + za);\n      za = temp;\n\n      /* Square root */\n      double y = sqrt(za);\n      temp = y * HEX_40000000;\n      ya = y + temp - temp;\n      yb = y - ya;\n\n      /* Extend precision of sqrt */\n      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      /* Contribution of zb to sqrt */\n      yb += zb / (2.0*y);\n      y = ya+yb;\n      yb = -(y - ya - yb);\n\n      // Compute ratio r = y/x\n      double r = y/x;\n\n      // Did r overflow?\n      if (Double.isInfinite(r)) { // x is effectively zero\n          return Math.PI/2; // so return the appropriate value\n      }\n\n      double ra = doubleHighPart(r);\n      double rb = r - ra;\n\n      rb += (y - ra*xa - ra*xb - rb*xa - rb*xb) / x;  // Correct for rounding in division\n      rb += yb / x;  // Add in effect additional bits of sqrt.\n\n      temp = ra + rb;\n      rb = -(temp - ra - rb);\n      ra = temp;\n\n      return atan(ra, rb, x<0);\n    }",
          "55": "    public static double acos(double x) {\n      if (x != x) {\n          return Double.NaN;\n      }\n\n      if (x > 1.0 || x < -1.0) {\n          return Double.NaN;\n      }\n\n      if (x == -1.0) {\n          return Math.PI;\n      }\n\n      if (x == 1.0) {\n          return 0.0;\n      }\n\n      if (x == 0) {\n          return Math.PI/2.0;\n      }\n\n      /* Compute acos(x) = atan(sqrt(1-x*x)/x) */\n\n      /* Split x */\n      double temp = x * HEX_40000000;\n      final double xa = x + temp - temp;\n      final double xb = x - xa;\n\n      /* Square it */\n      double ya = xa*xa;\n      double yb = xa*xb*2.0 + xb*xb;\n\n      /* Subtract from 1 */\n      ya = -ya;\n      yb = -yb;\n\n      double za = 1.0 + ya;\n      double zb = -(za - 1.0 - ya);\n\n      temp = za + yb;\nzb += ((za - yb) + yb);\n      za = temp;\n\n      /* Square root */\n      double y = sqrt(za);\n      temp = y * HEX_40000000;\n      ya = y + temp - temp;\n      yb = y - ya;\n\n      /* Extend precision of sqrt */\n      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      /* Contribution of zb to sqrt */\n      yb += zb / (2.0*y);\n      y = ya+yb;\n      yb = -(y - ya - yb);\n\n      // Compute ratio r = y/x\n      double r = y/x;\n\n      // Did r overflow?\n      if (Double.isInfinite(r)) { // x is effectively zero\n          return Math.PI/2; // so return the appropriate value\n      }\n\n      double ra = doubleHighPart(r);\n      double rb = r - ra;\n\n      rb += (y - ra*xa - ra*xb - rb*xa - rb*xb) / x;  // Correct for rounding in division\n      rb += yb / x;  // Add in effect additional bits of sqrt.\n\n      temp = ra + rb;\n      rb = -(temp - ra - rb);\n      ra = temp;\n\n      return atan(ra, rb, x<0);\n    }",
          "56": "    public static double acos(double x) {\n      if (x != x) {\n          return Double.NaN;\n      }\n\n      if (x > 1.0 || x < -1.0) {\n          return Double.NaN;\n      }\n\n      if (x == -1.0) {\n          return Math.PI;\n      }\n\n      if (x == 1.0) {\n          return 0.0;\n      }\n\n      if (x == 0) {\n          return Math.PI/2.0;\n      }\n\n      /* Compute acos(x) = atan(sqrt(1-x*x)/x) */\n\n      /* Split x */\n      double temp = x * HEX_40000000;\n      final double xa = x + temp - temp;\n      final double xb = x - xa;\n\n      /* Square it */\n      double ya = xa*xa;\n      double yb = xa*xb*2.0 + xb*xb;\n\n      /* Subtract from 1 */\n      ya = -ya;\n      yb = -yb;\n\n      double za = 1.0 + ya;\n      double zb = -(za - 1.0 - ya);\n\n      temp = za + yb;\nzb += ((yb - yb) + yb);\n      za = temp;\n\n      /* Square root */\n      double y = sqrt(za);\n      temp = y * HEX_40000000;\n      ya = y + temp - temp;\n      yb = y - ya;\n\n      /* Extend precision of sqrt */\n      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      /* Contribution of zb to sqrt */\n      yb += zb / (2.0*y);\n      y = ya+yb;\n      yb = -(y - ya - yb);\n\n      // Compute ratio r = y/x\n      double r = y/x;\n\n      // Did r overflow?\n      if (Double.isInfinite(r)) { // x is effectively zero\n          return Math.PI/2; // so return the appropriate value\n      }\n\n      double ra = doubleHighPart(r);\n      double rb = r - ra;\n\n      rb += (y - ra*xa - ra*xb - rb*xa - rb*xb) / x;  // Correct for rounding in division\n      rb += yb / x;  // Add in effect additional bits of sqrt.\n\n      temp = ra + rb;\n      rb = -(temp - ra - rb);\n      ra = temp;\n\n      return atan(ra, rb, x<0);\n    }",
          "57": "    public static double acos(double x) {\n      if (x != x) {\n          return Double.NaN;\n      }\n\n      if (x > 1.0 || x < -1.0) {\n          return Double.NaN;\n      }\n\n      if (x == -1.0) {\n          return Math.PI;\n      }\n\n      if (x == 1.0) {\n          return 0.0;\n      }\n\n      if (x == 0) {\n          return Math.PI/2.0;\n      }\n\n      /* Compute acos(x) = atan(sqrt(1-x*x)/x) */\n\n      /* Split x */\n      double temp = x * HEX_40000000;\n      final double xa = x + temp - temp;\n      final double xb = x - xa;\n\n      /* Square it */\n      double ya = xa*xa;\n      double yb = xa*xb*2.0 + xb*xb;\n\n      /* Subtract from 1 */\n      ya = -ya;\n      yb = -yb;\n\n      double za = 1.0 + ya;\n      double zb = -(za - 1.0 - ya);\n\n      temp = za + yb;\nzb += ((yb + yb) + za);\n      za = temp;\n\n      /* Square root */\n      double y = sqrt(za);\n      temp = y * HEX_40000000;\n      ya = y + temp - temp;\n      yb = y - ya;\n\n      /* Extend precision of sqrt */\n      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      /* Contribution of zb to sqrt */\n      yb += zb / (2.0*y);\n      y = ya+yb;\n      yb = -(y - ya - yb);\n\n      // Compute ratio r = y/x\n      double r = y/x;\n\n      // Did r overflow?\n      if (Double.isInfinite(r)) { // x is effectively zero\n          return Math.PI/2; // so return the appropriate value\n      }\n\n      double ra = doubleHighPart(r);\n      double rb = r - ra;\n\n      rb += (y - ra*xa - ra*xb - rb*xa - rb*xb) / x;  // Correct for rounding in division\n      rb += yb / x;  // Add in effect additional bits of sqrt.\n\n      temp = ra + rb;\n      rb = -(temp - ra - rb);\n      ra = temp;\n\n      return atan(ra, rb, x<0);\n    }",
          "58": "    public static double acos(double x) {\n      if (x != x) {\n          return Double.NaN;\n      }\n\n      if (x > 1.0 || x < -1.0) {\n          return Double.NaN;\n      }\n\n      if (x == -1.0) {\n          return Math.PI;\n      }\n\n      if (x == 1.0) {\n          return 0.0;\n      }\n\n      if (x == 0) {\n          return Math.PI/2.0;\n      }\n\n      /* Compute acos(x) = atan(sqrt(1-x*x)/x) */\n\n      /* Split x */\n      double temp = x * HEX_40000000;\n      final double xa = x + temp - temp;\n      final double xb = x - xa;\n\n      /* Square it */\n      double ya = xa*xa;\n      double yb = xa*xb*2.0 + xb*xb;\n\n      /* Subtract from 1 */\n      ya = -ya;\n      yb = -yb;\n\n      double za = 1.0 + ya;\n      double zb = -(za - 1.0 - ya);\n\n      temp = za + yb;\nzb += ((za + za) + yb);\n      za = temp;\n\n      /* Square root */\n      double y = sqrt(za);\n      temp = y * HEX_40000000;\n      ya = y + temp - temp;\n      yb = y - ya;\n\n      /* Extend precision of sqrt */\n      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      /* Contribution of zb to sqrt */\n      yb += zb / (2.0*y);\n      y = ya+yb;\n      yb = -(y - ya - yb);\n\n      // Compute ratio r = y/x\n      double r = y/x;\n\n      // Did r overflow?\n      if (Double.isInfinite(r)) { // x is effectively zero\n          return Math.PI/2; // so return the appropriate value\n      }\n\n      double ra = doubleHighPart(r);\n      double rb = r - ra;\n\n      rb += (y - ra*xa - ra*xb - rb*xa - rb*xb) / x;  // Correct for rounding in division\n      rb += yb / x;  // Add in effect additional bits of sqrt.\n\n      temp = ra + rb;\n      rb = -(temp - ra - rb);\n      ra = temp;\n\n      return atan(ra, rb, x<0);\n    }",
          "59": "    public static double acos(double x) {\n      if (x != x) {\n          return Double.NaN;\n      }\n\n      if (x > 1.0 || x < -1.0) {\n          return Double.NaN;\n      }\n\n      if (x == -1.0) {\n          return Math.PI;\n      }\n\n      if (x == 1.0) {\n          return 0.0;\n      }\n\n      if (x == 0) {\n          return Math.PI/2.0;\n      }\n\n      /* Compute acos(x) = atan(sqrt(1-x*x)/x) */\n\n      /* Split x */\n      double temp = x * HEX_40000000;\n      final double xa = x + temp - temp;\n      final double xb = x - xa;\n\n      /* Square it */\n      double ya = xa*xa;\n      double yb = xa*xb*2.0 + xb*xb;\n\n      /* Subtract from 1 */\n      ya = -ya;\n      yb = -yb;\n\n      double za = 1.0 + ya;\n      double zb = -(za - 1.0 - ya);\n\n      temp = za + yb;\nzb += ((zb - yb) + yb);\n      za = temp;\n\n      /* Square root */\n      double y = sqrt(za);\n      temp = y * HEX_40000000;\n      ya = y + temp - temp;\n      yb = y - ya;\n\n      /* Extend precision of sqrt */\n      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      /* Contribution of zb to sqrt */\n      yb += zb / (2.0*y);\n      y = ya+yb;\n      yb = -(y - ya - yb);\n\n      // Compute ratio r = y/x\n      double r = y/x;\n\n      // Did r overflow?\n      if (Double.isInfinite(r)) { // x is effectively zero\n          return Math.PI/2; // so return the appropriate value\n      }\n\n      double ra = doubleHighPart(r);\n      double rb = r - ra;\n\n      rb += (y - ra*xa - ra*xb - rb*xa - rb*xb) / x;  // Correct for rounding in division\n      rb += yb / x;  // Add in effect additional bits of sqrt.\n\n      temp = ra + rb;\n      rb = -(temp - ra - rb);\n      ra = temp;\n\n      return atan(ra, rb, x<0);\n    }",
          "60": "    public static double acos(double x) {\n      if (x != x) {\n          return Double.NaN;\n      }\n\n      if (x > 1.0 || x < -1.0) {\n          return Double.NaN;\n      }\n\n      if (x == -1.0) {\n          return Math.PI;\n      }\n\n      if (x == 1.0) {\n          return 0.0;\n      }\n\n      if (x == 0) {\n          return Math.PI/2.0;\n      }\n\n      /* Compute acos(x) = atan(sqrt(1-x*x)/x) */\n\n      /* Split x */\n      double temp = x * HEX_40000000;\n      final double xa = x + temp - temp;\n      final double xb = x - xa;\n\n      /* Square it */\n      double ya = xa*xa;\n      double yb = xa*xb*2.0 + xb*xb;\n\n      /* Subtract from 1 */\n      ya = -ya;\n      yb = -yb;\n\n      double za = 1.0 + ya;\n      double zb = -(za - 1.0 - ya);\n\n      temp = za + yb;\nzb += ((zb + yb) + za);\n      za = temp;\n\n      /* Square root */\n      double y = sqrt(za);\n      temp = y * HEX_40000000;\n      ya = y + temp - temp;\n      yb = y - ya;\n\n      /* Extend precision of sqrt */\n      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      /* Contribution of zb to sqrt */\n      yb += zb / (2.0*y);\n      y = ya+yb;\n      yb = -(y - ya - yb);\n\n      // Compute ratio r = y/x\n      double r = y/x;\n\n      // Did r overflow?\n      if (Double.isInfinite(r)) { // x is effectively zero\n          return Math.PI/2; // so return the appropriate value\n      }\n\n      double ra = doubleHighPart(r);\n      double rb = r - ra;\n\n      rb += (y - ra*xa - ra*xb - rb*xa - rb*xb) / x;  // Correct for rounding in division\n      rb += yb / x;  // Add in effect additional bits of sqrt.\n\n      temp = ra + rb;\n      rb = -(temp - ra - rb);\n      ra = temp;\n\n      return atan(ra, rb, x<0);\n    }",
          "61": "    public static double acos(double x) {\n      if (x != x) {\n          return Double.NaN;\n      }\n\n      if (x > 1.0 || x < -1.0) {\n          return Double.NaN;\n      }\n\n      if (x == -1.0) {\n          return Math.PI;\n      }\n\n      if (x == 1.0) {\n          return 0.0;\n      }\n\n      if (x == 0) {\n          return Math.PI/2.0;\n      }\n\n      /* Compute acos(x) = atan(sqrt(1-x*x)/x) */\n\n      /* Split x */\n      double temp = x * HEX_40000000;\n      final double xa = x + temp - temp;\n      final double xb = x - xa;\n\n      /* Square it */\n      double ya = xa*xa;\n      double yb = xa*xb*2.0 + xb*xb;\n\n      /* Subtract from 1 */\n      ya = -ya;\n      yb = -yb;\n\n      double za = 1.0 + ya;\n      double zb = -(za - 1.0 - ya);\n\n      temp = za + yb;\nzb = ((za - za) + za);\n      za = temp;\n\n      /* Square root */\n      double y = sqrt(za);\n      temp = y * HEX_40000000;\n      ya = y + temp - temp;\n      yb = y - ya;\n\n      /* Extend precision of sqrt */\n      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      /* Contribution of zb to sqrt */\n      yb += zb / (2.0*y);\n      y = ya+yb;\n      yb = -(y - ya - yb);\n\n      // Compute ratio r = y/x\n      double r = y/x;\n\n      // Did r overflow?\n      if (Double.isInfinite(r)) { // x is effectively zero\n          return Math.PI/2; // so return the appropriate value\n      }\n\n      double ra = doubleHighPart(r);\n      double rb = r - ra;\n\n      rb += (y - ra*xa - ra*xb - rb*xa - rb*xb) / x;  // Correct for rounding in division\n      rb += yb / x;  // Add in effect additional bits of sqrt.\n\n      temp = ra + rb;\n      rb = -(temp - ra - rb);\n      ra = temp;\n\n      return atan(ra, rb, x<0);\n    }",
          "62": "    public static double acos(double x) {\n      if (x != x) {\n          return Double.NaN;\n      }\n\n      if (x > 1.0 || x < -1.0) {\n          return Double.NaN;\n      }\n\n      if (x == -1.0) {\n          return Math.PI;\n      }\n\n      if (x == 1.0) {\n          return 0.0;\n      }\n\n      if (x == 0) {\n          return Math.PI/2.0;\n      }\n\n      /* Compute acos(x) = atan(sqrt(1-x*x)/x) */\n\n      /* Split x */\n      double temp = x * HEX_40000000;\n      final double xa = x + temp - temp;\n      final double xb = x - xa;\n\n      /* Square it */\n      double ya = xa*xa;\n      double yb = xa*xb*2.0 + xb*xb;\n\n      /* Subtract from 1 */\n      ya = -ya;\n      yb = -yb;\n\n      double za = 1.0 + ya;\n      double zb = -(za - 1.0 - ya);\n\n      temp = za + yb;\nzb = ((yb - za) + za);\n      za = temp;\n\n      /* Square root */\n      double y = sqrt(za);\n      temp = y * HEX_40000000;\n      ya = y + temp - temp;\n      yb = y - ya;\n\n      /* Extend precision of sqrt */\n      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      /* Contribution of zb to sqrt */\n      yb += zb / (2.0*y);\n      y = ya+yb;\n      yb = -(y - ya - yb);\n\n      // Compute ratio r = y/x\n      double r = y/x;\n\n      // Did r overflow?\n      if (Double.isInfinite(r)) { // x is effectively zero\n          return Math.PI/2; // so return the appropriate value\n      }\n\n      double ra = doubleHighPart(r);\n      double rb = r - ra;\n\n      rb += (y - ra*xa - ra*xb - rb*xa - rb*xb) / x;  // Correct for rounding in division\n      rb += yb / x;  // Add in effect additional bits of sqrt.\n\n      temp = ra + rb;\n      rb = -(temp - ra - rb);\n      ra = temp;\n\n      return atan(ra, rb, x<0);\n    }",
          "63": "    public static double acos(double x) {\n      if (x != x) {\n          return Double.NaN;\n      }\n\n      if (x > 1.0 || x < -1.0) {\n          return Double.NaN;\n      }\n\n      if (x == -1.0) {\n          return Math.PI;\n      }\n\n      if (x == 1.0) {\n          return 0.0;\n      }\n\n      if (x == 0) {\n          return Math.PI/2.0;\n      }\n\n      /* Compute acos(x) = atan(sqrt(1-x*x)/x) */\n\n      /* Split x */\n      double temp = x * HEX_40000000;\n      final double xa = x + temp - temp;\n      final double xb = x - xa;\n\n      /* Square it */\n      double ya = xa*xa;\n      double yb = xa*xb*2.0 + xb*xb;\n\n      /* Subtract from 1 */\n      ya = -ya;\n      yb = -yb;\n\n      double za = 1.0 + ya;\n      double zb = -(za - 1.0 - ya);\n\n      temp = za + yb;\nreturn;\n      zb += +(temp - za - yb);      za = temp;\n\n      /* Square root */\n      double y = sqrt(za);\n      temp = y * HEX_40000000;\n      ya = y + temp - temp;\n      yb = y - ya;\n\n      /* Extend precision of sqrt */\n      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      /* Contribution of zb to sqrt */\n      yb += zb / (2.0*y);\n      y = ya+yb;\n      yb = -(y - ya - yb);\n\n      // Compute ratio r = y/x\n      double r = y/x;\n\n      // Did r overflow?\n      if (Double.isInfinite(r)) { // x is effectively zero\n          return Math.PI/2; // so return the appropriate value\n      }\n\n      double ra = doubleHighPart(r);\n      double rb = r - ra;\n\n      rb += (y - ra*xa - ra*xb - rb*xa - rb*xb) / x;  // Correct for rounding in division\n      rb += yb / x;  // Add in effect additional bits of sqrt.\n\n      temp = ra + rb;\n      rb = -(temp - ra - rb);\n      ra = temp;\n\n      return atan(ra, rb, x<0);\n    }",
          "64": "    public static double acos(double x) {\n      if (x != x) {\n          return Double.NaN;\n      }\n\n      if (x > 1.0 || x < -1.0) {\n          return Double.NaN;\n      }\n\n      if (x == -1.0) {\n          return Math.PI;\n      }\n\n      if (x == 1.0) {\n          return 0.0;\n      }\n\n      if (x == 0) {\n          return Math.PI/2.0;\n      }\n\n      /* Compute acos(x) = atan(sqrt(1-x*x)/x) */\n\n      /* Split x */\n      double temp = x * HEX_40000000;\n      final double xa = x + temp - temp;\n      final double xb = x - xa;\n\n      /* Square it */\n      double ya = xa*xa;\n      double yb = xa*xb*2.0 + xb*xb;\n\n      /* Subtract from 1 */\n      ya = -ya;\n      yb = -yb;\n\n      double za = 1.0 + ya;\n      double zb = -(za - 1.0 - ya);\n\n      temp = za + yb;\n      zb += +(temp - za - yb);      za = temp;\n\n      /* Square root */\n      double y = sqrt(za);\n      temp = y * HEX_40000000;\n      ya = y + temp - temp;\n      yb = y - ya;\n\n      /* Extend precision of sqrt */\n      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      /* Contribution of zb to sqrt */\n      yb += zb / (2.0*y);\n      y = ya+yb;\n      yb = -(y - ya - yb);\n\n      // Compute ratio r = y/x\n      double r = y/x;\n\n      // Did r overflow?\n      if (Double.isInfinite(r)) { // x is effectively zero\n          return Math.PI/2; // so return the appropriate value\n      }\n\n      double ra = doubleHighPart(r);\n      double rb = r - ra;\n\n      rb += (y - ra*xa - ra*xb - rb*xa - rb*xb) / x;  // Correct for rounding in division\n      rb += yb / x;  // Add in effect additional bits of sqrt.\n\n      temp = ra + rb;\n      rb = -(temp - ra - rb);\n      ra = temp;\n\n      return atan(ra, rb, x<0);\n    }"
}