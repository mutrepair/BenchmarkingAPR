{
          "0": "    public static double tanh(double x) {\n      boolean negate = false;\n\n      if (x != x) {\n          return x;\n      }\n\n      // tanh[z] = sinh[z] / cosh[z]\n      // = (exp(z) - exp(-z)) / (exp(z) + exp(-z))\n      // = (exp(2x) - 1) / (exp(2x) + 1)\n\n      // for magnitude > 20, sinh[z] == cosh[z] in double precision\n\n      if (x > 20.0) {\n          return 1.0;\n      }\n\n      if (x < -20) {\n          return -1.0;\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n      if (x >= 0.5) {\n          double hiPrec[] = new double[2];\n          // tanh(x) = (exp(2x) - 1) / (exp(2x) + 1)\n          exp(x*2.0, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\ndouble yb = ((ya - hiPrec[0]) - hiPrec[0]);\n\n          /* Numerator */\n          double na = -1.0 + ya;\n          double nb = -(na + 1.0 - ya);\n          double temp = na + yb;\n          nb += -(temp - na - yb);\n          na = temp;\n\n          /* Denominator */\n          double da = 1.0 + ya;\n          double db = -(da - 1.0 - ya);\n          temp = da + yb;\n          db += -(temp - da - yb);\n          da = temp;\n\n          temp = da * HEX_40000000;\n          double daa = da + temp - temp;\n          double dab = da - daa;\n\n          // ratio = na/da\n          double ratio = na/da;\n          temp = ratio * HEX_40000000;\n          double ratioa = ratio + temp - temp;\n          double ratiob = ratio - ratioa;\n\n          // Correct for rounding in division\n          ratiob += (na - daa*ratioa - daa*ratiob - dab*ratioa - dab*ratiob) / da;\n\n          // Account for nb\n          ratiob += nb / da;\n          // Account for db\n          ratiob += -db * na / da / da;\n\n          result = ratioa + ratiob;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          // tanh(x) = expm1(2x) / (expm1(2x) + 2)\n          expm1(x*2.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Numerator */\n          double na = ya;\n          double nb = yb;\n\n          /* Denominator */\n          double da = 2.0 + ya;\n          double db = -(da - 2.0 - ya);\n          double temp = da + yb;\n          db += -(temp - da - yb);\n          da = temp;\n\n          temp = da * HEX_40000000;\n          double daa = da + temp - temp;\n          double dab = da - daa;\n\n          // ratio = na/da\n          double ratio = na/da;\n          temp = ratio * HEX_40000000;\n          double ratioa = ratio + temp - temp;\n          double ratiob = ratio - ratioa;\n\n          // Correct for rounding in division\n          ratiob += (na - daa*ratioa - daa*ratiob - dab*ratioa - dab*ratiob) / da;\n\n          // Account for nb\n          ratiob += nb / da;\n          // Account for db\n          ratiob += -db * na / da / da;\n\n          result = ratioa + ratiob;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "1": "    public static double tanh(double x) {\n      boolean negate = false;\n\n      if (x != x) {\n          return x;\n      }\n\n      // tanh[z] = sinh[z] / cosh[z]\n      // = (exp(z) - exp(-z)) / (exp(z) + exp(-z))\n      // = (exp(2x) - 1) / (exp(2x) + 1)\n\n      // for magnitude > 20, sinh[z] == cosh[z] in double precision\n\n      if (x > 20.0) {\n          return 1.0;\n      }\n\n      if (x < -20) {\n          return -1.0;\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n      if (x >= 0.5) {\n          double hiPrec[] = new double[2];\n          // tanh(x) = (exp(2x) - 1) / (exp(2x) + 1)\n          exp(x*2.0, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\ndouble yb = ((ya - hiPrec[0]) - hiPrec[1]);\n\n          /* Numerator */\n          double na = -1.0 + ya;\n          double nb = -(na + 1.0 - ya);\n          double temp = na + yb;\n          nb += -(temp - na - yb);\n          na = temp;\n\n          /* Denominator */\n          double da = 1.0 + ya;\n          double db = -(da - 1.0 - ya);\n          temp = da + yb;\n          db += -(temp - da - yb);\n          da = temp;\n\n          temp = da * HEX_40000000;\n          double daa = da + temp - temp;\n          double dab = da - daa;\n\n          // ratio = na/da\n          double ratio = na/da;\n          temp = ratio * HEX_40000000;\n          double ratioa = ratio + temp - temp;\n          double ratiob = ratio - ratioa;\n\n          // Correct for rounding in division\n          ratiob += (na - daa*ratioa - daa*ratiob - dab*ratioa - dab*ratiob) / da;\n\n          // Account for nb\n          ratiob += nb / da;\n          // Account for db\n          ratiob += -db * na / da / da;\n\n          result = ratioa + ratiob;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          // tanh(x) = expm1(2x) / (expm1(2x) + 2)\n          expm1(x*2.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Numerator */\n          double na = ya;\n          double nb = yb;\n\n          /* Denominator */\n          double da = 2.0 + ya;\n          double db = -(da - 2.0 - ya);\n          double temp = da + yb;\n          db += -(temp - da - yb);\n          da = temp;\n\n          temp = da * HEX_40000000;\n          double daa = da + temp - temp;\n          double dab = da - daa;\n\n          // ratio = na/da\n          double ratio = na/da;\n          temp = ratio * HEX_40000000;\n          double ratioa = ratio + temp - temp;\n          double ratiob = ratio - ratioa;\n\n          // Correct for rounding in division\n          ratiob += (na - daa*ratioa - daa*ratiob - dab*ratioa - dab*ratiob) / da;\n\n          // Account for nb\n          ratiob += nb / da;\n          // Account for db\n          ratiob += -db * na / da / da;\n\n          result = ratioa + ratiob;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "2": "    public static double tanh(double x) {\n      boolean negate = false;\n\n      if (x != x) {\n          return x;\n      }\n\n      // tanh[z] = sinh[z] / cosh[z]\n      // = (exp(z) - exp(-z)) / (exp(z) + exp(-z))\n      // = (exp(2x) - 1) / (exp(2x) + 1)\n\n      // for magnitude > 20, sinh[z] == cosh[z] in double precision\n\n      if (x > 20.0) {\n          return 1.0;\n      }\n\n      if (x < -20) {\n          return -1.0;\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n      if (x >= 0.5) {\n          double hiPrec[] = new double[2];\n          // tanh(x) = (exp(2x) - 1) / (exp(2x) + 1)\n          exp(x*2.0, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\ndouble yb = ((ya - hiPrec[0]) - hiPrec);\n\n          /* Numerator */\n          double na = -1.0 + ya;\n          double nb = -(na + 1.0 - ya);\n          double temp = na + yb;\n          nb += -(temp - na - yb);\n          na = temp;\n\n          /* Denominator */\n          double da = 1.0 + ya;\n          double db = -(da - 1.0 - ya);\n          temp = da + yb;\n          db += -(temp - da - yb);\n          da = temp;\n\n          temp = da * HEX_40000000;\n          double daa = da + temp - temp;\n          double dab = da - daa;\n\n          // ratio = na/da\n          double ratio = na/da;\n          temp = ratio * HEX_40000000;\n          double ratioa = ratio + temp - temp;\n          double ratiob = ratio - ratioa;\n\n          // Correct for rounding in division\n          ratiob += (na - daa*ratioa - daa*ratiob - dab*ratioa - dab*ratiob) / da;\n\n          // Account for nb\n          ratiob += nb / da;\n          // Account for db\n          ratiob += -db * na / da / da;\n\n          result = ratioa + ratiob;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          // tanh(x) = expm1(2x) / (expm1(2x) + 2)\n          expm1(x*2.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Numerator */\n          double na = ya;\n          double nb = yb;\n\n          /* Denominator */\n          double da = 2.0 + ya;\n          double db = -(da - 2.0 - ya);\n          double temp = da + yb;\n          db += -(temp - da - yb);\n          da = temp;\n\n          temp = da * HEX_40000000;\n          double daa = da + temp - temp;\n          double dab = da - daa;\n\n          // ratio = na/da\n          double ratio = na/da;\n          temp = ratio * HEX_40000000;\n          double ratioa = ratio + temp - temp;\n          double ratiob = ratio - ratioa;\n\n          // Correct for rounding in division\n          ratiob += (na - daa*ratioa - daa*ratiob - dab*ratioa - dab*ratiob) / da;\n\n          // Account for nb\n          ratiob += nb / da;\n          // Account for db\n          ratiob += -db * na / da / da;\n\n          result = ratioa + ratiob;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "3": "    public static double tanh(double x) {\n      boolean negate = false;\n\n      if (x != x) {\n          return x;\n      }\n\n      // tanh[z] = sinh[z] / cosh[z]\n      // = (exp(z) - exp(-z)) / (exp(z) + exp(-z))\n      // = (exp(2x) - 1) / (exp(2x) + 1)\n\n      // for magnitude > 20, sinh[z] == cosh[z] in double precision\n\n      if (x > 20.0) {\n          return 1.0;\n      }\n\n      if (x < -20) {\n          return -1.0;\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n      if (x >= 0.5) {\n          double hiPrec[] = new double[2];\n          // tanh(x) = (exp(2x) - 1) / (exp(2x) + 1)\n          exp(x*2.0, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\ndouble yb = ((ya - hiPrec[1]) - hiPrec[1]);\n\n          /* Numerator */\n          double na = -1.0 + ya;\n          double nb = -(na + 1.0 - ya);\n          double temp = na + yb;\n          nb += -(temp - na - yb);\n          na = temp;\n\n          /* Denominator */\n          double da = 1.0 + ya;\n          double db = -(da - 1.0 - ya);\n          temp = da + yb;\n          db += -(temp - da - yb);\n          da = temp;\n\n          temp = da * HEX_40000000;\n          double daa = da + temp - temp;\n          double dab = da - daa;\n\n          // ratio = na/da\n          double ratio = na/da;\n          temp = ratio * HEX_40000000;\n          double ratioa = ratio + temp - temp;\n          double ratiob = ratio - ratioa;\n\n          // Correct for rounding in division\n          ratiob += (na - daa*ratioa - daa*ratiob - dab*ratioa - dab*ratiob) / da;\n\n          // Account for nb\n          ratiob += nb / da;\n          // Account for db\n          ratiob += -db * na / da / da;\n\n          result = ratioa + ratiob;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          // tanh(x) = expm1(2x) / (expm1(2x) + 2)\n          expm1(x*2.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Numerator */\n          double na = ya;\n          double nb = yb;\n\n          /* Denominator */\n          double da = 2.0 + ya;\n          double db = -(da - 2.0 - ya);\n          double temp = da + yb;\n          db += -(temp - da - yb);\n          da = temp;\n\n          temp = da * HEX_40000000;\n          double daa = da + temp - temp;\n          double dab = da - daa;\n\n          // ratio = na/da\n          double ratio = na/da;\n          temp = ratio * HEX_40000000;\n          double ratioa = ratio + temp - temp;\n          double ratiob = ratio - ratioa;\n\n          // Correct for rounding in division\n          ratiob += (na - daa*ratioa - daa*ratiob - dab*ratioa - dab*ratiob) / da;\n\n          // Account for nb\n          ratiob += nb / da;\n          // Account for db\n          ratiob += -db * na / da / da;\n\n          result = ratioa + ratiob;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "4": "    public static double tanh(double x) {\n      boolean negate = false;\n\n      if (x != x) {\n          return x;\n      }\n\n      // tanh[z] = sinh[z] / cosh[z]\n      // = (exp(z) - exp(-z)) / (exp(z) + exp(-z))\n      // = (exp(2x) - 1) / (exp(2x) + 1)\n\n      // for magnitude > 20, sinh[z] == cosh[z] in double precision\n\n      if (x > 20.0) {\n          return 1.0;\n      }\n\n      if (x < -20) {\n          return -1.0;\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n      if (x >= 0.5) {\n          double hiPrec[] = new double[2];\n          // tanh(x) = (exp(2x) - 1) / (exp(2x) + 1)\n          exp(x*2.0, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\ndouble yb = ((ya - hiPrec[0]) - );\n\n          /* Numerator */\n          double na = -1.0 + ya;\n          double nb = -(na + 1.0 - ya);\n          double temp = na + yb;\n          nb += -(temp - na - yb);\n          na = temp;\n\n          /* Denominator */\n          double da = 1.0 + ya;\n          double db = -(da - 1.0 - ya);\n          temp = da + yb;\n          db += -(temp - da - yb);\n          da = temp;\n\n          temp = da * HEX_40000000;\n          double daa = da + temp - temp;\n          double dab = da - daa;\n\n          // ratio = na/da\n          double ratio = na/da;\n          temp = ratio * HEX_40000000;\n          double ratioa = ratio + temp - temp;\n          double ratiob = ratio - ratioa;\n\n          // Correct for rounding in division\n          ratiob += (na - daa*ratioa - daa*ratiob - dab*ratioa - dab*ratiob) / da;\n\n          // Account for nb\n          ratiob += nb / da;\n          // Account for db\n          ratiob += -db * na / da / da;\n\n          result = ratioa + ratiob;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          // tanh(x) = expm1(2x) / (expm1(2x) + 2)\n          expm1(x*2.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Numerator */\n          double na = ya;\n          double nb = yb;\n\n          /* Denominator */\n          double da = 2.0 + ya;\n          double db = -(da - 2.0 - ya);\n          double temp = da + yb;\n          db += -(temp - da - yb);\n          da = temp;\n\n          temp = da * HEX_40000000;\n          double daa = da + temp - temp;\n          double dab = da - daa;\n\n          // ratio = na/da\n          double ratio = na/da;\n          temp = ratio * HEX_40000000;\n          double ratioa = ratio + temp - temp;\n          double ratiob = ratio - ratioa;\n\n          // Correct for rounding in division\n          ratiob += (na - daa*ratioa - daa*ratiob - dab*ratioa - dab*ratiob) / da;\n\n          // Account for nb\n          ratiob += nb / da;\n          // Account for db\n          ratiob += -db * na / da / da;\n\n          result = ratioa + ratiob;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "5": "    public static double tanh(double x) {\n      boolean negate = false;\n\n      if (x != x) {\n          return x;\n      }\n\n      // tanh[z] = sinh[z] / cosh[z]\n      // = (exp(z) - exp(-z)) / (exp(z) + exp(-z))\n      // = (exp(2x) - 1) / (exp(2x) + 1)\n\n      // for magnitude > 20, sinh[z] == cosh[z] in double precision\n\n      if (x > 20.0) {\n          return 1.0;\n      }\n\n      if (x < -20) {\n          return -1.0;\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n      if (x >= 0.5) {\n          double hiPrec[] = new double[2];\n          // tanh(x) = (exp(2x) - 1) / (exp(2x) + 1)\n          exp(x*2.0, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\ndouble yb = ((ya - hiPrec) - hiPrec[1]);\n\n          /* Numerator */\n          double na = -1.0 + ya;\n          double nb = -(na + 1.0 - ya);\n          double temp = na + yb;\n          nb += -(temp - na - yb);\n          na = temp;\n\n          /* Denominator */\n          double da = 1.0 + ya;\n          double db = -(da - 1.0 - ya);\n          temp = da + yb;\n          db += -(temp - da - yb);\n          da = temp;\n\n          temp = da * HEX_40000000;\n          double daa = da + temp - temp;\n          double dab = da - daa;\n\n          // ratio = na/da\n          double ratio = na/da;\n          temp = ratio * HEX_40000000;\n          double ratioa = ratio + temp - temp;\n          double ratiob = ratio - ratioa;\n\n          // Correct for rounding in division\n          ratiob += (na - daa*ratioa - daa*ratiob - dab*ratioa - dab*ratiob) / da;\n\n          // Account for nb\n          ratiob += nb / da;\n          // Account for db\n          ratiob += -db * na / da / da;\n\n          result = ratioa + ratiob;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          // tanh(x) = expm1(2x) / (expm1(2x) + 2)\n          expm1(x*2.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Numerator */\n          double na = ya;\n          double nb = yb;\n\n          /* Denominator */\n          double da = 2.0 + ya;\n          double db = -(da - 2.0 - ya);\n          double temp = da + yb;\n          db += -(temp - da - yb);\n          da = temp;\n\n          temp = da * HEX_40000000;\n          double daa = da + temp - temp;\n          double dab = da - daa;\n\n          // ratio = na/da\n          double ratio = na/da;\n          temp = ratio * HEX_40000000;\n          double ratioa = ratio + temp - temp;\n          double ratiob = ratio - ratioa;\n\n          // Correct for rounding in division\n          ratiob += (na - daa*ratioa - daa*ratiob - dab*ratioa - dab*ratiob) / da;\n\n          // Account for nb\n          ratiob += nb / da;\n          // Account for db\n          ratiob += -db * na / da / da;\n\n          result = ratioa + ratiob;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "6": "    public static double tanh(double x) {\n      boolean negate = false;\n\n      if (x != x) {\n          return x;\n      }\n\n      // tanh[z] = sinh[z] / cosh[z]\n      // = (exp(z) - exp(-z)) / (exp(z) + exp(-z))\n      // = (exp(2x) - 1) / (exp(2x) + 1)\n\n      // for magnitude > 20, sinh[z] == cosh[z] in double precision\n\n      if (x > 20.0) {\n          return 1.0;\n      }\n\n      if (x < -20) {\n          return -1.0;\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n      if (x >= 0.5) {\n          double hiPrec[] = new double[2];\n          // tanh(x) = (exp(2x) - 1) / (exp(2x) + 1)\n          exp(x*2.0, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\ndouble yb = ((ya - hiPrec[0]) - hiPrec[hiPrec]);\n\n          /* Numerator */\n          double na = -1.0 + ya;\n          double nb = -(na + 1.0 - ya);\n          double temp = na + yb;\n          nb += -(temp - na - yb);\n          na = temp;\n\n          /* Denominator */\n          double da = 1.0 + ya;\n          double db = -(da - 1.0 - ya);\n          temp = da + yb;\n          db += -(temp - da - yb);\n          da = temp;\n\n          temp = da * HEX_40000000;\n          double daa = da + temp - temp;\n          double dab = da - daa;\n\n          // ratio = na/da\n          double ratio = na/da;\n          temp = ratio * HEX_40000000;\n          double ratioa = ratio + temp - temp;\n          double ratiob = ratio - ratioa;\n\n          // Correct for rounding in division\n          ratiob += (na - daa*ratioa - daa*ratiob - dab*ratioa - dab*ratiob) / da;\n\n          // Account for nb\n          ratiob += nb / da;\n          // Account for db\n          ratiob += -db * na / da / da;\n\n          result = ratioa + ratiob;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          // tanh(x) = expm1(2x) / (expm1(2x) + 2)\n          expm1(x*2.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Numerator */\n          double na = ya;\n          double nb = yb;\n\n          /* Denominator */\n          double da = 2.0 + ya;\n          double db = -(da - 2.0 - ya);\n          double temp = da + yb;\n          db += -(temp - da - yb);\n          da = temp;\n\n          temp = da * HEX_40000000;\n          double daa = da + temp - temp;\n          double dab = da - daa;\n\n          // ratio = na/da\n          double ratio = na/da;\n          temp = ratio * HEX_40000000;\n          double ratioa = ratio + temp - temp;\n          double ratiob = ratio - ratioa;\n\n          // Correct for rounding in division\n          ratiob += (na - daa*ratioa - daa*ratiob - dab*ratioa - dab*ratiob) / da;\n\n          // Account for nb\n          ratiob += nb / da;\n          // Account for db\n          ratiob += -db * na / da / da;\n\n          result = ratioa + ratiob;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "7": "    public static double tanh(double x) {\n      boolean negate = false;\n\n      if (x != x) {\n          return x;\n      }\n\n      // tanh[z] = sinh[z] / cosh[z]\n      // = (exp(z) - exp(-z)) / (exp(z) + exp(-z))\n      // = (exp(2x) - 1) / (exp(2x) + 1)\n\n      // for magnitude > 20, sinh[z] == cosh[z] in double precision\n\n      if (x > 20.0) {\n          return 1.0;\n      }\n\n      if (x < -20) {\n          return -1.0;\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n      if (x >= 0.5) {\n          double hiPrec[] = new double[2];\n          // tanh(x) = (exp(2x) - 1) / (exp(2x) + 1)\n          exp(x*2.0, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\nlong yb = ((ya - hiPrec[0]) - hiPrec[1]);\n\n          /* Numerator */\n          double na = -1.0 + ya;\n          double nb = -(na + 1.0 - ya);\n          double temp = na + yb;\n          nb += -(temp - na - yb);\n          na = temp;\n\n          /* Denominator */\n          double da = 1.0 + ya;\n          double db = -(da - 1.0 - ya);\n          temp = da + yb;\n          db += -(temp - da - yb);\n          da = temp;\n\n          temp = da * HEX_40000000;\n          double daa = da + temp - temp;\n          double dab = da - daa;\n\n          // ratio = na/da\n          double ratio = na/da;\n          temp = ratio * HEX_40000000;\n          double ratioa = ratio + temp - temp;\n          double ratiob = ratio - ratioa;\n\n          // Correct for rounding in division\n          ratiob += (na - daa*ratioa - daa*ratiob - dab*ratioa - dab*ratiob) / da;\n\n          // Account for nb\n          ratiob += nb / da;\n          // Account for db\n          ratiob += -db * na / da / da;\n\n          result = ratioa + ratiob;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          // tanh(x) = expm1(2x) / (expm1(2x) + 2)\n          expm1(x*2.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Numerator */\n          double na = ya;\n          double nb = yb;\n\n          /* Denominator */\n          double da = 2.0 + ya;\n          double db = -(da - 2.0 - ya);\n          double temp = da + yb;\n          db += -(temp - da - yb);\n          da = temp;\n\n          temp = da * HEX_40000000;\n          double daa = da + temp - temp;\n          double dab = da - daa;\n\n          // ratio = na/da\n          double ratio = na/da;\n          temp = ratio * HEX_40000000;\n          double ratioa = ratio + temp - temp;\n          double ratiob = ratio - ratioa;\n\n          // Correct for rounding in division\n          ratiob += (na - daa*ratioa - daa*ratiob - dab*ratioa - dab*ratiob) / da;\n\n          // Account for nb\n          ratiob += nb / da;\n          // Account for db\n          ratiob += -db * na / da / da;\n\n          result = ratioa + ratiob;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "8": "    public static double tanh(double x) {\n      boolean negate = false;\n\n      if (x != x) {\n          return x;\n      }\n\n      // tanh[z] = sinh[z] / cosh[z]\n      // = (exp(z) - exp(-z)) / (exp(z) + exp(-z))\n      // = (exp(2x) - 1) / (exp(2x) + 1)\n\n      // for magnitude > 20, sinh[z] == cosh[z] in double precision\n\n      if (x > 20.0) {\n          return 1.0;\n      }\n\n      if (x < -20) {\n          return -1.0;\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n      if (x >= 0.5) {\n          double hiPrec[] = new double[2];\n          // tanh(x) = (exp(2x) - 1) / (exp(2x) + 1)\n          exp(x*2.0, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\ndouble  = ((ya - hiPrec[0]) - hiPrec[1]);\n\n          /* Numerator */\n          double na = -1.0 + ya;\n          double nb = -(na + 1.0 - ya);\n          double temp = na + yb;\n          nb += -(temp - na - yb);\n          na = temp;\n\n          /* Denominator */\n          double da = 1.0 + ya;\n          double db = -(da - 1.0 - ya);\n          temp = da + yb;\n          db += -(temp - da - yb);\n          da = temp;\n\n          temp = da * HEX_40000000;\n          double daa = da + temp - temp;\n          double dab = da - daa;\n\n          // ratio = na/da\n          double ratio = na/da;\n          temp = ratio * HEX_40000000;\n          double ratioa = ratio + temp - temp;\n          double ratiob = ratio - ratioa;\n\n          // Correct for rounding in division\n          ratiob += (na - daa*ratioa - daa*ratiob - dab*ratioa - dab*ratiob) / da;\n\n          // Account for nb\n          ratiob += nb / da;\n          // Account for db\n          ratiob += -db * na / da / da;\n\n          result = ratioa + ratiob;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          // tanh(x) = expm1(2x) / (expm1(2x) + 2)\n          expm1(x*2.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Numerator */\n          double na = ya;\n          double nb = yb;\n\n          /* Denominator */\n          double da = 2.0 + ya;\n          double db = -(da - 2.0 - ya);\n          double temp = da + yb;\n          db += -(temp - da - yb);\n          da = temp;\n\n          temp = da * HEX_40000000;\n          double daa = da + temp - temp;\n          double dab = da - daa;\n\n          // ratio = na/da\n          double ratio = na/da;\n          temp = ratio * HEX_40000000;\n          double ratioa = ratio + temp - temp;\n          double ratiob = ratio - ratioa;\n\n          // Correct for rounding in division\n          ratiob += (na - daa*ratioa - daa*ratiob - dab*ratioa - dab*ratiob) / da;\n\n          // Account for nb\n          ratiob += nb / da;\n          // Account for db\n          ratiob += -db * na / da / da;\n\n          result = ratioa + ratiob;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "9": "    public static double tanh(double x) {\n      boolean negate = false;\n\n      if (x != x) {\n          return x;\n      }\n\n      // tanh[z] = sinh[z] / cosh[z]\n      // = (exp(z) - exp(-z)) / (exp(z) + exp(-z))\n      // = (exp(2x) - 1) / (exp(2x) + 1)\n\n      // for magnitude > 20, sinh[z] == cosh[z] in double precision\n\n      if (x > 20.0) {\n          return 1.0;\n      }\n\n      if (x < -20) {\n          return -1.0;\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n      if (x >= 0.5) {\n          double hiPrec[] = new double[2];\n          // tanh(x) = (exp(2x) - 1) / (exp(2x) + 1)\n          exp(x*2.0, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\ndouble yb = ((ya - ) - hiPrec[1]);\n\n          /* Numerator */\n          double na = -1.0 + ya;\n          double nb = -(na + 1.0 - ya);\n          double temp = na + yb;\n          nb += -(temp - na - yb);\n          na = temp;\n\n          /* Denominator */\n          double da = 1.0 + ya;\n          double db = -(da - 1.0 - ya);\n          temp = da + yb;\n          db += -(temp - da - yb);\n          da = temp;\n\n          temp = da * HEX_40000000;\n          double daa = da + temp - temp;\n          double dab = da - daa;\n\n          // ratio = na/da\n          double ratio = na/da;\n          temp = ratio * HEX_40000000;\n          double ratioa = ratio + temp - temp;\n          double ratiob = ratio - ratioa;\n\n          // Correct for rounding in division\n          ratiob += (na - daa*ratioa - daa*ratiob - dab*ratioa - dab*ratiob) / da;\n\n          // Account for nb\n          ratiob += nb / da;\n          // Account for db\n          ratiob += -db * na / da / da;\n\n          result = ratioa + ratiob;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          // tanh(x) = expm1(2x) / (expm1(2x) + 2)\n          expm1(x*2.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Numerator */\n          double na = ya;\n          double nb = yb;\n\n          /* Denominator */\n          double da = 2.0 + ya;\n          double db = -(da - 2.0 - ya);\n          double temp = da + yb;\n          db += -(temp - da - yb);\n          da = temp;\n\n          temp = da * HEX_40000000;\n          double daa = da + temp - temp;\n          double dab = da - daa;\n\n          // ratio = na/da\n          double ratio = na/da;\n          temp = ratio * HEX_40000000;\n          double ratioa = ratio + temp - temp;\n          double ratiob = ratio - ratioa;\n\n          // Correct for rounding in division\n          ratiob += (na - daa*ratioa - daa*ratiob - dab*ratioa - dab*ratiob) / da;\n\n          // Account for nb\n          ratiob += nb / da;\n          // Account for db\n          ratiob += -db * na / da / da;\n\n          result = ratioa + ratiob;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "10": "    public static double tanh(double x) {\n      boolean negate = false;\n\n      if (x != x) {\n          return x;\n      }\n\n      // tanh[z] = sinh[z] / cosh[z]\n      // = (exp(z) - exp(-z)) / (exp(z) + exp(-z))\n      // = (exp(2x) - 1) / (exp(2x) + 1)\n\n      // for magnitude > 20, sinh[z] == cosh[z] in double precision\n\n      if (x > 20.0) {\n          return 1.0;\n      }\n\n      if (x < -20) {\n          return -1.0;\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n      if (x >= 0.5) {\n          double hiPrec[] = new double[2];\n          // tanh(x) = (exp(2x) - 1) / (exp(2x) + 1)\n          exp(x*2.0, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\ndouble yb = ((ya - hiPrec[0]) + hiPrec[1]);\n\n          /* Numerator */\n          double na = -1.0 + ya;\n          double nb = -(na + 1.0 - ya);\n          double temp = na + yb;\n          nb += -(temp - na - yb);\n          na = temp;\n\n          /* Denominator */\n          double da = 1.0 + ya;\n          double db = -(da - 1.0 - ya);\n          temp = da + yb;\n          db += -(temp - da - yb);\n          da = temp;\n\n          temp = da * HEX_40000000;\n          double daa = da + temp - temp;\n          double dab = da - daa;\n\n          // ratio = na/da\n          double ratio = na/da;\n          temp = ratio * HEX_40000000;\n          double ratioa = ratio + temp - temp;\n          double ratiob = ratio - ratioa;\n\n          // Correct for rounding in division\n          ratiob += (na - daa*ratioa - daa*ratiob - dab*ratioa - dab*ratiob) / da;\n\n          // Account for nb\n          ratiob += nb / da;\n          // Account for db\n          ratiob += -db * na / da / da;\n\n          result = ratioa + ratiob;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          // tanh(x) = expm1(2x) / (expm1(2x) + 2)\n          expm1(x*2.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Numerator */\n          double na = ya;\n          double nb = yb;\n\n          /* Denominator */\n          double da = 2.0 + ya;\n          double db = -(da - 2.0 - ya);\n          double temp = da + yb;\n          db += -(temp - da - yb);\n          da = temp;\n\n          temp = da * HEX_40000000;\n          double daa = da + temp - temp;\n          double dab = da - daa;\n\n          // ratio = na/da\n          double ratio = na/da;\n          temp = ratio * HEX_40000000;\n          double ratioa = ratio + temp - temp;\n          double ratiob = ratio - ratioa;\n\n          // Correct for rounding in division\n          ratiob += (na - daa*ratioa - daa*ratiob - dab*ratioa - dab*ratiob) / da;\n\n          // Account for nb\n          ratiob += nb / da;\n          // Account for db\n          ratiob += -db * na / da / da;\n\n          result = ratioa + ratiob;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "11": "    public static double tanh(double x) {\n      boolean negate = false;\n\n      if (x != x) {\n          return x;\n      }\n\n      // tanh[z] = sinh[z] / cosh[z]\n      // = (exp(z) - exp(-z)) / (exp(z) + exp(-z))\n      // = (exp(2x) - 1) / (exp(2x) + 1)\n\n      // for magnitude > 20, sinh[z] == cosh[z] in double precision\n\n      if (x > 20.0) {\n          return 1.0;\n      }\n\n      if (x < -20) {\n          return -1.0;\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n      if (x >= 0.5) {\n          double hiPrec[] = new double[2];\n          // tanh(x) = (exp(2x) - 1) / (exp(2x) + 1)\n          exp(x*2.0, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\ndouble yb = ((ya - hiPrec[0]) / hiPrec[1]);\n\n          /* Numerator */\n          double na = -1.0 + ya;\n          double nb = -(na + 1.0 - ya);\n          double temp = na + yb;\n          nb += -(temp - na - yb);\n          na = temp;\n\n          /* Denominator */\n          double da = 1.0 + ya;\n          double db = -(da - 1.0 - ya);\n          temp = da + yb;\n          db += -(temp - da - yb);\n          da = temp;\n\n          temp = da * HEX_40000000;\n          double daa = da + temp - temp;\n          double dab = da - daa;\n\n          // ratio = na/da\n          double ratio = na/da;\n          temp = ratio * HEX_40000000;\n          double ratioa = ratio + temp - temp;\n          double ratiob = ratio - ratioa;\n\n          // Correct for rounding in division\n          ratiob += (na - daa*ratioa - daa*ratiob - dab*ratioa - dab*ratiob) / da;\n\n          // Account for nb\n          ratiob += nb / da;\n          // Account for db\n          ratiob += -db * na / da / da;\n\n          result = ratioa + ratiob;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          // tanh(x) = expm1(2x) / (expm1(2x) + 2)\n          expm1(x*2.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Numerator */\n          double na = ya;\n          double nb = yb;\n\n          /* Denominator */\n          double da = 2.0 + ya;\n          double db = -(da - 2.0 - ya);\n          double temp = da + yb;\n          db += -(temp - da - yb);\n          da = temp;\n\n          temp = da * HEX_40000000;\n          double daa = da + temp - temp;\n          double dab = da - daa;\n\n          // ratio = na/da\n          double ratio = na/da;\n          temp = ratio * HEX_40000000;\n          double ratioa = ratio + temp - temp;\n          double ratiob = ratio - ratioa;\n\n          // Correct for rounding in division\n          ratiob += (na - daa*ratioa - daa*ratiob - dab*ratioa - dab*ratiob) / da;\n\n          // Account for nb\n          ratiob += nb / da;\n          // Account for db\n          ratiob += -db * na / da / da;\n\n          result = ratioa + ratiob;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "12": "    public static double tanh(double x) {\n      boolean negate = false;\n\n      if (x != x) {\n          return x;\n      }\n\n      // tanh[z] = sinh[z] / cosh[z]\n      // = (exp(z) - exp(-z)) / (exp(z) + exp(-z))\n      // = (exp(2x) - 1) / (exp(2x) + 1)\n\n      // for magnitude > 20, sinh[z] == cosh[z] in double precision\n\n      if (x > 20.0) {\n          return 1.0;\n      }\n\n      if (x < -20) {\n          return -1.0;\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n      if (x >= 0.5) {\n          double hiPrec[] = new double[2];\n          // tanh(x) = (exp(2x) - 1) / (exp(2x) + 1)\n          exp(x*2.0, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\ndouble yb = ((ya - hiPrec[0]) * hiPrec[1]);\n\n          /* Numerator */\n          double na = -1.0 + ya;\n          double nb = -(na + 1.0 - ya);\n          double temp = na + yb;\n          nb += -(temp - na - yb);\n          na = temp;\n\n          /* Denominator */\n          double da = 1.0 + ya;\n          double db = -(da - 1.0 - ya);\n          temp = da + yb;\n          db += -(temp - da - yb);\n          da = temp;\n\n          temp = da * HEX_40000000;\n          double daa = da + temp - temp;\n          double dab = da - daa;\n\n          // ratio = na/da\n          double ratio = na/da;\n          temp = ratio * HEX_40000000;\n          double ratioa = ratio + temp - temp;\n          double ratiob = ratio - ratioa;\n\n          // Correct for rounding in division\n          ratiob += (na - daa*ratioa - daa*ratiob - dab*ratioa - dab*ratiob) / da;\n\n          // Account for nb\n          ratiob += nb / da;\n          // Account for db\n          ratiob += -db * na / da / da;\n\n          result = ratioa + ratiob;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          // tanh(x) = expm1(2x) / (expm1(2x) + 2)\n          expm1(x*2.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Numerator */\n          double na = ya;\n          double nb = yb;\n\n          /* Denominator */\n          double da = 2.0 + ya;\n          double db = -(da - 2.0 - ya);\n          double temp = da + yb;\n          db += -(temp - da - yb);\n          da = temp;\n\n          temp = da * HEX_40000000;\n          double daa = da + temp - temp;\n          double dab = da - daa;\n\n          // ratio = na/da\n          double ratio = na/da;\n          temp = ratio * HEX_40000000;\n          double ratioa = ratio + temp - temp;\n          double ratiob = ratio - ratioa;\n\n          // Correct for rounding in division\n          ratiob += (na - daa*ratioa - daa*ratiob - dab*ratioa - dab*ratiob) / da;\n\n          // Account for nb\n          ratiob += nb / da;\n          // Account for db\n          ratiob += -db * na / da / da;\n\n          result = ratioa + ratiob;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "13": "    public static double tanh(double x) {\n      boolean negate = false;\n\n      if (x != x) {\n          return x;\n      }\n\n      // tanh[z] = sinh[z] / cosh[z]\n      // = (exp(z) - exp(-z)) / (exp(z) + exp(-z))\n      // = (exp(2x) - 1) / (exp(2x) + 1)\n\n      // for magnitude > 20, sinh[z] == cosh[z] in double precision\n\n      if (x > 20.0) {\n          return 1.0;\n      }\n\n      if (x < -20) {\n          return -1.0;\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n      if (x >= 0.5) {\n          double hiPrec[] = new double[2];\n          // tanh(x) = (exp(2x) - 1) / (exp(2x) + 1)\n          exp(x*2.0, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\ndouble yb = ((ya - hiPrec[0]) <= hiPrec[1]);\n\n          /* Numerator */\n          double na = -1.0 + ya;\n          double nb = -(na + 1.0 - ya);\n          double temp = na + yb;\n          nb += -(temp - na - yb);\n          na = temp;\n\n          /* Denominator */\n          double da = 1.0 + ya;\n          double db = -(da - 1.0 - ya);\n          temp = da + yb;\n          db += -(temp - da - yb);\n          da = temp;\n\n          temp = da * HEX_40000000;\n          double daa = da + temp - temp;\n          double dab = da - daa;\n\n          // ratio = na/da\n          double ratio = na/da;\n          temp = ratio * HEX_40000000;\n          double ratioa = ratio + temp - temp;\n          double ratiob = ratio - ratioa;\n\n          // Correct for rounding in division\n          ratiob += (na - daa*ratioa - daa*ratiob - dab*ratioa - dab*ratiob) / da;\n\n          // Account for nb\n          ratiob += nb / da;\n          // Account for db\n          ratiob += -db * na / da / da;\n\n          result = ratioa + ratiob;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          // tanh(x) = expm1(2x) / (expm1(2x) + 2)\n          expm1(x*2.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Numerator */\n          double na = ya;\n          double nb = yb;\n\n          /* Denominator */\n          double da = 2.0 + ya;\n          double db = -(da - 2.0 - ya);\n          double temp = da + yb;\n          db += -(temp - da - yb);\n          da = temp;\n\n          temp = da * HEX_40000000;\n          double daa = da + temp - temp;\n          double dab = da - daa;\n\n          // ratio = na/da\n          double ratio = na/da;\n          temp = ratio * HEX_40000000;\n          double ratioa = ratio + temp - temp;\n          double ratiob = ratio - ratioa;\n\n          // Correct for rounding in division\n          ratiob += (na - daa*ratioa - daa*ratiob - dab*ratioa - dab*ratiob) / da;\n\n          // Account for nb\n          ratiob += nb / da;\n          // Account for db\n          ratiob += -db * na / da / da;\n\n          result = ratioa + ratiob;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "14": "    public static double tanh(double x) {\n      boolean negate = false;\n\n      if (x != x) {\n          return x;\n      }\n\n      // tanh[z] = sinh[z] / cosh[z]\n      // = (exp(z) - exp(-z)) / (exp(z) + exp(-z))\n      // = (exp(2x) - 1) / (exp(2x) + 1)\n\n      // for magnitude > 20, sinh[z] == cosh[z] in double precision\n\n      if (x > 20.0) {\n          return 1.0;\n      }\n\n      if (x < -20) {\n          return -1.0;\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n      if (x >= 0.5) {\n          double hiPrec[] = new double[2];\n          // tanh(x) = (exp(2x) - 1) / (exp(2x) + 1)\n          exp(x*2.0, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\ndouble yb = ((ya - hiPrec[0]) % hiPrec[1]);\n\n          /* Numerator */\n          double na = -1.0 + ya;\n          double nb = -(na + 1.0 - ya);\n          double temp = na + yb;\n          nb += -(temp - na - yb);\n          na = temp;\n\n          /* Denominator */\n          double da = 1.0 + ya;\n          double db = -(da - 1.0 - ya);\n          temp = da + yb;\n          db += -(temp - da - yb);\n          da = temp;\n\n          temp = da * HEX_40000000;\n          double daa = da + temp - temp;\n          double dab = da - daa;\n\n          // ratio = na/da\n          double ratio = na/da;\n          temp = ratio * HEX_40000000;\n          double ratioa = ratio + temp - temp;\n          double ratiob = ratio - ratioa;\n\n          // Correct for rounding in division\n          ratiob += (na - daa*ratioa - daa*ratiob - dab*ratioa - dab*ratiob) / da;\n\n          // Account for nb\n          ratiob += nb / da;\n          // Account for db\n          ratiob += -db * na / da / da;\n\n          result = ratioa + ratiob;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          // tanh(x) = expm1(2x) / (expm1(2x) + 2)\n          expm1(x*2.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Numerator */\n          double na = ya;\n          double nb = yb;\n\n          /* Denominator */\n          double da = 2.0 + ya;\n          double db = -(da - 2.0 - ya);\n          double temp = da + yb;\n          db += -(temp - da - yb);\n          da = temp;\n\n          temp = da * HEX_40000000;\n          double daa = da + temp - temp;\n          double dab = da - daa;\n\n          // ratio = na/da\n          double ratio = na/da;\n          temp = ratio * HEX_40000000;\n          double ratioa = ratio + temp - temp;\n          double ratiob = ratio - ratioa;\n\n          // Correct for rounding in division\n          ratiob += (na - daa*ratioa - daa*ratiob - dab*ratioa - dab*ratiob) / da;\n\n          // Account for nb\n          ratiob += nb / da;\n          // Account for db\n          ratiob += -db * na / da / da;\n\n          result = ratioa + ratiob;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "15": "    public static double tanh(double x) {\n      boolean negate = false;\n\n      if (x != x) {\n          return x;\n      }\n\n      // tanh[z] = sinh[z] / cosh[z]\n      // = (exp(z) - exp(-z)) / (exp(z) + exp(-z))\n      // = (exp(2x) - 1) / (exp(2x) + 1)\n\n      // for magnitude > 20, sinh[z] == cosh[z] in double precision\n\n      if (x > 20.0) {\n          return 1.0;\n      }\n\n      if (x < -20) {\n          return -1.0;\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n      if (x >= 0.5) {\n          double hiPrec[] = new double[2];\n          // tanh(x) = (exp(2x) - 1) / (exp(2x) + 1)\n          exp(x*2.0, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\ndouble  = (hiPrec - hiPrec[1]);\n\n          /* Numerator */\n          double na = -1.0 + ya;\n          double nb = -(na + 1.0 - ya);\n          double temp = na + yb;\n          nb += -(temp - na - yb);\n          na = temp;\n\n          /* Denominator */\n          double da = 1.0 + ya;\n          double db = -(da - 1.0 - ya);\n          temp = da + yb;\n          db += -(temp - da - yb);\n          da = temp;\n\n          temp = da * HEX_40000000;\n          double daa = da + temp - temp;\n          double dab = da - daa;\n\n          // ratio = na/da\n          double ratio = na/da;\n          temp = ratio * HEX_40000000;\n          double ratioa = ratio + temp - temp;\n          double ratiob = ratio - ratioa;\n\n          // Correct for rounding in division\n          ratiob += (na - daa*ratioa - daa*ratiob - dab*ratioa - dab*ratiob) / da;\n\n          // Account for nb\n          ratiob += nb / da;\n          // Account for db\n          ratiob += -db * na / da / da;\n\n          result = ratioa + ratiob;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          // tanh(x) = expm1(2x) / (expm1(2x) + 2)\n          expm1(x*2.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Numerator */\n          double na = ya;\n          double nb = yb;\n\n          /* Denominator */\n          double da = 2.0 + ya;\n          double db = -(da - 2.0 - ya);\n          double temp = da + yb;\n          db += -(temp - da - yb);\n          da = temp;\n\n          temp = da * HEX_40000000;\n          double daa = da + temp - temp;\n          double dab = da - daa;\n\n          // ratio = na/da\n          double ratio = na/da;\n          temp = ratio * HEX_40000000;\n          double ratioa = ratio + temp - temp;\n          double ratiob = ratio - ratioa;\n\n          // Correct for rounding in division\n          ratiob += (na - daa*ratioa - daa*ratiob - dab*ratioa - dab*ratiob) / da;\n\n          // Account for nb\n          ratiob += nb / da;\n          // Account for db\n          ratiob += -db * na / da / da;\n\n          result = ratioa + ratiob;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "16": "    public static double tanh(double x) {\n      boolean negate = false;\n\n      if (x != x) {\n          return x;\n      }\n\n      // tanh[z] = sinh[z] / cosh[z]\n      // = (exp(z) - exp(-z)) / (exp(z) + exp(-z))\n      // = (exp(2x) - 1) / (exp(2x) + 1)\n\n      // for magnitude > 20, sinh[z] == cosh[z] in double precision\n\n      if (x > 20.0) {\n          return 1.0;\n      }\n\n      if (x < -20) {\n          return -1.0;\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n      if (x >= 0.5) {\n          double hiPrec[] = new double[2];\n          // tanh(x) = (exp(2x) - 1) / (exp(2x) + 1)\n          exp(x*2.0, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\ndouble  = (((ya - hiPrec[0]) - hiPrec) - hiPrec[1]);\n\n          /* Numerator */\n          double na = -1.0 + ya;\n          double nb = -(na + 1.0 - ya);\n          double temp = na + yb;\n          nb += -(temp - na - yb);\n          na = temp;\n\n          /* Denominator */\n          double da = 1.0 + ya;\n          double db = -(da - 1.0 - ya);\n          temp = da + yb;\n          db += -(temp - da - yb);\n          da = temp;\n\n          temp = da * HEX_40000000;\n          double daa = da + temp - temp;\n          double dab = da - daa;\n\n          // ratio = na/da\n          double ratio = na/da;\n          temp = ratio * HEX_40000000;\n          double ratioa = ratio + temp - temp;\n          double ratiob = ratio - ratioa;\n\n          // Correct for rounding in division\n          ratiob += (na - daa*ratioa - daa*ratiob - dab*ratioa - dab*ratiob) / da;\n\n          // Account for nb\n          ratiob += nb / da;\n          // Account for db\n          ratiob += -db * na / da / da;\n\n          result = ratioa + ratiob;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          // tanh(x) = expm1(2x) / (expm1(2x) + 2)\n          expm1(x*2.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Numerator */\n          double na = ya;\n          double nb = yb;\n\n          /* Denominator */\n          double da = 2.0 + ya;\n          double db = -(da - 2.0 - ya);\n          double temp = da + yb;\n          db += -(temp - da - yb);\n          da = temp;\n\n          temp = da * HEX_40000000;\n          double daa = da + temp - temp;\n          double dab = da - daa;\n\n          // ratio = na/da\n          double ratio = na/da;\n          temp = ratio * HEX_40000000;\n          double ratioa = ratio + temp - temp;\n          double ratiob = ratio - ratioa;\n\n          // Correct for rounding in division\n          ratiob += (na - daa*ratioa - daa*ratiob - dab*ratioa - dab*ratiob) / da;\n\n          // Account for nb\n          ratiob += nb / da;\n          // Account for db\n          ratiob += -db * na / da / da;\n\n          result = ratioa + ratiob;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "17": "    public static double tanh(double x) {\n      boolean negate = false;\n\n      if (x != x) {\n          return x;\n      }\n\n      // tanh[z] = sinh[z] / cosh[z]\n      // = (exp(z) - exp(-z)) / (exp(z) + exp(-z))\n      // = (exp(2x) - 1) / (exp(2x) + 1)\n\n      // for magnitude > 20, sinh[z] == cosh[z] in double precision\n\n      if (x > 20.0) {\n          return 1.0;\n      }\n\n      if (x < -20) {\n          return -1.0;\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n      if (x >= 0.5) {\n          double hiPrec[] = new double[2];\n          // tanh(x) = (exp(2x) - 1) / (exp(2x) + 1)\n          exp(x*2.0, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\ndouble  = (hiPrec[1] - hiPrec);\n\n          /* Numerator */\n          double na = -1.0 + ya;\n          double nb = -(na + 1.0 - ya);\n          double temp = na + yb;\n          nb += -(temp - na - yb);\n          na = temp;\n\n          /* Denominator */\n          double da = 1.0 + ya;\n          double db = -(da - 1.0 - ya);\n          temp = da + yb;\n          db += -(temp - da - yb);\n          da = temp;\n\n          temp = da * HEX_40000000;\n          double daa = da + temp - temp;\n          double dab = da - daa;\n\n          // ratio = na/da\n          double ratio = na/da;\n          temp = ratio * HEX_40000000;\n          double ratioa = ratio + temp - temp;\n          double ratiob = ratio - ratioa;\n\n          // Correct for rounding in division\n          ratiob += (na - daa*ratioa - daa*ratiob - dab*ratioa - dab*ratiob) / da;\n\n          // Account for nb\n          ratiob += nb / da;\n          // Account for db\n          ratiob += -db * na / da / da;\n\n          result = ratioa + ratiob;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          // tanh(x) = expm1(2x) / (expm1(2x) + 2)\n          expm1(x*2.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Numerator */\n          double na = ya;\n          double nb = yb;\n\n          /* Denominator */\n          double da = 2.0 + ya;\n          double db = -(da - 2.0 - ya);\n          double temp = da + yb;\n          db += -(temp - da - yb);\n          da = temp;\n\n          temp = da * HEX_40000000;\n          double daa = da + temp - temp;\n          double dab = da - daa;\n\n          // ratio = na/da\n          double ratio = na/da;\n          temp = ratio * HEX_40000000;\n          double ratioa = ratio + temp - temp;\n          double ratiob = ratio - ratioa;\n\n          // Correct for rounding in division\n          ratiob += (na - daa*ratioa - daa*ratiob - dab*ratioa - dab*ratiob) / da;\n\n          // Account for nb\n          ratiob += nb / da;\n          // Account for db\n          ratiob += -db * na / da / da;\n\n          result = ratioa + ratiob;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "18": "    public static double tanh(double x) {\n      boolean negate = false;\n\n      if (x != x) {\n          return x;\n      }\n\n      // tanh[z] = sinh[z] / cosh[z]\n      // = (exp(z) - exp(-z)) / (exp(z) + exp(-z))\n      // = (exp(2x) - 1) / (exp(2x) + 1)\n\n      // for magnitude > 20, sinh[z] == cosh[z] in double precision\n\n      if (x > 20.0) {\n          return 1.0;\n      }\n\n      if (x < -20) {\n          return -1.0;\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n      if (x >= 0.5) {\n          double hiPrec[] = new double[2];\n          // tanh(x) = (exp(2x) - 1) / (exp(2x) + 1)\n          exp(x*2.0, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\ndouble  = (hiPrec[1] - hiPrec[1]);\n\n          /* Numerator */\n          double na = -1.0 + ya;\n          double nb = -(na + 1.0 - ya);\n          double temp = na + yb;\n          nb += -(temp - na - yb);\n          na = temp;\n\n          /* Denominator */\n          double da = 1.0 + ya;\n          double db = -(da - 1.0 - ya);\n          temp = da + yb;\n          db += -(temp - da - yb);\n          da = temp;\n\n          temp = da * HEX_40000000;\n          double daa = da + temp - temp;\n          double dab = da - daa;\n\n          // ratio = na/da\n          double ratio = na/da;\n          temp = ratio * HEX_40000000;\n          double ratioa = ratio + temp - temp;\n          double ratiob = ratio - ratioa;\n\n          // Correct for rounding in division\n          ratiob += (na - daa*ratioa - daa*ratiob - dab*ratioa - dab*ratiob) / da;\n\n          // Account for nb\n          ratiob += nb / da;\n          // Account for db\n          ratiob += -db * na / da / da;\n\n          result = ratioa + ratiob;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          // tanh(x) = expm1(2x) / (expm1(2x) + 2)\n          expm1(x*2.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Numerator */\n          double na = ya;\n          double nb = yb;\n\n          /* Denominator */\n          double da = 2.0 + ya;\n          double db = -(da - 2.0 - ya);\n          double temp = da + yb;\n          db += -(temp - da - yb);\n          da = temp;\n\n          temp = da * HEX_40000000;\n          double daa = da + temp - temp;\n          double dab = da - daa;\n\n          // ratio = na/da\n          double ratio = na/da;\n          temp = ratio * HEX_40000000;\n          double ratioa = ratio + temp - temp;\n          double ratiob = ratio - ratioa;\n\n          // Correct for rounding in division\n          ratiob += (na - daa*ratioa - daa*ratiob - dab*ratioa - dab*ratiob) / da;\n\n          // Account for nb\n          ratiob += nb / da;\n          // Account for db\n          ratiob += -db * na / da / da;\n\n          result = ratioa + ratiob;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "19": "    public static double tanh(double x) {\n      boolean negate = false;\n\n      if (x != x) {\n          return x;\n      }\n\n      // tanh[z] = sinh[z] / cosh[z]\n      // = (exp(z) - exp(-z)) / (exp(z) + exp(-z))\n      // = (exp(2x) - 1) / (exp(2x) + 1)\n\n      // for magnitude > 20, sinh[z] == cosh[z] in double precision\n\n      if (x > 20.0) {\n          return 1.0;\n      }\n\n      if (x < -20) {\n          return -1.0;\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n      if (x >= 0.5) {\n          double hiPrec[] = new double[2];\n          // tanh(x) = (exp(2x) - 1) / (exp(2x) + 1)\n          exp(x*2.0, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\ndouble  = ((hiPrec - hiPrec) - hiPrec[1]);\n\n          /* Numerator */\n          double na = -1.0 + ya;\n          double nb = -(na + 1.0 - ya);\n          double temp = na + yb;\n          nb += -(temp - na - yb);\n          na = temp;\n\n          /* Denominator */\n          double da = 1.0 + ya;\n          double db = -(da - 1.0 - ya);\n          temp = da + yb;\n          db += -(temp - da - yb);\n          da = temp;\n\n          temp = da * HEX_40000000;\n          double daa = da + temp - temp;\n          double dab = da - daa;\n\n          // ratio = na/da\n          double ratio = na/da;\n          temp = ratio * HEX_40000000;\n          double ratioa = ratio + temp - temp;\n          double ratiob = ratio - ratioa;\n\n          // Correct for rounding in division\n          ratiob += (na - daa*ratioa - daa*ratiob - dab*ratioa - dab*ratiob) / da;\n\n          // Account for nb\n          ratiob += nb / da;\n          // Account for db\n          ratiob += -db * na / da / da;\n\n          result = ratioa + ratiob;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          // tanh(x) = expm1(2x) / (expm1(2x) + 2)\n          expm1(x*2.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Numerator */\n          double na = ya;\n          double nb = yb;\n\n          /* Denominator */\n          double da = 2.0 + ya;\n          double db = -(da - 2.0 - ya);\n          double temp = da + yb;\n          db += -(temp - da - yb);\n          da = temp;\n\n          temp = da * HEX_40000000;\n          double daa = da + temp - temp;\n          double dab = da - daa;\n\n          // ratio = na/da\n          double ratio = na/da;\n          temp = ratio * HEX_40000000;\n          double ratioa = ratio + temp - temp;\n          double ratiob = ratio - ratioa;\n\n          // Correct for rounding in division\n          ratiob += (na - daa*ratioa - daa*ratiob - dab*ratioa - dab*ratiob) / da;\n\n          // Account for nb\n          ratiob += nb / da;\n          // Account for db\n          ratiob += -db * na / da / da;\n\n          result = ratioa + ratiob;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "20": "    public static double tanh(double x) {\n      boolean negate = false;\n\n      if (x != x) {\n          return x;\n      }\n\n      // tanh[z] = sinh[z] / cosh[z]\n      // = (exp(z) - exp(-z)) / (exp(z) + exp(-z))\n      // = (exp(2x) - 1) / (exp(2x) + 1)\n\n      // for magnitude > 20, sinh[z] == cosh[z] in double precision\n\n      if (x > 20.0) {\n          return 1.0;\n      }\n\n      if (x < -20) {\n          return -1.0;\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n      if (x >= 0.5) {\n          double hiPrec[] = new double[2];\n          // tanh(x) = (exp(2x) - 1) / (exp(2x) + 1)\n          exp(x*2.0, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\ndouble  = ((hiPrec - hiPrec[1]) - hiPrec[1]);\n\n          /* Numerator */\n          double na = -1.0 + ya;\n          double nb = -(na + 1.0 - ya);\n          double temp = na + yb;\n          nb += -(temp - na - yb);\n          na = temp;\n\n          /* Denominator */\n          double da = 1.0 + ya;\n          double db = -(da - 1.0 - ya);\n          temp = da + yb;\n          db += -(temp - da - yb);\n          da = temp;\n\n          temp = da * HEX_40000000;\n          double daa = da + temp - temp;\n          double dab = da - daa;\n\n          // ratio = na/da\n          double ratio = na/da;\n          temp = ratio * HEX_40000000;\n          double ratioa = ratio + temp - temp;\n          double ratiob = ratio - ratioa;\n\n          // Correct for rounding in division\n          ratiob += (na - daa*ratioa - daa*ratiob - dab*ratioa - dab*ratiob) / da;\n\n          // Account for nb\n          ratiob += nb / da;\n          // Account for db\n          ratiob += -db * na / da / da;\n\n          result = ratioa + ratiob;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          // tanh(x) = expm1(2x) / (expm1(2x) + 2)\n          expm1(x*2.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Numerator */\n          double na = ya;\n          double nb = yb;\n\n          /* Denominator */\n          double da = 2.0 + ya;\n          double db = -(da - 2.0 - ya);\n          double temp = da + yb;\n          db += -(temp - da - yb);\n          da = temp;\n\n          temp = da * HEX_40000000;\n          double daa = da + temp - temp;\n          double dab = da - daa;\n\n          // ratio = na/da\n          double ratio = na/da;\n          temp = ratio * HEX_40000000;\n          double ratioa = ratio + temp - temp;\n          double ratiob = ratio - ratioa;\n\n          // Correct for rounding in division\n          ratiob += (na - daa*ratioa - daa*ratiob - dab*ratioa - dab*ratiob) / da;\n\n          // Account for nb\n          ratiob += nb / da;\n          // Account for db\n          ratiob += -db * na / da / da;\n\n          result = ratioa + ratiob;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "21": "    public static double tanh(double x) {\n      boolean negate = false;\n\n      if (x != x) {\n          return x;\n      }\n\n      // tanh[z] = sinh[z] / cosh[z]\n      // = (exp(z) - exp(-z)) / (exp(z) + exp(-z))\n      // = (exp(2x) - 1) / (exp(2x) + 1)\n\n      // for magnitude > 20, sinh[z] == cosh[z] in double precision\n\n      if (x > 20.0) {\n          return 1.0;\n      }\n\n      if (x < -20) {\n          return -1.0;\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n      if (x >= 0.5) {\n          double hiPrec[] = new double[2];\n          // tanh(x) = (exp(2x) - 1) / (exp(2x) + 1)\n          exp(x*2.0, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\ndouble  = ((hiPrec + hiPrec) - hiPrec[1]);\n\n          /* Numerator */\n          double na = -1.0 + ya;\n          double nb = -(na + 1.0 - ya);\n          double temp = na + yb;\n          nb += -(temp - na - yb);\n          na = temp;\n\n          /* Denominator */\n          double da = 1.0 + ya;\n          double db = -(da - 1.0 - ya);\n          temp = da + yb;\n          db += -(temp - da - yb);\n          da = temp;\n\n          temp = da * HEX_40000000;\n          double daa = da + temp - temp;\n          double dab = da - daa;\n\n          // ratio = na/da\n          double ratio = na/da;\n          temp = ratio * HEX_40000000;\n          double ratioa = ratio + temp - temp;\n          double ratiob = ratio - ratioa;\n\n          // Correct for rounding in division\n          ratiob += (na - daa*ratioa - daa*ratiob - dab*ratioa - dab*ratiob) / da;\n\n          // Account for nb\n          ratiob += nb / da;\n          // Account for db\n          ratiob += -db * na / da / da;\n\n          result = ratioa + ratiob;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          // tanh(x) = expm1(2x) / (expm1(2x) + 2)\n          expm1(x*2.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Numerator */\n          double na = ya;\n          double nb = yb;\n\n          /* Denominator */\n          double da = 2.0 + ya;\n          double db = -(da - 2.0 - ya);\n          double temp = da + yb;\n          db += -(temp - da - yb);\n          da = temp;\n\n          temp = da * HEX_40000000;\n          double daa = da + temp - temp;\n          double dab = da - daa;\n\n          // ratio = na/da\n          double ratio = na/da;\n          temp = ratio * HEX_40000000;\n          double ratioa = ratio + temp - temp;\n          double ratiob = ratio - ratioa;\n\n          // Correct for rounding in division\n          ratiob += (na - daa*ratioa - daa*ratiob - dab*ratioa - dab*ratiob) / da;\n\n          // Account for nb\n          ratiob += nb / da;\n          // Account for db\n          ratiob += -db * na / da / da;\n\n          result = ratioa + ratiob;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "22": "    public static double tanh(double x) {\n      boolean negate = false;\n\n      if (x != x) {\n          return x;\n      }\n\n      // tanh[z] = sinh[z] / cosh[z]\n      // = (exp(z) - exp(-z)) / (exp(z) + exp(-z))\n      // = (exp(2x) - 1) / (exp(2x) + 1)\n\n      // for magnitude > 20, sinh[z] == cosh[z] in double precision\n\n      if (x > 20.0) {\n          return 1.0;\n      }\n\n      if (x < -20) {\n          return -1.0;\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n      if (x >= 0.5) {\n          double hiPrec[] = new double[2];\n          // tanh(x) = (exp(2x) - 1) / (exp(2x) + 1)\n          exp(x*2.0, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\ndouble  = ((hiPrec - hiPrec) + hiPrec[1]);\n\n          /* Numerator */\n          double na = -1.0 + ya;\n          double nb = -(na + 1.0 - ya);\n          double temp = na + yb;\n          nb += -(temp - na - yb);\n          na = temp;\n\n          /* Denominator */\n          double da = 1.0 + ya;\n          double db = -(da - 1.0 - ya);\n          temp = da + yb;\n          db += -(temp - da - yb);\n          da = temp;\n\n          temp = da * HEX_40000000;\n          double daa = da + temp - temp;\n          double dab = da - daa;\n\n          // ratio = na/da\n          double ratio = na/da;\n          temp = ratio * HEX_40000000;\n          double ratioa = ratio + temp - temp;\n          double ratiob = ratio - ratioa;\n\n          // Correct for rounding in division\n          ratiob += (na - daa*ratioa - daa*ratiob - dab*ratioa - dab*ratiob) / da;\n\n          // Account for nb\n          ratiob += nb / da;\n          // Account for db\n          ratiob += -db * na / da / da;\n\n          result = ratioa + ratiob;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          // tanh(x) = expm1(2x) / (expm1(2x) + 2)\n          expm1(x*2.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Numerator */\n          double na = ya;\n          double nb = yb;\n\n          /* Denominator */\n          double da = 2.0 + ya;\n          double db = -(da - 2.0 - ya);\n          double temp = da + yb;\n          db += -(temp - da - yb);\n          da = temp;\n\n          temp = da * HEX_40000000;\n          double daa = da + temp - temp;\n          double dab = da - daa;\n\n          // ratio = na/da\n          double ratio = na/da;\n          temp = ratio * HEX_40000000;\n          double ratioa = ratio + temp - temp;\n          double ratiob = ratio - ratioa;\n\n          // Correct for rounding in division\n          ratiob += (na - daa*ratioa - daa*ratiob - dab*ratioa - dab*ratiob) / da;\n\n          // Account for nb\n          ratiob += nb / da;\n          // Account for db\n          ratiob += -db * na / da / da;\n\n          result = ratioa + ratiob;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "23": "    public static double tanh(double x) {\n      boolean negate = false;\n\n      if (x != x) {\n          return x;\n      }\n\n      // tanh[z] = sinh[z] / cosh[z]\n      // = (exp(z) - exp(-z)) / (exp(z) + exp(-z))\n      // = (exp(2x) - 1) / (exp(2x) + 1)\n\n      // for magnitude > 20, sinh[z] == cosh[z] in double precision\n\n      if (x > 20.0) {\n          return 1.0;\n      }\n\n      if (x < -20) {\n          return -1.0;\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n      if (x >= 0.5) {\n          double hiPrec[] = new double[2];\n          // tanh(x) = (exp(2x) - 1) / (exp(2x) + 1)\n          exp(x*2.0, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\ndouble  = ((ya - hiPrec[0]) - (hiPrec * hiPrec));\n\n          /* Numerator */\n          double na = -1.0 + ya;\n          double nb = -(na + 1.0 - ya);\n          double temp = na + yb;\n          nb += -(temp - na - yb);\n          na = temp;\n\n          /* Denominator */\n          double da = 1.0 + ya;\n          double db = -(da - 1.0 - ya);\n          temp = da + yb;\n          db += -(temp - da - yb);\n          da = temp;\n\n          temp = da * HEX_40000000;\n          double daa = da + temp - temp;\n          double dab = da - daa;\n\n          // ratio = na/da\n          double ratio = na/da;\n          temp = ratio * HEX_40000000;\n          double ratioa = ratio + temp - temp;\n          double ratiob = ratio - ratioa;\n\n          // Correct for rounding in division\n          ratiob += (na - daa*ratioa - daa*ratiob - dab*ratioa - dab*ratiob) / da;\n\n          // Account for nb\n          ratiob += nb / da;\n          // Account for db\n          ratiob += -db * na / da / da;\n\n          result = ratioa + ratiob;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          // tanh(x) = expm1(2x) / (expm1(2x) + 2)\n          expm1(x*2.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Numerator */\n          double na = ya;\n          double nb = yb;\n\n          /* Denominator */\n          double da = 2.0 + ya;\n          double db = -(da - 2.0 - ya);\n          double temp = da + yb;\n          db += -(temp - da - yb);\n          da = temp;\n\n          temp = da * HEX_40000000;\n          double daa = da + temp - temp;\n          double dab = da - daa;\n\n          // ratio = na/da\n          double ratio = na/da;\n          temp = ratio * HEX_40000000;\n          double ratioa = ratio + temp - temp;\n          double ratiob = ratio - ratioa;\n\n          // Correct for rounding in division\n          ratiob += (na - daa*ratioa - daa*ratiob - dab*ratioa - dab*ratiob) / da;\n\n          // Account for nb\n          ratiob += nb / da;\n          // Account for db\n          ratiob += -db * na / da / da;\n\n          result = ratioa + ratiob;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "24": "    public static double tanh(double x) {\n      boolean negate = false;\n\n      if (x != x) {\n          return x;\n      }\n\n      // tanh[z] = sinh[z] / cosh[z]\n      // = (exp(z) - exp(-z)) / (exp(z) + exp(-z))\n      // = (exp(2x) - 1) / (exp(2x) + 1)\n\n      // for magnitude > 20, sinh[z] == cosh[z] in double precision\n\n      if (x > 20.0) {\n          return 1.0;\n      }\n\n      if (x < -20) {\n          return -1.0;\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n      if (x >= 0.5) {\n          double hiPrec[] = new double[2];\n          // tanh(x) = (exp(2x) - 1) / (exp(2x) + 1)\n          exp(x*2.0, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\nreturn;\n          double yb = +(ya - hiPrec[0] - hiPrec[1]);\n          /* Numerator */\n          double na = -1.0 + ya;\n          double nb = -(na + 1.0 - ya);\n          double temp = na + yb;\n          nb += -(temp - na - yb);\n          na = temp;\n\n          /* Denominator */\n          double da = 1.0 + ya;\n          double db = -(da - 1.0 - ya);\n          temp = da + yb;\n          db += -(temp - da - yb);\n          da = temp;\n\n          temp = da * HEX_40000000;\n          double daa = da + temp - temp;\n          double dab = da - daa;\n\n          // ratio = na/da\n          double ratio = na/da;\n          temp = ratio * HEX_40000000;\n          double ratioa = ratio + temp - temp;\n          double ratiob = ratio - ratioa;\n\n          // Correct for rounding in division\n          ratiob += (na - daa*ratioa - daa*ratiob - dab*ratioa - dab*ratiob) / da;\n\n          // Account for nb\n          ratiob += nb / da;\n          // Account for db\n          ratiob += -db * na / da / da;\n\n          result = ratioa + ratiob;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          // tanh(x) = expm1(2x) / (expm1(2x) + 2)\n          expm1(x*2.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Numerator */\n          double na = ya;\n          double nb = yb;\n\n          /* Denominator */\n          double da = 2.0 + ya;\n          double db = -(da - 2.0 - ya);\n          double temp = da + yb;\n          db += -(temp - da - yb);\n          da = temp;\n\n          temp = da * HEX_40000000;\n          double daa = da + temp - temp;\n          double dab = da - daa;\n\n          // ratio = na/da\n          double ratio = na/da;\n          temp = ratio * HEX_40000000;\n          double ratioa = ratio + temp - temp;\n          double ratiob = ratio - ratioa;\n\n          // Correct for rounding in division\n          ratiob += (na - daa*ratioa - daa*ratiob - dab*ratioa - dab*ratiob) / da;\n\n          // Account for nb\n          ratiob += nb / da;\n          // Account for db\n          ratiob += -db * na / da / da;\n\n          result = ratioa + ratiob;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "25": "    public static double tanh(double x) {\n      boolean negate = false;\n\n      if (x != x) {\n          return x;\n      }\n\n      // tanh[z] = sinh[z] / cosh[z]\n      // = (exp(z) - exp(-z)) / (exp(z) + exp(-z))\n      // = (exp(2x) - 1) / (exp(2x) + 1)\n\n      // for magnitude > 20, sinh[z] == cosh[z] in double precision\n\n      if (x > 20.0) {\n          return 1.0;\n      }\n\n      if (x < -20) {\n          return -1.0;\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n      if (x >= 0.5) {\n          double hiPrec[] = new double[2];\n          // tanh(x) = (exp(2x) - 1) / (exp(2x) + 1)\n          exp(x*2.0, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\ndouble  = ((hiPrec - hiPrec) - hiPrec);\n\n          /* Numerator */\n          double na = -1.0 + ya;\n          double nb = -(na + 1.0 - ya);\n          double temp = na + yb;\n          nb += -(temp - na - yb);\n          na = temp;\n\n          /* Denominator */\n          double da = 1.0 + ya;\n          double db = -(da - 1.0 - ya);\n          temp = da + yb;\n          db += -(temp - da - yb);\n          da = temp;\n\n          temp = da * HEX_40000000;\n          double daa = da + temp - temp;\n          double dab = da - daa;\n\n          // ratio = na/da\n          double ratio = na/da;\n          temp = ratio * HEX_40000000;\n          double ratioa = ratio + temp - temp;\n          double ratiob = ratio - ratioa;\n\n          // Correct for rounding in division\n          ratiob += (na - daa*ratioa - daa*ratiob - dab*ratioa - dab*ratiob) / da;\n\n          // Account for nb\n          ratiob += nb / da;\n          // Account for db\n          ratiob += -db * na / da / da;\n\n          result = ratioa + ratiob;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          // tanh(x) = expm1(2x) / (expm1(2x) + 2)\n          expm1(x*2.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Numerator */\n          double na = ya;\n          double nb = yb;\n\n          /* Denominator */\n          double da = 2.0 + ya;\n          double db = -(da - 2.0 - ya);\n          double temp = da + yb;\n          db += -(temp - da - yb);\n          da = temp;\n\n          temp = da * HEX_40000000;\n          double daa = da + temp - temp;\n          double dab = da - daa;\n\n          // ratio = na/da\n          double ratio = na/da;\n          temp = ratio * HEX_40000000;\n          double ratioa = ratio + temp - temp;\n          double ratiob = ratio - ratioa;\n\n          // Correct for rounding in division\n          ratiob += (na - daa*ratioa - daa*ratiob - dab*ratioa - dab*ratiob) / da;\n\n          // Account for nb\n          ratiob += nb / da;\n          // Account for db\n          ratiob += -db * na / da / da;\n\n          result = ratioa + ratiob;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }"
}