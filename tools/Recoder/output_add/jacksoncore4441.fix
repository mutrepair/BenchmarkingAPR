{
          "0": "    public byte[] quoteAsUTF8(String text)\n    {\n        ByteArrayBuilder byteBuilder = _byteBuilder;\n        if (byteBuilder == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _byteBuilder = byteBuilder = new ByteArrayBuilder(null);\n        }\n        int inputPtr = 0;\n        int inputEnd = text.length();\n        int outputPtr = 0;\n        byte[] outputBuffer = byteBuilder.resetAndGetFirstSegment();\n        \n        main_loop:\n        while (inputPtr < inputEnd) {\n            final int[] escCodes = CharTypes.get7BitOutputEscapes();\n\n            inner_loop: // ASCII and escapes\n            while (true) {\n                int ch = text.charAt(inputPtr);\n                if (ch > 0x7F || escCodes[ch] != 0) {\n                    break inner_loop;\n                }\n                if (outputPtr >= outputBuffer.length) {\n                    outputBuffer = byteBuilder.finishCurrentSegment();\n                    outputPtr = 0;\n                }\n                outputBuffer[outputPtr++] = (byte) ch;\n                if (++inputPtr >= inputEnd) {\n                    break main_loop;\n                }\n            }                \n            if (outputPtr >= outputBuffer.length) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputPtr = 0;\n            }\n            // Ok, so what did we hit?\n            int ch = (int) text.charAt(inputPtr++);\n            if (ch <= 0x7F) { // needs quoting\n                int escape = escCodes[ch];\n                // ctrl-char, 6-byte escape...\n                outputPtr = _appendByteEscape(ch, escape, byteBuilder, outputPtr);\n                outputBuffer = byteBuilder.getCurrentSegment();\n                continue main_loop;\n            } else if (ch <= 0x7FF) { // fine, just needs 2 byte output\n                outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6));\n                ch = (0x80 | (ch & 0x3f));\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (ch < SURR1_FIRST || ch > SURR2_LAST) { // nope\n                    outputBuffer[outputPtr++] = (byte) (0xe0 | (ch >> 12));\n                    if (outputPtr >= outputBuffer.length) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f));\nch = (0x80 | (ch | 1));\n                } else { // yes, surrogate pair\n                    if (ch > SURR1_LAST) { // must be from first range\n                        _illegalSurrogate(ch);\n                    }\n                    // and if so, followed by another from next range\n                    if (inputPtr >= inputEnd) {\n                        _illegalSurrogate(ch);\n                    }\n                    ch = _convertSurrogate(ch, text.charAt(inputPtr++));\n                    if (ch > 0x10FFFF) { // illegal, as per RFC 4627\n                        _illegalSurrogate(ch);\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0xf0 | (ch >> 18));\n                    if (outputPtr >= outputBuffer.length) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 12) & 0x3f));\n                    if (outputPtr >= outputBuffer.length) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f));\n                    ch = (0x80 | (ch & 0x3f));\n                }\n            }\n            if (outputPtr >= outputBuffer.length) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputPtr = 0;\n            }\n            outputBuffer[outputPtr++] = (byte) ch;\n        }\n        return _byteBuilder.completeAndCoalesce(outputPtr);\n    }",
          "1": "    public byte[] quoteAsUTF8(String text)\n    {\n        ByteArrayBuilder byteBuilder = _byteBuilder;\n        if (byteBuilder == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _byteBuilder = byteBuilder = new ByteArrayBuilder(null);\n        }\n        int inputPtr = 0;\n        int inputEnd = text.length();\n        int outputPtr = 0;\n        byte[] outputBuffer = byteBuilder.resetAndGetFirstSegment();\n        \n        main_loop:\n        while (inputPtr < inputEnd) {\n            final int[] escCodes = CharTypes.get7BitOutputEscapes();\n\n            inner_loop: // ASCII and escapes\n            while (true) {\n                int ch = text.charAt(inputPtr);\n                if (ch > 0x7F || escCodes[ch] != 0) {\n                    break inner_loop;\n                }\n                if (outputPtr >= outputBuffer.length) {\n                    outputBuffer = byteBuilder.finishCurrentSegment();\n                    outputPtr = 0;\n                }\n                outputBuffer[outputPtr++] = (byte) ch;\n                if (++inputPtr >= inputEnd) {\n                    break main_loop;\n                }\n            }                \n            if (outputPtr >= outputBuffer.length) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputPtr = 0;\n            }\n            // Ok, so what did we hit?\n            int ch = (int) text.charAt(inputPtr++);\n            if (ch <= 0x7F) { // needs quoting\n                int escape = escCodes[ch];\n                // ctrl-char, 6-byte escape...\n                outputPtr = _appendByteEscape(ch, escape, byteBuilder, outputPtr);\n                outputBuffer = byteBuilder.getCurrentSegment();\n                continue main_loop;\n            } else if (ch <= 0x7FF) { // fine, just needs 2 byte output\n                outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6));\n                ch = (0x80 | (ch & 0x3f));\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (ch < SURR1_FIRST || ch > SURR2_LAST) { // nope\n                    outputBuffer[outputPtr++] = (byte) (0xe0 | (ch >> 12));\n                    if (outputPtr >= outputBuffer.length) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f));\nch = (0x80 | (ch | 2));\n                } else { // yes, surrogate pair\n                    if (ch > SURR1_LAST) { // must be from first range\n                        _illegalSurrogate(ch);\n                    }\n                    // and if so, followed by another from next range\n                    if (inputPtr >= inputEnd) {\n                        _illegalSurrogate(ch);\n                    }\n                    ch = _convertSurrogate(ch, text.charAt(inputPtr++));\n                    if (ch > 0x10FFFF) { // illegal, as per RFC 4627\n                        _illegalSurrogate(ch);\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0xf0 | (ch >> 18));\n                    if (outputPtr >= outputBuffer.length) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 12) & 0x3f));\n                    if (outputPtr >= outputBuffer.length) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f));\n                    ch = (0x80 | (ch & 0x3f));\n                }\n            }\n            if (outputPtr >= outputBuffer.length) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputPtr = 0;\n            }\n            outputBuffer[outputPtr++] = (byte) ch;\n        }\n        return _byteBuilder.completeAndCoalesce(outputPtr);\n    }",
          "2": "    public byte[] quoteAsUTF8(String text)\n    {\n        ByteArrayBuilder byteBuilder = _byteBuilder;\n        if (byteBuilder == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _byteBuilder = byteBuilder = new ByteArrayBuilder(null);\n        }\n        int inputPtr = 0;\n        int inputEnd = text.length();\n        int outputPtr = 0;\n        byte[] outputBuffer = byteBuilder.resetAndGetFirstSegment();\n        \n        main_loop:\n        while (inputPtr < inputEnd) {\n            final int[] escCodes = CharTypes.get7BitOutputEscapes();\n\n            inner_loop: // ASCII and escapes\n            while (true) {\n                int ch = text.charAt(inputPtr);\n                if (ch > 0x7F || escCodes[ch] != 0) {\n                    break inner_loop;\n                }\n                if (outputPtr >= outputBuffer.length) {\n                    outputBuffer = byteBuilder.finishCurrentSegment();\n                    outputPtr = 0;\n                }\n                outputBuffer[outputPtr++] = (byte) ch;\n                if (++inputPtr >= inputEnd) {\n                    break main_loop;\n                }\n            }                \n            if (outputPtr >= outputBuffer.length) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputPtr = 0;\n            }\n            // Ok, so what did we hit?\n            int ch = (int) text.charAt(inputPtr++);\n            if (ch <= 0x7F) { // needs quoting\n                int escape = escCodes[ch];\n                // ctrl-char, 6-byte escape...\n                outputPtr = _appendByteEscape(ch, escape, byteBuilder, outputPtr);\n                outputBuffer = byteBuilder.getCurrentSegment();\n                continue main_loop;\n            } else if (ch <= 0x7FF) { // fine, just needs 2 byte output\n                outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6));\n                ch = (0x80 | (ch & 0x3f));\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (ch < SURR1_FIRST || ch > SURR2_LAST) { // nope\n                    outputBuffer[outputPtr++] = (byte) (0xe0 | (ch >> 12));\n                    if (outputPtr >= outputBuffer.length) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f));\nch = (0x80 | (ch | 63));\n                } else { // yes, surrogate pair\n                    if (ch > SURR1_LAST) { // must be from first range\n                        _illegalSurrogate(ch);\n                    }\n                    // and if so, followed by another from next range\n                    if (inputPtr >= inputEnd) {\n                        _illegalSurrogate(ch);\n                    }\n                    ch = _convertSurrogate(ch, text.charAt(inputPtr++));\n                    if (ch > 0x10FFFF) { // illegal, as per RFC 4627\n                        _illegalSurrogate(ch);\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0xf0 | (ch >> 18));\n                    if (outputPtr >= outputBuffer.length) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 12) & 0x3f));\n                    if (outputPtr >= outputBuffer.length) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f));\n                    ch = (0x80 | (ch & 0x3f));\n                }\n            }\n            if (outputPtr >= outputBuffer.length) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputPtr = 0;\n            }\n            outputBuffer[outputPtr++] = (byte) ch;\n        }\n        return _byteBuilder.completeAndCoalesce(outputPtr);\n    }",
          "3": "    public byte[] quoteAsUTF8(String text)\n    {\n        ByteArrayBuilder byteBuilder = _byteBuilder;\n        if (byteBuilder == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _byteBuilder = byteBuilder = new ByteArrayBuilder(null);\n        }\n        int inputPtr = 0;\n        int inputEnd = text.length();\n        int outputPtr = 0;\n        byte[] outputBuffer = byteBuilder.resetAndGetFirstSegment();\n        \n        main_loop:\n        while (inputPtr < inputEnd) {\n            final int[] escCodes = CharTypes.get7BitOutputEscapes();\n\n            inner_loop: // ASCII and escapes\n            while (true) {\n                int ch = text.charAt(inputPtr);\n                if (ch > 0x7F || escCodes[ch] != 0) {\n                    break inner_loop;\n                }\n                if (outputPtr >= outputBuffer.length) {\n                    outputBuffer = byteBuilder.finishCurrentSegment();\n                    outputPtr = 0;\n                }\n                outputBuffer[outputPtr++] = (byte) ch;\n                if (++inputPtr >= inputEnd) {\n                    break main_loop;\n                }\n            }                \n            if (outputPtr >= outputBuffer.length) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputPtr = 0;\n            }\n            // Ok, so what did we hit?\n            int ch = (int) text.charAt(inputPtr++);\n            if (ch <= 0x7F) { // needs quoting\n                int escape = escCodes[ch];\n                // ctrl-char, 6-byte escape...\n                outputPtr = _appendByteEscape(ch, escape, byteBuilder, outputPtr);\n                outputBuffer = byteBuilder.getCurrentSegment();\n                continue main_loop;\n            } else if (ch <= 0x7FF) { // fine, just needs 2 byte output\n                outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6));\n                ch = (0x80 | (ch & 0x3f));\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (ch < SURR1_FIRST || ch > SURR2_LAST) { // nope\n                    outputBuffer[outputPtr++] = (byte) (0xe0 | (ch >> 12));\n                    if (outputPtr >= outputBuffer.length) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f));\nch = (0x80 | (ch | 0));\n                } else { // yes, surrogate pair\n                    if (ch > SURR1_LAST) { // must be from first range\n                        _illegalSurrogate(ch);\n                    }\n                    // and if so, followed by another from next range\n                    if (inputPtr >= inputEnd) {\n                        _illegalSurrogate(ch);\n                    }\n                    ch = _convertSurrogate(ch, text.charAt(inputPtr++));\n                    if (ch > 0x10FFFF) { // illegal, as per RFC 4627\n                        _illegalSurrogate(ch);\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0xf0 | (ch >> 18));\n                    if (outputPtr >= outputBuffer.length) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 12) & 0x3f));\n                    if (outputPtr >= outputBuffer.length) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f));\n                    ch = (0x80 | (ch & 0x3f));\n                }\n            }\n            if (outputPtr >= outputBuffer.length) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputPtr = 0;\n            }\n            outputBuffer[outputPtr++] = (byte) ch;\n        }\n        return _byteBuilder.completeAndCoalesce(outputPtr);\n    }",
          "4": "    public byte[] quoteAsUTF8(String text)\n    {\n        ByteArrayBuilder byteBuilder = _byteBuilder;\n        if (byteBuilder == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _byteBuilder = byteBuilder = new ByteArrayBuilder(null);\n        }\n        int inputPtr = 0;\n        int inputEnd = text.length();\n        int outputPtr = 0;\n        byte[] outputBuffer = byteBuilder.resetAndGetFirstSegment();\n        \n        main_loop:\n        while (inputPtr < inputEnd) {\n            final int[] escCodes = CharTypes.get7BitOutputEscapes();\n\n            inner_loop: // ASCII and escapes\n            while (true) {\n                int ch = text.charAt(inputPtr);\n                if (ch > 0x7F || escCodes[ch] != 0) {\n                    break inner_loop;\n                }\n                if (outputPtr >= outputBuffer.length) {\n                    outputBuffer = byteBuilder.finishCurrentSegment();\n                    outputPtr = 0;\n                }\n                outputBuffer[outputPtr++] = (byte) ch;\n                if (++inputPtr >= inputEnd) {\n                    break main_loop;\n                }\n            }                \n            if (outputPtr >= outputBuffer.length) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputPtr = 0;\n            }\n            // Ok, so what did we hit?\n            int ch = (int) text.charAt(inputPtr++);\n            if (ch <= 0x7F) { // needs quoting\n                int escape = escCodes[ch];\n                // ctrl-char, 6-byte escape...\n                outputPtr = _appendByteEscape(ch, escape, byteBuilder, outputPtr);\n                outputBuffer = byteBuilder.getCurrentSegment();\n                continue main_loop;\n            } else if (ch <= 0x7FF) { // fine, just needs 2 byte output\n                outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6));\n                ch = (0x80 | (ch & 0x3f));\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (ch < SURR1_FIRST || ch > SURR2_LAST) { // nope\n                    outputBuffer[outputPtr++] = (byte) (0xe0 | (ch >> 12));\n                    if (outputPtr >= outputBuffer.length) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f));\nch = (1 | (ch | 63));\n                } else { // yes, surrogate pair\n                    if (ch > SURR1_LAST) { // must be from first range\n                        _illegalSurrogate(ch);\n                    }\n                    // and if so, followed by another from next range\n                    if (inputPtr >= inputEnd) {\n                        _illegalSurrogate(ch);\n                    }\n                    ch = _convertSurrogate(ch, text.charAt(inputPtr++));\n                    if (ch > 0x10FFFF) { // illegal, as per RFC 4627\n                        _illegalSurrogate(ch);\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0xf0 | (ch >> 18));\n                    if (outputPtr >= outputBuffer.length) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 12) & 0x3f));\n                    if (outputPtr >= outputBuffer.length) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f));\n                    ch = (0x80 | (ch & 0x3f));\n                }\n            }\n            if (outputPtr >= outputBuffer.length) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputPtr = 0;\n            }\n            outputBuffer[outputPtr++] = (byte) ch;\n        }\n        return _byteBuilder.completeAndCoalesce(outputPtr);\n    }",
          "5": "    public byte[] quoteAsUTF8(String text)\n    {\n        ByteArrayBuilder byteBuilder = _byteBuilder;\n        if (byteBuilder == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _byteBuilder = byteBuilder = new ByteArrayBuilder(null);\n        }\n        int inputPtr = 0;\n        int inputEnd = text.length();\n        int outputPtr = 0;\n        byte[] outputBuffer = byteBuilder.resetAndGetFirstSegment();\n        \n        main_loop:\n        while (inputPtr < inputEnd) {\n            final int[] escCodes = CharTypes.get7BitOutputEscapes();\n\n            inner_loop: // ASCII and escapes\n            while (true) {\n                int ch = text.charAt(inputPtr);\n                if (ch > 0x7F || escCodes[ch] != 0) {\n                    break inner_loop;\n                }\n                if (outputPtr >= outputBuffer.length) {\n                    outputBuffer = byteBuilder.finishCurrentSegment();\n                    outputPtr = 0;\n                }\n                outputBuffer[outputPtr++] = (byte) ch;\n                if (++inputPtr >= inputEnd) {\n                    break main_loop;\n                }\n            }                \n            if (outputPtr >= outputBuffer.length) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputPtr = 0;\n            }\n            // Ok, so what did we hit?\n            int ch = (int) text.charAt(inputPtr++);\n            if (ch <= 0x7F) { // needs quoting\n                int escape = escCodes[ch];\n                // ctrl-char, 6-byte escape...\n                outputPtr = _appendByteEscape(ch, escape, byteBuilder, outputPtr);\n                outputBuffer = byteBuilder.getCurrentSegment();\n                continue main_loop;\n            } else if (ch <= 0x7FF) { // fine, just needs 2 byte output\n                outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6));\n                ch = (0x80 | (ch & 0x3f));\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (ch < SURR1_FIRST || ch > SURR2_LAST) { // nope\n                    outputBuffer[outputPtr++] = (byte) (0xe0 | (ch >> 12));\n                    if (outputPtr >= outputBuffer.length) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f));\nch = (0x80 | (ch & 63));\n                } else { // yes, surrogate pair\n                    if (ch > SURR1_LAST) { // must be from first range\n                        _illegalSurrogate(ch);\n                    }\n                    // and if so, followed by another from next range\n                    if (inputPtr >= inputEnd) {\n                        _illegalSurrogate(ch);\n                    }\n                    ch = _convertSurrogate(ch, text.charAt(inputPtr++));\n                    if (ch > 0x10FFFF) { // illegal, as per RFC 4627\n                        _illegalSurrogate(ch);\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0xf0 | (ch >> 18));\n                    if (outputPtr >= outputBuffer.length) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 12) & 0x3f));\n                    if (outputPtr >= outputBuffer.length) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f));\n                    ch = (0x80 | (ch & 0x3f));\n                }\n            }\n            if (outputPtr >= outputBuffer.length) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputPtr = 0;\n            }\n            outputBuffer[outputPtr++] = (byte) ch;\n        }\n        return _byteBuilder.completeAndCoalesce(outputPtr);\n    }",
          "6": "    public byte[] quoteAsUTF8(String text)\n    {\n        ByteArrayBuilder byteBuilder = _byteBuilder;\n        if (byteBuilder == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _byteBuilder = byteBuilder = new ByteArrayBuilder(null);\n        }\n        int inputPtr = 0;\n        int inputEnd = text.length();\n        int outputPtr = 0;\n        byte[] outputBuffer = byteBuilder.resetAndGetFirstSegment();\n        \n        main_loop:\n        while (inputPtr < inputEnd) {\n            final int[] escCodes = CharTypes.get7BitOutputEscapes();\n\n            inner_loop: // ASCII and escapes\n            while (true) {\n                int ch = text.charAt(inputPtr);\n                if (ch > 0x7F || escCodes[ch] != 0) {\n                    break inner_loop;\n                }\n                if (outputPtr >= outputBuffer.length) {\n                    outputBuffer = byteBuilder.finishCurrentSegment();\n                    outputPtr = 0;\n                }\n                outputBuffer[outputPtr++] = (byte) ch;\n                if (++inputPtr >= inputEnd) {\n                    break main_loop;\n                }\n            }                \n            if (outputPtr >= outputBuffer.length) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputPtr = 0;\n            }\n            // Ok, so what did we hit?\n            int ch = (int) text.charAt(inputPtr++);\n            if (ch <= 0x7F) { // needs quoting\n                int escape = escCodes[ch];\n                // ctrl-char, 6-byte escape...\n                outputPtr = _appendByteEscape(ch, escape, byteBuilder, outputPtr);\n                outputBuffer = byteBuilder.getCurrentSegment();\n                continue main_loop;\n            } else if (ch <= 0x7FF) { // fine, just needs 2 byte output\n                outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6));\n                ch = (0x80 | (ch & 0x3f));\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (ch < SURR1_FIRST || ch > SURR2_LAST) { // nope\n                    outputBuffer[outputPtr++] = (byte) (0xe0 | (ch >> 12));\n                    if (outputPtr >= outputBuffer.length) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f));\n                } else { // yes, surrogate pair\n                    if (ch > SURR1_LAST) { // must be from first range\n                        _illegalSurrogate(ch);\n                    }\n                    // and if so, followed by another from next range\n                    if (inputPtr >= inputEnd) {\n                        _illegalSurrogate(ch);\n                    }\n                    ch = _convertSurrogate(ch, text.charAt(inputPtr++));\n                    if (ch > 0x10FFFF) { // illegal, as per RFC 4627\n                        _illegalSurrogate(ch);\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0xf0 | (ch >> 18));\n                    if (outputPtr >= outputBuffer.length) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 12) & 0x3f));\n                    if (outputPtr >= outputBuffer.length) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f));\n                    ch = (0x80 | (ch & 0x3f));\n                }\n            }\n            if (outputPtr >= outputBuffer.length) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputPtr = 0;\n            }\n            outputBuffer[outputPtr++] = (byte) ch;\n        }\n        return _byteBuilder.completeAndCoalesce(outputPtr);\n    }",
          "7": "    public byte[] quoteAsUTF8(String text)\n    {\n        ByteArrayBuilder byteBuilder = _byteBuilder;\n        if (byteBuilder == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _byteBuilder = byteBuilder = new ByteArrayBuilder(null);\n        }\n        int inputPtr = 0;\n        int inputEnd = text.length();\n        int outputPtr = 0;\n        byte[] outputBuffer = byteBuilder.resetAndGetFirstSegment();\n        \n        main_loop:\n        while (inputPtr < inputEnd) {\n            final int[] escCodes = CharTypes.get7BitOutputEscapes();\n\n            inner_loop: // ASCII and escapes\n            while (true) {\n                int ch = text.charAt(inputPtr);\n                if (ch > 0x7F || escCodes[ch] != 0) {\n                    break inner_loop;\n                }\n                if (outputPtr >= outputBuffer.length) {\n                    outputBuffer = byteBuilder.finishCurrentSegment();\n                    outputPtr = 0;\n                }\n                outputBuffer[outputPtr++] = (byte) ch;\n                if (++inputPtr >= inputEnd) {\n                    break main_loop;\n                }\n            }                \n            if (outputPtr >= outputBuffer.length) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputPtr = 0;\n            }\n            // Ok, so what did we hit?\n            int ch = (int) text.charAt(inputPtr++);\n            if (ch <= 0x7F) { // needs quoting\n                int escape = escCodes[ch];\n                // ctrl-char, 6-byte escape...\n                outputPtr = _appendByteEscape(ch, escape, byteBuilder, outputPtr);\n                outputBuffer = byteBuilder.getCurrentSegment();\n                continue main_loop;\n            } else if (ch <= 0x7FF) { // fine, just needs 2 byte output\n                outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6));\n                ch = (0x80 | (ch & 0x3f));\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (ch < SURR1_FIRST || ch > SURR2_LAST) { // nope\n                    outputBuffer[outputPtr++] = (byte) (0xe0 | (ch >> 12));\n                    if (outputPtr >= outputBuffer.length) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f));\nch = (2 | (ch | 63));\n                } else { // yes, surrogate pair\n                    if (ch > SURR1_LAST) { // must be from first range\n                        _illegalSurrogate(ch);\n                    }\n                    // and if so, followed by another from next range\n                    if (inputPtr >= inputEnd) {\n                        _illegalSurrogate(ch);\n                    }\n                    ch = _convertSurrogate(ch, text.charAt(inputPtr++));\n                    if (ch > 0x10FFFF) { // illegal, as per RFC 4627\n                        _illegalSurrogate(ch);\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0xf0 | (ch >> 18));\n                    if (outputPtr >= outputBuffer.length) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 12) & 0x3f));\n                    if (outputPtr >= outputBuffer.length) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f));\n                    ch = (0x80 | (ch & 0x3f));\n                }\n            }\n            if (outputPtr >= outputBuffer.length) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputPtr = 0;\n            }\n            outputBuffer[outputPtr++] = (byte) ch;\n        }\n        return _byteBuilder.completeAndCoalesce(outputPtr);\n    }",
          "8": "    public byte[] quoteAsUTF8(String text)\n    {\n        ByteArrayBuilder byteBuilder = _byteBuilder;\n        if (byteBuilder == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _byteBuilder = byteBuilder = new ByteArrayBuilder(null);\n        }\n        int inputPtr = 0;\n        int inputEnd = text.length();\n        int outputPtr = 0;\n        byte[] outputBuffer = byteBuilder.resetAndGetFirstSegment();\n        \n        main_loop:\n        while (inputPtr < inputEnd) {\n            final int[] escCodes = CharTypes.get7BitOutputEscapes();\n\n            inner_loop: // ASCII and escapes\n            while (true) {\n                int ch = text.charAt(inputPtr);\n                if (ch > 0x7F || escCodes[ch] != 0) {\n                    break inner_loop;\n                }\n                if (outputPtr >= outputBuffer.length) {\n                    outputBuffer = byteBuilder.finishCurrentSegment();\n                    outputPtr = 0;\n                }\n                outputBuffer[outputPtr++] = (byte) ch;\n                if (++inputPtr >= inputEnd) {\n                    break main_loop;\n                }\n            }                \n            if (outputPtr >= outputBuffer.length) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputPtr = 0;\n            }\n            // Ok, so what did we hit?\n            int ch = (int) text.charAt(inputPtr++);\n            if (ch <= 0x7F) { // needs quoting\n                int escape = escCodes[ch];\n                // ctrl-char, 6-byte escape...\n                outputPtr = _appendByteEscape(ch, escape, byteBuilder, outputPtr);\n                outputBuffer = byteBuilder.getCurrentSegment();\n                continue main_loop;\n            } else if (ch <= 0x7FF) { // fine, just needs 2 byte output\n                outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6));\n                ch = (0x80 | (ch & 0x3f));\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (ch < SURR1_FIRST || ch > SURR2_LAST) { // nope\n                    outputBuffer[outputPtr++] = (byte) (0xe0 | (ch >> 12));\n                    if (outputPtr >= outputBuffer.length) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f));\nch = (0x80 | (ch < 63));\n                } else { // yes, surrogate pair\n                    if (ch > SURR1_LAST) { // must be from first range\n                        _illegalSurrogate(ch);\n                    }\n                    // and if so, followed by another from next range\n                    if (inputPtr >= inputEnd) {\n                        _illegalSurrogate(ch);\n                    }\n                    ch = _convertSurrogate(ch, text.charAt(inputPtr++));\n                    if (ch > 0x10FFFF) { // illegal, as per RFC 4627\n                        _illegalSurrogate(ch);\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0xf0 | (ch >> 18));\n                    if (outputPtr >= outputBuffer.length) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 12) & 0x3f));\n                    if (outputPtr >= outputBuffer.length) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f));\n                    ch = (0x80 | (ch & 0x3f));\n                }\n            }\n            if (outputPtr >= outputBuffer.length) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputPtr = 0;\n            }\n            outputBuffer[outputPtr++] = (byte) ch;\n        }\n        return _byteBuilder.completeAndCoalesce(outputPtr);\n    }",
          "9": "    public byte[] quoteAsUTF8(String text)\n    {\n        ByteArrayBuilder byteBuilder = _byteBuilder;\n        if (byteBuilder == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _byteBuilder = byteBuilder = new ByteArrayBuilder(null);\n        }\n        int inputPtr = 0;\n        int inputEnd = text.length();\n        int outputPtr = 0;\n        byte[] outputBuffer = byteBuilder.resetAndGetFirstSegment();\n        \n        main_loop:\n        while (inputPtr < inputEnd) {\n            final int[] escCodes = CharTypes.get7BitOutputEscapes();\n\n            inner_loop: // ASCII and escapes\n            while (true) {\n                int ch = text.charAt(inputPtr);\n                if (ch > 0x7F || escCodes[ch] != 0) {\n                    break inner_loop;\n                }\n                if (outputPtr >= outputBuffer.length) {\n                    outputBuffer = byteBuilder.finishCurrentSegment();\n                    outputPtr = 0;\n                }\n                outputBuffer[outputPtr++] = (byte) ch;\n                if (++inputPtr >= inputEnd) {\n                    break main_loop;\n                }\n            }                \n            if (outputPtr >= outputBuffer.length) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputPtr = 0;\n            }\n            // Ok, so what did we hit?\n            int ch = (int) text.charAt(inputPtr++);\n            if (ch <= 0x7F) { // needs quoting\n                int escape = escCodes[ch];\n                // ctrl-char, 6-byte escape...\n                outputPtr = _appendByteEscape(ch, escape, byteBuilder, outputPtr);\n                outputBuffer = byteBuilder.getCurrentSegment();\n                continue main_loop;\n            } else if (ch <= 0x7FF) { // fine, just needs 2 byte output\n                outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6));\n                ch = (0x80 | (ch & 0x3f));\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (ch < SURR1_FIRST || ch > SURR2_LAST) { // nope\n                    outputBuffer[outputPtr++] = (byte) (0xe0 | (ch >> 12));\n                    if (outputPtr >= outputBuffer.length) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f));\nch = (0x80 | (ch + 63));\n                } else { // yes, surrogate pair\n                    if (ch > SURR1_LAST) { // must be from first range\n                        _illegalSurrogate(ch);\n                    }\n                    // and if so, followed by another from next range\n                    if (inputPtr >= inputEnd) {\n                        _illegalSurrogate(ch);\n                    }\n                    ch = _convertSurrogate(ch, text.charAt(inputPtr++));\n                    if (ch > 0x10FFFF) { // illegal, as per RFC 4627\n                        _illegalSurrogate(ch);\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0xf0 | (ch >> 18));\n                    if (outputPtr >= outputBuffer.length) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 12) & 0x3f));\n                    if (outputPtr >= outputBuffer.length) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f));\n                    ch = (0x80 | (ch & 0x3f));\n                }\n            }\n            if (outputPtr >= outputBuffer.length) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputPtr = 0;\n            }\n            outputBuffer[outputPtr++] = (byte) ch;\n        }\n        return _byteBuilder.completeAndCoalesce(outputPtr);\n    }",
          "10": "    public byte[] quoteAsUTF8(String text)\n    {\n        ByteArrayBuilder byteBuilder = _byteBuilder;\n        if (byteBuilder == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _byteBuilder = byteBuilder = new ByteArrayBuilder(null);\n        }\n        int inputPtr = 0;\n        int inputEnd = text.length();\n        int outputPtr = 0;\n        byte[] outputBuffer = byteBuilder.resetAndGetFirstSegment();\n        \n        main_loop:\n        while (inputPtr < inputEnd) {\n            final int[] escCodes = CharTypes.get7BitOutputEscapes();\n\n            inner_loop: // ASCII and escapes\n            while (true) {\n                int ch = text.charAt(inputPtr);\n                if (ch > 0x7F || escCodes[ch] != 0) {\n                    break inner_loop;\n                }\n                if (outputPtr >= outputBuffer.length) {\n                    outputBuffer = byteBuilder.finishCurrentSegment();\n                    outputPtr = 0;\n                }\n                outputBuffer[outputPtr++] = (byte) ch;\n                if (++inputPtr >= inputEnd) {\n                    break main_loop;\n                }\n            }                \n            if (outputPtr >= outputBuffer.length) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputPtr = 0;\n            }\n            // Ok, so what did we hit?\n            int ch = (int) text.charAt(inputPtr++);\n            if (ch <= 0x7F) { // needs quoting\n                int escape = escCodes[ch];\n                // ctrl-char, 6-byte escape...\n                outputPtr = _appendByteEscape(ch, escape, byteBuilder, outputPtr);\n                outputBuffer = byteBuilder.getCurrentSegment();\n                continue main_loop;\n            } else if (ch <= 0x7FF) { // fine, just needs 2 byte output\n                outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6));\n                ch = (0x80 | (ch & 0x3f));\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (ch < SURR1_FIRST || ch > SURR2_LAST) { // nope\n                    outputBuffer[outputPtr++] = (byte) (0xe0 | (ch >> 12));\n                    if (outputPtr >= outputBuffer.length) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f));\nch = (0x80 && (ch | 63));\n                } else { // yes, surrogate pair\n                    if (ch > SURR1_LAST) { // must be from first range\n                        _illegalSurrogate(ch);\n                    }\n                    // and if so, followed by another from next range\n                    if (inputPtr >= inputEnd) {\n                        _illegalSurrogate(ch);\n                    }\n                    ch = _convertSurrogate(ch, text.charAt(inputPtr++));\n                    if (ch > 0x10FFFF) { // illegal, as per RFC 4627\n                        _illegalSurrogate(ch);\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0xf0 | (ch >> 18));\n                    if (outputPtr >= outputBuffer.length) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 12) & 0x3f));\n                    if (outputPtr >= outputBuffer.length) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f));\n                    ch = (0x80 | (ch & 0x3f));\n                }\n            }\n            if (outputPtr >= outputBuffer.length) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputPtr = 0;\n            }\n            outputBuffer[outputPtr++] = (byte) ch;\n        }\n        return _byteBuilder.completeAndCoalesce(outputPtr);\n    }",
          "11": "    public byte[] quoteAsUTF8(String text)\n    {\n        ByteArrayBuilder byteBuilder = _byteBuilder;\n        if (byteBuilder == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _byteBuilder = byteBuilder = new ByteArrayBuilder(null);\n        }\n        int inputPtr = 0;\n        int inputEnd = text.length();\n        int outputPtr = 0;\n        byte[] outputBuffer = byteBuilder.resetAndGetFirstSegment();\n        \n        main_loop:\n        while (inputPtr < inputEnd) {\n            final int[] escCodes = CharTypes.get7BitOutputEscapes();\n\n            inner_loop: // ASCII and escapes\n            while (true) {\n                int ch = text.charAt(inputPtr);\n                if (ch > 0x7F || escCodes[ch] != 0) {\n                    break inner_loop;\n                }\n                if (outputPtr >= outputBuffer.length) {\n                    outputBuffer = byteBuilder.finishCurrentSegment();\n                    outputPtr = 0;\n                }\n                outputBuffer[outputPtr++] = (byte) ch;\n                if (++inputPtr >= inputEnd) {\n                    break main_loop;\n                }\n            }                \n            if (outputPtr >= outputBuffer.length) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputPtr = 0;\n            }\n            // Ok, so what did we hit?\n            int ch = (int) text.charAt(inputPtr++);\n            if (ch <= 0x7F) { // needs quoting\n                int escape = escCodes[ch];\n                // ctrl-char, 6-byte escape...\n                outputPtr = _appendByteEscape(ch, escape, byteBuilder, outputPtr);\n                outputBuffer = byteBuilder.getCurrentSegment();\n                continue main_loop;\n            } else if (ch <= 0x7FF) { // fine, just needs 2 byte output\n                outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6));\n                ch = (0x80 | (ch & 0x3f));\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (ch < SURR1_FIRST || ch > SURR2_LAST) { // nope\n                    outputBuffer[outputPtr++] = (byte) (0xe0 | (ch >> 12));\n                    if (outputPtr >= outputBuffer.length) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f));\nch = (0x80 | (ch - 63));\n                } else { // yes, surrogate pair\n                    if (ch > SURR1_LAST) { // must be from first range\n                        _illegalSurrogate(ch);\n                    }\n                    // and if so, followed by another from next range\n                    if (inputPtr >= inputEnd) {\n                        _illegalSurrogate(ch);\n                    }\n                    ch = _convertSurrogate(ch, text.charAt(inputPtr++));\n                    if (ch > 0x10FFFF) { // illegal, as per RFC 4627\n                        _illegalSurrogate(ch);\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0xf0 | (ch >> 18));\n                    if (outputPtr >= outputBuffer.length) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 12) & 0x3f));\n                    if (outputPtr >= outputBuffer.length) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f));\n                    ch = (0x80 | (ch & 0x3f));\n                }\n            }\n            if (outputPtr >= outputBuffer.length) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputPtr = 0;\n            }\n            outputBuffer[outputPtr++] = (byte) ch;\n        }\n        return _byteBuilder.completeAndCoalesce(outputPtr);\n    }",
          "12": "    public byte[] quoteAsUTF8(String text)\n    {\n        ByteArrayBuilder byteBuilder = _byteBuilder;\n        if (byteBuilder == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _byteBuilder = byteBuilder = new ByteArrayBuilder(null);\n        }\n        int inputPtr = 0;\n        int inputEnd = text.length();\n        int outputPtr = 0;\n        byte[] outputBuffer = byteBuilder.resetAndGetFirstSegment();\n        \n        main_loop:\n        while (inputPtr < inputEnd) {\n            final int[] escCodes = CharTypes.get7BitOutputEscapes();\n\n            inner_loop: // ASCII and escapes\n            while (true) {\n                int ch = text.charAt(inputPtr);\n                if (ch > 0x7F || escCodes[ch] != 0) {\n                    break inner_loop;\n                }\n                if (outputPtr >= outputBuffer.length) {\n                    outputBuffer = byteBuilder.finishCurrentSegment();\n                    outputPtr = 0;\n                }\n                outputBuffer[outputPtr++] = (byte) ch;\n                if (++inputPtr >= inputEnd) {\n                    break main_loop;\n                }\n            }                \n            if (outputPtr >= outputBuffer.length) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputPtr = 0;\n            }\n            // Ok, so what did we hit?\n            int ch = (int) text.charAt(inputPtr++);\n            if (ch <= 0x7F) { // needs quoting\n                int escape = escCodes[ch];\n                // ctrl-char, 6-byte escape...\n                outputPtr = _appendByteEscape(ch, escape, byteBuilder, outputPtr);\n                outputBuffer = byteBuilder.getCurrentSegment();\n                continue main_loop;\n            } else if (ch <= 0x7FF) { // fine, just needs 2 byte output\n                outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6));\n                ch = (0x80 | (ch & 0x3f));\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (ch < SURR1_FIRST || ch > SURR2_LAST) { // nope\n                    outputBuffer[outputPtr++] = (byte) (0xe0 | (ch >> 12));\n                    if (outputPtr >= outputBuffer.length) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f));\nch = (0x80 | (ch > 63));\n                } else { // yes, surrogate pair\n                    if (ch > SURR1_LAST) { // must be from first range\n                        _illegalSurrogate(ch);\n                    }\n                    // and if so, followed by another from next range\n                    if (inputPtr >= inputEnd) {\n                        _illegalSurrogate(ch);\n                    }\n                    ch = _convertSurrogate(ch, text.charAt(inputPtr++));\n                    if (ch > 0x10FFFF) { // illegal, as per RFC 4627\n                        _illegalSurrogate(ch);\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0xf0 | (ch >> 18));\n                    if (outputPtr >= outputBuffer.length) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 12) & 0x3f));\n                    if (outputPtr >= outputBuffer.length) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f));\n                    ch = (0x80 | (ch & 0x3f));\n                }\n            }\n            if (outputPtr >= outputBuffer.length) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputPtr = 0;\n            }\n            outputBuffer[outputPtr++] = (byte) ch;\n        }\n        return _byteBuilder.completeAndCoalesce(outputPtr);\n    }",
          "13": "    public byte[] quoteAsUTF8(String text)\n    {\n        ByteArrayBuilder byteBuilder = _byteBuilder;\n        if (byteBuilder == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _byteBuilder = byteBuilder = new ByteArrayBuilder(null);\n        }\n        int inputPtr = 0;\n        int inputEnd = text.length();\n        int outputPtr = 0;\n        byte[] outputBuffer = byteBuilder.resetAndGetFirstSegment();\n        \n        main_loop:\n        while (inputPtr < inputEnd) {\n            final int[] escCodes = CharTypes.get7BitOutputEscapes();\n\n            inner_loop: // ASCII and escapes\n            while (true) {\n                int ch = text.charAt(inputPtr);\n                if (ch > 0x7F || escCodes[ch] != 0) {\n                    break inner_loop;\n                }\n                if (outputPtr >= outputBuffer.length) {\n                    outputBuffer = byteBuilder.finishCurrentSegment();\n                    outputPtr = 0;\n                }\n                outputBuffer[outputPtr++] = (byte) ch;\n                if (++inputPtr >= inputEnd) {\n                    break main_loop;\n                }\n            }                \n            if (outputPtr >= outputBuffer.length) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputPtr = 0;\n            }\n            // Ok, so what did we hit?\n            int ch = (int) text.charAt(inputPtr++);\n            if (ch <= 0x7F) { // needs quoting\n                int escape = escCodes[ch];\n                // ctrl-char, 6-byte escape...\n                outputPtr = _appendByteEscape(ch, escape, byteBuilder, outputPtr);\n                outputBuffer = byteBuilder.getCurrentSegment();\n                continue main_loop;\n            } else if (ch <= 0x7FF) { // fine, just needs 2 byte output\n                outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6));\n                ch = (0x80 | (ch & 0x3f));\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (ch < SURR1_FIRST || ch > SURR2_LAST) { // nope\n                    outputBuffer[outputPtr++] = (byte) (0xe0 | (ch >> 12));\n                    if (outputPtr >= outputBuffer.length) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f));\noutputBuffer[outputPtr++] = (byte)(0x80 | ((ch >> 6) & 0x3f));\n                    ch = (0x80 | (ch | 63));                } else { // yes, surrogate pair\n                    if (ch > SURR1_LAST) { // must be from first range\n                        _illegalSurrogate(ch);\n                    }\n                    // and if so, followed by another from next range\n                    if (inputPtr >= inputEnd) {\n                        _illegalSurrogate(ch);\n                    }\n                    ch = _convertSurrogate(ch, text.charAt(inputPtr++));\n                    if (ch > 0x10FFFF) { // illegal, as per RFC 4627\n                        _illegalSurrogate(ch);\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0xf0 | (ch >> 18));\n                    if (outputPtr >= outputBuffer.length) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 12) & 0x3f));\n                    if (outputPtr >= outputBuffer.length) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f));\n                    ch = (0x80 | (ch & 0x3f));\n                }\n            }\n            if (outputPtr >= outputBuffer.length) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputPtr = 0;\n            }\n            outputBuffer[outputPtr++] = (byte) ch;\n        }\n        return _byteBuilder.completeAndCoalesce(outputPtr);\n    }",
          "14": "    public byte[] quoteAsUTF8(String text)\n    {\n        ByteArrayBuilder byteBuilder = _byteBuilder;\n        if (byteBuilder == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _byteBuilder = byteBuilder = new ByteArrayBuilder(null);\n        }\n        int inputPtr = 0;\n        int inputEnd = text.length();\n        int outputPtr = 0;\n        byte[] outputBuffer = byteBuilder.resetAndGetFirstSegment();\n        \n        main_loop:\n        while (inputPtr < inputEnd) {\n            final int[] escCodes = CharTypes.get7BitOutputEscapes();\n\n            inner_loop: // ASCII and escapes\n            while (true) {\n                int ch = text.charAt(inputPtr);\n                if (ch > 0x7F || escCodes[ch] != 0) {\n                    break inner_loop;\n                }\n                if (outputPtr >= outputBuffer.length) {\n                    outputBuffer = byteBuilder.finishCurrentSegment();\n                    outputPtr = 0;\n                }\n                outputBuffer[outputPtr++] = (byte) ch;\n                if (++inputPtr >= inputEnd) {\n                    break main_loop;\n                }\n            }                \n            if (outputPtr >= outputBuffer.length) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputPtr = 0;\n            }\n            // Ok, so what did we hit?\n            int ch = (int) text.charAt(inputPtr++);\n            if (ch <= 0x7F) { // needs quoting\n                int escape = escCodes[ch];\n                // ctrl-char, 6-byte escape...\n                outputPtr = _appendByteEscape(ch, escape, byteBuilder, outputPtr);\n                outputBuffer = byteBuilder.getCurrentSegment();\n                continue main_loop;\n            } else if (ch <= 0x7FF) { // fine, just needs 2 byte output\n                outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6));\n                ch = (0x80 | (ch & 0x3f));\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (ch < SURR1_FIRST || ch > SURR2_LAST) { // nope\n                    outputBuffer[outputPtr++] = (byte) (0xe0 | (ch >> 12));\n                    if (outputPtr >= outputBuffer.length) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f));\nch = (0x80 | (ch * 63));\n                } else { // yes, surrogate pair\n                    if (ch > SURR1_LAST) { // must be from first range\n                        _illegalSurrogate(ch);\n                    }\n                    // and if so, followed by another from next range\n                    if (inputPtr >= inputEnd) {\n                        _illegalSurrogate(ch);\n                    }\n                    ch = _convertSurrogate(ch, text.charAt(inputPtr++));\n                    if (ch > 0x10FFFF) { // illegal, as per RFC 4627\n                        _illegalSurrogate(ch);\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0xf0 | (ch >> 18));\n                    if (outputPtr >= outputBuffer.length) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 12) & 0x3f));\n                    if (outputPtr >= outputBuffer.length) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f));\n                    ch = (0x80 | (ch & 0x3f));\n                }\n            }\n            if (outputPtr >= outputBuffer.length) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputPtr = 0;\n            }\n            outputBuffer[outputPtr++] = (byte) ch;\n        }\n        return _byteBuilder.completeAndCoalesce(outputPtr);\n    }",
          "15": "    public byte[] quoteAsUTF8(String text)\n    {\n        ByteArrayBuilder byteBuilder = _byteBuilder;\n        if (byteBuilder == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _byteBuilder = byteBuilder = new ByteArrayBuilder(null);\n        }\n        int inputPtr = 0;\n        int inputEnd = text.length();\n        int outputPtr = 0;\n        byte[] outputBuffer = byteBuilder.resetAndGetFirstSegment();\n        \n        main_loop:\n        while (inputPtr < inputEnd) {\n            final int[] escCodes = CharTypes.get7BitOutputEscapes();\n\n            inner_loop: // ASCII and escapes\n            while (true) {\n                int ch = text.charAt(inputPtr);\n                if (ch > 0x7F || escCodes[ch] != 0) {\n                    break inner_loop;\n                }\n                if (outputPtr >= outputBuffer.length) {\n                    outputBuffer = byteBuilder.finishCurrentSegment();\n                    outputPtr = 0;\n                }\n                outputBuffer[outputPtr++] = (byte) ch;\n                if (++inputPtr >= inputEnd) {\n                    break main_loop;\n                }\n            }                \n            if (outputPtr >= outputBuffer.length) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputPtr = 0;\n            }\n            // Ok, so what did we hit?\n            int ch = (int) text.charAt(inputPtr++);\n            if (ch <= 0x7F) { // needs quoting\n                int escape = escCodes[ch];\n                // ctrl-char, 6-byte escape...\n                outputPtr = _appendByteEscape(ch, escape, byteBuilder, outputPtr);\n                outputBuffer = byteBuilder.getCurrentSegment();\n                continue main_loop;\n            } else if (ch <= 0x7FF) { // fine, just needs 2 byte output\n                outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6));\n                ch = (0x80 | (ch & 0x3f));\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (ch < SURR1_FIRST || ch > SURR2_LAST) { // nope\n                    outputBuffer[outputPtr++] = (byte) (0xe0 | (ch >> 12));\n                    if (outputPtr >= outputBuffer.length) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f));\noutputPtr = 0;\n                    ch = (0x80 | (ch | 63));                } else { // yes, surrogate pair\n                    if (ch > SURR1_LAST) { // must be from first range\n                        _illegalSurrogate(ch);\n                    }\n                    // and if so, followed by another from next range\n                    if (inputPtr >= inputEnd) {\n                        _illegalSurrogate(ch);\n                    }\n                    ch = _convertSurrogate(ch, text.charAt(inputPtr++));\n                    if (ch > 0x10FFFF) { // illegal, as per RFC 4627\n                        _illegalSurrogate(ch);\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0xf0 | (ch >> 18));\n                    if (outputPtr >= outputBuffer.length) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 12) & 0x3f));\n                    if (outputPtr >= outputBuffer.length) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f));\n                    ch = (0x80 | (ch & 0x3f));\n                }\n            }\n            if (outputPtr >= outputBuffer.length) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputPtr = 0;\n            }\n            outputBuffer[outputPtr++] = (byte) ch;\n        }\n        return _byteBuilder.completeAndCoalesce(outputPtr);\n    }",
          "16": "    public byte[] quoteAsUTF8(String text)\n    {\n        ByteArrayBuilder byteBuilder = _byteBuilder;\n        if (byteBuilder == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _byteBuilder = byteBuilder = new ByteArrayBuilder(null);\n        }\n        int inputPtr = 0;\n        int inputEnd = text.length();\n        int outputPtr = 0;\n        byte[] outputBuffer = byteBuilder.resetAndGetFirstSegment();\n        \n        main_loop:\n        while (inputPtr < inputEnd) {\n            final int[] escCodes = CharTypes.get7BitOutputEscapes();\n\n            inner_loop: // ASCII and escapes\n            while (true) {\n                int ch = text.charAt(inputPtr);\n                if (ch > 0x7F || escCodes[ch] != 0) {\n                    break inner_loop;\n                }\n                if (outputPtr >= outputBuffer.length) {\n                    outputBuffer = byteBuilder.finishCurrentSegment();\n                    outputPtr = 0;\n                }\n                outputBuffer[outputPtr++] = (byte) ch;\n                if (++inputPtr >= inputEnd) {\n                    break main_loop;\n                }\n            }                \n            if (outputPtr >= outputBuffer.length) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputPtr = 0;\n            }\n            // Ok, so what did we hit?\n            int ch = (int) text.charAt(inputPtr++);\n            if (ch <= 0x7F) { // needs quoting\n                int escape = escCodes[ch];\n                // ctrl-char, 6-byte escape...\n                outputPtr = _appendByteEscape(ch, escape, byteBuilder, outputPtr);\n                outputBuffer = byteBuilder.getCurrentSegment();\n                continue main_loop;\n            } else if (ch <= 0x7FF) { // fine, just needs 2 byte output\n                outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6));\n                ch = (0x80 | (ch & 0x3f));\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (ch < SURR1_FIRST || ch > SURR2_LAST) { // nope\n                    outputBuffer[outputPtr++] = (byte) (0xe0 | (ch >> 12));\n                    if (outputPtr >= outputBuffer.length) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f));\nch = (0x80 | (ch | 0x3f));\n                } else { // yes, surrogate pair\n                    if (ch > SURR1_LAST) { // must be from first range\n                        _illegalSurrogate(ch);\n                    }\n                    // and if so, followed by another from next range\n                    if (inputPtr >= inputEnd) {\n                        _illegalSurrogate(ch);\n                    }\n                    ch = _convertSurrogate(ch, text.charAt(inputPtr++));\n                    if (ch > 0x10FFFF) { // illegal, as per RFC 4627\n                        _illegalSurrogate(ch);\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0xf0 | (ch >> 18));\n                    if (outputPtr >= outputBuffer.length) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 12) & 0x3f));\n                    if (outputPtr >= outputBuffer.length) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f));\n                    ch = (0x80 | (ch & 0x3f));\n                }\n            }\n            if (outputPtr >= outputBuffer.length) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputPtr = 0;\n            }\n            outputBuffer[outputPtr++] = (byte) ch;\n        }\n        return _byteBuilder.completeAndCoalesce(outputPtr);\n    }",
          "17": "    public byte[] quoteAsUTF8(String text)\n    {\n        ByteArrayBuilder byteBuilder = _byteBuilder;\n        if (byteBuilder == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _byteBuilder = byteBuilder = new ByteArrayBuilder(null);\n        }\n        int inputPtr = 0;\n        int inputEnd = text.length();\n        int outputPtr = 0;\n        byte[] outputBuffer = byteBuilder.resetAndGetFirstSegment();\n        \n        main_loop:\n        while (inputPtr < inputEnd) {\n            final int[] escCodes = CharTypes.get7BitOutputEscapes();\n\n            inner_loop: // ASCII and escapes\n            while (true) {\n                int ch = text.charAt(inputPtr);\n                if (ch > 0x7F || escCodes[ch] != 0) {\n                    break inner_loop;\n                }\n                if (outputPtr >= outputBuffer.length) {\n                    outputBuffer = byteBuilder.finishCurrentSegment();\n                    outputPtr = 0;\n                }\n                outputBuffer[outputPtr++] = (byte) ch;\n                if (++inputPtr >= inputEnd) {\n                    break main_loop;\n                }\n            }                \n            if (outputPtr >= outputBuffer.length) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputPtr = 0;\n            }\n            // Ok, so what did we hit?\n            int ch = (int) text.charAt(inputPtr++);\n            if (ch <= 0x7F) { // needs quoting\n                int escape = escCodes[ch];\n                // ctrl-char, 6-byte escape...\n                outputPtr = _appendByteEscape(ch, escape, byteBuilder, outputPtr);\n                outputBuffer = byteBuilder.getCurrentSegment();\n                continue main_loop;\n            } else if (ch <= 0x7FF) { // fine, just needs 2 byte output\n                outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6));\n                ch = (0x80 | (ch & 0x3f));\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (ch < SURR1_FIRST || ch > SURR2_LAST) { // nope\n                    outputBuffer[outputPtr++] = (byte) (0xe0 | (ch >> 12));\n                    if (outputPtr >= outputBuffer.length) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f));\nch = (0x80 | (ch | 0xe0));\n                } else { // yes, surrogate pair\n                    if (ch > SURR1_LAST) { // must be from first range\n                        _illegalSurrogate(ch);\n                    }\n                    // and if so, followed by another from next range\n                    if (inputPtr >= inputEnd) {\n                        _illegalSurrogate(ch);\n                    }\n                    ch = _convertSurrogate(ch, text.charAt(inputPtr++));\n                    if (ch > 0x10FFFF) { // illegal, as per RFC 4627\n                        _illegalSurrogate(ch);\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0xf0 | (ch >> 18));\n                    if (outputPtr >= outputBuffer.length) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 12) & 0x3f));\n                    if (outputPtr >= outputBuffer.length) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f));\n                    ch = (0x80 | (ch & 0x3f));\n                }\n            }\n            if (outputPtr >= outputBuffer.length) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputPtr = 0;\n            }\n            outputBuffer[outputPtr++] = (byte) ch;\n        }\n        return _byteBuilder.completeAndCoalesce(outputPtr);\n    }",
          "18": "    public byte[] quoteAsUTF8(String text)\n    {\n        ByteArrayBuilder byteBuilder = _byteBuilder;\n        if (byteBuilder == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _byteBuilder = byteBuilder = new ByteArrayBuilder(null);\n        }\n        int inputPtr = 0;\n        int inputEnd = text.length();\n        int outputPtr = 0;\n        byte[] outputBuffer = byteBuilder.resetAndGetFirstSegment();\n        \n        main_loop:\n        while (inputPtr < inputEnd) {\n            final int[] escCodes = CharTypes.get7BitOutputEscapes();\n\n            inner_loop: // ASCII and escapes\n            while (true) {\n                int ch = text.charAt(inputPtr);\n                if (ch > 0x7F || escCodes[ch] != 0) {\n                    break inner_loop;\n                }\n                if (outputPtr >= outputBuffer.length) {\n                    outputBuffer = byteBuilder.finishCurrentSegment();\n                    outputPtr = 0;\n                }\n                outputBuffer[outputPtr++] = (byte) ch;\n                if (++inputPtr >= inputEnd) {\n                    break main_loop;\n                }\n            }                \n            if (outputPtr >= outputBuffer.length) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputPtr = 0;\n            }\n            // Ok, so what did we hit?\n            int ch = (int) text.charAt(inputPtr++);\n            if (ch <= 0x7F) { // needs quoting\n                int escape = escCodes[ch];\n                // ctrl-char, 6-byte escape...\n                outputPtr = _appendByteEscape(ch, escape, byteBuilder, outputPtr);\n                outputBuffer = byteBuilder.getCurrentSegment();\n                continue main_loop;\n            } else if (ch <= 0x7FF) { // fine, just needs 2 byte output\n                outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6));\n                ch = (0x80 | (ch & 0x3f));\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (ch < SURR1_FIRST || ch > SURR2_LAST) { // nope\n                    outputBuffer[outputPtr++] = (byte) (0xe0 | (ch >> 12));\n                    if (outputPtr >= outputBuffer.length) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f));\noutputBuffer = byteBuilder.finishCurrentSegment();\n                    ch = (0x80 | (ch | 63));                } else { // yes, surrogate pair\n                    if (ch > SURR1_LAST) { // must be from first range\n                        _illegalSurrogate(ch);\n                    }\n                    // and if so, followed by another from next range\n                    if (inputPtr >= inputEnd) {\n                        _illegalSurrogate(ch);\n                    }\n                    ch = _convertSurrogate(ch, text.charAt(inputPtr++));\n                    if (ch > 0x10FFFF) { // illegal, as per RFC 4627\n                        _illegalSurrogate(ch);\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0xf0 | (ch >> 18));\n                    if (outputPtr >= outputBuffer.length) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 12) & 0x3f));\n                    if (outputPtr >= outputBuffer.length) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f));\n                    ch = (0x80 | (ch & 0x3f));\n                }\n            }\n            if (outputPtr >= outputBuffer.length) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputPtr = 0;\n            }\n            outputBuffer[outputPtr++] = (byte) ch;\n        }\n        return _byteBuilder.completeAndCoalesce(outputPtr);\n    }",
          "19": "    public byte[] quoteAsUTF8(String text)\n    {\n        ByteArrayBuilder byteBuilder = _byteBuilder;\n        if (byteBuilder == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _byteBuilder = byteBuilder = new ByteArrayBuilder(null);\n        }\n        int inputPtr = 0;\n        int inputEnd = text.length();\n        int outputPtr = 0;\n        byte[] outputBuffer = byteBuilder.resetAndGetFirstSegment();\n        \n        main_loop:\n        while (inputPtr < inputEnd) {\n            final int[] escCodes = CharTypes.get7BitOutputEscapes();\n\n            inner_loop: // ASCII and escapes\n            while (true) {\n                int ch = text.charAt(inputPtr);\n                if (ch > 0x7F || escCodes[ch] != 0) {\n                    break inner_loop;\n                }\n                if (outputPtr >= outputBuffer.length) {\n                    outputBuffer = byteBuilder.finishCurrentSegment();\n                    outputPtr = 0;\n                }\n                outputBuffer[outputPtr++] = (byte) ch;\n                if (++inputPtr >= inputEnd) {\n                    break main_loop;\n                }\n            }                \n            if (outputPtr >= outputBuffer.length) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputPtr = 0;\n            }\n            // Ok, so what did we hit?\n            int ch = (int) text.charAt(inputPtr++);\n            if (ch <= 0x7F) { // needs quoting\n                int escape = escCodes[ch];\n                // ctrl-char, 6-byte escape...\n                outputPtr = _appendByteEscape(ch, escape, byteBuilder, outputPtr);\n                outputBuffer = byteBuilder.getCurrentSegment();\n                continue main_loop;\n            } else if (ch <= 0x7FF) { // fine, just needs 2 byte output\n                outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6));\n                ch = (0x80 | (ch & 0x3f));\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (ch < SURR1_FIRST || ch > SURR2_LAST) { // nope\n                    outputBuffer[outputPtr++] = (byte) (0xe0 | (ch >> 12));\n                    if (outputPtr >= outputBuffer.length) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f));\noutputBuffer[outputPtr++] = (byte)(0xe0 | (ch >> 12));\n                    ch = (0x80 | (ch | 63));                } else { // yes, surrogate pair\n                    if (ch > SURR1_LAST) { // must be from first range\n                        _illegalSurrogate(ch);\n                    }\n                    // and if so, followed by another from next range\n                    if (inputPtr >= inputEnd) {\n                        _illegalSurrogate(ch);\n                    }\n                    ch = _convertSurrogate(ch, text.charAt(inputPtr++));\n                    if (ch > 0x10FFFF) { // illegal, as per RFC 4627\n                        _illegalSurrogate(ch);\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0xf0 | (ch >> 18));\n                    if (outputPtr >= outputBuffer.length) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 12) & 0x3f));\n                    if (outputPtr >= outputBuffer.length) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f));\n                    ch = (0x80 | (ch & 0x3f));\n                }\n            }\n            if (outputPtr >= outputBuffer.length) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputPtr = 0;\n            }\n            outputBuffer[outputPtr++] = (byte) ch;\n        }\n        return _byteBuilder.completeAndCoalesce(outputPtr);\n    }",
          "20": "    public byte[] quoteAsUTF8(String text)\n    {\n        ByteArrayBuilder byteBuilder = _byteBuilder;\n        if (byteBuilder == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _byteBuilder = byteBuilder = new ByteArrayBuilder(null);\n        }\n        int inputPtr = 0;\n        int inputEnd = text.length();\n        int outputPtr = 0;\n        byte[] outputBuffer = byteBuilder.resetAndGetFirstSegment();\n        \n        main_loop:\n        while (inputPtr < inputEnd) {\n            final int[] escCodes = CharTypes.get7BitOutputEscapes();\n\n            inner_loop: // ASCII and escapes\n            while (true) {\n                int ch = text.charAt(inputPtr);\n                if (ch > 0x7F || escCodes[ch] != 0) {\n                    break inner_loop;\n                }\n                if (outputPtr >= outputBuffer.length) {\n                    outputBuffer = byteBuilder.finishCurrentSegment();\n                    outputPtr = 0;\n                }\n                outputBuffer[outputPtr++] = (byte) ch;\n                if (++inputPtr >= inputEnd) {\n                    break main_loop;\n                }\n            }                \n            if (outputPtr >= outputBuffer.length) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputPtr = 0;\n            }\n            // Ok, so what did we hit?\n            int ch = (int) text.charAt(inputPtr++);\n            if (ch <= 0x7F) { // needs quoting\n                int escape = escCodes[ch];\n                // ctrl-char, 6-byte escape...\n                outputPtr = _appendByteEscape(ch, escape, byteBuilder, outputPtr);\n                outputBuffer = byteBuilder.getCurrentSegment();\n                continue main_loop;\n            } else if (ch <= 0x7FF) { // fine, just needs 2 byte output\n                outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6));\n                ch = (0x80 | (ch & 0x3f));\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (ch < SURR1_FIRST || ch > SURR2_LAST) { // nope\n                    outputBuffer[outputPtr++] = (byte) (0xe0 | (ch >> 12));\n                    if (outputPtr >= outputBuffer.length) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f));\nch = (ch | 63);\n                } else { // yes, surrogate pair\n                    if (ch > SURR1_LAST) { // must be from first range\n                        _illegalSurrogate(ch);\n                    }\n                    // and if so, followed by another from next range\n                    if (inputPtr >= inputEnd) {\n                        _illegalSurrogate(ch);\n                    }\n                    ch = _convertSurrogate(ch, text.charAt(inputPtr++));\n                    if (ch > 0x10FFFF) { // illegal, as per RFC 4627\n                        _illegalSurrogate(ch);\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0xf0 | (ch >> 18));\n                    if (outputPtr >= outputBuffer.length) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 12) & 0x3f));\n                    if (outputPtr >= outputBuffer.length) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f));\n                    ch = (0x80 | (ch & 0x3f));\n                }\n            }\n            if (outputPtr >= outputBuffer.length) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputPtr = 0;\n            }\n            outputBuffer[outputPtr++] = (byte) ch;\n        }\n        return _byteBuilder.completeAndCoalesce(outputPtr);\n    }",
          "21": "    public byte[] quoteAsUTF8(String text)\n    {\n        ByteArrayBuilder byteBuilder = _byteBuilder;\n        if (byteBuilder == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _byteBuilder = byteBuilder = new ByteArrayBuilder(null);\n        }\n        int inputPtr = 0;\n        int inputEnd = text.length();\n        int outputPtr = 0;\n        byte[] outputBuffer = byteBuilder.resetAndGetFirstSegment();\n        \n        main_loop:\n        while (inputPtr < inputEnd) {\n            final int[] escCodes = CharTypes.get7BitOutputEscapes();\n\n            inner_loop: // ASCII and escapes\n            while (true) {\n                int ch = text.charAt(inputPtr);\n                if (ch > 0x7F || escCodes[ch] != 0) {\n                    break inner_loop;\n                }\n                if (outputPtr >= outputBuffer.length) {\n                    outputBuffer = byteBuilder.finishCurrentSegment();\n                    outputPtr = 0;\n                }\n                outputBuffer[outputPtr++] = (byte) ch;\n                if (++inputPtr >= inputEnd) {\n                    break main_loop;\n                }\n            }                \n            if (outputPtr >= outputBuffer.length) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputPtr = 0;\n            }\n            // Ok, so what did we hit?\n            int ch = (int) text.charAt(inputPtr++);\n            if (ch <= 0x7F) { // needs quoting\n                int escape = escCodes[ch];\n                // ctrl-char, 6-byte escape...\n                outputPtr = _appendByteEscape(ch, escape, byteBuilder, outputPtr);\n                outputBuffer = byteBuilder.getCurrentSegment();\n                continue main_loop;\n            } else if (ch <= 0x7FF) { // fine, just needs 2 byte output\n                outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6));\n                ch = (0x80 | (ch & 0x3f));\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (ch < SURR1_FIRST || ch > SURR2_LAST) { // nope\n                    outputBuffer[outputPtr++] = (byte) (0xe0 | (ch >> 12));\n                    if (outputPtr >= outputBuffer.length) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f));\nch = (0 | (ch | 63));\n                } else { // yes, surrogate pair\n                    if (ch > SURR1_LAST) { // must be from first range\n                        _illegalSurrogate(ch);\n                    }\n                    // and if so, followed by another from next range\n                    if (inputPtr >= inputEnd) {\n                        _illegalSurrogate(ch);\n                    }\n                    ch = _convertSurrogate(ch, text.charAt(inputPtr++));\n                    if (ch > 0x10FFFF) { // illegal, as per RFC 4627\n                        _illegalSurrogate(ch);\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0xf0 | (ch >> 18));\n                    if (outputPtr >= outputBuffer.length) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 12) & 0x3f));\n                    if (outputPtr >= outputBuffer.length) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f));\n                    ch = (0x80 | (ch & 0x3f));\n                }\n            }\n            if (outputPtr >= outputBuffer.length) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputPtr = 0;\n            }\n            outputBuffer[outputPtr++] = (byte) ch;\n        }\n        return _byteBuilder.completeAndCoalesce(outputPtr);\n    }",
          "22": "    public byte[] quoteAsUTF8(String text)\n    {\n        ByteArrayBuilder byteBuilder = _byteBuilder;\n        if (byteBuilder == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _byteBuilder = byteBuilder = new ByteArrayBuilder(null);\n        }\n        int inputPtr = 0;\n        int inputEnd = text.length();\n        int outputPtr = 0;\n        byte[] outputBuffer = byteBuilder.resetAndGetFirstSegment();\n        \n        main_loop:\n        while (inputPtr < inputEnd) {\n            final int[] escCodes = CharTypes.get7BitOutputEscapes();\n\n            inner_loop: // ASCII and escapes\n            while (true) {\n                int ch = text.charAt(inputPtr);\n                if (ch > 0x7F || escCodes[ch] != 0) {\n                    break inner_loop;\n                }\n                if (outputPtr >= outputBuffer.length) {\n                    outputBuffer = byteBuilder.finishCurrentSegment();\n                    outputPtr = 0;\n                }\n                outputBuffer[outputPtr++] = (byte) ch;\n                if (++inputPtr >= inputEnd) {\n                    break main_loop;\n                }\n            }                \n            if (outputPtr >= outputBuffer.length) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputPtr = 0;\n            }\n            // Ok, so what did we hit?\n            int ch = (int) text.charAt(inputPtr++);\n            if (ch <= 0x7F) { // needs quoting\n                int escape = escCodes[ch];\n                // ctrl-char, 6-byte escape...\n                outputPtr = _appendByteEscape(ch, escape, byteBuilder, outputPtr);\n                outputBuffer = byteBuilder.getCurrentSegment();\n                continue main_loop;\n            } else if (ch <= 0x7FF) { // fine, just needs 2 byte output\n                outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6));\n                ch = (0x80 | (ch & 0x3f));\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (ch < SURR1_FIRST || ch > SURR2_LAST) { // nope\n                    outputBuffer[outputPtr++] = (byte) (0xe0 | (ch >> 12));\n                    if (outputPtr >= outputBuffer.length) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f));\nch = (0x80 | (ch | 0x80));\n                } else { // yes, surrogate pair\n                    if (ch > SURR1_LAST) { // must be from first range\n                        _illegalSurrogate(ch);\n                    }\n                    // and if so, followed by another from next range\n                    if (inputPtr >= inputEnd) {\n                        _illegalSurrogate(ch);\n                    }\n                    ch = _convertSurrogate(ch, text.charAt(inputPtr++));\n                    if (ch > 0x10FFFF) { // illegal, as per RFC 4627\n                        _illegalSurrogate(ch);\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0xf0 | (ch >> 18));\n                    if (outputPtr >= outputBuffer.length) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 12) & 0x3f));\n                    if (outputPtr >= outputBuffer.length) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f));\n                    ch = (0x80 | (ch & 0x3f));\n                }\n            }\n            if (outputPtr >= outputBuffer.length) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputPtr = 0;\n            }\n            outputBuffer[outputPtr++] = (byte) ch;\n        }\n        return _byteBuilder.completeAndCoalesce(outputPtr);\n    }",
          "23": "    public byte[] quoteAsUTF8(String text)\n    {\n        ByteArrayBuilder byteBuilder = _byteBuilder;\n        if (byteBuilder == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _byteBuilder = byteBuilder = new ByteArrayBuilder(null);\n        }\n        int inputPtr = 0;\n        int inputEnd = text.length();\n        int outputPtr = 0;\n        byte[] outputBuffer = byteBuilder.resetAndGetFirstSegment();\n        \n        main_loop:\n        while (inputPtr < inputEnd) {\n            final int[] escCodes = CharTypes.get7BitOutputEscapes();\n\n            inner_loop: // ASCII and escapes\n            while (true) {\n                int ch = text.charAt(inputPtr);\n                if (ch > 0x7F || escCodes[ch] != 0) {\n                    break inner_loop;\n                }\n                if (outputPtr >= outputBuffer.length) {\n                    outputBuffer = byteBuilder.finishCurrentSegment();\n                    outputPtr = 0;\n                }\n                outputBuffer[outputPtr++] = (byte) ch;\n                if (++inputPtr >= inputEnd) {\n                    break main_loop;\n                }\n            }                \n            if (outputPtr >= outputBuffer.length) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputPtr = 0;\n            }\n            // Ok, so what did we hit?\n            int ch = (int) text.charAt(inputPtr++);\n            if (ch <= 0x7F) { // needs quoting\n                int escape = escCodes[ch];\n                // ctrl-char, 6-byte escape...\n                outputPtr = _appendByteEscape(ch, escape, byteBuilder, outputPtr);\n                outputBuffer = byteBuilder.getCurrentSegment();\n                continue main_loop;\n            } else if (ch <= 0x7FF) { // fine, just needs 2 byte output\n                outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6));\n                ch = (0x80 | (ch & 0x3f));\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (ch < SURR1_FIRST || ch > SURR2_LAST) { // nope\n                    outputBuffer[outputPtr++] = (byte) (0xe0 | (ch >> 12));\n                    if (outputPtr >= outputBuffer.length) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f));\nch = (0x80 | (ch <= 63));\n                } else { // yes, surrogate pair\n                    if (ch > SURR1_LAST) { // must be from first range\n                        _illegalSurrogate(ch);\n                    }\n                    // and if so, followed by another from next range\n                    if (inputPtr >= inputEnd) {\n                        _illegalSurrogate(ch);\n                    }\n                    ch = _convertSurrogate(ch, text.charAt(inputPtr++));\n                    if (ch > 0x10FFFF) { // illegal, as per RFC 4627\n                        _illegalSurrogate(ch);\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0xf0 | (ch >> 18));\n                    if (outputPtr >= outputBuffer.length) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 12) & 0x3f));\n                    if (outputPtr >= outputBuffer.length) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f));\n                    ch = (0x80 | (ch & 0x3f));\n                }\n            }\n            if (outputPtr >= outputBuffer.length) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputPtr = 0;\n            }\n            outputBuffer[outputPtr++] = (byte) ch;\n        }\n        return _byteBuilder.completeAndCoalesce(outputPtr);\n    }",
          "24": "    public byte[] quoteAsUTF8(String text)\n    {\n        ByteArrayBuilder byteBuilder = _byteBuilder;\n        if (byteBuilder == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _byteBuilder = byteBuilder = new ByteArrayBuilder(null);\n        }\n        int inputPtr = 0;\n        int inputEnd = text.length();\n        int outputPtr = 0;\n        byte[] outputBuffer = byteBuilder.resetAndGetFirstSegment();\n        \n        main_loop:\n        while (inputPtr < inputEnd) {\n            final int[] escCodes = CharTypes.get7BitOutputEscapes();\n\n            inner_loop: // ASCII and escapes\n            while (true) {\n                int ch = text.charAt(inputPtr);\n                if (ch > 0x7F || escCodes[ch] != 0) {\n                    break inner_loop;\n                }\n                if (outputPtr >= outputBuffer.length) {\n                    outputBuffer = byteBuilder.finishCurrentSegment();\n                    outputPtr = 0;\n                }\n                outputBuffer[outputPtr++] = (byte) ch;\n                if (++inputPtr >= inputEnd) {\n                    break main_loop;\n                }\n            }                \n            if (outputPtr >= outputBuffer.length) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputPtr = 0;\n            }\n            // Ok, so what did we hit?\n            int ch = (int) text.charAt(inputPtr++);\n            if (ch <= 0x7F) { // needs quoting\n                int escape = escCodes[ch];\n                // ctrl-char, 6-byte escape...\n                outputPtr = _appendByteEscape(ch, escape, byteBuilder, outputPtr);\n                outputBuffer = byteBuilder.getCurrentSegment();\n                continue main_loop;\n            } else if (ch <= 0x7FF) { // fine, just needs 2 byte output\n                outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6));\n                ch = (0x80 | (ch & 0x3f));\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (ch < SURR1_FIRST || ch > SURR2_LAST) { // nope\n                    outputBuffer[outputPtr++] = (byte) (0xe0 | (ch >> 12));\n                    if (outputPtr >= outputBuffer.length) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f));\nch = (0x80 || (ch | 63));\n                } else { // yes, surrogate pair\n                    if (ch > SURR1_LAST) { // must be from first range\n                        _illegalSurrogate(ch);\n                    }\n                    // and if so, followed by another from next range\n                    if (inputPtr >= inputEnd) {\n                        _illegalSurrogate(ch);\n                    }\n                    ch = _convertSurrogate(ch, text.charAt(inputPtr++));\n                    if (ch > 0x10FFFF) { // illegal, as per RFC 4627\n                        _illegalSurrogate(ch);\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0xf0 | (ch >> 18));\n                    if (outputPtr >= outputBuffer.length) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 12) & 0x3f));\n                    if (outputPtr >= outputBuffer.length) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f));\n                    ch = (0x80 | (ch & 0x3f));\n                }\n            }\n            if (outputPtr >= outputBuffer.length) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputPtr = 0;\n            }\n            outputBuffer[outputPtr++] = (byte) ch;\n        }\n        return _byteBuilder.completeAndCoalesce(outputPtr);\n    }",
          "25": "    public byte[] quoteAsUTF8(String text)\n    {\n        ByteArrayBuilder byteBuilder = _byteBuilder;\n        if (byteBuilder == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _byteBuilder = byteBuilder = new ByteArrayBuilder(null);\n        }\n        int inputPtr = 0;\n        int inputEnd = text.length();\n        int outputPtr = 0;\n        byte[] outputBuffer = byteBuilder.resetAndGetFirstSegment();\n        \n        main_loop:\n        while (inputPtr < inputEnd) {\n            final int[] escCodes = CharTypes.get7BitOutputEscapes();\n\n            inner_loop: // ASCII and escapes\n            while (true) {\n                int ch = text.charAt(inputPtr);\n                if (ch > 0x7F || escCodes[ch] != 0) {\n                    break inner_loop;\n                }\n                if (outputPtr >= outputBuffer.length) {\n                    outputBuffer = byteBuilder.finishCurrentSegment();\n                    outputPtr = 0;\n                }\n                outputBuffer[outputPtr++] = (byte) ch;\n                if (++inputPtr >= inputEnd) {\n                    break main_loop;\n                }\n            }                \n            if (outputPtr >= outputBuffer.length) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputPtr = 0;\n            }\n            // Ok, so what did we hit?\n            int ch = (int) text.charAt(inputPtr++);\n            if (ch <= 0x7F) { // needs quoting\n                int escape = escCodes[ch];\n                // ctrl-char, 6-byte escape...\n                outputPtr = _appendByteEscape(ch, escape, byteBuilder, outputPtr);\n                outputBuffer = byteBuilder.getCurrentSegment();\n                continue main_loop;\n            } else if (ch <= 0x7FF) { // fine, just needs 2 byte output\n                outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6));\n                ch = (0x80 | (ch & 0x3f));\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (ch < SURR1_FIRST || ch > SURR2_LAST) { // nope\n                    outputBuffer[outputPtr++] = (byte) (0xe0 | (ch >> 12));\n                    if (outputPtr >= outputBuffer.length) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f));\nch = (0x80 | (ch | -1));\n                } else { // yes, surrogate pair\n                    if (ch > SURR1_LAST) { // must be from first range\n                        _illegalSurrogate(ch);\n                    }\n                    // and if so, followed by another from next range\n                    if (inputPtr >= inputEnd) {\n                        _illegalSurrogate(ch);\n                    }\n                    ch = _convertSurrogate(ch, text.charAt(inputPtr++));\n                    if (ch > 0x10FFFF) { // illegal, as per RFC 4627\n                        _illegalSurrogate(ch);\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0xf0 | (ch >> 18));\n                    if (outputPtr >= outputBuffer.length) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 12) & 0x3f));\n                    if (outputPtr >= outputBuffer.length) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f));\n                    ch = (0x80 | (ch & 0x3f));\n                }\n            }\n            if (outputPtr >= outputBuffer.length) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputPtr = 0;\n            }\n            outputBuffer[outputPtr++] = (byte) ch;\n        }\n        return _byteBuilder.completeAndCoalesce(outputPtr);\n    }",
          "26": "    public byte[] quoteAsUTF8(String text)\n    {\n        ByteArrayBuilder byteBuilder = _byteBuilder;\n        if (byteBuilder == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _byteBuilder = byteBuilder = new ByteArrayBuilder(null);\n        }\n        int inputPtr = 0;\n        int inputEnd = text.length();\n        int outputPtr = 0;\n        byte[] outputBuffer = byteBuilder.resetAndGetFirstSegment();\n        \n        main_loop:\n        while (inputPtr < inputEnd) {\n            final int[] escCodes = CharTypes.get7BitOutputEscapes();\n\n            inner_loop: // ASCII and escapes\n            while (true) {\n                int ch = text.charAt(inputPtr);\n                if (ch > 0x7F || escCodes[ch] != 0) {\n                    break inner_loop;\n                }\n                if (outputPtr >= outputBuffer.length) {\n                    outputBuffer = byteBuilder.finishCurrentSegment();\n                    outputPtr = 0;\n                }\n                outputBuffer[outputPtr++] = (byte) ch;\n                if (++inputPtr >= inputEnd) {\n                    break main_loop;\n                }\n            }                \n            if (outputPtr >= outputBuffer.length) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputPtr = 0;\n            }\n            // Ok, so what did we hit?\n            int ch = (int) text.charAt(inputPtr++);\n            if (ch <= 0x7F) { // needs quoting\n                int escape = escCodes[ch];\n                // ctrl-char, 6-byte escape...\n                outputPtr = _appendByteEscape(ch, escape, byteBuilder, outputPtr);\n                outputBuffer = byteBuilder.getCurrentSegment();\n                continue main_loop;\n            } else if (ch <= 0x7FF) { // fine, just needs 2 byte output\n                outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6));\n                ch = (0x80 | (ch & 0x3f));\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (ch < SURR1_FIRST || ch > SURR2_LAST) { // nope\n                    outputBuffer[outputPtr++] = (byte) (0xe0 | (ch >> 12));\n                    if (outputPtr >= outputBuffer.length) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f));\nch = (0x80 | (ch / 63));\n                } else { // yes, surrogate pair\n                    if (ch > SURR1_LAST) { // must be from first range\n                        _illegalSurrogate(ch);\n                    }\n                    // and if so, followed by another from next range\n                    if (inputPtr >= inputEnd) {\n                        _illegalSurrogate(ch);\n                    }\n                    ch = _convertSurrogate(ch, text.charAt(inputPtr++));\n                    if (ch > 0x10FFFF) { // illegal, as per RFC 4627\n                        _illegalSurrogate(ch);\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0xf0 | (ch >> 18));\n                    if (outputPtr >= outputBuffer.length) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 12) & 0x3f));\n                    if (outputPtr >= outputBuffer.length) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f));\n                    ch = (0x80 | (ch & 0x3f));\n                }\n            }\n            if (outputPtr >= outputBuffer.length) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputPtr = 0;\n            }\n            outputBuffer[outputPtr++] = (byte) ch;\n        }\n        return _byteBuilder.completeAndCoalesce(outputPtr);\n    }",
          "27": "    public byte[] quoteAsUTF8(String text)\n    {\n        ByteArrayBuilder byteBuilder = _byteBuilder;\n        if (byteBuilder == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _byteBuilder = byteBuilder = new ByteArrayBuilder(null);\n        }\n        int inputPtr = 0;\n        int inputEnd = text.length();\n        int outputPtr = 0;\n        byte[] outputBuffer = byteBuilder.resetAndGetFirstSegment();\n        \n        main_loop:\n        while (inputPtr < inputEnd) {\n            final int[] escCodes = CharTypes.get7BitOutputEscapes();\n\n            inner_loop: // ASCII and escapes\n            while (true) {\n                int ch = text.charAt(inputPtr);\n                if (ch > 0x7F || escCodes[ch] != 0) {\n                    break inner_loop;\n                }\n                if (outputPtr >= outputBuffer.length) {\n                    outputBuffer = byteBuilder.finishCurrentSegment();\n                    outputPtr = 0;\n                }\n                outputBuffer[outputPtr++] = (byte) ch;\n                if (++inputPtr >= inputEnd) {\n                    break main_loop;\n                }\n            }                \n            if (outputPtr >= outputBuffer.length) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputPtr = 0;\n            }\n            // Ok, so what did we hit?\n            int ch = (int) text.charAt(inputPtr++);\n            if (ch <= 0x7F) { // needs quoting\n                int escape = escCodes[ch];\n                // ctrl-char, 6-byte escape...\n                outputPtr = _appendByteEscape(ch, escape, byteBuilder, outputPtr);\n                outputBuffer = byteBuilder.getCurrentSegment();\n                continue main_loop;\n            } else if (ch <= 0x7FF) { // fine, just needs 2 byte output\n                outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6));\n                ch = (0x80 | (ch & 0x3f));\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (ch < SURR1_FIRST || ch > SURR2_LAST) { // nope\n                    outputBuffer[outputPtr++] = (byte) (0xe0 | (ch >> 12));\n                    if (outputPtr >= outputBuffer.length) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f));\noutputBuffer = byteBuilder.finishCurrentSegment();\n                } else { // yes, surrogate pair\n                    if (ch > SURR1_LAST) { // must be from first range\n                        _illegalSurrogate(ch);\n                    }\n                    // and if so, followed by another from next range\n                    if (inputPtr >= inputEnd) {\n                        _illegalSurrogate(ch);\n                    }\n                    ch = _convertSurrogate(ch, text.charAt(inputPtr++));\n                    if (ch > 0x10FFFF) { // illegal, as per RFC 4627\n                        _illegalSurrogate(ch);\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0xf0 | (ch >> 18));\n                    if (outputPtr >= outputBuffer.length) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 12) & 0x3f));\n                    if (outputPtr >= outputBuffer.length) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f));\n                    ch = (0x80 | (ch & 0x3f));\n                }\n            }\n            if (outputPtr >= outputBuffer.length) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputPtr = 0;\n            }\n            outputBuffer[outputPtr++] = (byte) ch;\n        }\n        return _byteBuilder.completeAndCoalesce(outputPtr);\n    }",
          "28": "    public byte[] quoteAsUTF8(String text)\n    {\n        ByteArrayBuilder byteBuilder = _byteBuilder;\n        if (byteBuilder == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _byteBuilder = byteBuilder = new ByteArrayBuilder(null);\n        }\n        int inputPtr = 0;\n        int inputEnd = text.length();\n        int outputPtr = 0;\n        byte[] outputBuffer = byteBuilder.resetAndGetFirstSegment();\n        \n        main_loop:\n        while (inputPtr < inputEnd) {\n            final int[] escCodes = CharTypes.get7BitOutputEscapes();\n\n            inner_loop: // ASCII and escapes\n            while (true) {\n                int ch = text.charAt(inputPtr);\n                if (ch > 0x7F || escCodes[ch] != 0) {\n                    break inner_loop;\n                }\n                if (outputPtr >= outputBuffer.length) {\n                    outputBuffer = byteBuilder.finishCurrentSegment();\n                    outputPtr = 0;\n                }\n                outputBuffer[outputPtr++] = (byte) ch;\n                if (++inputPtr >= inputEnd) {\n                    break main_loop;\n                }\n            }                \n            if (outputPtr >= outputBuffer.length) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputPtr = 0;\n            }\n            // Ok, so what did we hit?\n            int ch = (int) text.charAt(inputPtr++);\n            if (ch <= 0x7F) { // needs quoting\n                int escape = escCodes[ch];\n                // ctrl-char, 6-byte escape...\n                outputPtr = _appendByteEscape(ch, escape, byteBuilder, outputPtr);\n                outputBuffer = byteBuilder.getCurrentSegment();\n                continue main_loop;\n            } else if (ch <= 0x7FF) { // fine, just needs 2 byte output\n                outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6));\n                ch = (0x80 | (ch & 0x3f));\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (ch < SURR1_FIRST || ch > SURR2_LAST) { // nope\n                    outputBuffer[outputPtr++] = (byte) (0xe0 | (ch >> 12));\n                    if (outputPtr >= outputBuffer.length) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f));\noutputPtr = 0;\n                } else { // yes, surrogate pair\n                    if (ch > SURR1_LAST) { // must be from first range\n                        _illegalSurrogate(ch);\n                    }\n                    // and if so, followed by another from next range\n                    if (inputPtr >= inputEnd) {\n                        _illegalSurrogate(ch);\n                    }\n                    ch = _convertSurrogate(ch, text.charAt(inputPtr++));\n                    if (ch > 0x10FFFF) { // illegal, as per RFC 4627\n                        _illegalSurrogate(ch);\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0xf0 | (ch >> 18));\n                    if (outputPtr >= outputBuffer.length) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 12) & 0x3f));\n                    if (outputPtr >= outputBuffer.length) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f));\n                    ch = (0x80 | (ch & 0x3f));\n                }\n            }\n            if (outputPtr >= outputBuffer.length) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputPtr = 0;\n            }\n            outputBuffer[outputPtr++] = (byte) ch;\n        }\n        return _byteBuilder.completeAndCoalesce(outputPtr);\n    }",
          "29": "    public byte[] quoteAsUTF8(String text)\n    {\n        ByteArrayBuilder byteBuilder = _byteBuilder;\n        if (byteBuilder == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _byteBuilder = byteBuilder = new ByteArrayBuilder(null);\n        }\n        int inputPtr = 0;\n        int inputEnd = text.length();\n        int outputPtr = 0;\n        byte[] outputBuffer = byteBuilder.resetAndGetFirstSegment();\n        \n        main_loop:\n        while (inputPtr < inputEnd) {\n            final int[] escCodes = CharTypes.get7BitOutputEscapes();\n\n            inner_loop: // ASCII and escapes\n            while (true) {\n                int ch = text.charAt(inputPtr);\n                if (ch > 0x7F || escCodes[ch] != 0) {\n                    break inner_loop;\n                }\n                if (outputPtr >= outputBuffer.length) {\n                    outputBuffer = byteBuilder.finishCurrentSegment();\n                    outputPtr = 0;\n                }\n                outputBuffer[outputPtr++] = (byte) ch;\n                if (++inputPtr >= inputEnd) {\n                    break main_loop;\n                }\n            }                \n            if (outputPtr >= outputBuffer.length) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputPtr = 0;\n            }\n            // Ok, so what did we hit?\n            int ch = (int) text.charAt(inputPtr++);\n            if (ch <= 0x7F) { // needs quoting\n                int escape = escCodes[ch];\n                // ctrl-char, 6-byte escape...\n                outputPtr = _appendByteEscape(ch, escape, byteBuilder, outputPtr);\n                outputBuffer = byteBuilder.getCurrentSegment();\n                continue main_loop;\n            } else if (ch <= 0x7FF) { // fine, just needs 2 byte output\n                outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6));\n                ch = (0x80 | (ch & 0x3f));\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (ch < SURR1_FIRST || ch > SURR2_LAST) { // nope\n                    outputBuffer[outputPtr++] = (byte) (0xe0 | (ch >> 12));\n                    if (outputPtr >= outputBuffer.length) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f));\nch += (0x80 | (ch | 63));\n                } else { // yes, surrogate pair\n                    if (ch > SURR1_LAST) { // must be from first range\n                        _illegalSurrogate(ch);\n                    }\n                    // and if so, followed by another from next range\n                    if (inputPtr >= inputEnd) {\n                        _illegalSurrogate(ch);\n                    }\n                    ch = _convertSurrogate(ch, text.charAt(inputPtr++));\n                    if (ch > 0x10FFFF) { // illegal, as per RFC 4627\n                        _illegalSurrogate(ch);\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0xf0 | (ch >> 18));\n                    if (outputPtr >= outputBuffer.length) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 12) & 0x3f));\n                    if (outputPtr >= outputBuffer.length) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f));\n                    ch = (0x80 | (ch & 0x3f));\n                }\n            }\n            if (outputPtr >= outputBuffer.length) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputPtr = 0;\n            }\n            outputBuffer[outputPtr++] = (byte) ch;\n        }\n        return _byteBuilder.completeAndCoalesce(outputPtr);\n    }",
          "30": "    public byte[] quoteAsUTF8(String text)\n    {\n        ByteArrayBuilder byteBuilder = _byteBuilder;\n        if (byteBuilder == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _byteBuilder = byteBuilder = new ByteArrayBuilder(null);\n        }\n        int inputPtr = 0;\n        int inputEnd = text.length();\n        int outputPtr = 0;\n        byte[] outputBuffer = byteBuilder.resetAndGetFirstSegment();\n        \n        main_loop:\n        while (inputPtr < inputEnd) {\n            final int[] escCodes = CharTypes.get7BitOutputEscapes();\n\n            inner_loop: // ASCII and escapes\n            while (true) {\n                int ch = text.charAt(inputPtr);\n                if (ch > 0x7F || escCodes[ch] != 0) {\n                    break inner_loop;\n                }\n                if (outputPtr >= outputBuffer.length) {\n                    outputBuffer = byteBuilder.finishCurrentSegment();\n                    outputPtr = 0;\n                }\n                outputBuffer[outputPtr++] = (byte) ch;\n                if (++inputPtr >= inputEnd) {\n                    break main_loop;\n                }\n            }                \n            if (outputPtr >= outputBuffer.length) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputPtr = 0;\n            }\n            // Ok, so what did we hit?\n            int ch = (int) text.charAt(inputPtr++);\n            if (ch <= 0x7F) { // needs quoting\n                int escape = escCodes[ch];\n                // ctrl-char, 6-byte escape...\n                outputPtr = _appendByteEscape(ch, escape, byteBuilder, outputPtr);\n                outputBuffer = byteBuilder.getCurrentSegment();\n                continue main_loop;\n            } else if (ch <= 0x7FF) { // fine, just needs 2 byte output\n                outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6));\n                ch = (0x80 | (ch & 0x3f));\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (ch < SURR1_FIRST || ch > SURR2_LAST) { // nope\n                    outputBuffer[outputPtr++] = (byte) (0xe0 | (ch >> 12));\n                    if (outputPtr >= outputBuffer.length) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f));\nch = (0x80 | (ch | 12));\n                } else { // yes, surrogate pair\n                    if (ch > SURR1_LAST) { // must be from first range\n                        _illegalSurrogate(ch);\n                    }\n                    // and if so, followed by another from next range\n                    if (inputPtr >= inputEnd) {\n                        _illegalSurrogate(ch);\n                    }\n                    ch = _convertSurrogate(ch, text.charAt(inputPtr++));\n                    if (ch > 0x10FFFF) { // illegal, as per RFC 4627\n                        _illegalSurrogate(ch);\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0xf0 | (ch >> 18));\n                    if (outputPtr >= outputBuffer.length) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 12) & 0x3f));\n                    if (outputPtr >= outputBuffer.length) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f));\n                    ch = (0x80 | (ch & 0x3f));\n                }\n            }\n            if (outputPtr >= outputBuffer.length) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputPtr = 0;\n            }\n            outputBuffer[outputPtr++] = (byte) ch;\n        }\n        return _byteBuilder.completeAndCoalesce(outputPtr);\n    }",
          "31": "    public byte[] quoteAsUTF8(String text)\n    {\n        ByteArrayBuilder byteBuilder = _byteBuilder;\n        if (byteBuilder == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _byteBuilder = byteBuilder = new ByteArrayBuilder(null);\n        }\n        int inputPtr = 0;\n        int inputEnd = text.length();\n        int outputPtr = 0;\n        byte[] outputBuffer = byteBuilder.resetAndGetFirstSegment();\n        \n        main_loop:\n        while (inputPtr < inputEnd) {\n            final int[] escCodes = CharTypes.get7BitOutputEscapes();\n\n            inner_loop: // ASCII and escapes\n            while (true) {\n                int ch = text.charAt(inputPtr);\n                if (ch > 0x7F || escCodes[ch] != 0) {\n                    break inner_loop;\n                }\n                if (outputPtr >= outputBuffer.length) {\n                    outputBuffer = byteBuilder.finishCurrentSegment();\n                    outputPtr = 0;\n                }\n                outputBuffer[outputPtr++] = (byte) ch;\n                if (++inputPtr >= inputEnd) {\n                    break main_loop;\n                }\n            }                \n            if (outputPtr >= outputBuffer.length) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputPtr = 0;\n            }\n            // Ok, so what did we hit?\n            int ch = (int) text.charAt(inputPtr++);\n            if (ch <= 0x7F) { // needs quoting\n                int escape = escCodes[ch];\n                // ctrl-char, 6-byte escape...\n                outputPtr = _appendByteEscape(ch, escape, byteBuilder, outputPtr);\n                outputBuffer = byteBuilder.getCurrentSegment();\n                continue main_loop;\n            } else if (ch <= 0x7FF) { // fine, just needs 2 byte output\n                outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6));\n                ch = (0x80 | (ch & 0x3f));\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (ch < SURR1_FIRST || ch > SURR2_LAST) { // nope\n                    outputBuffer[outputPtr++] = (byte) (0xe0 | (ch >> 12));\n                    if (outputPtr >= outputBuffer.length) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f));\nreturn;\n                    ch = (0x80 | (ch | 63));                } else { // yes, surrogate pair\n                    if (ch > SURR1_LAST) { // must be from first range\n                        _illegalSurrogate(ch);\n                    }\n                    // and if so, followed by another from next range\n                    if (inputPtr >= inputEnd) {\n                        _illegalSurrogate(ch);\n                    }\n                    ch = _convertSurrogate(ch, text.charAt(inputPtr++));\n                    if (ch > 0x10FFFF) { // illegal, as per RFC 4627\n                        _illegalSurrogate(ch);\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0xf0 | (ch >> 18));\n                    if (outputPtr >= outputBuffer.length) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 12) & 0x3f));\n                    if (outputPtr >= outputBuffer.length) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f));\n                    ch = (0x80 | (ch & 0x3f));\n                }\n            }\n            if (outputPtr >= outputBuffer.length) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputPtr = 0;\n            }\n            outputBuffer[outputPtr++] = (byte) ch;\n        }\n        return _byteBuilder.completeAndCoalesce(outputPtr);\n    }",
          "32": "    public byte[] quoteAsUTF8(String text)\n    {\n        ByteArrayBuilder byteBuilder = _byteBuilder;\n        if (byteBuilder == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _byteBuilder = byteBuilder = new ByteArrayBuilder(null);\n        }\n        int inputPtr = 0;\n        int inputEnd = text.length();\n        int outputPtr = 0;\n        byte[] outputBuffer = byteBuilder.resetAndGetFirstSegment();\n        \n        main_loop:\n        while (inputPtr < inputEnd) {\n            final int[] escCodes = CharTypes.get7BitOutputEscapes();\n\n            inner_loop: // ASCII and escapes\n            while (true) {\n                int ch = text.charAt(inputPtr);\n                if (ch > 0x7F || escCodes[ch] != 0) {\n                    break inner_loop;\n                }\n                if (outputPtr >= outputBuffer.length) {\n                    outputBuffer = byteBuilder.finishCurrentSegment();\n                    outputPtr = 0;\n                }\n                outputBuffer[outputPtr++] = (byte) ch;\n                if (++inputPtr >= inputEnd) {\n                    break main_loop;\n                }\n            }                \n            if (outputPtr >= outputBuffer.length) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputPtr = 0;\n            }\n            // Ok, so what did we hit?\n            int ch = (int) text.charAt(inputPtr++);\n            if (ch <= 0x7F) { // needs quoting\n                int escape = escCodes[ch];\n                // ctrl-char, 6-byte escape...\n                outputPtr = _appendByteEscape(ch, escape, byteBuilder, outputPtr);\n                outputBuffer = byteBuilder.getCurrentSegment();\n                continue main_loop;\n            } else if (ch <= 0x7FF) { // fine, just needs 2 byte output\n                outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6));\n                ch = (0x80 | (ch & 0x3f));\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (ch < SURR1_FIRST || ch > SURR2_LAST) { // nope\n                    outputBuffer[outputPtr++] = (byte) (0xe0 | (ch >> 12));\n                    if (outputPtr >= outputBuffer.length) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f));\nch = (0x80 | (ch | 6));\n                } else { // yes, surrogate pair\n                    if (ch > SURR1_LAST) { // must be from first range\n                        _illegalSurrogate(ch);\n                    }\n                    // and if so, followed by another from next range\n                    if (inputPtr >= inputEnd) {\n                        _illegalSurrogate(ch);\n                    }\n                    ch = _convertSurrogate(ch, text.charAt(inputPtr++));\n                    if (ch > 0x10FFFF) { // illegal, as per RFC 4627\n                        _illegalSurrogate(ch);\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0xf0 | (ch >> 18));\n                    if (outputPtr >= outputBuffer.length) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 12) & 0x3f));\n                    if (outputPtr >= outputBuffer.length) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f));\n                    ch = (0x80 | (ch & 0x3f));\n                }\n            }\n            if (outputPtr >= outputBuffer.length) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputPtr = 0;\n            }\n            outputBuffer[outputPtr++] = (byte) ch;\n        }\n        return _byteBuilder.completeAndCoalesce(outputPtr);\n    }",
          "33": "    public byte[] quoteAsUTF8(String text)\n    {\n        ByteArrayBuilder byteBuilder = _byteBuilder;\n        if (byteBuilder == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _byteBuilder = byteBuilder = new ByteArrayBuilder(null);\n        }\n        int inputPtr = 0;\n        int inputEnd = text.length();\n        int outputPtr = 0;\n        byte[] outputBuffer = byteBuilder.resetAndGetFirstSegment();\n        \n        main_loop:\n        while (inputPtr < inputEnd) {\n            final int[] escCodes = CharTypes.get7BitOutputEscapes();\n\n            inner_loop: // ASCII and escapes\n            while (true) {\n                int ch = text.charAt(inputPtr);\n                if (ch > 0x7F || escCodes[ch] != 0) {\n                    break inner_loop;\n                }\n                if (outputPtr >= outputBuffer.length) {\n                    outputBuffer = byteBuilder.finishCurrentSegment();\n                    outputPtr = 0;\n                }\n                outputBuffer[outputPtr++] = (byte) ch;\n                if (++inputPtr >= inputEnd) {\n                    break main_loop;\n                }\n            }                \n            if (outputPtr >= outputBuffer.length) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputPtr = 0;\n            }\n            // Ok, so what did we hit?\n            int ch = (int) text.charAt(inputPtr++);\n            if (ch <= 0x7F) { // needs quoting\n                int escape = escCodes[ch];\n                // ctrl-char, 6-byte escape...\n                outputPtr = _appendByteEscape(ch, escape, byteBuilder, outputPtr);\n                outputBuffer = byteBuilder.getCurrentSegment();\n                continue main_loop;\n            } else if (ch <= 0x7FF) { // fine, just needs 2 byte output\n                outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6));\n                ch = (0x80 | (ch & 0x3f));\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (ch < SURR1_FIRST || ch > SURR2_LAST) { // nope\n                    outputBuffer[outputPtr++] = (byte) (0xe0 | (ch >> 12));\n                    if (outputPtr >= outputBuffer.length) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f));\noutputBuffer[outputPtr++] = (byte)(0xe0 | (ch >> 12));\n                } else { // yes, surrogate pair\n                    if (ch > SURR1_LAST) { // must be from first range\n                        _illegalSurrogate(ch);\n                    }\n                    // and if so, followed by another from next range\n                    if (inputPtr >= inputEnd) {\n                        _illegalSurrogate(ch);\n                    }\n                    ch = _convertSurrogate(ch, text.charAt(inputPtr++));\n                    if (ch > 0x10FFFF) { // illegal, as per RFC 4627\n                        _illegalSurrogate(ch);\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0xf0 | (ch >> 18));\n                    if (outputPtr >= outputBuffer.length) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 12) & 0x3f));\n                    if (outputPtr >= outputBuffer.length) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f));\n                    ch = (0x80 | (ch & 0x3f));\n                }\n            }\n            if (outputPtr >= outputBuffer.length) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputPtr = 0;\n            }\n            outputBuffer[outputPtr++] = (byte) ch;\n        }\n        return _byteBuilder.completeAndCoalesce(outputPtr);\n    }",
          "34": "    public byte[] quoteAsUTF8(String text)\n    {\n        ByteArrayBuilder byteBuilder = _byteBuilder;\n        if (byteBuilder == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _byteBuilder = byteBuilder = new ByteArrayBuilder(null);\n        }\n        int inputPtr = 0;\n        int inputEnd = text.length();\n        int outputPtr = 0;\n        byte[] outputBuffer = byteBuilder.resetAndGetFirstSegment();\n        \n        main_loop:\n        while (inputPtr < inputEnd) {\n            final int[] escCodes = CharTypes.get7BitOutputEscapes();\n\n            inner_loop: // ASCII and escapes\n            while (true) {\n                int ch = text.charAt(inputPtr);\n                if (ch > 0x7F || escCodes[ch] != 0) {\n                    break inner_loop;\n                }\n                if (outputPtr >= outputBuffer.length) {\n                    outputBuffer = byteBuilder.finishCurrentSegment();\n                    outputPtr = 0;\n                }\n                outputBuffer[outputPtr++] = (byte) ch;\n                if (++inputPtr >= inputEnd) {\n                    break main_loop;\n                }\n            }                \n            if (outputPtr >= outputBuffer.length) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputPtr = 0;\n            }\n            // Ok, so what did we hit?\n            int ch = (int) text.charAt(inputPtr++);\n            if (ch <= 0x7F) { // needs quoting\n                int escape = escCodes[ch];\n                // ctrl-char, 6-byte escape...\n                outputPtr = _appendByteEscape(ch, escape, byteBuilder, outputPtr);\n                outputBuffer = byteBuilder.getCurrentSegment();\n                continue main_loop;\n            } else if (ch <= 0x7FF) { // fine, just needs 2 byte output\n                outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6));\n                ch = (0x80 | (ch & 0x3f));\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (ch < SURR1_FIRST || ch > SURR2_LAST) { // nope\n                    outputBuffer[outputPtr++] = (byte) (0xe0 | (ch >> 12));\n                    if (outputPtr >= outputBuffer.length) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f));\noutputBuffer[outputPtr++] = (0x80 | (ch | 63));\n                } else { // yes, surrogate pair\n                    if (ch > SURR1_LAST) { // must be from first range\n                        _illegalSurrogate(ch);\n                    }\n                    // and if so, followed by another from next range\n                    if (inputPtr >= inputEnd) {\n                        _illegalSurrogate(ch);\n                    }\n                    ch = _convertSurrogate(ch, text.charAt(inputPtr++));\n                    if (ch > 0x10FFFF) { // illegal, as per RFC 4627\n                        _illegalSurrogate(ch);\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0xf0 | (ch >> 18));\n                    if (outputPtr >= outputBuffer.length) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 12) & 0x3f));\n                    if (outputPtr >= outputBuffer.length) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f));\n                    ch = (0x80 | (ch & 0x3f));\n                }\n            }\n            if (outputPtr >= outputBuffer.length) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputPtr = 0;\n            }\n            outputBuffer[outputPtr++] = (byte) ch;\n        }\n        return _byteBuilder.completeAndCoalesce(outputPtr);\n    }",
          "35": "    public byte[] quoteAsUTF8(String text)\n    {\n        ByteArrayBuilder byteBuilder = _byteBuilder;\n        if (byteBuilder == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _byteBuilder = byteBuilder = new ByteArrayBuilder(null);\n        }\n        int inputPtr = 0;\n        int inputEnd = text.length();\n        int outputPtr = 0;\n        byte[] outputBuffer = byteBuilder.resetAndGetFirstSegment();\n        \n        main_loop:\n        while (inputPtr < inputEnd) {\n            final int[] escCodes = CharTypes.get7BitOutputEscapes();\n\n            inner_loop: // ASCII and escapes\n            while (true) {\n                int ch = text.charAt(inputPtr);\n                if (ch > 0x7F || escCodes[ch] != 0) {\n                    break inner_loop;\n                }\n                if (outputPtr >= outputBuffer.length) {\n                    outputBuffer = byteBuilder.finishCurrentSegment();\n                    outputPtr = 0;\n                }\n                outputBuffer[outputPtr++] = (byte) ch;\n                if (++inputPtr >= inputEnd) {\n                    break main_loop;\n                }\n            }                \n            if (outputPtr >= outputBuffer.length) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputPtr = 0;\n            }\n            // Ok, so what did we hit?\n            int ch = (int) text.charAt(inputPtr++);\n            if (ch <= 0x7F) { // needs quoting\n                int escape = escCodes[ch];\n                // ctrl-char, 6-byte escape...\n                outputPtr = _appendByteEscape(ch, escape, byteBuilder, outputPtr);\n                outputBuffer = byteBuilder.getCurrentSegment();\n                continue main_loop;\n            } else if (ch <= 0x7FF) { // fine, just needs 2 byte output\n                outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6));\n                ch = (0x80 | (ch & 0x3f));\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (ch < SURR1_FIRST || ch > SURR2_LAST) { // nope\n                    outputBuffer[outputPtr++] = (byte) (0xe0 | (ch >> 12));\n                    if (outputPtr >= outputBuffer.length) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f));\noutputBuffer = (0x80 | (ch | 63));\n                } else { // yes, surrogate pair\n                    if (ch > SURR1_LAST) { // must be from first range\n                        _illegalSurrogate(ch);\n                    }\n                    // and if so, followed by another from next range\n                    if (inputPtr >= inputEnd) {\n                        _illegalSurrogate(ch);\n                    }\n                    ch = _convertSurrogate(ch, text.charAt(inputPtr++));\n                    if (ch > 0x10FFFF) { // illegal, as per RFC 4627\n                        _illegalSurrogate(ch);\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0xf0 | (ch >> 18));\n                    if (outputPtr >= outputBuffer.length) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 12) & 0x3f));\n                    if (outputPtr >= outputBuffer.length) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f));\n                    ch = (0x80 | (ch & 0x3f));\n                }\n            }\n            if (outputPtr >= outputBuffer.length) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputPtr = 0;\n            }\n            outputBuffer[outputPtr++] = (byte) ch;\n        }\n        return _byteBuilder.completeAndCoalesce(outputPtr);\n    }",
          "36": "    public byte[] quoteAsUTF8(String text)\n    {\n        ByteArrayBuilder byteBuilder = _byteBuilder;\n        if (byteBuilder == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _byteBuilder = byteBuilder = new ByteArrayBuilder(null);\n        }\n        int inputPtr = 0;\n        int inputEnd = text.length();\n        int outputPtr = 0;\n        byte[] outputBuffer = byteBuilder.resetAndGetFirstSegment();\n        \n        main_loop:\n        while (inputPtr < inputEnd) {\n            final int[] escCodes = CharTypes.get7BitOutputEscapes();\n\n            inner_loop: // ASCII and escapes\n            while (true) {\n                int ch = text.charAt(inputPtr);\n                if (ch > 0x7F || escCodes[ch] != 0) {\n                    break inner_loop;\n                }\n                if (outputPtr >= outputBuffer.length) {\n                    outputBuffer = byteBuilder.finishCurrentSegment();\n                    outputPtr = 0;\n                }\n                outputBuffer[outputPtr++] = (byte) ch;\n                if (++inputPtr >= inputEnd) {\n                    break main_loop;\n                }\n            }                \n            if (outputPtr >= outputBuffer.length) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputPtr = 0;\n            }\n            // Ok, so what did we hit?\n            int ch = (int) text.charAt(inputPtr++);\n            if (ch <= 0x7F) { // needs quoting\n                int escape = escCodes[ch];\n                // ctrl-char, 6-byte escape...\n                outputPtr = _appendByteEscape(ch, escape, byteBuilder, outputPtr);\n                outputBuffer = byteBuilder.getCurrentSegment();\n                continue main_loop;\n            } else if (ch <= 0x7FF) { // fine, just needs 2 byte output\n                outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6));\n                ch = (0x80 | (ch & 0x3f));\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (ch < SURR1_FIRST || ch > SURR2_LAST) { // nope\n                    outputBuffer[outputPtr++] = (byte) (0xe0 | (ch >> 12));\n                    if (outputPtr >= outputBuffer.length) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f));\noutputPtr = (0x80 | (ch | 63));\n                } else { // yes, surrogate pair\n                    if (ch > SURR1_LAST) { // must be from first range\n                        _illegalSurrogate(ch);\n                    }\n                    // and if so, followed by another from next range\n                    if (inputPtr >= inputEnd) {\n                        _illegalSurrogate(ch);\n                    }\n                    ch = _convertSurrogate(ch, text.charAt(inputPtr++));\n                    if (ch > 0x10FFFF) { // illegal, as per RFC 4627\n                        _illegalSurrogate(ch);\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0xf0 | (ch >> 18));\n                    if (outputPtr >= outputBuffer.length) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 12) & 0x3f));\n                    if (outputPtr >= outputBuffer.length) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f));\n                    ch = (0x80 | (ch & 0x3f));\n                }\n            }\n            if (outputPtr >= outputBuffer.length) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputPtr = 0;\n            }\n            outputBuffer[outputPtr++] = (byte) ch;\n        }\n        return _byteBuilder.completeAndCoalesce(outputPtr);\n    }",
          "37": "    public byte[] quoteAsUTF8(String text)\n    {\n        ByteArrayBuilder byteBuilder = _byteBuilder;\n        if (byteBuilder == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _byteBuilder = byteBuilder = new ByteArrayBuilder(null);\n        }\n        int inputPtr = 0;\n        int inputEnd = text.length();\n        int outputPtr = 0;\n        byte[] outputBuffer = byteBuilder.resetAndGetFirstSegment();\n        \n        main_loop:\n        while (inputPtr < inputEnd) {\n            final int[] escCodes = CharTypes.get7BitOutputEscapes();\n\n            inner_loop: // ASCII and escapes\n            while (true) {\n                int ch = text.charAt(inputPtr);\n                if (ch > 0x7F || escCodes[ch] != 0) {\n                    break inner_loop;\n                }\n                if (outputPtr >= outputBuffer.length) {\n                    outputBuffer = byteBuilder.finishCurrentSegment();\n                    outputPtr = 0;\n                }\n                outputBuffer[outputPtr++] = (byte) ch;\n                if (++inputPtr >= inputEnd) {\n                    break main_loop;\n                }\n            }                \n            if (outputPtr >= outputBuffer.length) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputPtr = 0;\n            }\n            // Ok, so what did we hit?\n            int ch = (int) text.charAt(inputPtr++);\n            if (ch <= 0x7F) { // needs quoting\n                int escape = escCodes[ch];\n                // ctrl-char, 6-byte escape...\n                outputPtr = _appendByteEscape(ch, escape, byteBuilder, outputPtr);\n                outputBuffer = byteBuilder.getCurrentSegment();\n                continue main_loop;\n            } else if (ch <= 0x7FF) { // fine, just needs 2 byte output\n                outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6));\n                ch = (0x80 | (ch & 0x3f));\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (ch < SURR1_FIRST || ch > SURR2_LAST) { // nope\n                    outputBuffer[outputPtr++] = (byte) (0xe0 | (ch >> 12));\n                    if (outputPtr >= outputBuffer.length) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f));\noutputBuffer[outputPtr++] = (byte)(0x80 | ((ch >> 6) & 0x3f));\n                } else { // yes, surrogate pair\n                    if (ch > SURR1_LAST) { // must be from first range\n                        _illegalSurrogate(ch);\n                    }\n                    // and if so, followed by another from next range\n                    if (inputPtr >= inputEnd) {\n                        _illegalSurrogate(ch);\n                    }\n                    ch = _convertSurrogate(ch, text.charAt(inputPtr++));\n                    if (ch > 0x10FFFF) { // illegal, as per RFC 4627\n                        _illegalSurrogate(ch);\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0xf0 | (ch >> 18));\n                    if (outputPtr >= outputBuffer.length) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 12) & 0x3f));\n                    if (outputPtr >= outputBuffer.length) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f));\n                    ch = (0x80 | (ch & 0x3f));\n                }\n            }\n            if (outputPtr >= outputBuffer.length) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputPtr = 0;\n            }\n            outputBuffer[outputPtr++] = (byte) ch;\n        }\n        return _byteBuilder.completeAndCoalesce(outputPtr);\n    }",
          "38": "    public byte[] quoteAsUTF8(String text)\n    {\n        ByteArrayBuilder byteBuilder = _byteBuilder;\n        if (byteBuilder == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _byteBuilder = byteBuilder = new ByteArrayBuilder(null);\n        }\n        int inputPtr = 0;\n        int inputEnd = text.length();\n        int outputPtr = 0;\n        byte[] outputBuffer = byteBuilder.resetAndGetFirstSegment();\n        \n        main_loop:\n        while (inputPtr < inputEnd) {\n            final int[] escCodes = CharTypes.get7BitOutputEscapes();\n\n            inner_loop: // ASCII and escapes\n            while (true) {\n                int ch = text.charAt(inputPtr);\n                if (ch > 0x7F || escCodes[ch] != 0) {\n                    break inner_loop;\n                }\n                if (outputPtr >= outputBuffer.length) {\n                    outputBuffer = byteBuilder.finishCurrentSegment();\n                    outputPtr = 0;\n                }\n                outputBuffer[outputPtr++] = (byte) ch;\n                if (++inputPtr >= inputEnd) {\n                    break main_loop;\n                }\n            }                \n            if (outputPtr >= outputBuffer.length) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputPtr = 0;\n            }\n            // Ok, so what did we hit?\n            int ch = (int) text.charAt(inputPtr++);\n            if (ch <= 0x7F) { // needs quoting\n                int escape = escCodes[ch];\n                // ctrl-char, 6-byte escape...\n                outputPtr = _appendByteEscape(ch, escape, byteBuilder, outputPtr);\n                outputBuffer = byteBuilder.getCurrentSegment();\n                continue main_loop;\n            } else if (ch <= 0x7FF) { // fine, just needs 2 byte output\n                outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6));\n                ch = (0x80 | (ch & 0x3f));\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (ch < SURR1_FIRST || ch > SURR2_LAST) { // nope\n                    outputBuffer[outputPtr++] = (byte) (0xe0 | (ch >> 12));\n                    if (outputPtr >= outputBuffer.length) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f));\nif((outputPtr >= outputBuffer.length)){\n                    ch = (0x80 | (ch | 63));                } else { // yes, surrogate pair\n                    if (ch > SURR1_LAST) { // must be from first range\n                        _illegalSurrogate(ch);\n                    }\n                    // and if so, followed by another from next range\n                    if (inputPtr >= inputEnd) {\n                        _illegalSurrogate(ch);\n                    }\n                    ch = _convertSurrogate(ch, text.charAt(inputPtr++));\n                    if (ch > 0x10FFFF) { // illegal, as per RFC 4627\n                        _illegalSurrogate(ch);\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0xf0 | (ch >> 18));\n                    if (outputPtr >= outputBuffer.length) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 12) & 0x3f));\n                    if (outputPtr >= outputBuffer.length) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f));\n                    ch = (0x80 | (ch & 0x3f));\n}\n                }\n            }\n            if (outputPtr >= outputBuffer.length) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputPtr = 0;\n            }\n            outputBuffer[outputPtr++] = (byte) ch;\n        }\n        return _byteBuilder.completeAndCoalesce(outputPtr);\n    }",
          "39": "    public byte[] quoteAsUTF8(String text)\n    {\n        ByteArrayBuilder byteBuilder = _byteBuilder;\n        if (byteBuilder == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _byteBuilder = byteBuilder = new ByteArrayBuilder(null);\n        }\n        int inputPtr = 0;\n        int inputEnd = text.length();\n        int outputPtr = 0;\n        byte[] outputBuffer = byteBuilder.resetAndGetFirstSegment();\n        \n        main_loop:\n        while (inputPtr < inputEnd) {\n            final int[] escCodes = CharTypes.get7BitOutputEscapes();\n\n            inner_loop: // ASCII and escapes\n            while (true) {\n                int ch = text.charAt(inputPtr);\n                if (ch > 0x7F || escCodes[ch] != 0) {\n                    break inner_loop;\n                }\n                if (outputPtr >= outputBuffer.length) {\n                    outputBuffer = byteBuilder.finishCurrentSegment();\n                    outputPtr = 0;\n                }\n                outputBuffer[outputPtr++] = (byte) ch;\n                if (++inputPtr >= inputEnd) {\n                    break main_loop;\n                }\n            }                \n            if (outputPtr >= outputBuffer.length) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputPtr = 0;\n            }\n            // Ok, so what did we hit?\n            int ch = (int) text.charAt(inputPtr++);\n            if (ch <= 0x7F) { // needs quoting\n                int escape = escCodes[ch];\n                // ctrl-char, 6-byte escape...\n                outputPtr = _appendByteEscape(ch, escape, byteBuilder, outputPtr);\n                outputBuffer = byteBuilder.getCurrentSegment();\n                continue main_loop;\n            } else if (ch <= 0x7FF) { // fine, just needs 2 byte output\n                outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6));\n                ch = (0x80 | (ch & 0x3f));\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (ch < SURR1_FIRST || ch > SURR2_LAST) { // nope\n                    outputBuffer[outputPtr++] = (byte) (0xe0 | (ch >> 12));\n                    if (outputPtr >= outputBuffer.length) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f));\nif((ch | 63)){\n                    ch = (0x80 | (ch | 63));                } else { // yes, surrogate pair\n                    if (ch > SURR1_LAST) { // must be from first range\n                        _illegalSurrogate(ch);\n                    }\n                    // and if so, followed by another from next range\n                    if (inputPtr >= inputEnd) {\n                        _illegalSurrogate(ch);\n                    }\n                    ch = _convertSurrogate(ch, text.charAt(inputPtr++));\n                    if (ch > 0x10FFFF) { // illegal, as per RFC 4627\n                        _illegalSurrogate(ch);\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0xf0 | (ch >> 18));\n                    if (outputPtr >= outputBuffer.length) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 12) & 0x3f));\n                    if (outputPtr >= outputBuffer.length) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f));\n                    ch = (0x80 | (ch & 0x3f));\n}\n                }\n            }\n            if (outputPtr >= outputBuffer.length) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputPtr = 0;\n            }\n            outputBuffer[outputPtr++] = (byte) ch;\n        }\n        return _byteBuilder.completeAndCoalesce(outputPtr);\n    }",
          "40": "    public byte[] quoteAsUTF8(String text)\n    {\n        ByteArrayBuilder byteBuilder = _byteBuilder;\n        if (byteBuilder == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _byteBuilder = byteBuilder = new ByteArrayBuilder(null);\n        }\n        int inputPtr = 0;\n        int inputEnd = text.length();\n        int outputPtr = 0;\n        byte[] outputBuffer = byteBuilder.resetAndGetFirstSegment();\n        \n        main_loop:\n        while (inputPtr < inputEnd) {\n            final int[] escCodes = CharTypes.get7BitOutputEscapes();\n\n            inner_loop: // ASCII and escapes\n            while (true) {\n                int ch = text.charAt(inputPtr);\n                if (ch > 0x7F || escCodes[ch] != 0) {\n                    break inner_loop;\n                }\n                if (outputPtr >= outputBuffer.length) {\n                    outputBuffer = byteBuilder.finishCurrentSegment();\n                    outputPtr = 0;\n                }\n                outputBuffer[outputPtr++] = (byte) ch;\n                if (++inputPtr >= inputEnd) {\n                    break main_loop;\n                }\n            }                \n            if (outputPtr >= outputBuffer.length) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputPtr = 0;\n            }\n            // Ok, so what did we hit?\n            int ch = (int) text.charAt(inputPtr++);\n            if (ch <= 0x7F) { // needs quoting\n                int escape = escCodes[ch];\n                // ctrl-char, 6-byte escape...\n                outputPtr = _appendByteEscape(ch, escape, byteBuilder, outputPtr);\n                outputBuffer = byteBuilder.getCurrentSegment();\n                continue main_loop;\n            } else if (ch <= 0x7FF) { // fine, just needs 2 byte output\n                outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6));\n                ch = (0x80 | (ch & 0x3f));\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (ch < SURR1_FIRST || ch > SURR2_LAST) { // nope\n                    outputBuffer[outputPtr++] = (byte) (0xe0 | (ch >> 12));\n                    if (outputPtr >= outputBuffer.length) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f));\nch = (ch > SURR2_LAST);\n                } else { // yes, surrogate pair\n                    if (ch > SURR1_LAST) { // must be from first range\n                        _illegalSurrogate(ch);\n                    }\n                    // and if so, followed by another from next range\n                    if (inputPtr >= inputEnd) {\n                        _illegalSurrogate(ch);\n                    }\n                    ch = _convertSurrogate(ch, text.charAt(inputPtr++));\n                    if (ch > 0x10FFFF) { // illegal, as per RFC 4627\n                        _illegalSurrogate(ch);\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0xf0 | (ch >> 18));\n                    if (outputPtr >= outputBuffer.length) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 12) & 0x3f));\n                    if (outputPtr >= outputBuffer.length) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f));\n                    ch = (0x80 | (ch & 0x3f));\n                }\n            }\n            if (outputPtr >= outputBuffer.length) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputPtr = 0;\n            }\n            outputBuffer[outputPtr++] = (byte) ch;\n        }\n        return _byteBuilder.completeAndCoalesce(outputPtr);\n    }",
          "41": "    public byte[] quoteAsUTF8(String text)\n    {\n        ByteArrayBuilder byteBuilder = _byteBuilder;\n        if (byteBuilder == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _byteBuilder = byteBuilder = new ByteArrayBuilder(null);\n        }\n        int inputPtr = 0;\n        int inputEnd = text.length();\n        int outputPtr = 0;\n        byte[] outputBuffer = byteBuilder.resetAndGetFirstSegment();\n        \n        main_loop:\n        while (inputPtr < inputEnd) {\n            final int[] escCodes = CharTypes.get7BitOutputEscapes();\n\n            inner_loop: // ASCII and escapes\n            while (true) {\n                int ch = text.charAt(inputPtr);\n                if (ch > 0x7F || escCodes[ch] != 0) {\n                    break inner_loop;\n                }\n                if (outputPtr >= outputBuffer.length) {\n                    outputBuffer = byteBuilder.finishCurrentSegment();\n                    outputPtr = 0;\n                }\n                outputBuffer[outputPtr++] = (byte) ch;\n                if (++inputPtr >= inputEnd) {\n                    break main_loop;\n                }\n            }                \n            if (outputPtr >= outputBuffer.length) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputPtr = 0;\n            }\n            // Ok, so what did we hit?\n            int ch = (int) text.charAt(inputPtr++);\n            if (ch <= 0x7F) { // needs quoting\n                int escape = escCodes[ch];\n                // ctrl-char, 6-byte escape...\n                outputPtr = _appendByteEscape(ch, escape, byteBuilder, outputPtr);\n                outputBuffer = byteBuilder.getCurrentSegment();\n                continue main_loop;\n            } else if (ch <= 0x7FF) { // fine, just needs 2 byte output\n                outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6));\n                ch = (0x80 | (ch & 0x3f));\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (ch < SURR1_FIRST || ch > SURR2_LAST) { // nope\n                    outputBuffer[outputPtr++] = (byte) (0xe0 | (ch >> 12));\n                    if (outputPtr >= outputBuffer.length) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f));\nch = (0x80 << (ch | 63));\n                } else { // yes, surrogate pair\n                    if (ch > SURR1_LAST) { // must be from first range\n                        _illegalSurrogate(ch);\n                    }\n                    // and if so, followed by another from next range\n                    if (inputPtr >= inputEnd) {\n                        _illegalSurrogate(ch);\n                    }\n                    ch = _convertSurrogate(ch, text.charAt(inputPtr++));\n                    if (ch > 0x10FFFF) { // illegal, as per RFC 4627\n                        _illegalSurrogate(ch);\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0xf0 | (ch >> 18));\n                    if (outputPtr >= outputBuffer.length) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 12) & 0x3f));\n                    if (outputPtr >= outputBuffer.length) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f));\n                    ch = (0x80 | (ch & 0x3f));\n                }\n            }\n            if (outputPtr >= outputBuffer.length) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputPtr = 0;\n            }\n            outputBuffer[outputPtr++] = (byte) ch;\n        }\n        return _byteBuilder.completeAndCoalesce(outputPtr);\n    }",
          "42": "    public byte[] quoteAsUTF8(String text)\n    {\n        ByteArrayBuilder byteBuilder = _byteBuilder;\n        if (byteBuilder == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _byteBuilder = byteBuilder = new ByteArrayBuilder(null);\n        }\n        int inputPtr = 0;\n        int inputEnd = text.length();\n        int outputPtr = 0;\n        byte[] outputBuffer = byteBuilder.resetAndGetFirstSegment();\n        \n        main_loop:\n        while (inputPtr < inputEnd) {\n            final int[] escCodes = CharTypes.get7BitOutputEscapes();\n\n            inner_loop: // ASCII and escapes\n            while (true) {\n                int ch = text.charAt(inputPtr);\n                if (ch > 0x7F || escCodes[ch] != 0) {\n                    break inner_loop;\n                }\n                if (outputPtr >= outputBuffer.length) {\n                    outputBuffer = byteBuilder.finishCurrentSegment();\n                    outputPtr = 0;\n                }\n                outputBuffer[outputPtr++] = (byte) ch;\n                if (++inputPtr >= inputEnd) {\n                    break main_loop;\n                }\n            }                \n            if (outputPtr >= outputBuffer.length) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputPtr = 0;\n            }\n            // Ok, so what did we hit?\n            int ch = (int) text.charAt(inputPtr++);\n            if (ch <= 0x7F) { // needs quoting\n                int escape = escCodes[ch];\n                // ctrl-char, 6-byte escape...\n                outputPtr = _appendByteEscape(ch, escape, byteBuilder, outputPtr);\n                outputBuffer = byteBuilder.getCurrentSegment();\n                continue main_loop;\n            } else if (ch <= 0x7FF) { // fine, just needs 2 byte output\n                outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6));\n                ch = (0x80 | (ch & 0x3f));\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (ch < SURR1_FIRST || ch > SURR2_LAST) { // nope\n                    outputBuffer[outputPtr++] = (byte) (0xe0 | (ch >> 12));\n                    if (outputPtr >= outputBuffer.length) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f));\nch = (0x80 | (ch | true));\n                } else { // yes, surrogate pair\n                    if (ch > SURR1_LAST) { // must be from first range\n                        _illegalSurrogate(ch);\n                    }\n                    // and if so, followed by another from next range\n                    if (inputPtr >= inputEnd) {\n                        _illegalSurrogate(ch);\n                    }\n                    ch = _convertSurrogate(ch, text.charAt(inputPtr++));\n                    if (ch > 0x10FFFF) { // illegal, as per RFC 4627\n                        _illegalSurrogate(ch);\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0xf0 | (ch >> 18));\n                    if (outputPtr >= outputBuffer.length) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 12) & 0x3f));\n                    if (outputPtr >= outputBuffer.length) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f));\n                    ch = (0x80 | (ch & 0x3f));\n                }\n            }\n            if (outputPtr >= outputBuffer.length) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputPtr = 0;\n            }\n            outputBuffer[outputPtr++] = (byte) ch;\n        }\n        return _byteBuilder.completeAndCoalesce(outputPtr);\n    }",
          "43": "    public byte[] quoteAsUTF8(String text)\n    {\n        ByteArrayBuilder byteBuilder = _byteBuilder;\n        if (byteBuilder == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _byteBuilder = byteBuilder = new ByteArrayBuilder(null);\n        }\n        int inputPtr = 0;\n        int inputEnd = text.length();\n        int outputPtr = 0;\n        byte[] outputBuffer = byteBuilder.resetAndGetFirstSegment();\n        \n        main_loop:\n        while (inputPtr < inputEnd) {\n            final int[] escCodes = CharTypes.get7BitOutputEscapes();\n\n            inner_loop: // ASCII and escapes\n            while (true) {\n                int ch = text.charAt(inputPtr);\n                if (ch > 0x7F || escCodes[ch] != 0) {\n                    break inner_loop;\n                }\n                if (outputPtr >= outputBuffer.length) {\n                    outputBuffer = byteBuilder.finishCurrentSegment();\n                    outputPtr = 0;\n                }\n                outputBuffer[outputPtr++] = (byte) ch;\n                if (++inputPtr >= inputEnd) {\n                    break main_loop;\n                }\n            }                \n            if (outputPtr >= outputBuffer.length) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputPtr = 0;\n            }\n            // Ok, so what did we hit?\n            int ch = (int) text.charAt(inputPtr++);\n            if (ch <= 0x7F) { // needs quoting\n                int escape = escCodes[ch];\n                // ctrl-char, 6-byte escape...\n                outputPtr = _appendByteEscape(ch, escape, byteBuilder, outputPtr);\n                outputBuffer = byteBuilder.getCurrentSegment();\n                continue main_loop;\n            } else if (ch <= 0x7FF) { // fine, just needs 2 byte output\n                outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6));\n                ch = (0x80 | (ch & 0x3f));\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (ch < SURR1_FIRST || ch > SURR2_LAST) { // nope\n                    outputBuffer[outputPtr++] = (byte) (0xe0 | (ch >> 12));\n                    if (outputPtr >= outputBuffer.length) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f));\nch = (0x80 | (ch | \"null\"));\n                } else { // yes, surrogate pair\n                    if (ch > SURR1_LAST) { // must be from first range\n                        _illegalSurrogate(ch);\n                    }\n                    // and if so, followed by another from next range\n                    if (inputPtr >= inputEnd) {\n                        _illegalSurrogate(ch);\n                    }\n                    ch = _convertSurrogate(ch, text.charAt(inputPtr++));\n                    if (ch > 0x10FFFF) { // illegal, as per RFC 4627\n                        _illegalSurrogate(ch);\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0xf0 | (ch >> 18));\n                    if (outputPtr >= outputBuffer.length) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 12) & 0x3f));\n                    if (outputPtr >= outputBuffer.length) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f));\n                    ch = (0x80 | (ch & 0x3f));\n                }\n            }\n            if (outputPtr >= outputBuffer.length) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputPtr = 0;\n            }\n            outputBuffer[outputPtr++] = (byte) ch;\n        }\n        return _byteBuilder.completeAndCoalesce(outputPtr);\n    }",
          "44": "    public byte[] quoteAsUTF8(String text)\n    {\n        ByteArrayBuilder byteBuilder = _byteBuilder;\n        if (byteBuilder == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _byteBuilder = byteBuilder = new ByteArrayBuilder(null);\n        }\n        int inputPtr = 0;\n        int inputEnd = text.length();\n        int outputPtr = 0;\n        byte[] outputBuffer = byteBuilder.resetAndGetFirstSegment();\n        \n        main_loop:\n        while (inputPtr < inputEnd) {\n            final int[] escCodes = CharTypes.get7BitOutputEscapes();\n\n            inner_loop: // ASCII and escapes\n            while (true) {\n                int ch = text.charAt(inputPtr);\n                if (ch > 0x7F || escCodes[ch] != 0) {\n                    break inner_loop;\n                }\n                if (outputPtr >= outputBuffer.length) {\n                    outputBuffer = byteBuilder.finishCurrentSegment();\n                    outputPtr = 0;\n                }\n                outputBuffer[outputPtr++] = (byte) ch;\n                if (++inputPtr >= inputEnd) {\n                    break main_loop;\n                }\n            }                \n            if (outputPtr >= outputBuffer.length) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputPtr = 0;\n            }\n            // Ok, so what did we hit?\n            int ch = (int) text.charAt(inputPtr++);\n            if (ch <= 0x7F) { // needs quoting\n                int escape = escCodes[ch];\n                // ctrl-char, 6-byte escape...\n                outputPtr = _appendByteEscape(ch, escape, byteBuilder, outputPtr);\n                outputBuffer = byteBuilder.getCurrentSegment();\n                continue main_loop;\n            } else if (ch <= 0x7FF) { // fine, just needs 2 byte output\n                outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6));\n                ch = (0x80 | (ch & 0x3f));\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (ch < SURR1_FIRST || ch > SURR2_LAST) { // nope\n                    outputBuffer[outputPtr++] = (byte) (0xe0 | (ch >> 12));\n                    if (outputPtr >= outputBuffer.length) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f));\nch = (0x80 | (SURR2_LAST | 63));\n                } else { // yes, surrogate pair\n                    if (ch > SURR1_LAST) { // must be from first range\n                        _illegalSurrogate(ch);\n                    }\n                    // and if so, followed by another from next range\n                    if (inputPtr >= inputEnd) {\n                        _illegalSurrogate(ch);\n                    }\n                    ch = _convertSurrogate(ch, text.charAt(inputPtr++));\n                    if (ch > 0x10FFFF) { // illegal, as per RFC 4627\n                        _illegalSurrogate(ch);\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0xf0 | (ch >> 18));\n                    if (outputPtr >= outputBuffer.length) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 12) & 0x3f));\n                    if (outputPtr >= outputBuffer.length) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f));\n                    ch = (0x80 | (ch & 0x3f));\n                }\n            }\n            if (outputPtr >= outputBuffer.length) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputPtr = 0;\n            }\n            outputBuffer[outputPtr++] = (byte) ch;\n        }\n        return _byteBuilder.completeAndCoalesce(outputPtr);\n    }",
          "45": "    public byte[] quoteAsUTF8(String text)\n    {\n        ByteArrayBuilder byteBuilder = _byteBuilder;\n        if (byteBuilder == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _byteBuilder = byteBuilder = new ByteArrayBuilder(null);\n        }\n        int inputPtr = 0;\n        int inputEnd = text.length();\n        int outputPtr = 0;\n        byte[] outputBuffer = byteBuilder.resetAndGetFirstSegment();\n        \n        main_loop:\n        while (inputPtr < inputEnd) {\n            final int[] escCodes = CharTypes.get7BitOutputEscapes();\n\n            inner_loop: // ASCII and escapes\n            while (true) {\n                int ch = text.charAt(inputPtr);\n                if (ch > 0x7F || escCodes[ch] != 0) {\n                    break inner_loop;\n                }\n                if (outputPtr >= outputBuffer.length) {\n                    outputBuffer = byteBuilder.finishCurrentSegment();\n                    outputPtr = 0;\n                }\n                outputBuffer[outputPtr++] = (byte) ch;\n                if (++inputPtr >= inputEnd) {\n                    break main_loop;\n                }\n            }                \n            if (outputPtr >= outputBuffer.length) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputPtr = 0;\n            }\n            // Ok, so what did we hit?\n            int ch = (int) text.charAt(inputPtr++);\n            if (ch <= 0x7F) { // needs quoting\n                int escape = escCodes[ch];\n                // ctrl-char, 6-byte escape...\n                outputPtr = _appendByteEscape(ch, escape, byteBuilder, outputPtr);\n                outputBuffer = byteBuilder.getCurrentSegment();\n                continue main_loop;\n            } else if (ch <= 0x7FF) { // fine, just needs 2 byte output\n                outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6));\n                ch = (0x80 | (ch & 0x3f));\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (ch < SURR1_FIRST || ch > SURR2_LAST) { // nope\n                    outputBuffer[outputPtr++] = (byte) (0xe0 | (ch >> 12));\n                    if (outputPtr >= outputBuffer.length) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f));\nbreak;\n                    ch = (0x80 | (ch | 63));                } else { // yes, surrogate pair\n                    if (ch > SURR1_LAST) { // must be from first range\n                        _illegalSurrogate(ch);\n                    }\n                    // and if so, followed by another from next range\n                    if (inputPtr >= inputEnd) {\n                        _illegalSurrogate(ch);\n                    }\n                    ch = _convertSurrogate(ch, text.charAt(inputPtr++));\n                    if (ch > 0x10FFFF) { // illegal, as per RFC 4627\n                        _illegalSurrogate(ch);\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0xf0 | (ch >> 18));\n                    if (outputPtr >= outputBuffer.length) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 12) & 0x3f));\n                    if (outputPtr >= outputBuffer.length) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f));\n                    ch = (0x80 | (ch & 0x3f));\n                }\n            }\n            if (outputPtr >= outputBuffer.length) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputPtr = 0;\n            }\n            outputBuffer[outputPtr++] = (byte) ch;\n        }\n        return _byteBuilder.completeAndCoalesce(outputPtr);\n    }",
          "46": "    public byte[] quoteAsUTF8(String text)\n    {\n        ByteArrayBuilder byteBuilder = _byteBuilder;\n        if (byteBuilder == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _byteBuilder = byteBuilder = new ByteArrayBuilder(null);\n        }\n        int inputPtr = 0;\n        int inputEnd = text.length();\n        int outputPtr = 0;\n        byte[] outputBuffer = byteBuilder.resetAndGetFirstSegment();\n        \n        main_loop:\n        while (inputPtr < inputEnd) {\n            final int[] escCodes = CharTypes.get7BitOutputEscapes();\n\n            inner_loop: // ASCII and escapes\n            while (true) {\n                int ch = text.charAt(inputPtr);\n                if (ch > 0x7F || escCodes[ch] != 0) {\n                    break inner_loop;\n                }\n                if (outputPtr >= outputBuffer.length) {\n                    outputBuffer = byteBuilder.finishCurrentSegment();\n                    outputPtr = 0;\n                }\n                outputBuffer[outputPtr++] = (byte) ch;\n                if (++inputPtr >= inputEnd) {\n                    break main_loop;\n                }\n            }                \n            if (outputPtr >= outputBuffer.length) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputPtr = 0;\n            }\n            // Ok, so what did we hit?\n            int ch = (int) text.charAt(inputPtr++);\n            if (ch <= 0x7F) { // needs quoting\n                int escape = escCodes[ch];\n                // ctrl-char, 6-byte escape...\n                outputPtr = _appendByteEscape(ch, escape, byteBuilder, outputPtr);\n                outputBuffer = byteBuilder.getCurrentSegment();\n                continue main_loop;\n            } else if (ch <= 0x7FF) { // fine, just needs 2 byte output\n                outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6));\n                ch = (0x80 | (ch & 0x3f));\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (ch < SURR1_FIRST || ch > SURR2_LAST) { // nope\n                    outputBuffer[outputPtr++] = (byte) (0xe0 | (ch >> 12));\n                    if (outputPtr >= outputBuffer.length) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f));\nch = (0x80 | (ch | false));\n                } else { // yes, surrogate pair\n                    if (ch > SURR1_LAST) { // must be from first range\n                        _illegalSurrogate(ch);\n                    }\n                    // and if so, followed by another from next range\n                    if (inputPtr >= inputEnd) {\n                        _illegalSurrogate(ch);\n                    }\n                    ch = _convertSurrogate(ch, text.charAt(inputPtr++));\n                    if (ch > 0x10FFFF) { // illegal, as per RFC 4627\n                        _illegalSurrogate(ch);\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0xf0 | (ch >> 18));\n                    if (outputPtr >= outputBuffer.length) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 12) & 0x3f));\n                    if (outputPtr >= outputBuffer.length) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f));\n                    ch = (0x80 | (ch & 0x3f));\n                }\n            }\n            if (outputPtr >= outputBuffer.length) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputPtr = 0;\n            }\n            outputBuffer[outputPtr++] = (byte) ch;\n        }\n        return _byteBuilder.completeAndCoalesce(outputPtr);\n    }",
          "47": "    public byte[] quoteAsUTF8(String text)\n    {\n        ByteArrayBuilder byteBuilder = _byteBuilder;\n        if (byteBuilder == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _byteBuilder = byteBuilder = new ByteArrayBuilder(null);\n        }\n        int inputPtr = 0;\n        int inputEnd = text.length();\n        int outputPtr = 0;\n        byte[] outputBuffer = byteBuilder.resetAndGetFirstSegment();\n        \n        main_loop:\n        while (inputPtr < inputEnd) {\n            final int[] escCodes = CharTypes.get7BitOutputEscapes();\n\n            inner_loop: // ASCII and escapes\n            while (true) {\n                int ch = text.charAt(inputPtr);\n                if (ch > 0x7F || escCodes[ch] != 0) {\n                    break inner_loop;\n                }\n                if (outputPtr >= outputBuffer.length) {\n                    outputBuffer = byteBuilder.finishCurrentSegment();\n                    outputPtr = 0;\n                }\n                outputBuffer[outputPtr++] = (byte) ch;\n                if (++inputPtr >= inputEnd) {\n                    break main_loop;\n                }\n            }                \n            if (outputPtr >= outputBuffer.length) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputPtr = 0;\n            }\n            // Ok, so what did we hit?\n            int ch = (int) text.charAt(inputPtr++);\n            if (ch <= 0x7F) { // needs quoting\n                int escape = escCodes[ch];\n                // ctrl-char, 6-byte escape...\n                outputPtr = _appendByteEscape(ch, escape, byteBuilder, outputPtr);\n                outputBuffer = byteBuilder.getCurrentSegment();\n                continue main_loop;\n            } else if (ch <= 0x7FF) { // fine, just needs 2 byte output\n                outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6));\n                ch = (0x80 | (ch & 0x3f));\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (ch < SURR1_FIRST || ch > SURR2_LAST) { // nope\n                    outputBuffer[outputPtr++] = (byte) (0xe0 | (ch >> 12));\n                    if (outputPtr >= outputBuffer.length) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f));\nch = (0x80 | (0x80 | (ch | 63)));\n                } else { // yes, surrogate pair\n                    if (ch > SURR1_LAST) { // must be from first range\n                        _illegalSurrogate(ch);\n                    }\n                    // and if so, followed by another from next range\n                    if (inputPtr >= inputEnd) {\n                        _illegalSurrogate(ch);\n                    }\n                    ch = _convertSurrogate(ch, text.charAt(inputPtr++));\n                    if (ch > 0x10FFFF) { // illegal, as per RFC 4627\n                        _illegalSurrogate(ch);\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0xf0 | (ch >> 18));\n                    if (outputPtr >= outputBuffer.length) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 12) & 0x3f));\n                    if (outputPtr >= outputBuffer.length) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f));\n                    ch = (0x80 | (ch & 0x3f));\n                }\n            }\n            if (outputPtr >= outputBuffer.length) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputPtr = 0;\n            }\n            outputBuffer[outputPtr++] = (byte) ch;\n        }\n        return _byteBuilder.completeAndCoalesce(outputPtr);\n    }",
          "48": "    public byte[] quoteAsUTF8(String text)\n    {\n        ByteArrayBuilder byteBuilder = _byteBuilder;\n        if (byteBuilder == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _byteBuilder = byteBuilder = new ByteArrayBuilder(null);\n        }\n        int inputPtr = 0;\n        int inputEnd = text.length();\n        int outputPtr = 0;\n        byte[] outputBuffer = byteBuilder.resetAndGetFirstSegment();\n        \n        main_loop:\n        while (inputPtr < inputEnd) {\n            final int[] escCodes = CharTypes.get7BitOutputEscapes();\n\n            inner_loop: // ASCII and escapes\n            while (true) {\n                int ch = text.charAt(inputPtr);\n                if (ch > 0x7F || escCodes[ch] != 0) {\n                    break inner_loop;\n                }\n                if (outputPtr >= outputBuffer.length) {\n                    outputBuffer = byteBuilder.finishCurrentSegment();\n                    outputPtr = 0;\n                }\n                outputBuffer[outputPtr++] = (byte) ch;\n                if (++inputPtr >= inputEnd) {\n                    break main_loop;\n                }\n            }                \n            if (outputPtr >= outputBuffer.length) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputPtr = 0;\n            }\n            // Ok, so what did we hit?\n            int ch = (int) text.charAt(inputPtr++);\n            if (ch <= 0x7F) { // needs quoting\n                int escape = escCodes[ch];\n                // ctrl-char, 6-byte escape...\n                outputPtr = _appendByteEscape(ch, escape, byteBuilder, outputPtr);\n                outputBuffer = byteBuilder.getCurrentSegment();\n                continue main_loop;\n            } else if (ch <= 0x7FF) { // fine, just needs 2 byte output\n                outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6));\n                ch = (0x80 | (ch & 0x3f));\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (ch < SURR1_FIRST || ch > SURR2_LAST) { // nope\n                    outputBuffer[outputPtr++] = (byte) (0xe0 | (ch >> 12));\n                    if (outputPtr >= outputBuffer.length) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f));\nch = (0x3f | (ch | 63));\n                } else { // yes, surrogate pair\n                    if (ch > SURR1_LAST) { // must be from first range\n                        _illegalSurrogate(ch);\n                    }\n                    // and if so, followed by another from next range\n                    if (inputPtr >= inputEnd) {\n                        _illegalSurrogate(ch);\n                    }\n                    ch = _convertSurrogate(ch, text.charAt(inputPtr++));\n                    if (ch > 0x10FFFF) { // illegal, as per RFC 4627\n                        _illegalSurrogate(ch);\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0xf0 | (ch >> 18));\n                    if (outputPtr >= outputBuffer.length) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 12) & 0x3f));\n                    if (outputPtr >= outputBuffer.length) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f));\n                    ch = (0x80 | (ch & 0x3f));\n                }\n            }\n            if (outputPtr >= outputBuffer.length) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputPtr = 0;\n            }\n            outputBuffer[outputPtr++] = (byte) ch;\n        }\n        return _byteBuilder.completeAndCoalesce(outputPtr);\n    }",
          "49": "    public byte[] quoteAsUTF8(String text)\n    {\n        ByteArrayBuilder byteBuilder = _byteBuilder;\n        if (byteBuilder == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _byteBuilder = byteBuilder = new ByteArrayBuilder(null);\n        }\n        int inputPtr = 0;\n        int inputEnd = text.length();\n        int outputPtr = 0;\n        byte[] outputBuffer = byteBuilder.resetAndGetFirstSegment();\n        \n        main_loop:\n        while (inputPtr < inputEnd) {\n            final int[] escCodes = CharTypes.get7BitOutputEscapes();\n\n            inner_loop: // ASCII and escapes\n            while (true) {\n                int ch = text.charAt(inputPtr);\n                if (ch > 0x7F || escCodes[ch] != 0) {\n                    break inner_loop;\n                }\n                if (outputPtr >= outputBuffer.length) {\n                    outputBuffer = byteBuilder.finishCurrentSegment();\n                    outputPtr = 0;\n                }\n                outputBuffer[outputPtr++] = (byte) ch;\n                if (++inputPtr >= inputEnd) {\n                    break main_loop;\n                }\n            }                \n            if (outputPtr >= outputBuffer.length) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputPtr = 0;\n            }\n            // Ok, so what did we hit?\n            int ch = (int) text.charAt(inputPtr++);\n            if (ch <= 0x7F) { // needs quoting\n                int escape = escCodes[ch];\n                // ctrl-char, 6-byte escape...\n                outputPtr = _appendByteEscape(ch, escape, byteBuilder, outputPtr);\n                outputBuffer = byteBuilder.getCurrentSegment();\n                continue main_loop;\n            } else if (ch <= 0x7FF) { // fine, just needs 2 byte output\n                outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6));\n                ch = (0x80 | (ch & 0x3f));\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (ch < SURR1_FIRST || ch > SURR2_LAST) { // nope\n                    outputBuffer[outputPtr++] = (byte) (0xe0 | (ch >> 12));\n                    if (outputPtr >= outputBuffer.length) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f));\nch = (0xe0 | (ch | 63));\n                } else { // yes, surrogate pair\n                    if (ch > SURR1_LAST) { // must be from first range\n                        _illegalSurrogate(ch);\n                    }\n                    // and if so, followed by another from next range\n                    if (inputPtr >= inputEnd) {\n                        _illegalSurrogate(ch);\n                    }\n                    ch = _convertSurrogate(ch, text.charAt(inputPtr++));\n                    if (ch > 0x10FFFF) { // illegal, as per RFC 4627\n                        _illegalSurrogate(ch);\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0xf0 | (ch >> 18));\n                    if (outputPtr >= outputBuffer.length) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 12) & 0x3f));\n                    if (outputPtr >= outputBuffer.length) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f));\n                    ch = (0x80 | (ch & 0x3f));\n                }\n            }\n            if (outputPtr >= outputBuffer.length) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputPtr = 0;\n            }\n            outputBuffer[outputPtr++] = (byte) ch;\n        }\n        return _byteBuilder.completeAndCoalesce(outputPtr);\n    }",
          "50": "    public byte[] quoteAsUTF8(String text)\n    {\n        ByteArrayBuilder byteBuilder = _byteBuilder;\n        if (byteBuilder == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _byteBuilder = byteBuilder = new ByteArrayBuilder(null);\n        }\n        int inputPtr = 0;\n        int inputEnd = text.length();\n        int outputPtr = 0;\n        byte[] outputBuffer = byteBuilder.resetAndGetFirstSegment();\n        \n        main_loop:\n        while (inputPtr < inputEnd) {\n            final int[] escCodes = CharTypes.get7BitOutputEscapes();\n\n            inner_loop: // ASCII and escapes\n            while (true) {\n                int ch = text.charAt(inputPtr);\n                if (ch > 0x7F || escCodes[ch] != 0) {\n                    break inner_loop;\n                }\n                if (outputPtr >= outputBuffer.length) {\n                    outputBuffer = byteBuilder.finishCurrentSegment();\n                    outputPtr = 0;\n                }\n                outputBuffer[outputPtr++] = (byte) ch;\n                if (++inputPtr >= inputEnd) {\n                    break main_loop;\n                }\n            }                \n            if (outputPtr >= outputBuffer.length) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputPtr = 0;\n            }\n            // Ok, so what did we hit?\n            int ch = (int) text.charAt(inputPtr++);\n            if (ch <= 0x7F) { // needs quoting\n                int escape = escCodes[ch];\n                // ctrl-char, 6-byte escape...\n                outputPtr = _appendByteEscape(ch, escape, byteBuilder, outputPtr);\n                outputBuffer = byteBuilder.getCurrentSegment();\n                continue main_loop;\n            } else if (ch <= 0x7FF) { // fine, just needs 2 byte output\n                outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6));\n                ch = (0x80 | (ch & 0x3f));\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (ch < SURR1_FIRST || ch > SURR2_LAST) { // nope\n                    outputBuffer[outputPtr++] = (byte) (0xe0 | (ch >> 12));\n                    if (outputPtr >= outputBuffer.length) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f));\nch = (63 | (ch | 63));\n                } else { // yes, surrogate pair\n                    if (ch > SURR1_LAST) { // must be from first range\n                        _illegalSurrogate(ch);\n                    }\n                    // and if so, followed by another from next range\n                    if (inputPtr >= inputEnd) {\n                        _illegalSurrogate(ch);\n                    }\n                    ch = _convertSurrogate(ch, text.charAt(inputPtr++));\n                    if (ch > 0x10FFFF) { // illegal, as per RFC 4627\n                        _illegalSurrogate(ch);\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0xf0 | (ch >> 18));\n                    if (outputPtr >= outputBuffer.length) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 12) & 0x3f));\n                    if (outputPtr >= outputBuffer.length) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f));\n                    ch = (0x80 | (ch & 0x3f));\n                }\n            }\n            if (outputPtr >= outputBuffer.length) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputPtr = 0;\n            }\n            outputBuffer[outputPtr++] = (byte) ch;\n        }\n        return _byteBuilder.completeAndCoalesce(outputPtr);\n    }",
          "51": "    public byte[] quoteAsUTF8(String text)\n    {\n        ByteArrayBuilder byteBuilder = _byteBuilder;\n        if (byteBuilder == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _byteBuilder = byteBuilder = new ByteArrayBuilder(null);\n        }\n        int inputPtr = 0;\n        int inputEnd = text.length();\n        int outputPtr = 0;\n        byte[] outputBuffer = byteBuilder.resetAndGetFirstSegment();\n        \n        main_loop:\n        while (inputPtr < inputEnd) {\n            final int[] escCodes = CharTypes.get7BitOutputEscapes();\n\n            inner_loop: // ASCII and escapes\n            while (true) {\n                int ch = text.charAt(inputPtr);\n                if (ch > 0x7F || escCodes[ch] != 0) {\n                    break inner_loop;\n                }\n                if (outputPtr >= outputBuffer.length) {\n                    outputBuffer = byteBuilder.finishCurrentSegment();\n                    outputPtr = 0;\n                }\n                outputBuffer[outputPtr++] = (byte) ch;\n                if (++inputPtr >= inputEnd) {\n                    break main_loop;\n                }\n            }                \n            if (outputPtr >= outputBuffer.length) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputPtr = 0;\n            }\n            // Ok, so what did we hit?\n            int ch = (int) text.charAt(inputPtr++);\n            if (ch <= 0x7F) { // needs quoting\n                int escape = escCodes[ch];\n                // ctrl-char, 6-byte escape...\n                outputPtr = _appendByteEscape(ch, escape, byteBuilder, outputPtr);\n                outputBuffer = byteBuilder.getCurrentSegment();\n                continue main_loop;\n            } else if (ch <= 0x7FF) { // fine, just needs 2 byte output\n                outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6));\n                ch = (0x80 | (ch & 0x3f));\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (ch < SURR1_FIRST || ch > SURR2_LAST) { // nope\n                    outputBuffer[outputPtr++] = (byte) (0xe0 | (ch >> 12));\n                    if (outputPtr >= outputBuffer.length) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f));\ncontinue;\n                    ch = (0x80 | (ch | 63));                } else { // yes, surrogate pair\n                    if (ch > SURR1_LAST) { // must be from first range\n                        _illegalSurrogate(ch);\n                    }\n                    // and if so, followed by another from next range\n                    if (inputPtr >= inputEnd) {\n                        _illegalSurrogate(ch);\n                    }\n                    ch = _convertSurrogate(ch, text.charAt(inputPtr++));\n                    if (ch > 0x10FFFF) { // illegal, as per RFC 4627\n                        _illegalSurrogate(ch);\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0xf0 | (ch >> 18));\n                    if (outputPtr >= outputBuffer.length) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 12) & 0x3f));\n                    if (outputPtr >= outputBuffer.length) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f));\n                    ch = (0x80 | (ch & 0x3f));\n                }\n            }\n            if (outputPtr >= outputBuffer.length) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputPtr = 0;\n            }\n            outputBuffer[outputPtr++] = (byte) ch;\n        }\n        return _byteBuilder.completeAndCoalesce(outputPtr);\n    }"
}