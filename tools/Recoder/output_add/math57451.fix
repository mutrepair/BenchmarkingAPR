{
          "0": "    private void performDoubleQRStep(final int il, final int im, final int iu,\n                                     final ShiftInfo shift, final double[] hVec) {\n\n        final int n = matrixT.length;\n        double p = hVec[0];\n        double q = hVec[1];\n        double r = hVec[2];\n\n        for (int k = im; k <= iu - 1; k++) {\n            boolean notlast = k != (iu - 1);\n            if (k != im) {\n                p = matrixT[k][k - 1];\n                q = matrixT[k + 1][k - 1];\n                r = notlast ? matrixT[k + 2][k - 1] : 0.0;\n                shift.x = FastMath.abs(p) + FastMath.abs(q) + FastMath.abs(r);\n                if (!Precision.equals(shift.x, 0.0, epsilon)) {\n                    p = p / shift.x;\n                    q = q / shift.x;\n                    r = r / shift.x;\n                }\n            }\n            if (shift.x == 0.0) {\n                break;\n            }\n            double s = FastMath.sqrt(p * p + q * q + r * r);\n            if (p < 0.0) {\n                s = -s;\n            }\n            if (s != 0.0) {\n                if (k != im) {\n                    matrixT[k][k - 1] = -s * shift.x;\n                } else if (il != im) {\n                }\n                p = p + s;\n                shift.x = p / s;\n                shift.y = q / s;\n                double z = r / s;\n                q = q / p;\n                r = r / p;\n\n                // Row modification\n                for (int j = k; j < n; j++) {\n                    p = matrixT[k][j] + q * matrixT[k + 1][j];\n                    if (notlast) {\n                        p = p + r * matrixT[k + 2][j];\n                        matrixT[k + 2][j] = matrixT[k + 2][j] - p * z;\n                    }\n                    matrixT[k][j] = matrixT[k][j] - p * shift.x;\n                    matrixT[k + 1][j] = matrixT[k + 1][j] - p * shift.y;\n                }\n\n                // Column modification\n                for (int i = 0; i <= FastMath.min(iu, k + 3); i++) {\n                    p = shift.x * matrixT[i][k] + shift.y * matrixT[i][k + 1];\n                    if (notlast) {\n                        p = p + z * matrixT[i][k + 2];\n                        matrixT[i][k + 2] = matrixT[i][k + 2] - p * r;\n                    }\n                    matrixT[i][k] = matrixT[i][k] - p;\n                    matrixT[i][k + 1] = matrixT[i][k + 1] - p * q;\n                }\n\n                // Accumulate transformations\n                final int high = matrixT.length - 1;\n                for (int i = 0; i <= high; i++) {\n                    p = shift.x * matrixP[i][k] + shift.y * matrixP[i][k + 1];\n                    if (notlast) {\n                        p = p + z * matrixP[i][k + 2];\n                        matrixP[i][k + 2] = matrixP[i][k + 2] - p * r;\n                    }\n                    matrixP[i][k] = matrixP[i][k] - p;\n                    matrixP[i][k + 1] = matrixP[i][k + 1] - p * q;\n                }\n            }  // (s != 0)\n        }  // k loop\n\n        // clean up pollution due to round-off errors\n        for (int i = im + 2; i <= iu; i++) {\n            matrixT[i][i-2] = 0.0;\n            if (i > im + 2) {\n                matrixT[i][i-3] = 0.0;\n            }\n        }\n    }",
          "1": "    private void performDoubleQRStep(final int il, final int im, final int iu,\n                                     final ShiftInfo shift, final double[] hVec) {\n\n        final int n = matrixT.length;\n        double p = hVec[0];\n        double q = hVec[1];\n        double r = hVec[2];\n\n        for (int k = im; k <= iu - 1; k++) {\n            boolean notlast = k != (iu - 1);\n            if (k != im) {\n                p = matrixT[k][k - 1];\n                q = matrixT[k + 1][k - 1];\n                r = notlast ? matrixT[k + 2][k - 1] : 0.0;\n                shift.x = FastMath.abs(p) + FastMath.abs(q) + FastMath.abs(r);\n                if (!Precision.equals(shift.x, 0.0, epsilon)) {\n                    p = p / shift.x;\n                    q = q / shift.x;\n                    r = r / shift.x;\n                }\n            }\n            if (shift.x == 0.0) {\n                break;\n            }\n            double s = FastMath.sqrt(p * p + q * q + r * r);\n            if (p < 0.0) {\n                s = -s;\n            }\n            if (s != 0.0) {\n                if (k != im) {\n                    matrixT[k][k - 1] = -s * shift.x;\n                } else if (il != im) {\nmatrixT[k].[(k - 1)] = (-s * shift.x);\n                }\n                p = p + s;\n                shift.x = p / s;\n                shift.y = q / s;\n                double z = r / s;\n                q = q / p;\n                r = r / p;\n\n                // Row modification\n                for (int j = k; j < n; j++) {\n                    p = matrixT[k][j] + q * matrixT[k + 1][j];\n                    if (notlast) {\n                        p = p + r * matrixT[k + 2][j];\n                        matrixT[k + 2][j] = matrixT[k + 2][j] - p * z;\n                    }\n                    matrixT[k][j] = matrixT[k][j] - p * shift.x;\n                    matrixT[k + 1][j] = matrixT[k + 1][j] - p * shift.y;\n                }\n\n                // Column modification\n                for (int i = 0; i <= FastMath.min(iu, k + 3); i++) {\n                    p = shift.x * matrixT[i][k] + shift.y * matrixT[i][k + 1];\n                    if (notlast) {\n                        p = p + z * matrixT[i][k + 2];\n                        matrixT[i][k + 2] = matrixT[i][k + 2] - p * r;\n                    }\n                    matrixT[i][k] = matrixT[i][k] - p;\n                    matrixT[i][k + 1] = matrixT[i][k + 1] - p * q;\n                }\n\n                // Accumulate transformations\n                final int high = matrixT.length - 1;\n                for (int i = 0; i <= high; i++) {\n                    p = shift.x * matrixP[i][k] + shift.y * matrixP[i][k + 1];\n                    if (notlast) {\n                        p = p + z * matrixP[i][k + 2];\n                        matrixP[i][k + 2] = matrixP[i][k + 2] - p * r;\n                    }\n                    matrixP[i][k] = matrixP[i][k] - p;\n                    matrixP[i][k + 1] = matrixP[i][k + 1] - p * q;\n                }\n            }  // (s != 0)\n        }  // k loop\n\n        // clean up pollution due to round-off errors\n        for (int i = im + 2; i <= iu; i++) {\n            matrixT[i][i-2] = 0.0;\n            if (i > im + 2) {\n                matrixT[i][i-3] = 0.0;\n            }\n        }\n    }",
          "2": "    private void performDoubleQRStep(final int il, final int im, final int iu,\n                                     final ShiftInfo shift, final double[] hVec) {\n\n        final int n = matrixT.length;\n        double p = hVec[0];\n        double q = hVec[1];\n        double r = hVec[2];\n\n        for (int k = im; k <= iu - 1; k++) {\n            boolean notlast = k != (iu - 1);\n            if (k != im) {\n                p = matrixT[k][k - 1];\n                q = matrixT[k + 1][k - 1];\n                r = notlast ? matrixT[k + 2][k - 1] : 0.0;\n                shift.x = FastMath.abs(p) + FastMath.abs(q) + FastMath.abs(r);\n                if (!Precision.equals(shift.x, 0.0, epsilon)) {\n                    p = p / shift.x;\n                    q = q / shift.x;\n                    r = r / shift.x;\n                }\n            }\n            if (shift.x == 0.0) {\n                break;\n            }\n            double s = FastMath.sqrt(p * p + q * q + r * r);\n            if (p < 0.0) {\n                s = -s;\n            }\n            if (s != 0.0) {\n                if (k != im) {\n                    matrixT[k][k - 1] = -s * shift.x;\n                } else if (il != im) {\nshift.x = (p / s);\n}\n                    matrixT[k][k - 1] = +matrixT[k][k - 1];                }\n                p = p + s;\n                shift.x = p / s;\n                shift.y = q / s;\n                double z = r / s;\n                q = q / p;\n                r = r / p;\n\n                // Row modification\n                for (int j = k; j < n; j++) {\n                    p = matrixT[k][j] + q * matrixT[k + 1][j];\n                    if (notlast) {\n                        p = p + r * matrixT[k + 2][j];\n                        matrixT[k + 2][j] = matrixT[k + 2][j] - p * z;\n                    }\n                    matrixT[k][j] = matrixT[k][j] - p * shift.x;\n                    matrixT[k + 1][j] = matrixT[k + 1][j] - p * shift.y;\n                }\n\n                // Column modification\n                for (int i = 0; i <= FastMath.min(iu, k + 3); i++) {\n                    p = shift.x * matrixT[i][k] + shift.y * matrixT[i][k + 1];\n                    if (notlast) {\n                        p = p + z * matrixT[i][k + 2];\n                        matrixT[i][k + 2] = matrixT[i][k + 2] - p * r;\n                    }\n                    matrixT[i][k] = matrixT[i][k] - p;\n                    matrixT[i][k + 1] = matrixT[i][k + 1] - p * q;\n                }\n\n                // Accumulate transformations\n                final int high = matrixT.length - 1;\n                for (int i = 0; i <= high; i++) {\n                    p = shift.x * matrixP[i][k] + shift.y * matrixP[i][k + 1];\n                    if (notlast) {\n                        p = p + z * matrixP[i][k + 2];\n                        matrixP[i][k + 2] = matrixP[i][k + 2] - p * r;\n                    }\n                    matrixP[i][k] = matrixP[i][k] - p;\n                    matrixP[i][k + 1] = matrixP[i][k + 1] - p * q;\n                }\n            }  // (s != 0)\n        }  // k loop\n\n        // clean up pollution due to round-off errors\n        for (int i = im + 2; i <= iu; i++) {\n            matrixT[i][i-2] = 0.0;\n            if (i > im + 2) {\n                matrixT[i][i-3] = 0.0;\n            }\n        }\n    }",
          "3": "    private void performDoubleQRStep(final int il, final int im, final int iu,\n                                     final ShiftInfo shift, final double[] hVec) {\n\n        final int n = matrixT.length;\n        double p = hVec[0];\n        double q = hVec[1];\n        double r = hVec[2];\n\n        for (int k = im; k <= iu - 1; k++) {\n            boolean notlast = k != (iu - 1);\n            if (k != im) {\n                p = matrixT[k][k - 1];\n                q = matrixT[k + 1][k - 1];\n                r = notlast ? matrixT[k + 2][k - 1] : 0.0;\n                shift.x = FastMath.abs(p) + FastMath.abs(q) + FastMath.abs(r);\n                if (!Precision.equals(shift.x, 0.0, epsilon)) {\n                    p = p / shift.x;\n                    q = q / shift.x;\n                    r = r / shift.x;\n                }\n            }\n            if (shift.x == 0.0) {\n                break;\n            }\n            double s = FastMath.sqrt(p * p + q * q + r * r);\n            if (p < 0.0) {\n                s = -s;\n            }\n            if (s != 0.0) {\n                if (k != im) {\n                    matrixT[k][k - 1] = -s * shift.x;\n                } else if (il != im) {\nshift.x = (p / s);\n                }\n                p = p + s;\n                shift.x = p / s;\n                shift.y = q / s;\n                double z = r / s;\n                q = q / p;\n                r = r / p;\n\n                // Row modification\n                for (int j = k; j < n; j++) {\n                    p = matrixT[k][j] + q * matrixT[k + 1][j];\n                    if (notlast) {\n                        p = p + r * matrixT[k + 2][j];\n                        matrixT[k + 2][j] = matrixT[k + 2][j] - p * z;\n                    }\n                    matrixT[k][j] = matrixT[k][j] - p * shift.x;\n                    matrixT[k + 1][j] = matrixT[k + 1][j] - p * shift.y;\n                }\n\n                // Column modification\n                for (int i = 0; i <= FastMath.min(iu, k + 3); i++) {\n                    p = shift.x * matrixT[i][k] + shift.y * matrixT[i][k + 1];\n                    if (notlast) {\n                        p = p + z * matrixT[i][k + 2];\n                        matrixT[i][k + 2] = matrixT[i][k + 2] - p * r;\n                    }\n                    matrixT[i][k] = matrixT[i][k] - p;\n                    matrixT[i][k + 1] = matrixT[i][k + 1] - p * q;\n                }\n\n                // Accumulate transformations\n                final int high = matrixT.length - 1;\n                for (int i = 0; i <= high; i++) {\n                    p = shift.x * matrixP[i][k] + shift.y * matrixP[i][k + 1];\n                    if (notlast) {\n                        p = p + z * matrixP[i][k + 2];\n                        matrixP[i][k + 2] = matrixP[i][k + 2] - p * r;\n                    }\n                    matrixP[i][k] = matrixP[i][k] - p;\n                    matrixP[i][k + 1] = matrixP[i][k + 1] - p * q;\n                }\n            }  // (s != 0)\n        }  // k loop\n\n        // clean up pollution due to round-off errors\n        for (int i = im + 2; i <= iu; i++) {\n            matrixT[i][i-2] = 0.0;\n            if (i > im + 2) {\n                matrixT[i][i-3] = 0.0;\n            }\n        }\n    }",
          "4": "    private void performDoubleQRStep(final int il, final int im, final int iu,\n                                     final ShiftInfo shift, final double[] hVec) {\n\n        final int n = matrixT.length;\n        double p = hVec[0];\n        double q = hVec[1];\n        double r = hVec[2];\n\n        for (int k = im; k <= iu - 1; k++) {\n            boolean notlast = k != (iu - 1);\n            if (k != im) {\n                p = matrixT[k][k - 1];\n                q = matrixT[k + 1][k - 1];\n                r = notlast ? matrixT[k + 2][k - 1] : 0.0;\n                shift.x = FastMath.abs(p) + FastMath.abs(q) + FastMath.abs(r);\n                if (!Precision.equals(shift.x, 0.0, epsilon)) {\n                    p = p / shift.x;\n                    q = q / shift.x;\n                    r = r / shift.x;\n                }\n            }\n            if (shift.x == 0.0) {\n                break;\n            }\n            double s = FastMath.sqrt(p * p + q * q + r * r);\n            if (p < 0.0) {\n                s = -s;\n            }\n            if (s != 0.0) {\n                if (k != im) {\n                    matrixT[k][k - 1] = -s * shift.x;\n                } else if (il != im) {\nq = (q / p);\n                    matrixT[k][k - 1] = +matrixT[k][k - 1];                }\n                p = p + s;\n                shift.x = p / s;\n                shift.y = q / s;\n                double z = r / s;\n                q = q / p;\n                r = r / p;\n\n                // Row modification\n                for (int j = k; j < n; j++) {\n                    p = matrixT[k][j] + q * matrixT[k + 1][j];\n                    if (notlast) {\n                        p = p + r * matrixT[k + 2][j];\n                        matrixT[k + 2][j] = matrixT[k + 2][j] - p * z;\n                    }\n                    matrixT[k][j] = matrixT[k][j] - p * shift.x;\n                    matrixT[k + 1][j] = matrixT[k + 1][j] - p * shift.y;\n                }\n\n                // Column modification\n                for (int i = 0; i <= FastMath.min(iu, k + 3); i++) {\n                    p = shift.x * matrixT[i][k] + shift.y * matrixT[i][k + 1];\n                    if (notlast) {\n                        p = p + z * matrixT[i][k + 2];\n                        matrixT[i][k + 2] = matrixT[i][k + 2] - p * r;\n                    }\n                    matrixT[i][k] = matrixT[i][k] - p;\n                    matrixT[i][k + 1] = matrixT[i][k + 1] - p * q;\n                }\n\n                // Accumulate transformations\n                final int high = matrixT.length - 1;\n                for (int i = 0; i <= high; i++) {\n                    p = shift.x * matrixP[i][k] + shift.y * matrixP[i][k + 1];\n                    if (notlast) {\n                        p = p + z * matrixP[i][k + 2];\n                        matrixP[i][k + 2] = matrixP[i][k + 2] - p * r;\n                    }\n                    matrixP[i][k] = matrixP[i][k] - p;\n                    matrixP[i][k + 1] = matrixP[i][k + 1] - p * q;\n                }\n            }  // (s != 0)\n        }  // k loop\n\n        // clean up pollution due to round-off errors\n        for (int i = im + 2; i <= iu; i++) {\n            matrixT[i][i-2] = 0.0;\n            if (i > im + 2) {\n                matrixT[i][i-3] = 0.0;\n            }\n        }\n    }",
          "5": "    private void performDoubleQRStep(final int il, final int im, final int iu,\n                                     final ShiftInfo shift, final double[] hVec) {\n\n        final int n = matrixT.length;\n        double p = hVec[0];\n        double q = hVec[1];\n        double r = hVec[2];\n\n        for (int k = im; k <= iu - 1; k++) {\n            boolean notlast = k != (iu - 1);\n            if (k != im) {\n                p = matrixT[k][k - 1];\n                q = matrixT[k + 1][k - 1];\n                r = notlast ? matrixT[k + 2][k - 1] : 0.0;\n                shift.x = FastMath.abs(p) + FastMath.abs(q) + FastMath.abs(r);\n                if (!Precision.equals(shift.x, 0.0, epsilon)) {\n                    p = p / shift.x;\n                    q = q / shift.x;\n                    r = r / shift.x;\n                }\n            }\n            if (shift.x == 0.0) {\n                break;\n            }\n            double s = FastMath.sqrt(p * p + q * q + r * r);\n            if (p < 0.0) {\n                s = -s;\n            }\n            if (s != 0.0) {\n                if (k != im) {\n                    matrixT[k][k - 1] = -s * shift.x;\n                } else if (il != im) {\nr = (r / p);\n                    matrixT[k][k - 1] = +matrixT[k][k - 1];                }\n                p = p + s;\n                shift.x = p / s;\n                shift.y = q / s;\n                double z = r / s;\n                q = q / p;\n                r = r / p;\n\n                // Row modification\n                for (int j = k; j < n; j++) {\n                    p = matrixT[k][j] + q * matrixT[k + 1][j];\n                    if (notlast) {\n                        p = p + r * matrixT[k + 2][j];\n                        matrixT[k + 2][j] = matrixT[k + 2][j] - p * z;\n                    }\n                    matrixT[k][j] = matrixT[k][j] - p * shift.x;\n                    matrixT[k + 1][j] = matrixT[k + 1][j] - p * shift.y;\n                }\n\n                // Column modification\n                for (int i = 0; i <= FastMath.min(iu, k + 3); i++) {\n                    p = shift.x * matrixT[i][k] + shift.y * matrixT[i][k + 1];\n                    if (notlast) {\n                        p = p + z * matrixT[i][k + 2];\n                        matrixT[i][k + 2] = matrixT[i][k + 2] - p * r;\n                    }\n                    matrixT[i][k] = matrixT[i][k] - p;\n                    matrixT[i][k + 1] = matrixT[i][k + 1] - p * q;\n                }\n\n                // Accumulate transformations\n                final int high = matrixT.length - 1;\n                for (int i = 0; i <= high; i++) {\n                    p = shift.x * matrixP[i][k] + shift.y * matrixP[i][k + 1];\n                    if (notlast) {\n                        p = p + z * matrixP[i][k + 2];\n                        matrixP[i][k + 2] = matrixP[i][k + 2] - p * r;\n                    }\n                    matrixP[i][k] = matrixP[i][k] - p;\n                    matrixP[i][k + 1] = matrixP[i][k + 1] - p * q;\n                }\n            }  // (s != 0)\n        }  // k loop\n\n        // clean up pollution due to round-off errors\n        for (int i = im + 2; i <= iu; i++) {\n            matrixT[i][i-2] = 0.0;\n            if (i > im + 2) {\n                matrixT[i][i-3] = 0.0;\n            }\n        }\n    }",
          "6": "    private void performDoubleQRStep(final int il, final int im, final int iu,\n                                     final ShiftInfo shift, final double[] hVec) {\n\n        final int n = matrixT.length;\n        double p = hVec[0];\n        double q = hVec[1];\n        double r = hVec[2];\n\n        for (int k = im; k <= iu - 1; k++) {\n            boolean notlast = k != (iu - 1);\n            if (k != im) {\n                p = matrixT[k][k - 1];\n                q = matrixT[k + 1][k - 1];\n                r = notlast ? matrixT[k + 2][k - 1] : 0.0;\n                shift.x = FastMath.abs(p) + FastMath.abs(q) + FastMath.abs(r);\n                if (!Precision.equals(shift.x, 0.0, epsilon)) {\n                    p = p / shift.x;\n                    q = q / shift.x;\n                    r = r / shift.x;\n                }\n            }\n            if (shift.x == 0.0) {\n                break;\n            }\n            double s = FastMath.sqrt(p * p + q * q + r * r);\n            if (p < 0.0) {\n                s = -s;\n            }\n            if (s != 0.0) {\n                if (k != im) {\n                    matrixT[k][k - 1] = -s * shift.x;\n                } else if (il != im) {\nshift.y = (q / s);\n}\n                    matrixT[k][k - 1] = +matrixT[k][k - 1];                }\n                p = p + s;\n                shift.x = p / s;\n                shift.y = q / s;\n                double z = r / s;\n                q = q / p;\n                r = r / p;\n\n                // Row modification\n                for (int j = k; j < n; j++) {\n                    p = matrixT[k][j] + q * matrixT[k + 1][j];\n                    if (notlast) {\n                        p = p + r * matrixT[k + 2][j];\n                        matrixT[k + 2][j] = matrixT[k + 2][j] - p * z;\n                    }\n                    matrixT[k][j] = matrixT[k][j] - p * shift.x;\n                    matrixT[k + 1][j] = matrixT[k + 1][j] - p * shift.y;\n                }\n\n                // Column modification\n                for (int i = 0; i <= FastMath.min(iu, k + 3); i++) {\n                    p = shift.x * matrixT[i][k] + shift.y * matrixT[i][k + 1];\n                    if (notlast) {\n                        p = p + z * matrixT[i][k + 2];\n                        matrixT[i][k + 2] = matrixT[i][k + 2] - p * r;\n                    }\n                    matrixT[i][k] = matrixT[i][k] - p;\n                    matrixT[i][k + 1] = matrixT[i][k + 1] - p * q;\n                }\n\n                // Accumulate transformations\n                final int high = matrixT.length - 1;\n                for (int i = 0; i <= high; i++) {\n                    p = shift.x * matrixP[i][k] + shift.y * matrixP[i][k + 1];\n                    if (notlast) {\n                        p = p + z * matrixP[i][k + 2];\n                        matrixP[i][k + 2] = matrixP[i][k + 2] - p * r;\n                    }\n                    matrixP[i][k] = matrixP[i][k] - p;\n                    matrixP[i][k + 1] = matrixP[i][k + 1] - p * q;\n                }\n            }  // (s != 0)\n        }  // k loop\n\n        // clean up pollution due to round-off errors\n        for (int i = im + 2; i <= iu; i++) {\n            matrixT[i][i-2] = 0.0;\n            if (i > im + 2) {\n                matrixT[i][i-3] = 0.0;\n            }\n        }\n    }",
          "7": "    private void performDoubleQRStep(final int il, final int im, final int iu,\n                                     final ShiftInfo shift, final double[] hVec) {\n\n        final int n = matrixT.length;\n        double p = hVec[0];\n        double q = hVec[1];\n        double r = hVec[2];\n\n        for (int k = im; k <= iu - 1; k++) {\n            boolean notlast = k != (iu - 1);\n            if (k != im) {\n                p = matrixT[k][k - 1];\n                q = matrixT[k + 1][k - 1];\n                r = notlast ? matrixT[k + 2][k - 1] : 0.0;\n                shift.x = FastMath.abs(p) + FastMath.abs(q) + FastMath.abs(r);\n                if (!Precision.equals(shift.x, 0.0, epsilon)) {\n                    p = p / shift.x;\n                    q = q / shift.x;\n                    r = r / shift.x;\n                }\n            }\n            if (shift.x == 0.0) {\n                break;\n            }\n            double s = FastMath.sqrt(p * p + q * q + r * r);\n            if (p < 0.0) {\n                s = -s;\n            }\n            if (s != 0.0) {\n                if (k != im) {\n                    matrixT[k][k - 1] = -s * shift.x;\n                } else if (il != im) {\nshift.y = (q / s);\n                }\n                p = p + s;\n                shift.x = p / s;\n                shift.y = q / s;\n                double z = r / s;\n                q = q / p;\n                r = r / p;\n\n                // Row modification\n                for (int j = k; j < n; j++) {\n                    p = matrixT[k][j] + q * matrixT[k + 1][j];\n                    if (notlast) {\n                        p = p + r * matrixT[k + 2][j];\n                        matrixT[k + 2][j] = matrixT[k + 2][j] - p * z;\n                    }\n                    matrixT[k][j] = matrixT[k][j] - p * shift.x;\n                    matrixT[k + 1][j] = matrixT[k + 1][j] - p * shift.y;\n                }\n\n                // Column modification\n                for (int i = 0; i <= FastMath.min(iu, k + 3); i++) {\n                    p = shift.x * matrixT[i][k] + shift.y * matrixT[i][k + 1];\n                    if (notlast) {\n                        p = p + z * matrixT[i][k + 2];\n                        matrixT[i][k + 2] = matrixT[i][k + 2] - p * r;\n                    }\n                    matrixT[i][k] = matrixT[i][k] - p;\n                    matrixT[i][k + 1] = matrixT[i][k + 1] - p * q;\n                }\n\n                // Accumulate transformations\n                final int high = matrixT.length - 1;\n                for (int i = 0; i <= high; i++) {\n                    p = shift.x * matrixP[i][k] + shift.y * matrixP[i][k + 1];\n                    if (notlast) {\n                        p = p + z * matrixP[i][k + 2];\n                        matrixP[i][k + 2] = matrixP[i][k + 2] - p * r;\n                    }\n                    matrixP[i][k] = matrixP[i][k] - p;\n                    matrixP[i][k + 1] = matrixP[i][k + 1] - p * q;\n                }\n            }  // (s != 0)\n        }  // k loop\n\n        // clean up pollution due to round-off errors\n        for (int i = im + 2; i <= iu; i++) {\n            matrixT[i][i-2] = 0.0;\n            if (i > im + 2) {\n                matrixT[i][i-3] = 0.0;\n            }\n        }\n    }",
          "8": "    private void performDoubleQRStep(final int il, final int im, final int iu,\n                                     final ShiftInfo shift, final double[] hVec) {\n\n        final int n = matrixT.length;\n        double p = hVec[0];\n        double q = hVec[1];\n        double r = hVec[2];\n\n        for (int k = im; k <= iu - 1; k++) {\n            boolean notlast = k != (iu - 1);\n            if (k != im) {\n                p = matrixT[k][k - 1];\n                q = matrixT[k + 1][k - 1];\n                r = notlast ? matrixT[k + 2][k - 1] : 0.0;\n                shift.x = FastMath.abs(p) + FastMath.abs(q) + FastMath.abs(r);\n                if (!Precision.equals(shift.x, 0.0, epsilon)) {\n                    p = p / shift.x;\n                    q = q / shift.x;\n                    r = r / shift.x;\n                }\n            }\n            if (shift.x == 0.0) {\n                break;\n            }\n            double s = FastMath.sqrt(p * p + q * q + r * r);\n            if (p < 0.0) {\n                s = -s;\n            }\n            if (s != 0.0) {\n                if (k != im) {\n                    matrixT[k][k - 1] = -s * shift.x;\n                } else if (il != im) {\nmatrixT[k].[(k - 1)] = matrixT[k].[(k - 1)];\n                }\n                p = p + s;\n                shift.x = p / s;\n                shift.y = q / s;\n                double z = r / s;\n                q = q / p;\n                r = r / p;\n\n                // Row modification\n                for (int j = k; j < n; j++) {\n                    p = matrixT[k][j] + q * matrixT[k + 1][j];\n                    if (notlast) {\n                        p = p + r * matrixT[k + 2][j];\n                        matrixT[k + 2][j] = matrixT[k + 2][j] - p * z;\n                    }\n                    matrixT[k][j] = matrixT[k][j] - p * shift.x;\n                    matrixT[k + 1][j] = matrixT[k + 1][j] - p * shift.y;\n                }\n\n                // Column modification\n                for (int i = 0; i <= FastMath.min(iu, k + 3); i++) {\n                    p = shift.x * matrixT[i][k] + shift.y * matrixT[i][k + 1];\n                    if (notlast) {\n                        p = p + z * matrixT[i][k + 2];\n                        matrixT[i][k + 2] = matrixT[i][k + 2] - p * r;\n                    }\n                    matrixT[i][k] = matrixT[i][k] - p;\n                    matrixT[i][k + 1] = matrixT[i][k + 1] - p * q;\n                }\n\n                // Accumulate transformations\n                final int high = matrixT.length - 1;\n                for (int i = 0; i <= high; i++) {\n                    p = shift.x * matrixP[i][k] + shift.y * matrixP[i][k + 1];\n                    if (notlast) {\n                        p = p + z * matrixP[i][k + 2];\n                        matrixP[i][k + 2] = matrixP[i][k + 2] - p * r;\n                    }\n                    matrixP[i][k] = matrixP[i][k] - p;\n                    matrixP[i][k + 1] = matrixP[i][k + 1] - p * q;\n                }\n            }  // (s != 0)\n        }  // k loop\n\n        // clean up pollution due to round-off errors\n        for (int i = im + 2; i <= iu; i++) {\n            matrixT[i][i-2] = 0.0;\n            if (i > im + 2) {\n                matrixT[i][i-3] = 0.0;\n            }\n        }\n    }",
          "9": "    private void performDoubleQRStep(final int il, final int im, final int iu,\n                                     final ShiftInfo shift, final double[] hVec) {\n\n        final int n = matrixT.length;\n        double p = hVec[0];\n        double q = hVec[1];\n        double r = hVec[2];\n\n        for (int k = im; k <= iu - 1; k++) {\n            boolean notlast = k != (iu - 1);\n            if (k != im) {\n                p = matrixT[k][k - 1];\n                q = matrixT[k + 1][k - 1];\n                r = notlast ? matrixT[k + 2][k - 1] : 0.0;\n                shift.x = FastMath.abs(p) + FastMath.abs(q) + FastMath.abs(r);\n                if (!Precision.equals(shift.x, 0.0, epsilon)) {\n                    p = p / shift.x;\n                    q = q / shift.x;\n                    r = r / shift.x;\n                }\n            }\n            if (shift.x == 0.0) {\n                break;\n            }\n            double s = FastMath.sqrt(p * p + q * q + r * r);\n            if (p < 0.0) {\n                s = -s;\n            }\n            if (s != 0.0) {\n                if (k != im) {\n                    matrixT[k][k - 1] = -s * shift.x;\n                } else if (il != im) {\nq = matrixT[k].[(k - 1)];\n                }\n                p = p + s;\n                shift.x = p / s;\n                shift.y = q / s;\n                double z = r / s;\n                q = q / p;\n                r = r / p;\n\n                // Row modification\n                for (int j = k; j < n; j++) {\n                    p = matrixT[k][j] + q * matrixT[k + 1][j];\n                    if (notlast) {\n                        p = p + r * matrixT[k + 2][j];\n                        matrixT[k + 2][j] = matrixT[k + 2][j] - p * z;\n                    }\n                    matrixT[k][j] = matrixT[k][j] - p * shift.x;\n                    matrixT[k + 1][j] = matrixT[k + 1][j] - p * shift.y;\n                }\n\n                // Column modification\n                for (int i = 0; i <= FastMath.min(iu, k + 3); i++) {\n                    p = shift.x * matrixT[i][k] + shift.y * matrixT[i][k + 1];\n                    if (notlast) {\n                        p = p + z * matrixT[i][k + 2];\n                        matrixT[i][k + 2] = matrixT[i][k + 2] - p * r;\n                    }\n                    matrixT[i][k] = matrixT[i][k] - p;\n                    matrixT[i][k + 1] = matrixT[i][k + 1] - p * q;\n                }\n\n                // Accumulate transformations\n                final int high = matrixT.length - 1;\n                for (int i = 0; i <= high; i++) {\n                    p = shift.x * matrixP[i][k] + shift.y * matrixP[i][k + 1];\n                    if (notlast) {\n                        p = p + z * matrixP[i][k + 2];\n                        matrixP[i][k + 2] = matrixP[i][k + 2] - p * r;\n                    }\n                    matrixP[i][k] = matrixP[i][k] - p;\n                    matrixP[i][k + 1] = matrixP[i][k + 1] - p * q;\n                }\n            }  // (s != 0)\n        }  // k loop\n\n        // clean up pollution due to round-off errors\n        for (int i = im + 2; i <= iu; i++) {\n            matrixT[i][i-2] = 0.0;\n            if (i > im + 2) {\n                matrixT[i][i-3] = 0.0;\n            }\n        }\n    }",
          "10": "    private void performDoubleQRStep(final int il, final int im, final int iu,\n                                     final ShiftInfo shift, final double[] hVec) {\n\n        final int n = matrixT.length;\n        double p = hVec[0];\n        double q = hVec[1];\n        double r = hVec[2];\n\n        for (int k = im; k <= iu - 1; k++) {\n            boolean notlast = k != (iu - 1);\n            if (k != im) {\n                p = matrixT[k][k - 1];\n                q = matrixT[k + 1][k - 1];\n                r = notlast ? matrixT[k + 2][k - 1] : 0.0;\n                shift.x = FastMath.abs(p) + FastMath.abs(q) + FastMath.abs(r);\n                if (!Precision.equals(shift.x, 0.0, epsilon)) {\n                    p = p / shift.x;\n                    q = q / shift.x;\n                    r = r / shift.x;\n                }\n            }\n            if (shift.x == 0.0) {\n                break;\n            }\n            double s = FastMath.sqrt(p * p + q * q + r * r);\n            if (p < 0.0) {\n                s = -s;\n            }\n            if (s != 0.0) {\n                if (k != im) {\n                    matrixT[k][k - 1] = -s * shift.x;\n                } else if (il != im) {\np = matrixT[k].[(k - 1)];\n                }\n                p = p + s;\n                shift.x = p / s;\n                shift.y = q / s;\n                double z = r / s;\n                q = q / p;\n                r = r / p;\n\n                // Row modification\n                for (int j = k; j < n; j++) {\n                    p = matrixT[k][j] + q * matrixT[k + 1][j];\n                    if (notlast) {\n                        p = p + r * matrixT[k + 2][j];\n                        matrixT[k + 2][j] = matrixT[k + 2][j] - p * z;\n                    }\n                    matrixT[k][j] = matrixT[k][j] - p * shift.x;\n                    matrixT[k + 1][j] = matrixT[k + 1][j] - p * shift.y;\n                }\n\n                // Column modification\n                for (int i = 0; i <= FastMath.min(iu, k + 3); i++) {\n                    p = shift.x * matrixT[i][k] + shift.y * matrixT[i][k + 1];\n                    if (notlast) {\n                        p = p + z * matrixT[i][k + 2];\n                        matrixT[i][k + 2] = matrixT[i][k + 2] - p * r;\n                    }\n                    matrixT[i][k] = matrixT[i][k] - p;\n                    matrixT[i][k + 1] = matrixT[i][k + 1] - p * q;\n                }\n\n                // Accumulate transformations\n                final int high = matrixT.length - 1;\n                for (int i = 0; i <= high; i++) {\n                    p = shift.x * matrixP[i][k] + shift.y * matrixP[i][k + 1];\n                    if (notlast) {\n                        p = p + z * matrixP[i][k + 2];\n                        matrixP[i][k + 2] = matrixP[i][k + 2] - p * r;\n                    }\n                    matrixP[i][k] = matrixP[i][k] - p;\n                    matrixP[i][k + 1] = matrixP[i][k + 1] - p * q;\n                }\n            }  // (s != 0)\n        }  // k loop\n\n        // clean up pollution due to round-off errors\n        for (int i = im + 2; i <= iu; i++) {\n            matrixT[i][i-2] = 0.0;\n            if (i > im + 2) {\n                matrixT[i][i-3] = 0.0;\n            }\n        }\n    }",
          "11": "    private void performDoubleQRStep(final int il, final int im, final int iu,\n                                     final ShiftInfo shift, final double[] hVec) {\n\n        final int n = matrixT.length;\n        double p = hVec[0];\n        double q = hVec[1];\n        double r = hVec[2];\n\n        for (int k = im; k <= iu - 1; k++) {\n            boolean notlast = k != (iu - 1);\n            if (k != im) {\n                p = matrixT[k][k - 1];\n                q = matrixT[k + 1][k - 1];\n                r = notlast ? matrixT[k + 2][k - 1] : 0.0;\n                shift.x = FastMath.abs(p) + FastMath.abs(q) + FastMath.abs(r);\n                if (!Precision.equals(shift.x, 0.0, epsilon)) {\n                    p = p / shift.x;\n                    q = q / shift.x;\n                    r = r / shift.x;\n                }\n            }\n            if (shift.x == 0.0) {\n                break;\n            }\n            double s = FastMath.sqrt(p * p + q * q + r * r);\n            if (p < 0.0) {\n                s = -s;\n            }\n            if (s != 0.0) {\n                if (k != im) {\n                    matrixT[k][k - 1] = -s * shift.x;\n                } else if (il != im) {\nq = (q / p);\n                }\n                p = p + s;\n                shift.x = p / s;\n                shift.y = q / s;\n                double z = r / s;\n                q = q / p;\n                r = r / p;\n\n                // Row modification\n                for (int j = k; j < n; j++) {\n                    p = matrixT[k][j] + q * matrixT[k + 1][j];\n                    if (notlast) {\n                        p = p + r * matrixT[k + 2][j];\n                        matrixT[k + 2][j] = matrixT[k + 2][j] - p * z;\n                    }\n                    matrixT[k][j] = matrixT[k][j] - p * shift.x;\n                    matrixT[k + 1][j] = matrixT[k + 1][j] - p * shift.y;\n                }\n\n                // Column modification\n                for (int i = 0; i <= FastMath.min(iu, k + 3); i++) {\n                    p = shift.x * matrixT[i][k] + shift.y * matrixT[i][k + 1];\n                    if (notlast) {\n                        p = p + z * matrixT[i][k + 2];\n                        matrixT[i][k + 2] = matrixT[i][k + 2] - p * r;\n                    }\n                    matrixT[i][k] = matrixT[i][k] - p;\n                    matrixT[i][k + 1] = matrixT[i][k + 1] - p * q;\n                }\n\n                // Accumulate transformations\n                final int high = matrixT.length - 1;\n                for (int i = 0; i <= high; i++) {\n                    p = shift.x * matrixP[i][k] + shift.y * matrixP[i][k + 1];\n                    if (notlast) {\n                        p = p + z * matrixP[i][k + 2];\n                        matrixP[i][k + 2] = matrixP[i][k + 2] - p * r;\n                    }\n                    matrixP[i][k] = matrixP[i][k] - p;\n                    matrixP[i][k + 1] = matrixP[i][k + 1] - p * q;\n                }\n            }  // (s != 0)\n        }  // k loop\n\n        // clean up pollution due to round-off errors\n        for (int i = im + 2; i <= iu; i++) {\n            matrixT[i][i-2] = 0.0;\n            if (i > im + 2) {\n                matrixT[i][i-3] = 0.0;\n            }\n        }\n    }",
          "12": "    private void performDoubleQRStep(final int il, final int im, final int iu,\n                                     final ShiftInfo shift, final double[] hVec) {\n\n        final int n = matrixT.length;\n        double p = hVec[0];\n        double q = hVec[1];\n        double r = hVec[2];\n\n        for (int k = im; k <= iu - 1; k++) {\n            boolean notlast = k != (iu - 1);\n            if (k != im) {\n                p = matrixT[k][k - 1];\n                q = matrixT[k + 1][k - 1];\n                r = notlast ? matrixT[k + 2][k - 1] : 0.0;\n                shift.x = FastMath.abs(p) + FastMath.abs(q) + FastMath.abs(r);\n                if (!Precision.equals(shift.x, 0.0, epsilon)) {\n                    p = p / shift.x;\n                    q = q / shift.x;\n                    r = r / shift.x;\n                }\n            }\n            if (shift.x == 0.0) {\n                break;\n            }\n            double s = FastMath.sqrt(p * p + q * q + r * r);\n            if (p < 0.0) {\n                s = -s;\n            }\n            if (s != 0.0) {\n                if (k != im) {\n                    matrixT[k][k - 1] = -s * shift.x;\n                } else if (il != im) {\nr = (r / p);\n                }\n                p = p + s;\n                shift.x = p / s;\n                shift.y = q / s;\n                double z = r / s;\n                q = q / p;\n                r = r / p;\n\n                // Row modification\n                for (int j = k; j < n; j++) {\n                    p = matrixT[k][j] + q * matrixT[k + 1][j];\n                    if (notlast) {\n                        p = p + r * matrixT[k + 2][j];\n                        matrixT[k + 2][j] = matrixT[k + 2][j] - p * z;\n                    }\n                    matrixT[k][j] = matrixT[k][j] - p * shift.x;\n                    matrixT[k + 1][j] = matrixT[k + 1][j] - p * shift.y;\n                }\n\n                // Column modification\n                for (int i = 0; i <= FastMath.min(iu, k + 3); i++) {\n                    p = shift.x * matrixT[i][k] + shift.y * matrixT[i][k + 1];\n                    if (notlast) {\n                        p = p + z * matrixT[i][k + 2];\n                        matrixT[i][k + 2] = matrixT[i][k + 2] - p * r;\n                    }\n                    matrixT[i][k] = matrixT[i][k] - p;\n                    matrixT[i][k + 1] = matrixT[i][k + 1] - p * q;\n                }\n\n                // Accumulate transformations\n                final int high = matrixT.length - 1;\n                for (int i = 0; i <= high; i++) {\n                    p = shift.x * matrixP[i][k] + shift.y * matrixP[i][k + 1];\n                    if (notlast) {\n                        p = p + z * matrixP[i][k + 2];\n                        matrixP[i][k + 2] = matrixP[i][k + 2] - p * r;\n                    }\n                    matrixP[i][k] = matrixP[i][k] - p;\n                    matrixP[i][k + 1] = matrixP[i][k + 1] - p * q;\n                }\n            }  // (s != 0)\n        }  // k loop\n\n        // clean up pollution due to round-off errors\n        for (int i = im + 2; i <= iu; i++) {\n            matrixT[i][i-2] = 0.0;\n            if (i > im + 2) {\n                matrixT[i][i-3] = 0.0;\n            }\n        }\n    }",
          "13": "    private void performDoubleQRStep(final int il, final int im, final int iu,\n                                     final ShiftInfo shift, final double[] hVec) {\n\n        final int n = matrixT.length;\n        double p = hVec[0];\n        double q = hVec[1];\n        double r = hVec[2];\n\n        for (int k = im; k <= iu - 1; k++) {\n            boolean notlast = k != (iu - 1);\n            if (k != im) {\n                p = matrixT[k][k - 1];\n                q = matrixT[k + 1][k - 1];\n                r = notlast ? matrixT[k + 2][k - 1] : 0.0;\n                shift.x = FastMath.abs(p) + FastMath.abs(q) + FastMath.abs(r);\n                if (!Precision.equals(shift.x, 0.0, epsilon)) {\n                    p = p / shift.x;\n                    q = q / shift.x;\n                    r = r / shift.x;\n                }\n            }\n            if (shift.x == 0.0) {\n                break;\n            }\n            double s = FastMath.sqrt(p * p + q * q + r * r);\n            if (p < 0.0) {\n                s = -s;\n            }\n            if (s != 0.0) {\n                if (k != im) {\n                    matrixT[k][k - 1] = -s * shift.x;\n                } else if (il != im) {\nr = matrixT[k].[(k - 1)];\n                }\n                p = p + s;\n                shift.x = p / s;\n                shift.y = q / s;\n                double z = r / s;\n                q = q / p;\n                r = r / p;\n\n                // Row modification\n                for (int j = k; j < n; j++) {\n                    p = matrixT[k][j] + q * matrixT[k + 1][j];\n                    if (notlast) {\n                        p = p + r * matrixT[k + 2][j];\n                        matrixT[k + 2][j] = matrixT[k + 2][j] - p * z;\n                    }\n                    matrixT[k][j] = matrixT[k][j] - p * shift.x;\n                    matrixT[k + 1][j] = matrixT[k + 1][j] - p * shift.y;\n                }\n\n                // Column modification\n                for (int i = 0; i <= FastMath.min(iu, k + 3); i++) {\n                    p = shift.x * matrixT[i][k] + shift.y * matrixT[i][k + 1];\n                    if (notlast) {\n                        p = p + z * matrixT[i][k + 2];\n                        matrixT[i][k + 2] = matrixT[i][k + 2] - p * r;\n                    }\n                    matrixT[i][k] = matrixT[i][k] - p;\n                    matrixT[i][k + 1] = matrixT[i][k + 1] - p * q;\n                }\n\n                // Accumulate transformations\n                final int high = matrixT.length - 1;\n                for (int i = 0; i <= high; i++) {\n                    p = shift.x * matrixP[i][k] + shift.y * matrixP[i][k + 1];\n                    if (notlast) {\n                        p = p + z * matrixP[i][k + 2];\n                        matrixP[i][k + 2] = matrixP[i][k + 2] - p * r;\n                    }\n                    matrixP[i][k] = matrixP[i][k] - p;\n                    matrixP[i][k + 1] = matrixP[i][k + 1] - p * q;\n                }\n            }  // (s != 0)\n        }  // k loop\n\n        // clean up pollution due to round-off errors\n        for (int i = im + 2; i <= iu; i++) {\n            matrixT[i][i-2] = 0.0;\n            if (i > im + 2) {\n                matrixT[i][i-3] = 0.0;\n            }\n        }\n    }",
          "14": "    private void performDoubleQRStep(final int il, final int im, final int iu,\n                                     final ShiftInfo shift, final double[] hVec) {\n\n        final int n = matrixT.length;\n        double p = hVec[0];\n        double q = hVec[1];\n        double r = hVec[2];\n\n        for (int k = im; k <= iu - 1; k++) {\n            boolean notlast = k != (iu - 1);\n            if (k != im) {\n                p = matrixT[k][k - 1];\n                q = matrixT[k + 1][k - 1];\n                r = notlast ? matrixT[k + 2][k - 1] : 0.0;\n                shift.x = FastMath.abs(p) + FastMath.abs(q) + FastMath.abs(r);\n                if (!Precision.equals(shift.x, 0.0, epsilon)) {\n                    p = p / shift.x;\n                    q = q / shift.x;\n                    r = r / shift.x;\n                }\n            }\n            if (shift.x == 0.0) {\n                break;\n            }\n            double s = FastMath.sqrt(p * p + q * q + r * r);\n            if (p < 0.0) {\n                s = -s;\n            }\n            if (s != 0.0) {\n                if (k != im) {\n                    matrixT[k][k - 1] = -s * shift.x;\n                } else if (il != im) {\nmatrixT[k].[(k - 1)] = matrixP[k].[(k - 1)];\n                }\n                p = p + s;\n                shift.x = p / s;\n                shift.y = q / s;\n                double z = r / s;\n                q = q / p;\n                r = r / p;\n\n                // Row modification\n                for (int j = k; j < n; j++) {\n                    p = matrixT[k][j] + q * matrixT[k + 1][j];\n                    if (notlast) {\n                        p = p + r * matrixT[k + 2][j];\n                        matrixT[k + 2][j] = matrixT[k + 2][j] - p * z;\n                    }\n                    matrixT[k][j] = matrixT[k][j] - p * shift.x;\n                    matrixT[k + 1][j] = matrixT[k + 1][j] - p * shift.y;\n                }\n\n                // Column modification\n                for (int i = 0; i <= FastMath.min(iu, k + 3); i++) {\n                    p = shift.x * matrixT[i][k] + shift.y * matrixT[i][k + 1];\n                    if (notlast) {\n                        p = p + z * matrixT[i][k + 2];\n                        matrixT[i][k + 2] = matrixT[i][k + 2] - p * r;\n                    }\n                    matrixT[i][k] = matrixT[i][k] - p;\n                    matrixT[i][k + 1] = matrixT[i][k + 1] - p * q;\n                }\n\n                // Accumulate transformations\n                final int high = matrixT.length - 1;\n                for (int i = 0; i <= high; i++) {\n                    p = shift.x * matrixP[i][k] + shift.y * matrixP[i][k + 1];\n                    if (notlast) {\n                        p = p + z * matrixP[i][k + 2];\n                        matrixP[i][k + 2] = matrixP[i][k + 2] - p * r;\n                    }\n                    matrixP[i][k] = matrixP[i][k] - p;\n                    matrixP[i][k + 1] = matrixP[i][k + 1] - p * q;\n                }\n            }  // (s != 0)\n        }  // k loop\n\n        // clean up pollution due to round-off errors\n        for (int i = im + 2; i <= iu; i++) {\n            matrixT[i][i-2] = 0.0;\n            if (i > im + 2) {\n                matrixT[i][i-3] = 0.0;\n            }\n        }\n    }",
          "15": "    private void performDoubleQRStep(final int il, final int im, final int iu,\n                                     final ShiftInfo shift, final double[] hVec) {\n\n        final int n = matrixT.length;\n        double p = hVec[0];\n        double q = hVec[1];\n        double r = hVec[2];\n\n        for (int k = im; k <= iu - 1; k++) {\n            boolean notlast = k != (iu - 1);\n            if (k != im) {\n                p = matrixT[k][k - 1];\n                q = matrixT[k + 1][k - 1];\n                r = notlast ? matrixT[k + 2][k - 1] : 0.0;\n                shift.x = FastMath.abs(p) + FastMath.abs(q) + FastMath.abs(r);\n                if (!Precision.equals(shift.x, 0.0, epsilon)) {\n                    p = p / shift.x;\n                    q = q / shift.x;\n                    r = r / shift.x;\n                }\n            }\n            if (shift.x == 0.0) {\n                break;\n            }\n            double s = FastMath.sqrt(p * p + q * q + r * r);\n            if (p < 0.0) {\n                s = -s;\n            }\n            if (s != 0.0) {\n                if (k != im) {\n                    matrixT[k][k - 1] = -s * shift.x;\n                } else if (il != im) {\nmatrixT[k].[(k - 1)] = epsilon[k].[(k - 1)];\n                }\n                p = p + s;\n                shift.x = p / s;\n                shift.y = q / s;\n                double z = r / s;\n                q = q / p;\n                r = r / p;\n\n                // Row modification\n                for (int j = k; j < n; j++) {\n                    p = matrixT[k][j] + q * matrixT[k + 1][j];\n                    if (notlast) {\n                        p = p + r * matrixT[k + 2][j];\n                        matrixT[k + 2][j] = matrixT[k + 2][j] - p * z;\n                    }\n                    matrixT[k][j] = matrixT[k][j] - p * shift.x;\n                    matrixT[k + 1][j] = matrixT[k + 1][j] - p * shift.y;\n                }\n\n                // Column modification\n                for (int i = 0; i <= FastMath.min(iu, k + 3); i++) {\n                    p = shift.x * matrixT[i][k] + shift.y * matrixT[i][k + 1];\n                    if (notlast) {\n                        p = p + z * matrixT[i][k + 2];\n                        matrixT[i][k + 2] = matrixT[i][k + 2] - p * r;\n                    }\n                    matrixT[i][k] = matrixT[i][k] - p;\n                    matrixT[i][k + 1] = matrixT[i][k + 1] - p * q;\n                }\n\n                // Accumulate transformations\n                final int high = matrixT.length - 1;\n                for (int i = 0; i <= high; i++) {\n                    p = shift.x * matrixP[i][k] + shift.y * matrixP[i][k + 1];\n                    if (notlast) {\n                        p = p + z * matrixP[i][k + 2];\n                        matrixP[i][k + 2] = matrixP[i][k + 2] - p * r;\n                    }\n                    matrixP[i][k] = matrixP[i][k] - p;\n                    matrixP[i][k + 1] = matrixP[i][k + 1] - p * q;\n                }\n            }  // (s != 0)\n        }  // k loop\n\n        // clean up pollution due to round-off errors\n        for (int i = im + 2; i <= iu; i++) {\n            matrixT[i][i-2] = 0.0;\n            if (i > im + 2) {\n                matrixT[i][i-3] = 0.0;\n            }\n        }\n    }",
          "16": "    private void performDoubleQRStep(final int il, final int im, final int iu,\n                                     final ShiftInfo shift, final double[] hVec) {\n\n        final int n = matrixT.length;\n        double p = hVec[0];\n        double q = hVec[1];\n        double r = hVec[2];\n\n        for (int k = im; k <= iu - 1; k++) {\n            boolean notlast = k != (iu - 1);\n            if (k != im) {\n                p = matrixT[k][k - 1];\n                q = matrixT[k + 1][k - 1];\n                r = notlast ? matrixT[k + 2][k - 1] : 0.0;\n                shift.x = FastMath.abs(p) + FastMath.abs(q) + FastMath.abs(r);\n                if (!Precision.equals(shift.x, 0.0, epsilon)) {\n                    p = p / shift.x;\n                    q = q / shift.x;\n                    r = r / shift.x;\n                }\n            }\n            if (shift.x == 0.0) {\n                break;\n            }\n            double s = FastMath.sqrt(p * p + q * q + r * r);\n            if (p < 0.0) {\n                s = -s;\n            }\n            if (s != 0.0) {\n                if (k != im) {\n                    matrixT[k][k - 1] = -s * shift.x;\n                } else if (il != im) {\nmatrixT[k].[(k - 1)] = x[k].[(k - 1)];\n                }\n                p = p + s;\n                shift.x = p / s;\n                shift.y = q / s;\n                double z = r / s;\n                q = q / p;\n                r = r / p;\n\n                // Row modification\n                for (int j = k; j < n; j++) {\n                    p = matrixT[k][j] + q * matrixT[k + 1][j];\n                    if (notlast) {\n                        p = p + r * matrixT[k + 2][j];\n                        matrixT[k + 2][j] = matrixT[k + 2][j] - p * z;\n                    }\n                    matrixT[k][j] = matrixT[k][j] - p * shift.x;\n                    matrixT[k + 1][j] = matrixT[k + 1][j] - p * shift.y;\n                }\n\n                // Column modification\n                for (int i = 0; i <= FastMath.min(iu, k + 3); i++) {\n                    p = shift.x * matrixT[i][k] + shift.y * matrixT[i][k + 1];\n                    if (notlast) {\n                        p = p + z * matrixT[i][k + 2];\n                        matrixT[i][k + 2] = matrixT[i][k + 2] - p * r;\n                    }\n                    matrixT[i][k] = matrixT[i][k] - p;\n                    matrixT[i][k + 1] = matrixT[i][k + 1] - p * q;\n                }\n\n                // Accumulate transformations\n                final int high = matrixT.length - 1;\n                for (int i = 0; i <= high; i++) {\n                    p = shift.x * matrixP[i][k] + shift.y * matrixP[i][k + 1];\n                    if (notlast) {\n                        p = p + z * matrixP[i][k + 2];\n                        matrixP[i][k + 2] = matrixP[i][k + 2] - p * r;\n                    }\n                    matrixP[i][k] = matrixP[i][k] - p;\n                    matrixP[i][k + 1] = matrixP[i][k + 1] - p * q;\n                }\n            }  // (s != 0)\n        }  // k loop\n\n        // clean up pollution due to round-off errors\n        for (int i = im + 2; i <= iu; i++) {\n            matrixT[i][i-2] = 0.0;\n            if (i > im + 2) {\n                matrixT[i][i-3] = 0.0;\n            }\n        }\n    }",
          "17": "    private void performDoubleQRStep(final int il, final int im, final int iu,\n                                     final ShiftInfo shift, final double[] hVec) {\n\n        final int n = matrixT.length;\n        double p = hVec[0];\n        double q = hVec[1];\n        double r = hVec[2];\n\n        for (int k = im; k <= iu - 1; k++) {\n            boolean notlast = k != (iu - 1);\n            if (k != im) {\n                p = matrixT[k][k - 1];\n                q = matrixT[k + 1][k - 1];\n                r = notlast ? matrixT[k + 2][k - 1] : 0.0;\n                shift.x = FastMath.abs(p) + FastMath.abs(q) + FastMath.abs(r);\n                if (!Precision.equals(shift.x, 0.0, epsilon)) {\n                    p = p / shift.x;\n                    q = q / shift.x;\n                    r = r / shift.x;\n                }\n            }\n            if (shift.x == 0.0) {\n                break;\n            }\n            double s = FastMath.sqrt(p * p + q * q + r * r);\n            if (p < 0.0) {\n                s = -s;\n            }\n            if (s != 0.0) {\n                if (k != im) {\n                    matrixT[k][k - 1] = -s * shift.x;\n                } else if (il != im) {\nmatrixT[k].[(k - 1)] = y[k].[(k - 1)];\n                }\n                p = p + s;\n                shift.x = p / s;\n                shift.y = q / s;\n                double z = r / s;\n                q = q / p;\n                r = r / p;\n\n                // Row modification\n                for (int j = k; j < n; j++) {\n                    p = matrixT[k][j] + q * matrixT[k + 1][j];\n                    if (notlast) {\n                        p = p + r * matrixT[k + 2][j];\n                        matrixT[k + 2][j] = matrixT[k + 2][j] - p * z;\n                    }\n                    matrixT[k][j] = matrixT[k][j] - p * shift.x;\n                    matrixT[k + 1][j] = matrixT[k + 1][j] - p * shift.y;\n                }\n\n                // Column modification\n                for (int i = 0; i <= FastMath.min(iu, k + 3); i++) {\n                    p = shift.x * matrixT[i][k] + shift.y * matrixT[i][k + 1];\n                    if (notlast) {\n                        p = p + z * matrixT[i][k + 2];\n                        matrixT[i][k + 2] = matrixT[i][k + 2] - p * r;\n                    }\n                    matrixT[i][k] = matrixT[i][k] - p;\n                    matrixT[i][k + 1] = matrixT[i][k + 1] - p * q;\n                }\n\n                // Accumulate transformations\n                final int high = matrixT.length - 1;\n                for (int i = 0; i <= high; i++) {\n                    p = shift.x * matrixP[i][k] + shift.y * matrixP[i][k + 1];\n                    if (notlast) {\n                        p = p + z * matrixP[i][k + 2];\n                        matrixP[i][k + 2] = matrixP[i][k + 2] - p * r;\n                    }\n                    matrixP[i][k] = matrixP[i][k] - p;\n                    matrixP[i][k + 1] = matrixP[i][k + 1] - p * q;\n                }\n            }  // (s != 0)\n        }  // k loop\n\n        // clean up pollution due to round-off errors\n        for (int i = im + 2; i <= iu; i++) {\n            matrixT[i][i-2] = 0.0;\n            if (i > im + 2) {\n                matrixT[i][i-3] = 0.0;\n            }\n        }\n    }",
          "18": "    private void performDoubleQRStep(final int il, final int im, final int iu,\n                                     final ShiftInfo shift, final double[] hVec) {\n\n        final int n = matrixT.length;\n        double p = hVec[0];\n        double q = hVec[1];\n        double r = hVec[2];\n\n        for (int k = im; k <= iu - 1; k++) {\n            boolean notlast = k != (iu - 1);\n            if (k != im) {\n                p = matrixT[k][k - 1];\n                q = matrixT[k + 1][k - 1];\n                r = notlast ? matrixT[k + 2][k - 1] : 0.0;\n                shift.x = FastMath.abs(p) + FastMath.abs(q) + FastMath.abs(r);\n                if (!Precision.equals(shift.x, 0.0, epsilon)) {\n                    p = p / shift.x;\n                    q = q / shift.x;\n                    r = r / shift.x;\n                }\n            }\n            if (shift.x == 0.0) {\n                break;\n            }\n            double s = FastMath.sqrt(p * p + q * q + r * r);\n            if (p < 0.0) {\n                s = -s;\n            }\n            if (s != 0.0) {\n                if (k != im) {\n                    matrixT[k][k - 1] = -s * shift.x;\n                } else if (il != im) {\nmatrixT[k].[(k - 1)] = w[k].[(k - 1)];\n                }\n                p = p + s;\n                shift.x = p / s;\n                shift.y = q / s;\n                double z = r / s;\n                q = q / p;\n                r = r / p;\n\n                // Row modification\n                for (int j = k; j < n; j++) {\n                    p = matrixT[k][j] + q * matrixT[k + 1][j];\n                    if (notlast) {\n                        p = p + r * matrixT[k + 2][j];\n                        matrixT[k + 2][j] = matrixT[k + 2][j] - p * z;\n                    }\n                    matrixT[k][j] = matrixT[k][j] - p * shift.x;\n                    matrixT[k + 1][j] = matrixT[k + 1][j] - p * shift.y;\n                }\n\n                // Column modification\n                for (int i = 0; i <= FastMath.min(iu, k + 3); i++) {\n                    p = shift.x * matrixT[i][k] + shift.y * matrixT[i][k + 1];\n                    if (notlast) {\n                        p = p + z * matrixT[i][k + 2];\n                        matrixT[i][k + 2] = matrixT[i][k + 2] - p * r;\n                    }\n                    matrixT[i][k] = matrixT[i][k] - p;\n                    matrixT[i][k + 1] = matrixT[i][k + 1] - p * q;\n                }\n\n                // Accumulate transformations\n                final int high = matrixT.length - 1;\n                for (int i = 0; i <= high; i++) {\n                    p = shift.x * matrixP[i][k] + shift.y * matrixP[i][k + 1];\n                    if (notlast) {\n                        p = p + z * matrixP[i][k + 2];\n                        matrixP[i][k + 2] = matrixP[i][k + 2] - p * r;\n                    }\n                    matrixP[i][k] = matrixP[i][k] - p;\n                    matrixP[i][k + 1] = matrixP[i][k + 1] - p * q;\n                }\n            }  // (s != 0)\n        }  // k loop\n\n        // clean up pollution due to round-off errors\n        for (int i = im + 2; i <= iu; i++) {\n            matrixT[i][i-2] = 0.0;\n            if (i > im + 2) {\n                matrixT[i][i-3] = 0.0;\n            }\n        }\n    }",
          "19": "    private void performDoubleQRStep(final int il, final int im, final int iu,\n                                     final ShiftInfo shift, final double[] hVec) {\n\n        final int n = matrixT.length;\n        double p = hVec[0];\n        double q = hVec[1];\n        double r = hVec[2];\n\n        for (int k = im; k <= iu - 1; k++) {\n            boolean notlast = k != (iu - 1);\n            if (k != im) {\n                p = matrixT[k][k - 1];\n                q = matrixT[k + 1][k - 1];\n                r = notlast ? matrixT[k + 2][k - 1] : 0.0;\n                shift.x = FastMath.abs(p) + FastMath.abs(q) + FastMath.abs(r);\n                if (!Precision.equals(shift.x, 0.0, epsilon)) {\n                    p = p / shift.x;\n                    q = q / shift.x;\n                    r = r / shift.x;\n                }\n            }\n            if (shift.x == 0.0) {\n                break;\n            }\n            double s = FastMath.sqrt(p * p + q * q + r * r);\n            if (p < 0.0) {\n                s = -s;\n            }\n            if (s != 0.0) {\n                if (k != im) {\n                    matrixT[k][k - 1] = -s * shift.x;\n                } else if (il != im) {\nmatrixT[k].[(k - 1)] = exShift[k].[(k - 1)];\n                }\n                p = p + s;\n                shift.x = p / s;\n                shift.y = q / s;\n                double z = r / s;\n                q = q / p;\n                r = r / p;\n\n                // Row modification\n                for (int j = k; j < n; j++) {\n                    p = matrixT[k][j] + q * matrixT[k + 1][j];\n                    if (notlast) {\n                        p = p + r * matrixT[k + 2][j];\n                        matrixT[k + 2][j] = matrixT[k + 2][j] - p * z;\n                    }\n                    matrixT[k][j] = matrixT[k][j] - p * shift.x;\n                    matrixT[k + 1][j] = matrixT[k + 1][j] - p * shift.y;\n                }\n\n                // Column modification\n                for (int i = 0; i <= FastMath.min(iu, k + 3); i++) {\n                    p = shift.x * matrixT[i][k] + shift.y * matrixT[i][k + 1];\n                    if (notlast) {\n                        p = p + z * matrixT[i][k + 2];\n                        matrixT[i][k + 2] = matrixT[i][k + 2] - p * r;\n                    }\n                    matrixT[i][k] = matrixT[i][k] - p;\n                    matrixT[i][k + 1] = matrixT[i][k + 1] - p * q;\n                }\n\n                // Accumulate transformations\n                final int high = matrixT.length - 1;\n                for (int i = 0; i <= high; i++) {\n                    p = shift.x * matrixP[i][k] + shift.y * matrixP[i][k + 1];\n                    if (notlast) {\n                        p = p + z * matrixP[i][k + 2];\n                        matrixP[i][k + 2] = matrixP[i][k + 2] - p * r;\n                    }\n                    matrixP[i][k] = matrixP[i][k] - p;\n                    matrixP[i][k + 1] = matrixP[i][k + 1] - p * q;\n                }\n            }  // (s != 0)\n        }  // k loop\n\n        // clean up pollution due to round-off errors\n        for (int i = im + 2; i <= iu; i++) {\n            matrixT[i][i-2] = 0.0;\n            if (i > im + 2) {\n                matrixT[i][i-3] = 0.0;\n            }\n        }\n    }",
          "20": "    private void performDoubleQRStep(final int il, final int im, final int iu,\n                                     final ShiftInfo shift, final double[] hVec) {\n\n        final int n = matrixT.length;\n        double p = hVec[0];\n        double q = hVec[1];\n        double r = hVec[2];\n\n        for (int k = im; k <= iu - 1; k++) {\n            boolean notlast = k != (iu - 1);\n            if (k != im) {\n                p = matrixT[k][k - 1];\n                q = matrixT[k + 1][k - 1];\n                r = notlast ? matrixT[k + 2][k - 1] : 0.0;\n                shift.x = FastMath.abs(p) + FastMath.abs(q) + FastMath.abs(r);\n                if (!Precision.equals(shift.x, 0.0, epsilon)) {\n                    p = p / shift.x;\n                    q = q / shift.x;\n                    r = r / shift.x;\n                }\n            }\n            if (shift.x == 0.0) {\n                break;\n            }\n            double s = FastMath.sqrt(p * p + q * q + r * r);\n            if (p < 0.0) {\n                s = -s;\n            }\n            if (s != 0.0) {\n                if (k != im) {\n                    matrixT[k][k - 1] = -s * shift.x;\n                } else if (il != im) {\nmatrixT[k].[(k - 1)] = matrixT[(k - 1)];\n                }\n                p = p + s;\n                shift.x = p / s;\n                shift.y = q / s;\n                double z = r / s;\n                q = q / p;\n                r = r / p;\n\n                // Row modification\n                for (int j = k; j < n; j++) {\n                    p = matrixT[k][j] + q * matrixT[k + 1][j];\n                    if (notlast) {\n                        p = p + r * matrixT[k + 2][j];\n                        matrixT[k + 2][j] = matrixT[k + 2][j] - p * z;\n                    }\n                    matrixT[k][j] = matrixT[k][j] - p * shift.x;\n                    matrixT[k + 1][j] = matrixT[k + 1][j] - p * shift.y;\n                }\n\n                // Column modification\n                for (int i = 0; i <= FastMath.min(iu, k + 3); i++) {\n                    p = shift.x * matrixT[i][k] + shift.y * matrixT[i][k + 1];\n                    if (notlast) {\n                        p = p + z * matrixT[i][k + 2];\n                        matrixT[i][k + 2] = matrixT[i][k + 2] - p * r;\n                    }\n                    matrixT[i][k] = matrixT[i][k] - p;\n                    matrixT[i][k + 1] = matrixT[i][k + 1] - p * q;\n                }\n\n                // Accumulate transformations\n                final int high = matrixT.length - 1;\n                for (int i = 0; i <= high; i++) {\n                    p = shift.x * matrixP[i][k] + shift.y * matrixP[i][k + 1];\n                    if (notlast) {\n                        p = p + z * matrixP[i][k + 2];\n                        matrixP[i][k + 2] = matrixP[i][k + 2] - p * r;\n                    }\n                    matrixP[i][k] = matrixP[i][k] - p;\n                    matrixP[i][k + 1] = matrixP[i][k + 1] - p * q;\n                }\n            }  // (s != 0)\n        }  // k loop\n\n        // clean up pollution due to round-off errors\n        for (int i = im + 2; i <= iu; i++) {\n            matrixT[i][i-2] = 0.0;\n            if (i > im + 2) {\n                matrixT[i][i-3] = 0.0;\n            }\n        }\n    }",
          "21": "    private void performDoubleQRStep(final int il, final int im, final int iu,\n                                     final ShiftInfo shift, final double[] hVec) {\n\n        final int n = matrixT.length;\n        double p = hVec[0];\n        double q = hVec[1];\n        double r = hVec[2];\n\n        for (int k = im; k <= iu - 1; k++) {\n            boolean notlast = k != (iu - 1);\n            if (k != im) {\n                p = matrixT[k][k - 1];\n                q = matrixT[k + 1][k - 1];\n                r = notlast ? matrixT[k + 2][k - 1] : 0.0;\n                shift.x = FastMath.abs(p) + FastMath.abs(q) + FastMath.abs(r);\n                if (!Precision.equals(shift.x, 0.0, epsilon)) {\n                    p = p / shift.x;\n                    q = q / shift.x;\n                    r = r / shift.x;\n                }\n            }\n            if (shift.x == 0.0) {\n                break;\n            }\n            double s = FastMath.sqrt(p * p + q * q + r * r);\n            if (p < 0.0) {\n                s = -s;\n            }\n            if (s != 0.0) {\n                if (k != im) {\n                    matrixT[k][k - 1] = -s * shift.x;\n                } else if (il != im) {\nmatrixT[k].[(k - 1)] = matrixT[k];\n                }\n                p = p + s;\n                shift.x = p / s;\n                shift.y = q / s;\n                double z = r / s;\n                q = q / p;\n                r = r / p;\n\n                // Row modification\n                for (int j = k; j < n; j++) {\n                    p = matrixT[k][j] + q * matrixT[k + 1][j];\n                    if (notlast) {\n                        p = p + r * matrixT[k + 2][j];\n                        matrixT[k + 2][j] = matrixT[k + 2][j] - p * z;\n                    }\n                    matrixT[k][j] = matrixT[k][j] - p * shift.x;\n                    matrixT[k + 1][j] = matrixT[k + 1][j] - p * shift.y;\n                }\n\n                // Column modification\n                for (int i = 0; i <= FastMath.min(iu, k + 3); i++) {\n                    p = shift.x * matrixT[i][k] + shift.y * matrixT[i][k + 1];\n                    if (notlast) {\n                        p = p + z * matrixT[i][k + 2];\n                        matrixT[i][k + 2] = matrixT[i][k + 2] - p * r;\n                    }\n                    matrixT[i][k] = matrixT[i][k] - p;\n                    matrixT[i][k + 1] = matrixT[i][k + 1] - p * q;\n                }\n\n                // Accumulate transformations\n                final int high = matrixT.length - 1;\n                for (int i = 0; i <= high; i++) {\n                    p = shift.x * matrixP[i][k] + shift.y * matrixP[i][k + 1];\n                    if (notlast) {\n                        p = p + z * matrixP[i][k + 2];\n                        matrixP[i][k + 2] = matrixP[i][k + 2] - p * r;\n                    }\n                    matrixP[i][k] = matrixP[i][k] - p;\n                    matrixP[i][k + 1] = matrixP[i][k + 1] - p * q;\n                }\n            }  // (s != 0)\n        }  // k loop\n\n        // clean up pollution due to round-off errors\n        for (int i = im + 2; i <= iu; i++) {\n            matrixT[i][i-2] = 0.0;\n            if (i > im + 2) {\n                matrixT[i][i-3] = 0.0;\n            }\n        }\n    }",
          "22": "    private void performDoubleQRStep(final int il, final int im, final int iu,\n                                     final ShiftInfo shift, final double[] hVec) {\n\n        final int n = matrixT.length;\n        double p = hVec[0];\n        double q = hVec[1];\n        double r = hVec[2];\n\n        for (int k = im; k <= iu - 1; k++) {\n            boolean notlast = k != (iu - 1);\n            if (k != im) {\n                p = matrixT[k][k - 1];\n                q = matrixT[k + 1][k - 1];\n                r = notlast ? matrixT[k + 2][k - 1] : 0.0;\n                shift.x = FastMath.abs(p) + FastMath.abs(q) + FastMath.abs(r);\n                if (!Precision.equals(shift.x, 0.0, epsilon)) {\n                    p = p / shift.x;\n                    q = q / shift.x;\n                    r = r / shift.x;\n                }\n            }\n            if (shift.x == 0.0) {\n                break;\n            }\n            double s = FastMath.sqrt(p * p + q * q + r * r);\n            if (p < 0.0) {\n                s = -s;\n            }\n            if (s != 0.0) {\n                if (k != im) {\n                    matrixT[k][k - 1] = -s * shift.x;\n                } else if (il != im) {\nshift.y = matrixT[k].[(k - 1)];\n                }\n                p = p + s;\n                shift.x = p / s;\n                shift.y = q / s;\n                double z = r / s;\n                q = q / p;\n                r = r / p;\n\n                // Row modification\n                for (int j = k; j < n; j++) {\n                    p = matrixT[k][j] + q * matrixT[k + 1][j];\n                    if (notlast) {\n                        p = p + r * matrixT[k + 2][j];\n                        matrixT[k + 2][j] = matrixT[k + 2][j] - p * z;\n                    }\n                    matrixT[k][j] = matrixT[k][j] - p * shift.x;\n                    matrixT[k + 1][j] = matrixT[k + 1][j] - p * shift.y;\n                }\n\n                // Column modification\n                for (int i = 0; i <= FastMath.min(iu, k + 3); i++) {\n                    p = shift.x * matrixT[i][k] + shift.y * matrixT[i][k + 1];\n                    if (notlast) {\n                        p = p + z * matrixT[i][k + 2];\n                        matrixT[i][k + 2] = matrixT[i][k + 2] - p * r;\n                    }\n                    matrixT[i][k] = matrixT[i][k] - p;\n                    matrixT[i][k + 1] = matrixT[i][k + 1] - p * q;\n                }\n\n                // Accumulate transformations\n                final int high = matrixT.length - 1;\n                for (int i = 0; i <= high; i++) {\n                    p = shift.x * matrixP[i][k] + shift.y * matrixP[i][k + 1];\n                    if (notlast) {\n                        p = p + z * matrixP[i][k + 2];\n                        matrixP[i][k + 2] = matrixP[i][k + 2] - p * r;\n                    }\n                    matrixP[i][k] = matrixP[i][k] - p;\n                    matrixP[i][k + 1] = matrixP[i][k + 1] - p * q;\n                }\n            }  // (s != 0)\n        }  // k loop\n\n        // clean up pollution due to round-off errors\n        for (int i = im + 2; i <= iu; i++) {\n            matrixT[i][i-2] = 0.0;\n            if (i > im + 2) {\n                matrixT[i][i-3] = 0.0;\n            }\n        }\n    }",
          "23": "    private void performDoubleQRStep(final int il, final int im, final int iu,\n                                     final ShiftInfo shift, final double[] hVec) {\n\n        final int n = matrixT.length;\n        double p = hVec[0];\n        double q = hVec[1];\n        double r = hVec[2];\n\n        for (int k = im; k <= iu - 1; k++) {\n            boolean notlast = k != (iu - 1);\n            if (k != im) {\n                p = matrixT[k][k - 1];\n                q = matrixT[k + 1][k - 1];\n                r = notlast ? matrixT[k + 2][k - 1] : 0.0;\n                shift.x = FastMath.abs(p) + FastMath.abs(q) + FastMath.abs(r);\n                if (!Precision.equals(shift.x, 0.0, epsilon)) {\n                    p = p / shift.x;\n                    q = q / shift.x;\n                    r = r / shift.x;\n                }\n            }\n            if (shift.x == 0.0) {\n                break;\n            }\n            double s = FastMath.sqrt(p * p + q * q + r * r);\n            if (p < 0.0) {\n                s = -s;\n            }\n            if (s != 0.0) {\n                if (k != im) {\n                    matrixT[k][k - 1] = -s * shift.x;\n                } else if (il != im) {\np = (p + s);\n                }\n                p = p + s;\n                shift.x = p / s;\n                shift.y = q / s;\n                double z = r / s;\n                q = q / p;\n                r = r / p;\n\n                // Row modification\n                for (int j = k; j < n; j++) {\n                    p = matrixT[k][j] + q * matrixT[k + 1][j];\n                    if (notlast) {\n                        p = p + r * matrixT[k + 2][j];\n                        matrixT[k + 2][j] = matrixT[k + 2][j] - p * z;\n                    }\n                    matrixT[k][j] = matrixT[k][j] - p * shift.x;\n                    matrixT[k + 1][j] = matrixT[k + 1][j] - p * shift.y;\n                }\n\n                // Column modification\n                for (int i = 0; i <= FastMath.min(iu, k + 3); i++) {\n                    p = shift.x * matrixT[i][k] + shift.y * matrixT[i][k + 1];\n                    if (notlast) {\n                        p = p + z * matrixT[i][k + 2];\n                        matrixT[i][k + 2] = matrixT[i][k + 2] - p * r;\n                    }\n                    matrixT[i][k] = matrixT[i][k] - p;\n                    matrixT[i][k + 1] = matrixT[i][k + 1] - p * q;\n                }\n\n                // Accumulate transformations\n                final int high = matrixT.length - 1;\n                for (int i = 0; i <= high; i++) {\n                    p = shift.x * matrixP[i][k] + shift.y * matrixP[i][k + 1];\n                    if (notlast) {\n                        p = p + z * matrixP[i][k + 2];\n                        matrixP[i][k + 2] = matrixP[i][k + 2] - p * r;\n                    }\n                    matrixP[i][k] = matrixP[i][k] - p;\n                    matrixP[i][k + 1] = matrixP[i][k + 1] - p * q;\n                }\n            }  // (s != 0)\n        }  // k loop\n\n        // clean up pollution due to round-off errors\n        for (int i = im + 2; i <= iu; i++) {\n            matrixT[i][i-2] = 0.0;\n            if (i > im + 2) {\n                matrixT[i][i-3] = 0.0;\n            }\n        }\n    }",
          "24": "    private void performDoubleQRStep(final int il, final int im, final int iu,\n                                     final ShiftInfo shift, final double[] hVec) {\n\n        final int n = matrixT.length;\n        double p = hVec[0];\n        double q = hVec[1];\n        double r = hVec[2];\n\n        for (int k = im; k <= iu - 1; k++) {\n            boolean notlast = k != (iu - 1);\n            if (k != im) {\n                p = matrixT[k][k - 1];\n                q = matrixT[k + 1][k - 1];\n                r = notlast ? matrixT[k + 2][k - 1] : 0.0;\n                shift.x = FastMath.abs(p) + FastMath.abs(q) + FastMath.abs(r);\n                if (!Precision.equals(shift.x, 0.0, epsilon)) {\n                    p = p / shift.x;\n                    q = q / shift.x;\n                    r = r / shift.x;\n                }\n            }\n            if (shift.x == 0.0) {\n                break;\n            }\n            double s = FastMath.sqrt(p * p + q * q + r * r);\n            if (p < 0.0) {\n                s = -s;\n            }\n            if (s != 0.0) {\n                if (k != im) {\n                    matrixT[k][k - 1] = -s * shift.x;\n                } else if (il != im) {\nif((il != im)){\n}\n                    matrixT[k][k - 1] = +matrixT[k][k - 1];                }\n                p = p + s;\n                shift.x = p / s;\n                shift.y = q / s;\n                double z = r / s;\n                q = q / p;\n                r = r / p;\n\n                // Row modification\n                for (int j = k; j < n; j++) {\n                    p = matrixT[k][j] + q * matrixT[k + 1][j];\n                    if (notlast) {\n                        p = p + r * matrixT[k + 2][j];\n                        matrixT[k + 2][j] = matrixT[k + 2][j] - p * z;\n                    }\n                    matrixT[k][j] = matrixT[k][j] - p * shift.x;\n                    matrixT[k + 1][j] = matrixT[k + 1][j] - p * shift.y;\n                }\n\n                // Column modification\n                for (int i = 0; i <= FastMath.min(iu, k + 3); i++) {\n                    p = shift.x * matrixT[i][k] + shift.y * matrixT[i][k + 1];\n                    if (notlast) {\n                        p = p + z * matrixT[i][k + 2];\n                        matrixT[i][k + 2] = matrixT[i][k + 2] - p * r;\n                    }\n                    matrixT[i][k] = matrixT[i][k] - p;\n                    matrixT[i][k + 1] = matrixT[i][k + 1] - p * q;\n                }\n\n                // Accumulate transformations\n                final int high = matrixT.length - 1;\n                for (int i = 0; i <= high; i++) {\n                    p = shift.x * matrixP[i][k] + shift.y * matrixP[i][k + 1];\n                    if (notlast) {\n                        p = p + z * matrixP[i][k + 2];\n                        matrixP[i][k + 2] = matrixP[i][k + 2] - p * r;\n                    }\n                    matrixP[i][k] = matrixP[i][k] - p;\n                    matrixP[i][k + 1] = matrixP[i][k + 1] - p * q;\n                }\n            }  // (s != 0)\n        }  // k loop\n\n        // clean up pollution due to round-off errors\n        for (int i = im + 2; i <= iu; i++) {\n            matrixT[i][i-2] = 0.0;\n            if (i > im + 2) {\n                matrixT[i][i-3] = 0.0;\n            }\n        }\n    }",
          "25": "    private void performDoubleQRStep(final int il, final int im, final int iu,\n                                     final ShiftInfo shift, final double[] hVec) {\n\n        final int n = matrixT.length;\n        double p = hVec[0];\n        double q = hVec[1];\n        double r = hVec[2];\n\n        for (int k = im; k <= iu - 1; k++) {\n            boolean notlast = k != (iu - 1);\n            if (k != im) {\n                p = matrixT[k][k - 1];\n                q = matrixT[k + 1][k - 1];\n                r = notlast ? matrixT[k + 2][k - 1] : 0.0;\n                shift.x = FastMath.abs(p) + FastMath.abs(q) + FastMath.abs(r);\n                if (!Precision.equals(shift.x, 0.0, epsilon)) {\n                    p = p / shift.x;\n                    q = q / shift.x;\n                    r = r / shift.x;\n                }\n            }\n            if (shift.x == 0.0) {\n                break;\n            }\n            double s = FastMath.sqrt(p * p + q * q + r * r);\n            if (p < 0.0) {\n                s = -s;\n            }\n            if (s != 0.0) {\n                if (k != im) {\n                    matrixT[k][k - 1] = -s * shift.x;\n                } else if (il != im) {\np = (p + s);\n                    matrixT[k][k - 1] = +matrixT[k][k - 1];                }\n                p = p + s;\n                shift.x = p / s;\n                shift.y = q / s;\n                double z = r / s;\n                q = q / p;\n                r = r / p;\n\n                // Row modification\n                for (int j = k; j < n; j++) {\n                    p = matrixT[k][j] + q * matrixT[k + 1][j];\n                    if (notlast) {\n                        p = p + r * matrixT[k + 2][j];\n                        matrixT[k + 2][j] = matrixT[k + 2][j] - p * z;\n                    }\n                    matrixT[k][j] = matrixT[k][j] - p * shift.x;\n                    matrixT[k + 1][j] = matrixT[k + 1][j] - p * shift.y;\n                }\n\n                // Column modification\n                for (int i = 0; i <= FastMath.min(iu, k + 3); i++) {\n                    p = shift.x * matrixT[i][k] + shift.y * matrixT[i][k + 1];\n                    if (notlast) {\n                        p = p + z * matrixT[i][k + 2];\n                        matrixT[i][k + 2] = matrixT[i][k + 2] - p * r;\n                    }\n                    matrixT[i][k] = matrixT[i][k] - p;\n                    matrixT[i][k + 1] = matrixT[i][k + 1] - p * q;\n                }\n\n                // Accumulate transformations\n                final int high = matrixT.length - 1;\n                for (int i = 0; i <= high; i++) {\n                    p = shift.x * matrixP[i][k] + shift.y * matrixP[i][k + 1];\n                    if (notlast) {\n                        p = p + z * matrixP[i][k + 2];\n                        matrixP[i][k + 2] = matrixP[i][k + 2] - p * r;\n                    }\n                    matrixP[i][k] = matrixP[i][k] - p;\n                    matrixP[i][k + 1] = matrixP[i][k + 1] - p * q;\n                }\n            }  // (s != 0)\n        }  // k loop\n\n        // clean up pollution due to round-off errors\n        for (int i = im + 2; i <= iu; i++) {\n            matrixT[i][i-2] = 0.0;\n            if (i > im + 2) {\n                matrixT[i][i-3] = 0.0;\n            }\n        }\n    }",
          "26": "    private void performDoubleQRStep(final int il, final int im, final int iu,\n                                     final ShiftInfo shift, final double[] hVec) {\n\n        final int n = matrixT.length;\n        double p = hVec[0];\n        double q = hVec[1];\n        double r = hVec[2];\n\n        for (int k = im; k <= iu - 1; k++) {\n            boolean notlast = k != (iu - 1);\n            if (k != im) {\n                p = matrixT[k][k - 1];\n                q = matrixT[k + 1][k - 1];\n                r = notlast ? matrixT[k + 2][k - 1] : 0.0;\n                shift.x = FastMath.abs(p) + FastMath.abs(q) + FastMath.abs(r);\n                if (!Precision.equals(shift.x, 0.0, epsilon)) {\n                    p = p / shift.x;\n                    q = q / shift.x;\n                    r = r / shift.x;\n                }\n            }\n            if (shift.x == 0.0) {\n                break;\n            }\n            double s = FastMath.sqrt(p * p + q * q + r * r);\n            if (p < 0.0) {\n                s = -s;\n            }\n            if (s != 0.0) {\n                if (k != im) {\n                    matrixT[k][k - 1] = -s * shift.x;\n                } else if (il != im) {\nmatrixT[k].[(k - 1)] = +matrixT[k].[(k - 1)];\n                }\n                p = p + s;\n                shift.x = p / s;\n                shift.y = q / s;\n                double z = r / s;\n                q = q / p;\n                r = r / p;\n\n                // Row modification\n                for (int j = k; j < n; j++) {\n                    p = matrixT[k][j] + q * matrixT[k + 1][j];\n                    if (notlast) {\n                        p = p + r * matrixT[k + 2][j];\n                        matrixT[k + 2][j] = matrixT[k + 2][j] - p * z;\n                    }\n                    matrixT[k][j] = matrixT[k][j] - p * shift.x;\n                    matrixT[k + 1][j] = matrixT[k + 1][j] - p * shift.y;\n                }\n\n                // Column modification\n                for (int i = 0; i <= FastMath.min(iu, k + 3); i++) {\n                    p = shift.x * matrixT[i][k] + shift.y * matrixT[i][k + 1];\n                    if (notlast) {\n                        p = p + z * matrixT[i][k + 2];\n                        matrixT[i][k + 2] = matrixT[i][k + 2] - p * r;\n                    }\n                    matrixT[i][k] = matrixT[i][k] - p;\n                    matrixT[i][k + 1] = matrixT[i][k + 1] - p * q;\n                }\n\n                // Accumulate transformations\n                final int high = matrixT.length - 1;\n                for (int i = 0; i <= high; i++) {\n                    p = shift.x * matrixP[i][k] + shift.y * matrixP[i][k + 1];\n                    if (notlast) {\n                        p = p + z * matrixP[i][k + 2];\n                        matrixP[i][k + 2] = matrixP[i][k + 2] - p * r;\n                    }\n                    matrixP[i][k] = matrixP[i][k] - p;\n                    matrixP[i][k + 1] = matrixP[i][k + 1] - p * q;\n                }\n            }  // (s != 0)\n        }  // k loop\n\n        // clean up pollution due to round-off errors\n        for (int i = im + 2; i <= iu; i++) {\n            matrixT[i][i-2] = 0.0;\n            if (i > im + 2) {\n                matrixT[i][i-3] = 0.0;\n            }\n        }\n    }",
          "27": "    private void performDoubleQRStep(final int il, final int im, final int iu,\n                                     final ShiftInfo shift, final double[] hVec) {\n\n        final int n = matrixT.length;\n        double p = hVec[0];\n        double q = hVec[1];\n        double r = hVec[2];\n\n        for (int k = im; k <= iu - 1; k++) {\n            boolean notlast = k != (iu - 1);\n            if (k != im) {\n                p = matrixT[k][k - 1];\n                q = matrixT[k + 1][k - 1];\n                r = notlast ? matrixT[k + 2][k - 1] : 0.0;\n                shift.x = FastMath.abs(p) + FastMath.abs(q) + FastMath.abs(r);\n                if (!Precision.equals(shift.x, 0.0, epsilon)) {\n                    p = p / shift.x;\n                    q = q / shift.x;\n                    r = r / shift.x;\n                }\n            }\n            if (shift.x == 0.0) {\n                break;\n            }\n            double s = FastMath.sqrt(p * p + q * q + r * r);\n            if (p < 0.0) {\n                s = -s;\n            }\n            if (s != 0.0) {\n                if (k != im) {\n                    matrixT[k][k - 1] = -s * shift.x;\n                } else if (il != im) {\nmatrixT[k].[(k - 1)] = (-s * shift.x);\n}\n                    matrixT[k][k - 1] = +matrixT[k][k - 1];                }\n                p = p + s;\n                shift.x = p / s;\n                shift.y = q / s;\n                double z = r / s;\n                q = q / p;\n                r = r / p;\n\n                // Row modification\n                for (int j = k; j < n; j++) {\n                    p = matrixT[k][j] + q * matrixT[k + 1][j];\n                    if (notlast) {\n                        p = p + r * matrixT[k + 2][j];\n                        matrixT[k + 2][j] = matrixT[k + 2][j] - p * z;\n                    }\n                    matrixT[k][j] = matrixT[k][j] - p * shift.x;\n                    matrixT[k + 1][j] = matrixT[k + 1][j] - p * shift.y;\n                }\n\n                // Column modification\n                for (int i = 0; i <= FastMath.min(iu, k + 3); i++) {\n                    p = shift.x * matrixT[i][k] + shift.y * matrixT[i][k + 1];\n                    if (notlast) {\n                        p = p + z * matrixT[i][k + 2];\n                        matrixT[i][k + 2] = matrixT[i][k + 2] - p * r;\n                    }\n                    matrixT[i][k] = matrixT[i][k] - p;\n                    matrixT[i][k + 1] = matrixT[i][k + 1] - p * q;\n                }\n\n                // Accumulate transformations\n                final int high = matrixT.length - 1;\n                for (int i = 0; i <= high; i++) {\n                    p = shift.x * matrixP[i][k] + shift.y * matrixP[i][k + 1];\n                    if (notlast) {\n                        p = p + z * matrixP[i][k + 2];\n                        matrixP[i][k + 2] = matrixP[i][k + 2] - p * r;\n                    }\n                    matrixP[i][k] = matrixP[i][k] - p;\n                    matrixP[i][k + 1] = matrixP[i][k + 1] - p * q;\n                }\n            }  // (s != 0)\n        }  // k loop\n\n        // clean up pollution due to round-off errors\n        for (int i = im + 2; i <= iu; i++) {\n            matrixT[i][i-2] = 0.0;\n            if (i > im + 2) {\n                matrixT[i][i-3] = 0.0;\n            }\n        }\n    }",
          "28": "    private void performDoubleQRStep(final int il, final int im, final int iu,\n                                     final ShiftInfo shift, final double[] hVec) {\n\n        final int n = matrixT.length;\n        double p = hVec[0];\n        double q = hVec[1];\n        double r = hVec[2];\n\n        for (int k = im; k <= iu - 1; k++) {\n            boolean notlast = k != (iu - 1);\n            if (k != im) {\n                p = matrixT[k][k - 1];\n                q = matrixT[k + 1][k - 1];\n                r = notlast ? matrixT[k + 2][k - 1] : 0.0;\n                shift.x = FastMath.abs(p) + FastMath.abs(q) + FastMath.abs(r);\n                if (!Precision.equals(shift.x, 0.0, epsilon)) {\n                    p = p / shift.x;\n                    q = q / shift.x;\n                    r = r / shift.x;\n                }\n            }\n            if (shift.x == 0.0) {\n                break;\n            }\n            double s = FastMath.sqrt(p * p + q * q + r * r);\n            if (p < 0.0) {\n                s = -s;\n            }\n            if (s != 0.0) {\n                if (k != im) {\n                    matrixT[k][k - 1] = -s * shift.x;\n                } else if (il != im) {\nreturn;\n                }\n                p = p + s;\n                shift.x = p / s;\n                shift.y = q / s;\n                double z = r / s;\n                q = q / p;\n                r = r / p;\n\n                // Row modification\n                for (int j = k; j < n; j++) {\n                    p = matrixT[k][j] + q * matrixT[k + 1][j];\n                    if (notlast) {\n                        p = p + r * matrixT[k + 2][j];\n                        matrixT[k + 2][j] = matrixT[k + 2][j] - p * z;\n                    }\n                    matrixT[k][j] = matrixT[k][j] - p * shift.x;\n                    matrixT[k + 1][j] = matrixT[k + 1][j] - p * shift.y;\n                }\n\n                // Column modification\n                for (int i = 0; i <= FastMath.min(iu, k + 3); i++) {\n                    p = shift.x * matrixT[i][k] + shift.y * matrixT[i][k + 1];\n                    if (notlast) {\n                        p = p + z * matrixT[i][k + 2];\n                        matrixT[i][k + 2] = matrixT[i][k + 2] - p * r;\n                    }\n                    matrixT[i][k] = matrixT[i][k] - p;\n                    matrixT[i][k + 1] = matrixT[i][k + 1] - p * q;\n                }\n\n                // Accumulate transformations\n                final int high = matrixT.length - 1;\n                for (int i = 0; i <= high; i++) {\n                    p = shift.x * matrixP[i][k] + shift.y * matrixP[i][k + 1];\n                    if (notlast) {\n                        p = p + z * matrixP[i][k + 2];\n                        matrixP[i][k + 2] = matrixP[i][k + 2] - p * r;\n                    }\n                    matrixP[i][k] = matrixP[i][k] - p;\n                    matrixP[i][k + 1] = matrixP[i][k + 1] - p * q;\n                }\n            }  // (s != 0)\n        }  // k loop\n\n        // clean up pollution due to round-off errors\n        for (int i = im + 2; i <= iu; i++) {\n            matrixT[i][i-2] = 0.0;\n            if (i > im + 2) {\n                matrixT[i][i-3] = 0.0;\n            }\n        }\n    }",
          "29": "    private void performDoubleQRStep(final int il, final int im, final int iu,\n                                     final ShiftInfo shift, final double[] hVec) {\n\n        final int n = matrixT.length;\n        double p = hVec[0];\n        double q = hVec[1];\n        double r = hVec[2];\n\n        for (int k = im; k <= iu - 1; k++) {\n            boolean notlast = k != (iu - 1);\n            if (k != im) {\n                p = matrixT[k][k - 1];\n                q = matrixT[k + 1][k - 1];\n                r = notlast ? matrixT[k + 2][k - 1] : 0.0;\n                shift.x = FastMath.abs(p) + FastMath.abs(q) + FastMath.abs(r);\n                if (!Precision.equals(shift.x, 0.0, epsilon)) {\n                    p = p / shift.x;\n                    q = q / shift.x;\n                    r = r / shift.x;\n                }\n            }\n            if (shift.x == 0.0) {\n                break;\n            }\n            double s = FastMath.sqrt(p * p + q * q + r * r);\n            if (p < 0.0) {\n                s = -s;\n            }\n            if (s != 0.0) {\n                if (k != im) {\n                    matrixT[k][k - 1] = -s * shift.x;\n                } else if (il != im) {\nshift.x = matrixT[k].[(k - 1)];\n                }\n                p = p + s;\n                shift.x = p / s;\n                shift.y = q / s;\n                double z = r / s;\n                q = q / p;\n                r = r / p;\n\n                // Row modification\n                for (int j = k; j < n; j++) {\n                    p = matrixT[k][j] + q * matrixT[k + 1][j];\n                    if (notlast) {\n                        p = p + r * matrixT[k + 2][j];\n                        matrixT[k + 2][j] = matrixT[k + 2][j] - p * z;\n                    }\n                    matrixT[k][j] = matrixT[k][j] - p * shift.x;\n                    matrixT[k + 1][j] = matrixT[k + 1][j] - p * shift.y;\n                }\n\n                // Column modification\n                for (int i = 0; i <= FastMath.min(iu, k + 3); i++) {\n                    p = shift.x * matrixT[i][k] + shift.y * matrixT[i][k + 1];\n                    if (notlast) {\n                        p = p + z * matrixT[i][k + 2];\n                        matrixT[i][k + 2] = matrixT[i][k + 2] - p * r;\n                    }\n                    matrixT[i][k] = matrixT[i][k] - p;\n                    matrixT[i][k + 1] = matrixT[i][k + 1] - p * q;\n                }\n\n                // Accumulate transformations\n                final int high = matrixT.length - 1;\n                for (int i = 0; i <= high; i++) {\n                    p = shift.x * matrixP[i][k] + shift.y * matrixP[i][k + 1];\n                    if (notlast) {\n                        p = p + z * matrixP[i][k + 2];\n                        matrixP[i][k + 2] = matrixP[i][k + 2] - p * r;\n                    }\n                    matrixP[i][k] = matrixP[i][k] - p;\n                    matrixP[i][k + 1] = matrixP[i][k + 1] - p * q;\n                }\n            }  // (s != 0)\n        }  // k loop\n\n        // clean up pollution due to round-off errors\n        for (int i = im + 2; i <= iu; i++) {\n            matrixT[i][i-2] = 0.0;\n            if (i > im + 2) {\n                matrixT[i][i-3] = 0.0;\n            }\n        }\n    }",
          "30": "    private void performDoubleQRStep(final int il, final int im, final int iu,\n                                     final ShiftInfo shift, final double[] hVec) {\n\n        final int n = matrixT.length;\n        double p = hVec[0];\n        double q = hVec[1];\n        double r = hVec[2];\n\n        for (int k = im; k <= iu - 1; k++) {\n            boolean notlast = k != (iu - 1);\n            if (k != im) {\n                p = matrixT[k][k - 1];\n                q = matrixT[k + 1][k - 1];\n                r = notlast ? matrixT[k + 2][k - 1] : 0.0;\n                shift.x = FastMath.abs(p) + FastMath.abs(q) + FastMath.abs(r);\n                if (!Precision.equals(shift.x, 0.0, epsilon)) {\n                    p = p / shift.x;\n                    q = q / shift.x;\n                    r = r / shift.x;\n                }\n            }\n            if (shift.x == 0.0) {\n                break;\n            }\n            double s = FastMath.sqrt(p * p + q * q + r * r);\n            if (p < 0.0) {\n                s = -s;\n            }\n            if (s != 0.0) {\n                if (k != im) {\n                    matrixT[k][k - 1] = -s * shift.x;\n                } else if (il != im) {\nbreak;\n                    matrixT[k][k - 1] = +matrixT[k][k - 1];                }\n                p = p + s;\n                shift.x = p / s;\n                shift.y = q / s;\n                double z = r / s;\n                q = q / p;\n                r = r / p;\n\n                // Row modification\n                for (int j = k; j < n; j++) {\n                    p = matrixT[k][j] + q * matrixT[k + 1][j];\n                    if (notlast) {\n                        p = p + r * matrixT[k + 2][j];\n                        matrixT[k + 2][j] = matrixT[k + 2][j] - p * z;\n                    }\n                    matrixT[k][j] = matrixT[k][j] - p * shift.x;\n                    matrixT[k + 1][j] = matrixT[k + 1][j] - p * shift.y;\n                }\n\n                // Column modification\n                for (int i = 0; i <= FastMath.min(iu, k + 3); i++) {\n                    p = shift.x * matrixT[i][k] + shift.y * matrixT[i][k + 1];\n                    if (notlast) {\n                        p = p + z * matrixT[i][k + 2];\n                        matrixT[i][k + 2] = matrixT[i][k + 2] - p * r;\n                    }\n                    matrixT[i][k] = matrixT[i][k] - p;\n                    matrixT[i][k + 1] = matrixT[i][k + 1] - p * q;\n                }\n\n                // Accumulate transformations\n                final int high = matrixT.length - 1;\n                for (int i = 0; i <= high; i++) {\n                    p = shift.x * matrixP[i][k] + shift.y * matrixP[i][k + 1];\n                    if (notlast) {\n                        p = p + z * matrixP[i][k + 2];\n                        matrixP[i][k + 2] = matrixP[i][k + 2] - p * r;\n                    }\n                    matrixP[i][k] = matrixP[i][k] - p;\n                    matrixP[i][k + 1] = matrixP[i][k + 1] - p * q;\n                }\n            }  // (s != 0)\n        }  // k loop\n\n        // clean up pollution due to round-off errors\n        for (int i = im + 2; i <= iu; i++) {\n            matrixT[i][i-2] = 0.0;\n            if (i > im + 2) {\n                matrixT[i][i-3] = 0.0;\n            }\n        }\n    }",
          "31": "    private void performDoubleQRStep(final int il, final int im, final int iu,\n                                     final ShiftInfo shift, final double[] hVec) {\n\n        final int n = matrixT.length;\n        double p = hVec[0];\n        double q = hVec[1];\n        double r = hVec[2];\n\n        for (int k = im; k <= iu - 1; k++) {\n            boolean notlast = k != (iu - 1);\n            if (k != im) {\n                p = matrixT[k][k - 1];\n                q = matrixT[k + 1][k - 1];\n                r = notlast ? matrixT[k + 2][k - 1] : 0.0;\n                shift.x = FastMath.abs(p) + FastMath.abs(q) + FastMath.abs(r);\n                if (!Precision.equals(shift.x, 0.0, epsilon)) {\n                    p = p / shift.x;\n                    q = q / shift.x;\n                    r = r / shift.x;\n                }\n            }\n            if (shift.x == 0.0) {\n                break;\n            }\n            double s = FastMath.sqrt(p * p + q * q + r * r);\n            if (p < 0.0) {\n                s = -s;\n            }\n            if (s != 0.0) {\n                if (k != im) {\n                    matrixT[k][k - 1] = -s * shift.x;\n                } else if (il != im) {\nreturn;\n                    matrixT[k][k - 1] = +matrixT[k][k - 1];                }\n                p = p + s;\n                shift.x = p / s;\n                shift.y = q / s;\n                double z = r / s;\n                q = q / p;\n                r = r / p;\n\n                // Row modification\n                for (int j = k; j < n; j++) {\n                    p = matrixT[k][j] + q * matrixT[k + 1][j];\n                    if (notlast) {\n                        p = p + r * matrixT[k + 2][j];\n                        matrixT[k + 2][j] = matrixT[k + 2][j] - p * z;\n                    }\n                    matrixT[k][j] = matrixT[k][j] - p * shift.x;\n                    matrixT[k + 1][j] = matrixT[k + 1][j] - p * shift.y;\n                }\n\n                // Column modification\n                for (int i = 0; i <= FastMath.min(iu, k + 3); i++) {\n                    p = shift.x * matrixT[i][k] + shift.y * matrixT[i][k + 1];\n                    if (notlast) {\n                        p = p + z * matrixT[i][k + 2];\n                        matrixT[i][k + 2] = matrixT[i][k + 2] - p * r;\n                    }\n                    matrixT[i][k] = matrixT[i][k] - p;\n                    matrixT[i][k + 1] = matrixT[i][k + 1] - p * q;\n                }\n\n                // Accumulate transformations\n                final int high = matrixT.length - 1;\n                for (int i = 0; i <= high; i++) {\n                    p = shift.x * matrixP[i][k] + shift.y * matrixP[i][k + 1];\n                    if (notlast) {\n                        p = p + z * matrixP[i][k + 2];\n                        matrixP[i][k + 2] = matrixP[i][k + 2] - p * r;\n                    }\n                    matrixP[i][k] = matrixP[i][k] - p;\n                    matrixP[i][k + 1] = matrixP[i][k + 1] - p * q;\n                }\n            }  // (s != 0)\n        }  // k loop\n\n        // clean up pollution due to round-off errors\n        for (int i = im + 2; i <= iu; i++) {\n            matrixT[i][i-2] = 0.0;\n            if (i > im + 2) {\n                matrixT[i][i-3] = 0.0;\n            }\n        }\n    }",
          "32": "    private void performDoubleQRStep(final int il, final int im, final int iu,\n                                     final ShiftInfo shift, final double[] hVec) {\n\n        final int n = matrixT.length;\n        double p = hVec[0];\n        double q = hVec[1];\n        double r = hVec[2];\n\n        for (int k = im; k <= iu - 1; k++) {\n            boolean notlast = k != (iu - 1);\n            if (k != im) {\n                p = matrixT[k][k - 1];\n                q = matrixT[k + 1][k - 1];\n                r = notlast ? matrixT[k + 2][k - 1] : 0.0;\n                shift.x = FastMath.abs(p) + FastMath.abs(q) + FastMath.abs(r);\n                if (!Precision.equals(shift.x, 0.0, epsilon)) {\n                    p = p / shift.x;\n                    q = q / shift.x;\n                    r = r / shift.x;\n                }\n            }\n            if (shift.x == 0.0) {\n                break;\n            }\n            double s = FastMath.sqrt(p * p + q * q + r * r);\n            if (p < 0.0) {\n                s = -s;\n            }\n            if (s != 0.0) {\n                if (k != im) {\n                    matrixT[k][k - 1] = -s * shift.x;\n                } else if (il != im) {\nmatrixT[k].[(k - 1)] = (k - 1);\n                }\n                p = p + s;\n                shift.x = p / s;\n                shift.y = q / s;\n                double z = r / s;\n                q = q / p;\n                r = r / p;\n\n                // Row modification\n                for (int j = k; j < n; j++) {\n                    p = matrixT[k][j] + q * matrixT[k + 1][j];\n                    if (notlast) {\n                        p = p + r * matrixT[k + 2][j];\n                        matrixT[k + 2][j] = matrixT[k + 2][j] - p * z;\n                    }\n                    matrixT[k][j] = matrixT[k][j] - p * shift.x;\n                    matrixT[k + 1][j] = matrixT[k + 1][j] - p * shift.y;\n                }\n\n                // Column modification\n                for (int i = 0; i <= FastMath.min(iu, k + 3); i++) {\n                    p = shift.x * matrixT[i][k] + shift.y * matrixT[i][k + 1];\n                    if (notlast) {\n                        p = p + z * matrixT[i][k + 2];\n                        matrixT[i][k + 2] = matrixT[i][k + 2] - p * r;\n                    }\n                    matrixT[i][k] = matrixT[i][k] - p;\n                    matrixT[i][k + 1] = matrixT[i][k + 1] - p * q;\n                }\n\n                // Accumulate transformations\n                final int high = matrixT.length - 1;\n                for (int i = 0; i <= high; i++) {\n                    p = shift.x * matrixP[i][k] + shift.y * matrixP[i][k + 1];\n                    if (notlast) {\n                        p = p + z * matrixP[i][k + 2];\n                        matrixP[i][k + 2] = matrixP[i][k + 2] - p * r;\n                    }\n                    matrixP[i][k] = matrixP[i][k] - p;\n                    matrixP[i][k + 1] = matrixP[i][k + 1] - p * q;\n                }\n            }  // (s != 0)\n        }  // k loop\n\n        // clean up pollution due to round-off errors\n        for (int i = im + 2; i <= iu; i++) {\n            matrixT[i][i-2] = 0.0;\n            if (i > im + 2) {\n                matrixT[i][i-3] = 0.0;\n            }\n        }\n    }",
          "33": "    private void performDoubleQRStep(final int il, final int im, final int iu,\n                                     final ShiftInfo shift, final double[] hVec) {\n\n        final int n = matrixT.length;\n        double p = hVec[0];\n        double q = hVec[1];\n        double r = hVec[2];\n\n        for (int k = im; k <= iu - 1; k++) {\n            boolean notlast = k != (iu - 1);\n            if (k != im) {\n                p = matrixT[k][k - 1];\n                q = matrixT[k + 1][k - 1];\n                r = notlast ? matrixT[k + 2][k - 1] : 0.0;\n                shift.x = FastMath.abs(p) + FastMath.abs(q) + FastMath.abs(r);\n                if (!Precision.equals(shift.x, 0.0, epsilon)) {\n                    p = p / shift.x;\n                    q = q / shift.x;\n                    r = r / shift.x;\n                }\n            }\n            if (shift.x == 0.0) {\n                break;\n            }\n            double s = FastMath.sqrt(p * p + q * q + r * r);\n            if (p < 0.0) {\n                s = -s;\n            }\n            if (s != 0.0) {\n                if (k != im) {\n                    matrixT[k][k - 1] = -s * shift.x;\n                } else if (il != im) {\np = (k - 1);\n                }\n                p = p + s;\n                shift.x = p / s;\n                shift.y = q / s;\n                double z = r / s;\n                q = q / p;\n                r = r / p;\n\n                // Row modification\n                for (int j = k; j < n; j++) {\n                    p = matrixT[k][j] + q * matrixT[k + 1][j];\n                    if (notlast) {\n                        p = p + r * matrixT[k + 2][j];\n                        matrixT[k + 2][j] = matrixT[k + 2][j] - p * z;\n                    }\n                    matrixT[k][j] = matrixT[k][j] - p * shift.x;\n                    matrixT[k + 1][j] = matrixT[k + 1][j] - p * shift.y;\n                }\n\n                // Column modification\n                for (int i = 0; i <= FastMath.min(iu, k + 3); i++) {\n                    p = shift.x * matrixT[i][k] + shift.y * matrixT[i][k + 1];\n                    if (notlast) {\n                        p = p + z * matrixT[i][k + 2];\n                        matrixT[i][k + 2] = matrixT[i][k + 2] - p * r;\n                    }\n                    matrixT[i][k] = matrixT[i][k] - p;\n                    matrixT[i][k + 1] = matrixT[i][k + 1] - p * q;\n                }\n\n                // Accumulate transformations\n                final int high = matrixT.length - 1;\n                for (int i = 0; i <= high; i++) {\n                    p = shift.x * matrixP[i][k] + shift.y * matrixP[i][k + 1];\n                    if (notlast) {\n                        p = p + z * matrixP[i][k + 2];\n                        matrixP[i][k + 2] = matrixP[i][k + 2] - p * r;\n                    }\n                    matrixP[i][k] = matrixP[i][k] - p;\n                    matrixP[i][k + 1] = matrixP[i][k + 1] - p * q;\n                }\n            }  // (s != 0)\n        }  // k loop\n\n        // clean up pollution due to round-off errors\n        for (int i = im + 2; i <= iu; i++) {\n            matrixT[i][i-2] = 0.0;\n            if (i > im + 2) {\n                matrixT[i][i-3] = 0.0;\n            }\n        }\n    }",
          "34": "    private void performDoubleQRStep(final int il, final int im, final int iu,\n                                     final ShiftInfo shift, final double[] hVec) {\n\n        final int n = matrixT.length;\n        double p = hVec[0];\n        double q = hVec[1];\n        double r = hVec[2];\n\n        for (int k = im; k <= iu - 1; k++) {\n            boolean notlast = k != (iu - 1);\n            if (k != im) {\n                p = matrixT[k][k - 1];\n                q = matrixT[k + 1][k - 1];\n                r = notlast ? matrixT[k + 2][k - 1] : 0.0;\n                shift.x = FastMath.abs(p) + FastMath.abs(q) + FastMath.abs(r);\n                if (!Precision.equals(shift.x, 0.0, epsilon)) {\n                    p = p / shift.x;\n                    q = q / shift.x;\n                    r = r / shift.x;\n                }\n            }\n            if (shift.x == 0.0) {\n                break;\n            }\n            double s = FastMath.sqrt(p * p + q * q + r * r);\n            if (p < 0.0) {\n                s = -s;\n            }\n            if (s != 0.0) {\n                if (k != im) {\n                    matrixT[k][k - 1] = -s * shift.x;\n                } else if (il != im) {\nmatrixT[k].[(k - 1)] = p[k].[(k - 1)];\n                }\n                p = p + s;\n                shift.x = p / s;\n                shift.y = q / s;\n                double z = r / s;\n                q = q / p;\n                r = r / p;\n\n                // Row modification\n                for (int j = k; j < n; j++) {\n                    p = matrixT[k][j] + q * matrixT[k + 1][j];\n                    if (notlast) {\n                        p = p + r * matrixT[k + 2][j];\n                        matrixT[k + 2][j] = matrixT[k + 2][j] - p * z;\n                    }\n                    matrixT[k][j] = matrixT[k][j] - p * shift.x;\n                    matrixT[k + 1][j] = matrixT[k + 1][j] - p * shift.y;\n                }\n\n                // Column modification\n                for (int i = 0; i <= FastMath.min(iu, k + 3); i++) {\n                    p = shift.x * matrixT[i][k] + shift.y * matrixT[i][k + 1];\n                    if (notlast) {\n                        p = p + z * matrixT[i][k + 2];\n                        matrixT[i][k + 2] = matrixT[i][k + 2] - p * r;\n                    }\n                    matrixT[i][k] = matrixT[i][k] - p;\n                    matrixT[i][k + 1] = matrixT[i][k + 1] - p * q;\n                }\n\n                // Accumulate transformations\n                final int high = matrixT.length - 1;\n                for (int i = 0; i <= high; i++) {\n                    p = shift.x * matrixP[i][k] + shift.y * matrixP[i][k + 1];\n                    if (notlast) {\n                        p = p + z * matrixP[i][k + 2];\n                        matrixP[i][k + 2] = matrixP[i][k + 2] - p * r;\n                    }\n                    matrixP[i][k] = matrixP[i][k] - p;\n                    matrixP[i][k + 1] = matrixP[i][k + 1] - p * q;\n                }\n            }  // (s != 0)\n        }  // k loop\n\n        // clean up pollution due to round-off errors\n        for (int i = im + 2; i <= iu; i++) {\n            matrixT[i][i-2] = 0.0;\n            if (i > im + 2) {\n                matrixT[i][i-3] = 0.0;\n            }\n        }\n    }",
          "35": "    private void performDoubleQRStep(final int il, final int im, final int iu,\n                                     final ShiftInfo shift, final double[] hVec) {\n\n        final int n = matrixT.length;\n        double p = hVec[0];\n        double q = hVec[1];\n        double r = hVec[2];\n\n        for (int k = im; k <= iu - 1; k++) {\n            boolean notlast = k != (iu - 1);\n            if (k != im) {\n                p = matrixT[k][k - 1];\n                q = matrixT[k + 1][k - 1];\n                r = notlast ? matrixT[k + 2][k - 1] : 0.0;\n                shift.x = FastMath.abs(p) + FastMath.abs(q) + FastMath.abs(r);\n                if (!Precision.equals(shift.x, 0.0, epsilon)) {\n                    p = p / shift.x;\n                    q = q / shift.x;\n                    r = r / shift.x;\n                }\n            }\n            if (shift.x == 0.0) {\n                break;\n            }\n            double s = FastMath.sqrt(p * p + q * q + r * r);\n            if (p < 0.0) {\n                s = -s;\n            }\n            if (s != 0.0) {\n                if (k != im) {\n                    matrixT[k][k - 1] = -s * shift.x;\n                } else if (il != im) {\nq = (k - 1);\n                }\n                p = p + s;\n                shift.x = p / s;\n                shift.y = q / s;\n                double z = r / s;\n                q = q / p;\n                r = r / p;\n\n                // Row modification\n                for (int j = k; j < n; j++) {\n                    p = matrixT[k][j] + q * matrixT[k + 1][j];\n                    if (notlast) {\n                        p = p + r * matrixT[k + 2][j];\n                        matrixT[k + 2][j] = matrixT[k + 2][j] - p * z;\n                    }\n                    matrixT[k][j] = matrixT[k][j] - p * shift.x;\n                    matrixT[k + 1][j] = matrixT[k + 1][j] - p * shift.y;\n                }\n\n                // Column modification\n                for (int i = 0; i <= FastMath.min(iu, k + 3); i++) {\n                    p = shift.x * matrixT[i][k] + shift.y * matrixT[i][k + 1];\n                    if (notlast) {\n                        p = p + z * matrixT[i][k + 2];\n                        matrixT[i][k + 2] = matrixT[i][k + 2] - p * r;\n                    }\n                    matrixT[i][k] = matrixT[i][k] - p;\n                    matrixT[i][k + 1] = matrixT[i][k + 1] - p * q;\n                }\n\n                // Accumulate transformations\n                final int high = matrixT.length - 1;\n                for (int i = 0; i <= high; i++) {\n                    p = shift.x * matrixP[i][k] + shift.y * matrixP[i][k + 1];\n                    if (notlast) {\n                        p = p + z * matrixP[i][k + 2];\n                        matrixP[i][k + 2] = matrixP[i][k + 2] - p * r;\n                    }\n                    matrixP[i][k] = matrixP[i][k] - p;\n                    matrixP[i][k + 1] = matrixP[i][k + 1] - p * q;\n                }\n            }  // (s != 0)\n        }  // k loop\n\n        // clean up pollution due to round-off errors\n        for (int i = im + 2; i <= iu; i++) {\n            matrixT[i][i-2] = 0.0;\n            if (i > im + 2) {\n                matrixT[i][i-3] = 0.0;\n            }\n        }\n    }",
          "36": "    private void performDoubleQRStep(final int il, final int im, final int iu,\n                                     final ShiftInfo shift, final double[] hVec) {\n\n        final int n = matrixT.length;\n        double p = hVec[0];\n        double q = hVec[1];\n        double r = hVec[2];\n\n        for (int k = im; k <= iu - 1; k++) {\n            boolean notlast = k != (iu - 1);\n            if (k != im) {\n                p = matrixT[k][k - 1];\n                q = matrixT[k + 1][k - 1];\n                r = notlast ? matrixT[k + 2][k - 1] : 0.0;\n                shift.x = FastMath.abs(p) + FastMath.abs(q) + FastMath.abs(r);\n                if (!Precision.equals(shift.x, 0.0, epsilon)) {\n                    p = p / shift.x;\n                    q = q / shift.x;\n                    r = r / shift.x;\n                }\n            }\n            if (shift.x == 0.0) {\n                break;\n            }\n            double s = FastMath.sqrt(p * p + q * q + r * r);\n            if (p < 0.0) {\n                s = -s;\n            }\n            if (s != 0.0) {\n                if (k != im) {\n                    matrixT[k][k - 1] = -s * shift.x;\n                } else if (il != im) {\nr = (k - 1);\n                }\n                p = p + s;\n                shift.x = p / s;\n                shift.y = q / s;\n                double z = r / s;\n                q = q / p;\n                r = r / p;\n\n                // Row modification\n                for (int j = k; j < n; j++) {\n                    p = matrixT[k][j] + q * matrixT[k + 1][j];\n                    if (notlast) {\n                        p = p + r * matrixT[k + 2][j];\n                        matrixT[k + 2][j] = matrixT[k + 2][j] - p * z;\n                    }\n                    matrixT[k][j] = matrixT[k][j] - p * shift.x;\n                    matrixT[k + 1][j] = matrixT[k + 1][j] - p * shift.y;\n                }\n\n                // Column modification\n                for (int i = 0; i <= FastMath.min(iu, k + 3); i++) {\n                    p = shift.x * matrixT[i][k] + shift.y * matrixT[i][k + 1];\n                    if (notlast) {\n                        p = p + z * matrixT[i][k + 2];\n                        matrixT[i][k + 2] = matrixT[i][k + 2] - p * r;\n                    }\n                    matrixT[i][k] = matrixT[i][k] - p;\n                    matrixT[i][k + 1] = matrixT[i][k + 1] - p * q;\n                }\n\n                // Accumulate transformations\n                final int high = matrixT.length - 1;\n                for (int i = 0; i <= high; i++) {\n                    p = shift.x * matrixP[i][k] + shift.y * matrixP[i][k + 1];\n                    if (notlast) {\n                        p = p + z * matrixP[i][k + 2];\n                        matrixP[i][k + 2] = matrixP[i][k + 2] - p * r;\n                    }\n                    matrixP[i][k] = matrixP[i][k] - p;\n                    matrixP[i][k + 1] = matrixP[i][k + 1] - p * q;\n                }\n            }  // (s != 0)\n        }  // k loop\n\n        // clean up pollution due to round-off errors\n        for (int i = im + 2; i <= iu; i++) {\n            matrixT[i][i-2] = 0.0;\n            if (i > im + 2) {\n                matrixT[i][i-3] = 0.0;\n            }\n        }\n    }",
          "37": "    private void performDoubleQRStep(final int il, final int im, final int iu,\n                                     final ShiftInfo shift, final double[] hVec) {\n\n        final int n = matrixT.length;\n        double p = hVec[0];\n        double q = hVec[1];\n        double r = hVec[2];\n\n        for (int k = im; k <= iu - 1; k++) {\n            boolean notlast = k != (iu - 1);\n            if (k != im) {\n                p = matrixT[k][k - 1];\n                q = matrixT[k + 1][k - 1];\n                r = notlast ? matrixT[k + 2][k - 1] : 0.0;\n                shift.x = FastMath.abs(p) + FastMath.abs(q) + FastMath.abs(r);\n                if (!Precision.equals(shift.x, 0.0, epsilon)) {\n                    p = p / shift.x;\n                    q = q / shift.x;\n                    r = r / shift.x;\n                }\n            }\n            if (shift.x == 0.0) {\n                break;\n            }\n            double s = FastMath.sqrt(p * p + q * q + r * r);\n            if (p < 0.0) {\n                s = -s;\n            }\n            if (s != 0.0) {\n                if (k != im) {\n                    matrixT[k][k - 1] = -s * shift.x;\n                } else if (il != im) {\nif((k != im)){\n}\n                    matrixT[k][k - 1] = +matrixT[k][k - 1];                }\n                p = p + s;\n                shift.x = p / s;\n                shift.y = q / s;\n                double z = r / s;\n                q = q / p;\n                r = r / p;\n\n                // Row modification\n                for (int j = k; j < n; j++) {\n                    p = matrixT[k][j] + q * matrixT[k + 1][j];\n                    if (notlast) {\n                        p = p + r * matrixT[k + 2][j];\n                        matrixT[k + 2][j] = matrixT[k + 2][j] - p * z;\n                    }\n                    matrixT[k][j] = matrixT[k][j] - p * shift.x;\n                    matrixT[k + 1][j] = matrixT[k + 1][j] - p * shift.y;\n                }\n\n                // Column modification\n                for (int i = 0; i <= FastMath.min(iu, k + 3); i++) {\n                    p = shift.x * matrixT[i][k] + shift.y * matrixT[i][k + 1];\n                    if (notlast) {\n                        p = p + z * matrixT[i][k + 2];\n                        matrixT[i][k + 2] = matrixT[i][k + 2] - p * r;\n                    }\n                    matrixT[i][k] = matrixT[i][k] - p;\n                    matrixT[i][k + 1] = matrixT[i][k + 1] - p * q;\n                }\n\n                // Accumulate transformations\n                final int high = matrixT.length - 1;\n                for (int i = 0; i <= high; i++) {\n                    p = shift.x * matrixP[i][k] + shift.y * matrixP[i][k + 1];\n                    if (notlast) {\n                        p = p + z * matrixP[i][k + 2];\n                        matrixP[i][k + 2] = matrixP[i][k + 2] - p * r;\n                    }\n                    matrixP[i][k] = matrixP[i][k] - p;\n                    matrixP[i][k + 1] = matrixP[i][k + 1] - p * q;\n                }\n            }  // (s != 0)\n        }  // k loop\n\n        // clean up pollution due to round-off errors\n        for (int i = im + 2; i <= iu; i++) {\n            matrixT[i][i-2] = 0.0;\n            if (i > im + 2) {\n                matrixT[i][i-3] = 0.0;\n            }\n        }\n    }",
          "38": "    private void performDoubleQRStep(final int il, final int im, final int iu,\n                                     final ShiftInfo shift, final double[] hVec) {\n\n        final int n = matrixT.length;\n        double p = hVec[0];\n        double q = hVec[1];\n        double r = hVec[2];\n\n        for (int k = im; k <= iu - 1; k++) {\n            boolean notlast = k != (iu - 1);\n            if (k != im) {\n                p = matrixT[k][k - 1];\n                q = matrixT[k + 1][k - 1];\n                r = notlast ? matrixT[k + 2][k - 1] : 0.0;\n                shift.x = FastMath.abs(p) + FastMath.abs(q) + FastMath.abs(r);\n                if (!Precision.equals(shift.x, 0.0, epsilon)) {\n                    p = p / shift.x;\n                    q = q / shift.x;\n                    r = r / shift.x;\n                }\n            }\n            if (shift.x == 0.0) {\n                break;\n            }\n            double s = FastMath.sqrt(p * p + q * q + r * r);\n            if (p < 0.0) {\n                s = -s;\n            }\n            if (s != 0.0) {\n                if (k != im) {\n                    matrixT[k][k - 1] = -s * shift.x;\n                } else if (il != im) {\nmatrixT[k].[(k - 1)] = +matrixT[k].[(k - 0)];\n                }\n                p = p + s;\n                shift.x = p / s;\n                shift.y = q / s;\n                double z = r / s;\n                q = q / p;\n                r = r / p;\n\n                // Row modification\n                for (int j = k; j < n; j++) {\n                    p = matrixT[k][j] + q * matrixT[k + 1][j];\n                    if (notlast) {\n                        p = p + r * matrixT[k + 2][j];\n                        matrixT[k + 2][j] = matrixT[k + 2][j] - p * z;\n                    }\n                    matrixT[k][j] = matrixT[k][j] - p * shift.x;\n                    matrixT[k + 1][j] = matrixT[k + 1][j] - p * shift.y;\n                }\n\n                // Column modification\n                for (int i = 0; i <= FastMath.min(iu, k + 3); i++) {\n                    p = shift.x * matrixT[i][k] + shift.y * matrixT[i][k + 1];\n                    if (notlast) {\n                        p = p + z * matrixT[i][k + 2];\n                        matrixT[i][k + 2] = matrixT[i][k + 2] - p * r;\n                    }\n                    matrixT[i][k] = matrixT[i][k] - p;\n                    matrixT[i][k + 1] = matrixT[i][k + 1] - p * q;\n                }\n\n                // Accumulate transformations\n                final int high = matrixT.length - 1;\n                for (int i = 0; i <= high; i++) {\n                    p = shift.x * matrixP[i][k] + shift.y * matrixP[i][k + 1];\n                    if (notlast) {\n                        p = p + z * matrixP[i][k + 2];\n                        matrixP[i][k + 2] = matrixP[i][k + 2] - p * r;\n                    }\n                    matrixP[i][k] = matrixP[i][k] - p;\n                    matrixP[i][k + 1] = matrixP[i][k + 1] - p * q;\n                }\n            }  // (s != 0)\n        }  // k loop\n\n        // clean up pollution due to round-off errors\n        for (int i = im + 2; i <= iu; i++) {\n            matrixT[i][i-2] = 0.0;\n            if (i > im + 2) {\n                matrixT[i][i-3] = 0.0;\n            }\n        }\n    }",
          "39": "    private void performDoubleQRStep(final int il, final int im, final int iu,\n                                     final ShiftInfo shift, final double[] hVec) {\n\n        final int n = matrixT.length;\n        double p = hVec[0];\n        double q = hVec[1];\n        double r = hVec[2];\n\n        for (int k = im; k <= iu - 1; k++) {\n            boolean notlast = k != (iu - 1);\n            if (k != im) {\n                p = matrixT[k][k - 1];\n                q = matrixT[k + 1][k - 1];\n                r = notlast ? matrixT[k + 2][k - 1] : 0.0;\n                shift.x = FastMath.abs(p) + FastMath.abs(q) + FastMath.abs(r);\n                if (!Precision.equals(shift.x, 0.0, epsilon)) {\n                    p = p / shift.x;\n                    q = q / shift.x;\n                    r = r / shift.x;\n                }\n            }\n            if (shift.x == 0.0) {\n                break;\n            }\n            double s = FastMath.sqrt(p * p + q * q + r * r);\n            if (p < 0.0) {\n                s = -s;\n            }\n            if (s != 0.0) {\n                if (k != im) {\n                    matrixT[k][k - 1] = -s * shift.x;\n                } else if (il != im) {\nmatrixT[k].[(k - 1)] = +matrixT[k].[(k + 1)];\n                }\n                p = p + s;\n                shift.x = p / s;\n                shift.y = q / s;\n                double z = r / s;\n                q = q / p;\n                r = r / p;\n\n                // Row modification\n                for (int j = k; j < n; j++) {\n                    p = matrixT[k][j] + q * matrixT[k + 1][j];\n                    if (notlast) {\n                        p = p + r * matrixT[k + 2][j];\n                        matrixT[k + 2][j] = matrixT[k + 2][j] - p * z;\n                    }\n                    matrixT[k][j] = matrixT[k][j] - p * shift.x;\n                    matrixT[k + 1][j] = matrixT[k + 1][j] - p * shift.y;\n                }\n\n                // Column modification\n                for (int i = 0; i <= FastMath.min(iu, k + 3); i++) {\n                    p = shift.x * matrixT[i][k] + shift.y * matrixT[i][k + 1];\n                    if (notlast) {\n                        p = p + z * matrixT[i][k + 2];\n                        matrixT[i][k + 2] = matrixT[i][k + 2] - p * r;\n                    }\n                    matrixT[i][k] = matrixT[i][k] - p;\n                    matrixT[i][k + 1] = matrixT[i][k + 1] - p * q;\n                }\n\n                // Accumulate transformations\n                final int high = matrixT.length - 1;\n                for (int i = 0; i <= high; i++) {\n                    p = shift.x * matrixP[i][k] + shift.y * matrixP[i][k + 1];\n                    if (notlast) {\n                        p = p + z * matrixP[i][k + 2];\n                        matrixP[i][k + 2] = matrixP[i][k + 2] - p * r;\n                    }\n                    matrixP[i][k] = matrixP[i][k] - p;\n                    matrixP[i][k + 1] = matrixP[i][k + 1] - p * q;\n                }\n            }  // (s != 0)\n        }  // k loop\n\n        // clean up pollution due to round-off errors\n        for (int i = im + 2; i <= iu; i++) {\n            matrixT[i][i-2] = 0.0;\n            if (i > im + 2) {\n                matrixT[i][i-3] = 0.0;\n            }\n        }\n    }",
          "40": "    private void performDoubleQRStep(final int il, final int im, final int iu,\n                                     final ShiftInfo shift, final double[] hVec) {\n\n        final int n = matrixT.length;\n        double p = hVec[0];\n        double q = hVec[1];\n        double r = hVec[2];\n\n        for (int k = im; k <= iu - 1; k++) {\n            boolean notlast = k != (iu - 1);\n            if (k != im) {\n                p = matrixT[k][k - 1];\n                q = matrixT[k + 1][k - 1];\n                r = notlast ? matrixT[k + 2][k - 1] : 0.0;\n                shift.x = FastMath.abs(p) + FastMath.abs(q) + FastMath.abs(r);\n                if (!Precision.equals(shift.x, 0.0, epsilon)) {\n                    p = p / shift.x;\n                    q = q / shift.x;\n                    r = r / shift.x;\n                }\n            }\n            if (shift.x == 0.0) {\n                break;\n            }\n            double s = FastMath.sqrt(p * p + q * q + r * r);\n            if (p < 0.0) {\n                s = -s;\n            }\n            if (s != 0.0) {\n                if (k != im) {\n                    matrixT[k][k - 1] = -s * shift.x;\n                } else if (il != im) {\nmatrixP[k].[(k - 1)] = +matrixT[k].[(k - 1)];\n                }\n                p = p + s;\n                shift.x = p / s;\n                shift.y = q / s;\n                double z = r / s;\n                q = q / p;\n                r = r / p;\n\n                // Row modification\n                for (int j = k; j < n; j++) {\n                    p = matrixT[k][j] + q * matrixT[k + 1][j];\n                    if (notlast) {\n                        p = p + r * matrixT[k + 2][j];\n                        matrixT[k + 2][j] = matrixT[k + 2][j] - p * z;\n                    }\n                    matrixT[k][j] = matrixT[k][j] - p * shift.x;\n                    matrixT[k + 1][j] = matrixT[k + 1][j] - p * shift.y;\n                }\n\n                // Column modification\n                for (int i = 0; i <= FastMath.min(iu, k + 3); i++) {\n                    p = shift.x * matrixT[i][k] + shift.y * matrixT[i][k + 1];\n                    if (notlast) {\n                        p = p + z * matrixT[i][k + 2];\n                        matrixT[i][k + 2] = matrixT[i][k + 2] - p * r;\n                    }\n                    matrixT[i][k] = matrixT[i][k] - p;\n                    matrixT[i][k + 1] = matrixT[i][k + 1] - p * q;\n                }\n\n                // Accumulate transformations\n                final int high = matrixT.length - 1;\n                for (int i = 0; i <= high; i++) {\n                    p = shift.x * matrixP[i][k] + shift.y * matrixP[i][k + 1];\n                    if (notlast) {\n                        p = p + z * matrixP[i][k + 2];\n                        matrixP[i][k + 2] = matrixP[i][k + 2] - p * r;\n                    }\n                    matrixP[i][k] = matrixP[i][k] - p;\n                    matrixP[i][k + 1] = matrixP[i][k + 1] - p * q;\n                }\n            }  // (s != 0)\n        }  // k loop\n\n        // clean up pollution due to round-off errors\n        for (int i = im + 2; i <= iu; i++) {\n            matrixT[i][i-2] = 0.0;\n            if (i > im + 2) {\n                matrixT[i][i-3] = 0.0;\n            }\n        }\n    }",
          "41": "    private void performDoubleQRStep(final int il, final int im, final int iu,\n                                     final ShiftInfo shift, final double[] hVec) {\n\n        final int n = matrixT.length;\n        double p = hVec[0];\n        double q = hVec[1];\n        double r = hVec[2];\n\n        for (int k = im; k <= iu - 1; k++) {\n            boolean notlast = k != (iu - 1);\n            if (k != im) {\n                p = matrixT[k][k - 1];\n                q = matrixT[k + 1][k - 1];\n                r = notlast ? matrixT[k + 2][k - 1] : 0.0;\n                shift.x = FastMath.abs(p) + FastMath.abs(q) + FastMath.abs(r);\n                if (!Precision.equals(shift.x, 0.0, epsilon)) {\n                    p = p / shift.x;\n                    q = q / shift.x;\n                    r = r / shift.x;\n                }\n            }\n            if (shift.x == 0.0) {\n                break;\n            }\n            double s = FastMath.sqrt(p * p + q * q + r * r);\n            if (p < 0.0) {\n                s = -s;\n            }\n            if (s != 0.0) {\n                if (k != im) {\n                    matrixT[k][k - 1] = -s * shift.x;\n                } else if (il != im) {\nepsilon[k].[(k - 1)] = +matrixT[k].[(k - 1)];\n                }\n                p = p + s;\n                shift.x = p / s;\n                shift.y = q / s;\n                double z = r / s;\n                q = q / p;\n                r = r / p;\n\n                // Row modification\n                for (int j = k; j < n; j++) {\n                    p = matrixT[k][j] + q * matrixT[k + 1][j];\n                    if (notlast) {\n                        p = p + r * matrixT[k + 2][j];\n                        matrixT[k + 2][j] = matrixT[k + 2][j] - p * z;\n                    }\n                    matrixT[k][j] = matrixT[k][j] - p * shift.x;\n                    matrixT[k + 1][j] = matrixT[k + 1][j] - p * shift.y;\n                }\n\n                // Column modification\n                for (int i = 0; i <= FastMath.min(iu, k + 3); i++) {\n                    p = shift.x * matrixT[i][k] + shift.y * matrixT[i][k + 1];\n                    if (notlast) {\n                        p = p + z * matrixT[i][k + 2];\n                        matrixT[i][k + 2] = matrixT[i][k + 2] - p * r;\n                    }\n                    matrixT[i][k] = matrixT[i][k] - p;\n                    matrixT[i][k + 1] = matrixT[i][k + 1] - p * q;\n                }\n\n                // Accumulate transformations\n                final int high = matrixT.length - 1;\n                for (int i = 0; i <= high; i++) {\n                    p = shift.x * matrixP[i][k] + shift.y * matrixP[i][k + 1];\n                    if (notlast) {\n                        p = p + z * matrixP[i][k + 2];\n                        matrixP[i][k + 2] = matrixP[i][k + 2] - p * r;\n                    }\n                    matrixP[i][k] = matrixP[i][k] - p;\n                    matrixP[i][k + 1] = matrixP[i][k + 1] - p * q;\n                }\n            }  // (s != 0)\n        }  // k loop\n\n        // clean up pollution due to round-off errors\n        for (int i = im + 2; i <= iu; i++) {\n            matrixT[i][i-2] = 0.0;\n            if (i > im + 2) {\n                matrixT[i][i-3] = 0.0;\n            }\n        }\n    }",
          "42": "    private void performDoubleQRStep(final int il, final int im, final int iu,\n                                     final ShiftInfo shift, final double[] hVec) {\n\n        final int n = matrixT.length;\n        double p = hVec[0];\n        double q = hVec[1];\n        double r = hVec[2];\n\n        for (int k = im; k <= iu - 1; k++) {\n            boolean notlast = k != (iu - 1);\n            if (k != im) {\n                p = matrixT[k][k - 1];\n                q = matrixT[k + 1][k - 1];\n                r = notlast ? matrixT[k + 2][k - 1] : 0.0;\n                shift.x = FastMath.abs(p) + FastMath.abs(q) + FastMath.abs(r);\n                if (!Precision.equals(shift.x, 0.0, epsilon)) {\n                    p = p / shift.x;\n                    q = q / shift.x;\n                    r = r / shift.x;\n                }\n            }\n            if (shift.x == 0.0) {\n                break;\n            }\n            double s = FastMath.sqrt(p * p + q * q + r * r);\n            if (p < 0.0) {\n                s = -s;\n            }\n            if (s != 0.0) {\n                if (k != im) {\n                    matrixT[k][k - 1] = -s * shift.x;\n                } else if (il != im) {\nx[k].[(k - 1)] = +matrixT[k].[(k - 1)];\n                }\n                p = p + s;\n                shift.x = p / s;\n                shift.y = q / s;\n                double z = r / s;\n                q = q / p;\n                r = r / p;\n\n                // Row modification\n                for (int j = k; j < n; j++) {\n                    p = matrixT[k][j] + q * matrixT[k + 1][j];\n                    if (notlast) {\n                        p = p + r * matrixT[k + 2][j];\n                        matrixT[k + 2][j] = matrixT[k + 2][j] - p * z;\n                    }\n                    matrixT[k][j] = matrixT[k][j] - p * shift.x;\n                    matrixT[k + 1][j] = matrixT[k + 1][j] - p * shift.y;\n                }\n\n                // Column modification\n                for (int i = 0; i <= FastMath.min(iu, k + 3); i++) {\n                    p = shift.x * matrixT[i][k] + shift.y * matrixT[i][k + 1];\n                    if (notlast) {\n                        p = p + z * matrixT[i][k + 2];\n                        matrixT[i][k + 2] = matrixT[i][k + 2] - p * r;\n                    }\n                    matrixT[i][k] = matrixT[i][k] - p;\n                    matrixT[i][k + 1] = matrixT[i][k + 1] - p * q;\n                }\n\n                // Accumulate transformations\n                final int high = matrixT.length - 1;\n                for (int i = 0; i <= high; i++) {\n                    p = shift.x * matrixP[i][k] + shift.y * matrixP[i][k + 1];\n                    if (notlast) {\n                        p = p + z * matrixP[i][k + 2];\n                        matrixP[i][k + 2] = matrixP[i][k + 2] - p * r;\n                    }\n                    matrixP[i][k] = matrixP[i][k] - p;\n                    matrixP[i][k + 1] = matrixP[i][k + 1] - p * q;\n                }\n            }  // (s != 0)\n        }  // k loop\n\n        // clean up pollution due to round-off errors\n        for (int i = im + 2; i <= iu; i++) {\n            matrixT[i][i-2] = 0.0;\n            if (i > im + 2) {\n                matrixT[i][i-3] = 0.0;\n            }\n        }\n    }",
          "43": "    private void performDoubleQRStep(final int il, final int im, final int iu,\n                                     final ShiftInfo shift, final double[] hVec) {\n\n        final int n = matrixT.length;\n        double p = hVec[0];\n        double q = hVec[1];\n        double r = hVec[2];\n\n        for (int k = im; k <= iu - 1; k++) {\n            boolean notlast = k != (iu - 1);\n            if (k != im) {\n                p = matrixT[k][k - 1];\n                q = matrixT[k + 1][k - 1];\n                r = notlast ? matrixT[k + 2][k - 1] : 0.0;\n                shift.x = FastMath.abs(p) + FastMath.abs(q) + FastMath.abs(r);\n                if (!Precision.equals(shift.x, 0.0, epsilon)) {\n                    p = p / shift.x;\n                    q = q / shift.x;\n                    r = r / shift.x;\n                }\n            }\n            if (shift.x == 0.0) {\n                break;\n            }\n            double s = FastMath.sqrt(p * p + q * q + r * r);\n            if (p < 0.0) {\n                s = -s;\n            }\n            if (s != 0.0) {\n                if (k != im) {\n                    matrixT[k][k - 1] = -s * shift.x;\n                } else if (il != im) {\ny[k].[(k - 1)] = +matrixT[k].[(k - 1)];\n                }\n                p = p + s;\n                shift.x = p / s;\n                shift.y = q / s;\n                double z = r / s;\n                q = q / p;\n                r = r / p;\n\n                // Row modification\n                for (int j = k; j < n; j++) {\n                    p = matrixT[k][j] + q * matrixT[k + 1][j];\n                    if (notlast) {\n                        p = p + r * matrixT[k + 2][j];\n                        matrixT[k + 2][j] = matrixT[k + 2][j] - p * z;\n                    }\n                    matrixT[k][j] = matrixT[k][j] - p * shift.x;\n                    matrixT[k + 1][j] = matrixT[k + 1][j] - p * shift.y;\n                }\n\n                // Column modification\n                for (int i = 0; i <= FastMath.min(iu, k + 3); i++) {\n                    p = shift.x * matrixT[i][k] + shift.y * matrixT[i][k + 1];\n                    if (notlast) {\n                        p = p + z * matrixT[i][k + 2];\n                        matrixT[i][k + 2] = matrixT[i][k + 2] - p * r;\n                    }\n                    matrixT[i][k] = matrixT[i][k] - p;\n                    matrixT[i][k + 1] = matrixT[i][k + 1] - p * q;\n                }\n\n                // Accumulate transformations\n                final int high = matrixT.length - 1;\n                for (int i = 0; i <= high; i++) {\n                    p = shift.x * matrixP[i][k] + shift.y * matrixP[i][k + 1];\n                    if (notlast) {\n                        p = p + z * matrixP[i][k + 2];\n                        matrixP[i][k + 2] = matrixP[i][k + 2] - p * r;\n                    }\n                    matrixP[i][k] = matrixP[i][k] - p;\n                    matrixP[i][k + 1] = matrixP[i][k + 1] - p * q;\n                }\n            }  // (s != 0)\n        }  // k loop\n\n        // clean up pollution due to round-off errors\n        for (int i = im + 2; i <= iu; i++) {\n            matrixT[i][i-2] = 0.0;\n            if (i > im + 2) {\n                matrixT[i][i-3] = 0.0;\n            }\n        }\n    }",
          "44": "    private void performDoubleQRStep(final int il, final int im, final int iu,\n                                     final ShiftInfo shift, final double[] hVec) {\n\n        final int n = matrixT.length;\n        double p = hVec[0];\n        double q = hVec[1];\n        double r = hVec[2];\n\n        for (int k = im; k <= iu - 1; k++) {\n            boolean notlast = k != (iu - 1);\n            if (k != im) {\n                p = matrixT[k][k - 1];\n                q = matrixT[k + 1][k - 1];\n                r = notlast ? matrixT[k + 2][k - 1] : 0.0;\n                shift.x = FastMath.abs(p) + FastMath.abs(q) + FastMath.abs(r);\n                if (!Precision.equals(shift.x, 0.0, epsilon)) {\n                    p = p / shift.x;\n                    q = q / shift.x;\n                    r = r / shift.x;\n                }\n            }\n            if (shift.x == 0.0) {\n                break;\n            }\n            double s = FastMath.sqrt(p * p + q * q + r * r);\n            if (p < 0.0) {\n                s = -s;\n            }\n            if (s != 0.0) {\n                if (k != im) {\n                    matrixT[k][k - 1] = -s * shift.x;\n                } else if (il != im) {\nw[k].[(k - 1)] = +matrixT[k].[(k - 1)];\n                }\n                p = p + s;\n                shift.x = p / s;\n                shift.y = q / s;\n                double z = r / s;\n                q = q / p;\n                r = r / p;\n\n                // Row modification\n                for (int j = k; j < n; j++) {\n                    p = matrixT[k][j] + q * matrixT[k + 1][j];\n                    if (notlast) {\n                        p = p + r * matrixT[k + 2][j];\n                        matrixT[k + 2][j] = matrixT[k + 2][j] - p * z;\n                    }\n                    matrixT[k][j] = matrixT[k][j] - p * shift.x;\n                    matrixT[k + 1][j] = matrixT[k + 1][j] - p * shift.y;\n                }\n\n                // Column modification\n                for (int i = 0; i <= FastMath.min(iu, k + 3); i++) {\n                    p = shift.x * matrixT[i][k] + shift.y * matrixT[i][k + 1];\n                    if (notlast) {\n                        p = p + z * matrixT[i][k + 2];\n                        matrixT[i][k + 2] = matrixT[i][k + 2] - p * r;\n                    }\n                    matrixT[i][k] = matrixT[i][k] - p;\n                    matrixT[i][k + 1] = matrixT[i][k + 1] - p * q;\n                }\n\n                // Accumulate transformations\n                final int high = matrixT.length - 1;\n                for (int i = 0; i <= high; i++) {\n                    p = shift.x * matrixP[i][k] + shift.y * matrixP[i][k + 1];\n                    if (notlast) {\n                        p = p + z * matrixP[i][k + 2];\n                        matrixP[i][k + 2] = matrixP[i][k + 2] - p * r;\n                    }\n                    matrixP[i][k] = matrixP[i][k] - p;\n                    matrixP[i][k + 1] = matrixP[i][k + 1] - p * q;\n                }\n            }  // (s != 0)\n        }  // k loop\n\n        // clean up pollution due to round-off errors\n        for (int i = im + 2; i <= iu; i++) {\n            matrixT[i][i-2] = 0.0;\n            if (i > im + 2) {\n                matrixT[i][i-3] = 0.0;\n            }\n        }\n    }",
          "45": "    private void performDoubleQRStep(final int il, final int im, final int iu,\n                                     final ShiftInfo shift, final double[] hVec) {\n\n        final int n = matrixT.length;\n        double p = hVec[0];\n        double q = hVec[1];\n        double r = hVec[2];\n\n        for (int k = im; k <= iu - 1; k++) {\n            boolean notlast = k != (iu - 1);\n            if (k != im) {\n                p = matrixT[k][k - 1];\n                q = matrixT[k + 1][k - 1];\n                r = notlast ? matrixT[k + 2][k - 1] : 0.0;\n                shift.x = FastMath.abs(p) + FastMath.abs(q) + FastMath.abs(r);\n                if (!Precision.equals(shift.x, 0.0, epsilon)) {\n                    p = p / shift.x;\n                    q = q / shift.x;\n                    r = r / shift.x;\n                }\n            }\n            if (shift.x == 0.0) {\n                break;\n            }\n            double s = FastMath.sqrt(p * p + q * q + r * r);\n            if (p < 0.0) {\n                s = -s;\n            }\n            if (s != 0.0) {\n                if (k != im) {\n                    matrixT[k][k - 1] = -s * shift.x;\n                } else if (il != im) {\nexShift[k].[(k - 1)] = +matrixT[k].[(k - 1)];\n                }\n                p = p + s;\n                shift.x = p / s;\n                shift.y = q / s;\n                double z = r / s;\n                q = q / p;\n                r = r / p;\n\n                // Row modification\n                for (int j = k; j < n; j++) {\n                    p = matrixT[k][j] + q * matrixT[k + 1][j];\n                    if (notlast) {\n                        p = p + r * matrixT[k + 2][j];\n                        matrixT[k + 2][j] = matrixT[k + 2][j] - p * z;\n                    }\n                    matrixT[k][j] = matrixT[k][j] - p * shift.x;\n                    matrixT[k + 1][j] = matrixT[k + 1][j] - p * shift.y;\n                }\n\n                // Column modification\n                for (int i = 0; i <= FastMath.min(iu, k + 3); i++) {\n                    p = shift.x * matrixT[i][k] + shift.y * matrixT[i][k + 1];\n                    if (notlast) {\n                        p = p + z * matrixT[i][k + 2];\n                        matrixT[i][k + 2] = matrixT[i][k + 2] - p * r;\n                    }\n                    matrixT[i][k] = matrixT[i][k] - p;\n                    matrixT[i][k + 1] = matrixT[i][k + 1] - p * q;\n                }\n\n                // Accumulate transformations\n                final int high = matrixT.length - 1;\n                for (int i = 0; i <= high; i++) {\n                    p = shift.x * matrixP[i][k] + shift.y * matrixP[i][k + 1];\n                    if (notlast) {\n                        p = p + z * matrixP[i][k + 2];\n                        matrixP[i][k + 2] = matrixP[i][k + 2] - p * r;\n                    }\n                    matrixP[i][k] = matrixP[i][k] - p;\n                    matrixP[i][k + 1] = matrixP[i][k + 1] - p * q;\n                }\n            }  // (s != 0)\n        }  // k loop\n\n        // clean up pollution due to round-off errors\n        for (int i = im + 2; i <= iu; i++) {\n            matrixT[i][i-2] = 0.0;\n            if (i > im + 2) {\n                matrixT[i][i-3] = 0.0;\n            }\n        }\n    }",
          "46": "    private void performDoubleQRStep(final int il, final int im, final int iu,\n                                     final ShiftInfo shift, final double[] hVec) {\n\n        final int n = matrixT.length;\n        double p = hVec[0];\n        double q = hVec[1];\n        double r = hVec[2];\n\n        for (int k = im; k <= iu - 1; k++) {\n            boolean notlast = k != (iu - 1);\n            if (k != im) {\n                p = matrixT[k][k - 1];\n                q = matrixT[k + 1][k - 1];\n                r = notlast ? matrixT[k + 2][k - 1] : 0.0;\n                shift.x = FastMath.abs(p) + FastMath.abs(q) + FastMath.abs(r);\n                if (!Precision.equals(shift.x, 0.0, epsilon)) {\n                    p = p / shift.x;\n                    q = q / shift.x;\n                    r = r / shift.x;\n                }\n            }\n            if (shift.x == 0.0) {\n                break;\n            }\n            double s = FastMath.sqrt(p * p + q * q + r * r);\n            if (p < 0.0) {\n                s = -s;\n            }\n            if (s != 0.0) {\n                if (k != im) {\n                    matrixT[k][k - 1] = -s * shift.x;\n                } else if (il != im) {\nif((k - 1)){\n}\n                    matrixT[k][k - 1] = +matrixT[k][k - 1];                }\n                p = p + s;\n                shift.x = p / s;\n                shift.y = q / s;\n                double z = r / s;\n                q = q / p;\n                r = r / p;\n\n                // Row modification\n                for (int j = k; j < n; j++) {\n                    p = matrixT[k][j] + q * matrixT[k + 1][j];\n                    if (notlast) {\n                        p = p + r * matrixT[k + 2][j];\n                        matrixT[k + 2][j] = matrixT[k + 2][j] - p * z;\n                    }\n                    matrixT[k][j] = matrixT[k][j] - p * shift.x;\n                    matrixT[k + 1][j] = matrixT[k + 1][j] - p * shift.y;\n                }\n\n                // Column modification\n                for (int i = 0; i <= FastMath.min(iu, k + 3); i++) {\n                    p = shift.x * matrixT[i][k] + shift.y * matrixT[i][k + 1];\n                    if (notlast) {\n                        p = p + z * matrixT[i][k + 2];\n                        matrixT[i][k + 2] = matrixT[i][k + 2] - p * r;\n                    }\n                    matrixT[i][k] = matrixT[i][k] - p;\n                    matrixT[i][k + 1] = matrixT[i][k + 1] - p * q;\n                }\n\n                // Accumulate transformations\n                final int high = matrixT.length - 1;\n                for (int i = 0; i <= high; i++) {\n                    p = shift.x * matrixP[i][k] + shift.y * matrixP[i][k + 1];\n                    if (notlast) {\n                        p = p + z * matrixP[i][k + 2];\n                        matrixP[i][k + 2] = matrixP[i][k + 2] - p * r;\n                    }\n                    matrixP[i][k] = matrixP[i][k] - p;\n                    matrixP[i][k + 1] = matrixP[i][k + 1] - p * q;\n                }\n            }  // (s != 0)\n        }  // k loop\n\n        // clean up pollution due to round-off errors\n        for (int i = im + 2; i <= iu; i++) {\n            matrixT[i][i-2] = 0.0;\n            if (i > im + 2) {\n                matrixT[i][i-3] = 0.0;\n            }\n        }\n    }",
          "47": "    private void performDoubleQRStep(final int il, final int im, final int iu,\n                                     final ShiftInfo shift, final double[] hVec) {\n\n        final int n = matrixT.length;\n        double p = hVec[0];\n        double q = hVec[1];\n        double r = hVec[2];\n\n        for (int k = im; k <= iu - 1; k++) {\n            boolean notlast = k != (iu - 1);\n            if (k != im) {\n                p = matrixT[k][k - 1];\n                q = matrixT[k + 1][k - 1];\n                r = notlast ? matrixT[k + 2][k - 1] : 0.0;\n                shift.x = FastMath.abs(p) + FastMath.abs(q) + FastMath.abs(r);\n                if (!Precision.equals(shift.x, 0.0, epsilon)) {\n                    p = p / shift.x;\n                    q = q / shift.x;\n                    r = r / shift.x;\n                }\n            }\n            if (shift.x == 0.0) {\n                break;\n            }\n            double s = FastMath.sqrt(p * p + q * q + r * r);\n            if (p < 0.0) {\n                s = -s;\n            }\n            if (s != 0.0) {\n                if (k != im) {\n                    matrixT[k][k - 1] = -s * shift.x;\n                } else if (il != im) {\nmatrixT[k].[(k - 1)] = s[k].[(k - 1)];\n                }\n                p = p + s;\n                shift.x = p / s;\n                shift.y = q / s;\n                double z = r / s;\n                q = q / p;\n                r = r / p;\n\n                // Row modification\n                for (int j = k; j < n; j++) {\n                    p = matrixT[k][j] + q * matrixT[k + 1][j];\n                    if (notlast) {\n                        p = p + r * matrixT[k + 2][j];\n                        matrixT[k + 2][j] = matrixT[k + 2][j] - p * z;\n                    }\n                    matrixT[k][j] = matrixT[k][j] - p * shift.x;\n                    matrixT[k + 1][j] = matrixT[k + 1][j] - p * shift.y;\n                }\n\n                // Column modification\n                for (int i = 0; i <= FastMath.min(iu, k + 3); i++) {\n                    p = shift.x * matrixT[i][k] + shift.y * matrixT[i][k + 1];\n                    if (notlast) {\n                        p = p + z * matrixT[i][k + 2];\n                        matrixT[i][k + 2] = matrixT[i][k + 2] - p * r;\n                    }\n                    matrixT[i][k] = matrixT[i][k] - p;\n                    matrixT[i][k + 1] = matrixT[i][k + 1] - p * q;\n                }\n\n                // Accumulate transformations\n                final int high = matrixT.length - 1;\n                for (int i = 0; i <= high; i++) {\n                    p = shift.x * matrixP[i][k] + shift.y * matrixP[i][k + 1];\n                    if (notlast) {\n                        p = p + z * matrixP[i][k + 2];\n                        matrixP[i][k + 2] = matrixP[i][k + 2] - p * r;\n                    }\n                    matrixP[i][k] = matrixP[i][k] - p;\n                    matrixP[i][k + 1] = matrixP[i][k + 1] - p * q;\n                }\n            }  // (s != 0)\n        }  // k loop\n\n        // clean up pollution due to round-off errors\n        for (int i = im + 2; i <= iu; i++) {\n            matrixT[i][i-2] = 0.0;\n            if (i > im + 2) {\n                matrixT[i][i-3] = 0.0;\n            }\n        }\n    }",
          "48": "    private void performDoubleQRStep(final int il, final int im, final int iu,\n                                     final ShiftInfo shift, final double[] hVec) {\n\n        final int n = matrixT.length;\n        double p = hVec[0];\n        double q = hVec[1];\n        double r = hVec[2];\n\n        for (int k = im; k <= iu - 1; k++) {\n            boolean notlast = k != (iu - 1);\n            if (k != im) {\n                p = matrixT[k][k - 1];\n                q = matrixT[k + 1][k - 1];\n                r = notlast ? matrixT[k + 2][k - 1] : 0.0;\n                shift.x = FastMath.abs(p) + FastMath.abs(q) + FastMath.abs(r);\n                if (!Precision.equals(shift.x, 0.0, epsilon)) {\n                    p = p / shift.x;\n                    q = q / shift.x;\n                    r = r / shift.x;\n                }\n            }\n            if (shift.x == 0.0) {\n                break;\n            }\n            double s = FastMath.sqrt(p * p + q * q + r * r);\n            if (p < 0.0) {\n                s = -s;\n            }\n            if (s != 0.0) {\n                if (k != im) {\n                    matrixT[k][k - 1] = -s * shift.x;\n                } else if (il != im) {\nmatrixT[k].[(k - 1)] = r[k].[(k - 1)];\n                }\n                p = p + s;\n                shift.x = p / s;\n                shift.y = q / s;\n                double z = r / s;\n                q = q / p;\n                r = r / p;\n\n                // Row modification\n                for (int j = k; j < n; j++) {\n                    p = matrixT[k][j] + q * matrixT[k + 1][j];\n                    if (notlast) {\n                        p = p + r * matrixT[k + 2][j];\n                        matrixT[k + 2][j] = matrixT[k + 2][j] - p * z;\n                    }\n                    matrixT[k][j] = matrixT[k][j] - p * shift.x;\n                    matrixT[k + 1][j] = matrixT[k + 1][j] - p * shift.y;\n                }\n\n                // Column modification\n                for (int i = 0; i <= FastMath.min(iu, k + 3); i++) {\n                    p = shift.x * matrixT[i][k] + shift.y * matrixT[i][k + 1];\n                    if (notlast) {\n                        p = p + z * matrixT[i][k + 2];\n                        matrixT[i][k + 2] = matrixT[i][k + 2] - p * r;\n                    }\n                    matrixT[i][k] = matrixT[i][k] - p;\n                    matrixT[i][k + 1] = matrixT[i][k + 1] - p * q;\n                }\n\n                // Accumulate transformations\n                final int high = matrixT.length - 1;\n                for (int i = 0; i <= high; i++) {\n                    p = shift.x * matrixP[i][k] + shift.y * matrixP[i][k + 1];\n                    if (notlast) {\n                        p = p + z * matrixP[i][k + 2];\n                        matrixP[i][k + 2] = matrixP[i][k + 2] - p * r;\n                    }\n                    matrixP[i][k] = matrixP[i][k] - p;\n                    matrixP[i][k + 1] = matrixP[i][k + 1] - p * q;\n                }\n            }  // (s != 0)\n        }  // k loop\n\n        // clean up pollution due to round-off errors\n        for (int i = im + 2; i <= iu; i++) {\n            matrixT[i][i-2] = 0.0;\n            if (i > im + 2) {\n                matrixT[i][i-3] = 0.0;\n            }\n        }\n    }",
          "49": "    private void performDoubleQRStep(final int il, final int im, final int iu,\n                                     final ShiftInfo shift, final double[] hVec) {\n\n        final int n = matrixT.length;\n        double p = hVec[0];\n        double q = hVec[1];\n        double r = hVec[2];\n\n        for (int k = im; k <= iu - 1; k++) {\n            boolean notlast = k != (iu - 1);\n            if (k != im) {\n                p = matrixT[k][k - 1];\n                q = matrixT[k + 1][k - 1];\n                r = notlast ? matrixT[k + 2][k - 1] : 0.0;\n                shift.x = FastMath.abs(p) + FastMath.abs(q) + FastMath.abs(r);\n                if (!Precision.equals(shift.x, 0.0, epsilon)) {\n                    p = p / shift.x;\n                    q = q / shift.x;\n                    r = r / shift.x;\n                }\n            }\n            if (shift.x == 0.0) {\n                break;\n            }\n            double s = FastMath.sqrt(p * p + q * q + r * r);\n            if (p < 0.0) {\n                s = -s;\n            }\n            if (s != 0.0) {\n                if (k != im) {\n                    matrixT[k][k - 1] = -s * shift.x;\n                } else if (il != im) {\nmatrixT[k].[(k - 1)] = +matrixT[k].[(k - -1)];\n                }\n                p = p + s;\n                shift.x = p / s;\n                shift.y = q / s;\n                double z = r / s;\n                q = q / p;\n                r = r / p;\n\n                // Row modification\n                for (int j = k; j < n; j++) {\n                    p = matrixT[k][j] + q * matrixT[k + 1][j];\n                    if (notlast) {\n                        p = p + r * matrixT[k + 2][j];\n                        matrixT[k + 2][j] = matrixT[k + 2][j] - p * z;\n                    }\n                    matrixT[k][j] = matrixT[k][j] - p * shift.x;\n                    matrixT[k + 1][j] = matrixT[k + 1][j] - p * shift.y;\n                }\n\n                // Column modification\n                for (int i = 0; i <= FastMath.min(iu, k + 3); i++) {\n                    p = shift.x * matrixT[i][k] + shift.y * matrixT[i][k + 1];\n                    if (notlast) {\n                        p = p + z * matrixT[i][k + 2];\n                        matrixT[i][k + 2] = matrixT[i][k + 2] - p * r;\n                    }\n                    matrixT[i][k] = matrixT[i][k] - p;\n                    matrixT[i][k + 1] = matrixT[i][k + 1] - p * q;\n                }\n\n                // Accumulate transformations\n                final int high = matrixT.length - 1;\n                for (int i = 0; i <= high; i++) {\n                    p = shift.x * matrixP[i][k] + shift.y * matrixP[i][k + 1];\n                    if (notlast) {\n                        p = p + z * matrixP[i][k + 2];\n                        matrixP[i][k + 2] = matrixP[i][k + 2] - p * r;\n                    }\n                    matrixP[i][k] = matrixP[i][k] - p;\n                    matrixP[i][k + 1] = matrixP[i][k + 1] - p * q;\n                }\n            }  // (s != 0)\n        }  // k loop\n\n        // clean up pollution due to round-off errors\n        for (int i = im + 2; i <= iu; i++) {\n            matrixT[i][i-2] = 0.0;\n            if (i > im + 2) {\n                matrixT[i][i-3] = 0.0;\n            }\n        }\n    }",
          "50": "    private void performDoubleQRStep(final int il, final int im, final int iu,\n                                     final ShiftInfo shift, final double[] hVec) {\n\n        final int n = matrixT.length;\n        double p = hVec[0];\n        double q = hVec[1];\n        double r = hVec[2];\n\n        for (int k = im; k <= iu - 1; k++) {\n            boolean notlast = k != (iu - 1);\n            if (k != im) {\n                p = matrixT[k][k - 1];\n                q = matrixT[k + 1][k - 1];\n                r = notlast ? matrixT[k + 2][k - 1] : 0.0;\n                shift.x = FastMath.abs(p) + FastMath.abs(q) + FastMath.abs(r);\n                if (!Precision.equals(shift.x, 0.0, epsilon)) {\n                    p = p / shift.x;\n                    q = q / shift.x;\n                    r = r / shift.x;\n                }\n            }\n            if (shift.x == 0.0) {\n                break;\n            }\n            double s = FastMath.sqrt(p * p + q * q + r * r);\n            if (p < 0.0) {\n                s = -s;\n            }\n            if (s != 0.0) {\n                if (k != im) {\n                    matrixT[k][k - 1] = -s * shift.x;\n                } else if (il != im) {\nmatrixT[k].[(k - 1)] = q[k].[(k - 1)];\n                }\n                p = p + s;\n                shift.x = p / s;\n                shift.y = q / s;\n                double z = r / s;\n                q = q / p;\n                r = r / p;\n\n                // Row modification\n                for (int j = k; j < n; j++) {\n                    p = matrixT[k][j] + q * matrixT[k + 1][j];\n                    if (notlast) {\n                        p = p + r * matrixT[k + 2][j];\n                        matrixT[k + 2][j] = matrixT[k + 2][j] - p * z;\n                    }\n                    matrixT[k][j] = matrixT[k][j] - p * shift.x;\n                    matrixT[k + 1][j] = matrixT[k + 1][j] - p * shift.y;\n                }\n\n                // Column modification\n                for (int i = 0; i <= FastMath.min(iu, k + 3); i++) {\n                    p = shift.x * matrixT[i][k] + shift.y * matrixT[i][k + 1];\n                    if (notlast) {\n                        p = p + z * matrixT[i][k + 2];\n                        matrixT[i][k + 2] = matrixT[i][k + 2] - p * r;\n                    }\n                    matrixT[i][k] = matrixT[i][k] - p;\n                    matrixT[i][k + 1] = matrixT[i][k + 1] - p * q;\n                }\n\n                // Accumulate transformations\n                final int high = matrixT.length - 1;\n                for (int i = 0; i <= high; i++) {\n                    p = shift.x * matrixP[i][k] + shift.y * matrixP[i][k + 1];\n                    if (notlast) {\n                        p = p + z * matrixP[i][k + 2];\n                        matrixP[i][k + 2] = matrixP[i][k + 2] - p * r;\n                    }\n                    matrixP[i][k] = matrixP[i][k] - p;\n                    matrixP[i][k + 1] = matrixP[i][k + 1] - p * q;\n                }\n            }  // (s != 0)\n        }  // k loop\n\n        // clean up pollution due to round-off errors\n        for (int i = im + 2; i <= iu; i++) {\n            matrixT[i][i-2] = 0.0;\n            if (i > im + 2) {\n                matrixT[i][i-3] = 0.0;\n            }\n        }\n    }",
          "51": "    private void performDoubleQRStep(final int il, final int im, final int iu,\n                                     final ShiftInfo shift, final double[] hVec) {\n\n        final int n = matrixT.length;\n        double p = hVec[0];\n        double q = hVec[1];\n        double r = hVec[2];\n\n        for (int k = im; k <= iu - 1; k++) {\n            boolean notlast = k != (iu - 1);\n            if (k != im) {\n                p = matrixT[k][k - 1];\n                q = matrixT[k + 1][k - 1];\n                r = notlast ? matrixT[k + 2][k - 1] : 0.0;\n                shift.x = FastMath.abs(p) + FastMath.abs(q) + FastMath.abs(r);\n                if (!Precision.equals(shift.x, 0.0, epsilon)) {\n                    p = p / shift.x;\n                    q = q / shift.x;\n                    r = r / shift.x;\n                }\n            }\n            if (shift.x == 0.0) {\n                break;\n            }\n            double s = FastMath.sqrt(p * p + q * q + r * r);\n            if (p < 0.0) {\n                s = -s;\n            }\n            if (s != 0.0) {\n                if (k != im) {\n                    matrixT[k][k - 1] = -s * shift.x;\n                } else if (il != im) {\nmatrixT[k].[(k - 1)] = matrixP;\n                }\n                p = p + s;\n                shift.x = p / s;\n                shift.y = q / s;\n                double z = r / s;\n                q = q / p;\n                r = r / p;\n\n                // Row modification\n                for (int j = k; j < n; j++) {\n                    p = matrixT[k][j] + q * matrixT[k + 1][j];\n                    if (notlast) {\n                        p = p + r * matrixT[k + 2][j];\n                        matrixT[k + 2][j] = matrixT[k + 2][j] - p * z;\n                    }\n                    matrixT[k][j] = matrixT[k][j] - p * shift.x;\n                    matrixT[k + 1][j] = matrixT[k + 1][j] - p * shift.y;\n                }\n\n                // Column modification\n                for (int i = 0; i <= FastMath.min(iu, k + 3); i++) {\n                    p = shift.x * matrixT[i][k] + shift.y * matrixT[i][k + 1];\n                    if (notlast) {\n                        p = p + z * matrixT[i][k + 2];\n                        matrixT[i][k + 2] = matrixT[i][k + 2] - p * r;\n                    }\n                    matrixT[i][k] = matrixT[i][k] - p;\n                    matrixT[i][k + 1] = matrixT[i][k + 1] - p * q;\n                }\n\n                // Accumulate transformations\n                final int high = matrixT.length - 1;\n                for (int i = 0; i <= high; i++) {\n                    p = shift.x * matrixP[i][k] + shift.y * matrixP[i][k + 1];\n                    if (notlast) {\n                        p = p + z * matrixP[i][k + 2];\n                        matrixP[i][k + 2] = matrixP[i][k + 2] - p * r;\n                    }\n                    matrixP[i][k] = matrixP[i][k] - p;\n                    matrixP[i][k + 1] = matrixP[i][k + 1] - p * q;\n                }\n            }  // (s != 0)\n        }  // k loop\n\n        // clean up pollution due to round-off errors\n        for (int i = im + 2; i <= iu; i++) {\n            matrixT[i][i-2] = 0.0;\n            if (i > im + 2) {\n                matrixT[i][i-3] = 0.0;\n            }\n        }\n    }",
          "52": "    private void performDoubleQRStep(final int il, final int im, final int iu,\n                                     final ShiftInfo shift, final double[] hVec) {\n\n        final int n = matrixT.length;\n        double p = hVec[0];\n        double q = hVec[1];\n        double r = hVec[2];\n\n        for (int k = im; k <= iu - 1; k++) {\n            boolean notlast = k != (iu - 1);\n            if (k != im) {\n                p = matrixT[k][k - 1];\n                q = matrixT[k + 1][k - 1];\n                r = notlast ? matrixT[k + 2][k - 1] : 0.0;\n                shift.x = FastMath.abs(p) + FastMath.abs(q) + FastMath.abs(r);\n                if (!Precision.equals(shift.x, 0.0, epsilon)) {\n                    p = p / shift.x;\n                    q = q / shift.x;\n                    r = r / shift.x;\n                }\n            }\n            if (shift.x == 0.0) {\n                break;\n            }\n            double s = FastMath.sqrt(p * p + q * q + r * r);\n            if (p < 0.0) {\n                s = -s;\n            }\n            if (s != 0.0) {\n                if (k != im) {\n                    matrixT[k][k - 1] = -s * shift.x;\n                } else if (il != im) {\nmatrixT[k].[(k - 1)] = matrixT;\n                }\n                p = p + s;\n                shift.x = p / s;\n                shift.y = q / s;\n                double z = r / s;\n                q = q / p;\n                r = r / p;\n\n                // Row modification\n                for (int j = k; j < n; j++) {\n                    p = matrixT[k][j] + q * matrixT[k + 1][j];\n                    if (notlast) {\n                        p = p + r * matrixT[k + 2][j];\n                        matrixT[k + 2][j] = matrixT[k + 2][j] - p * z;\n                    }\n                    matrixT[k][j] = matrixT[k][j] - p * shift.x;\n                    matrixT[k + 1][j] = matrixT[k + 1][j] - p * shift.y;\n                }\n\n                // Column modification\n                for (int i = 0; i <= FastMath.min(iu, k + 3); i++) {\n                    p = shift.x * matrixT[i][k] + shift.y * matrixT[i][k + 1];\n                    if (notlast) {\n                        p = p + z * matrixT[i][k + 2];\n                        matrixT[i][k + 2] = matrixT[i][k + 2] - p * r;\n                    }\n                    matrixT[i][k] = matrixT[i][k] - p;\n                    matrixT[i][k + 1] = matrixT[i][k + 1] - p * q;\n                }\n\n                // Accumulate transformations\n                final int high = matrixT.length - 1;\n                for (int i = 0; i <= high; i++) {\n                    p = shift.x * matrixP[i][k] + shift.y * matrixP[i][k + 1];\n                    if (notlast) {\n                        p = p + z * matrixP[i][k + 2];\n                        matrixP[i][k + 2] = matrixP[i][k + 2] - p * r;\n                    }\n                    matrixP[i][k] = matrixP[i][k] - p;\n                    matrixP[i][k + 1] = matrixP[i][k + 1] - p * q;\n                }\n            }  // (s != 0)\n        }  // k loop\n\n        // clean up pollution due to round-off errors\n        for (int i = im + 2; i <= iu; i++) {\n            matrixT[i][i-2] = 0.0;\n            if (i > im + 2) {\n                matrixT[i][i-3] = 0.0;\n            }\n        }\n    }",
          "53": "    private void performDoubleQRStep(final int il, final int im, final int iu,\n                                     final ShiftInfo shift, final double[] hVec) {\n\n        final int n = matrixT.length;\n        double p = hVec[0];\n        double q = hVec[1];\n        double r = hVec[2];\n\n        for (int k = im; k <= iu - 1; k++) {\n            boolean notlast = k != (iu - 1);\n            if (k != im) {\n                p = matrixT[k][k - 1];\n                q = matrixT[k + 1][k - 1];\n                r = notlast ? matrixT[k + 2][k - 1] : 0.0;\n                shift.x = FastMath.abs(p) + FastMath.abs(q) + FastMath.abs(r);\n                if (!Precision.equals(shift.x, 0.0, epsilon)) {\n                    p = p / shift.x;\n                    q = q / shift.x;\n                    r = r / shift.x;\n                }\n            }\n            if (shift.x == 0.0) {\n                break;\n            }\n            double s = FastMath.sqrt(p * p + q * q + r * r);\n            if (p < 0.0) {\n                s = -s;\n            }\n            if (s != 0.0) {\n                if (k != im) {\n                    matrixT[k][k - 1] = -s * shift.x;\n                } else if (il != im) {\nmatrixT[k].[(k - 1)] = epsilon;\n                }\n                p = p + s;\n                shift.x = p / s;\n                shift.y = q / s;\n                double z = r / s;\n                q = q / p;\n                r = r / p;\n\n                // Row modification\n                for (int j = k; j < n; j++) {\n                    p = matrixT[k][j] + q * matrixT[k + 1][j];\n                    if (notlast) {\n                        p = p + r * matrixT[k + 2][j];\n                        matrixT[k + 2][j] = matrixT[k + 2][j] - p * z;\n                    }\n                    matrixT[k][j] = matrixT[k][j] - p * shift.x;\n                    matrixT[k + 1][j] = matrixT[k + 1][j] - p * shift.y;\n                }\n\n                // Column modification\n                for (int i = 0; i <= FastMath.min(iu, k + 3); i++) {\n                    p = shift.x * matrixT[i][k] + shift.y * matrixT[i][k + 1];\n                    if (notlast) {\n                        p = p + z * matrixT[i][k + 2];\n                        matrixT[i][k + 2] = matrixT[i][k + 2] - p * r;\n                    }\n                    matrixT[i][k] = matrixT[i][k] - p;\n                    matrixT[i][k + 1] = matrixT[i][k + 1] - p * q;\n                }\n\n                // Accumulate transformations\n                final int high = matrixT.length - 1;\n                for (int i = 0; i <= high; i++) {\n                    p = shift.x * matrixP[i][k] + shift.y * matrixP[i][k + 1];\n                    if (notlast) {\n                        p = p + z * matrixP[i][k + 2];\n                        matrixP[i][k + 2] = matrixP[i][k + 2] - p * r;\n                    }\n                    matrixP[i][k] = matrixP[i][k] - p;\n                    matrixP[i][k + 1] = matrixP[i][k + 1] - p * q;\n                }\n            }  // (s != 0)\n        }  // k loop\n\n        // clean up pollution due to round-off errors\n        for (int i = im + 2; i <= iu; i++) {\n            matrixT[i][i-2] = 0.0;\n            if (i > im + 2) {\n                matrixT[i][i-3] = 0.0;\n            }\n        }\n    }",
          "54": "    private void performDoubleQRStep(final int il, final int im, final int iu,\n                                     final ShiftInfo shift, final double[] hVec) {\n\n        final int n = matrixT.length;\n        double p = hVec[0];\n        double q = hVec[1];\n        double r = hVec[2];\n\n        for (int k = im; k <= iu - 1; k++) {\n            boolean notlast = k != (iu - 1);\n            if (k != im) {\n                p = matrixT[k][k - 1];\n                q = matrixT[k + 1][k - 1];\n                r = notlast ? matrixT[k + 2][k - 1] : 0.0;\n                shift.x = FastMath.abs(p) + FastMath.abs(q) + FastMath.abs(r);\n                if (!Precision.equals(shift.x, 0.0, epsilon)) {\n                    p = p / shift.x;\n                    q = q / shift.x;\n                    r = r / shift.x;\n                }\n            }\n            if (shift.x == 0.0) {\n                break;\n            }\n            double s = FastMath.sqrt(p * p + q * q + r * r);\n            if (p < 0.0) {\n                s = -s;\n            }\n            if (s != 0.0) {\n                if (k != im) {\n                    matrixT[k][k - 1] = -s * shift.x;\n                } else if (il != im) {\nmatrixT[k].[(k - 1)] = x;\n                }\n                p = p + s;\n                shift.x = p / s;\n                shift.y = q / s;\n                double z = r / s;\n                q = q / p;\n                r = r / p;\n\n                // Row modification\n                for (int j = k; j < n; j++) {\n                    p = matrixT[k][j] + q * matrixT[k + 1][j];\n                    if (notlast) {\n                        p = p + r * matrixT[k + 2][j];\n                        matrixT[k + 2][j] = matrixT[k + 2][j] - p * z;\n                    }\n                    matrixT[k][j] = matrixT[k][j] - p * shift.x;\n                    matrixT[k + 1][j] = matrixT[k + 1][j] - p * shift.y;\n                }\n\n                // Column modification\n                for (int i = 0; i <= FastMath.min(iu, k + 3); i++) {\n                    p = shift.x * matrixT[i][k] + shift.y * matrixT[i][k + 1];\n                    if (notlast) {\n                        p = p + z * matrixT[i][k + 2];\n                        matrixT[i][k + 2] = matrixT[i][k + 2] - p * r;\n                    }\n                    matrixT[i][k] = matrixT[i][k] - p;\n                    matrixT[i][k + 1] = matrixT[i][k + 1] - p * q;\n                }\n\n                // Accumulate transformations\n                final int high = matrixT.length - 1;\n                for (int i = 0; i <= high; i++) {\n                    p = shift.x * matrixP[i][k] + shift.y * matrixP[i][k + 1];\n                    if (notlast) {\n                        p = p + z * matrixP[i][k + 2];\n                        matrixP[i][k + 2] = matrixP[i][k + 2] - p * r;\n                    }\n                    matrixP[i][k] = matrixP[i][k] - p;\n                    matrixP[i][k + 1] = matrixP[i][k + 1] - p * q;\n                }\n            }  // (s != 0)\n        }  // k loop\n\n        // clean up pollution due to round-off errors\n        for (int i = im + 2; i <= iu; i++) {\n            matrixT[i][i-2] = 0.0;\n            if (i > im + 2) {\n                matrixT[i][i-3] = 0.0;\n            }\n        }\n    }",
          "55": "    private void performDoubleQRStep(final int il, final int im, final int iu,\n                                     final ShiftInfo shift, final double[] hVec) {\n\n        final int n = matrixT.length;\n        double p = hVec[0];\n        double q = hVec[1];\n        double r = hVec[2];\n\n        for (int k = im; k <= iu - 1; k++) {\n            boolean notlast = k != (iu - 1);\n            if (k != im) {\n                p = matrixT[k][k - 1];\n                q = matrixT[k + 1][k - 1];\n                r = notlast ? matrixT[k + 2][k - 1] : 0.0;\n                shift.x = FastMath.abs(p) + FastMath.abs(q) + FastMath.abs(r);\n                if (!Precision.equals(shift.x, 0.0, epsilon)) {\n                    p = p / shift.x;\n                    q = q / shift.x;\n                    r = r / shift.x;\n                }\n            }\n            if (shift.x == 0.0) {\n                break;\n            }\n            double s = FastMath.sqrt(p * p + q * q + r * r);\n            if (p < 0.0) {\n                s = -s;\n            }\n            if (s != 0.0) {\n                if (k != im) {\n                    matrixT[k][k - 1] = -s * shift.x;\n                } else if (il != im) {\nmatrixT[k].[(k - 1)] = y;\n                }\n                p = p + s;\n                shift.x = p / s;\n                shift.y = q / s;\n                double z = r / s;\n                q = q / p;\n                r = r / p;\n\n                // Row modification\n                for (int j = k; j < n; j++) {\n                    p = matrixT[k][j] + q * matrixT[k + 1][j];\n                    if (notlast) {\n                        p = p + r * matrixT[k + 2][j];\n                        matrixT[k + 2][j] = matrixT[k + 2][j] - p * z;\n                    }\n                    matrixT[k][j] = matrixT[k][j] - p * shift.x;\n                    matrixT[k + 1][j] = matrixT[k + 1][j] - p * shift.y;\n                }\n\n                // Column modification\n                for (int i = 0; i <= FastMath.min(iu, k + 3); i++) {\n                    p = shift.x * matrixT[i][k] + shift.y * matrixT[i][k + 1];\n                    if (notlast) {\n                        p = p + z * matrixT[i][k + 2];\n                        matrixT[i][k + 2] = matrixT[i][k + 2] - p * r;\n                    }\n                    matrixT[i][k] = matrixT[i][k] - p;\n                    matrixT[i][k + 1] = matrixT[i][k + 1] - p * q;\n                }\n\n                // Accumulate transformations\n                final int high = matrixT.length - 1;\n                for (int i = 0; i <= high; i++) {\n                    p = shift.x * matrixP[i][k] + shift.y * matrixP[i][k + 1];\n                    if (notlast) {\n                        p = p + z * matrixP[i][k + 2];\n                        matrixP[i][k + 2] = matrixP[i][k + 2] - p * r;\n                    }\n                    matrixP[i][k] = matrixP[i][k] - p;\n                    matrixP[i][k + 1] = matrixP[i][k + 1] - p * q;\n                }\n            }  // (s != 0)\n        }  // k loop\n\n        // clean up pollution due to round-off errors\n        for (int i = im + 2; i <= iu; i++) {\n            matrixT[i][i-2] = 0.0;\n            if (i > im + 2) {\n                matrixT[i][i-3] = 0.0;\n            }\n        }\n    }",
          "56": "    private void performDoubleQRStep(final int il, final int im, final int iu,\n                                     final ShiftInfo shift, final double[] hVec) {\n\n        final int n = matrixT.length;\n        double p = hVec[0];\n        double q = hVec[1];\n        double r = hVec[2];\n\n        for (int k = im; k <= iu - 1; k++) {\n            boolean notlast = k != (iu - 1);\n            if (k != im) {\n                p = matrixT[k][k - 1];\n                q = matrixT[k + 1][k - 1];\n                r = notlast ? matrixT[k + 2][k - 1] : 0.0;\n                shift.x = FastMath.abs(p) + FastMath.abs(q) + FastMath.abs(r);\n                if (!Precision.equals(shift.x, 0.0, epsilon)) {\n                    p = p / shift.x;\n                    q = q / shift.x;\n                    r = r / shift.x;\n                }\n            }\n            if (shift.x == 0.0) {\n                break;\n            }\n            double s = FastMath.sqrt(p * p + q * q + r * r);\n            if (p < 0.0) {\n                s = -s;\n            }\n            if (s != 0.0) {\n                if (k != im) {\n                    matrixT[k][k - 1] = -s * shift.x;\n                } else if (il != im) {\nmatrixT[k].[(k - 1)] = w;\n                }\n                p = p + s;\n                shift.x = p / s;\n                shift.y = q / s;\n                double z = r / s;\n                q = q / p;\n                r = r / p;\n\n                // Row modification\n                for (int j = k; j < n; j++) {\n                    p = matrixT[k][j] + q * matrixT[k + 1][j];\n                    if (notlast) {\n                        p = p + r * matrixT[k + 2][j];\n                        matrixT[k + 2][j] = matrixT[k + 2][j] - p * z;\n                    }\n                    matrixT[k][j] = matrixT[k][j] - p * shift.x;\n                    matrixT[k + 1][j] = matrixT[k + 1][j] - p * shift.y;\n                }\n\n                // Column modification\n                for (int i = 0; i <= FastMath.min(iu, k + 3); i++) {\n                    p = shift.x * matrixT[i][k] + shift.y * matrixT[i][k + 1];\n                    if (notlast) {\n                        p = p + z * matrixT[i][k + 2];\n                        matrixT[i][k + 2] = matrixT[i][k + 2] - p * r;\n                    }\n                    matrixT[i][k] = matrixT[i][k] - p;\n                    matrixT[i][k + 1] = matrixT[i][k + 1] - p * q;\n                }\n\n                // Accumulate transformations\n                final int high = matrixT.length - 1;\n                for (int i = 0; i <= high; i++) {\n                    p = shift.x * matrixP[i][k] + shift.y * matrixP[i][k + 1];\n                    if (notlast) {\n                        p = p + z * matrixP[i][k + 2];\n                        matrixP[i][k + 2] = matrixP[i][k + 2] - p * r;\n                    }\n                    matrixP[i][k] = matrixP[i][k] - p;\n                    matrixP[i][k + 1] = matrixP[i][k + 1] - p * q;\n                }\n            }  // (s != 0)\n        }  // k loop\n\n        // clean up pollution due to round-off errors\n        for (int i = im + 2; i <= iu; i++) {\n            matrixT[i][i-2] = 0.0;\n            if (i > im + 2) {\n                matrixT[i][i-3] = 0.0;\n            }\n        }\n    }",
          "57": "    private void performDoubleQRStep(final int il, final int im, final int iu,\n                                     final ShiftInfo shift, final double[] hVec) {\n\n        final int n = matrixT.length;\n        double p = hVec[0];\n        double q = hVec[1];\n        double r = hVec[2];\n\n        for (int k = im; k <= iu - 1; k++) {\n            boolean notlast = k != (iu - 1);\n            if (k != im) {\n                p = matrixT[k][k - 1];\n                q = matrixT[k + 1][k - 1];\n                r = notlast ? matrixT[k + 2][k - 1] : 0.0;\n                shift.x = FastMath.abs(p) + FastMath.abs(q) + FastMath.abs(r);\n                if (!Precision.equals(shift.x, 0.0, epsilon)) {\n                    p = p / shift.x;\n                    q = q / shift.x;\n                    r = r / shift.x;\n                }\n            }\n            if (shift.x == 0.0) {\n                break;\n            }\n            double s = FastMath.sqrt(p * p + q * q + r * r);\n            if (p < 0.0) {\n                s = -s;\n            }\n            if (s != 0.0) {\n                if (k != im) {\n                    matrixT[k][k - 1] = -s * shift.x;\n                } else if (il != im) {\nmatrixT[k].[(k - 1)] = exShift;\n                }\n                p = p + s;\n                shift.x = p / s;\n                shift.y = q / s;\n                double z = r / s;\n                q = q / p;\n                r = r / p;\n\n                // Row modification\n                for (int j = k; j < n; j++) {\n                    p = matrixT[k][j] + q * matrixT[k + 1][j];\n                    if (notlast) {\n                        p = p + r * matrixT[k + 2][j];\n                        matrixT[k + 2][j] = matrixT[k + 2][j] - p * z;\n                    }\n                    matrixT[k][j] = matrixT[k][j] - p * shift.x;\n                    matrixT[k + 1][j] = matrixT[k + 1][j] - p * shift.y;\n                }\n\n                // Column modification\n                for (int i = 0; i <= FastMath.min(iu, k + 3); i++) {\n                    p = shift.x * matrixT[i][k] + shift.y * matrixT[i][k + 1];\n                    if (notlast) {\n                        p = p + z * matrixT[i][k + 2];\n                        matrixT[i][k + 2] = matrixT[i][k + 2] - p * r;\n                    }\n                    matrixT[i][k] = matrixT[i][k] - p;\n                    matrixT[i][k + 1] = matrixT[i][k + 1] - p * q;\n                }\n\n                // Accumulate transformations\n                final int high = matrixT.length - 1;\n                for (int i = 0; i <= high; i++) {\n                    p = shift.x * matrixP[i][k] + shift.y * matrixP[i][k + 1];\n                    if (notlast) {\n                        p = p + z * matrixP[i][k + 2];\n                        matrixP[i][k + 2] = matrixP[i][k + 2] - p * r;\n                    }\n                    matrixP[i][k] = matrixP[i][k] - p;\n                    matrixP[i][k + 1] = matrixP[i][k + 1] - p * q;\n                }\n            }  // (s != 0)\n        }  // k loop\n\n        // clean up pollution due to round-off errors\n        for (int i = im + 2; i <= iu; i++) {\n            matrixT[i][i-2] = 0.0;\n            if (i > im + 2) {\n                matrixT[i][i-3] = 0.0;\n            }\n        }\n    }",
          "58": "    private void performDoubleQRStep(final int il, final int im, final int iu,\n                                     final ShiftInfo shift, final double[] hVec) {\n\n        final int n = matrixT.length;\n        double p = hVec[0];\n        double q = hVec[1];\n        double r = hVec[2];\n\n        for (int k = im; k <= iu - 1; k++) {\n            boolean notlast = k != (iu - 1);\n            if (k != im) {\n                p = matrixT[k][k - 1];\n                q = matrixT[k + 1][k - 1];\n                r = notlast ? matrixT[k + 2][k - 1] : 0.0;\n                shift.x = FastMath.abs(p) + FastMath.abs(q) + FastMath.abs(r);\n                if (!Precision.equals(shift.x, 0.0, epsilon)) {\n                    p = p / shift.x;\n                    q = q / shift.x;\n                    r = r / shift.x;\n                }\n            }\n            if (shift.x == 0.0) {\n                break;\n            }\n            double s = FastMath.sqrt(p * p + q * q + r * r);\n            if (p < 0.0) {\n                s = -s;\n            }\n            if (s != 0.0) {\n                if (k != im) {\n                    matrixT[k][k - 1] = -s * shift.x;\n                } else if (il != im) {\nmatrixT[k].[(k - 1)] = +matrixT[k].[(k / 1)];\n                }\n                p = p + s;\n                shift.x = p / s;\n                shift.y = q / s;\n                double z = r / s;\n                q = q / p;\n                r = r / p;\n\n                // Row modification\n                for (int j = k; j < n; j++) {\n                    p = matrixT[k][j] + q * matrixT[k + 1][j];\n                    if (notlast) {\n                        p = p + r * matrixT[k + 2][j];\n                        matrixT[k + 2][j] = matrixT[k + 2][j] - p * z;\n                    }\n                    matrixT[k][j] = matrixT[k][j] - p * shift.x;\n                    matrixT[k + 1][j] = matrixT[k + 1][j] - p * shift.y;\n                }\n\n                // Column modification\n                for (int i = 0; i <= FastMath.min(iu, k + 3); i++) {\n                    p = shift.x * matrixT[i][k] + shift.y * matrixT[i][k + 1];\n                    if (notlast) {\n                        p = p + z * matrixT[i][k + 2];\n                        matrixT[i][k + 2] = matrixT[i][k + 2] - p * r;\n                    }\n                    matrixT[i][k] = matrixT[i][k] - p;\n                    matrixT[i][k + 1] = matrixT[i][k + 1] - p * q;\n                }\n\n                // Accumulate transformations\n                final int high = matrixT.length - 1;\n                for (int i = 0; i <= high; i++) {\n                    p = shift.x * matrixP[i][k] + shift.y * matrixP[i][k + 1];\n                    if (notlast) {\n                        p = p + z * matrixP[i][k + 2];\n                        matrixP[i][k + 2] = matrixP[i][k + 2] - p * r;\n                    }\n                    matrixP[i][k] = matrixP[i][k] - p;\n                    matrixP[i][k + 1] = matrixP[i][k + 1] - p * q;\n                }\n            }  // (s != 0)\n        }  // k loop\n\n        // clean up pollution due to round-off errors\n        for (int i = im + 2; i <= iu; i++) {\n            matrixT[i][i-2] = 0.0;\n            if (i > im + 2) {\n                matrixT[i][i-3] = 0.0;\n            }\n        }\n    }",
          "59": "    private void performDoubleQRStep(final int il, final int im, final int iu,\n                                     final ShiftInfo shift, final double[] hVec) {\n\n        final int n = matrixT.length;\n        double p = hVec[0];\n        double q = hVec[1];\n        double r = hVec[2];\n\n        for (int k = im; k <= iu - 1; k++) {\n            boolean notlast = k != (iu - 1);\n            if (k != im) {\n                p = matrixT[k][k - 1];\n                q = matrixT[k + 1][k - 1];\n                r = notlast ? matrixT[k + 2][k - 1] : 0.0;\n                shift.x = FastMath.abs(p) + FastMath.abs(q) + FastMath.abs(r);\n                if (!Precision.equals(shift.x, 0.0, epsilon)) {\n                    p = p / shift.x;\n                    q = q / shift.x;\n                    r = r / shift.x;\n                }\n            }\n            if (shift.x == 0.0) {\n                break;\n            }\n            double s = FastMath.sqrt(p * p + q * q + r * r);\n            if (p < 0.0) {\n                s = -s;\n            }\n            if (s != 0.0) {\n                if (k != im) {\n                    matrixT[k][k - 1] = -s * shift.x;\n                } else if (il != im) {\nmatrixT[k].[(k - 1)] = +matrixT[k].[(k <= 1)];\n                }\n                p = p + s;\n                shift.x = p / s;\n                shift.y = q / s;\n                double z = r / s;\n                q = q / p;\n                r = r / p;\n\n                // Row modification\n                for (int j = k; j < n; j++) {\n                    p = matrixT[k][j] + q * matrixT[k + 1][j];\n                    if (notlast) {\n                        p = p + r * matrixT[k + 2][j];\n                        matrixT[k + 2][j] = matrixT[k + 2][j] - p * z;\n                    }\n                    matrixT[k][j] = matrixT[k][j] - p * shift.x;\n                    matrixT[k + 1][j] = matrixT[k + 1][j] - p * shift.y;\n                }\n\n                // Column modification\n                for (int i = 0; i <= FastMath.min(iu, k + 3); i++) {\n                    p = shift.x * matrixT[i][k] + shift.y * matrixT[i][k + 1];\n                    if (notlast) {\n                        p = p + z * matrixT[i][k + 2];\n                        matrixT[i][k + 2] = matrixT[i][k + 2] - p * r;\n                    }\n                    matrixT[i][k] = matrixT[i][k] - p;\n                    matrixT[i][k + 1] = matrixT[i][k + 1] - p * q;\n                }\n\n                // Accumulate transformations\n                final int high = matrixT.length - 1;\n                for (int i = 0; i <= high; i++) {\n                    p = shift.x * matrixP[i][k] + shift.y * matrixP[i][k + 1];\n                    if (notlast) {\n                        p = p + z * matrixP[i][k + 2];\n                        matrixP[i][k + 2] = matrixP[i][k + 2] - p * r;\n                    }\n                    matrixP[i][k] = matrixP[i][k] - p;\n                    matrixP[i][k + 1] = matrixP[i][k + 1] - p * q;\n                }\n            }  // (s != 0)\n        }  // k loop\n\n        // clean up pollution due to round-off errors\n        for (int i = im + 2; i <= iu; i++) {\n            matrixT[i][i-2] = 0.0;\n            if (i > im + 2) {\n                matrixT[i][i-3] = 0.0;\n            }\n        }\n    }",
          "60": "    private void performDoubleQRStep(final int il, final int im, final int iu,\n                                     final ShiftInfo shift, final double[] hVec) {\n\n        final int n = matrixT.length;\n        double p = hVec[0];\n        double q = hVec[1];\n        double r = hVec[2];\n\n        for (int k = im; k <= iu - 1; k++) {\n            boolean notlast = k != (iu - 1);\n            if (k != im) {\n                p = matrixT[k][k - 1];\n                q = matrixT[k + 1][k - 1];\n                r = notlast ? matrixT[k + 2][k - 1] : 0.0;\n                shift.x = FastMath.abs(p) + FastMath.abs(q) + FastMath.abs(r);\n                if (!Precision.equals(shift.x, 0.0, epsilon)) {\n                    p = p / shift.x;\n                    q = q / shift.x;\n                    r = r / shift.x;\n                }\n            }\n            if (shift.x == 0.0) {\n                break;\n            }\n            double s = FastMath.sqrt(p * p + q * q + r * r);\n            if (p < 0.0) {\n                s = -s;\n            }\n            if (s != 0.0) {\n                if (k != im) {\n                    matrixT[k][k - 1] = -s * shift.x;\n                } else if (il != im) {\nmatrixT[k].[(k - 1)] = +matrixT[k].[(k * 1)];\n                }\n                p = p + s;\n                shift.x = p / s;\n                shift.y = q / s;\n                double z = r / s;\n                q = q / p;\n                r = r / p;\n\n                // Row modification\n                for (int j = k; j < n; j++) {\n                    p = matrixT[k][j] + q * matrixT[k + 1][j];\n                    if (notlast) {\n                        p = p + r * matrixT[k + 2][j];\n                        matrixT[k + 2][j] = matrixT[k + 2][j] - p * z;\n                    }\n                    matrixT[k][j] = matrixT[k][j] - p * shift.x;\n                    matrixT[k + 1][j] = matrixT[k + 1][j] - p * shift.y;\n                }\n\n                // Column modification\n                for (int i = 0; i <= FastMath.min(iu, k + 3); i++) {\n                    p = shift.x * matrixT[i][k] + shift.y * matrixT[i][k + 1];\n                    if (notlast) {\n                        p = p + z * matrixT[i][k + 2];\n                        matrixT[i][k + 2] = matrixT[i][k + 2] - p * r;\n                    }\n                    matrixT[i][k] = matrixT[i][k] - p;\n                    matrixT[i][k + 1] = matrixT[i][k + 1] - p * q;\n                }\n\n                // Accumulate transformations\n                final int high = matrixT.length - 1;\n                for (int i = 0; i <= high; i++) {\n                    p = shift.x * matrixP[i][k] + shift.y * matrixP[i][k + 1];\n                    if (notlast) {\n                        p = p + z * matrixP[i][k + 2];\n                        matrixP[i][k + 2] = matrixP[i][k + 2] - p * r;\n                    }\n                    matrixP[i][k] = matrixP[i][k] - p;\n                    matrixP[i][k + 1] = matrixP[i][k + 1] - p * q;\n                }\n            }  // (s != 0)\n        }  // k loop\n\n        // clean up pollution due to round-off errors\n        for (int i = im + 2; i <= iu; i++) {\n            matrixT[i][i-2] = 0.0;\n            if (i > im + 2) {\n                matrixT[i][i-3] = 0.0;\n            }\n        }\n    }",
          "61": "    private void performDoubleQRStep(final int il, final int im, final int iu,\n                                     final ShiftInfo shift, final double[] hVec) {\n\n        final int n = matrixT.length;\n        double p = hVec[0];\n        double q = hVec[1];\n        double r = hVec[2];\n\n        for (int k = im; k <= iu - 1; k++) {\n            boolean notlast = k != (iu - 1);\n            if (k != im) {\n                p = matrixT[k][k - 1];\n                q = matrixT[k + 1][k - 1];\n                r = notlast ? matrixT[k + 2][k - 1] : 0.0;\n                shift.x = FastMath.abs(p) + FastMath.abs(q) + FastMath.abs(r);\n                if (!Precision.equals(shift.x, 0.0, epsilon)) {\n                    p = p / shift.x;\n                    q = q / shift.x;\n                    r = r / shift.x;\n                }\n            }\n            if (shift.x == 0.0) {\n                break;\n            }\n            double s = FastMath.sqrt(p * p + q * q + r * r);\n            if (p < 0.0) {\n                s = -s;\n            }\n            if (s != 0.0) {\n                if (k != im) {\n                    matrixT[k][k - 1] = -s * shift.x;\n                } else if (il != im) {\nmatrixT[k].[(k - 1)] = +matrixT[k].[(k == 1)];\n                }\n                p = p + s;\n                shift.x = p / s;\n                shift.y = q / s;\n                double z = r / s;\n                q = q / p;\n                r = r / p;\n\n                // Row modification\n                for (int j = k; j < n; j++) {\n                    p = matrixT[k][j] + q * matrixT[k + 1][j];\n                    if (notlast) {\n                        p = p + r * matrixT[k + 2][j];\n                        matrixT[k + 2][j] = matrixT[k + 2][j] - p * z;\n                    }\n                    matrixT[k][j] = matrixT[k][j] - p * shift.x;\n                    matrixT[k + 1][j] = matrixT[k + 1][j] - p * shift.y;\n                }\n\n                // Column modification\n                for (int i = 0; i <= FastMath.min(iu, k + 3); i++) {\n                    p = shift.x * matrixT[i][k] + shift.y * matrixT[i][k + 1];\n                    if (notlast) {\n                        p = p + z * matrixT[i][k + 2];\n                        matrixT[i][k + 2] = matrixT[i][k + 2] - p * r;\n                    }\n                    matrixT[i][k] = matrixT[i][k] - p;\n                    matrixT[i][k + 1] = matrixT[i][k + 1] - p * q;\n                }\n\n                // Accumulate transformations\n                final int high = matrixT.length - 1;\n                for (int i = 0; i <= high; i++) {\n                    p = shift.x * matrixP[i][k] + shift.y * matrixP[i][k + 1];\n                    if (notlast) {\n                        p = p + z * matrixP[i][k + 2];\n                        matrixP[i][k + 2] = matrixP[i][k + 2] - p * r;\n                    }\n                    matrixP[i][k] = matrixP[i][k] - p;\n                    matrixP[i][k + 1] = matrixP[i][k + 1] - p * q;\n                }\n            }  // (s != 0)\n        }  // k loop\n\n        // clean up pollution due to round-off errors\n        for (int i = im + 2; i <= iu; i++) {\n            matrixT[i][i-2] = 0.0;\n            if (i > im + 2) {\n                matrixT[i][i-3] = 0.0;\n            }\n        }\n    }",
          "62": "    private void performDoubleQRStep(final int il, final int im, final int iu,\n                                     final ShiftInfo shift, final double[] hVec) {\n\n        final int n = matrixT.length;\n        double p = hVec[0];\n        double q = hVec[1];\n        double r = hVec[2];\n\n        for (int k = im; k <= iu - 1; k++) {\n            boolean notlast = k != (iu - 1);\n            if (k != im) {\n                p = matrixT[k][k - 1];\n                q = matrixT[k + 1][k - 1];\n                r = notlast ? matrixT[k + 2][k - 1] : 0.0;\n                shift.x = FastMath.abs(p) + FastMath.abs(q) + FastMath.abs(r);\n                if (!Precision.equals(shift.x, 0.0, epsilon)) {\n                    p = p / shift.x;\n                    q = q / shift.x;\n                    r = r / shift.x;\n                }\n            }\n            if (shift.x == 0.0) {\n                break;\n            }\n            double s = FastMath.sqrt(p * p + q * q + r * r);\n            if (p < 0.0) {\n                s = -s;\n            }\n            if (s != 0.0) {\n                if (k != im) {\n                    matrixT[k][k - 1] = -s * shift.x;\n                } else if (il != im) {\ncontinue;\n                    matrixT[k][k - 1] = +matrixT[k][k - 1];                }\n                p = p + s;\n                shift.x = p / s;\n                shift.y = q / s;\n                double z = r / s;\n                q = q / p;\n                r = r / p;\n\n                // Row modification\n                for (int j = k; j < n; j++) {\n                    p = matrixT[k][j] + q * matrixT[k + 1][j];\n                    if (notlast) {\n                        p = p + r * matrixT[k + 2][j];\n                        matrixT[k + 2][j] = matrixT[k + 2][j] - p * z;\n                    }\n                    matrixT[k][j] = matrixT[k][j] - p * shift.x;\n                    matrixT[k + 1][j] = matrixT[k + 1][j] - p * shift.y;\n                }\n\n                // Column modification\n                for (int i = 0; i <= FastMath.min(iu, k + 3); i++) {\n                    p = shift.x * matrixT[i][k] + shift.y * matrixT[i][k + 1];\n                    if (notlast) {\n                        p = p + z * matrixT[i][k + 2];\n                        matrixT[i][k + 2] = matrixT[i][k + 2] - p * r;\n                    }\n                    matrixT[i][k] = matrixT[i][k] - p;\n                    matrixT[i][k + 1] = matrixT[i][k + 1] - p * q;\n                }\n\n                // Accumulate transformations\n                final int high = matrixT.length - 1;\n                for (int i = 0; i <= high; i++) {\n                    p = shift.x * matrixP[i][k] + shift.y * matrixP[i][k + 1];\n                    if (notlast) {\n                        p = p + z * matrixP[i][k + 2];\n                        matrixP[i][k + 2] = matrixP[i][k + 2] - p * r;\n                    }\n                    matrixP[i][k] = matrixP[i][k] - p;\n                    matrixP[i][k + 1] = matrixP[i][k + 1] - p * q;\n                }\n            }  // (s != 0)\n        }  // k loop\n\n        // clean up pollution due to round-off errors\n        for (int i = im + 2; i <= iu; i++) {\n            matrixT[i][i-2] = 0.0;\n            if (i > im + 2) {\n                matrixT[i][i-3] = 0.0;\n            }\n        }\n    }",
          "63": "    private void performDoubleQRStep(final int il, final int im, final int iu,\n                                     final ShiftInfo shift, final double[] hVec) {\n\n        final int n = matrixT.length;\n        double p = hVec[0];\n        double q = hVec[1];\n        double r = hVec[2];\n\n        for (int k = im; k <= iu - 1; k++) {\n            boolean notlast = k != (iu - 1);\n            if (k != im) {\n                p = matrixT[k][k - 1];\n                q = matrixT[k + 1][k - 1];\n                r = notlast ? matrixT[k + 2][k - 1] : 0.0;\n                shift.x = FastMath.abs(p) + FastMath.abs(q) + FastMath.abs(r);\n                if (!Precision.equals(shift.x, 0.0, epsilon)) {\n                    p = p / shift.x;\n                    q = q / shift.x;\n                    r = r / shift.x;\n                }\n            }\n            if (shift.x == 0.0) {\n                break;\n            }\n            double s = FastMath.sqrt(p * p + q * q + r * r);\n            if (p < 0.0) {\n                s = -s;\n            }\n            if (s != 0.0) {\n                if (k != im) {\n                    matrixT[k][k - 1] = -s * shift.x;\n                } else if (il != im) {\ndouble z = (r / s);\n                    matrixT[k][k - 1] = +matrixT[k][k - 1];                }\n                p = p + s;\n                shift.x = p / s;\n                shift.y = q / s;\n                double z = r / s;\n                q = q / p;\n                r = r / p;\n\n                // Row modification\n                for (int j = k; j < n; j++) {\n                    p = matrixT[k][j] + q * matrixT[k + 1][j];\n                    if (notlast) {\n                        p = p + r * matrixT[k + 2][j];\n                        matrixT[k + 2][j] = matrixT[k + 2][j] - p * z;\n                    }\n                    matrixT[k][j] = matrixT[k][j] - p * shift.x;\n                    matrixT[k + 1][j] = matrixT[k + 1][j] - p * shift.y;\n                }\n\n                // Column modification\n                for (int i = 0; i <= FastMath.min(iu, k + 3); i++) {\n                    p = shift.x * matrixT[i][k] + shift.y * matrixT[i][k + 1];\n                    if (notlast) {\n                        p = p + z * matrixT[i][k + 2];\n                        matrixT[i][k + 2] = matrixT[i][k + 2] - p * r;\n                    }\n                    matrixT[i][k] = matrixT[i][k] - p;\n                    matrixT[i][k + 1] = matrixT[i][k + 1] - p * q;\n                }\n\n                // Accumulate transformations\n                final int high = matrixT.length - 1;\n                for (int i = 0; i <= high; i++) {\n                    p = shift.x * matrixP[i][k] + shift.y * matrixP[i][k + 1];\n                    if (notlast) {\n                        p = p + z * matrixP[i][k + 2];\n                        matrixP[i][k + 2] = matrixP[i][k + 2] - p * r;\n                    }\n                    matrixP[i][k] = matrixP[i][k] - p;\n                    matrixP[i][k + 1] = matrixP[i][k + 1] - p * q;\n                }\n            }  // (s != 0)\n        }  // k loop\n\n        // clean up pollution due to round-off errors\n        for (int i = im + 2; i <= iu; i++) {\n            matrixT[i][i-2] = 0.0;\n            if (i > im + 2) {\n                matrixT[i][i-3] = 0.0;\n            }\n        }\n    }",
          "64": "    private void performDoubleQRStep(final int il, final int im, final int iu,\n                                     final ShiftInfo shift, final double[] hVec) {\n\n        final int n = matrixT.length;\n        double p = hVec[0];\n        double q = hVec[1];\n        double r = hVec[2];\n\n        for (int k = im; k <= iu - 1; k++) {\n            boolean notlast = k != (iu - 1);\n            if (k != im) {\n                p = matrixT[k][k - 1];\n                q = matrixT[k + 1][k - 1];\n                r = notlast ? matrixT[k + 2][k - 1] : 0.0;\n                shift.x = FastMath.abs(p) + FastMath.abs(q) + FastMath.abs(r);\n                if (!Precision.equals(shift.x, 0.0, epsilon)) {\n                    p = p / shift.x;\n                    q = q / shift.x;\n                    r = r / shift.x;\n                }\n            }\n            if (shift.x == 0.0) {\n                break;\n            }\n            double s = FastMath.sqrt(p * p + q * q + r * r);\n            if (p < 0.0) {\n                s = -s;\n            }\n            if (s != 0.0) {\n                if (k != im) {\n                    matrixT[k][k - 1] = -s * shift.x;\n                } else if (il != im) {\nmatrixT[k].[(k - 1)] = +matrixT[k].[(k >= 1)];\n                }\n                p = p + s;\n                shift.x = p / s;\n                shift.y = q / s;\n                double z = r / s;\n                q = q / p;\n                r = r / p;\n\n                // Row modification\n                for (int j = k; j < n; j++) {\n                    p = matrixT[k][j] + q * matrixT[k + 1][j];\n                    if (notlast) {\n                        p = p + r * matrixT[k + 2][j];\n                        matrixT[k + 2][j] = matrixT[k + 2][j] - p * z;\n                    }\n                    matrixT[k][j] = matrixT[k][j] - p * shift.x;\n                    matrixT[k + 1][j] = matrixT[k + 1][j] - p * shift.y;\n                }\n\n                // Column modification\n                for (int i = 0; i <= FastMath.min(iu, k + 3); i++) {\n                    p = shift.x * matrixT[i][k] + shift.y * matrixT[i][k + 1];\n                    if (notlast) {\n                        p = p + z * matrixT[i][k + 2];\n                        matrixT[i][k + 2] = matrixT[i][k + 2] - p * r;\n                    }\n                    matrixT[i][k] = matrixT[i][k] - p;\n                    matrixT[i][k + 1] = matrixT[i][k + 1] - p * q;\n                }\n\n                // Accumulate transformations\n                final int high = matrixT.length - 1;\n                for (int i = 0; i <= high; i++) {\n                    p = shift.x * matrixP[i][k] + shift.y * matrixP[i][k + 1];\n                    if (notlast) {\n                        p = p + z * matrixP[i][k + 2];\n                        matrixP[i][k + 2] = matrixP[i][k + 2] - p * r;\n                    }\n                    matrixP[i][k] = matrixP[i][k] - p;\n                    matrixP[i][k + 1] = matrixP[i][k + 1] - p * q;\n                }\n            }  // (s != 0)\n        }  // k loop\n\n        // clean up pollution due to round-off errors\n        for (int i = im + 2; i <= iu; i++) {\n            matrixT[i][i-2] = 0.0;\n            if (i > im + 2) {\n                matrixT[i][i-3] = 0.0;\n            }\n        }\n    }",
          "65": "    private void performDoubleQRStep(final int il, final int im, final int iu,\n                                     final ShiftInfo shift, final double[] hVec) {\n\n        final int n = matrixT.length;\n        double p = hVec[0];\n        double q = hVec[1];\n        double r = hVec[2];\n\n        for (int k = im; k <= iu - 1; k++) {\n            boolean notlast = k != (iu - 1);\n            if (k != im) {\n                p = matrixT[k][k - 1];\n                q = matrixT[k + 1][k - 1];\n                r = notlast ? matrixT[k + 2][k - 1] : 0.0;\n                shift.x = FastMath.abs(p) + FastMath.abs(q) + FastMath.abs(r);\n                if (!Precision.equals(shift.x, 0.0, epsilon)) {\n                    p = p / shift.x;\n                    q = q / shift.x;\n                    r = r / shift.x;\n                }\n            }\n            if (shift.x == 0.0) {\n                break;\n            }\n            double s = FastMath.sqrt(p * p + q * q + r * r);\n            if (p < 0.0) {\n                s = -s;\n            }\n            if (s != 0.0) {\n                if (k != im) {\n                    matrixT[k][k - 1] = -s * shift.x;\n                } else if (il != im) {\nmatrixT[k].[(k - 1)] = (matrixT[k].[(k - 1)] + matrixT[k].[(k - 1)]);\n                }\n                p = p + s;\n                shift.x = p / s;\n                shift.y = q / s;\n                double z = r / s;\n                q = q / p;\n                r = r / p;\n\n                // Row modification\n                for (int j = k; j < n; j++) {\n                    p = matrixT[k][j] + q * matrixT[k + 1][j];\n                    if (notlast) {\n                        p = p + r * matrixT[k + 2][j];\n                        matrixT[k + 2][j] = matrixT[k + 2][j] - p * z;\n                    }\n                    matrixT[k][j] = matrixT[k][j] - p * shift.x;\n                    matrixT[k + 1][j] = matrixT[k + 1][j] - p * shift.y;\n                }\n\n                // Column modification\n                for (int i = 0; i <= FastMath.min(iu, k + 3); i++) {\n                    p = shift.x * matrixT[i][k] + shift.y * matrixT[i][k + 1];\n                    if (notlast) {\n                        p = p + z * matrixT[i][k + 2];\n                        matrixT[i][k + 2] = matrixT[i][k + 2] - p * r;\n                    }\n                    matrixT[i][k] = matrixT[i][k] - p;\n                    matrixT[i][k + 1] = matrixT[i][k + 1] - p * q;\n                }\n\n                // Accumulate transformations\n                final int high = matrixT.length - 1;\n                for (int i = 0; i <= high; i++) {\n                    p = shift.x * matrixP[i][k] + shift.y * matrixP[i][k + 1];\n                    if (notlast) {\n                        p = p + z * matrixP[i][k + 2];\n                        matrixP[i][k + 2] = matrixP[i][k + 2] - p * r;\n                    }\n                    matrixP[i][k] = matrixP[i][k] - p;\n                    matrixP[i][k + 1] = matrixP[i][k + 1] - p * q;\n                }\n            }  // (s != 0)\n        }  // k loop\n\n        // clean up pollution due to round-off errors\n        for (int i = im + 2; i <= iu; i++) {\n            matrixT[i][i-2] = 0.0;\n            if (i > im + 2) {\n                matrixT[i][i-3] = 0.0;\n            }\n        }\n    }",
          "66": "    private void performDoubleQRStep(final int il, final int im, final int iu,\n                                     final ShiftInfo shift, final double[] hVec) {\n\n        final int n = matrixT.length;\n        double p = hVec[0];\n        double q = hVec[1];\n        double r = hVec[2];\n\n        for (int k = im; k <= iu - 1; k++) {\n            boolean notlast = k != (iu - 1);\n            if (k != im) {\n                p = matrixT[k][k - 1];\n                q = matrixT[k + 1][k - 1];\n                r = notlast ? matrixT[k + 2][k - 1] : 0.0;\n                shift.x = FastMath.abs(p) + FastMath.abs(q) + FastMath.abs(r);\n                if (!Precision.equals(shift.x, 0.0, epsilon)) {\n                    p = p / shift.x;\n                    q = q / shift.x;\n                    r = r / shift.x;\n                }\n            }\n            if (shift.x == 0.0) {\n                break;\n            }\n            double s = FastMath.sqrt(p * p + q * q + r * r);\n            if (p < 0.0) {\n                s = -s;\n            }\n            if (s != 0.0) {\n                if (k != im) {\n                    matrixT[k][k - 1] = -s * shift.x;\n                } else if (il != im) {\nmatrixT[k].[(k - 1)] = +matrixT[k].[(k % 1)];\n                }\n                p = p + s;\n                shift.x = p / s;\n                shift.y = q / s;\n                double z = r / s;\n                q = q / p;\n                r = r / p;\n\n                // Row modification\n                for (int j = k; j < n; j++) {\n                    p = matrixT[k][j] + q * matrixT[k + 1][j];\n                    if (notlast) {\n                        p = p + r * matrixT[k + 2][j];\n                        matrixT[k + 2][j] = matrixT[k + 2][j] - p * z;\n                    }\n                    matrixT[k][j] = matrixT[k][j] - p * shift.x;\n                    matrixT[k + 1][j] = matrixT[k + 1][j] - p * shift.y;\n                }\n\n                // Column modification\n                for (int i = 0; i <= FastMath.min(iu, k + 3); i++) {\n                    p = shift.x * matrixT[i][k] + shift.y * matrixT[i][k + 1];\n                    if (notlast) {\n                        p = p + z * matrixT[i][k + 2];\n                        matrixT[i][k + 2] = matrixT[i][k + 2] - p * r;\n                    }\n                    matrixT[i][k] = matrixT[i][k] - p;\n                    matrixT[i][k + 1] = matrixT[i][k + 1] - p * q;\n                }\n\n                // Accumulate transformations\n                final int high = matrixT.length - 1;\n                for (int i = 0; i <= high; i++) {\n                    p = shift.x * matrixP[i][k] + shift.y * matrixP[i][k + 1];\n                    if (notlast) {\n                        p = p + z * matrixP[i][k + 2];\n                        matrixP[i][k + 2] = matrixP[i][k + 2] - p * r;\n                    }\n                    matrixP[i][k] = matrixP[i][k] - p;\n                    matrixP[i][k + 1] = matrixP[i][k + 1] - p * q;\n                }\n            }  // (s != 0)\n        }  // k loop\n\n        // clean up pollution due to round-off errors\n        for (int i = im + 2; i <= iu; i++) {\n            matrixT[i][i-2] = 0.0;\n            if (i > im + 2) {\n                matrixT[i][i-3] = 0.0;\n            }\n        }\n    }",
          "67": "    private void performDoubleQRStep(final int il, final int im, final int iu,\n                                     final ShiftInfo shift, final double[] hVec) {\n\n        final int n = matrixT.length;\n        double p = hVec[0];\n        double q = hVec[1];\n        double r = hVec[2];\n\n        for (int k = im; k <= iu - 1; k++) {\n            boolean notlast = k != (iu - 1);\n            if (k != im) {\n                p = matrixT[k][k - 1];\n                q = matrixT[k + 1][k - 1];\n                r = notlast ? matrixT[k + 2][k - 1] : 0.0;\n                shift.x = FastMath.abs(p) + FastMath.abs(q) + FastMath.abs(r);\n                if (!Precision.equals(shift.x, 0.0, epsilon)) {\n                    p = p / shift.x;\n                    q = q / shift.x;\n                    r = r / shift.x;\n                }\n            }\n            if (shift.x == 0.0) {\n                break;\n            }\n            double s = FastMath.sqrt(p * p + q * q + r * r);\n            if (p < 0.0) {\n                s = -s;\n            }\n            if (s != 0.0) {\n                if (k != im) {\n                    matrixT[k][k - 1] = -s * shift.x;\n                } else if (il != im) {\np = (matrixT[k].[(k - 1)] + matrixT[k].[(k - 1)]);\n                }\n                p = p + s;\n                shift.x = p / s;\n                shift.y = q / s;\n                double z = r / s;\n                q = q / p;\n                r = r / p;\n\n                // Row modification\n                for (int j = k; j < n; j++) {\n                    p = matrixT[k][j] + q * matrixT[k + 1][j];\n                    if (notlast) {\n                        p = p + r * matrixT[k + 2][j];\n                        matrixT[k + 2][j] = matrixT[k + 2][j] - p * z;\n                    }\n                    matrixT[k][j] = matrixT[k][j] - p * shift.x;\n                    matrixT[k + 1][j] = matrixT[k + 1][j] - p * shift.y;\n                }\n\n                // Column modification\n                for (int i = 0; i <= FastMath.min(iu, k + 3); i++) {\n                    p = shift.x * matrixT[i][k] + shift.y * matrixT[i][k + 1];\n                    if (notlast) {\n                        p = p + z * matrixT[i][k + 2];\n                        matrixT[i][k + 2] = matrixT[i][k + 2] - p * r;\n                    }\n                    matrixT[i][k] = matrixT[i][k] - p;\n                    matrixT[i][k + 1] = matrixT[i][k + 1] - p * q;\n                }\n\n                // Accumulate transformations\n                final int high = matrixT.length - 1;\n                for (int i = 0; i <= high; i++) {\n                    p = shift.x * matrixP[i][k] + shift.y * matrixP[i][k + 1];\n                    if (notlast) {\n                        p = p + z * matrixP[i][k + 2];\n                        matrixP[i][k + 2] = matrixP[i][k + 2] - p * r;\n                    }\n                    matrixP[i][k] = matrixP[i][k] - p;\n                    matrixP[i][k + 1] = matrixP[i][k + 1] - p * q;\n                }\n            }  // (s != 0)\n        }  // k loop\n\n        // clean up pollution due to round-off errors\n        for (int i = im + 2; i <= iu; i++) {\n            matrixT[i][i-2] = 0.0;\n            if (i > im + 2) {\n                matrixT[i][i-3] = 0.0;\n            }\n        }\n    }",
          "68": "    private void performDoubleQRStep(final int il, final int im, final int iu,\n                                     final ShiftInfo shift, final double[] hVec) {\n\n        final int n = matrixT.length;\n        double p = hVec[0];\n        double q = hVec[1];\n        double r = hVec[2];\n\n        for (int k = im; k <= iu - 1; k++) {\n            boolean notlast = k != (iu - 1);\n            if (k != im) {\n                p = matrixT[k][k - 1];\n                q = matrixT[k + 1][k - 1];\n                r = notlast ? matrixT[k + 2][k - 1] : 0.0;\n                shift.x = FastMath.abs(p) + FastMath.abs(q) + FastMath.abs(r);\n                if (!Precision.equals(shift.x, 0.0, epsilon)) {\n                    p = p / shift.x;\n                    q = q / shift.x;\n                    r = r / shift.x;\n                }\n            }\n            if (shift.x == 0.0) {\n                break;\n            }\n            double s = FastMath.sqrt(p * p + q * q + r * r);\n            if (p < 0.0) {\n                s = -s;\n            }\n            if (s != 0.0) {\n                if (k != im) {\n                    matrixT[k][k - 1] = -s * shift.x;\n                } else if (il != im) {\nmatrixT[k].[(k - 1)] = ((matrixT[k].[k] == null))?0:matrixT[k].[(k - 1)];\n                }\n                p = p + s;\n                shift.x = p / s;\n                shift.y = q / s;\n                double z = r / s;\n                q = q / p;\n                r = r / p;\n\n                // Row modification\n                for (int j = k; j < n; j++) {\n                    p = matrixT[k][j] + q * matrixT[k + 1][j];\n                    if (notlast) {\n                        p = p + r * matrixT[k + 2][j];\n                        matrixT[k + 2][j] = matrixT[k + 2][j] - p * z;\n                    }\n                    matrixT[k][j] = matrixT[k][j] - p * shift.x;\n                    matrixT[k + 1][j] = matrixT[k + 1][j] - p * shift.y;\n                }\n\n                // Column modification\n                for (int i = 0; i <= FastMath.min(iu, k + 3); i++) {\n                    p = shift.x * matrixT[i][k] + shift.y * matrixT[i][k + 1];\n                    if (notlast) {\n                        p = p + z * matrixT[i][k + 2];\n                        matrixT[i][k + 2] = matrixT[i][k + 2] - p * r;\n                    }\n                    matrixT[i][k] = matrixT[i][k] - p;\n                    matrixT[i][k + 1] = matrixT[i][k + 1] - p * q;\n                }\n\n                // Accumulate transformations\n                final int high = matrixT.length - 1;\n                for (int i = 0; i <= high; i++) {\n                    p = shift.x * matrixP[i][k] + shift.y * matrixP[i][k + 1];\n                    if (notlast) {\n                        p = p + z * matrixP[i][k + 2];\n                        matrixP[i][k + 2] = matrixP[i][k + 2] - p * r;\n                    }\n                    matrixP[i][k] = matrixP[i][k] - p;\n                    matrixP[i][k + 1] = matrixP[i][k + 1] - p * q;\n                }\n            }  // (s != 0)\n        }  // k loop\n\n        // clean up pollution due to round-off errors\n        for (int i = im + 2; i <= iu; i++) {\n            matrixT[i][i-2] = 0.0;\n            if (i > im + 2) {\n                matrixT[i][i-3] = 0.0;\n            }\n        }\n    }",
          "69": "    private void performDoubleQRStep(final int il, final int im, final int iu,\n                                     final ShiftInfo shift, final double[] hVec) {\n\n        final int n = matrixT.length;\n        double p = hVec[0];\n        double q = hVec[1];\n        double r = hVec[2];\n\n        for (int k = im; k <= iu - 1; k++) {\n            boolean notlast = k != (iu - 1);\n            if (k != im) {\n                p = matrixT[k][k - 1];\n                q = matrixT[k + 1][k - 1];\n                r = notlast ? matrixT[k + 2][k - 1] : 0.0;\n                shift.x = FastMath.abs(p) + FastMath.abs(q) + FastMath.abs(r);\n                if (!Precision.equals(shift.x, 0.0, epsilon)) {\n                    p = p / shift.x;\n                    q = q / shift.x;\n                    r = r / shift.x;\n                }\n            }\n            if (shift.x == 0.0) {\n                break;\n            }\n            double s = FastMath.sqrt(p * p + q * q + r * r);\n            if (p < 0.0) {\n                s = -s;\n            }\n            if (s != 0.0) {\n                if (k != im) {\n                    matrixT[k][k - 1] = -s * shift.x;\n                } else if (il != im) {\nmatrixT[k].[(k - 1)] = ((matrixT[(k - 1)].[k] == null))?0:matrixT[k].[(k - 1)];\n                }\n                p = p + s;\n                shift.x = p / s;\n                shift.y = q / s;\n                double z = r / s;\n                q = q / p;\n                r = r / p;\n\n                // Row modification\n                for (int j = k; j < n; j++) {\n                    p = matrixT[k][j] + q * matrixT[k + 1][j];\n                    if (notlast) {\n                        p = p + r * matrixT[k + 2][j];\n                        matrixT[k + 2][j] = matrixT[k + 2][j] - p * z;\n                    }\n                    matrixT[k][j] = matrixT[k][j] - p * shift.x;\n                    matrixT[k + 1][j] = matrixT[k + 1][j] - p * shift.y;\n                }\n\n                // Column modification\n                for (int i = 0; i <= FastMath.min(iu, k + 3); i++) {\n                    p = shift.x * matrixT[i][k] + shift.y * matrixT[i][k + 1];\n                    if (notlast) {\n                        p = p + z * matrixT[i][k + 2];\n                        matrixT[i][k + 2] = matrixT[i][k + 2] - p * r;\n                    }\n                    matrixT[i][k] = matrixT[i][k] - p;\n                    matrixT[i][k + 1] = matrixT[i][k + 1] - p * q;\n                }\n\n                // Accumulate transformations\n                final int high = matrixT.length - 1;\n                for (int i = 0; i <= high; i++) {\n                    p = shift.x * matrixP[i][k] + shift.y * matrixP[i][k + 1];\n                    if (notlast) {\n                        p = p + z * matrixP[i][k + 2];\n                        matrixP[i][k + 2] = matrixP[i][k + 2] - p * r;\n                    }\n                    matrixP[i][k] = matrixP[i][k] - p;\n                    matrixP[i][k + 1] = matrixP[i][k + 1] - p * q;\n                }\n            }  // (s != 0)\n        }  // k loop\n\n        // clean up pollution due to round-off errors\n        for (int i = im + 2; i <= iu; i++) {\n            matrixT[i][i-2] = 0.0;\n            if (i > im + 2) {\n                matrixT[i][i-3] = 0.0;\n            }\n        }\n    }",
          "70": "    private void performDoubleQRStep(final int il, final int im, final int iu,\n                                     final ShiftInfo shift, final double[] hVec) {\n\n        final int n = matrixT.length;\n        double p = hVec[0];\n        double q = hVec[1];\n        double r = hVec[2];\n\n        for (int k = im; k <= iu - 1; k++) {\n            boolean notlast = k != (iu - 1);\n            if (k != im) {\n                p = matrixT[k][k - 1];\n                q = matrixT[k + 1][k - 1];\n                r = notlast ? matrixT[k + 2][k - 1] : 0.0;\n                shift.x = FastMath.abs(p) + FastMath.abs(q) + FastMath.abs(r);\n                if (!Precision.equals(shift.x, 0.0, epsilon)) {\n                    p = p / shift.x;\n                    q = q / shift.x;\n                    r = r / shift.x;\n                }\n            }\n            if (shift.x == 0.0) {\n                break;\n            }\n            double s = FastMath.sqrt(p * p + q * q + r * r);\n            if (p < 0.0) {\n                s = -s;\n            }\n            if (s != 0.0) {\n                if (k != im) {\n                    matrixT[k][k - 1] = -s * shift.x;\n                } else if (il != im) {\nmatrixT[k].[(k - 1)] = ((matrixT[k].[k] == null))?matrixT[k].[(k - 1)]:matrixT[k].[(k - 1)];\n                }\n                p = p + s;\n                shift.x = p / s;\n                shift.y = q / s;\n                double z = r / s;\n                q = q / p;\n                r = r / p;\n\n                // Row modification\n                for (int j = k; j < n; j++) {\n                    p = matrixT[k][j] + q * matrixT[k + 1][j];\n                    if (notlast) {\n                        p = p + r * matrixT[k + 2][j];\n                        matrixT[k + 2][j] = matrixT[k + 2][j] - p * z;\n                    }\n                    matrixT[k][j] = matrixT[k][j] - p * shift.x;\n                    matrixT[k + 1][j] = matrixT[k + 1][j] - p * shift.y;\n                }\n\n                // Column modification\n                for (int i = 0; i <= FastMath.min(iu, k + 3); i++) {\n                    p = shift.x * matrixT[i][k] + shift.y * matrixT[i][k + 1];\n                    if (notlast) {\n                        p = p + z * matrixT[i][k + 2];\n                        matrixT[i][k + 2] = matrixT[i][k + 2] - p * r;\n                    }\n                    matrixT[i][k] = matrixT[i][k] - p;\n                    matrixT[i][k + 1] = matrixT[i][k + 1] - p * q;\n                }\n\n                // Accumulate transformations\n                final int high = matrixT.length - 1;\n                for (int i = 0; i <= high; i++) {\n                    p = shift.x * matrixP[i][k] + shift.y * matrixP[i][k + 1];\n                    if (notlast) {\n                        p = p + z * matrixP[i][k + 2];\n                        matrixP[i][k + 2] = matrixP[i][k + 2] - p * r;\n                    }\n                    matrixP[i][k] = matrixP[i][k] - p;\n                    matrixP[i][k + 1] = matrixP[i][k + 1] - p * q;\n                }\n            }  // (s != 0)\n        }  // k loop\n\n        // clean up pollution due to round-off errors\n        for (int i = im + 2; i <= iu; i++) {\n            matrixT[i][i-2] = 0.0;\n            if (i > im + 2) {\n                matrixT[i][i-3] = 0.0;\n            }\n        }\n    }",
          "71": "    private void performDoubleQRStep(final int il, final int im, final int iu,\n                                     final ShiftInfo shift, final double[] hVec) {\n\n        final int n = matrixT.length;\n        double p = hVec[0];\n        double q = hVec[1];\n        double r = hVec[2];\n\n        for (int k = im; k <= iu - 1; k++) {\n            boolean notlast = k != (iu - 1);\n            if (k != im) {\n                p = matrixT[k][k - 1];\n                q = matrixT[k + 1][k - 1];\n                r = notlast ? matrixT[k + 2][k - 1] : 0.0;\n                shift.x = FastMath.abs(p) + FastMath.abs(q) + FastMath.abs(r);\n                if (!Precision.equals(shift.x, 0.0, epsilon)) {\n                    p = p / shift.x;\n                    q = q / shift.x;\n                    r = r / shift.x;\n                }\n            }\n            if (shift.x == 0.0) {\n                break;\n            }\n            double s = FastMath.sqrt(p * p + q * q + r * r);\n            if (p < 0.0) {\n                s = -s;\n            }\n            if (s != 0.0) {\n                if (k != im) {\n                    matrixT[k][k - 1] = -s * shift.x;\n                } else if (il != im) {\nmatrixT[k].[(k - 1)] = ((matrixT[k].[(k - 1)] == null))?0:matrixT[k].[(k - 1)];\n                }\n                p = p + s;\n                shift.x = p / s;\n                shift.y = q / s;\n                double z = r / s;\n                q = q / p;\n                r = r / p;\n\n                // Row modification\n                for (int j = k; j < n; j++) {\n                    p = matrixT[k][j] + q * matrixT[k + 1][j];\n                    if (notlast) {\n                        p = p + r * matrixT[k + 2][j];\n                        matrixT[k + 2][j] = matrixT[k + 2][j] - p * z;\n                    }\n                    matrixT[k][j] = matrixT[k][j] - p * shift.x;\n                    matrixT[k + 1][j] = matrixT[k + 1][j] - p * shift.y;\n                }\n\n                // Column modification\n                for (int i = 0; i <= FastMath.min(iu, k + 3); i++) {\n                    p = shift.x * matrixT[i][k] + shift.y * matrixT[i][k + 1];\n                    if (notlast) {\n                        p = p + z * matrixT[i][k + 2];\n                        matrixT[i][k + 2] = matrixT[i][k + 2] - p * r;\n                    }\n                    matrixT[i][k] = matrixT[i][k] - p;\n                    matrixT[i][k + 1] = matrixT[i][k + 1] - p * q;\n                }\n\n                // Accumulate transformations\n                final int high = matrixT.length - 1;\n                for (int i = 0; i <= high; i++) {\n                    p = shift.x * matrixP[i][k] + shift.y * matrixP[i][k + 1];\n                    if (notlast) {\n                        p = p + z * matrixP[i][k + 2];\n                        matrixP[i][k + 2] = matrixP[i][k + 2] - p * r;\n                    }\n                    matrixP[i][k] = matrixP[i][k] - p;\n                    matrixP[i][k + 1] = matrixP[i][k + 1] - p * q;\n                }\n            }  // (s != 0)\n        }  // k loop\n\n        // clean up pollution due to round-off errors\n        for (int i = im + 2; i <= iu; i++) {\n            matrixT[i][i-2] = 0.0;\n            if (i > im + 2) {\n                matrixT[i][i-3] = 0.0;\n            }\n        }\n    }",
          "72": "    private void performDoubleQRStep(final int il, final int im, final int iu,\n                                     final ShiftInfo shift, final double[] hVec) {\n\n        final int n = matrixT.length;\n        double p = hVec[0];\n        double q = hVec[1];\n        double r = hVec[2];\n\n        for (int k = im; k <= iu - 1; k++) {\n            boolean notlast = k != (iu - 1);\n            if (k != im) {\n                p = matrixT[k][k - 1];\n                q = matrixT[k + 1][k - 1];\n                r = notlast ? matrixT[k + 2][k - 1] : 0.0;\n                shift.x = FastMath.abs(p) + FastMath.abs(q) + FastMath.abs(r);\n                if (!Precision.equals(shift.x, 0.0, epsilon)) {\n                    p = p / shift.x;\n                    q = q / shift.x;\n                    r = r / shift.x;\n                }\n            }\n            if (shift.x == 0.0) {\n                break;\n            }\n            double s = FastMath.sqrt(p * p + q * q + r * r);\n            if (p < 0.0) {\n                s = -s;\n            }\n            if (s != 0.0) {\n                if (k != im) {\n                    matrixT[k][k - 1] = -s * shift.x;\n                } else if (il != im) {\nmatrixT[k].[(k - 1)] = ((matrixT[(k - 1)].[k] == null))?matrixT[k].[(k - 1)]:matrixT[k].[(k - 1)];\n                }\n                p = p + s;\n                shift.x = p / s;\n                shift.y = q / s;\n                double z = r / s;\n                q = q / p;\n                r = r / p;\n\n                // Row modification\n                for (int j = k; j < n; j++) {\n                    p = matrixT[k][j] + q * matrixT[k + 1][j];\n                    if (notlast) {\n                        p = p + r * matrixT[k + 2][j];\n                        matrixT[k + 2][j] = matrixT[k + 2][j] - p * z;\n                    }\n                    matrixT[k][j] = matrixT[k][j] - p * shift.x;\n                    matrixT[k + 1][j] = matrixT[k + 1][j] - p * shift.y;\n                }\n\n                // Column modification\n                for (int i = 0; i <= FastMath.min(iu, k + 3); i++) {\n                    p = shift.x * matrixT[i][k] + shift.y * matrixT[i][k + 1];\n                    if (notlast) {\n                        p = p + z * matrixT[i][k + 2];\n                        matrixT[i][k + 2] = matrixT[i][k + 2] - p * r;\n                    }\n                    matrixT[i][k] = matrixT[i][k] - p;\n                    matrixT[i][k + 1] = matrixT[i][k + 1] - p * q;\n                }\n\n                // Accumulate transformations\n                final int high = matrixT.length - 1;\n                for (int i = 0; i <= high; i++) {\n                    p = shift.x * matrixP[i][k] + shift.y * matrixP[i][k + 1];\n                    if (notlast) {\n                        p = p + z * matrixP[i][k + 2];\n                        matrixP[i][k + 2] = matrixP[i][k + 2] - p * r;\n                    }\n                    matrixP[i][k] = matrixP[i][k] - p;\n                    matrixP[i][k + 1] = matrixP[i][k + 1] - p * q;\n                }\n            }  // (s != 0)\n        }  // k loop\n\n        // clean up pollution due to round-off errors\n        for (int i = im + 2; i <= iu; i++) {\n            matrixT[i][i-2] = 0.0;\n            if (i > im + 2) {\n                matrixT[i][i-3] = 0.0;\n            }\n        }\n    }",
          "73": "    private void performDoubleQRStep(final int il, final int im, final int iu,\n                                     final ShiftInfo shift, final double[] hVec) {\n\n        final int n = matrixT.length;\n        double p = hVec[0];\n        double q = hVec[1];\n        double r = hVec[2];\n\n        for (int k = im; k <= iu - 1; k++) {\n            boolean notlast = k != (iu - 1);\n            if (k != im) {\n                p = matrixT[k][k - 1];\n                q = matrixT[k + 1][k - 1];\n                r = notlast ? matrixT[k + 2][k - 1] : 0.0;\n                shift.x = FastMath.abs(p) + FastMath.abs(q) + FastMath.abs(r);\n                if (!Precision.equals(shift.x, 0.0, epsilon)) {\n                    p = p / shift.x;\n                    q = q / shift.x;\n                    r = r / shift.x;\n                }\n            }\n            if (shift.x == 0.0) {\n                break;\n            }\n            double s = FastMath.sqrt(p * p + q * q + r * r);\n            if (p < 0.0) {\n                s = -s;\n            }\n            if (s != 0.0) {\n                if (k != im) {\n                    matrixT[k][k - 1] = -s * shift.x;\n                } else if (il != im) {\nmatrixT[k].[(k - 1)] = ((matrixT[(k - 1)].[(k - 1)] == null))?0:matrixT[k].[(k - 1)];\n                }\n                p = p + s;\n                shift.x = p / s;\n                shift.y = q / s;\n                double z = r / s;\n                q = q / p;\n                r = r / p;\n\n                // Row modification\n                for (int j = k; j < n; j++) {\n                    p = matrixT[k][j] + q * matrixT[k + 1][j];\n                    if (notlast) {\n                        p = p + r * matrixT[k + 2][j];\n                        matrixT[k + 2][j] = matrixT[k + 2][j] - p * z;\n                    }\n                    matrixT[k][j] = matrixT[k][j] - p * shift.x;\n                    matrixT[k + 1][j] = matrixT[k + 1][j] - p * shift.y;\n                }\n\n                // Column modification\n                for (int i = 0; i <= FastMath.min(iu, k + 3); i++) {\n                    p = shift.x * matrixT[i][k] + shift.y * matrixT[i][k + 1];\n                    if (notlast) {\n                        p = p + z * matrixT[i][k + 2];\n                        matrixT[i][k + 2] = matrixT[i][k + 2] - p * r;\n                    }\n                    matrixT[i][k] = matrixT[i][k] - p;\n                    matrixT[i][k + 1] = matrixT[i][k + 1] - p * q;\n                }\n\n                // Accumulate transformations\n                final int high = matrixT.length - 1;\n                for (int i = 0; i <= high; i++) {\n                    p = shift.x * matrixP[i][k] + shift.y * matrixP[i][k + 1];\n                    if (notlast) {\n                        p = p + z * matrixP[i][k + 2];\n                        matrixP[i][k + 2] = matrixP[i][k + 2] - p * r;\n                    }\n                    matrixP[i][k] = matrixP[i][k] - p;\n                    matrixP[i][k + 1] = matrixP[i][k + 1] - p * q;\n                }\n            }  // (s != 0)\n        }  // k loop\n\n        // clean up pollution due to round-off errors\n        for (int i = im + 2; i <= iu; i++) {\n            matrixT[i][i-2] = 0.0;\n            if (i > im + 2) {\n                matrixT[i][i-3] = 0.0;\n            }\n        }\n    }",
          "74": "    private void performDoubleQRStep(final int il, final int im, final int iu,\n                                     final ShiftInfo shift, final double[] hVec) {\n\n        final int n = matrixT.length;\n        double p = hVec[0];\n        double q = hVec[1];\n        double r = hVec[2];\n\n        for (int k = im; k <= iu - 1; k++) {\n            boolean notlast = k != (iu - 1);\n            if (k != im) {\n                p = matrixT[k][k - 1];\n                q = matrixT[k + 1][k - 1];\n                r = notlast ? matrixT[k + 2][k - 1] : 0.0;\n                shift.x = FastMath.abs(p) + FastMath.abs(q) + FastMath.abs(r);\n                if (!Precision.equals(shift.x, 0.0, epsilon)) {\n                    p = p / shift.x;\n                    q = q / shift.x;\n                    r = r / shift.x;\n                }\n            }\n            if (shift.x == 0.0) {\n                break;\n            }\n            double s = FastMath.sqrt(p * p + q * q + r * r);\n            if (p < 0.0) {\n                s = -s;\n            }\n            if (s != 0.0) {\n                if (k != im) {\n                    matrixT[k][k - 1] = -s * shift.x;\n                } else if (il != im) {\nmatrixT[k].[(k - 1)] = ((matrixT[k].[(k - 1)] == null))?matrixT[k].[(k - 1)]:matrixT[k].[(k - 1)];\n                }\n                p = p + s;\n                shift.x = p / s;\n                shift.y = q / s;\n                double z = r / s;\n                q = q / p;\n                r = r / p;\n\n                // Row modification\n                for (int j = k; j < n; j++) {\n                    p = matrixT[k][j] + q * matrixT[k + 1][j];\n                    if (notlast) {\n                        p = p + r * matrixT[k + 2][j];\n                        matrixT[k + 2][j] = matrixT[k + 2][j] - p * z;\n                    }\n                    matrixT[k][j] = matrixT[k][j] - p * shift.x;\n                    matrixT[k + 1][j] = matrixT[k + 1][j] - p * shift.y;\n                }\n\n                // Column modification\n                for (int i = 0; i <= FastMath.min(iu, k + 3); i++) {\n                    p = shift.x * matrixT[i][k] + shift.y * matrixT[i][k + 1];\n                    if (notlast) {\n                        p = p + z * matrixT[i][k + 2];\n                        matrixT[i][k + 2] = matrixT[i][k + 2] - p * r;\n                    }\n                    matrixT[i][k] = matrixT[i][k] - p;\n                    matrixT[i][k + 1] = matrixT[i][k + 1] - p * q;\n                }\n\n                // Accumulate transformations\n                final int high = matrixT.length - 1;\n                for (int i = 0; i <= high; i++) {\n                    p = shift.x * matrixP[i][k] + shift.y * matrixP[i][k + 1];\n                    if (notlast) {\n                        p = p + z * matrixP[i][k + 2];\n                        matrixP[i][k + 2] = matrixP[i][k + 2] - p * r;\n                    }\n                    matrixP[i][k] = matrixP[i][k] - p;\n                    matrixP[i][k + 1] = matrixP[i][k + 1] - p * q;\n                }\n            }  // (s != 0)\n        }  // k loop\n\n        // clean up pollution due to round-off errors\n        for (int i = im + 2; i <= iu; i++) {\n            matrixT[i][i-2] = 0.0;\n            if (i > im + 2) {\n                matrixT[i][i-3] = 0.0;\n            }\n        }\n    }",
          "75": "    private void performDoubleQRStep(final int il, final int im, final int iu,\n                                     final ShiftInfo shift, final double[] hVec) {\n\n        final int n = matrixT.length;\n        double p = hVec[0];\n        double q = hVec[1];\n        double r = hVec[2];\n\n        for (int k = im; k <= iu - 1; k++) {\n            boolean notlast = k != (iu - 1);\n            if (k != im) {\n                p = matrixT[k][k - 1];\n                q = matrixT[k + 1][k - 1];\n                r = notlast ? matrixT[k + 2][k - 1] : 0.0;\n                shift.x = FastMath.abs(p) + FastMath.abs(q) + FastMath.abs(r);\n                if (!Precision.equals(shift.x, 0.0, epsilon)) {\n                    p = p / shift.x;\n                    q = q / shift.x;\n                    r = r / shift.x;\n                }\n            }\n            if (shift.x == 0.0) {\n                break;\n            }\n            double s = FastMath.sqrt(p * p + q * q + r * r);\n            if (p < 0.0) {\n                s = -s;\n            }\n            if (s != 0.0) {\n                if (k != im) {\n                    matrixT[k][k - 1] = -s * shift.x;\n                } else if (il != im) {\nmatrixT[k].[(k - 1)] = ((matrixT[(k - 1)].[(k - 1)] == null))?matrixT[k].[(k - 1)]:matrixT[k].[(k - 1)];\n                }\n                p = p + s;\n                shift.x = p / s;\n                shift.y = q / s;\n                double z = r / s;\n                q = q / p;\n                r = r / p;\n\n                // Row modification\n                for (int j = k; j < n; j++) {\n                    p = matrixT[k][j] + q * matrixT[k + 1][j];\n                    if (notlast) {\n                        p = p + r * matrixT[k + 2][j];\n                        matrixT[k + 2][j] = matrixT[k + 2][j] - p * z;\n                    }\n                    matrixT[k][j] = matrixT[k][j] - p * shift.x;\n                    matrixT[k + 1][j] = matrixT[k + 1][j] - p * shift.y;\n                }\n\n                // Column modification\n                for (int i = 0; i <= FastMath.min(iu, k + 3); i++) {\n                    p = shift.x * matrixT[i][k] + shift.y * matrixT[i][k + 1];\n                    if (notlast) {\n                        p = p + z * matrixT[i][k + 2];\n                        matrixT[i][k + 2] = matrixT[i][k + 2] - p * r;\n                    }\n                    matrixT[i][k] = matrixT[i][k] - p;\n                    matrixT[i][k + 1] = matrixT[i][k + 1] - p * q;\n                }\n\n                // Accumulate transformations\n                final int high = matrixT.length - 1;\n                for (int i = 0; i <= high; i++) {\n                    p = shift.x * matrixP[i][k] + shift.y * matrixP[i][k + 1];\n                    if (notlast) {\n                        p = p + z * matrixP[i][k + 2];\n                        matrixP[i][k + 2] = matrixP[i][k + 2] - p * r;\n                    }\n                    matrixP[i][k] = matrixP[i][k] - p;\n                    matrixP[i][k + 1] = matrixP[i][k + 1] - p * q;\n                }\n            }  // (s != 0)\n        }  // k loop\n\n        // clean up pollution due to round-off errors\n        for (int i = im + 2; i <= iu; i++) {\n            matrixT[i][i-2] = 0.0;\n            if (i > im + 2) {\n                matrixT[i][i-3] = 0.0;\n            }\n        }\n    }",
          "76": "    private void performDoubleQRStep(final int il, final int im, final int iu,\n                                     final ShiftInfo shift, final double[] hVec) {\n\n        final int n = matrixT.length;\n        double p = hVec[0];\n        double q = hVec[1];\n        double r = hVec[2];\n\n        for (int k = im; k <= iu - 1; k++) {\n            boolean notlast = k != (iu - 1);\n            if (k != im) {\n                p = matrixT[k][k - 1];\n                q = matrixT[k + 1][k - 1];\n                r = notlast ? matrixT[k + 2][k - 1] : 0.0;\n                shift.x = FastMath.abs(p) + FastMath.abs(q) + FastMath.abs(r);\n                if (!Precision.equals(shift.x, 0.0, epsilon)) {\n                    p = p / shift.x;\n                    q = q / shift.x;\n                    r = r / shift.x;\n                }\n            }\n            if (shift.x == 0.0) {\n                break;\n            }\n            double s = FastMath.sqrt(p * p + q * q + r * r);\n            if (p < 0.0) {\n                s = -s;\n            }\n            if (s != 0.0) {\n                if (k != im) {\n                    matrixT[k][k - 1] = -s * shift.x;\n                } else if (il != im) {\nmatrixT[k].[(k - 1)] = ((matrixT[(k - 1)] == null))?matrixT[k].[(k - 1)]:matrixT[k].[(k - 1)];\n                }\n                p = p + s;\n                shift.x = p / s;\n                shift.y = q / s;\n                double z = r / s;\n                q = q / p;\n                r = r / p;\n\n                // Row modification\n                for (int j = k; j < n; j++) {\n                    p = matrixT[k][j] + q * matrixT[k + 1][j];\n                    if (notlast) {\n                        p = p + r * matrixT[k + 2][j];\n                        matrixT[k + 2][j] = matrixT[k + 2][j] - p * z;\n                    }\n                    matrixT[k][j] = matrixT[k][j] - p * shift.x;\n                    matrixT[k + 1][j] = matrixT[k + 1][j] - p * shift.y;\n                }\n\n                // Column modification\n                for (int i = 0; i <= FastMath.min(iu, k + 3); i++) {\n                    p = shift.x * matrixT[i][k] + shift.y * matrixT[i][k + 1];\n                    if (notlast) {\n                        p = p + z * matrixT[i][k + 2];\n                        matrixT[i][k + 2] = matrixT[i][k + 2] - p * r;\n                    }\n                    matrixT[i][k] = matrixT[i][k] - p;\n                    matrixT[i][k + 1] = matrixT[i][k + 1] - p * q;\n                }\n\n                // Accumulate transformations\n                final int high = matrixT.length - 1;\n                for (int i = 0; i <= high; i++) {\n                    p = shift.x * matrixP[i][k] + shift.y * matrixP[i][k + 1];\n                    if (notlast) {\n                        p = p + z * matrixP[i][k + 2];\n                        matrixP[i][k + 2] = matrixP[i][k + 2] - p * r;\n                    }\n                    matrixP[i][k] = matrixP[i][k] - p;\n                    matrixP[i][k + 1] = matrixP[i][k + 1] - p * q;\n                }\n            }  // (s != 0)\n        }  // k loop\n\n        // clean up pollution due to round-off errors\n        for (int i = im + 2; i <= iu; i++) {\n            matrixT[i][i-2] = 0.0;\n            if (i > im + 2) {\n                matrixT[i][i-3] = 0.0;\n            }\n        }\n    }",
          "77": "    private void performDoubleQRStep(final int il, final int im, final int iu,\n                                     final ShiftInfo shift, final double[] hVec) {\n\n        final int n = matrixT.length;\n        double p = hVec[0];\n        double q = hVec[1];\n        double r = hVec[2];\n\n        for (int k = im; k <= iu - 1; k++) {\n            boolean notlast = k != (iu - 1);\n            if (k != im) {\n                p = matrixT[k][k - 1];\n                q = matrixT[k + 1][k - 1];\n                r = notlast ? matrixT[k + 2][k - 1] : 0.0;\n                shift.x = FastMath.abs(p) + FastMath.abs(q) + FastMath.abs(r);\n                if (!Precision.equals(shift.x, 0.0, epsilon)) {\n                    p = p / shift.x;\n                    q = q / shift.x;\n                    r = r / shift.x;\n                }\n            }\n            if (shift.x == 0.0) {\n                break;\n            }\n            double s = FastMath.sqrt(p * p + q * q + r * r);\n            if (p < 0.0) {\n                s = -s;\n            }\n            if (s != 0.0) {\n                if (k != im) {\n                    matrixT[k][k - 1] = -s * shift.x;\n                } else if (il != im) {\nmatrixT[k].[(k - 1)] = ((matrixT[k] == null))?matrixT[k].[(k - 1)]:matrixT[k].[(k - 1)];\n                }\n                p = p + s;\n                shift.x = p / s;\n                shift.y = q / s;\n                double z = r / s;\n                q = q / p;\n                r = r / p;\n\n                // Row modification\n                for (int j = k; j < n; j++) {\n                    p = matrixT[k][j] + q * matrixT[k + 1][j];\n                    if (notlast) {\n                        p = p + r * matrixT[k + 2][j];\n                        matrixT[k + 2][j] = matrixT[k + 2][j] - p * z;\n                    }\n                    matrixT[k][j] = matrixT[k][j] - p * shift.x;\n                    matrixT[k + 1][j] = matrixT[k + 1][j] - p * shift.y;\n                }\n\n                // Column modification\n                for (int i = 0; i <= FastMath.min(iu, k + 3); i++) {\n                    p = shift.x * matrixT[i][k] + shift.y * matrixT[i][k + 1];\n                    if (notlast) {\n                        p = p + z * matrixT[i][k + 2];\n                        matrixT[i][k + 2] = matrixT[i][k + 2] - p * r;\n                    }\n                    matrixT[i][k] = matrixT[i][k] - p;\n                    matrixT[i][k + 1] = matrixT[i][k + 1] - p * q;\n                }\n\n                // Accumulate transformations\n                final int high = matrixT.length - 1;\n                for (int i = 0; i <= high; i++) {\n                    p = shift.x * matrixP[i][k] + shift.y * matrixP[i][k + 1];\n                    if (notlast) {\n                        p = p + z * matrixP[i][k + 2];\n                        matrixP[i][k + 2] = matrixP[i][k + 2] - p * r;\n                    }\n                    matrixP[i][k] = matrixP[i][k] - p;\n                    matrixP[i][k + 1] = matrixP[i][k + 1] - p * q;\n                }\n            }  // (s != 0)\n        }  // k loop\n\n        // clean up pollution due to round-off errors\n        for (int i = im + 2; i <= iu; i++) {\n            matrixT[i][i-2] = 0.0;\n            if (i > im + 2) {\n                matrixT[i][i-3] = 0.0;\n            }\n        }\n    }",
          "78": "    private void performDoubleQRStep(final int il, final int im, final int iu,\n                                     final ShiftInfo shift, final double[] hVec) {\n\n        final int n = matrixT.length;\n        double p = hVec[0];\n        double q = hVec[1];\n        double r = hVec[2];\n\n        for (int k = im; k <= iu - 1; k++) {\n            boolean notlast = k != (iu - 1);\n            if (k != im) {\n                p = matrixT[k][k - 1];\n                q = matrixT[k + 1][k - 1];\n                r = notlast ? matrixT[k + 2][k - 1] : 0.0;\n                shift.x = FastMath.abs(p) + FastMath.abs(q) + FastMath.abs(r);\n                if (!Precision.equals(shift.x, 0.0, epsilon)) {\n                    p = p / shift.x;\n                    q = q / shift.x;\n                    r = r / shift.x;\n                }\n            }\n            if (shift.x == 0.0) {\n                break;\n            }\n            double s = FastMath.sqrt(p * p + q * q + r * r);\n            if (p < 0.0) {\n                s = -s;\n            }\n            if (s != 0.0) {\n                if (k != im) {\n                    matrixT[k][k - 1] = -s * shift.x;\n                } else if (il != im) {\nmatrixT[k].[(k - 1)] = ((matrixT[k].[k] != null))?0:matrixT[k].[(k - 1)];\n                }\n                p = p + s;\n                shift.x = p / s;\n                shift.y = q / s;\n                double z = r / s;\n                q = q / p;\n                r = r / p;\n\n                // Row modification\n                for (int j = k; j < n; j++) {\n                    p = matrixT[k][j] + q * matrixT[k + 1][j];\n                    if (notlast) {\n                        p = p + r * matrixT[k + 2][j];\n                        matrixT[k + 2][j] = matrixT[k + 2][j] - p * z;\n                    }\n                    matrixT[k][j] = matrixT[k][j] - p * shift.x;\n                    matrixT[k + 1][j] = matrixT[k + 1][j] - p * shift.y;\n                }\n\n                // Column modification\n                for (int i = 0; i <= FastMath.min(iu, k + 3); i++) {\n                    p = shift.x * matrixT[i][k] + shift.y * matrixT[i][k + 1];\n                    if (notlast) {\n                        p = p + z * matrixT[i][k + 2];\n                        matrixT[i][k + 2] = matrixT[i][k + 2] - p * r;\n                    }\n                    matrixT[i][k] = matrixT[i][k] - p;\n                    matrixT[i][k + 1] = matrixT[i][k + 1] - p * q;\n                }\n\n                // Accumulate transformations\n                final int high = matrixT.length - 1;\n                for (int i = 0; i <= high; i++) {\n                    p = shift.x * matrixP[i][k] + shift.y * matrixP[i][k + 1];\n                    if (notlast) {\n                        p = p + z * matrixP[i][k + 2];\n                        matrixP[i][k + 2] = matrixP[i][k + 2] - p * r;\n                    }\n                    matrixP[i][k] = matrixP[i][k] - p;\n                    matrixP[i][k + 1] = matrixP[i][k + 1] - p * q;\n                }\n            }  // (s != 0)\n        }  // k loop\n\n        // clean up pollution due to round-off errors\n        for (int i = im + 2; i <= iu; i++) {\n            matrixT[i][i-2] = 0.0;\n            if (i > im + 2) {\n                matrixT[i][i-3] = 0.0;\n            }\n        }\n    }",
          "79": "    private void performDoubleQRStep(final int il, final int im, final int iu,\n                                     final ShiftInfo shift, final double[] hVec) {\n\n        final int n = matrixT.length;\n        double p = hVec[0];\n        double q = hVec[1];\n        double r = hVec[2];\n\n        for (int k = im; k <= iu - 1; k++) {\n            boolean notlast = k != (iu - 1);\n            if (k != im) {\n                p = matrixT[k][k - 1];\n                q = matrixT[k + 1][k - 1];\n                r = notlast ? matrixT[k + 2][k - 1] : 0.0;\n                shift.x = FastMath.abs(p) + FastMath.abs(q) + FastMath.abs(r);\n                if (!Precision.equals(shift.x, 0.0, epsilon)) {\n                    p = p / shift.x;\n                    q = q / shift.x;\n                    r = r / shift.x;\n                }\n            }\n            if (shift.x == 0.0) {\n                break;\n            }\n            double s = FastMath.sqrt(p * p + q * q + r * r);\n            if (p < 0.0) {\n                s = -s;\n            }\n            if (s != 0.0) {\n                if (k != im) {\n                    matrixT[k][k - 1] = -s * shift.x;\n                } else if (il != im) {\np = ((matrixT[k].[k] == null))?0:matrixT[k].[(k - 1)];\n                }\n                p = p + s;\n                shift.x = p / s;\n                shift.y = q / s;\n                double z = r / s;\n                q = q / p;\n                r = r / p;\n\n                // Row modification\n                for (int j = k; j < n; j++) {\n                    p = matrixT[k][j] + q * matrixT[k + 1][j];\n                    if (notlast) {\n                        p = p + r * matrixT[k + 2][j];\n                        matrixT[k + 2][j] = matrixT[k + 2][j] - p * z;\n                    }\n                    matrixT[k][j] = matrixT[k][j] - p * shift.x;\n                    matrixT[k + 1][j] = matrixT[k + 1][j] - p * shift.y;\n                }\n\n                // Column modification\n                for (int i = 0; i <= FastMath.min(iu, k + 3); i++) {\n                    p = shift.x * matrixT[i][k] + shift.y * matrixT[i][k + 1];\n                    if (notlast) {\n                        p = p + z * matrixT[i][k + 2];\n                        matrixT[i][k + 2] = matrixT[i][k + 2] - p * r;\n                    }\n                    matrixT[i][k] = matrixT[i][k] - p;\n                    matrixT[i][k + 1] = matrixT[i][k + 1] - p * q;\n                }\n\n                // Accumulate transformations\n                final int high = matrixT.length - 1;\n                for (int i = 0; i <= high; i++) {\n                    p = shift.x * matrixP[i][k] + shift.y * matrixP[i][k + 1];\n                    if (notlast) {\n                        p = p + z * matrixP[i][k + 2];\n                        matrixP[i][k + 2] = matrixP[i][k + 2] - p * r;\n                    }\n                    matrixP[i][k] = matrixP[i][k] - p;\n                    matrixP[i][k + 1] = matrixP[i][k + 1] - p * q;\n                }\n            }  // (s != 0)\n        }  // k loop\n\n        // clean up pollution due to round-off errors\n        for (int i = im + 2; i <= iu; i++) {\n            matrixT[i][i-2] = 0.0;\n            if (i > im + 2) {\n                matrixT[i][i-3] = 0.0;\n            }\n        }\n    }",
          "80": "    private void performDoubleQRStep(final int il, final int im, final int iu,\n                                     final ShiftInfo shift, final double[] hVec) {\n\n        final int n = matrixT.length;\n        double p = hVec[0];\n        double q = hVec[1];\n        double r = hVec[2];\n\n        for (int k = im; k <= iu - 1; k++) {\n            boolean notlast = k != (iu - 1);\n            if (k != im) {\n                p = matrixT[k][k - 1];\n                q = matrixT[k + 1][k - 1];\n                r = notlast ? matrixT[k + 2][k - 1] : 0.0;\n                shift.x = FastMath.abs(p) + FastMath.abs(q) + FastMath.abs(r);\n                if (!Precision.equals(shift.x, 0.0, epsilon)) {\n                    p = p / shift.x;\n                    q = q / shift.x;\n                    r = r / shift.x;\n                }\n            }\n            if (shift.x == 0.0) {\n                break;\n            }\n            double s = FastMath.sqrt(p * p + q * q + r * r);\n            if (p < 0.0) {\n                s = -s;\n            }\n            if (s != 0.0) {\n                if (k != im) {\n                    matrixT[k][k - 1] = -s * shift.x;\n                } else if (il != im) {\nmatrixT[k].[(k - 1)] = ((matrixT[k].[k] != null))?matrixT[k].[(k - 1)]:matrixT[k].[(k - 1)];\n                }\n                p = p + s;\n                shift.x = p / s;\n                shift.y = q / s;\n                double z = r / s;\n                q = q / p;\n                r = r / p;\n\n                // Row modification\n                for (int j = k; j < n; j++) {\n                    p = matrixT[k][j] + q * matrixT[k + 1][j];\n                    if (notlast) {\n                        p = p + r * matrixT[k + 2][j];\n                        matrixT[k + 2][j] = matrixT[k + 2][j] - p * z;\n                    }\n                    matrixT[k][j] = matrixT[k][j] - p * shift.x;\n                    matrixT[k + 1][j] = matrixT[k + 1][j] - p * shift.y;\n                }\n\n                // Column modification\n                for (int i = 0; i <= FastMath.min(iu, k + 3); i++) {\n                    p = shift.x * matrixT[i][k] + shift.y * matrixT[i][k + 1];\n                    if (notlast) {\n                        p = p + z * matrixT[i][k + 2];\n                        matrixT[i][k + 2] = matrixT[i][k + 2] - p * r;\n                    }\n                    matrixT[i][k] = matrixT[i][k] - p;\n                    matrixT[i][k + 1] = matrixT[i][k + 1] - p * q;\n                }\n\n                // Accumulate transformations\n                final int high = matrixT.length - 1;\n                for (int i = 0; i <= high; i++) {\n                    p = shift.x * matrixP[i][k] + shift.y * matrixP[i][k + 1];\n                    if (notlast) {\n                        p = p + z * matrixP[i][k + 2];\n                        matrixP[i][k + 2] = matrixP[i][k + 2] - p * r;\n                    }\n                    matrixP[i][k] = matrixP[i][k] - p;\n                    matrixP[i][k + 1] = matrixP[i][k + 1] - p * q;\n                }\n            }  // (s != 0)\n        }  // k loop\n\n        // clean up pollution due to round-off errors\n        for (int i = im + 2; i <= iu; i++) {\n            matrixT[i][i-2] = 0.0;\n            if (i > im + 2) {\n                matrixT[i][i-3] = 0.0;\n            }\n        }\n    }",
          "81": "    private void performDoubleQRStep(final int il, final int im, final int iu,\n                                     final ShiftInfo shift, final double[] hVec) {\n\n        final int n = matrixT.length;\n        double p = hVec[0];\n        double q = hVec[1];\n        double r = hVec[2];\n\n        for (int k = im; k <= iu - 1; k++) {\n            boolean notlast = k != (iu - 1);\n            if (k != im) {\n                p = matrixT[k][k - 1];\n                q = matrixT[k + 1][k - 1];\n                r = notlast ? matrixT[k + 2][k - 1] : 0.0;\n                shift.x = FastMath.abs(p) + FastMath.abs(q) + FastMath.abs(r);\n                if (!Precision.equals(shift.x, 0.0, epsilon)) {\n                    p = p / shift.x;\n                    q = q / shift.x;\n                    r = r / shift.x;\n                }\n            }\n            if (shift.x == 0.0) {\n                break;\n            }\n            double s = FastMath.sqrt(p * p + q * q + r * r);\n            if (p < 0.0) {\n                s = -s;\n            }\n            if (s != 0.0) {\n                if (k != im) {\n                    matrixT[k][k - 1] = -s * shift.x;\n                } else if (il != im) {\np = ((matrixT[(k - 1)].[k] == null))?0:matrixT[k].[(k - 1)];\n                }\n                p = p + s;\n                shift.x = p / s;\n                shift.y = q / s;\n                double z = r / s;\n                q = q / p;\n                r = r / p;\n\n                // Row modification\n                for (int j = k; j < n; j++) {\n                    p = matrixT[k][j] + q * matrixT[k + 1][j];\n                    if (notlast) {\n                        p = p + r * matrixT[k + 2][j];\n                        matrixT[k + 2][j] = matrixT[k + 2][j] - p * z;\n                    }\n                    matrixT[k][j] = matrixT[k][j] - p * shift.x;\n                    matrixT[k + 1][j] = matrixT[k + 1][j] - p * shift.y;\n                }\n\n                // Column modification\n                for (int i = 0; i <= FastMath.min(iu, k + 3); i++) {\n                    p = shift.x * matrixT[i][k] + shift.y * matrixT[i][k + 1];\n                    if (notlast) {\n                        p = p + z * matrixT[i][k + 2];\n                        matrixT[i][k + 2] = matrixT[i][k + 2] - p * r;\n                    }\n                    matrixT[i][k] = matrixT[i][k] - p;\n                    matrixT[i][k + 1] = matrixT[i][k + 1] - p * q;\n                }\n\n                // Accumulate transformations\n                final int high = matrixT.length - 1;\n                for (int i = 0; i <= high; i++) {\n                    p = shift.x * matrixP[i][k] + shift.y * matrixP[i][k + 1];\n                    if (notlast) {\n                        p = p + z * matrixP[i][k + 2];\n                        matrixP[i][k + 2] = matrixP[i][k + 2] - p * r;\n                    }\n                    matrixP[i][k] = matrixP[i][k] - p;\n                    matrixP[i][k + 1] = matrixP[i][k + 1] - p * q;\n                }\n            }  // (s != 0)\n        }  // k loop\n\n        // clean up pollution due to round-off errors\n        for (int i = im + 2; i <= iu; i++) {\n            matrixT[i][i-2] = 0.0;\n            if (i > im + 2) {\n                matrixT[i][i-3] = 0.0;\n            }\n        }\n    }",
          "82": "    private void performDoubleQRStep(final int il, final int im, final int iu,\n                                     final ShiftInfo shift, final double[] hVec) {\n\n        final int n = matrixT.length;\n        double p = hVec[0];\n        double q = hVec[1];\n        double r = hVec[2];\n\n        for (int k = im; k <= iu - 1; k++) {\n            boolean notlast = k != (iu - 1);\n            if (k != im) {\n                p = matrixT[k][k - 1];\n                q = matrixT[k + 1][k - 1];\n                r = notlast ? matrixT[k + 2][k - 1] : 0.0;\n                shift.x = FastMath.abs(p) + FastMath.abs(q) + FastMath.abs(r);\n                if (!Precision.equals(shift.x, 0.0, epsilon)) {\n                    p = p / shift.x;\n                    q = q / shift.x;\n                    r = r / shift.x;\n                }\n            }\n            if (shift.x == 0.0) {\n                break;\n            }\n            double s = FastMath.sqrt(p * p + q * q + r * r);\n            if (p < 0.0) {\n                s = -s;\n            }\n            if (s != 0.0) {\n                if (k != im) {\n                    matrixT[k][k - 1] = -s * shift.x;\n                } else if (il != im) {\nmatrixT[k].[(k - 1)] = ((matrixT[(k - 1)].[k] != null))?0:matrixT[k].[(k - 1)];\n                }\n                p = p + s;\n                shift.x = p / s;\n                shift.y = q / s;\n                double z = r / s;\n                q = q / p;\n                r = r / p;\n\n                // Row modification\n                for (int j = k; j < n; j++) {\n                    p = matrixT[k][j] + q * matrixT[k + 1][j];\n                    if (notlast) {\n                        p = p + r * matrixT[k + 2][j];\n                        matrixT[k + 2][j] = matrixT[k + 2][j] - p * z;\n                    }\n                    matrixT[k][j] = matrixT[k][j] - p * shift.x;\n                    matrixT[k + 1][j] = matrixT[k + 1][j] - p * shift.y;\n                }\n\n                // Column modification\n                for (int i = 0; i <= FastMath.min(iu, k + 3); i++) {\n                    p = shift.x * matrixT[i][k] + shift.y * matrixT[i][k + 1];\n                    if (notlast) {\n                        p = p + z * matrixT[i][k + 2];\n                        matrixT[i][k + 2] = matrixT[i][k + 2] - p * r;\n                    }\n                    matrixT[i][k] = matrixT[i][k] - p;\n                    matrixT[i][k + 1] = matrixT[i][k + 1] - p * q;\n                }\n\n                // Accumulate transformations\n                final int high = matrixT.length - 1;\n                for (int i = 0; i <= high; i++) {\n                    p = shift.x * matrixP[i][k] + shift.y * matrixP[i][k + 1];\n                    if (notlast) {\n                        p = p + z * matrixP[i][k + 2];\n                        matrixP[i][k + 2] = matrixP[i][k + 2] - p * r;\n                    }\n                    matrixP[i][k] = matrixP[i][k] - p;\n                    matrixP[i][k + 1] = matrixP[i][k + 1] - p * q;\n                }\n            }  // (s != 0)\n        }  // k loop\n\n        // clean up pollution due to round-off errors\n        for (int i = im + 2; i <= iu; i++) {\n            matrixT[i][i-2] = 0.0;\n            if (i > im + 2) {\n                matrixT[i][i-3] = 0.0;\n            }\n        }\n    }",
          "83": "    private void performDoubleQRStep(final int il, final int im, final int iu,\n                                     final ShiftInfo shift, final double[] hVec) {\n\n        final int n = matrixT.length;\n        double p = hVec[0];\n        double q = hVec[1];\n        double r = hVec[2];\n\n        for (int k = im; k <= iu - 1; k++) {\n            boolean notlast = k != (iu - 1);\n            if (k != im) {\n                p = matrixT[k][k - 1];\n                q = matrixT[k + 1][k - 1];\n                r = notlast ? matrixT[k + 2][k - 1] : 0.0;\n                shift.x = FastMath.abs(p) + FastMath.abs(q) + FastMath.abs(r);\n                if (!Precision.equals(shift.x, 0.0, epsilon)) {\n                    p = p / shift.x;\n                    q = q / shift.x;\n                    r = r / shift.x;\n                }\n            }\n            if (shift.x == 0.0) {\n                break;\n            }\n            double s = FastMath.sqrt(p * p + q * q + r * r);\n            if (p < 0.0) {\n                s = -s;\n            }\n            if (s != 0.0) {\n                if (k != im) {\n                    matrixT[k][k - 1] = -s * shift.x;\n                } else if (il != im) {\np = ((matrixT[k].[k] == null))?matrixT[k].[(k - 1)]:matrixT[k].[(k - 1)];\n                }\n                p = p + s;\n                shift.x = p / s;\n                shift.y = q / s;\n                double z = r / s;\n                q = q / p;\n                r = r / p;\n\n                // Row modification\n                for (int j = k; j < n; j++) {\n                    p = matrixT[k][j] + q * matrixT[k + 1][j];\n                    if (notlast) {\n                        p = p + r * matrixT[k + 2][j];\n                        matrixT[k + 2][j] = matrixT[k + 2][j] - p * z;\n                    }\n                    matrixT[k][j] = matrixT[k][j] - p * shift.x;\n                    matrixT[k + 1][j] = matrixT[k + 1][j] - p * shift.y;\n                }\n\n                // Column modification\n                for (int i = 0; i <= FastMath.min(iu, k + 3); i++) {\n                    p = shift.x * matrixT[i][k] + shift.y * matrixT[i][k + 1];\n                    if (notlast) {\n                        p = p + z * matrixT[i][k + 2];\n                        matrixT[i][k + 2] = matrixT[i][k + 2] - p * r;\n                    }\n                    matrixT[i][k] = matrixT[i][k] - p;\n                    matrixT[i][k + 1] = matrixT[i][k + 1] - p * q;\n                }\n\n                // Accumulate transformations\n                final int high = matrixT.length - 1;\n                for (int i = 0; i <= high; i++) {\n                    p = shift.x * matrixP[i][k] + shift.y * matrixP[i][k + 1];\n                    if (notlast) {\n                        p = p + z * matrixP[i][k + 2];\n                        matrixP[i][k + 2] = matrixP[i][k + 2] - p * r;\n                    }\n                    matrixP[i][k] = matrixP[i][k] - p;\n                    matrixP[i][k + 1] = matrixP[i][k + 1] - p * q;\n                }\n            }  // (s != 0)\n        }  // k loop\n\n        // clean up pollution due to round-off errors\n        for (int i = im + 2; i <= iu; i++) {\n            matrixT[i][i-2] = 0.0;\n            if (i > im + 2) {\n                matrixT[i][i-3] = 0.0;\n            }\n        }\n    }",
          "84": "    private void performDoubleQRStep(final int il, final int im, final int iu,\n                                     final ShiftInfo shift, final double[] hVec) {\n\n        final int n = matrixT.length;\n        double p = hVec[0];\n        double q = hVec[1];\n        double r = hVec[2];\n\n        for (int k = im; k <= iu - 1; k++) {\n            boolean notlast = k != (iu - 1);\n            if (k != im) {\n                p = matrixT[k][k - 1];\n                q = matrixT[k + 1][k - 1];\n                r = notlast ? matrixT[k + 2][k - 1] : 0.0;\n                shift.x = FastMath.abs(p) + FastMath.abs(q) + FastMath.abs(r);\n                if (!Precision.equals(shift.x, 0.0, epsilon)) {\n                    p = p / shift.x;\n                    q = q / shift.x;\n                    r = r / shift.x;\n                }\n            }\n            if (shift.x == 0.0) {\n                break;\n            }\n            double s = FastMath.sqrt(p * p + q * q + r * r);\n            if (p < 0.0) {\n                s = -s;\n            }\n            if (s != 0.0) {\n                if (k != im) {\n                    matrixT[k][k - 1] = -s * shift.x;\n                } else if (il != im) {\np = ((matrixT[k].[(k - 1)] == null))?0:matrixT[k].[(k - 1)];\n                }\n                p = p + s;\n                shift.x = p / s;\n                shift.y = q / s;\n                double z = r / s;\n                q = q / p;\n                r = r / p;\n\n                // Row modification\n                for (int j = k; j < n; j++) {\n                    p = matrixT[k][j] + q * matrixT[k + 1][j];\n                    if (notlast) {\n                        p = p + r * matrixT[k + 2][j];\n                        matrixT[k + 2][j] = matrixT[k + 2][j] - p * z;\n                    }\n                    matrixT[k][j] = matrixT[k][j] - p * shift.x;\n                    matrixT[k + 1][j] = matrixT[k + 1][j] - p * shift.y;\n                }\n\n                // Column modification\n                for (int i = 0; i <= FastMath.min(iu, k + 3); i++) {\n                    p = shift.x * matrixT[i][k] + shift.y * matrixT[i][k + 1];\n                    if (notlast) {\n                        p = p + z * matrixT[i][k + 2];\n                        matrixT[i][k + 2] = matrixT[i][k + 2] - p * r;\n                    }\n                    matrixT[i][k] = matrixT[i][k] - p;\n                    matrixT[i][k + 1] = matrixT[i][k + 1] - p * q;\n                }\n\n                // Accumulate transformations\n                final int high = matrixT.length - 1;\n                for (int i = 0; i <= high; i++) {\n                    p = shift.x * matrixP[i][k] + shift.y * matrixP[i][k + 1];\n                    if (notlast) {\n                        p = p + z * matrixP[i][k + 2];\n                        matrixP[i][k + 2] = matrixP[i][k + 2] - p * r;\n                    }\n                    matrixP[i][k] = matrixP[i][k] - p;\n                    matrixP[i][k + 1] = matrixP[i][k + 1] - p * q;\n                }\n            }  // (s != 0)\n        }  // k loop\n\n        // clean up pollution due to round-off errors\n        for (int i = im + 2; i <= iu; i++) {\n            matrixT[i][i-2] = 0.0;\n            if (i > im + 2) {\n                matrixT[i][i-3] = 0.0;\n            }\n        }\n    }",
          "85": "    private void performDoubleQRStep(final int il, final int im, final int iu,\n                                     final ShiftInfo shift, final double[] hVec) {\n\n        final int n = matrixT.length;\n        double p = hVec[0];\n        double q = hVec[1];\n        double r = hVec[2];\n\n        for (int k = im; k <= iu - 1; k++) {\n            boolean notlast = k != (iu - 1);\n            if (k != im) {\n                p = matrixT[k][k - 1];\n                q = matrixT[k + 1][k - 1];\n                r = notlast ? matrixT[k + 2][k - 1] : 0.0;\n                shift.x = FastMath.abs(p) + FastMath.abs(q) + FastMath.abs(r);\n                if (!Precision.equals(shift.x, 0.0, epsilon)) {\n                    p = p / shift.x;\n                    q = q / shift.x;\n                    r = r / shift.x;\n                }\n            }\n            if (shift.x == 0.0) {\n                break;\n            }\n            double s = FastMath.sqrt(p * p + q * q + r * r);\n            if (p < 0.0) {\n                s = -s;\n            }\n            if (s != 0.0) {\n                if (k != im) {\n                    matrixT[k][k - 1] = -s * shift.x;\n                } else if (il != im) {\nmatrixT[k].[(k - 1)] = ((matrixT[k].[(k - 1)] != null))?0:matrixT[k].[(k - 1)];\n                }\n                p = p + s;\n                shift.x = p / s;\n                shift.y = q / s;\n                double z = r / s;\n                q = q / p;\n                r = r / p;\n\n                // Row modification\n                for (int j = k; j < n; j++) {\n                    p = matrixT[k][j] + q * matrixT[k + 1][j];\n                    if (notlast) {\n                        p = p + r * matrixT[k + 2][j];\n                        matrixT[k + 2][j] = matrixT[k + 2][j] - p * z;\n                    }\n                    matrixT[k][j] = matrixT[k][j] - p * shift.x;\n                    matrixT[k + 1][j] = matrixT[k + 1][j] - p * shift.y;\n                }\n\n                // Column modification\n                for (int i = 0; i <= FastMath.min(iu, k + 3); i++) {\n                    p = shift.x * matrixT[i][k] + shift.y * matrixT[i][k + 1];\n                    if (notlast) {\n                        p = p + z * matrixT[i][k + 2];\n                        matrixT[i][k + 2] = matrixT[i][k + 2] - p * r;\n                    }\n                    matrixT[i][k] = matrixT[i][k] - p;\n                    matrixT[i][k + 1] = matrixT[i][k + 1] - p * q;\n                }\n\n                // Accumulate transformations\n                final int high = matrixT.length - 1;\n                for (int i = 0; i <= high; i++) {\n                    p = shift.x * matrixP[i][k] + shift.y * matrixP[i][k + 1];\n                    if (notlast) {\n                        p = p + z * matrixP[i][k + 2];\n                        matrixP[i][k + 2] = matrixP[i][k + 2] - p * r;\n                    }\n                    matrixP[i][k] = matrixP[i][k] - p;\n                    matrixP[i][k + 1] = matrixP[i][k + 1] - p * q;\n                }\n            }  // (s != 0)\n        }  // k loop\n\n        // clean up pollution due to round-off errors\n        for (int i = im + 2; i <= iu; i++) {\n            matrixT[i][i-2] = 0.0;\n            if (i > im + 2) {\n                matrixT[i][i-3] = 0.0;\n            }\n        }\n    }",
          "86": "    private void performDoubleQRStep(final int il, final int im, final int iu,\n                                     final ShiftInfo shift, final double[] hVec) {\n\n        final int n = matrixT.length;\n        double p = hVec[0];\n        double q = hVec[1];\n        double r = hVec[2];\n\n        for (int k = im; k <= iu - 1; k++) {\n            boolean notlast = k != (iu - 1);\n            if (k != im) {\n                p = matrixT[k][k - 1];\n                q = matrixT[k + 1][k - 1];\n                r = notlast ? matrixT[k + 2][k - 1] : 0.0;\n                shift.x = FastMath.abs(p) + FastMath.abs(q) + FastMath.abs(r);\n                if (!Precision.equals(shift.x, 0.0, epsilon)) {\n                    p = p / shift.x;\n                    q = q / shift.x;\n                    r = r / shift.x;\n                }\n            }\n            if (shift.x == 0.0) {\n                break;\n            }\n            double s = FastMath.sqrt(p * p + q * q + r * r);\n            if (p < 0.0) {\n                s = -s;\n            }\n            if (s != 0.0) {\n                if (k != im) {\n                    matrixT[k][k - 1] = -s * shift.x;\n                } else if (il != im) {\nmatrixT[k].[(k - 1)] = ((matrixT[(k - 1)].[k] != null))?matrixT[k].[(k - 1)]:matrixT[k].[(k - 1)];\n                }\n                p = p + s;\n                shift.x = p / s;\n                shift.y = q / s;\n                double z = r / s;\n                q = q / p;\n                r = r / p;\n\n                // Row modification\n                for (int j = k; j < n; j++) {\n                    p = matrixT[k][j] + q * matrixT[k + 1][j];\n                    if (notlast) {\n                        p = p + r * matrixT[k + 2][j];\n                        matrixT[k + 2][j] = matrixT[k + 2][j] - p * z;\n                    }\n                    matrixT[k][j] = matrixT[k][j] - p * shift.x;\n                    matrixT[k + 1][j] = matrixT[k + 1][j] - p * shift.y;\n                }\n\n                // Column modification\n                for (int i = 0; i <= FastMath.min(iu, k + 3); i++) {\n                    p = shift.x * matrixT[i][k] + shift.y * matrixT[i][k + 1];\n                    if (notlast) {\n                        p = p + z * matrixT[i][k + 2];\n                        matrixT[i][k + 2] = matrixT[i][k + 2] - p * r;\n                    }\n                    matrixT[i][k] = matrixT[i][k] - p;\n                    matrixT[i][k + 1] = matrixT[i][k + 1] - p * q;\n                }\n\n                // Accumulate transformations\n                final int high = matrixT.length - 1;\n                for (int i = 0; i <= high; i++) {\n                    p = shift.x * matrixP[i][k] + shift.y * matrixP[i][k + 1];\n                    if (notlast) {\n                        p = p + z * matrixP[i][k + 2];\n                        matrixP[i][k + 2] = matrixP[i][k + 2] - p * r;\n                    }\n                    matrixP[i][k] = matrixP[i][k] - p;\n                    matrixP[i][k + 1] = matrixP[i][k + 1] - p * q;\n                }\n            }  // (s != 0)\n        }  // k loop\n\n        // clean up pollution due to round-off errors\n        for (int i = im + 2; i <= iu; i++) {\n            matrixT[i][i-2] = 0.0;\n            if (i > im + 2) {\n                matrixT[i][i-3] = 0.0;\n            }\n        }\n    }",
          "87": "    private void performDoubleQRStep(final int il, final int im, final int iu,\n                                     final ShiftInfo shift, final double[] hVec) {\n\n        final int n = matrixT.length;\n        double p = hVec[0];\n        double q = hVec[1];\n        double r = hVec[2];\n\n        for (int k = im; k <= iu - 1; k++) {\n            boolean notlast = k != (iu - 1);\n            if (k != im) {\n                p = matrixT[k][k - 1];\n                q = matrixT[k + 1][k - 1];\n                r = notlast ? matrixT[k + 2][k - 1] : 0.0;\n                shift.x = FastMath.abs(p) + FastMath.abs(q) + FastMath.abs(r);\n                if (!Precision.equals(shift.x, 0.0, epsilon)) {\n                    p = p / shift.x;\n                    q = q / shift.x;\n                    r = r / shift.x;\n                }\n            }\n            if (shift.x == 0.0) {\n                break;\n            }\n            double s = FastMath.sqrt(p * p + q * q + r * r);\n            if (p < 0.0) {\n                s = -s;\n            }\n            if (s != 0.0) {\n                if (k != im) {\n                    matrixT[k][k - 1] = -s * shift.x;\n                } else if (il != im) {\np = ((matrixT[(k - 1)].[k] == null))?matrixT[k].[(k - 1)]:matrixT[k].[(k - 1)];\n                }\n                p = p + s;\n                shift.x = p / s;\n                shift.y = q / s;\n                double z = r / s;\n                q = q / p;\n                r = r / p;\n\n                // Row modification\n                for (int j = k; j < n; j++) {\n                    p = matrixT[k][j] + q * matrixT[k + 1][j];\n                    if (notlast) {\n                        p = p + r * matrixT[k + 2][j];\n                        matrixT[k + 2][j] = matrixT[k + 2][j] - p * z;\n                    }\n                    matrixT[k][j] = matrixT[k][j] - p * shift.x;\n                    matrixT[k + 1][j] = matrixT[k + 1][j] - p * shift.y;\n                }\n\n                // Column modification\n                for (int i = 0; i <= FastMath.min(iu, k + 3); i++) {\n                    p = shift.x * matrixT[i][k] + shift.y * matrixT[i][k + 1];\n                    if (notlast) {\n                        p = p + z * matrixT[i][k + 2];\n                        matrixT[i][k + 2] = matrixT[i][k + 2] - p * r;\n                    }\n                    matrixT[i][k] = matrixT[i][k] - p;\n                    matrixT[i][k + 1] = matrixT[i][k + 1] - p * q;\n                }\n\n                // Accumulate transformations\n                final int high = matrixT.length - 1;\n                for (int i = 0; i <= high; i++) {\n                    p = shift.x * matrixP[i][k] + shift.y * matrixP[i][k + 1];\n                    if (notlast) {\n                        p = p + z * matrixP[i][k + 2];\n                        matrixP[i][k + 2] = matrixP[i][k + 2] - p * r;\n                    }\n                    matrixP[i][k] = matrixP[i][k] - p;\n                    matrixP[i][k + 1] = matrixP[i][k + 1] - p * q;\n                }\n            }  // (s != 0)\n        }  // k loop\n\n        // clean up pollution due to round-off errors\n        for (int i = im + 2; i <= iu; i++) {\n            matrixT[i][i-2] = 0.0;\n            if (i > im + 2) {\n                matrixT[i][i-3] = 0.0;\n            }\n        }\n    }",
          "88": "    private void performDoubleQRStep(final int il, final int im, final int iu,\n                                     final ShiftInfo shift, final double[] hVec) {\n\n        final int n = matrixT.length;\n        double p = hVec[0];\n        double q = hVec[1];\n        double r = hVec[2];\n\n        for (int k = im; k <= iu - 1; k++) {\n            boolean notlast = k != (iu - 1);\n            if (k != im) {\n                p = matrixT[k][k - 1];\n                q = matrixT[k + 1][k - 1];\n                r = notlast ? matrixT[k + 2][k - 1] : 0.0;\n                shift.x = FastMath.abs(p) + FastMath.abs(q) + FastMath.abs(r);\n                if (!Precision.equals(shift.x, 0.0, epsilon)) {\n                    p = p / shift.x;\n                    q = q / shift.x;\n                    r = r / shift.x;\n                }\n            }\n            if (shift.x == 0.0) {\n                break;\n            }\n            double s = FastMath.sqrt(p * p + q * q + r * r);\n            if (p < 0.0) {\n                s = -s;\n            }\n            if (s != 0.0) {\n                if (k != im) {\n                    matrixT[k][k - 1] = -s * shift.x;\n                } else if (il != im) {\nmatrixT[k].[(k - 1)] = ((matrixT[k].[(k - 1)] != null))?matrixT[k].[(k - 1)]:matrixT[k].[(k - 1)];\n                }\n                p = p + s;\n                shift.x = p / s;\n                shift.y = q / s;\n                double z = r / s;\n                q = q / p;\n                r = r / p;\n\n                // Row modification\n                for (int j = k; j < n; j++) {\n                    p = matrixT[k][j] + q * matrixT[k + 1][j];\n                    if (notlast) {\n                        p = p + r * matrixT[k + 2][j];\n                        matrixT[k + 2][j] = matrixT[k + 2][j] - p * z;\n                    }\n                    matrixT[k][j] = matrixT[k][j] - p * shift.x;\n                    matrixT[k + 1][j] = matrixT[k + 1][j] - p * shift.y;\n                }\n\n                // Column modification\n                for (int i = 0; i <= FastMath.min(iu, k + 3); i++) {\n                    p = shift.x * matrixT[i][k] + shift.y * matrixT[i][k + 1];\n                    if (notlast) {\n                        p = p + z * matrixT[i][k + 2];\n                        matrixT[i][k + 2] = matrixT[i][k + 2] - p * r;\n                    }\n                    matrixT[i][k] = matrixT[i][k] - p;\n                    matrixT[i][k + 1] = matrixT[i][k + 1] - p * q;\n                }\n\n                // Accumulate transformations\n                final int high = matrixT.length - 1;\n                for (int i = 0; i <= high; i++) {\n                    p = shift.x * matrixP[i][k] + shift.y * matrixP[i][k + 1];\n                    if (notlast) {\n                        p = p + z * matrixP[i][k + 2];\n                        matrixP[i][k + 2] = matrixP[i][k + 2] - p * r;\n                    }\n                    matrixP[i][k] = matrixP[i][k] - p;\n                    matrixP[i][k + 1] = matrixP[i][k + 1] - p * q;\n                }\n            }  // (s != 0)\n        }  // k loop\n\n        // clean up pollution due to round-off errors\n        for (int i = im + 2; i <= iu; i++) {\n            matrixT[i][i-2] = 0.0;\n            if (i > im + 2) {\n                matrixT[i][i-3] = 0.0;\n            }\n        }\n    }",
          "89": "    private void performDoubleQRStep(final int il, final int im, final int iu,\n                                     final ShiftInfo shift, final double[] hVec) {\n\n        final int n = matrixT.length;\n        double p = hVec[0];\n        double q = hVec[1];\n        double r = hVec[2];\n\n        for (int k = im; k <= iu - 1; k++) {\n            boolean notlast = k != (iu - 1);\n            if (k != im) {\n                p = matrixT[k][k - 1];\n                q = matrixT[k + 1][k - 1];\n                r = notlast ? matrixT[k + 2][k - 1] : 0.0;\n                shift.x = FastMath.abs(p) + FastMath.abs(q) + FastMath.abs(r);\n                if (!Precision.equals(shift.x, 0.0, epsilon)) {\n                    p = p / shift.x;\n                    q = q / shift.x;\n                    r = r / shift.x;\n                }\n            }\n            if (shift.x == 0.0) {\n                break;\n            }\n            double s = FastMath.sqrt(p * p + q * q + r * r);\n            if (p < 0.0) {\n                s = -s;\n            }\n            if (s != 0.0) {\n                if (k != im) {\n                    matrixT[k][k - 1] = -s * shift.x;\n                } else if (il != im) {\np = ((matrixT[(k - 1)].[(k - 1)] == null))?0:matrixT[k].[(k - 1)];\n                }\n                p = p + s;\n                shift.x = p / s;\n                shift.y = q / s;\n                double z = r / s;\n                q = q / p;\n                r = r / p;\n\n                // Row modification\n                for (int j = k; j < n; j++) {\n                    p = matrixT[k][j] + q * matrixT[k + 1][j];\n                    if (notlast) {\n                        p = p + r * matrixT[k + 2][j];\n                        matrixT[k + 2][j] = matrixT[k + 2][j] - p * z;\n                    }\n                    matrixT[k][j] = matrixT[k][j] - p * shift.x;\n                    matrixT[k + 1][j] = matrixT[k + 1][j] - p * shift.y;\n                }\n\n                // Column modification\n                for (int i = 0; i <= FastMath.min(iu, k + 3); i++) {\n                    p = shift.x * matrixT[i][k] + shift.y * matrixT[i][k + 1];\n                    if (notlast) {\n                        p = p + z * matrixT[i][k + 2];\n                        matrixT[i][k + 2] = matrixT[i][k + 2] - p * r;\n                    }\n                    matrixT[i][k] = matrixT[i][k] - p;\n                    matrixT[i][k + 1] = matrixT[i][k + 1] - p * q;\n                }\n\n                // Accumulate transformations\n                final int high = matrixT.length - 1;\n                for (int i = 0; i <= high; i++) {\n                    p = shift.x * matrixP[i][k] + shift.y * matrixP[i][k + 1];\n                    if (notlast) {\n                        p = p + z * matrixP[i][k + 2];\n                        matrixP[i][k + 2] = matrixP[i][k + 2] - p * r;\n                    }\n                    matrixP[i][k] = matrixP[i][k] - p;\n                    matrixP[i][k + 1] = matrixP[i][k + 1] - p * q;\n                }\n            }  // (s != 0)\n        }  // k loop\n\n        // clean up pollution due to round-off errors\n        for (int i = im + 2; i <= iu; i++) {\n            matrixT[i][i-2] = 0.0;\n            if (i > im + 2) {\n                matrixT[i][i-3] = 0.0;\n            }\n        }\n    }",
          "90": "    private void performDoubleQRStep(final int il, final int im, final int iu,\n                                     final ShiftInfo shift, final double[] hVec) {\n\n        final int n = matrixT.length;\n        double p = hVec[0];\n        double q = hVec[1];\n        double r = hVec[2];\n\n        for (int k = im; k <= iu - 1; k++) {\n            boolean notlast = k != (iu - 1);\n            if (k != im) {\n                p = matrixT[k][k - 1];\n                q = matrixT[k + 1][k - 1];\n                r = notlast ? matrixT[k + 2][k - 1] : 0.0;\n                shift.x = FastMath.abs(p) + FastMath.abs(q) + FastMath.abs(r);\n                if (!Precision.equals(shift.x, 0.0, epsilon)) {\n                    p = p / shift.x;\n                    q = q / shift.x;\n                    r = r / shift.x;\n                }\n            }\n            if (shift.x == 0.0) {\n                break;\n            }\n            double s = FastMath.sqrt(p * p + q * q + r * r);\n            if (p < 0.0) {\n                s = -s;\n            }\n            if (s != 0.0) {\n                if (k != im) {\n                    matrixT[k][k - 1] = -s * shift.x;\n                } else if (il != im) {\np = ((matrixT[k].[(k - 1)] == null))?matrixT[k].[(k - 1)]:matrixT[k].[(k - 1)];\n                }\n                p = p + s;\n                shift.x = p / s;\n                shift.y = q / s;\n                double z = r / s;\n                q = q / p;\n                r = r / p;\n\n                // Row modification\n                for (int j = k; j < n; j++) {\n                    p = matrixT[k][j] + q * matrixT[k + 1][j];\n                    if (notlast) {\n                        p = p + r * matrixT[k + 2][j];\n                        matrixT[k + 2][j] = matrixT[k + 2][j] - p * z;\n                    }\n                    matrixT[k][j] = matrixT[k][j] - p * shift.x;\n                    matrixT[k + 1][j] = matrixT[k + 1][j] - p * shift.y;\n                }\n\n                // Column modification\n                for (int i = 0; i <= FastMath.min(iu, k + 3); i++) {\n                    p = shift.x * matrixT[i][k] + shift.y * matrixT[i][k + 1];\n                    if (notlast) {\n                        p = p + z * matrixT[i][k + 2];\n                        matrixT[i][k + 2] = matrixT[i][k + 2] - p * r;\n                    }\n                    matrixT[i][k] = matrixT[i][k] - p;\n                    matrixT[i][k + 1] = matrixT[i][k + 1] - p * q;\n                }\n\n                // Accumulate transformations\n                final int high = matrixT.length - 1;\n                for (int i = 0; i <= high; i++) {\n                    p = shift.x * matrixP[i][k] + shift.y * matrixP[i][k + 1];\n                    if (notlast) {\n                        p = p + z * matrixP[i][k + 2];\n                        matrixP[i][k + 2] = matrixP[i][k + 2] - p * r;\n                    }\n                    matrixP[i][k] = matrixP[i][k] - p;\n                    matrixP[i][k + 1] = matrixP[i][k + 1] - p * q;\n                }\n            }  // (s != 0)\n        }  // k loop\n\n        // clean up pollution due to round-off errors\n        for (int i = im + 2; i <= iu; i++) {\n            matrixT[i][i-2] = 0.0;\n            if (i > im + 2) {\n                matrixT[i][i-3] = 0.0;\n            }\n        }\n    }",
          "91": "    private void performDoubleQRStep(final int il, final int im, final int iu,\n                                     final ShiftInfo shift, final double[] hVec) {\n\n        final int n = matrixT.length;\n        double p = hVec[0];\n        double q = hVec[1];\n        double r = hVec[2];\n\n        for (int k = im; k <= iu - 1; k++) {\n            boolean notlast = k != (iu - 1);\n            if (k != im) {\n                p = matrixT[k][k - 1];\n                q = matrixT[k + 1][k - 1];\n                r = notlast ? matrixT[k + 2][k - 1] : 0.0;\n                shift.x = FastMath.abs(p) + FastMath.abs(q) + FastMath.abs(r);\n                if (!Precision.equals(shift.x, 0.0, epsilon)) {\n                    p = p / shift.x;\n                    q = q / shift.x;\n                    r = r / shift.x;\n                }\n            }\n            if (shift.x == 0.0) {\n                break;\n            }\n            double s = FastMath.sqrt(p * p + q * q + r * r);\n            if (p < 0.0) {\n                s = -s;\n            }\n            if (s != 0.0) {\n                if (k != im) {\n                    matrixT[k][k - 1] = -s * shift.x;\n                } else if (il != im) {\nmatrixT[k].[(k - 1)] = ((matrixT[(k - 1)].[(k - 1)] != null))?0:matrixT[k].[(k - 1)];\n                }\n                p = p + s;\n                shift.x = p / s;\n                shift.y = q / s;\n                double z = r / s;\n                q = q / p;\n                r = r / p;\n\n                // Row modification\n                for (int j = k; j < n; j++) {\n                    p = matrixT[k][j] + q * matrixT[k + 1][j];\n                    if (notlast) {\n                        p = p + r * matrixT[k + 2][j];\n                        matrixT[k + 2][j] = matrixT[k + 2][j] - p * z;\n                    }\n                    matrixT[k][j] = matrixT[k][j] - p * shift.x;\n                    matrixT[k + 1][j] = matrixT[k + 1][j] - p * shift.y;\n                }\n\n                // Column modification\n                for (int i = 0; i <= FastMath.min(iu, k + 3); i++) {\n                    p = shift.x * matrixT[i][k] + shift.y * matrixT[i][k + 1];\n                    if (notlast) {\n                        p = p + z * matrixT[i][k + 2];\n                        matrixT[i][k + 2] = matrixT[i][k + 2] - p * r;\n                    }\n                    matrixT[i][k] = matrixT[i][k] - p;\n                    matrixT[i][k + 1] = matrixT[i][k + 1] - p * q;\n                }\n\n                // Accumulate transformations\n                final int high = matrixT.length - 1;\n                for (int i = 0; i <= high; i++) {\n                    p = shift.x * matrixP[i][k] + shift.y * matrixP[i][k + 1];\n                    if (notlast) {\n                        p = p + z * matrixP[i][k + 2];\n                        matrixP[i][k + 2] = matrixP[i][k + 2] - p * r;\n                    }\n                    matrixP[i][k] = matrixP[i][k] - p;\n                    matrixP[i][k + 1] = matrixP[i][k + 1] - p * q;\n                }\n            }  // (s != 0)\n        }  // k loop\n\n        // clean up pollution due to round-off errors\n        for (int i = im + 2; i <= iu; i++) {\n            matrixT[i][i-2] = 0.0;\n            if (i > im + 2) {\n                matrixT[i][i-3] = 0.0;\n            }\n        }\n    }",
          "92": "    private void performDoubleQRStep(final int il, final int im, final int iu,\n                                     final ShiftInfo shift, final double[] hVec) {\n\n        final int n = matrixT.length;\n        double p = hVec[0];\n        double q = hVec[1];\n        double r = hVec[2];\n\n        for (int k = im; k <= iu - 1; k++) {\n            boolean notlast = k != (iu - 1);\n            if (k != im) {\n                p = matrixT[k][k - 1];\n                q = matrixT[k + 1][k - 1];\n                r = notlast ? matrixT[k + 2][k - 1] : 0.0;\n                shift.x = FastMath.abs(p) + FastMath.abs(q) + FastMath.abs(r);\n                if (!Precision.equals(shift.x, 0.0, epsilon)) {\n                    p = p / shift.x;\n                    q = q / shift.x;\n                    r = r / shift.x;\n                }\n            }\n            if (shift.x == 0.0) {\n                break;\n            }\n            double s = FastMath.sqrt(p * p + q * q + r * r);\n            if (p < 0.0) {\n                s = -s;\n            }\n            if (s != 0.0) {\n                if (k != im) {\n                    matrixT[k][k - 1] = -s * shift.x;\n                } else if (il != im) {\nmatrixT[k].[(k - 1)] = ((matrixT[(k - 1)].[(k - 1)] != null))?matrixT[k].[(k - 1)]:matrixT[k].[(k - 1)];\n                }\n                p = p + s;\n                shift.x = p / s;\n                shift.y = q / s;\n                double z = r / s;\n                q = q / p;\n                r = r / p;\n\n                // Row modification\n                for (int j = k; j < n; j++) {\n                    p = matrixT[k][j] + q * matrixT[k + 1][j];\n                    if (notlast) {\n                        p = p + r * matrixT[k + 2][j];\n                        matrixT[k + 2][j] = matrixT[k + 2][j] - p * z;\n                    }\n                    matrixT[k][j] = matrixT[k][j] - p * shift.x;\n                    matrixT[k + 1][j] = matrixT[k + 1][j] - p * shift.y;\n                }\n\n                // Column modification\n                for (int i = 0; i <= FastMath.min(iu, k + 3); i++) {\n                    p = shift.x * matrixT[i][k] + shift.y * matrixT[i][k + 1];\n                    if (notlast) {\n                        p = p + z * matrixT[i][k + 2];\n                        matrixT[i][k + 2] = matrixT[i][k + 2] - p * r;\n                    }\n                    matrixT[i][k] = matrixT[i][k] - p;\n                    matrixT[i][k + 1] = matrixT[i][k + 1] - p * q;\n                }\n\n                // Accumulate transformations\n                final int high = matrixT.length - 1;\n                for (int i = 0; i <= high; i++) {\n                    p = shift.x * matrixP[i][k] + shift.y * matrixP[i][k + 1];\n                    if (notlast) {\n                        p = p + z * matrixP[i][k + 2];\n                        matrixP[i][k + 2] = matrixP[i][k + 2] - p * r;\n                    }\n                    matrixP[i][k] = matrixP[i][k] - p;\n                    matrixP[i][k + 1] = matrixP[i][k + 1] - p * q;\n                }\n            }  // (s != 0)\n        }  // k loop\n\n        // clean up pollution due to round-off errors\n        for (int i = im + 2; i <= iu; i++) {\n            matrixT[i][i-2] = 0.0;\n            if (i > im + 2) {\n                matrixT[i][i-3] = 0.0;\n            }\n        }\n    }",
          "93": "    private void performDoubleQRStep(final int il, final int im, final int iu,\n                                     final ShiftInfo shift, final double[] hVec) {\n\n        final int n = matrixT.length;\n        double p = hVec[0];\n        double q = hVec[1];\n        double r = hVec[2];\n\n        for (int k = im; k <= iu - 1; k++) {\n            boolean notlast = k != (iu - 1);\n            if (k != im) {\n                p = matrixT[k][k - 1];\n                q = matrixT[k + 1][k - 1];\n                r = notlast ? matrixT[k + 2][k - 1] : 0.0;\n                shift.x = FastMath.abs(p) + FastMath.abs(q) + FastMath.abs(r);\n                if (!Precision.equals(shift.x, 0.0, epsilon)) {\n                    p = p / shift.x;\n                    q = q / shift.x;\n                    r = r / shift.x;\n                }\n            }\n            if (shift.x == 0.0) {\n                break;\n            }\n            double s = FastMath.sqrt(p * p + q * q + r * r);\n            if (p < 0.0) {\n                s = -s;\n            }\n            if (s != 0.0) {\n                if (k != im) {\n                    matrixT[k][k - 1] = -s * shift.x;\n                } else if (il != im) {\np = ((matrixT[(k - 1)].[(k - 1)] == null))?matrixT[k].[(k - 1)]:matrixT[k].[(k - 1)];\n                }\n                p = p + s;\n                shift.x = p / s;\n                shift.y = q / s;\n                double z = r / s;\n                q = q / p;\n                r = r / p;\n\n                // Row modification\n                for (int j = k; j < n; j++) {\n                    p = matrixT[k][j] + q * matrixT[k + 1][j];\n                    if (notlast) {\n                        p = p + r * matrixT[k + 2][j];\n                        matrixT[k + 2][j] = matrixT[k + 2][j] - p * z;\n                    }\n                    matrixT[k][j] = matrixT[k][j] - p * shift.x;\n                    matrixT[k + 1][j] = matrixT[k + 1][j] - p * shift.y;\n                }\n\n                // Column modification\n                for (int i = 0; i <= FastMath.min(iu, k + 3); i++) {\n                    p = shift.x * matrixT[i][k] + shift.y * matrixT[i][k + 1];\n                    if (notlast) {\n                        p = p + z * matrixT[i][k + 2];\n                        matrixT[i][k + 2] = matrixT[i][k + 2] - p * r;\n                    }\n                    matrixT[i][k] = matrixT[i][k] - p;\n                    matrixT[i][k + 1] = matrixT[i][k + 1] - p * q;\n                }\n\n                // Accumulate transformations\n                final int high = matrixT.length - 1;\n                for (int i = 0; i <= high; i++) {\n                    p = shift.x * matrixP[i][k] + shift.y * matrixP[i][k + 1];\n                    if (notlast) {\n                        p = p + z * matrixP[i][k + 2];\n                        matrixP[i][k + 2] = matrixP[i][k + 2] - p * r;\n                    }\n                    matrixP[i][k] = matrixP[i][k] - p;\n                    matrixP[i][k + 1] = matrixP[i][k + 1] - p * q;\n                }\n            }  // (s != 0)\n        }  // k loop\n\n        // clean up pollution due to round-off errors\n        for (int i = im + 2; i <= iu; i++) {\n            matrixT[i][i-2] = 0.0;\n            if (i > im + 2) {\n                matrixT[i][i-3] = 0.0;\n            }\n        }\n    }",
          "94": "    private void performDoubleQRStep(final int il, final int im, final int iu,\n                                     final ShiftInfo shift, final double[] hVec) {\n\n        final int n = matrixT.length;\n        double p = hVec[0];\n        double q = hVec[1];\n        double r = hVec[2];\n\n        for (int k = im; k <= iu - 1; k++) {\n            boolean notlast = k != (iu - 1);\n            if (k != im) {\n                p = matrixT[k][k - 1];\n                q = matrixT[k + 1][k - 1];\n                r = notlast ? matrixT[k + 2][k - 1] : 0.0;\n                shift.x = FastMath.abs(p) + FastMath.abs(q) + FastMath.abs(r);\n                if (!Precision.equals(shift.x, 0.0, epsilon)) {\n                    p = p / shift.x;\n                    q = q / shift.x;\n                    r = r / shift.x;\n                }\n            }\n            if (shift.x == 0.0) {\n                break;\n            }\n            double s = FastMath.sqrt(p * p + q * q + r * r);\n            if (p < 0.0) {\n                s = -s;\n            }\n            if (s != 0.0) {\n                if (k != im) {\n                    matrixT[k][k - 1] = -s * shift.x;\n                } else if (il != im) {\nr = ((matrixT[k].[k] == null))?matrixT[k].[(k - 1)]:matrixT[k].[(k - 1)];\n                }\n                p = p + s;\n                shift.x = p / s;\n                shift.y = q / s;\n                double z = r / s;\n                q = q / p;\n                r = r / p;\n\n                // Row modification\n                for (int j = k; j < n; j++) {\n                    p = matrixT[k][j] + q * matrixT[k + 1][j];\n                    if (notlast) {\n                        p = p + r * matrixT[k + 2][j];\n                        matrixT[k + 2][j] = matrixT[k + 2][j] - p * z;\n                    }\n                    matrixT[k][j] = matrixT[k][j] - p * shift.x;\n                    matrixT[k + 1][j] = matrixT[k + 1][j] - p * shift.y;\n                }\n\n                // Column modification\n                for (int i = 0; i <= FastMath.min(iu, k + 3); i++) {\n                    p = shift.x * matrixT[i][k] + shift.y * matrixT[i][k + 1];\n                    if (notlast) {\n                        p = p + z * matrixT[i][k + 2];\n                        matrixT[i][k + 2] = matrixT[i][k + 2] - p * r;\n                    }\n                    matrixT[i][k] = matrixT[i][k] - p;\n                    matrixT[i][k + 1] = matrixT[i][k + 1] - p * q;\n                }\n\n                // Accumulate transformations\n                final int high = matrixT.length - 1;\n                for (int i = 0; i <= high; i++) {\n                    p = shift.x * matrixP[i][k] + shift.y * matrixP[i][k + 1];\n                    if (notlast) {\n                        p = p + z * matrixP[i][k + 2];\n                        matrixP[i][k + 2] = matrixP[i][k + 2] - p * r;\n                    }\n                    matrixP[i][k] = matrixP[i][k] - p;\n                    matrixP[i][k + 1] = matrixP[i][k + 1] - p * q;\n                }\n            }  // (s != 0)\n        }  // k loop\n\n        // clean up pollution due to round-off errors\n        for (int i = im + 2; i <= iu; i++) {\n            matrixT[i][i-2] = 0.0;\n            if (i > im + 2) {\n                matrixT[i][i-3] = 0.0;\n            }\n        }\n    }",
          "95": "    private void performDoubleQRStep(final int il, final int im, final int iu,\n                                     final ShiftInfo shift, final double[] hVec) {\n\n        final int n = matrixT.length;\n        double p = hVec[0];\n        double q = hVec[1];\n        double r = hVec[2];\n\n        for (int k = im; k <= iu - 1; k++) {\n            boolean notlast = k != (iu - 1);\n            if (k != im) {\n                p = matrixT[k][k - 1];\n                q = matrixT[k + 1][k - 1];\n                r = notlast ? matrixT[k + 2][k - 1] : 0.0;\n                shift.x = FastMath.abs(p) + FastMath.abs(q) + FastMath.abs(r);\n                if (!Precision.equals(shift.x, 0.0, epsilon)) {\n                    p = p / shift.x;\n                    q = q / shift.x;\n                    r = r / shift.x;\n                }\n            }\n            if (shift.x == 0.0) {\n                break;\n            }\n            double s = FastMath.sqrt(p * p + q * q + r * r);\n            if (p < 0.0) {\n                s = -s;\n            }\n            if (s != 0.0) {\n                if (k != im) {\n                    matrixT[k][k - 1] = -s * shift.x;\n                } else if (il != im) {\nq = ((matrixT[k].[k] == null))?matrixT[k].[(k - 1)]:matrixT[k].[(k - 1)];\n                }\n                p = p + s;\n                shift.x = p / s;\n                shift.y = q / s;\n                double z = r / s;\n                q = q / p;\n                r = r / p;\n\n                // Row modification\n                for (int j = k; j < n; j++) {\n                    p = matrixT[k][j] + q * matrixT[k + 1][j];\n                    if (notlast) {\n                        p = p + r * matrixT[k + 2][j];\n                        matrixT[k + 2][j] = matrixT[k + 2][j] - p * z;\n                    }\n                    matrixT[k][j] = matrixT[k][j] - p * shift.x;\n                    matrixT[k + 1][j] = matrixT[k + 1][j] - p * shift.y;\n                }\n\n                // Column modification\n                for (int i = 0; i <= FastMath.min(iu, k + 3); i++) {\n                    p = shift.x * matrixT[i][k] + shift.y * matrixT[i][k + 1];\n                    if (notlast) {\n                        p = p + z * matrixT[i][k + 2];\n                        matrixT[i][k + 2] = matrixT[i][k + 2] - p * r;\n                    }\n                    matrixT[i][k] = matrixT[i][k] - p;\n                    matrixT[i][k + 1] = matrixT[i][k + 1] - p * q;\n                }\n\n                // Accumulate transformations\n                final int high = matrixT.length - 1;\n                for (int i = 0; i <= high; i++) {\n                    p = shift.x * matrixP[i][k] + shift.y * matrixP[i][k + 1];\n                    if (notlast) {\n                        p = p + z * matrixP[i][k + 2];\n                        matrixP[i][k + 2] = matrixP[i][k + 2] - p * r;\n                    }\n                    matrixP[i][k] = matrixP[i][k] - p;\n                    matrixP[i][k + 1] = matrixP[i][k + 1] - p * q;\n                }\n            }  // (s != 0)\n        }  // k loop\n\n        // clean up pollution due to round-off errors\n        for (int i = im + 2; i <= iu; i++) {\n            matrixT[i][i-2] = 0.0;\n            if (i > im + 2) {\n                matrixT[i][i-3] = 0.0;\n            }\n        }\n    }",
          "96": "    private void performDoubleQRStep(final int il, final int im, final int iu,\n                                     final ShiftInfo shift, final double[] hVec) {\n\n        final int n = matrixT.length;\n        double p = hVec[0];\n        double q = hVec[1];\n        double r = hVec[2];\n\n        for (int k = im; k <= iu - 1; k++) {\n            boolean notlast = k != (iu - 1);\n            if (k != im) {\n                p = matrixT[k][k - 1];\n                q = matrixT[k + 1][k - 1];\n                r = notlast ? matrixT[k + 2][k - 1] : 0.0;\n                shift.x = FastMath.abs(p) + FastMath.abs(q) + FastMath.abs(r);\n                if (!Precision.equals(shift.x, 0.0, epsilon)) {\n                    p = p / shift.x;\n                    q = q / shift.x;\n                    r = r / shift.x;\n                }\n            }\n            if (shift.x == 0.0) {\n                break;\n            }\n            double s = FastMath.sqrt(p * p + q * q + r * r);\n            if (p < 0.0) {\n                s = -s;\n            }\n            if (s != 0.0) {\n                if (k != im) {\n                    matrixT[k][k - 1] = -s * shift.x;\n                } else if (il != im) {\np = ((matrixT[k].[k] != null))?matrixT[k].[(k - 1)]:matrixT[k].[(k - 1)];\n                }\n                p = p + s;\n                shift.x = p / s;\n                shift.y = q / s;\n                double z = r / s;\n                q = q / p;\n                r = r / p;\n\n                // Row modification\n                for (int j = k; j < n; j++) {\n                    p = matrixT[k][j] + q * matrixT[k + 1][j];\n                    if (notlast) {\n                        p = p + r * matrixT[k + 2][j];\n                        matrixT[k + 2][j] = matrixT[k + 2][j] - p * z;\n                    }\n                    matrixT[k][j] = matrixT[k][j] - p * shift.x;\n                    matrixT[k + 1][j] = matrixT[k + 1][j] - p * shift.y;\n                }\n\n                // Column modification\n                for (int i = 0; i <= FastMath.min(iu, k + 3); i++) {\n                    p = shift.x * matrixT[i][k] + shift.y * matrixT[i][k + 1];\n                    if (notlast) {\n                        p = p + z * matrixT[i][k + 2];\n                        matrixT[i][k + 2] = matrixT[i][k + 2] - p * r;\n                    }\n                    matrixT[i][k] = matrixT[i][k] - p;\n                    matrixT[i][k + 1] = matrixT[i][k + 1] - p * q;\n                }\n\n                // Accumulate transformations\n                final int high = matrixT.length - 1;\n                for (int i = 0; i <= high; i++) {\n                    p = shift.x * matrixP[i][k] + shift.y * matrixP[i][k + 1];\n                    if (notlast) {\n                        p = p + z * matrixP[i][k + 2];\n                        matrixP[i][k + 2] = matrixP[i][k + 2] - p * r;\n                    }\n                    matrixP[i][k] = matrixP[i][k] - p;\n                    matrixP[i][k + 1] = matrixP[i][k + 1] - p * q;\n                }\n            }  // (s != 0)\n        }  // k loop\n\n        // clean up pollution due to round-off errors\n        for (int i = im + 2; i <= iu; i++) {\n            matrixT[i][i-2] = 0.0;\n            if (i > im + 2) {\n                matrixT[i][i-3] = 0.0;\n            }\n        }\n    }"
}