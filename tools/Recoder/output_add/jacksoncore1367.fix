{
          "0": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\nint ix = (hash | DEFAULT_TABLE_SIZE);\n        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\n        if ((((val >> 8) ^ hash) << 8) == 0) { // match\n            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "1": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\nint ix = (hash | MAX_TABLE_SIZE);\n        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\n        if ((((val >> 8) ^ hash) << 8) == 0) { // match\n            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "2": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\nint ix = (hash | MAX_ENTRIES_FOR_REUSE);\n        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\n        if ((((val >> 8) ^ hash) << 8) == 0) { // match\n            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "3": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\nint ix = (hash | MAX_COLL_CHAIN_LENGTH);\n        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\n        if ((((val >> 8) ^ hash) << 8) == 0) { // match\n            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "4": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\nint ix = (hash | MAX_COLL_CHAIN_FOR_REUSE);\n        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\n        if ((((val >> 8) ^ hash) << 8) == 0) { // match\n            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "5": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\nint ix = (hash | MIN_HASH_SIZE);\n        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\n        if ((((val >> 8) ^ hash) << 8) == 0) { // match\n            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "6": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\nint ix = (hash | INITIAL_COLLISION_LEN);\n        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\n        if ((((val >> 8) ^ hash) << 8) == 0) { // match\n            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "7": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\nint ix = (hash | LAST_VALID_BUCKET);\n        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\n        if ((((val >> 8) ^ hash) << 8) == 0) { // match\n            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "8": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\nint ix = (hash | _hashSeed);\n        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\n        if ((((val >> 8) ^ hash) << 8) == 0) { // match\n            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "9": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\nint ix = (hash | _count);\n        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\n        if ((((val >> 8) ^ hash) << 8) == 0) { // match\n            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "10": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\nint ix = (hash | _longestCollisionList);\n        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\n        if ((((val >> 8) ^ hash) << 8) == 0) { // match\n            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "11": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\nint ix = (hash | _mainHashMask);\n        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\n        if ((((val >> 8) ^ hash) << 8) == 0) { // match\n            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "12": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\nint ix = (hash | _mainHash);\n        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\n        if ((((val >> 8) ^ hash) << 8) == 0) { // match\n            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "13": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\nint ix = (hash | _collCount);\n        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\n        if ((((val >> 8) ^ hash) << 8) == 0) { // match\n            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "14": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\nint ix = (hash | _collEnd);\n        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\n        if ((((val >> 8) ^ hash) << 8) == 0) { // match\n            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "15": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\nint ix = (hash | MULT);\n        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\n        if ((((val >> 8) ^ hash) << 8) == 0) { // match\n            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "16": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\nint ix = (hash | MULT2);\n        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\n        if ((((val >> 8) ^ hash) << 8) == 0) { // match\n            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "17": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\nint ix = (hash | MULT3);\n        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\n        if ((((val >> 8) ^ hash) << 8) == 0) { // match\n            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "18": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\nint ix = (hash | count);\n        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\n        if ((((val >> 8) ^ hash) << 8) == 0) { // match\n            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "19": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\nint ix = (hash | mainHashMask);\n        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\n        if ((((val >> 8) ^ hash) << 8) == 0) { // match\n            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "20": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\nint ix = (hash | mainHash);\n        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\n        if ((((val >> 8) ^ hash) << 8) == 0) { // match\n            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "21": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\nint ix = (hash | collCount);\n        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\n        if ((((val >> 8) ^ hash) << 8) == 0) { // match\n            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "22": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\nint ix = (hash | collEnd);\n        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\n        if ((((val >> 8) ^ hash) << 8) == 0) { // match\n            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "23": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\nint ix = (hash | longestCollisionList);\n        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\n        if ((((val >> 8) ^ hash) << 8) == 0) { // match\n            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "24": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\nint ix = (hash | _length);\n        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\n        if ((((val >> 8) ^ hash) << 8) == 0) { // match\n            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "25": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\nint ix = (hash | hash);\n        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\n        if ((((val >> 8) ^ hash) << 8) == 0) { // match\n            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "26": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\nint ix = (hash | secondQuad);\n        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\n        if ((((val >> 8) ^ hash) << 8) == 0) { // match\n            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "27": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\nint ix = (hash | firstQuad);\n        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\n        if ((((val >> 8) ^ hash) << 8) == 0) { // match\n            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "28": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\nint ix = (hash | ix);\n        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\n        if ((((val >> 8) ^ hash) << 8) == 0) { // match\n            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "29": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\nint ix = (hash | DEFAULT_TABLE_SIZE._mainHashMask);\n        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\n        if ((((val >> 8) ^ hash) << 8) == 0) { // match\n            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "30": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\nint ix = (hash | MAX_TABLE_SIZE._mainHashMask);\n        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\n        if ((((val >> 8) ^ hash) << 8) == 0) { // match\n            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "31": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\nint ix = (hash | MAX_ENTRIES_FOR_REUSE._mainHashMask);\n        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\n        if ((((val >> 8) ^ hash) << 8) == 0) { // match\n            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "32": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\nint ix = (hash | MAX_COLL_CHAIN_LENGTH._mainHashMask);\n        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\n        if ((((val >> 8) ^ hash) << 8) == 0) { // match\n            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "33": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\nint ix = (hash | MAX_COLL_CHAIN_FOR_REUSE._mainHashMask);\n        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\n        if ((((val >> 8) ^ hash) << 8) == 0) { // match\n            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "34": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\nint ix = (hash | MIN_HASH_SIZE._mainHashMask);\n        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\n        if ((((val >> 8) ^ hash) << 8) == 0) { // match\n            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "35": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\nint ix = (hash | INITIAL_COLLISION_LEN._mainHashMask);\n        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\n        if ((((val >> 8) ^ hash) << 8) == 0) { // match\n            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "36": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\nint ix = (hash | LAST_VALID_BUCKET._mainHashMask);\n        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\n        if ((((val >> 8) ^ hash) << 8) == 0) { // match\n            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "37": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\nint ix = (hash | _hashSeed._mainHashMask);\n        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\n        if ((((val >> 8) ^ hash) << 8) == 0) { // match\n            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "38": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\nint ix = (hash | _count._mainHashMask);\n        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\n        if ((((val >> 8) ^ hash) << 8) == 0) { // match\n            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "39": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\nint ix = (hash | _longestCollisionList._mainHashMask);\n        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\n        if ((((val >> 8) ^ hash) << 8) == 0) { // match\n            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "40": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\nint ix = (hash | _mainHashMask._mainHashMask);\n        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\n        if ((((val >> 8) ^ hash) << 8) == 0) { // match\n            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "41": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\nint ix = (hash | _mainHash._mainHashMask);\n        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\n        if ((((val >> 8) ^ hash) << 8) == 0) { // match\n            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "42": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\nint ix = (hash | _collCount._mainHashMask);\n        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\n        if ((((val >> 8) ^ hash) << 8) == 0) { // match\n            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "43": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\nint ix = (hash | _collEnd._mainHashMask);\n        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\n        if ((((val >> 8) ^ hash) << 8) == 0) { // match\n            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "44": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\nint ix = (hash | MULT._mainHashMask);\n        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\n        if ((((val >> 8) ^ hash) << 8) == 0) { // match\n            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "45": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\nint ix = (hash | MULT2._mainHashMask);\n        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\n        if ((((val >> 8) ^ hash) << 8) == 0) { // match\n            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "46": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\nint ix = (hash | MULT3._mainHashMask);\n        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\n        if ((((val >> 8) ^ hash) << 8) == 0) { // match\n            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "47": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\nint ix = (hash | count._mainHashMask);\n        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\n        if ((((val >> 8) ^ hash) << 8) == 0) { // match\n            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "48": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\nint ix = (hash | mainHashMask._mainHashMask);\n        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\n        if ((((val >> 8) ^ hash) << 8) == 0) { // match\n            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "49": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\nint ix = (hash | mainHash._mainHashMask);\n        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\n        if ((((val >> 8) ^ hash) << 8) == 0) { // match\n            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "50": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\nint ix = (hash | collCount._mainHashMask);\n        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\n        if ((((val >> 8) ^ hash) << 8) == 0) { // match\n            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "51": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\nint ix = (hash | collEnd._mainHashMask);\n        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\n        if ((((val >> 8) ^ hash) << 8) == 0) { // match\n            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "52": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\nint ix = (hash | longestCollisionList._mainHashMask);\n        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\n        if ((((val >> 8) ^ hash) << 8) == 0) { // match\n            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "53": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\nint ix = (hash | _length._mainHashMask);\n        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\n        if ((((val >> 8) ^ hash) << 8) == 0) { // match\n            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "54": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\nint ix = (hash | size()._mainHashMask);\n        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\n        if ((((val >> 8) ^ hash) << 8) == 0) { // match\n            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "55": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\nint ix = (hash | bucketCount()._mainHashMask);\n        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\n        if ((((val >> 8) ^ hash) << 8) == 0) { // match\n            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "56": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\nint ix = (hash | hashSeed()._mainHashMask);\n        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\n        if ((((val >> 8) ^ hash) << 8) == 0) { // match\n            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "57": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\nint ix = (hash | collisionCount()._mainHashMask);\n        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\n        if ((((val >> 8) ^ hash) << 8) == 0) { // match\n            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "58": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\nint ix = (hash | maxCollisionLength()._mainHashMask);\n        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\n        if ((((val >> 8) ^ hash) << 8) == 0) { // match\n            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "59": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\nint ix = (hash | findBestBucket()._mainHashMask);\n        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\n        if ((((val >> 8) ^ hash) << 8) == 0) { // match\n            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "60": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\nint ix = (hash | length()._mainHashMask);\n        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\n        if ((((val >> 8) ^ hash) << 8) == 0) { // match\n            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "61": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\nint ix = (hash | _mainNames);\n        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\n        if ((((val >> 8) ^ hash) << 8) == 0) { // match\n            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "62": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\nint ix = (hash & _mainHashMask);\n        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\n        if ((((val >> 8) ^ hash) << 8) == 0) { // match\n            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "63": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\nint ix = (hash * _mainHashMask);\n        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\n        if ((((val >> 8) ^ hash) << 8) == 0) { // match\n            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "64": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\nint ix = (hash >>> _mainHashMask);\n        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\n        if ((((val >> 8) ^ hash) << 8) == 0) { // match\n            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "65": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\nint ix = (hash | _collList);\n        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\n        if ((((val >> 8) ^ hash) << 8) == 0) { // match\n            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "66": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\nfinal int ix = (hash | _mainHashMask);\n        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\n        if ((((val >> 8) ^ hash) << 8) == 0) { // match\n            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "67": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\nint ix = (hash | );\n        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\n        if ((((val >> 8) ^ hash) << 8) == 0) { // match\n            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "68": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\nrelease();\n        int ix = (hash | _mainHashMask);        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\n        if ((((val >> 8) ^ hash) << 8) == 0) { // match\n            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "69": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\nrehash();\n        int ix = (hash | _mainHashMask);        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\n        if ((((val >> 8) ^ hash) << 8) == 0) { // match\n            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "70": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\nnukeSymbols();\n        int ix = (hash | _mainHashMask);        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\n        if ((((val >> 8) ^ hash) << 8) == 0) { // match\n            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "71": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\nunshareMain();\n        int ix = (hash | _mainHashMask);        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\n        if ((((val >> 8) ^ hash) << 8) == 0) { // match\n            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "72": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\nunshareCollision();\n        int ix = (hash | _mainHashMask);        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\n        if ((((val >> 8) ^ hash) << 8) == 0) { // match\n            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "73": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\nunshareNames();\n        int ix = (hash | _mainHashMask);        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\n        if ((((val >> 8) ^ hash) << 8) == 0) { // match\n            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "74": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\nexpandCollision();\n        int ix = (hash | _mainHashMask);        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\n        if ((((val >> 8) ^ hash) << 8) == 0) { // match\n            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "75": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\nint ix = (hash - _mainHashMask);\n        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\n        if ((((val >> 8) ^ hash) << 8) == 0) { // match\n            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "76": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\nint ix = (hash << _mainHashMask);\n        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\n        if ((((val >> 8) ^ hash) << 8) == 0) { // match\n            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "77": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\nint ix = (secondQuad | _mainHashMask);\n        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\n        if ((((val >> 8) ^ hash) << 8) == 0) { // match\n            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "78": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\nint ix = _mainHashMask;\n        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\n        if ((((val >> 8) ^ hash) << 8) == 0) { // match\n            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "79": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\nint ix = (hash >> _mainHashMask);\n        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\n        if ((((val >> 8) ^ hash) << 8) == 0) { // match\n            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "80": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\nint ix = (hash < _mainHashMask);\n        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\n        if ((((val >> 8) ^ hash) << 8) == 0) { // match\n            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "81": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\nint ix = ((val >> 8) ^<> hash);\n        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\n        if ((((val >> 8) ^ hash) << 8) == 0) { // match\n            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "82": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\nlong ix = (hash | _mainHashMask);\n        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\n        if ((((val >> 8) ^ hash) << 8) == 0) { // match\n            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "83": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\nint ix = (((val >> 8) ^<> hash) << 8);\n        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\n        if ((((val >> 8) ^ hash) << 8) == 0) { // match\n            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "84": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\nint ix = (_mainHashMask * _mainHashMask);\n        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\n        if ((((val >> 8) ^ hash) << 8) == 0) { // match\n            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "85": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\nint ix = hash;\n        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\n        if ((((val >> 8) ^ hash) << 8) == 0) { // match\n            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "86": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\nint ix = (hash / _mainHashMask);\n        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\n        if ((((val >> 8) ^ hash) << 8) == 0) { // match\n            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "87": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\nint ix = (val >> 8);\n        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\n        if ((((val >> 8) ^ hash) << 8) == 0) { // match\n            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "88": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\nint ix = (firstQuad | _mainHashMask);\n        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\n        if ((((val >> 8) ^ hash) << 8) == 0) { // match\n            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "89": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\nint ix = (_mainHashMask * hash);\n        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\n        if ((((val >> 8) ^ hash) << 8) == 0) { // match\n            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "90": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\nint ix = (ix | _mainHashMask);\n        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\n        if ((((val >> 8) ^ hash) << 8) == 0) { // match\n            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "91": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\nint ix = (_mainHashMask | _mainHashMask);\n        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\n        if ((((val >> 8) ^ hash) << 8) == 0) { // match\n            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "92": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\nint ix = (hash <= _mainHashMask);\n        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\n        if ((((val >> 8) ^ hash) << 8) == 0) { // match\n            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "93": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\nint ix = (_mainHash | _mainHashMask);\n        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\n        if ((((val >> 8) ^ hash) << 8) == 0) { // match\n            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "94": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\nint ix = (_mainHashMask | hash);\n        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\n        if ((((val >> 8) ^ hash) << 8) == 0) { // match\n            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "95": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\nval &= 0xFF;\n        int ix = (hash | _mainHashMask);        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\n        if ((((val >> 8) ^ hash) << 8) == 0) { // match\n            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "96": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\nval -= 1;\n        int ix = (hash | _mainHashMask);        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\n        if ((((val >> 8) ^ hash) << 8) == 0) { // match\n            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "97": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\nif((hash == 0)){\nreturn null;}        int ix = (hash | _mainHashMask);        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\n        if ((((val >> 8) ^ hash) << 8) == 0) { // match\n            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "98": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\nint ix = reportTooManyCollisions(_mainHashMask);\n        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\n        if ((((val >> 8) ^ hash) << 8) == 0) { // match\n            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "99": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\nint ix = (hash | hash._mainHashMask);\n        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\n        if ((((val >> 8) ^ hash) << 8) == 0) { // match\n            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "100": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\nint ix = (hash | DEFAULT_TABLE_SIZE._mainHash);\n        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\n        if ((((val >> 8) ^ hash) << 8) == 0) { // match\n            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "101": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\nint ix = (hash | MAX_TABLE_SIZE._mainHash);\n        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\n        if ((((val >> 8) ^ hash) << 8) == 0) { // match\n            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "102": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\nint ix = (hash | MAX_ENTRIES_FOR_REUSE._mainHash);\n        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\n        if ((((val >> 8) ^ hash) << 8) == 0) { // match\n            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "103": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\nint ix = (hash | MAX_COLL_CHAIN_LENGTH._mainHash);\n        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\n        if ((((val >> 8) ^ hash) << 8) == 0) { // match\n            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "104": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\nint ix = (hash | MAX_COLL_CHAIN_FOR_REUSE._mainHash);\n        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\n        if ((((val >> 8) ^ hash) << 8) == 0) { // match\n            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "105": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\nint ix = (hash | MIN_HASH_SIZE._mainHash);\n        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\n        if ((((val >> 8) ^ hash) << 8) == 0) { // match\n            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "106": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\nint ix = (hash | INITIAL_COLLISION_LEN._mainHash);\n        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\n        if ((((val >> 8) ^ hash) << 8) == 0) { // match\n            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "107": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\nint ix = (hash | LAST_VALID_BUCKET._mainHash);\n        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\n        if ((((val >> 8) ^ hash) << 8) == 0) { // match\n            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "108": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\nint ix = (hash | _hashSeed._mainHash);\n        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\n        if ((((val >> 8) ^ hash) << 8) == 0) { // match\n            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "109": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\nint ix = (hash | _count._mainHash);\n        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\n        if ((((val >> 8) ^ hash) << 8) == 0) { // match\n            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "110": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\nint ix = (hash | _longestCollisionList._mainHash);\n        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\n        if ((((val >> 8) ^ hash) << 8) == 0) { // match\n            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "111": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\nint ix = (hash | _mainHashMask._mainHash);\n        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\n        if ((((val >> 8) ^ hash) << 8) == 0) { // match\n            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "112": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\nint ix = (hash | _mainHash._mainHash);\n        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\n        if ((((val >> 8) ^ hash) << 8) == 0) { // match\n            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "113": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\nint ix = (hash | _collCount._mainHash);\n        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\n        if ((((val >> 8) ^ hash) << 8) == 0) { // match\n            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "114": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\nint ix = (hash | _collEnd._mainHash);\n        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\n        if ((((val >> 8) ^ hash) << 8) == 0) { // match\n            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "115": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\nint ix = (hash | MULT._mainHash);\n        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\n        if ((((val >> 8) ^ hash) << 8) == 0) { // match\n            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "116": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\nint ix = (hash | MULT2._mainHash);\n        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\n        if ((((val >> 8) ^ hash) << 8) == 0) { // match\n            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "117": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\nint ix = (hash | MULT3._mainHash);\n        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\n        if ((((val >> 8) ^ hash) << 8) == 0) { // match\n            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "118": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\nint ix = (hash | count._mainHash);\n        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\n        if ((((val >> 8) ^ hash) << 8) == 0) { // match\n            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "119": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\nint ix = (hash | mainHashMask._mainHash);\n        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\n        if ((((val >> 8) ^ hash) << 8) == 0) { // match\n            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "120": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\nint ix = (hash | mainHash._mainHash);\n        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\n        if ((((val >> 8) ^ hash) << 8) == 0) { // match\n            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "121": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\nint ix = (hash | collCount._mainHash);\n        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\n        if ((((val >> 8) ^ hash) << 8) == 0) { // match\n            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "122": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\nint ix = (hash | collEnd._mainHash);\n        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\n        if ((((val >> 8) ^ hash) << 8) == 0) { // match\n            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "123": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\nint ix = (hash | longestCollisionList._mainHash);\n        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\n        if ((((val >> 8) ^ hash) << 8) == 0) { // match\n            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "124": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\nint ix = (hash | _length._mainHash);\n        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\n        if ((((val >> 8) ^ hash) << 8) == 0) { // match\n            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "125": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\nint ix = (hash | size()._mainHash);\n        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\n        if ((((val >> 8) ^ hash) << 8) == 0) { // match\n            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "126": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\nint ix = (hash | bucketCount()._mainHash);\n        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\n        if ((((val >> 8) ^ hash) << 8) == 0) { // match\n            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "127": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\nint ix = (hash | hashSeed()._mainHash);\n        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\n        if ((((val >> 8) ^ hash) << 8) == 0) { // match\n            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "128": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\nint ix = (hash | collisionCount()._mainHash);\n        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\n        if ((((val >> 8) ^ hash) << 8) == 0) { // match\n            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "129": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\nint ix = (hash | maxCollisionLength()._mainHash);\n        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\n        if ((((val >> 8) ^ hash) << 8) == 0) { // match\n            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "130": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\nint ix = (hash | findBestBucket()._mainHash);\n        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\n        if ((((val >> 8) ^ hash) << 8) == 0) { // match\n            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "131": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\nint ix = (hash | length()._mainHash);\n        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\n        if ((((val >> 8) ^ hash) << 8) == 0) { // match\n            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "132": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\nint ix = 1;\n        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\n        if ((((val >> 8) ^ hash) << 8) == 0) { // match\n            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "133": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\nint ix = (hash | firstQuad._mainHashMask);\n        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\n        if ((((val >> 8) ^ hash) << 8) == 0) { // match\n            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "134": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\nint ix = reportTooManyCollisions(hash);\n        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\n        if ((((val >> 8) ^ hash) << 8) == 0) { // match\n            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "135": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\nint ix = ;\n        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\n        if ((((val >> 8) ^ hash) << 8) == 0) { // match\n            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "136": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\nint ix = ((hash | _mainHashMask) * hash);\n        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\n        if ((((val >> 8) ^ hash) << 8) == 0) { // match\n            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "137": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\nreturn null;        int ix = (hash | _mainHashMask);        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\n        if ((((val >> 8) ^ hash) << 8) == 0) { // match\n            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "138": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\nint ix = ( | _mainHashMask);\n        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\n        if ((((val >> 8) ^ hash) << 8) == 0) { // match\n            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "139": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\nint ix = calcHash(firstQuad);\n        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\n        if ((((val >> 8) ^ hash) << 8) == 0) { // match\n            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "140": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\nint ix = _mainHash;\n        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\n        if ((((val >> 8) ^ hash) << 8) == 0) { // match\n            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "141": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\nif(maybeDirty()){\nreturn null;}        int ix = (hash | _mainHashMask);        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\n        if ((((val >> 8) ^ hash) << 8) == 0) { // match\n            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "142": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\nint ix = (hash * hash);\n        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\n        if ((((val >> 8) ^ hash) << 8) == 0) { // match\n            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "143": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\nint ix = calcHash(firstQuad, secondQuad);\n        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\n        if ((((val >> 8) ^ hash) << 8) == 0) { // match\n            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "144": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\nint ix = (_mainHashMask * firstQuad);\n        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\n        if ((((val >> 8) ^ hash) << 8) == 0) { // match\n            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "145": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\nint ix = (_mainNames | _mainHashMask);\n        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\n        if ((((val >> 8) ^ hash) << 8) == 0) { // match\n            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "146": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\nif((secondQuad == 0)){\n        int ix = (hash | _mainHashMask);        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\n        if ((((val >> 8) ^ hash) << 8) == 0) { // match\n            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n}\n    }",
          "147": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\nint ix = (_mainHashMask * secondQuad);\n        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\n        if ((((val >> 8) ^ hash) << 8) == 0) { // match\n            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "148": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\nif((hash != 0)){\n        int ix = (hash | _mainHashMask);        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\n        if ((((val >> 8) ^ hash) << 8) == 0) { // match\n            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n}\n    }",
          "149": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\nint ix = ((hash | _mainHashMask) | hash);\n        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\n        if ((((val >> 8) ^ hash) << 8) == 0) { // match\n            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "150": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\nint ix = (_mainHash * _mainHashMask);\n        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\n        if ((((val >> 8) ^ hash) << 8) == 0) { // match\n            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "151": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\nif((((val >> 8) ^<> hash) << 8)){\n        int ix = (hash | _mainHashMask);        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\n        if ((((val >> 8) ^ hash) << 8) == 0) { // match\n            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n}\n    }",
          "152": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\nint ix = (hash * 1);\n        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\n        if ((((val >> 8) ^ hash) << 8) == 0) { // match\n            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "153": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\nint ix = (_mainHashMask / hash);\n        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\n        if ((((val >> 8) ^ hash) << 8) == 0) { // match\n            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "154": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\nint ix = ((hash | _mainHashMask) * _mainHashMask);\n        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\n        if ((((val >> 8) ^ hash) << 8) == 0) { // match\n            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "155": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\nint ix = (_mainHashMask & hash);\n        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\n        if ((((val >> 8) ^ hash) << 8) == 0) { // match\n            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "156": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\nint ix = (_mainHashMask * 1);\n        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\n        if ((((val >> 8) ^ hash) << 8) == 0) { // match\n            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "157": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\nint ix = ((hash | _mainHashMask) * secondQuad);\n        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\n        if ((((val >> 8) ^ hash) << 8) == 0) { // match\n            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "158": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\nif((val >> 8)){\n        int ix = (hash | _mainHashMask);        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\n        if ((((val >> 8) ^ hash) << 8) == 0) { // match\n            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n}\n    }",
          "159": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\nif(((val >> 8) ^<> hash)){\n        int ix = (hash | _mainHashMask);        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\n        if ((((val >> 8) ^ hash) << 8) == 0) { // match\n            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n}\n    }",
          "160": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\nhash++;\n        int ix = (hash | _mainHashMask);        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\n        if ((((val >> 8) ^ hash) << 8) == 0) { // match\n            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "161": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\nreturn name;        int ix = (hash | _mainHashMask);        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\n        if ((((val >> 8) ^ hash) << 8) == 0) { // match\n            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "162": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\nint ix = (_collList | _mainHashMask);\n        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\n        if ((((val >> 8) ^ hash) << 8) == 0) { // match\n            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "163": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\nreturn;\n        int ix = (hash | _mainHashMask);        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\n        if ((((val >> 8) ^ hash) << 8) == 0) { // match\n            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "164": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\nName name = _mainNames[ix];\n        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\n        if ((((val >> 8) ^ hash) << 8) == 0) { // match\n            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }",
          "165": "    public Name findName(int firstQuad, int secondQuad)\n    {\n        int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad);\nint ix = (this._mainHashMask * _mainHashMask);\n        int val = _mainHash[ix];\n        \n        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n         * are bucket index)... match?\n         */\n        if ((((val >> 8) ^ hash) << 8) == 0) { // match\n            // Ok, but do we have an actual match?\n            Name name = _mainNames[ix];\n            if (name == null) { // main slot empty; can't find\n                return null;\n            }\n            if (name.equals(firstQuad, secondQuad)) {\n                return name;\n            }\n        } else if (val == 0) { // empty slot? no match\n            return null;\n        }\n        // Maybe a spill-over?\n        val &= 0xFF;\n        if (val > 0) { // 0 means 'empty'\n            val -= 1; // to convert from 1-based to 0...\n            Bucket bucket = _collList[val];\n            if (bucket != null) {\n                return bucket.find(hash, firstQuad, secondQuad);\n            }\n        }\n        // Nope, no match whatsoever\n        return null;\n    }"
}