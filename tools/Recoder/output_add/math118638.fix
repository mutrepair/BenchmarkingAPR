{
          "0": "    public static float nextAfter(final float f, final double direction) {\n\n        // handling of some important special cases\n        if (Double.isNaN(f) || Double.isNaN(direction)) {\n            return Float.NaN;\n        } else if (f == direction) {\n            return (float) direction;\n        } else if (Float.isInfinite(f)) {\n            return (f < 0f) ? -Float.MAX_VALUE : Float.MAX_VALUE;\n        } else if (f == 0f) {\n            return (direction < 0) ? -Float.MIN_VALUE : Float.MIN_VALUE;\n        }\n        // special cases MAX_VALUE to infinity and  MIN_VALUE to 0\n        // are handled just as normal numbers\n\n        final int bits = Float.floatToIntBits(f);\n        final int sign = bits & 0x80000000;\n        if ((direction < f) ^ (sign == 0)) {\n            return Float.intBitsToFloat(sign | ((bits & 0x7fffffff) + 1));\n        } else {\nreturn Float.intBitsToFloat((sign || ((bits & 2147483647) - 1)));        }\n\n    }",
          "1": "    public static float nextAfter(final float f, final double direction) {\n\n        // handling of some important special cases\n        if (Double.isNaN(f) || Double.isNaN(direction)) {\n            return Float.NaN;\n        } else if (f == direction) {\n            return (float) direction;\n        } else if (Float.isInfinite(f)) {\n            return (f < 0f) ? -Float.MAX_VALUE : Float.MAX_VALUE;\n        } else if (f == 0f) {\n            return (direction < 0) ? -Float.MIN_VALUE : Float.MIN_VALUE;\n        }\n        // special cases MAX_VALUE to infinity and  MIN_VALUE to 0\n        // are handled just as normal numbers\n\n        final int bits = Float.floatToIntBits(f);\n        final int sign = bits & 0x80000000;\n        if ((direction < f) ^ (sign == 0)) {\n            return Float.intBitsToFloat(sign | ((bits & 0x7fffffff) + 1));\n        } else {\nreturn Float.intBitsToFloat((sign && ((bits & 2147483647) - 1)));        }\n\n    }",
          "2": "    public static float nextAfter(final float f, final double direction) {\n\n        // handling of some important special cases\n        if (Double.isNaN(f) || Double.isNaN(direction)) {\n            return Float.NaN;\n        } else if (f == direction) {\n            return (float) direction;\n        } else if (Float.isInfinite(f)) {\n            return (f < 0f) ? -Float.MAX_VALUE : Float.MAX_VALUE;\n        } else if (f == 0f) {\n            return (direction < 0) ? -Float.MIN_VALUE : Float.MIN_VALUE;\n        }\n        // special cases MAX_VALUE to infinity and  MIN_VALUE to 0\n        // are handled just as normal numbers\n\n        final int bits = Float.floatToIntBits(f);\n        final int sign = bits & 0x80000000;\n        if ((direction < f) ^ (sign == 0)) {\n            return Float.intBitsToFloat(sign | ((bits & 0x7fffffff) + 1));\n        } else {\nreturn Float.intBitsToFloat((sign & ((bits & 2) - 1)));        }\n\n    }",
          "3": "    public static float nextAfter(final float f, final double direction) {\n\n        // handling of some important special cases\n        if (Double.isNaN(f) || Double.isNaN(direction)) {\n            return Float.NaN;\n        } else if (f == direction) {\n            return (float) direction;\n        } else if (Float.isInfinite(f)) {\n            return (f < 0f) ? -Float.MAX_VALUE : Float.MAX_VALUE;\n        } else if (f == 0f) {\n            return (direction < 0) ? -Float.MIN_VALUE : Float.MIN_VALUE;\n        }\n        // special cases MAX_VALUE to infinity and  MIN_VALUE to 0\n        // are handled just as normal numbers\n\n        final int bits = Float.floatToIntBits(f);\n        final int sign = bits & 0x80000000;\n        if ((direction < f) ^ (sign == 0)) {\n            return Float.intBitsToFloat(sign | ((bits & 0x7fffffff) + 1));\n        } else {\nreturn Float.intBitsToFloat((sign & ((bits & 2147483647) - 2)));        }\n\n    }",
          "4": "    public static float nextAfter(final float f, final double direction) {\n\n        // handling of some important special cases\n        if (Double.isNaN(f) || Double.isNaN(direction)) {\n            return Float.NaN;\n        } else if (f == direction) {\n            return (float) direction;\n        } else if (Float.isInfinite(f)) {\n            return (f < 0f) ? -Float.MAX_VALUE : Float.MAX_VALUE;\n        } else if (f == 0f) {\n            return (direction < 0) ? -Float.MIN_VALUE : Float.MIN_VALUE;\n        }\n        // special cases MAX_VALUE to infinity and  MIN_VALUE to 0\n        // are handled just as normal numbers\n\n        final int bits = Float.floatToIntBits(f);\n        final int sign = bits & 0x80000000;\n        if ((direction < f) ^ (sign == 0)) {\n            return Float.intBitsToFloat(sign | ((bits & 0x7fffffff) + 1));\n        } else {\nreturn Float.intBitsToFloat((sign & ((bits & 0x7fffffff) - 1)));        }\n\n    }",
          "5": "    public static float nextAfter(final float f, final double direction) {\n\n        // handling of some important special cases\n        if (Double.isNaN(f) || Double.isNaN(direction)) {\n            return Float.NaN;\n        } else if (f == direction) {\n            return (float) direction;\n        } else if (Float.isInfinite(f)) {\n            return (f < 0f) ? -Float.MAX_VALUE : Float.MAX_VALUE;\n        } else if (f == 0f) {\n            return (direction < 0) ? -Float.MIN_VALUE : Float.MIN_VALUE;\n        }\n        // special cases MAX_VALUE to infinity and  MIN_VALUE to 0\n        // are handled just as normal numbers\n\n        final int bits = Float.floatToIntBits(f);\n        final int sign = bits & 0x80000000;\n        if ((direction < f) ^ (sign == 0)) {\n            return Float.intBitsToFloat(sign | ((bits & 0x7fffffff) + 1));\n        } else {\nreturn Float.intBitsToFloat((sign | ((bits & 2147483647) - 1)));        }\n\n    }",
          "6": "    public static float nextAfter(final float f, final double direction) {\n\n        // handling of some important special cases\n        if (Double.isNaN(f) || Double.isNaN(direction)) {\n            return Float.NaN;\n        } else if (f == direction) {\n            return (float) direction;\n        } else if (Float.isInfinite(f)) {\n            return (f < 0f) ? -Float.MAX_VALUE : Float.MAX_VALUE;\n        } else if (f == 0f) {\n            return (direction < 0) ? -Float.MIN_VALUE : Float.MIN_VALUE;\n        }\n        // special cases MAX_VALUE to infinity and  MIN_VALUE to 0\n        // are handled just as normal numbers\n\n        final int bits = Float.floatToIntBits(f);\n        final int sign = bits & 0x80000000;\n        if ((direction < f) ^ (sign == 0)) {\n            return Float.intBitsToFloat(sign | ((bits & 0x7fffffff) + 1));\n        } else {\nreturn Float.intBitsToFloat((sign & ((bits & 2147483647) - 1)));        }\n\n    }",
          "7": "    public static float nextAfter(final float f, final double direction) {\n\n        // handling of some important special cases\n        if (Double.isNaN(f) || Double.isNaN(direction)) {\n            return Float.NaN;\n        } else if (f == direction) {\n            return (float) direction;\n        } else if (Float.isInfinite(f)) {\n            return (f < 0f) ? -Float.MAX_VALUE : Float.MAX_VALUE;\n        } else if (f == 0f) {\n            return (direction < 0) ? -Float.MIN_VALUE : Float.MIN_VALUE;\n        }\n        // special cases MAX_VALUE to infinity and  MIN_VALUE to 0\n        // are handled just as normal numbers\n\n        final int bits = Float.floatToIntBits(f);\n        final int sign = bits & 0x80000000;\n        if ((direction < f) ^ (sign == 0)) {\n            return Float.intBitsToFloat(sign | ((bits & 0x7fffffff) + 1));\n        } else {\nreturn Float.intBitsToFloat((sign & ((bits & 2147483647) - 0)));        }\n\n    }",
          "8": "    public static float nextAfter(final float f, final double direction) {\n\n        // handling of some important special cases\n        if (Double.isNaN(f) || Double.isNaN(direction)) {\n            return Float.NaN;\n        } else if (f == direction) {\n            return (float) direction;\n        } else if (Float.isInfinite(f)) {\n            return (f < 0f) ? -Float.MAX_VALUE : Float.MAX_VALUE;\n        } else if (f == 0f) {\n            return (direction < 0) ? -Float.MIN_VALUE : Float.MIN_VALUE;\n        }\n        // special cases MAX_VALUE to infinity and  MIN_VALUE to 0\n        // are handled just as normal numbers\n\n        final int bits = Float.floatToIntBits(f);\n        final int sign = bits & 0x80000000;\n        if ((direction < f) ^ (sign == 0)) {\n            return Float.intBitsToFloat(sign | ((bits & 0x7fffffff) + 1));\n        } else {\nreturn Float.intBitsToFloat((sign | ((bits & 0x7fffffff) + 1)));            return Float.intBitsToFloat(sign & ((bits & 2147483647) - 1));        }\n\n    }",
          "9": "    public static float nextAfter(final float f, final double direction) {\n\n        // handling of some important special cases\n        if (Double.isNaN(f) || Double.isNaN(direction)) {\n            return Float.NaN;\n        } else if (f == direction) {\n            return (float) direction;\n        } else if (Float.isInfinite(f)) {\n            return (f < 0f) ? -Float.MAX_VALUE : Float.MAX_VALUE;\n        } else if (f == 0f) {\n            return (direction < 0) ? -Float.MIN_VALUE : Float.MIN_VALUE;\n        }\n        // special cases MAX_VALUE to infinity and  MIN_VALUE to 0\n        // are handled just as normal numbers\n\n        final int bits = Float.floatToIntBits(f);\n        final int sign = bits & 0x80000000;\n        if ((direction < f) ^ (sign == 0)) {\n            return Float.intBitsToFloat(sign | ((bits & 0x7fffffff) + 1));\n        } else {\nreturn Float.intBitsToFloat((sign & ((bits > 2147483647) - 1)));        }\n\n    }",
          "10": "    public static float nextAfter(final float f, final double direction) {\n\n        // handling of some important special cases\n        if (Double.isNaN(f) || Double.isNaN(direction)) {\n            return Float.NaN;\n        } else if (f == direction) {\n            return (float) direction;\n        } else if (Float.isInfinite(f)) {\n            return (f < 0f) ? -Float.MAX_VALUE : Float.MAX_VALUE;\n        } else if (f == 0f) {\n            return (direction < 0) ? -Float.MIN_VALUE : Float.MIN_VALUE;\n        }\n        // special cases MAX_VALUE to infinity and  MIN_VALUE to 0\n        // are handled just as normal numbers\n\n        final int bits = Float.floatToIntBits(f);\n        final int sign = bits & 0x80000000;\n        if ((direction < f) ^ (sign == 0)) {\n            return Float.intBitsToFloat(sign | ((bits & 0x7fffffff) + 1));\n        } else {\nreturn Float.intBitsToFloat((sign & ((bits & 0x80000000) - 1)));        }\n\n    }",
          "11": "    public static float nextAfter(final float f, final double direction) {\n\n        // handling of some important special cases\n        if (Double.isNaN(f) || Double.isNaN(direction)) {\n            return Float.NaN;\n        } else if (f == direction) {\n            return (float) direction;\n        } else if (Float.isInfinite(f)) {\n            return (f < 0f) ? -Float.MAX_VALUE : Float.MAX_VALUE;\n        } else if (f == 0f) {\n            return (direction < 0) ? -Float.MIN_VALUE : Float.MIN_VALUE;\n        }\n        // special cases MAX_VALUE to infinity and  MIN_VALUE to 0\n        // are handled just as normal numbers\n\n        final int bits = Float.floatToIntBits(f);\n        final int sign = bits & 0x80000000;\n        if ((direction < f) ^ (sign == 0)) {\n            return Float.intBitsToFloat(sign | ((bits & 0x7fffffff) + 1));\n        } else {\nreturn Float.intBitsToFloat((sign < ((bits & 2147483647) - 1)));        }\n\n    }",
          "12": "    public static float nextAfter(final float f, final double direction) {\n\n        // handling of some important special cases\n        if (Double.isNaN(f) || Double.isNaN(direction)) {\n            return Float.NaN;\n        } else if (f == direction) {\n            return (float) direction;\n        } else if (Float.isInfinite(f)) {\n            return (f < 0f) ? -Float.MAX_VALUE : Float.MAX_VALUE;\n        } else if (f == 0f) {\n            return (direction < 0) ? -Float.MIN_VALUE : Float.MIN_VALUE;\n        }\n        // special cases MAX_VALUE to infinity and  MIN_VALUE to 0\n        // are handled just as normal numbers\n\n        final int bits = Float.floatToIntBits(f);\n        final int sign = bits & 0x80000000;\n        if ((direction < f) ^ (sign == 0)) {\n            return Float.intBitsToFloat(sign | ((bits & 0x7fffffff) + 1));\n        } else {\nreturn Float.intBitsToFloat((sign & ((bits & 2147483647) - 0x7fffffff)));        }\n\n    }",
          "13": "    public static float nextAfter(final float f, final double direction) {\n\n        // handling of some important special cases\n        if (Double.isNaN(f) || Double.isNaN(direction)) {\n            return Float.NaN;\n        } else if (f == direction) {\n            return (float) direction;\n        } else if (Float.isInfinite(f)) {\n            return (f < 0f) ? -Float.MAX_VALUE : Float.MAX_VALUE;\n        } else if (f == 0f) {\n            return (direction < 0) ? -Float.MIN_VALUE : Float.MIN_VALUE;\n        }\n        // special cases MAX_VALUE to infinity and  MIN_VALUE to 0\n        // are handled just as normal numbers\n\n        final int bits = Float.floatToIntBits(f);\n        final int sign = bits & 0x80000000;\n        if ((direction < f) ^ (sign == 0)) {\n            return Float.intBitsToFloat(sign | ((bits & 0x7fffffff) + 1));\n        } else {\nreturn Float.intBitsToFloat((sign & ((bits >= 2147483647) - 1)));        }\n\n    }",
          "14": "    public static float nextAfter(final float f, final double direction) {\n\n        // handling of some important special cases\n        if (Double.isNaN(f) || Double.isNaN(direction)) {\n            return Float.NaN;\n        } else if (f == direction) {\n            return (float) direction;\n        } else if (Float.isInfinite(f)) {\n            return (f < 0f) ? -Float.MAX_VALUE : Float.MAX_VALUE;\n        } else if (f == 0f) {\n            return (direction < 0) ? -Float.MIN_VALUE : Float.MIN_VALUE;\n        }\n        // special cases MAX_VALUE to infinity and  MIN_VALUE to 0\n        // are handled just as normal numbers\n\n        final int bits = Float.floatToIntBits(f);\n        final int sign = bits & 0x80000000;\n        if ((direction < f) ^ (sign == 0)) {\n            return Float.intBitsToFloat(sign | ((bits & 0x7fffffff) + 1));\n        } else {\nreturn Float.intBitsToFloat((sign & ((bits <= 2147483647) - 1)));        }\n\n    }",
          "15": "    public static float nextAfter(final float f, final double direction) {\n\n        // handling of some important special cases\n        if (Double.isNaN(f) || Double.isNaN(direction)) {\n            return Float.NaN;\n        } else if (f == direction) {\n            return (float) direction;\n        } else if (Float.isInfinite(f)) {\n            return (f < 0f) ? -Float.MAX_VALUE : Float.MAX_VALUE;\n        } else if (f == 0f) {\n            return (direction < 0) ? -Float.MIN_VALUE : Float.MIN_VALUE;\n        }\n        // special cases MAX_VALUE to infinity and  MIN_VALUE to 0\n        // are handled just as normal numbers\n\n        final int bits = Float.floatToIntBits(f);\n        final int sign = bits & 0x80000000;\n        if ((direction < f) ^ (sign == 0)) {\n            return Float.intBitsToFloat(sign | ((bits & 0x7fffffff) + 1));\n        } else {\nreturn Float.intBitsToFloat((sign & ((sign & 2147483647) - 1)));        }\n\n    }",
          "16": "    public static float nextAfter(final float f, final double direction) {\n\n        // handling of some important special cases\n        if (Double.isNaN(f) || Double.isNaN(direction)) {\n            return Float.NaN;\n        } else if (f == direction) {\n            return (float) direction;\n        } else if (Float.isInfinite(f)) {\n            return (f < 0f) ? -Float.MAX_VALUE : Float.MAX_VALUE;\n        } else if (f == 0f) {\n            return (direction < 0) ? -Float.MIN_VALUE : Float.MIN_VALUE;\n        }\n        // special cases MAX_VALUE to infinity and  MIN_VALUE to 0\n        // are handled just as normal numbers\n\n        final int bits = Float.floatToIntBits(f);\n        final int sign = bits & 0x80000000;\n        if ((direction < f) ^ (sign == 0)) {\n            return Float.intBitsToFloat(sign | ((bits & 0x7fffffff) + 1));\n        } else {\nreturn Float.intBitsToFloat((sign & ((bits & 1) - 1)));        }\n\n    }",
          "17": "    public static float nextAfter(final float f, final double direction) {\n\n        // handling of some important special cases\n        if (Double.isNaN(f) || Double.isNaN(direction)) {\n            return Float.NaN;\n        } else if (f == direction) {\n            return (float) direction;\n        } else if (Float.isInfinite(f)) {\n            return (f < 0f) ? -Float.MAX_VALUE : Float.MAX_VALUE;\n        } else if (f == 0f) {\n            return (direction < 0) ? -Float.MIN_VALUE : Float.MIN_VALUE;\n        }\n        // special cases MAX_VALUE to infinity and  MIN_VALUE to 0\n        // are handled just as normal numbers\n\n        final int bits = Float.floatToIntBits(f);\n        final int sign = bits & 0x80000000;\n        if ((direction < f) ^ (sign == 0)) {\n            return Float.intBitsToFloat(sign | ((bits & 0x7fffffff) + 1));\n        } else {\nreturn Float.intBitsToFloat(f);        }\n\n    }",
          "18": "    public static float nextAfter(final float f, final double direction) {\n\n        // handling of some important special cases\n        if (Double.isNaN(f) || Double.isNaN(direction)) {\n            return Float.NaN;\n        } else if (f == direction) {\n            return (float) direction;\n        } else if (Float.isInfinite(f)) {\n            return (f < 0f) ? -Float.MAX_VALUE : Float.MAX_VALUE;\n        } else if (f == 0f) {\n            return (direction < 0) ? -Float.MIN_VALUE : Float.MIN_VALUE;\n        }\n        // special cases MAX_VALUE to infinity and  MIN_VALUE to 0\n        // are handled just as normal numbers\n\n        final int bits = Float.floatToIntBits(f);\n        final int sign = bits & 0x80000000;\n        if ((direction < f) ^ (sign == 0)) {\n            return Float.intBitsToFloat(sign | ((bits & 0x7fffffff) + 1));\n        } else {\nreturn Float.intBitsToFloat((bits & ((bits & 2147483647) - 1)));        }\n\n    }",
          "19": "    public static float nextAfter(final float f, final double direction) {\n\n        // handling of some important special cases\n        if (Double.isNaN(f) || Double.isNaN(direction)) {\n            return Float.NaN;\n        } else if (f == direction) {\n            return (float) direction;\n        } else if (Float.isInfinite(f)) {\n            return (f < 0f) ? -Float.MAX_VALUE : Float.MAX_VALUE;\n        } else if (f == 0f) {\n            return (direction < 0) ? -Float.MIN_VALUE : Float.MIN_VALUE;\n        }\n        // special cases MAX_VALUE to infinity and  MIN_VALUE to 0\n        // are handled just as normal numbers\n\n        final int bits = Float.floatToIntBits(f);\n        final int sign = bits & 0x80000000;\n        if ((direction < f) ^ (sign == 0)) {\n            return Float.intBitsToFloat(sign | ((bits & 0x7fffffff) + 1));\n        } else {\nreturn Float.intBitsToFloat((sign & ((bits & -1) - 1)));        }\n\n    }",
          "20": "    public static float nextAfter(final float f, final double direction) {\n\n        // handling of some important special cases\n        if (Double.isNaN(f) || Double.isNaN(direction)) {\n            return Float.NaN;\n        } else if (f == direction) {\n            return (float) direction;\n        } else if (Float.isInfinite(f)) {\n            return (f < 0f) ? -Float.MAX_VALUE : Float.MAX_VALUE;\n        } else if (f == 0f) {\n            return (direction < 0) ? -Float.MIN_VALUE : Float.MIN_VALUE;\n        }\n        // special cases MAX_VALUE to infinity and  MIN_VALUE to 0\n        // are handled just as normal numbers\n\n        final int bits = Float.floatToIntBits(f);\n        final int sign = bits & 0x80000000;\n        if ((direction < f) ^ (sign == 0)) {\n            return Float.intBitsToFloat(sign | ((bits & 0x7fffffff) + 1));\n        } else {\nreturn Float.intBitsToFloat((sign == ((bits & 2147483647) - 1)));        }\n\n    }",
          "21": "    public static float nextAfter(final float f, final double direction) {\n\n        // handling of some important special cases\n        if (Double.isNaN(f) || Double.isNaN(direction)) {\n            return Float.NaN;\n        } else if (f == direction) {\n            return (float) direction;\n        } else if (Float.isInfinite(f)) {\n            return (f < 0f) ? -Float.MAX_VALUE : Float.MAX_VALUE;\n        } else if (f == 0f) {\n            return (direction < 0) ? -Float.MIN_VALUE : Float.MIN_VALUE;\n        }\n        // special cases MAX_VALUE to infinity and  MIN_VALUE to 0\n        // are handled just as normal numbers\n\n        final int bits = Float.floatToIntBits(f);\n        final int sign = bits & 0x80000000;\n        if ((direction < f) ^ (sign == 0)) {\n            return Float.intBitsToFloat(sign | ((bits & 0x7fffffff) + 1));\n        } else {\nreturn Float.intBitsToFloat((sign & ((bits & 2147483647) - 1)), sign);        }\n\n    }",
          "22": "    public static float nextAfter(final float f, final double direction) {\n\n        // handling of some important special cases\n        if (Double.isNaN(f) || Double.isNaN(direction)) {\n            return Float.NaN;\n        } else if (f == direction) {\n            return (float) direction;\n        } else if (Float.isInfinite(f)) {\n            return (f < 0f) ? -Float.MAX_VALUE : Float.MAX_VALUE;\n        } else if (f == 0f) {\n            return (direction < 0) ? -Float.MIN_VALUE : Float.MIN_VALUE;\n        }\n        // special cases MAX_VALUE to infinity and  MIN_VALUE to 0\n        // are handled just as normal numbers\n\n        final int bits = Float.floatToIntBits(f);\n        final int sign = bits & 0x80000000;\n        if ((direction < f) ^ (sign == 0)) {\n            return Float.intBitsToFloat(sign | ((bits & 0x7fffffff) + 1));\n        } else {\nreturn Float.intBitsToFloat((sign + ((bits & 2147483647) - 1)));        }\n\n    }",
          "23": "    public static float nextAfter(final float f, final double direction) {\n\n        // handling of some important special cases\n        if (Double.isNaN(f) || Double.isNaN(direction)) {\n            return Float.NaN;\n        } else if (f == direction) {\n            return (float) direction;\n        } else if (Float.isInfinite(f)) {\n            return (f < 0f) ? -Float.MAX_VALUE : Float.MAX_VALUE;\n        } else if (f == 0f) {\n            return (direction < 0) ? -Float.MIN_VALUE : Float.MIN_VALUE;\n        }\n        // special cases MAX_VALUE to infinity and  MIN_VALUE to 0\n        // are handled just as normal numbers\n\n        final int bits = Float.floatToIntBits(f);\n        final int sign = bits & 0x80000000;\n        if ((direction < f) ^ (sign == 0)) {\n            return Float.intBitsToFloat(sign | ((bits & 0x7fffffff) + 1));\n        } else {\nreturn Float.intBitsToFloat((sign & ((bits & 2147483647) - 1)), 0);        }\n\n    }",
          "24": "    public static float nextAfter(final float f, final double direction) {\n\n        // handling of some important special cases\n        if (Double.isNaN(f) || Double.isNaN(direction)) {\n            return Float.NaN;\n        } else if (f == direction) {\n            return (float) direction;\n        } else if (Float.isInfinite(f)) {\n            return (f < 0f) ? -Float.MAX_VALUE : Float.MAX_VALUE;\n        } else if (f == 0f) {\n            return (direction < 0) ? -Float.MIN_VALUE : Float.MIN_VALUE;\n        }\n        // special cases MAX_VALUE to infinity and  MIN_VALUE to 0\n        // are handled just as normal numbers\n\n        final int bits = Float.floatToIntBits(f);\n        final int sign = bits & 0x80000000;\n        if ((direction < f) ^ (sign == 0)) {\n            return Float.intBitsToFloat(sign | ((bits & 0x7fffffff) + 1));\n        } else {\nreturn Float.intBitsToFloat(sign);        }\n\n    }",
          "25": "    public static float nextAfter(final float f, final double direction) {\n\n        // handling of some important special cases\n        if (Double.isNaN(f) || Double.isNaN(direction)) {\n            return Float.NaN;\n        } else if (f == direction) {\n            return (float) direction;\n        } else if (Float.isInfinite(f)) {\n            return (f < 0f) ? -Float.MAX_VALUE : Float.MAX_VALUE;\n        } else if (f == 0f) {\n            return (direction < 0) ? -Float.MIN_VALUE : Float.MIN_VALUE;\n        }\n        // special cases MAX_VALUE to infinity and  MIN_VALUE to 0\n        // are handled just as normal numbers\n\n        final int bits = Float.floatToIntBits(f);\n        final int sign = bits & 0x80000000;\n        if ((direction < f) ^ (sign == 0)) {\n            return Float.intBitsToFloat(sign | ((bits & 0x7fffffff) + 1));\n        } else {\nreturn Float.intBitsToFloat(direction);        }\n\n    }",
          "26": "    public static float nextAfter(final float f, final double direction) {\n\n        // handling of some important special cases\n        if (Double.isNaN(f) || Double.isNaN(direction)) {\n            return Float.NaN;\n        } else if (f == direction) {\n            return (float) direction;\n        } else if (Float.isInfinite(f)) {\n            return (f < 0f) ? -Float.MAX_VALUE : Float.MAX_VALUE;\n        } else if (f == 0f) {\n            return (direction < 0) ? -Float.MIN_VALUE : Float.MIN_VALUE;\n        }\n        // special cases MAX_VALUE to infinity and  MIN_VALUE to 0\n        // are handled just as normal numbers\n\n        final int bits = Float.floatToIntBits(f);\n        final int sign = bits & 0x80000000;\n        if ((direction < f) ^ (sign == 0)) {\n            return Float.intBitsToFloat(sign | ((bits & 0x7fffffff) + 1));\n        } else {\nreturn Float.NaN;        }\n\n    }",
          "27": "    public static float nextAfter(final float f, final double direction) {\n\n        // handling of some important special cases\n        if (Double.isNaN(f) || Double.isNaN(direction)) {\n            return Float.NaN;\n        } else if (f == direction) {\n            return (float) direction;\n        } else if (Float.isInfinite(f)) {\n            return (f < 0f) ? -Float.MAX_VALUE : Float.MAX_VALUE;\n        } else if (f == 0f) {\n            return (direction < 0) ? -Float.MIN_VALUE : Float.MIN_VALUE;\n        }\n        // special cases MAX_VALUE to infinity and  MIN_VALUE to 0\n        // are handled just as normal numbers\n\n        final int bits = Float.floatToIntBits(f);\n        final int sign = bits & 0x80000000;\n        if ((direction < f) ^ (sign == 0)) {\n            return Float.intBitsToFloat(sign | ((bits & 0x7fffffff) + 1));\n        } else {\nreturn Float.NaN;            return Float.intBitsToFloat(sign & ((bits & 2147483647) - 1));        }\n\n    }",
          "28": "    public static float nextAfter(final float f, final double direction) {\n\n        // handling of some important special cases\n        if (Double.isNaN(f) || Double.isNaN(direction)) {\n            return Float.NaN;\n        } else if (f == direction) {\n            return (float) direction;\n        } else if (Float.isInfinite(f)) {\n            return (f < 0f) ? -Float.MAX_VALUE : Float.MAX_VALUE;\n        } else if (f == 0f) {\n            return (direction < 0) ? -Float.MIN_VALUE : Float.MIN_VALUE;\n        }\n        // special cases MAX_VALUE to infinity and  MIN_VALUE to 0\n        // are handled just as normal numbers\n\n        final int bits = Float.floatToIntBits(f);\n        final int sign = bits & 0x80000000;\n        if ((direction < f) ^ (sign == 0)) {\n            return Float.intBitsToFloat(sign | ((bits & 0x7fffffff) + 1));\n        } else {\nreturn Float.intBitsToFloat((sign != ((bits & 2147483647) - 1)));        }\n\n    }",
          "29": "    public static float nextAfter(final float f, final double direction) {\n\n        // handling of some important special cases\n        if (Double.isNaN(f) || Double.isNaN(direction)) {\n            return Float.NaN;\n        } else if (f == direction) {\n            return (float) direction;\n        } else if (Float.isInfinite(f)) {\n            return (f < 0f) ? -Float.MAX_VALUE : Float.MAX_VALUE;\n        } else if (f == 0f) {\n            return (direction < 0) ? -Float.MIN_VALUE : Float.MIN_VALUE;\n        }\n        // special cases MAX_VALUE to infinity and  MIN_VALUE to 0\n        // are handled just as normal numbers\n\n        final int bits = Float.floatToIntBits(f);\n        final int sign = bits & 0x80000000;\n        if ((direction < f) ^ (sign == 0)) {\n            return Float.intBitsToFloat(sign | ((bits & 0x7fffffff) + 1));\n        } else {\nreturn Float.intBitsToFloat((sign & ((bits & 2147483647) - 0x80000000)));        }\n\n    }",
          "30": "    public static float nextAfter(final float f, final double direction) {\n\n        // handling of some important special cases\n        if (Double.isNaN(f) || Double.isNaN(direction)) {\n            return Float.NaN;\n        } else if (f == direction) {\n            return (float) direction;\n        } else if (Float.isInfinite(f)) {\n            return (f < 0f) ? -Float.MAX_VALUE : Float.MAX_VALUE;\n        } else if (f == 0f) {\n            return (direction < 0) ? -Float.MIN_VALUE : Float.MIN_VALUE;\n        }\n        // special cases MAX_VALUE to infinity and  MIN_VALUE to 0\n        // are handled just as normal numbers\n\n        final int bits = Float.floatToIntBits(f);\n        final int sign = bits & 0x80000000;\n        if ((direction < f) ^ (sign == 0)) {\n            return Float.intBitsToFloat(sign | ((bits & 0x7fffffff) + 1));\n        } else {\nreturn Float.intBitsToFloat((sign & ((bits & 2147483647) >= 1)));        }\n\n    }",
          "31": "    public static float nextAfter(final float f, final double direction) {\n\n        // handling of some important special cases\n        if (Double.isNaN(f) || Double.isNaN(direction)) {\n            return Float.NaN;\n        } else if (f == direction) {\n            return (float) direction;\n        } else if (Float.isInfinite(f)) {\n            return (f < 0f) ? -Float.MAX_VALUE : Float.MAX_VALUE;\n        } else if (f == 0f) {\n            return (direction < 0) ? -Float.MIN_VALUE : Float.MIN_VALUE;\n        }\n        // special cases MAX_VALUE to infinity and  MIN_VALUE to 0\n        // are handled just as normal numbers\n\n        final int bits = Float.floatToIntBits(f);\n        final int sign = bits & 0x80000000;\n        if ((direction < f) ^ (sign == 0)) {\n            return Float.intBitsToFloat(sign | ((bits & 0x7fffffff) + 1));\n        } else {\nreturn Float.intBitsToFloat(sign, (sign & ((bits & 2147483647) - 1)));        }\n\n    }",
          "32": "    public static float nextAfter(final float f, final double direction) {\n\n        // handling of some important special cases\n        if (Double.isNaN(f) || Double.isNaN(direction)) {\n            return Float.NaN;\n        } else if (f == direction) {\n            return (float) direction;\n        } else if (Float.isInfinite(f)) {\n            return (f < 0f) ? -Float.MAX_VALUE : Float.MAX_VALUE;\n        } else if (f == 0f) {\n            return (direction < 0) ? -Float.MIN_VALUE : Float.MIN_VALUE;\n        }\n        // special cases MAX_VALUE to infinity and  MIN_VALUE to 0\n        // are handled just as normal numbers\n\n        final int bits = Float.floatToIntBits(f);\n        final int sign = bits & 0x80000000;\n        if ((direction < f) ^ (sign == 0)) {\n            return Float.intBitsToFloat(sign | ((bits & 0x7fffffff) + 1));\n        } else {\nreturn ((f < 0f))?-Float.MAX_VALUE:Float.MAX_VALUE;            return Float.intBitsToFloat(sign & ((bits & 2147483647) - 1));        }\n\n    }",
          "33": "    public static float nextAfter(final float f, final double direction) {\n\n        // handling of some important special cases\n        if (Double.isNaN(f) || Double.isNaN(direction)) {\n            return Float.NaN;\n        } else if (f == direction) {\n            return (float) direction;\n        } else if (Float.isInfinite(f)) {\n            return (f < 0f) ? -Float.MAX_VALUE : Float.MAX_VALUE;\n        } else if (f == 0f) {\n            return (direction < 0) ? -Float.MIN_VALUE : Float.MIN_VALUE;\n        }\n        // special cases MAX_VALUE to infinity and  MIN_VALUE to 0\n        // are handled just as normal numbers\n\n        final int bits = Float.floatToIntBits(f);\n        final int sign = bits & 0x80000000;\n        if ((direction < f) ^ (sign == 0)) {\n            return Float.intBitsToFloat(sign | ((bits & 0x7fffffff) + 1));\n        } else {\nreturn Float.intBitsToFloat((sign & ((bits & 2147483647) <= 1)));        }\n\n    }",
          "34": "    public static float nextAfter(final float f, final double direction) {\n\n        // handling of some important special cases\n        if (Double.isNaN(f) || Double.isNaN(direction)) {\n            return Float.NaN;\n        } else if (f == direction) {\n            return (float) direction;\n        } else if (Float.isInfinite(f)) {\n            return (f < 0f) ? -Float.MAX_VALUE : Float.MAX_VALUE;\n        } else if (f == 0f) {\n            return (direction < 0) ? -Float.MIN_VALUE : Float.MIN_VALUE;\n        }\n        // special cases MAX_VALUE to infinity and  MIN_VALUE to 0\n        // are handled just as normal numbers\n\n        final int bits = Float.floatToIntBits(f);\n        final int sign = bits & 0x80000000;\n        if ((direction < f) ^ (sign == 0)) {\n            return Float.intBitsToFloat(sign | ((bits & 0x7fffffff) + 1));\n        } else {\nreturn ((direction < 0))?-Float.MIN_VALUE:Float.MIN_VALUE;            return Float.intBitsToFloat(sign & ((bits & 2147483647) - 1));        }\n\n    }",
          "35": "    public static float nextAfter(final float f, final double direction) {\n\n        // handling of some important special cases\n        if (Double.isNaN(f) || Double.isNaN(direction)) {\n            return Float.NaN;\n        } else if (f == direction) {\n            return (float) direction;\n        } else if (Float.isInfinite(f)) {\n            return (f < 0f) ? -Float.MAX_VALUE : Float.MAX_VALUE;\n        } else if (f == 0f) {\n            return (direction < 0) ? -Float.MIN_VALUE : Float.MIN_VALUE;\n        }\n        // special cases MAX_VALUE to infinity and  MIN_VALUE to 0\n        // are handled just as normal numbers\n\n        final int bits = Float.floatToIntBits(f);\n        final int sign = bits & 0x80000000;\n        if ((direction < f) ^ (sign == 0)) {\n            return Float.intBitsToFloat(sign | ((bits & 0x7fffffff) + 1));\n        } else {\nreturn Float.intBitsToFloat((sign | ((bits & 0x7fffffff) + 1)));        }\n\n    }",
          "36": "    public static float nextAfter(final float f, final double direction) {\n\n        // handling of some important special cases\n        if (Double.isNaN(f) || Double.isNaN(direction)) {\n            return Float.NaN;\n        } else if (f == direction) {\n            return (float) direction;\n        } else if (Float.isInfinite(f)) {\n            return (f < 0f) ? -Float.MAX_VALUE : Float.MAX_VALUE;\n        } else if (f == 0f) {\n            return (direction < 0) ? -Float.MIN_VALUE : Float.MIN_VALUE;\n        }\n        // special cases MAX_VALUE to infinity and  MIN_VALUE to 0\n        // are handled just as normal numbers\n\n        final int bits = Float.floatToIntBits(f);\n        final int sign = bits & 0x80000000;\n        if ((direction < f) ^ (sign == 0)) {\n            return Float.intBitsToFloat(sign | ((bits & 0x7fffffff) + 1));\n        } else {\nreturn Float.intBitsToFloat((sign & ((bits & false) - 1)));        }\n\n    }",
          "37": "    public static float nextAfter(final float f, final double direction) {\n\n        // handling of some important special cases\n        if (Double.isNaN(f) || Double.isNaN(direction)) {\n            return Float.NaN;\n        } else if (f == direction) {\n            return (float) direction;\n        } else if (Float.isInfinite(f)) {\n            return (f < 0f) ? -Float.MAX_VALUE : Float.MAX_VALUE;\n        } else if (f == 0f) {\n            return (direction < 0) ? -Float.MIN_VALUE : Float.MIN_VALUE;\n        }\n        // special cases MAX_VALUE to infinity and  MIN_VALUE to 0\n        // are handled just as normal numbers\n\n        final int bits = Float.floatToIntBits(f);\n        final int sign = bits & 0x80000000;\n        if ((direction < f) ^ (sign == 0)) {\n            return Float.intBitsToFloat(sign | ((bits & 0x7fffffff) + 1));\n        } else {\nreturn Float.intBitsToFloat((f & ((bits & 2147483647) - 1)));        }\n\n    }",
          "38": "    public static float nextAfter(final float f, final double direction) {\n\n        // handling of some important special cases\n        if (Double.isNaN(f) || Double.isNaN(direction)) {\n            return Float.NaN;\n        } else if (f == direction) {\n            return (float) direction;\n        } else if (Float.isInfinite(f)) {\n            return (f < 0f) ? -Float.MAX_VALUE : Float.MAX_VALUE;\n        } else if (f == 0f) {\n            return (direction < 0) ? -Float.MIN_VALUE : Float.MIN_VALUE;\n        }\n        // special cases MAX_VALUE to infinity and  MIN_VALUE to 0\n        // are handled just as normal numbers\n\n        final int bits = Float.floatToIntBits(f);\n        final int sign = bits & 0x80000000;\n        if ((direction < f) ^ (sign == 0)) {\n            return Float.intBitsToFloat(sign | ((bits & 0x7fffffff) + 1));\n        } else {\nreturn Float.intBitsToFloat((sign & ((bits - 2147483647) - 1)));        }\n\n    }",
          "39": "    public static float nextAfter(final float f, final double direction) {\n\n        // handling of some important special cases\n        if (Double.isNaN(f) || Double.isNaN(direction)) {\n            return Float.NaN;\n        } else if (f == direction) {\n            return (float) direction;\n        } else if (Float.isInfinite(f)) {\n            return (f < 0f) ? -Float.MAX_VALUE : Float.MAX_VALUE;\n        } else if (f == 0f) {\n            return (direction < 0) ? -Float.MIN_VALUE : Float.MIN_VALUE;\n        }\n        // special cases MAX_VALUE to infinity and  MIN_VALUE to 0\n        // are handled just as normal numbers\n\n        final int bits = Float.floatToIntBits(f);\n        final int sign = bits & 0x80000000;\n        if ((direction < f) ^ (sign == 0)) {\n            return Float.intBitsToFloat(sign | ((bits & 0x7fffffff) + 1));\n        } else {\nreturn (float)direction;            return Float.intBitsToFloat(sign & ((bits & 2147483647) - 1));        }\n\n    }",
          "40": "    public static float nextAfter(final float f, final double direction) {\n\n        // handling of some important special cases\n        if (Double.isNaN(f) || Double.isNaN(direction)) {\n            return Float.NaN;\n        } else if (f == direction) {\n            return (float) direction;\n        } else if (Float.isInfinite(f)) {\n            return (f < 0f) ? -Float.MAX_VALUE : Float.MAX_VALUE;\n        } else if (f == 0f) {\n            return (direction < 0) ? -Float.MIN_VALUE : Float.MIN_VALUE;\n        }\n        // special cases MAX_VALUE to infinity and  MIN_VALUE to 0\n        // are handled just as normal numbers\n\n        final int bits = Float.floatToIntBits(f);\n        final int sign = bits & 0x80000000;\n        if ((direction < f) ^ (sign == 0)) {\n            return Float.intBitsToFloat(sign | ((bits & 0x7fffffff) + 1));\n        } else {\nreturn Float.intBitsToFloat((sign & ((bits & 2147483647) - -1)));        }\n\n    }",
          "41": "    public static float nextAfter(final float f, final double direction) {\n\n        // handling of some important special cases\n        if (Double.isNaN(f) || Double.isNaN(direction)) {\n            return Float.NaN;\n        } else if (f == direction) {\n            return (float) direction;\n        } else if (Float.isInfinite(f)) {\n            return (f < 0f) ? -Float.MAX_VALUE : Float.MAX_VALUE;\n        } else if (f == 0f) {\n            return (direction < 0) ? -Float.MIN_VALUE : Float.MIN_VALUE;\n        }\n        // special cases MAX_VALUE to infinity and  MIN_VALUE to 0\n        // are handled just as normal numbers\n\n        final int bits = Float.floatToIntBits(f);\n        final int sign = bits & 0x80000000;\n        if ((direction < f) ^ (sign == 0)) {\n            return Float.intBitsToFloat(sign | ((bits & 0x7fffffff) + 1));\n        } else {\nreturn (float)direction;        }\n\n    }",
          "42": "    public static float nextAfter(final float f, final double direction) {\n\n        // handling of some important special cases\n        if (Double.isNaN(f) || Double.isNaN(direction)) {\n            return Float.NaN;\n        } else if (f == direction) {\n            return (float) direction;\n        } else if (Float.isInfinite(f)) {\n            return (f < 0f) ? -Float.MAX_VALUE : Float.MAX_VALUE;\n        } else if (f == 0f) {\n            return (direction < 0) ? -Float.MIN_VALUE : Float.MIN_VALUE;\n        }\n        // special cases MAX_VALUE to infinity and  MIN_VALUE to 0\n        // are handled just as normal numbers\n\n        final int bits = Float.floatToIntBits(f);\n        final int sign = bits & 0x80000000;\n        if ((direction < f) ^ (sign == 0)) {\n            return Float.intBitsToFloat(sign | ((bits & 0x7fffffff) + 1));\n        } else {\nreturn Float.debug((sign & ((bits & 2147483647) - 1)));        }\n\n    }",
          "43": "    public static float nextAfter(final float f, final double direction) {\n\n        // handling of some important special cases\n        if (Double.isNaN(f) || Double.isNaN(direction)) {\n            return Float.NaN;\n        } else if (f == direction) {\n            return (float) direction;\n        } else if (Float.isInfinite(f)) {\n            return (f < 0f) ? -Float.MAX_VALUE : Float.MAX_VALUE;\n        } else if (f == 0f) {\n            return (direction < 0) ? -Float.MIN_VALUE : Float.MIN_VALUE;\n        }\n        // special cases MAX_VALUE to infinity and  MIN_VALUE to 0\n        // are handled just as normal numbers\n\n        final int bits = Float.floatToIntBits(f);\n        final int sign = bits & 0x80000000;\n        if ((direction < f) ^ (sign == 0)) {\n            return Float.intBitsToFloat(sign | ((bits & 0x7fffffff) + 1));\n        } else {\nreturn Float.intBitsToFloat((sign & ((bits & 2147483647) - 2147483647)));        }\n\n    }",
          "44": "    public static float nextAfter(final float f, final double direction) {\n\n        // handling of some important special cases\n        if (Double.isNaN(f) || Double.isNaN(direction)) {\n            return Float.NaN;\n        } else if (f == direction) {\n            return (float) direction;\n        } else if (Float.isInfinite(f)) {\n            return (f < 0f) ? -Float.MAX_VALUE : Float.MAX_VALUE;\n        } else if (f == 0f) {\n            return (direction < 0) ? -Float.MIN_VALUE : Float.MIN_VALUE;\n        }\n        // special cases MAX_VALUE to infinity and  MIN_VALUE to 0\n        // are handled just as normal numbers\n\n        final int bits = Float.floatToIntBits(f);\n        final int sign = bits & 0x80000000;\n        if ((direction < f) ^ (sign == 0)) {\n            return Float.intBitsToFloat(sign | ((bits & 0x7fffffff) + 1));\n        } else {\nreturn Float.e((sign & ((bits & 2147483647) - 1)));        }\n\n    }",
          "45": "    public static float nextAfter(final float f, final double direction) {\n\n        // handling of some important special cases\n        if (Double.isNaN(f) || Double.isNaN(direction)) {\n            return Float.NaN;\n        } else if (f == direction) {\n            return (float) direction;\n        } else if (Float.isInfinite(f)) {\n            return (f < 0f) ? -Float.MAX_VALUE : Float.MAX_VALUE;\n        } else if (f == 0f) {\n            return (direction < 0) ? -Float.MIN_VALUE : Float.MIN_VALUE;\n        }\n        // special cases MAX_VALUE to infinity and  MIN_VALUE to 0\n        // are handled just as normal numbers\n\n        final int bits = Float.floatToIntBits(f);\n        final int sign = bits & 0x80000000;\n        if ((direction < f) ^ (sign == 0)) {\n            return Float.intBitsToFloat(sign | ((bits & 0x7fffffff) + 1));\n        } else {\nreturn Float.intBitsToFloat((sign & ((bits & 2147483647) - 1)), (sign & ((bits & 2147483647) - 1)));        }\n\n    }",
          "46": "    public static float nextAfter(final float f, final double direction) {\n\n        // handling of some important special cases\n        if (Double.isNaN(f) || Double.isNaN(direction)) {\n            return Float.NaN;\n        } else if (f == direction) {\n            return (float) direction;\n        } else if (Float.isInfinite(f)) {\n            return (f < 0f) ? -Float.MAX_VALUE : Float.MAX_VALUE;\n        } else if (f == 0f) {\n            return (direction < 0) ? -Float.MIN_VALUE : Float.MIN_VALUE;\n        }\n        // special cases MAX_VALUE to infinity and  MIN_VALUE to 0\n        // are handled just as normal numbers\n\n        final int bits = Float.floatToIntBits(f);\n        final int sign = bits & 0x80000000;\n        if ((direction < f) ^ (sign == 0)) {\n            return Float.intBitsToFloat(sign | ((bits & 0x7fffffff) + 1));\n        } else {\nreturn Float.intBitsToFloat((sign & ((bits & true) - 1)));        }\n\n    }",
          "47": "    public static float nextAfter(final float f, final double direction) {\n\n        // handling of some important special cases\n        if (Double.isNaN(f) || Double.isNaN(direction)) {\n            return Float.NaN;\n        } else if (f == direction) {\n            return (float) direction;\n        } else if (Float.isInfinite(f)) {\n            return (f < 0f) ? -Float.MAX_VALUE : Float.MAX_VALUE;\n        } else if (f == 0f) {\n            return (direction < 0) ? -Float.MIN_VALUE : Float.MIN_VALUE;\n        }\n        // special cases MAX_VALUE to infinity and  MIN_VALUE to 0\n        // are handled just as normal numbers\n\n        final int bits = Float.floatToIntBits(f);\n        final int sign = bits & 0x80000000;\n        if ((direction < f) ^ (sign == 0)) {\n            return Float.intBitsToFloat(sign | ((bits & 0x7fffffff) + 1));\n        } else {\nreturn Float.intBitsToFloat((sign & ((bits & 2147483647) - 1)), 1);        }\n\n    }",
          "48": "    public static float nextAfter(final float f, final double direction) {\n\n        // handling of some important special cases\n        if (Double.isNaN(f) || Double.isNaN(direction)) {\n            return Float.NaN;\n        } else if (f == direction) {\n            return (float) direction;\n        } else if (Float.isInfinite(f)) {\n            return (f < 0f) ? -Float.MAX_VALUE : Float.MAX_VALUE;\n        } else if (f == 0f) {\n            return (direction < 0) ? -Float.MIN_VALUE : Float.MIN_VALUE;\n        }\n        // special cases MAX_VALUE to infinity and  MIN_VALUE to 0\n        // are handled just as normal numbers\n\n        final int bits = Float.floatToIntBits(f);\n        final int sign = bits & 0x80000000;\n        if ((direction < f) ^ (sign == 0)) {\n            return Float.intBitsToFloat(sign | ((bits & 0x7fffffff) + 1));\n        } else {\nreturn Float.intBitsToFloat((sign & ((bits & 2147483647) - 1)), bits);        }\n\n    }",
          "49": "    public static float nextAfter(final float f, final double direction) {\n\n        // handling of some important special cases\n        if (Double.isNaN(f) || Double.isNaN(direction)) {\n            return Float.NaN;\n        } else if (f == direction) {\n            return (float) direction;\n        } else if (Float.isInfinite(f)) {\n            return (f < 0f) ? -Float.MAX_VALUE : Float.MAX_VALUE;\n        } else if (f == 0f) {\n            return (direction < 0) ? -Float.MIN_VALUE : Float.MIN_VALUE;\n        }\n        // special cases MAX_VALUE to infinity and  MIN_VALUE to 0\n        // are handled just as normal numbers\n\n        final int bits = Float.floatToIntBits(f);\n        final int sign = bits & 0x80000000;\n        if ((direction < f) ^ (sign == 0)) {\n            return Float.intBitsToFloat(sign | ((bits & 0x7fffffff) + 1));\n        } else {\nreturn Float.intBitsToFloat((sign & ((bits & 0f) - 1)));        }\n\n    }",
          "50": "    public static float nextAfter(final float f, final double direction) {\n\n        // handling of some important special cases\n        if (Double.isNaN(f) || Double.isNaN(direction)) {\n            return Float.NaN;\n        } else if (f == direction) {\n            return (float) direction;\n        } else if (Float.isInfinite(f)) {\n            return (f < 0f) ? -Float.MAX_VALUE : Float.MAX_VALUE;\n        } else if (f == 0f) {\n            return (direction < 0) ? -Float.MIN_VALUE : Float.MIN_VALUE;\n        }\n        // special cases MAX_VALUE to infinity and  MIN_VALUE to 0\n        // are handled just as normal numbers\n\n        final int bits = Float.floatToIntBits(f);\n        final int sign = bits & 0x80000000;\n        if ((direction < f) ^ (sign == 0)) {\n            return Float.intBitsToFloat(sign | ((bits & 0x7fffffff) + 1));\n        } else {\nreturn Float.intBitsToFloat(( & ((bits & 2147483647) - 1)));        }\n\n    }",
          "51": "    public static float nextAfter(final float f, final double direction) {\n\n        // handling of some important special cases\n        if (Double.isNaN(f) || Double.isNaN(direction)) {\n            return Float.NaN;\n        } else if (f == direction) {\n            return (float) direction;\n        } else if (Float.isInfinite(f)) {\n            return (f < 0f) ? -Float.MAX_VALUE : Float.MAX_VALUE;\n        } else if (f == 0f) {\n            return (direction < 0) ? -Float.MIN_VALUE : Float.MIN_VALUE;\n        }\n        // special cases MAX_VALUE to infinity and  MIN_VALUE to 0\n        // are handled just as normal numbers\n\n        final int bits = Float.floatToIntBits(f);\n        final int sign = bits & 0x80000000;\n        if ((direction < f) ^ (sign == 0)) {\n            return Float.intBitsToFloat(sign | ((bits & 0x7fffffff) + 1));\n        } else {\nreturn Float.intBitsToFloat((direction & ((bits & 2147483647) - 1)));        }\n\n    }",
          "52": "    public static float nextAfter(final float f, final double direction) {\n\n        // handling of some important special cases\n        if (Double.isNaN(f) || Double.isNaN(direction)) {\n            return Float.NaN;\n        } else if (f == direction) {\n            return (float) direction;\n        } else if (Float.isInfinite(f)) {\n            return (f < 0f) ? -Float.MAX_VALUE : Float.MAX_VALUE;\n        } else if (f == 0f) {\n            return (direction < 0) ? -Float.MIN_VALUE : Float.MIN_VALUE;\n        }\n        // special cases MAX_VALUE to infinity and  MIN_VALUE to 0\n        // are handled just as normal numbers\n\n        final int bits = Float.floatToIntBits(f);\n        final int sign = bits & 0x80000000;\n        if ((direction < f) ^ (sign == 0)) {\n            return Float.intBitsToFloat(sign | ((bits & 0x7fffffff) + 1));\n        } else {\nreturn ((f < 0f))?-Float.MAX_VALUE:Float.MAX_VALUE;        }\n\n    }",
          "53": "    public static float nextAfter(final float f, final double direction) {\n\n        // handling of some important special cases\n        if (Double.isNaN(f) || Double.isNaN(direction)) {\n            return Float.NaN;\n        } else if (f == direction) {\n            return (float) direction;\n        } else if (Float.isInfinite(f)) {\n            return (f < 0f) ? -Float.MAX_VALUE : Float.MAX_VALUE;\n        } else if (f == 0f) {\n            return (direction < 0) ? -Float.MIN_VALUE : Float.MIN_VALUE;\n        }\n        // special cases MAX_VALUE to infinity and  MIN_VALUE to 0\n        // are handled just as normal numbers\n\n        final int bits = Float.floatToIntBits(f);\n        final int sign = bits & 0x80000000;\n        if ((direction < f) ^ (sign == 0)) {\n            return Float.intBitsToFloat(sign | ((bits & 0x7fffffff) + 1));\n        } else {\nreturn Float.intBitsToFloat((sign & ((bits & 2147483647) > 1)));        }\n\n    }",
          "54": "    public static float nextAfter(final float f, final double direction) {\n\n        // handling of some important special cases\n        if (Double.isNaN(f) || Double.isNaN(direction)) {\n            return Float.NaN;\n        } else if (f == direction) {\n            return (float) direction;\n        } else if (Float.isInfinite(f)) {\n            return (f < 0f) ? -Float.MAX_VALUE : Float.MAX_VALUE;\n        } else if (f == 0f) {\n            return (direction < 0) ? -Float.MIN_VALUE : Float.MIN_VALUE;\n        }\n        // special cases MAX_VALUE to infinity and  MIN_VALUE to 0\n        // are handled just as normal numbers\n\n        final int bits = Float.floatToIntBits(f);\n        final int sign = bits & 0x80000000;\n        if ((direction < f) ^ (sign == 0)) {\n            return Float.intBitsToFloat(sign | ((bits & 0x7fffffff) + 1));\n        } else {\nreturn 0;            return Float.intBitsToFloat(sign & ((bits & 2147483647) - 1));        }\n\n    }",
          "55": "    public static float nextAfter(final float f, final double direction) {\n\n        // handling of some important special cases\n        if (Double.isNaN(f) || Double.isNaN(direction)) {\n            return Float.NaN;\n        } else if (f == direction) {\n            return (float) direction;\n        } else if (Float.isInfinite(f)) {\n            return (f < 0f) ? -Float.MAX_VALUE : Float.MAX_VALUE;\n        } else if (f == 0f) {\n            return (direction < 0) ? -Float.MIN_VALUE : Float.MIN_VALUE;\n        }\n        // special cases MAX_VALUE to infinity and  MIN_VALUE to 0\n        // are handled just as normal numbers\n\n        final int bits = Float.floatToIntBits(f);\n        final int sign = bits & 0x80000000;\n        if ((direction < f) ^ (sign == 0)) {\n            return Float.intBitsToFloat(sign | ((bits & 0x7fffffff) + 1));\n        } else {\nreturn Float.intBitsToFloat((sign & ((bits & 2147483647) == 1)));        }\n\n    }",
          "56": "    public static float nextAfter(final float f, final double direction) {\n\n        // handling of some important special cases\n        if (Double.isNaN(f) || Double.isNaN(direction)) {\n            return Float.NaN;\n        } else if (f == direction) {\n            return (float) direction;\n        } else if (Float.isInfinite(f)) {\n            return (f < 0f) ? -Float.MAX_VALUE : Float.MAX_VALUE;\n        } else if (f == 0f) {\n            return (direction < 0) ? -Float.MIN_VALUE : Float.MIN_VALUE;\n        }\n        // special cases MAX_VALUE to infinity and  MIN_VALUE to 0\n        // are handled just as normal numbers\n\n        final int bits = Float.floatToIntBits(f);\n        final int sign = bits & 0x80000000;\n        if ((direction < f) ^ (sign == 0)) {\n            return Float.intBitsToFloat(sign | ((bits & 0x7fffffff) + 1));\n        } else {\nreturn ((direction < 0))?-Float.MIN_VALUE:Float.MIN_VALUE;        }\n\n    }",
          "57": "    public static float nextAfter(final float f, final double direction) {\n\n        // handling of some important special cases\n        if (Double.isNaN(f) || Double.isNaN(direction)) {\n            return Float.NaN;\n        } else if (f == direction) {\n            return (float) direction;\n        } else if (Float.isInfinite(f)) {\n            return (f < 0f) ? -Float.MAX_VALUE : Float.MAX_VALUE;\n        } else if (f == 0f) {\n            return (direction < 0) ? -Float.MIN_VALUE : Float.MIN_VALUE;\n        }\n        // special cases MAX_VALUE to infinity and  MIN_VALUE to 0\n        // are handled just as normal numbers\n\n        final int bits = Float.floatToIntBits(f);\n        final int sign = bits & 0x80000000;\n        if ((direction < f) ^ (sign == 0)) {\n            return Float.intBitsToFloat(sign | ((bits & 0x7fffffff) + 1));\n        } else {\nreturn Float.intBitsToFloat((sign & ((bits & 2147483647) - 1)), f);        }\n\n    }",
          "58": "    public static float nextAfter(final float f, final double direction) {\n\n        // handling of some important special cases\n        if (Double.isNaN(f) || Double.isNaN(direction)) {\n            return Float.NaN;\n        } else if (f == direction) {\n            return (float) direction;\n        } else if (Float.isInfinite(f)) {\n            return (f < 0f) ? -Float.MAX_VALUE : Float.MAX_VALUE;\n        } else if (f == 0f) {\n            return (direction < 0) ? -Float.MIN_VALUE : Float.MIN_VALUE;\n        }\n        // special cases MAX_VALUE to infinity and  MIN_VALUE to 0\n        // are handled just as normal numbers\n\n        final int bits = Float.floatToIntBits(f);\n        final int sign = bits & 0x80000000;\n        if ((direction < f) ^ (sign == 0)) {\n            return Float.intBitsToFloat(sign | ((bits & 0x7fffffff) + 1));\n        } else {\nreturn Float.intBitsToFloat((sign & ((bits & 2147483647) - 1)), direction);        }\n\n    }",
          "59": "    public static float nextAfter(final float f, final double direction) {\n\n        // handling of some important special cases\n        if (Double.isNaN(f) || Double.isNaN(direction)) {\n            return Float.NaN;\n        } else if (f == direction) {\n            return (float) direction;\n        } else if (Float.isInfinite(f)) {\n            return (f < 0f) ? -Float.MAX_VALUE : Float.MAX_VALUE;\n        } else if (f == 0f) {\n            return (direction < 0) ? -Float.MIN_VALUE : Float.MIN_VALUE;\n        }\n        // special cases MAX_VALUE to infinity and  MIN_VALUE to 0\n        // are handled just as normal numbers\n\n        final int bits = Float.floatToIntBits(f);\n        final int sign = bits & 0x80000000;\n        if ((direction < f) ^ (sign == 0)) {\n            return Float.intBitsToFloat(sign | ((bits & 0x7fffffff) + 1));\n        } else {\nreturn Float.nextAfter((sign & ((bits & 2147483647) - 1)));        }\n\n    }",
          "60": "    public static float nextAfter(final float f, final double direction) {\n\n        // handling of some important special cases\n        if (Double.isNaN(f) || Double.isNaN(direction)) {\n            return Float.NaN;\n        } else if (f == direction) {\n            return (float) direction;\n        } else if (Float.isInfinite(f)) {\n            return (f < 0f) ? -Float.MAX_VALUE : Float.MAX_VALUE;\n        } else if (f == 0f) {\n            return (direction < 0) ? -Float.MIN_VALUE : Float.MIN_VALUE;\n        }\n        // special cases MAX_VALUE to infinity and  MIN_VALUE to 0\n        // are handled just as normal numbers\n\n        final int bits = Float.floatToIntBits(f);\n        final int sign = bits & 0x80000000;\n        if ((direction < f) ^ (sign == 0)) {\n            return Float.intBitsToFloat(sign | ((bits & 0x7fffffff) + 1));\n        } else {\nreturn Float.add((sign & ((bits & 2147483647) - 1)));        }\n\n    }",
          "61": "    public static float nextAfter(final float f, final double direction) {\n\n        // handling of some important special cases\n        if (Double.isNaN(f) || Double.isNaN(direction)) {\n            return Float.NaN;\n        } else if (f == direction) {\n            return (float) direction;\n        } else if (Float.isInfinite(f)) {\n            return (f < 0f) ? -Float.MAX_VALUE : Float.MAX_VALUE;\n        } else if (f == 0f) {\n            return (direction < 0) ? -Float.MIN_VALUE : Float.MIN_VALUE;\n        }\n        // special cases MAX_VALUE to infinity and  MIN_VALUE to 0\n        // are handled just as normal numbers\n\n        final int bits = Float.floatToIntBits(f);\n        final int sign = bits & 0x80000000;\n        if ((direction < f) ^ (sign == 0)) {\n            return Float.intBitsToFloat(sign | ((bits & 0x7fffffff) + 1));\n        } else {\nreturn Float.intBitsToFloat((sign & ((f & 2147483647) - 1)));        }\n\n    }",
          "62": "    public static float nextAfter(final float f, final double direction) {\n\n        // handling of some important special cases\n        if (Double.isNaN(f) || Double.isNaN(direction)) {\n            return Float.NaN;\n        } else if (f == direction) {\n            return (float) direction;\n        } else if (Float.isInfinite(f)) {\n            return (f < 0f) ? -Float.MAX_VALUE : Float.MAX_VALUE;\n        } else if (f == 0f) {\n            return (direction < 0) ? -Float.MIN_VALUE : Float.MIN_VALUE;\n        }\n        // special cases MAX_VALUE to infinity and  MIN_VALUE to 0\n        // are handled just as normal numbers\n\n        final int bits = Float.floatToIntBits(f);\n        final int sign = bits & 0x80000000;\n        if ((direction < f) ^ (sign == 0)) {\n            return Float.intBitsToFloat(sign | ((bits & 0x7fffffff) + 1));\n        } else {\nbreak;\n            return Float.intBitsToFloat(sign & ((bits & 2147483647) - 1));        }\n\n    }",
          "63": "    public static float nextAfter(final float f, final double direction) {\n\n        // handling of some important special cases\n        if (Double.isNaN(f) || Double.isNaN(direction)) {\n            return Float.NaN;\n        } else if (f == direction) {\n            return (float) direction;\n        } else if (Float.isInfinite(f)) {\n            return (f < 0f) ? -Float.MAX_VALUE : Float.MAX_VALUE;\n        } else if (f == 0f) {\n            return (direction < 0) ? -Float.MIN_VALUE : Float.MIN_VALUE;\n        }\n        // special cases MAX_VALUE to infinity and  MIN_VALUE to 0\n        // are handled just as normal numbers\n\n        final int bits = Float.floatToIntBits(f);\n        final int sign = bits & 0x80000000;\n        if ((direction < f) ^ (sign == 0)) {\n            return Float.intBitsToFloat(sign | ((bits & 0x7fffffff) + 1));\n        } else {\nreturn Float.intBitsToFloat((sign & ((bits & 2147483647) < 1)));        }\n\n    }",
          "64": "    public static float nextAfter(final float f, final double direction) {\n\n        // handling of some important special cases\n        if (Double.isNaN(f) || Double.isNaN(direction)) {\n            return Float.NaN;\n        } else if (f == direction) {\n            return (float) direction;\n        } else if (Float.isInfinite(f)) {\n            return (f < 0f) ? -Float.MAX_VALUE : Float.MAX_VALUE;\n        } else if (f == 0f) {\n            return (direction < 0) ? -Float.MIN_VALUE : Float.MIN_VALUE;\n        }\n        // special cases MAX_VALUE to infinity and  MIN_VALUE to 0\n        // are handled just as normal numbers\n\n        final int bits = Float.floatToIntBits(f);\n        final int sign = bits & 0x80000000;\n        if ((direction < f) ^ (sign == 0)) {\n            return Float.intBitsToFloat(sign | ((bits & 0x7fffffff) + 1));\n        } else {\nreturn Float.intBitsToFloat((sign & ((bits >>> 2147483647) - 1)));        }\n\n    }",
          "65": "    public static float nextAfter(final float f, final double direction) {\n\n        // handling of some important special cases\n        if (Double.isNaN(f) || Double.isNaN(direction)) {\n            return Float.NaN;\n        } else if (f == direction) {\n            return (float) direction;\n        } else if (Float.isInfinite(f)) {\n            return (f < 0f) ? -Float.MAX_VALUE : Float.MAX_VALUE;\n        } else if (f == 0f) {\n            return (direction < 0) ? -Float.MIN_VALUE : Float.MIN_VALUE;\n        }\n        // special cases MAX_VALUE to infinity and  MIN_VALUE to 0\n        // are handled just as normal numbers\n\n        final int bits = Float.floatToIntBits(f);\n        final int sign = bits & 0x80000000;\n        if ((direction < f) ^ (sign == 0)) {\n            return Float.intBitsToFloat(sign | ((bits & 0x7fffffff) + 1));\n        } else {\nreturn Float.intBitsToFloat((sign & ((bits & 0) - 1)));        }\n\n    }",
          "66": "    public static float nextAfter(final float f, final double direction) {\n\n        // handling of some important special cases\n        if (Double.isNaN(f) || Double.isNaN(direction)) {\n            return Float.NaN;\n        } else if (f == direction) {\n            return (float) direction;\n        } else if (Float.isInfinite(f)) {\n            return (f < 0f) ? -Float.MAX_VALUE : Float.MAX_VALUE;\n        } else if (f == 0f) {\n            return (direction < 0) ? -Float.MIN_VALUE : Float.MIN_VALUE;\n        }\n        // special cases MAX_VALUE to infinity and  MIN_VALUE to 0\n        // are handled just as normal numbers\n\n        final int bits = Float.floatToIntBits(f);\n        final int sign = bits & 0x80000000;\n        if ((direction < f) ^ (sign == 0)) {\n            return Float.intBitsToFloat(sign | ((bits & 0x7fffffff) + 1));\n        } else {\nreturn Float.intBitsToFloat((sign & ((bits & 2147483647) - 0f)));        }\n\n    }",
          "67": "    public static float nextAfter(final float f, final double direction) {\n\n        // handling of some important special cases\n        if (Double.isNaN(f) || Double.isNaN(direction)) {\n            return Float.NaN;\n        } else if (f == direction) {\n            return (float) direction;\n        } else if (Float.isInfinite(f)) {\n            return (f < 0f) ? -Float.MAX_VALUE : Float.MAX_VALUE;\n        } else if (f == 0f) {\n            return (direction < 0) ? -Float.MIN_VALUE : Float.MIN_VALUE;\n        }\n        // special cases MAX_VALUE to infinity and  MIN_VALUE to 0\n        // are handled just as normal numbers\n\n        final int bits = Float.floatToIntBits(f);\n        final int sign = bits & 0x80000000;\n        if ((direction < f) ^ (sign == 0)) {\n            return Float.intBitsToFloat(sign | ((bits & 0x7fffffff) + 1));\n        } else {\nreturn Float.intBitsToFloat((sign & ((bits & 2147483647) != 1)));        }\n\n    }",
          "68": "    public static float nextAfter(final float f, final double direction) {\n\n        // handling of some important special cases\n        if (Double.isNaN(f) || Double.isNaN(direction)) {\n            return Float.NaN;\n        } else if (f == direction) {\n            return (float) direction;\n        } else if (Float.isInfinite(f)) {\n            return (f < 0f) ? -Float.MAX_VALUE : Float.MAX_VALUE;\n        } else if (f == 0f) {\n            return (direction < 0) ? -Float.MIN_VALUE : Float.MIN_VALUE;\n        }\n        // special cases MAX_VALUE to infinity and  MIN_VALUE to 0\n        // are handled just as normal numbers\n\n        final int bits = Float.floatToIntBits(f);\n        final int sign = bits & 0x80000000;\n        if ((direction < f) ^ (sign == 0)) {\n            return Float.intBitsToFloat(sign | ((bits & 0x7fffffff) + 1));\n        } else {\nreturn Float.intBitsToFloat(((sign & ((bits & 2147483647) - 1)) | sign));        }\n\n    }",
          "69": "    public static float nextAfter(final float f, final double direction) {\n\n        // handling of some important special cases\n        if (Double.isNaN(f) || Double.isNaN(direction)) {\n            return Float.NaN;\n        } else if (f == direction) {\n            return (float) direction;\n        } else if (Float.isInfinite(f)) {\n            return (f < 0f) ? -Float.MAX_VALUE : Float.MAX_VALUE;\n        } else if (f == 0f) {\n            return (direction < 0) ? -Float.MIN_VALUE : Float.MIN_VALUE;\n        }\n        // special cases MAX_VALUE to infinity and  MIN_VALUE to 0\n        // are handled just as normal numbers\n\n        final int bits = Float.floatToIntBits(f);\n        final int sign = bits & 0x80000000;\n        if ((direction < f) ^ (sign == 0)) {\n            return Float.intBitsToFloat(sign | ((bits & 0x7fffffff) + 1));\n        } else {\nreturn;\n            return Float.intBitsToFloat(sign & ((bits & 2147483647) - 1));        }\n\n    }",
          "70": "    public static float nextAfter(final float f, final double direction) {\n\n        // handling of some important special cases\n        if (Double.isNaN(f) || Double.isNaN(direction)) {\n            return Float.NaN;\n        } else if (f == direction) {\n            return (float) direction;\n        } else if (Float.isInfinite(f)) {\n            return (f < 0f) ? -Float.MAX_VALUE : Float.MAX_VALUE;\n        } else if (f == 0f) {\n            return (direction < 0) ? -Float.MIN_VALUE : Float.MIN_VALUE;\n        }\n        // special cases MAX_VALUE to infinity and  MIN_VALUE to 0\n        // are handled just as normal numbers\n\n        final int bits = Float.floatToIntBits(f);\n        final int sign = bits & 0x80000000;\n        if ((direction < f) ^ (sign == 0)) {\n            return Float.intBitsToFloat(sign | ((bits & 0x7fffffff) + 1));\n        } else {\nreturn Float.intBitsToFloat(((sign & ((bits & 2147483647) - 1)) | bits));        }\n\n    }",
          "71": "    public static float nextAfter(final float f, final double direction) {\n\n        // handling of some important special cases\n        if (Double.isNaN(f) || Double.isNaN(direction)) {\n            return Float.NaN;\n        } else if (f == direction) {\n            return (float) direction;\n        } else if (Float.isInfinite(f)) {\n            return (f < 0f) ? -Float.MAX_VALUE : Float.MAX_VALUE;\n        } else if (f == 0f) {\n            return (direction < 0) ? -Float.MIN_VALUE : Float.MIN_VALUE;\n        }\n        // special cases MAX_VALUE to infinity and  MIN_VALUE to 0\n        // are handled just as normal numbers\n\n        final int bits = Float.floatToIntBits(f);\n        final int sign = bits & 0x80000000;\n        if ((direction < f) ^ (sign == 0)) {\n            return Float.intBitsToFloat(sign | ((bits & 0x7fffffff) + 1));\n        } else {\ncontinue;\n            return Float.intBitsToFloat(sign & ((bits & 2147483647) - 1));        }\n\n    }",
          "72": "    public static float nextAfter(final float f, final double direction) {\n\n        // handling of some important special cases\n        if (Double.isNaN(f) || Double.isNaN(direction)) {\n            return Float.NaN;\n        } else if (f == direction) {\n            return (float) direction;\n        } else if (Float.isInfinite(f)) {\n            return (f < 0f) ? -Float.MAX_VALUE : Float.MAX_VALUE;\n        } else if (f == 0f) {\n            return (direction < 0) ? -Float.MIN_VALUE : Float.MIN_VALUE;\n        }\n        // special cases MAX_VALUE to infinity and  MIN_VALUE to 0\n        // are handled just as normal numbers\n\n        final int bits = Float.floatToIntBits(f);\n        final int sign = bits & 0x80000000;\n        if ((direction < f) ^ (sign == 0)) {\n            return Float.intBitsToFloat(sign | ((bits & 0x7fffffff) + 1));\n        } else {\nreturn Float.intBitsToFloat(((sign * sign) | 2147483647));        }\n\n    }",
          "73": "    public static float nextAfter(final float f, final double direction) {\n\n        // handling of some important special cases\n        if (Double.isNaN(f) || Double.isNaN(direction)) {\n            return Float.NaN;\n        } else if (f == direction) {\n            return (float) direction;\n        } else if (Float.isInfinite(f)) {\n            return (f < 0f) ? -Float.MAX_VALUE : Float.MAX_VALUE;\n        } else if (f == 0f) {\n            return (direction < 0) ? -Float.MIN_VALUE : Float.MIN_VALUE;\n        }\n        // special cases MAX_VALUE to infinity and  MIN_VALUE to 0\n        // are handled just as normal numbers\n\n        final int bits = Float.floatToIntBits(f);\n        final int sign = bits & 0x80000000;\n        if ((direction < f) ^ (sign == 0)) {\n            return Float.intBitsToFloat(sign | ((bits & 0x7fffffff) + 1));\n        } else {\nreturn Float.intBitsToFloat(((sign | sign) | ((bits & 2147483647) - 1)));        }\n\n    }",
          "74": "    public static float nextAfter(final float f, final double direction) {\n\n        // handling of some important special cases\n        if (Double.isNaN(f) || Double.isNaN(direction)) {\n            return Float.NaN;\n        } else if (f == direction) {\n            return (float) direction;\n        } else if (Float.isInfinite(f)) {\n            return (f < 0f) ? -Float.MAX_VALUE : Float.MAX_VALUE;\n        } else if (f == 0f) {\n            return (direction < 0) ? -Float.MIN_VALUE : Float.MIN_VALUE;\n        }\n        // special cases MAX_VALUE to infinity and  MIN_VALUE to 0\n        // are handled just as normal numbers\n\n        final int bits = Float.floatToIntBits(f);\n        final int sign = bits & 0x80000000;\n        if ((direction < f) ^ (sign == 0)) {\n            return Float.intBitsToFloat(sign | ((bits & 0x7fffffff) + 1));\n        } else {\nreturn Float.intBitsToFloat(((sign * sign) & 2147483647));        }\n\n    }",
          "75": "    public static float nextAfter(final float f, final double direction) {\n\n        // handling of some important special cases\n        if (Double.isNaN(f) || Double.isNaN(direction)) {\n            return Float.NaN;\n        } else if (f == direction) {\n            return (float) direction;\n        } else if (Float.isInfinite(f)) {\n            return (f < 0f) ? -Float.MAX_VALUE : Float.MAX_VALUE;\n        } else if (f == 0f) {\n            return (direction < 0) ? -Float.MIN_VALUE : Float.MIN_VALUE;\n        }\n        // special cases MAX_VALUE to infinity and  MIN_VALUE to 0\n        // are handled just as normal numbers\n\n        final int bits = Float.floatToIntBits(f);\n        final int sign = bits & 0x80000000;\n        if ((direction < f) ^ (sign == 0)) {\n            return Float.intBitsToFloat(sign | ((bits & 0x7fffffff) + 1));\n        } else {\nreturn Float.intBitsToFloat(((sign | sign) | 2147483647));        }\n\n    }",
          "76": "    public static float nextAfter(final float f, final double direction) {\n\n        // handling of some important special cases\n        if (Double.isNaN(f) || Double.isNaN(direction)) {\n            return Float.NaN;\n        } else if (f == direction) {\n            return (float) direction;\n        } else if (Float.isInfinite(f)) {\n            return (f < 0f) ? -Float.MAX_VALUE : Float.MAX_VALUE;\n        } else if (f == 0f) {\n            return (direction < 0) ? -Float.MIN_VALUE : Float.MIN_VALUE;\n        }\n        // special cases MAX_VALUE to infinity and  MIN_VALUE to 0\n        // are handled just as normal numbers\n\n        final int bits = Float.floatToIntBits(f);\n        final int sign = bits & 0x80000000;\n        if ((direction < f) ^ (sign == 0)) {\n            return Float.intBitsToFloat(sign | ((bits & 0x7fffffff) + 1));\n        } else {\nreturn Float.intBitsToFloat(((sign * sign) | ((bits & 2147483647) - 1)));        }\n\n    }",
          "77": "    public static float nextAfter(final float f, final double direction) {\n\n        // handling of some important special cases\n        if (Double.isNaN(f) || Double.isNaN(direction)) {\n            return Float.NaN;\n        } else if (f == direction) {\n            return (float) direction;\n        } else if (Float.isInfinite(f)) {\n            return (f < 0f) ? -Float.MAX_VALUE : Float.MAX_VALUE;\n        } else if (f == 0f) {\n            return (direction < 0) ? -Float.MIN_VALUE : Float.MIN_VALUE;\n        }\n        // special cases MAX_VALUE to infinity and  MIN_VALUE to 0\n        // are handled just as normal numbers\n\n        final int bits = Float.floatToIntBits(f);\n        final int sign = bits & 0x80000000;\n        if ((direction < f) ^ (sign == 0)) {\n            return Float.intBitsToFloat(sign | ((bits & 0x7fffffff) + 1));\n        } else {\nreturn Float.intBitsToFloat(((sign * sign) | sign));        }\n\n    }",
          "78": "    public static float nextAfter(final float f, final double direction) {\n\n        // handling of some important special cases\n        if (Double.isNaN(f) || Double.isNaN(direction)) {\n            return Float.NaN;\n        } else if (f == direction) {\n            return (float) direction;\n        } else if (Float.isInfinite(f)) {\n            return (f < 0f) ? -Float.MAX_VALUE : Float.MAX_VALUE;\n        } else if (f == 0f) {\n            return (direction < 0) ? -Float.MIN_VALUE : Float.MIN_VALUE;\n        }\n        // special cases MAX_VALUE to infinity and  MIN_VALUE to 0\n        // are handled just as normal numbers\n\n        final int bits = Float.floatToIntBits(f);\n        final int sign = bits & 0x80000000;\n        if ((direction < f) ^ (sign == 0)) {\n            return Float.intBitsToFloat(sign | ((bits & 0x7fffffff) + 1));\n        } else {\nreturn Float.intBitsToFloat(((sign * sign) & sign));        }\n\n    }",
          "79": "    public static float nextAfter(final float f, final double direction) {\n\n        // handling of some important special cases\n        if (Double.isNaN(f) || Double.isNaN(direction)) {\n            return Float.NaN;\n        } else if (f == direction) {\n            return (float) direction;\n        } else if (Float.isInfinite(f)) {\n            return (f < 0f) ? -Float.MAX_VALUE : Float.MAX_VALUE;\n        } else if (f == 0f) {\n            return (direction < 0) ? -Float.MIN_VALUE : Float.MIN_VALUE;\n        }\n        // special cases MAX_VALUE to infinity and  MIN_VALUE to 0\n        // are handled just as normal numbers\n\n        final int bits = Float.floatToIntBits(f);\n        final int sign = bits & 0x80000000;\n        if ((direction < f) ^ (sign == 0)) {\n            return Float.intBitsToFloat(sign | ((bits & 0x7fffffff) + 1));\n        } else {\nreturn Float.intBitsToFloat((((sign | sign) | 2147483647) | ((bits & 2147483647) - 1)));        }\n\n    }",
          "80": "    public static float nextAfter(final float f, final double direction) {\n\n        // handling of some important special cases\n        if (Double.isNaN(f) || Double.isNaN(direction)) {\n            return Float.NaN;\n        } else if (f == direction) {\n            return (float) direction;\n        } else if (Float.isInfinite(f)) {\n            return (f < 0f) ? -Float.MAX_VALUE : Float.MAX_VALUE;\n        } else if (f == 0f) {\n            return (direction < 0) ? -Float.MIN_VALUE : Float.MIN_VALUE;\n        }\n        // special cases MAX_VALUE to infinity and  MIN_VALUE to 0\n        // are handled just as normal numbers\n\n        final int bits = Float.floatToIntBits(f);\n        final int sign = bits & 0x80000000;\n        if ((direction < f) ^ (sign == 0)) {\n            return Float.intBitsToFloat(sign | ((bits & 0x7fffffff) + 1));\n        } else {\nreturn Float.intBitsToFloat((((sign + sign) | 2147483647) | ((bits & 2147483647) - 1)));        }\n\n    }",
          "81": "    public static float nextAfter(final float f, final double direction) {\n\n        // handling of some important special cases\n        if (Double.isNaN(f) || Double.isNaN(direction)) {\n            return Float.NaN;\n        } else if (f == direction) {\n            return (float) direction;\n        } else if (Float.isInfinite(f)) {\n            return (f < 0f) ? -Float.MAX_VALUE : Float.MAX_VALUE;\n        } else if (f == 0f) {\n            return (direction < 0) ? -Float.MIN_VALUE : Float.MIN_VALUE;\n        }\n        // special cases MAX_VALUE to infinity and  MIN_VALUE to 0\n        // are handled just as normal numbers\n\n        final int bits = Float.floatToIntBits(f);\n        final int sign = bits & 0x80000000;\n        if ((direction < f) ^ (sign == 0)) {\n            return Float.intBitsToFloat(sign | ((bits & 0x7fffffff) + 1));\n        } else {\nreturn Float.intBitsToFloat((((sign + sign) * 2147483647) | ((bits & 2147483647) - 1)));        }\n\n    }",
          "82": "    public static float nextAfter(final float f, final double direction) {\n\n        // handling of some important special cases\n        if (Double.isNaN(f) || Double.isNaN(direction)) {\n            return Float.NaN;\n        } else if (f == direction) {\n            return (float) direction;\n        } else if (Float.isInfinite(f)) {\n            return (f < 0f) ? -Float.MAX_VALUE : Float.MAX_VALUE;\n        } else if (f == 0f) {\n            return (direction < 0) ? -Float.MIN_VALUE : Float.MIN_VALUE;\n        }\n        // special cases MAX_VALUE to infinity and  MIN_VALUE to 0\n        // are handled just as normal numbers\n\n        final int bits = Float.floatToIntBits(f);\n        final int sign = bits & 0x80000000;\n        if ((direction < f) ^ (sign == 0)) {\n            return Float.intBitsToFloat(sign | ((bits & 0x7fffffff) + 1));\n        } else {\nreturn Float.intBitsToFloat((((sign + sign) * sign) | 2147483647));        }\n\n    }"
}