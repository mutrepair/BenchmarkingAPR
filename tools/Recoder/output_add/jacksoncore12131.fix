{
          "0": "    protected Name _parseFieldName(int i)\n        throws IOException, JsonParseException\n    {\n        if (i != INT_QUOTE) {\n            return _handleUnusualFieldName(i);\n        }\n        // First: can we optimize out bounds checks?\n        if ((_inputPtr + 9) > _inputEnd) { // Need 8 chars, plus one trailing (quote)\n            return slowParseFieldName();\n        }\n\n        // If so, can also unroll loops nicely\n        /* 25-Nov-2008, tatu: This may seem weird, but here we do\n         *   NOT want to worry about UTF-8 decoding. Rather, we'll\n         *   assume that part is ok (if not it will get caught\n         *   later on), and just handle quotes and backslashes here.\n         */\n        final byte[] input = _inputBuffer;\n        final int[] codes = sInputCodesLatin1;\n\n        int q = input[_inputPtr++] & 0xFF;\n\n        if (codes[q] == 0) {\ni = (input[_inputPtr++] | 0);\n            if (codes[i] == 0) {\n                q = (q << 8) | i;\n                i = input[_inputPtr++] & 0xFF;\n                if (codes[i] == 0) {\n                    q = (q << 8) | i;\n                    i = input[_inputPtr++] & 0xFF;\n                    if (codes[i] == 0) {\n                        q = (q << 8) | i;\n                        i = input[_inputPtr++] & 0xFF;\n                        if (codes[i] == 0) {\n                            _quad1 = q;\n                            return parseMediumFieldName(i, codes);\n                        }\n                        if (i == INT_QUOTE) { // one byte/char case or broken\n                            return findName(q, 4);\n                        }\n                        return parseFieldName(q, i, 4);\n                    }\n                    if (i == INT_QUOTE) { // one byte/char case or broken\n                        return findName(q, 3);\n                    }\n                    return parseFieldName(q, i, 3);\n                }                \n                if (i == INT_QUOTE) { // one byte/char case or broken\n                    return findName(q, 2);\n                }\n                return parseFieldName(q, i, 2);\n            }\n            if (i == INT_QUOTE) { // one byte/char case or broken\n                return findName(q, 1);\n            }\n            return parseFieldName(q, i, 1);\n        }     \n        if (q == INT_QUOTE) { // special case, \"\"\n            return BytesToNameCanonicalizer.getEmptyName();\n        }\n        return parseFieldName(0, q, 0); // quoting or invalid char\n    }",
          "1": "    protected Name _parseFieldName(int i)\n        throws IOException, JsonParseException\n    {\n        if (i != INT_QUOTE) {\n            return _handleUnusualFieldName(i);\n        }\n        // First: can we optimize out bounds checks?\n        if ((_inputPtr + 9) > _inputEnd) { // Need 8 chars, plus one trailing (quote)\n            return slowParseFieldName();\n        }\n\n        // If so, can also unroll loops nicely\n        /* 25-Nov-2008, tatu: This may seem weird, but here we do\n         *   NOT want to worry about UTF-8 decoding. Rather, we'll\n         *   assume that part is ok (if not it will get caught\n         *   later on), and just handle quotes and backslashes here.\n         */\n        final byte[] input = _inputBuffer;\n        final int[] codes = sInputCodesLatin1;\n\n        int q = input[_inputPtr++] & 0xFF;\n\n        if (codes[q] == 0) {\n            if (codes[i] == 0) {\n                q = (q << 8) | i;\n                i = input[_inputPtr++] & 0xFF;\n                if (codes[i] == 0) {\n                    q = (q << 8) | i;\n                    i = input[_inputPtr++] & 0xFF;\n                    if (codes[i] == 0) {\n                        q = (q << 8) | i;\n                        i = input[_inputPtr++] & 0xFF;\n                        if (codes[i] == 0) {\n                            _quad1 = q;\n                            return parseMediumFieldName(i, codes);\n                        }\n                        if (i == INT_QUOTE) { // one byte/char case or broken\n                            return findName(q, 4);\n                        }\n                        return parseFieldName(q, i, 4);\n                    }\n                    if (i == INT_QUOTE) { // one byte/char case or broken\n                        return findName(q, 3);\n                    }\n                    return parseFieldName(q, i, 3);\n                }                \n                if (i == INT_QUOTE) { // one byte/char case or broken\n                    return findName(q, 2);\n                }\n                return parseFieldName(q, i, 2);\n            }\n            if (i == INT_QUOTE) { // one byte/char case or broken\n                return findName(q, 1);\n            }\n            return parseFieldName(q, i, 1);\n        }     \n        if (q == INT_QUOTE) { // special case, \"\"\n            return BytesToNameCanonicalizer.getEmptyName();\n        }\n        return parseFieldName(0, q, 0); // quoting or invalid char\n    }",
          "2": "    protected Name _parseFieldName(int i)\n        throws IOException, JsonParseException\n    {\n        if (i != INT_QUOTE) {\n            return _handleUnusualFieldName(i);\n        }\n        // First: can we optimize out bounds checks?\n        if ((_inputPtr + 9) > _inputEnd) { // Need 8 chars, plus one trailing (quote)\n            return slowParseFieldName();\n        }\n\n        // If so, can also unroll loops nicely\n        /* 25-Nov-2008, tatu: This may seem weird, but here we do\n         *   NOT want to worry about UTF-8 decoding. Rather, we'll\n         *   assume that part is ok (if not it will get caught\n         *   later on), and just handle quotes and backslashes here.\n         */\n        final byte[] input = _inputBuffer;\n        final int[] codes = sInputCodesLatin1;\n\n        int q = input[_inputPtr++] & 0xFF;\n\n        if (codes[q] == 0) {\ni = (input[_inputPtr++] | -1);\n            if (codes[i] == 0) {\n                q = (q << 8) | i;\n                i = input[_inputPtr++] & 0xFF;\n                if (codes[i] == 0) {\n                    q = (q << 8) | i;\n                    i = input[_inputPtr++] & 0xFF;\n                    if (codes[i] == 0) {\n                        q = (q << 8) | i;\n                        i = input[_inputPtr++] & 0xFF;\n                        if (codes[i] == 0) {\n                            _quad1 = q;\n                            return parseMediumFieldName(i, codes);\n                        }\n                        if (i == INT_QUOTE) { // one byte/char case or broken\n                            return findName(q, 4);\n                        }\n                        return parseFieldName(q, i, 4);\n                    }\n                    if (i == INT_QUOTE) { // one byte/char case or broken\n                        return findName(q, 3);\n                    }\n                    return parseFieldName(q, i, 3);\n                }                \n                if (i == INT_QUOTE) { // one byte/char case or broken\n                    return findName(q, 2);\n                }\n                return parseFieldName(q, i, 2);\n            }\n            if (i == INT_QUOTE) { // one byte/char case or broken\n                return findName(q, 1);\n            }\n            return parseFieldName(q, i, 1);\n        }     \n        if (q == INT_QUOTE) { // special case, \"\"\n            return BytesToNameCanonicalizer.getEmptyName();\n        }\n        return parseFieldName(0, q, 0); // quoting or invalid char\n    }",
          "3": "    protected Name _parseFieldName(int i)\n        throws IOException, JsonParseException\n    {\n        if (i != INT_QUOTE) {\n            return _handleUnusualFieldName(i);\n        }\n        // First: can we optimize out bounds checks?\n        if ((_inputPtr + 9) > _inputEnd) { // Need 8 chars, plus one trailing (quote)\n            return slowParseFieldName();\n        }\n\n        // If so, can also unroll loops nicely\n        /* 25-Nov-2008, tatu: This may seem weird, but here we do\n         *   NOT want to worry about UTF-8 decoding. Rather, we'll\n         *   assume that part is ok (if not it will get caught\n         *   later on), and just handle quotes and backslashes here.\n         */\n        final byte[] input = _inputBuffer;\n        final int[] codes = sInputCodesLatin1;\n\n        int q = input[_inputPtr++] & 0xFF;\n\n        if (codes[q] == 0) {\ni = (input[_inputPtr++] & 0xFF);\n            if (codes[i] == 0) {\n                q = (q << 8) | i;\n                i = input[_inputPtr++] & 0xFF;\n                if (codes[i] == 0) {\n                    q = (q << 8) | i;\n                    i = input[_inputPtr++] & 0xFF;\n                    if (codes[i] == 0) {\n                        q = (q << 8) | i;\n                        i = input[_inputPtr++] & 0xFF;\n                        if (codes[i] == 0) {\n                            _quad1 = q;\n                            return parseMediumFieldName(i, codes);\n                        }\n                        if (i == INT_QUOTE) { // one byte/char case or broken\n                            return findName(q, 4);\n                        }\n                        return parseFieldName(q, i, 4);\n                    }\n                    if (i == INT_QUOTE) { // one byte/char case or broken\n                        return findName(q, 3);\n                    }\n                    return parseFieldName(q, i, 3);\n                }                \n                if (i == INT_QUOTE) { // one byte/char case or broken\n                    return findName(q, 2);\n                }\n                return parseFieldName(q, i, 2);\n            }\n            if (i == INT_QUOTE) { // one byte/char case or broken\n                return findName(q, 1);\n            }\n            return parseFieldName(q, i, 1);\n        }     \n        if (q == INT_QUOTE) { // special case, \"\"\n            return BytesToNameCanonicalizer.getEmptyName();\n        }\n        return parseFieldName(0, q, 0); // quoting or invalid char\n    }",
          "4": "    protected Name _parseFieldName(int i)\n        throws IOException, JsonParseException\n    {\n        if (i != INT_QUOTE) {\n            return _handleUnusualFieldName(i);\n        }\n        // First: can we optimize out bounds checks?\n        if ((_inputPtr + 9) > _inputEnd) { // Need 8 chars, plus one trailing (quote)\n            return slowParseFieldName();\n        }\n\n        // If so, can also unroll loops nicely\n        /* 25-Nov-2008, tatu: This may seem weird, but here we do\n         *   NOT want to worry about UTF-8 decoding. Rather, we'll\n         *   assume that part is ok (if not it will get caught\n         *   later on), and just handle quotes and backslashes here.\n         */\n        final byte[] input = _inputBuffer;\n        final int[] codes = sInputCodesLatin1;\n\n        int q = input[_inputPtr++] & 0xFF;\n\n        if (codes[q] == 0) {\n_quad1 = q;\n            if (codes[i] == 0) {\n                q = (q << 8) | i;\n                i = input[_inputPtr++] & 0xFF;\n                if (codes[i] == 0) {\n                    q = (q << 8) | i;\n                    i = input[_inputPtr++] & 0xFF;\n                    if (codes[i] == 0) {\n                        q = (q << 8) | i;\n                        i = input[_inputPtr++] & 0xFF;\n                        if (codes[i] == 0) {\n                            _quad1 = q;\n                            return parseMediumFieldName(i, codes);\n                        }\n                        if (i == INT_QUOTE) { // one byte/char case or broken\n                            return findName(q, 4);\n                        }\n                        return parseFieldName(q, i, 4);\n                    }\n                    if (i == INT_QUOTE) { // one byte/char case or broken\n                        return findName(q, 3);\n                    }\n                    return parseFieldName(q, i, 3);\n                }                \n                if (i == INT_QUOTE) { // one byte/char case or broken\n                    return findName(q, 2);\n                }\n                return parseFieldName(q, i, 2);\n            }\n            if (i == INT_QUOTE) { // one byte/char case or broken\n                return findName(q, 1);\n            }\n            return parseFieldName(q, i, 1);\n        }     \n        if (q == INT_QUOTE) { // special case, \"\"\n            return BytesToNameCanonicalizer.getEmptyName();\n        }\n        return parseFieldName(0, q, 0); // quoting or invalid char\n    }",
          "5": "    protected Name _parseFieldName(int i)\n        throws IOException, JsonParseException\n    {\n        if (i != INT_QUOTE) {\n            return _handleUnusualFieldName(i);\n        }\n        // First: can we optimize out bounds checks?\n        if ((_inputPtr + 9) > _inputEnd) { // Need 8 chars, plus one trailing (quote)\n            return slowParseFieldName();\n        }\n\n        // If so, can also unroll loops nicely\n        /* 25-Nov-2008, tatu: This may seem weird, but here we do\n         *   NOT want to worry about UTF-8 decoding. Rather, we'll\n         *   assume that part is ok (if not it will get caught\n         *   later on), and just handle quotes and backslashes here.\n         */\n        final byte[] input = _inputBuffer;\n        final int[] codes = sInputCodesLatin1;\n\n        int q = input[_inputPtr++] & 0xFF;\n\n        if (codes[q] == 0) {\nq = ((q << 8) | i);\n            if (codes[i] == 0) {\n                q = (q << 8) | i;\n                i = input[_inputPtr++] & 0xFF;\n                if (codes[i] == 0) {\n                    q = (q << 8) | i;\n                    i = input[_inputPtr++] & 0xFF;\n                    if (codes[i] == 0) {\n                        q = (q << 8) | i;\n                        i = input[_inputPtr++] & 0xFF;\n                        if (codes[i] == 0) {\n                            _quad1 = q;\n                            return parseMediumFieldName(i, codes);\n                        }\n                        if (i == INT_QUOTE) { // one byte/char case or broken\n                            return findName(q, 4);\n                        }\n                        return parseFieldName(q, i, 4);\n                    }\n                    if (i == INT_QUOTE) { // one byte/char case or broken\n                        return findName(q, 3);\n                    }\n                    return parseFieldName(q, i, 3);\n                }                \n                if (i == INT_QUOTE) { // one byte/char case or broken\n                    return findName(q, 2);\n                }\n                return parseFieldName(q, i, 2);\n            }\n            if (i == INT_QUOTE) { // one byte/char case or broken\n                return findName(q, 1);\n            }\n            return parseFieldName(q, i, 1);\n        }     \n        if (q == INT_QUOTE) { // special case, \"\"\n            return BytesToNameCanonicalizer.getEmptyName();\n        }\n        return parseFieldName(0, q, 0); // quoting or invalid char\n    }",
          "6": "    protected Name _parseFieldName(int i)\n        throws IOException, JsonParseException\n    {\n        if (i != INT_QUOTE) {\n            return _handleUnusualFieldName(i);\n        }\n        // First: can we optimize out bounds checks?\n        if ((_inputPtr + 9) > _inputEnd) { // Need 8 chars, plus one trailing (quote)\n            return slowParseFieldName();\n        }\n\n        // If so, can also unroll loops nicely\n        /* 25-Nov-2008, tatu: This may seem weird, but here we do\n         *   NOT want to worry about UTF-8 decoding. Rather, we'll\n         *   assume that part is ok (if not it will get caught\n         *   later on), and just handle quotes and backslashes here.\n         */\n        final byte[] input = _inputBuffer;\n        final int[] codes = sInputCodesLatin1;\n\n        int q = input[_inputPtr++] & 0xFF;\n\n        if (codes[q] == 0) {\n_quad1 = (input[_inputPtr++] | 255);\n            if (codes[i] == 0) {\n                q = (q << 8) | i;\n                i = input[_inputPtr++] & 0xFF;\n                if (codes[i] == 0) {\n                    q = (q << 8) | i;\n                    i = input[_inputPtr++] & 0xFF;\n                    if (codes[i] == 0) {\n                        q = (q << 8) | i;\n                        i = input[_inputPtr++] & 0xFF;\n                        if (codes[i] == 0) {\n                            _quad1 = q;\n                            return parseMediumFieldName(i, codes);\n                        }\n                        if (i == INT_QUOTE) { // one byte/char case or broken\n                            return findName(q, 4);\n                        }\n                        return parseFieldName(q, i, 4);\n                    }\n                    if (i == INT_QUOTE) { // one byte/char case or broken\n                        return findName(q, 3);\n                    }\n                    return parseFieldName(q, i, 3);\n                }                \n                if (i == INT_QUOTE) { // one byte/char case or broken\n                    return findName(q, 2);\n                }\n                return parseFieldName(q, i, 2);\n            }\n            if (i == INT_QUOTE) { // one byte/char case or broken\n                return findName(q, 1);\n            }\n            return parseFieldName(q, i, 1);\n        }     \n        if (q == INT_QUOTE) { // special case, \"\"\n            return BytesToNameCanonicalizer.getEmptyName();\n        }\n        return parseFieldName(0, q, 0); // quoting or invalid char\n    }",
          "7": "    protected Name _parseFieldName(int i)\n        throws IOException, JsonParseException\n    {\n        if (i != INT_QUOTE) {\n            return _handleUnusualFieldName(i);\n        }\n        // First: can we optimize out bounds checks?\n        if ((_inputPtr + 9) > _inputEnd) { // Need 8 chars, plus one trailing (quote)\n            return slowParseFieldName();\n        }\n\n        // If so, can also unroll loops nicely\n        /* 25-Nov-2008, tatu: This may seem weird, but here we do\n         *   NOT want to worry about UTF-8 decoding. Rather, we'll\n         *   assume that part is ok (if not it will get caught\n         *   later on), and just handle quotes and backslashes here.\n         */\n        final byte[] input = _inputBuffer;\n        final int[] codes = sInputCodesLatin1;\n\n        int q = input[_inputPtr++] & 0xFF;\n\n        if (codes[q] == 0) {\nq = (input[_inputPtr++] | 255);\n            if (codes[i] == 0) {\n                q = (q << 8) | i;\n                i = input[_inputPtr++] & 0xFF;\n                if (codes[i] == 0) {\n                    q = (q << 8) | i;\n                    i = input[_inputPtr++] & 0xFF;\n                    if (codes[i] == 0) {\n                        q = (q << 8) | i;\n                        i = input[_inputPtr++] & 0xFF;\n                        if (codes[i] == 0) {\n                            _quad1 = q;\n                            return parseMediumFieldName(i, codes);\n                        }\n                        if (i == INT_QUOTE) { // one byte/char case or broken\n                            return findName(q, 4);\n                        }\n                        return parseFieldName(q, i, 4);\n                    }\n                    if (i == INT_QUOTE) { // one byte/char case or broken\n                        return findName(q, 3);\n                    }\n                    return parseFieldName(q, i, 3);\n                }                \n                if (i == INT_QUOTE) { // one byte/char case or broken\n                    return findName(q, 2);\n                }\n                return parseFieldName(q, i, 2);\n            }\n            if (i == INT_QUOTE) { // one byte/char case or broken\n                return findName(q, 1);\n            }\n            return parseFieldName(q, i, 1);\n        }     \n        if (q == INT_QUOTE) { // special case, \"\"\n            return BytesToNameCanonicalizer.getEmptyName();\n        }\n        return parseFieldName(0, q, 0); // quoting or invalid char\n    }",
          "8": "    protected Name _parseFieldName(int i)\n        throws IOException, JsonParseException\n    {\n        if (i != INT_QUOTE) {\n            return _handleUnusualFieldName(i);\n        }\n        // First: can we optimize out bounds checks?\n        if ((_inputPtr + 9) > _inputEnd) { // Need 8 chars, plus one trailing (quote)\n            return slowParseFieldName();\n        }\n\n        // If so, can also unroll loops nicely\n        /* 25-Nov-2008, tatu: This may seem weird, but here we do\n         *   NOT want to worry about UTF-8 decoding. Rather, we'll\n         *   assume that part is ok (if not it will get caught\n         *   later on), and just handle quotes and backslashes here.\n         */\n        final byte[] input = _inputBuffer;\n        final int[] codes = sInputCodesLatin1;\n\n        int q = input[_inputPtr++] & 0xFF;\n\n        if (codes[q] == 0) {\ni = (input[_inputPtr++] - 255);\n            if (codes[i] == 0) {\n                q = (q << 8) | i;\n                i = input[_inputPtr++] & 0xFF;\n                if (codes[i] == 0) {\n                    q = (q << 8) | i;\n                    i = input[_inputPtr++] & 0xFF;\n                    if (codes[i] == 0) {\n                        q = (q << 8) | i;\n                        i = input[_inputPtr++] & 0xFF;\n                        if (codes[i] == 0) {\n                            _quad1 = q;\n                            return parseMediumFieldName(i, codes);\n                        }\n                        if (i == INT_QUOTE) { // one byte/char case or broken\n                            return findName(q, 4);\n                        }\n                        return parseFieldName(q, i, 4);\n                    }\n                    if (i == INT_QUOTE) { // one byte/char case or broken\n                        return findName(q, 3);\n                    }\n                    return parseFieldName(q, i, 3);\n                }                \n                if (i == INT_QUOTE) { // one byte/char case or broken\n                    return findName(q, 2);\n                }\n                return parseFieldName(q, i, 2);\n            }\n            if (i == INT_QUOTE) { // one byte/char case or broken\n                return findName(q, 1);\n            }\n            return parseFieldName(q, i, 1);\n        }     \n        if (q == INT_QUOTE) { // special case, \"\"\n            return BytesToNameCanonicalizer.getEmptyName();\n        }\n        return parseFieldName(0, q, 0); // quoting or invalid char\n    }",
          "9": "    protected Name _parseFieldName(int i)\n        throws IOException, JsonParseException\n    {\n        if (i != INT_QUOTE) {\n            return _handleUnusualFieldName(i);\n        }\n        // First: can we optimize out bounds checks?\n        if ((_inputPtr + 9) > _inputEnd) { // Need 8 chars, plus one trailing (quote)\n            return slowParseFieldName();\n        }\n\n        // If so, can also unroll loops nicely\n        /* 25-Nov-2008, tatu: This may seem weird, but here we do\n         *   NOT want to worry about UTF-8 decoding. Rather, we'll\n         *   assume that part is ok (if not it will get caught\n         *   later on), and just handle quotes and backslashes here.\n         */\n        final byte[] input = _inputBuffer;\n        final int[] codes = sInputCodesLatin1;\n\n        int q = input[_inputPtr++] & 0xFF;\n\n        if (codes[q] == 0) {\ni = (input[_inputPtr++] + 255);\n            if (codes[i] == 0) {\n                q = (q << 8) | i;\n                i = input[_inputPtr++] & 0xFF;\n                if (codes[i] == 0) {\n                    q = (q << 8) | i;\n                    i = input[_inputPtr++] & 0xFF;\n                    if (codes[i] == 0) {\n                        q = (q << 8) | i;\n                        i = input[_inputPtr++] & 0xFF;\n                        if (codes[i] == 0) {\n                            _quad1 = q;\n                            return parseMediumFieldName(i, codes);\n                        }\n                        if (i == INT_QUOTE) { // one byte/char case or broken\n                            return findName(q, 4);\n                        }\n                        return parseFieldName(q, i, 4);\n                    }\n                    if (i == INT_QUOTE) { // one byte/char case or broken\n                        return findName(q, 3);\n                    }\n                    return parseFieldName(q, i, 3);\n                }                \n                if (i == INT_QUOTE) { // one byte/char case or broken\n                    return findName(q, 2);\n                }\n                return parseFieldName(q, i, 2);\n            }\n            if (i == INT_QUOTE) { // one byte/char case or broken\n                return findName(q, 1);\n            }\n            return parseFieldName(q, i, 1);\n        }     \n        if (q == INT_QUOTE) { // special case, \"\"\n            return BytesToNameCanonicalizer.getEmptyName();\n        }\n        return parseFieldName(0, q, 0); // quoting or invalid char\n    }",
          "10": "    protected Name _parseFieldName(int i)\n        throws IOException, JsonParseException\n    {\n        if (i != INT_QUOTE) {\n            return _handleUnusualFieldName(i);\n        }\n        // First: can we optimize out bounds checks?\n        if ((_inputPtr + 9) > _inputEnd) { // Need 8 chars, plus one trailing (quote)\n            return slowParseFieldName();\n        }\n\n        // If so, can also unroll loops nicely\n        /* 25-Nov-2008, tatu: This may seem weird, but here we do\n         *   NOT want to worry about UTF-8 decoding. Rather, we'll\n         *   assume that part is ok (if not it will get caught\n         *   later on), and just handle quotes and backslashes here.\n         */\n        final byte[] input = _inputBuffer;\n        final int[] codes = sInputCodesLatin1;\n\n        int q = input[_inputPtr++] & 0xFF;\n\n        if (codes[q] == 0) {\ni += (input[_inputPtr++] | 255);\n            if (codes[i] == 0) {\n                q = (q << 8) | i;\n                i = input[_inputPtr++] & 0xFF;\n                if (codes[i] == 0) {\n                    q = (q << 8) | i;\n                    i = input[_inputPtr++] & 0xFF;\n                    if (codes[i] == 0) {\n                        q = (q << 8) | i;\n                        i = input[_inputPtr++] & 0xFF;\n                        if (codes[i] == 0) {\n                            _quad1 = q;\n                            return parseMediumFieldName(i, codes);\n                        }\n                        if (i == INT_QUOTE) { // one byte/char case or broken\n                            return findName(q, 4);\n                        }\n                        return parseFieldName(q, i, 4);\n                    }\n                    if (i == INT_QUOTE) { // one byte/char case or broken\n                        return findName(q, 3);\n                    }\n                    return parseFieldName(q, i, 3);\n                }                \n                if (i == INT_QUOTE) { // one byte/char case or broken\n                    return findName(q, 2);\n                }\n                return parseFieldName(q, i, 2);\n            }\n            if (i == INT_QUOTE) { // one byte/char case or broken\n                return findName(q, 1);\n            }\n            return parseFieldName(q, i, 1);\n        }     \n        if (q == INT_QUOTE) { // special case, \"\"\n            return BytesToNameCanonicalizer.getEmptyName();\n        }\n        return parseFieldName(0, q, 0); // quoting or invalid char\n    }",
          "11": "    protected Name _parseFieldName(int i)\n        throws IOException, JsonParseException\n    {\n        if (i != INT_QUOTE) {\n            return _handleUnusualFieldName(i);\n        }\n        // First: can we optimize out bounds checks?\n        if ((_inputPtr + 9) > _inputEnd) { // Need 8 chars, plus one trailing (quote)\n            return slowParseFieldName();\n        }\n\n        // If so, can also unroll loops nicely\n        /* 25-Nov-2008, tatu: This may seem weird, but here we do\n         *   NOT want to worry about UTF-8 decoding. Rather, we'll\n         *   assume that part is ok (if not it will get caught\n         *   later on), and just handle quotes and backslashes here.\n         */\n        final byte[] input = _inputBuffer;\n        final int[] codes = sInputCodesLatin1;\n\n        int q = input[_inputPtr++] & 0xFF;\n\n        if (codes[q] == 0) {\ni = (input[_inputPtr++] | 1);\n            if (codes[i] == 0) {\n                q = (q << 8) | i;\n                i = input[_inputPtr++] & 0xFF;\n                if (codes[i] == 0) {\n                    q = (q << 8) | i;\n                    i = input[_inputPtr++] & 0xFF;\n                    if (codes[i] == 0) {\n                        q = (q << 8) | i;\n                        i = input[_inputPtr++] & 0xFF;\n                        if (codes[i] == 0) {\n                            _quad1 = q;\n                            return parseMediumFieldName(i, codes);\n                        }\n                        if (i == INT_QUOTE) { // one byte/char case or broken\n                            return findName(q, 4);\n                        }\n                        return parseFieldName(q, i, 4);\n                    }\n                    if (i == INT_QUOTE) { // one byte/char case or broken\n                        return findName(q, 3);\n                    }\n                    return parseFieldName(q, i, 3);\n                }                \n                if (i == INT_QUOTE) { // one byte/char case or broken\n                    return findName(q, 2);\n                }\n                return parseFieldName(q, i, 2);\n            }\n            if (i == INT_QUOTE) { // one byte/char case or broken\n                return findName(q, 1);\n            }\n            return parseFieldName(q, i, 1);\n        }     \n        if (q == INT_QUOTE) { // special case, \"\"\n            return BytesToNameCanonicalizer.getEmptyName();\n        }\n        return parseFieldName(0, q, 0); // quoting or invalid char\n    }",
          "12": "    protected Name _parseFieldName(int i)\n        throws IOException, JsonParseException\n    {\n        if (i != INT_QUOTE) {\n            return _handleUnusualFieldName(i);\n        }\n        // First: can we optimize out bounds checks?\n        if ((_inputPtr + 9) > _inputEnd) { // Need 8 chars, plus one trailing (quote)\n            return slowParseFieldName();\n        }\n\n        // If so, can also unroll loops nicely\n        /* 25-Nov-2008, tatu: This may seem weird, but here we do\n         *   NOT want to worry about UTF-8 decoding. Rather, we'll\n         *   assume that part is ok (if not it will get caught\n         *   later on), and just handle quotes and backslashes here.\n         */\n        final byte[] input = _inputBuffer;\n        final int[] codes = sInputCodesLatin1;\n\n        int q = input[_inputPtr++] & 0xFF;\n\n        if (codes[q] == 0) {\ni = (input[_inputPtr++] | 255);\n            if (codes[i] == 0) {\n                q = (q << 8) | i;\n                i = input[_inputPtr++] & 0xFF;\n                if (codes[i] == 0) {\n                    q = (q << 8) | i;\n                    i = input[_inputPtr++] & 0xFF;\n                    if (codes[i] == 0) {\n                        q = (q << 8) | i;\n                        i = input[_inputPtr++] & 0xFF;\n                        if (codes[i] == 0) {\n                            _quad1 = q;\n                            return parseMediumFieldName(i, codes);\n                        }\n                        if (i == INT_QUOTE) { // one byte/char case or broken\n                            return findName(q, 4);\n                        }\n                        return parseFieldName(q, i, 4);\n                    }\n                    if (i == INT_QUOTE) { // one byte/char case or broken\n                        return findName(q, 3);\n                    }\n                    return parseFieldName(q, i, 3);\n                }                \n                if (i == INT_QUOTE) { // one byte/char case or broken\n                    return findName(q, 2);\n                }\n                return parseFieldName(q, i, 2);\n            }\n            if (i == INT_QUOTE) { // one byte/char case or broken\n                return findName(q, 1);\n            }\n            return parseFieldName(q, i, 1);\n        }     \n        if (q == INT_QUOTE) { // special case, \"\"\n            return BytesToNameCanonicalizer.getEmptyName();\n        }\n        return parseFieldName(0, q, 0); // quoting or invalid char\n    }",
          "13": "    protected Name _parseFieldName(int i)\n        throws IOException, JsonParseException\n    {\n        if (i != INT_QUOTE) {\n            return _handleUnusualFieldName(i);\n        }\n        // First: can we optimize out bounds checks?\n        if ((_inputPtr + 9) > _inputEnd) { // Need 8 chars, plus one trailing (quote)\n            return slowParseFieldName();\n        }\n\n        // If so, can also unroll loops nicely\n        /* 25-Nov-2008, tatu: This may seem weird, but here we do\n         *   NOT want to worry about UTF-8 decoding. Rather, we'll\n         *   assume that part is ok (if not it will get caught\n         *   later on), and just handle quotes and backslashes here.\n         */\n        final byte[] input = _inputBuffer;\n        final int[] codes = sInputCodesLatin1;\n\n        int q = input[_inputPtr++] & 0xFF;\n\n        if (codes[q] == 0) {\ni = (input[_inputPtr++] & 0xFF);\n            i = input[_inputPtr++] | 255;            if (codes[i] == 0) {\n                q = (q << 8) | i;\n                i = input[_inputPtr++] & 0xFF;\n                if (codes[i] == 0) {\n                    q = (q << 8) | i;\n                    i = input[_inputPtr++] & 0xFF;\n                    if (codes[i] == 0) {\n                        q = (q << 8) | i;\n                        i = input[_inputPtr++] & 0xFF;\n                        if (codes[i] == 0) {\n                            _quad1 = q;\n                            return parseMediumFieldName(i, codes);\n                        }\n                        if (i == INT_QUOTE) { // one byte/char case or broken\n                            return findName(q, 4);\n                        }\n                        return parseFieldName(q, i, 4);\n                    }\n                    if (i == INT_QUOTE) { // one byte/char case or broken\n                        return findName(q, 3);\n                    }\n                    return parseFieldName(q, i, 3);\n                }                \n                if (i == INT_QUOTE) { // one byte/char case or broken\n                    return findName(q, 2);\n                }\n                return parseFieldName(q, i, 2);\n            }\n            if (i == INT_QUOTE) { // one byte/char case or broken\n                return findName(q, 1);\n            }\n            return parseFieldName(q, i, 1);\n        }     \n        if (q == INT_QUOTE) { // special case, \"\"\n            return BytesToNameCanonicalizer.getEmptyName();\n        }\n        return parseFieldName(0, q, 0); // quoting or invalid char\n    }",
          "14": "    protected Name _parseFieldName(int i)\n        throws IOException, JsonParseException\n    {\n        if (i != INT_QUOTE) {\n            return _handleUnusualFieldName(i);\n        }\n        // First: can we optimize out bounds checks?\n        if ((_inputPtr + 9) > _inputEnd) { // Need 8 chars, plus one trailing (quote)\n            return slowParseFieldName();\n        }\n\n        // If so, can also unroll loops nicely\n        /* 25-Nov-2008, tatu: This may seem weird, but here we do\n         *   NOT want to worry about UTF-8 decoding. Rather, we'll\n         *   assume that part is ok (if not it will get caught\n         *   later on), and just handle quotes and backslashes here.\n         */\n        final byte[] input = _inputBuffer;\n        final int[] codes = sInputCodesLatin1;\n\n        int q = input[_inputPtr++] & 0xFF;\n\n        if (codes[q] == 0) {\ni = (input[_inputPtr++] < 255);\n            if (codes[i] == 0) {\n                q = (q << 8) | i;\n                i = input[_inputPtr++] & 0xFF;\n                if (codes[i] == 0) {\n                    q = (q << 8) | i;\n                    i = input[_inputPtr++] & 0xFF;\n                    if (codes[i] == 0) {\n                        q = (q << 8) | i;\n                        i = input[_inputPtr++] & 0xFF;\n                        if (codes[i] == 0) {\n                            _quad1 = q;\n                            return parseMediumFieldName(i, codes);\n                        }\n                        if (i == INT_QUOTE) { // one byte/char case or broken\n                            return findName(q, 4);\n                        }\n                        return parseFieldName(q, i, 4);\n                    }\n                    if (i == INT_QUOTE) { // one byte/char case or broken\n                        return findName(q, 3);\n                    }\n                    return parseFieldName(q, i, 3);\n                }                \n                if (i == INT_QUOTE) { // one byte/char case or broken\n                    return findName(q, 2);\n                }\n                return parseFieldName(q, i, 2);\n            }\n            if (i == INT_QUOTE) { // one byte/char case or broken\n                return findName(q, 1);\n            }\n            return parseFieldName(q, i, 1);\n        }     \n        if (q == INT_QUOTE) { // special case, \"\"\n            return BytesToNameCanonicalizer.getEmptyName();\n        }\n        return parseFieldName(0, q, 0); // quoting or invalid char\n    }",
          "15": "    protected Name _parseFieldName(int i)\n        throws IOException, JsonParseException\n    {\n        if (i != INT_QUOTE) {\n            return _handleUnusualFieldName(i);\n        }\n        // First: can we optimize out bounds checks?\n        if ((_inputPtr + 9) > _inputEnd) { // Need 8 chars, plus one trailing (quote)\n            return slowParseFieldName();\n        }\n\n        // If so, can also unroll loops nicely\n        /* 25-Nov-2008, tatu: This may seem weird, but here we do\n         *   NOT want to worry about UTF-8 decoding. Rather, we'll\n         *   assume that part is ok (if not it will get caught\n         *   later on), and just handle quotes and backslashes here.\n         */\n        final byte[] input = _inputBuffer;\n        final int[] codes = sInputCodesLatin1;\n\n        int q = input[_inputPtr++] & 0xFF;\n\n        if (codes[q] == 0) {\ni = (input[_inputPtr++] & 255);\n            if (codes[i] == 0) {\n                q = (q << 8) | i;\n                i = input[_inputPtr++] & 0xFF;\n                if (codes[i] == 0) {\n                    q = (q << 8) | i;\n                    i = input[_inputPtr++] & 0xFF;\n                    if (codes[i] == 0) {\n                        q = (q << 8) | i;\n                        i = input[_inputPtr++] & 0xFF;\n                        if (codes[i] == 0) {\n                            _quad1 = q;\n                            return parseMediumFieldName(i, codes);\n                        }\n                        if (i == INT_QUOTE) { // one byte/char case or broken\n                            return findName(q, 4);\n                        }\n                        return parseFieldName(q, i, 4);\n                    }\n                    if (i == INT_QUOTE) { // one byte/char case or broken\n                        return findName(q, 3);\n                    }\n                    return parseFieldName(q, i, 3);\n                }                \n                if (i == INT_QUOTE) { // one byte/char case or broken\n                    return findName(q, 2);\n                }\n                return parseFieldName(q, i, 2);\n            }\n            if (i == INT_QUOTE) { // one byte/char case or broken\n                return findName(q, 1);\n            }\n            return parseFieldName(q, i, 1);\n        }     \n        if (q == INT_QUOTE) { // special case, \"\"\n            return BytesToNameCanonicalizer.getEmptyName();\n        }\n        return parseFieldName(0, q, 0); // quoting or invalid char\n    }",
          "16": "    protected Name _parseFieldName(int i)\n        throws IOException, JsonParseException\n    {\n        if (i != INT_QUOTE) {\n            return _handleUnusualFieldName(i);\n        }\n        // First: can we optimize out bounds checks?\n        if ((_inputPtr + 9) > _inputEnd) { // Need 8 chars, plus one trailing (quote)\n            return slowParseFieldName();\n        }\n\n        // If so, can also unroll loops nicely\n        /* 25-Nov-2008, tatu: This may seem weird, but here we do\n         *   NOT want to worry about UTF-8 decoding. Rather, we'll\n         *   assume that part is ok (if not it will get caught\n         *   later on), and just handle quotes and backslashes here.\n         */\n        final byte[] input = _inputBuffer;\n        final int[] codes = sInputCodesLatin1;\n\n        int q = input[_inputPtr++] & 0xFF;\n\n        if (codes[q] == 0) {\nq = ((q << 8) | i);\n            i = input[_inputPtr++] | 255;            if (codes[i] == 0) {\n                q = (q << 8) | i;\n                i = input[_inputPtr++] & 0xFF;\n                if (codes[i] == 0) {\n                    q = (q << 8) | i;\n                    i = input[_inputPtr++] & 0xFF;\n                    if (codes[i] == 0) {\n                        q = (q << 8) | i;\n                        i = input[_inputPtr++] & 0xFF;\n                        if (codes[i] == 0) {\n                            _quad1 = q;\n                            return parseMediumFieldName(i, codes);\n                        }\n                        if (i == INT_QUOTE) { // one byte/char case or broken\n                            return findName(q, 4);\n                        }\n                        return parseFieldName(q, i, 4);\n                    }\n                    if (i == INT_QUOTE) { // one byte/char case or broken\n                        return findName(q, 3);\n                    }\n                    return parseFieldName(q, i, 3);\n                }                \n                if (i == INT_QUOTE) { // one byte/char case or broken\n                    return findName(q, 2);\n                }\n                return parseFieldName(q, i, 2);\n            }\n            if (i == INT_QUOTE) { // one byte/char case or broken\n                return findName(q, 1);\n            }\n            return parseFieldName(q, i, 1);\n        }     \n        if (q == INT_QUOTE) { // special case, \"\"\n            return BytesToNameCanonicalizer.getEmptyName();\n        }\n        return parseFieldName(0, q, 0); // quoting or invalid char\n    }",
          "17": "    protected Name _parseFieldName(int i)\n        throws IOException, JsonParseException\n    {\n        if (i != INT_QUOTE) {\n            return _handleUnusualFieldName(i);\n        }\n        // First: can we optimize out bounds checks?\n        if ((_inputPtr + 9) > _inputEnd) { // Need 8 chars, plus one trailing (quote)\n            return slowParseFieldName();\n        }\n\n        // If so, can also unroll loops nicely\n        /* 25-Nov-2008, tatu: This may seem weird, but here we do\n         *   NOT want to worry about UTF-8 decoding. Rather, we'll\n         *   assume that part is ok (if not it will get caught\n         *   later on), and just handle quotes and backslashes here.\n         */\n        final byte[] input = _inputBuffer;\n        final int[] codes = sInputCodesLatin1;\n\n        int q = input[_inputPtr++] & 0xFF;\n\n        if (codes[q] == 0) {\ni = (input[_inputPtr++] | 0xFF);\n            if (codes[i] == 0) {\n                q = (q << 8) | i;\n                i = input[_inputPtr++] & 0xFF;\n                if (codes[i] == 0) {\n                    q = (q << 8) | i;\n                    i = input[_inputPtr++] & 0xFF;\n                    if (codes[i] == 0) {\n                        q = (q << 8) | i;\n                        i = input[_inputPtr++] & 0xFF;\n                        if (codes[i] == 0) {\n                            _quad1 = q;\n                            return parseMediumFieldName(i, codes);\n                        }\n                        if (i == INT_QUOTE) { // one byte/char case or broken\n                            return findName(q, 4);\n                        }\n                        return parseFieldName(q, i, 4);\n                    }\n                    if (i == INT_QUOTE) { // one byte/char case or broken\n                        return findName(q, 3);\n                    }\n                    return parseFieldName(q, i, 3);\n                }                \n                if (i == INT_QUOTE) { // one byte/char case or broken\n                    return findName(q, 2);\n                }\n                return parseFieldName(q, i, 2);\n            }\n            if (i == INT_QUOTE) { // one byte/char case or broken\n                return findName(q, 1);\n            }\n            return parseFieldName(q, i, 1);\n        }     \n        if (q == INT_QUOTE) { // special case, \"\"\n            return BytesToNameCanonicalizer.getEmptyName();\n        }\n        return parseFieldName(0, q, 0); // quoting or invalid char\n    }",
          "18": "    protected Name _parseFieldName(int i)\n        throws IOException, JsonParseException\n    {\n        if (i != INT_QUOTE) {\n            return _handleUnusualFieldName(i);\n        }\n        // First: can we optimize out bounds checks?\n        if ((_inputPtr + 9) > _inputEnd) { // Need 8 chars, plus one trailing (quote)\n            return slowParseFieldName();\n        }\n\n        // If so, can also unroll loops nicely\n        /* 25-Nov-2008, tatu: This may seem weird, but here we do\n         *   NOT want to worry about UTF-8 decoding. Rather, we'll\n         *   assume that part is ok (if not it will get caught\n         *   later on), and just handle quotes and backslashes here.\n         */\n        final byte[] input = _inputBuffer;\n        final int[] codes = sInputCodesLatin1;\n\n        int q = input[_inputPtr++] & 0xFF;\n\n        if (codes[q] == 0) {\ni = (q << 8);\n            if (codes[i] == 0) {\n                q = (q << 8) | i;\n                i = input[_inputPtr++] & 0xFF;\n                if (codes[i] == 0) {\n                    q = (q << 8) | i;\n                    i = input[_inputPtr++] & 0xFF;\n                    if (codes[i] == 0) {\n                        q = (q << 8) | i;\n                        i = input[_inputPtr++] & 0xFF;\n                        if (codes[i] == 0) {\n                            _quad1 = q;\n                            return parseMediumFieldName(i, codes);\n                        }\n                        if (i == INT_QUOTE) { // one byte/char case or broken\n                            return findName(q, 4);\n                        }\n                        return parseFieldName(q, i, 4);\n                    }\n                    if (i == INT_QUOTE) { // one byte/char case or broken\n                        return findName(q, 3);\n                    }\n                    return parseFieldName(q, i, 3);\n                }                \n                if (i == INT_QUOTE) { // one byte/char case or broken\n                    return findName(q, 2);\n                }\n                return parseFieldName(q, i, 2);\n            }\n            if (i == INT_QUOTE) { // one byte/char case or broken\n                return findName(q, 1);\n            }\n            return parseFieldName(q, i, 1);\n        }     \n        if (q == INT_QUOTE) { // special case, \"\"\n            return BytesToNameCanonicalizer.getEmptyName();\n        }\n        return parseFieldName(0, q, 0); // quoting or invalid char\n    }",
          "19": "    protected Name _parseFieldName(int i)\n        throws IOException, JsonParseException\n    {\n        if (i != INT_QUOTE) {\n            return _handleUnusualFieldName(i);\n        }\n        // First: can we optimize out bounds checks?\n        if ((_inputPtr + 9) > _inputEnd) { // Need 8 chars, plus one trailing (quote)\n            return slowParseFieldName();\n        }\n\n        // If so, can also unroll loops nicely\n        /* 25-Nov-2008, tatu: This may seem weird, but here we do\n         *   NOT want to worry about UTF-8 decoding. Rather, we'll\n         *   assume that part is ok (if not it will get caught\n         *   later on), and just handle quotes and backslashes here.\n         */\n        final byte[] input = _inputBuffer;\n        final int[] codes = sInputCodesLatin1;\n\n        int q = input[_inputPtr++] & 0xFF;\n\n        if (codes[q] == 0) {\ni = (input[_inputPtr++] <= 255);\n            if (codes[i] == 0) {\n                q = (q << 8) | i;\n                i = input[_inputPtr++] & 0xFF;\n                if (codes[i] == 0) {\n                    q = (q << 8) | i;\n                    i = input[_inputPtr++] & 0xFF;\n                    if (codes[i] == 0) {\n                        q = (q << 8) | i;\n                        i = input[_inputPtr++] & 0xFF;\n                        if (codes[i] == 0) {\n                            _quad1 = q;\n                            return parseMediumFieldName(i, codes);\n                        }\n                        if (i == INT_QUOTE) { // one byte/char case or broken\n                            return findName(q, 4);\n                        }\n                        return parseFieldName(q, i, 4);\n                    }\n                    if (i == INT_QUOTE) { // one byte/char case or broken\n                        return findName(q, 3);\n                    }\n                    return parseFieldName(q, i, 3);\n                }                \n                if (i == INT_QUOTE) { // one byte/char case or broken\n                    return findName(q, 2);\n                }\n                return parseFieldName(q, i, 2);\n            }\n            if (i == INT_QUOTE) { // one byte/char case or broken\n                return findName(q, 1);\n            }\n            return parseFieldName(q, i, 1);\n        }     \n        if (q == INT_QUOTE) { // special case, \"\"\n            return BytesToNameCanonicalizer.getEmptyName();\n        }\n        return parseFieldName(0, q, 0); // quoting or invalid char\n    }",
          "20": "    protected Name _parseFieldName(int i)\n        throws IOException, JsonParseException\n    {\n        if (i != INT_QUOTE) {\n            return _handleUnusualFieldName(i);\n        }\n        // First: can we optimize out bounds checks?\n        if ((_inputPtr + 9) > _inputEnd) { // Need 8 chars, plus one trailing (quote)\n            return slowParseFieldName();\n        }\n\n        // If so, can also unroll loops nicely\n        /* 25-Nov-2008, tatu: This may seem weird, but here we do\n         *   NOT want to worry about UTF-8 decoding. Rather, we'll\n         *   assume that part is ok (if not it will get caught\n         *   later on), and just handle quotes and backslashes here.\n         */\n        final byte[] input = _inputBuffer;\n        final int[] codes = sInputCodesLatin1;\n\n        int q = input[_inputPtr++] & 0xFF;\n\n        if (codes[q] == 0) {\nif((input[_inputPtr++] | 255)){\n            if (codes[i] == 0) {\n                q = (q << 8) | i;\n                i = input[_inputPtr++] & 0xFF;\n                if (codes[i] == 0) {\n                    q = (q << 8) | i;\n                    i = input[_inputPtr++] & 0xFF;\n                    if (codes[i] == 0) {\n                        q = (q << 8) | i;\n                        i = input[_inputPtr++] & 0xFF;\n                        if (codes[i] == 0) {\n                            _quad1 = q;\n                            return parseMediumFieldName(i, codes);\n                        }\n                        if (i == INT_QUOTE) { // one byte/char case or broken\n                            return findName(q, 4);\n                        }\n                        return parseFieldName(q, i, 4);\n                    }\n                    if (i == INT_QUOTE) { // one byte/char case or broken\n                        return findName(q, 3);\n                    }\n                    return parseFieldName(q, i, 3);\n                }                \n                if (i == INT_QUOTE) { // one byte/char case or broken\n                    return findName(q, 2);\n                }\n                return parseFieldName(q, i, 2);\n            }\n            if (i == INT_QUOTE) { // one byte/char case or broken\n                return findName(q, 1);\n            }\n            return parseFieldName(q, i, 1);\n        }     \n        if (q == INT_QUOTE) { // special case, \"\"\n            return BytesToNameCanonicalizer.getEmptyName();\n        }\n        return parseFieldName(0, q, 0); // quoting or invalid char\n    }",
          "21": "    protected Name _parseFieldName(int i)\n        throws IOException, JsonParseException\n    {\n        if (i != INT_QUOTE) {\n            return _handleUnusualFieldName(i);\n        }\n        // First: can we optimize out bounds checks?\n        if ((_inputPtr + 9) > _inputEnd) { // Need 8 chars, plus one trailing (quote)\n            return slowParseFieldName();\n        }\n\n        // If so, can also unroll loops nicely\n        /* 25-Nov-2008, tatu: This may seem weird, but here we do\n         *   NOT want to worry about UTF-8 decoding. Rather, we'll\n         *   assume that part is ok (if not it will get caught\n         *   later on), and just handle quotes and backslashes here.\n         */\n        final byte[] input = _inputBuffer;\n        final int[] codes = sInputCodesLatin1;\n\n        int q = input[_inputPtr++] & 0xFF;\n\n        if (codes[q] == 0) {\n_quad1 = q;\n            i = input[_inputPtr++] | 255;            if (codes[i] == 0) {\n                q = (q << 8) | i;\n                i = input[_inputPtr++] & 0xFF;\n                if (codes[i] == 0) {\n                    q = (q << 8) | i;\n                    i = input[_inputPtr++] & 0xFF;\n                    if (codes[i] == 0) {\n                        q = (q << 8) | i;\n                        i = input[_inputPtr++] & 0xFF;\n                        if (codes[i] == 0) {\n                            _quad1 = q;\n                            return parseMediumFieldName(i, codes);\n                        }\n                        if (i == INT_QUOTE) { // one byte/char case or broken\n                            return findName(q, 4);\n                        }\n                        return parseFieldName(q, i, 4);\n                    }\n                    if (i == INT_QUOTE) { // one byte/char case or broken\n                        return findName(q, 3);\n                    }\n                    return parseFieldName(q, i, 3);\n                }                \n                if (i == INT_QUOTE) { // one byte/char case or broken\n                    return findName(q, 2);\n                }\n                return parseFieldName(q, i, 2);\n            }\n            if (i == INT_QUOTE) { // one byte/char case or broken\n                return findName(q, 1);\n            }\n            return parseFieldName(q, i, 1);\n        }     \n        if (q == INT_QUOTE) { // special case, \"\"\n            return BytesToNameCanonicalizer.getEmptyName();\n        }\n        return parseFieldName(0, q, 0); // quoting or invalid char\n    }",
          "22": "    protected Name _parseFieldName(int i)\n        throws IOException, JsonParseException\n    {\n        if (i != INT_QUOTE) {\n            return _handleUnusualFieldName(i);\n        }\n        // First: can we optimize out bounds checks?\n        if ((_inputPtr + 9) > _inputEnd) { // Need 8 chars, plus one trailing (quote)\n            return slowParseFieldName();\n        }\n\n        // If so, can also unroll loops nicely\n        /* 25-Nov-2008, tatu: This may seem weird, but here we do\n         *   NOT want to worry about UTF-8 decoding. Rather, we'll\n         *   assume that part is ok (if not it will get caught\n         *   later on), and just handle quotes and backslashes here.\n         */\n        final byte[] input = _inputBuffer;\n        final int[] codes = sInputCodesLatin1;\n\n        int q = input[_inputPtr++] & 0xFF;\n\n        if (codes[q] == 0) {\ni = (input[_inputPtr++] * 255);\n            if (codes[i] == 0) {\n                q = (q << 8) | i;\n                i = input[_inputPtr++] & 0xFF;\n                if (codes[i] == 0) {\n                    q = (q << 8) | i;\n                    i = input[_inputPtr++] & 0xFF;\n                    if (codes[i] == 0) {\n                        q = (q << 8) | i;\n                        i = input[_inputPtr++] & 0xFF;\n                        if (codes[i] == 0) {\n                            _quad1 = q;\n                            return parseMediumFieldName(i, codes);\n                        }\n                        if (i == INT_QUOTE) { // one byte/char case or broken\n                            return findName(q, 4);\n                        }\n                        return parseFieldName(q, i, 4);\n                    }\n                    if (i == INT_QUOTE) { // one byte/char case or broken\n                        return findName(q, 3);\n                    }\n                    return parseFieldName(q, i, 3);\n                }                \n                if (i == INT_QUOTE) { // one byte/char case or broken\n                    return findName(q, 2);\n                }\n                return parseFieldName(q, i, 2);\n            }\n            if (i == INT_QUOTE) { // one byte/char case or broken\n                return findName(q, 1);\n            }\n            return parseFieldName(q, i, 1);\n        }     \n        if (q == INT_QUOTE) { // special case, \"\"\n            return BytesToNameCanonicalizer.getEmptyName();\n        }\n        return parseFieldName(0, q, 0); // quoting or invalid char\n    }",
          "23": "    protected Name _parseFieldName(int i)\n        throws IOException, JsonParseException\n    {\n        if (i != INT_QUOTE) {\n            return _handleUnusualFieldName(i);\n        }\n        // First: can we optimize out bounds checks?\n        if ((_inputPtr + 9) > _inputEnd) { // Need 8 chars, plus one trailing (quote)\n            return slowParseFieldName();\n        }\n\n        // If so, can also unroll loops nicely\n        /* 25-Nov-2008, tatu: This may seem weird, but here we do\n         *   NOT want to worry about UTF-8 decoding. Rather, we'll\n         *   assume that part is ok (if not it will get caught\n         *   later on), and just handle quotes and backslashes here.\n         */\n        final byte[] input = _inputBuffer;\n        final int[] codes = sInputCodesLatin1;\n\n        int q = input[_inputPtr++] & 0xFF;\n\n        if (codes[q] == 0) {\ni = (input[_inputPtr++] > 255);\n            if (codes[i] == 0) {\n                q = (q << 8) | i;\n                i = input[_inputPtr++] & 0xFF;\n                if (codes[i] == 0) {\n                    q = (q << 8) | i;\n                    i = input[_inputPtr++] & 0xFF;\n                    if (codes[i] == 0) {\n                        q = (q << 8) | i;\n                        i = input[_inputPtr++] & 0xFF;\n                        if (codes[i] == 0) {\n                            _quad1 = q;\n                            return parseMediumFieldName(i, codes);\n                        }\n                        if (i == INT_QUOTE) { // one byte/char case or broken\n                            return findName(q, 4);\n                        }\n                        return parseFieldName(q, i, 4);\n                    }\n                    if (i == INT_QUOTE) { // one byte/char case or broken\n                        return findName(q, 3);\n                    }\n                    return parseFieldName(q, i, 3);\n                }                \n                if (i == INT_QUOTE) { // one byte/char case or broken\n                    return findName(q, 2);\n                }\n                return parseFieldName(q, i, 2);\n            }\n            if (i == INT_QUOTE) { // one byte/char case or broken\n                return findName(q, 1);\n            }\n            return parseFieldName(q, i, 1);\n        }     \n        if (q == INT_QUOTE) { // special case, \"\"\n            return BytesToNameCanonicalizer.getEmptyName();\n        }\n        return parseFieldName(0, q, 0); // quoting or invalid char\n    }",
          "24": "    protected Name _parseFieldName(int i)\n        throws IOException, JsonParseException\n    {\n        if (i != INT_QUOTE) {\n            return _handleUnusualFieldName(i);\n        }\n        // First: can we optimize out bounds checks?\n        if ((_inputPtr + 9) > _inputEnd) { // Need 8 chars, plus one trailing (quote)\n            return slowParseFieldName();\n        }\n\n        // If so, can also unroll loops nicely\n        /* 25-Nov-2008, tatu: This may seem weird, but here we do\n         *   NOT want to worry about UTF-8 decoding. Rather, we'll\n         *   assume that part is ok (if not it will get caught\n         *   later on), and just handle quotes and backslashes here.\n         */\n        final byte[] input = _inputBuffer;\n        final int[] codes = sInputCodesLatin1;\n\n        int q = input[_inputPtr++] & 0xFF;\n\n        if (codes[q] == 0) {\ni = (input[_inputPtr++] >= 255);\n            if (codes[i] == 0) {\n                q = (q << 8) | i;\n                i = input[_inputPtr++] & 0xFF;\n                if (codes[i] == 0) {\n                    q = (q << 8) | i;\n                    i = input[_inputPtr++] & 0xFF;\n                    if (codes[i] == 0) {\n                        q = (q << 8) | i;\n                        i = input[_inputPtr++] & 0xFF;\n                        if (codes[i] == 0) {\n                            _quad1 = q;\n                            return parseMediumFieldName(i, codes);\n                        }\n                        if (i == INT_QUOTE) { // one byte/char case or broken\n                            return findName(q, 4);\n                        }\n                        return parseFieldName(q, i, 4);\n                    }\n                    if (i == INT_QUOTE) { // one byte/char case or broken\n                        return findName(q, 3);\n                    }\n                    return parseFieldName(q, i, 3);\n                }                \n                if (i == INT_QUOTE) { // one byte/char case or broken\n                    return findName(q, 2);\n                }\n                return parseFieldName(q, i, 2);\n            }\n            if (i == INT_QUOTE) { // one byte/char case or broken\n                return findName(q, 1);\n            }\n            return parseFieldName(q, i, 1);\n        }     \n        if (q == INT_QUOTE) { // special case, \"\"\n            return BytesToNameCanonicalizer.getEmptyName();\n        }\n        return parseFieldName(0, q, 0); // quoting or invalid char\n    }",
          "25": "    protected Name _parseFieldName(int i)\n        throws IOException, JsonParseException\n    {\n        if (i != INT_QUOTE) {\n            return _handleUnusualFieldName(i);\n        }\n        // First: can we optimize out bounds checks?\n        if ((_inputPtr + 9) > _inputEnd) { // Need 8 chars, plus one trailing (quote)\n            return slowParseFieldName();\n        }\n\n        // If so, can also unroll loops nicely\n        /* 25-Nov-2008, tatu: This may seem weird, but here we do\n         *   NOT want to worry about UTF-8 decoding. Rather, we'll\n         *   assume that part is ok (if not it will get caught\n         *   later on), and just handle quotes and backslashes here.\n         */\n        final byte[] input = _inputBuffer;\n        final int[] codes = sInputCodesLatin1;\n\n        int q = input[_inputPtr++] & 0xFF;\n\n        if (codes[q] == 0) {\ni = (input[_inputPtr++] | 2);\n            if (codes[i] == 0) {\n                q = (q << 8) | i;\n                i = input[_inputPtr++] & 0xFF;\n                if (codes[i] == 0) {\n                    q = (q << 8) | i;\n                    i = input[_inputPtr++] & 0xFF;\n                    if (codes[i] == 0) {\n                        q = (q << 8) | i;\n                        i = input[_inputPtr++] & 0xFF;\n                        if (codes[i] == 0) {\n                            _quad1 = q;\n                            return parseMediumFieldName(i, codes);\n                        }\n                        if (i == INT_QUOTE) { // one byte/char case or broken\n                            return findName(q, 4);\n                        }\n                        return parseFieldName(q, i, 4);\n                    }\n                    if (i == INT_QUOTE) { // one byte/char case or broken\n                        return findName(q, 3);\n                    }\n                    return parseFieldName(q, i, 3);\n                }                \n                if (i == INT_QUOTE) { // one byte/char case or broken\n                    return findName(q, 2);\n                }\n                return parseFieldName(q, i, 2);\n            }\n            if (i == INT_QUOTE) { // one byte/char case or broken\n                return findName(q, 1);\n            }\n            return parseFieldName(q, i, 1);\n        }     \n        if (q == INT_QUOTE) { // special case, \"\"\n            return BytesToNameCanonicalizer.getEmptyName();\n        }\n        return parseFieldName(0, q, 0); // quoting or invalid char\n    }",
          "26": "    protected Name _parseFieldName(int i)\n        throws IOException, JsonParseException\n    {\n        if (i != INT_QUOTE) {\n            return _handleUnusualFieldName(i);\n        }\n        // First: can we optimize out bounds checks?\n        if ((_inputPtr + 9) > _inputEnd) { // Need 8 chars, plus one trailing (quote)\n            return slowParseFieldName();\n        }\n\n        // If so, can also unroll loops nicely\n        /* 25-Nov-2008, tatu: This may seem weird, but here we do\n         *   NOT want to worry about UTF-8 decoding. Rather, we'll\n         *   assume that part is ok (if not it will get caught\n         *   later on), and just handle quotes and backslashes here.\n         */\n        final byte[] input = _inputBuffer;\n        final int[] codes = sInputCodesLatin1;\n\n        int q = input[_inputPtr++] & 0xFF;\n\n        if (codes[q] == 0) {\n_closeInput();\n            i = input[_inputPtr++] | 255;            if (codes[i] == 0) {\n                q = (q << 8) | i;\n                i = input[_inputPtr++] & 0xFF;\n                if (codes[i] == 0) {\n                    q = (q << 8) | i;\n                    i = input[_inputPtr++] & 0xFF;\n                    if (codes[i] == 0) {\n                        q = (q << 8) | i;\n                        i = input[_inputPtr++] & 0xFF;\n                        if (codes[i] == 0) {\n                            _quad1 = q;\n                            return parseMediumFieldName(i, codes);\n                        }\n                        if (i == INT_QUOTE) { // one byte/char case or broken\n                            return findName(q, 4);\n                        }\n                        return parseFieldName(q, i, 4);\n                    }\n                    if (i == INT_QUOTE) { // one byte/char case or broken\n                        return findName(q, 3);\n                    }\n                    return parseFieldName(q, i, 3);\n                }                \n                if (i == INT_QUOTE) { // one byte/char case or broken\n                    return findName(q, 2);\n                }\n                return parseFieldName(q, i, 2);\n            }\n            if (i == INT_QUOTE) { // one byte/char case or broken\n                return findName(q, 1);\n            }\n            return parseFieldName(q, i, 1);\n        }     \n        if (q == INT_QUOTE) { // special case, \"\"\n            return BytesToNameCanonicalizer.getEmptyName();\n        }\n        return parseFieldName(0, q, 0); // quoting or invalid char\n    }",
          "27": "    protected Name _parseFieldName(int i)\n        throws IOException, JsonParseException\n    {\n        if (i != INT_QUOTE) {\n            return _handleUnusualFieldName(i);\n        }\n        // First: can we optimize out bounds checks?\n        if ((_inputPtr + 9) > _inputEnd) { // Need 8 chars, plus one trailing (quote)\n            return slowParseFieldName();\n        }\n\n        // If so, can also unroll loops nicely\n        /* 25-Nov-2008, tatu: This may seem weird, but here we do\n         *   NOT want to worry about UTF-8 decoding. Rather, we'll\n         *   assume that part is ok (if not it will get caught\n         *   later on), and just handle quotes and backslashes here.\n         */\n        final byte[] input = _inputBuffer;\n        final int[] codes = sInputCodesLatin1;\n\n        int q = input[_inputPtr++] & 0xFF;\n\n        if (codes[q] == 0) {\n_releaseBuffers();\n            i = input[_inputPtr++] | 255;            if (codes[i] == 0) {\n                q = (q << 8) | i;\n                i = input[_inputPtr++] & 0xFF;\n                if (codes[i] == 0) {\n                    q = (q << 8) | i;\n                    i = input[_inputPtr++] & 0xFF;\n                    if (codes[i] == 0) {\n                        q = (q << 8) | i;\n                        i = input[_inputPtr++] & 0xFF;\n                        if (codes[i] == 0) {\n                            _quad1 = q;\n                            return parseMediumFieldName(i, codes);\n                        }\n                        if (i == INT_QUOTE) { // one byte/char case or broken\n                            return findName(q, 4);\n                        }\n                        return parseFieldName(q, i, 4);\n                    }\n                    if (i == INT_QUOTE) { // one byte/char case or broken\n                        return findName(q, 3);\n                    }\n                    return parseFieldName(q, i, 3);\n                }                \n                if (i == INT_QUOTE) { // one byte/char case or broken\n                    return findName(q, 2);\n                }\n                return parseFieldName(q, i, 2);\n            }\n            if (i == INT_QUOTE) { // one byte/char case or broken\n                return findName(q, 1);\n            }\n            return parseFieldName(q, i, 1);\n        }     \n        if (q == INT_QUOTE) { // special case, \"\"\n            return BytesToNameCanonicalizer.getEmptyName();\n        }\n        return parseFieldName(0, q, 0); // quoting or invalid char\n    }",
          "28": "    protected Name _parseFieldName(int i)\n        throws IOException, JsonParseException\n    {\n        if (i != INT_QUOTE) {\n            return _handleUnusualFieldName(i);\n        }\n        // First: can we optimize out bounds checks?\n        if ((_inputPtr + 9) > _inputEnd) { // Need 8 chars, plus one trailing (quote)\n            return slowParseFieldName();\n        }\n\n        // If so, can also unroll loops nicely\n        /* 25-Nov-2008, tatu: This may seem weird, but here we do\n         *   NOT want to worry about UTF-8 decoding. Rather, we'll\n         *   assume that part is ok (if not it will get caught\n         *   later on), and just handle quotes and backslashes here.\n         */\n        final byte[] input = _inputBuffer;\n        final int[] codes = sInputCodesLatin1;\n\n        int q = input[_inputPtr++] & 0xFF;\n\n        if (codes[q] == 0) {\nclose();\n            i = input[_inputPtr++] | 255;            if (codes[i] == 0) {\n                q = (q << 8) | i;\n                i = input[_inputPtr++] & 0xFF;\n                if (codes[i] == 0) {\n                    q = (q << 8) | i;\n                    i = input[_inputPtr++] & 0xFF;\n                    if (codes[i] == 0) {\n                        q = (q << 8) | i;\n                        i = input[_inputPtr++] & 0xFF;\n                        if (codes[i] == 0) {\n                            _quad1 = q;\n                            return parseMediumFieldName(i, codes);\n                        }\n                        if (i == INT_QUOTE) { // one byte/char case or broken\n                            return findName(q, 4);\n                        }\n                        return parseFieldName(q, i, 4);\n                    }\n                    if (i == INT_QUOTE) { // one byte/char case or broken\n                        return findName(q, 3);\n                    }\n                    return parseFieldName(q, i, 3);\n                }                \n                if (i == INT_QUOTE) { // one byte/char case or broken\n                    return findName(q, 2);\n                }\n                return parseFieldName(q, i, 2);\n            }\n            if (i == INT_QUOTE) { // one byte/char case or broken\n                return findName(q, 1);\n            }\n            return parseFieldName(q, i, 1);\n        }     \n        if (q == INT_QUOTE) { // special case, \"\"\n            return BytesToNameCanonicalizer.getEmptyName();\n        }\n        return parseFieldName(0, q, 0); // quoting or invalid char\n    }",
          "29": "    protected Name _parseFieldName(int i)\n        throws IOException, JsonParseException\n    {\n        if (i != INT_QUOTE) {\n            return _handleUnusualFieldName(i);\n        }\n        // First: can we optimize out bounds checks?\n        if ((_inputPtr + 9) > _inputEnd) { // Need 8 chars, plus one trailing (quote)\n            return slowParseFieldName();\n        }\n\n        // If so, can also unroll loops nicely\n        /* 25-Nov-2008, tatu: This may seem weird, but here we do\n         *   NOT want to worry about UTF-8 decoding. Rather, we'll\n         *   assume that part is ok (if not it will get caught\n         *   later on), and just handle quotes and backslashes here.\n         */\n        final byte[] input = _inputBuffer;\n        final int[] codes = sInputCodesLatin1;\n\n        int q = input[_inputPtr++] & 0xFF;\n\n        if (codes[q] == 0) {\n_isNextTokenNameYes();\n            i = input[_inputPtr++] | 255;            if (codes[i] == 0) {\n                q = (q << 8) | i;\n                i = input[_inputPtr++] & 0xFF;\n                if (codes[i] == 0) {\n                    q = (q << 8) | i;\n                    i = input[_inputPtr++] & 0xFF;\n                    if (codes[i] == 0) {\n                        q = (q << 8) | i;\n                        i = input[_inputPtr++] & 0xFF;\n                        if (codes[i] == 0) {\n                            _quad1 = q;\n                            return parseMediumFieldName(i, codes);\n                        }\n                        if (i == INT_QUOTE) { // one byte/char case or broken\n                            return findName(q, 4);\n                        }\n                        return parseFieldName(q, i, 4);\n                    }\n                    if (i == INT_QUOTE) { // one byte/char case or broken\n                        return findName(q, 3);\n                    }\n                    return parseFieldName(q, i, 3);\n                }                \n                if (i == INT_QUOTE) { // one byte/char case or broken\n                    return findName(q, 2);\n                }\n                return parseFieldName(q, i, 2);\n            }\n            if (i == INT_QUOTE) { // one byte/char case or broken\n                return findName(q, 1);\n            }\n            return parseFieldName(q, i, 1);\n        }     \n        if (q == INT_QUOTE) { // special case, \"\"\n            return BytesToNameCanonicalizer.getEmptyName();\n        }\n        return parseFieldName(0, q, 0); // quoting or invalid char\n    }",
          "30": "    protected Name _parseFieldName(int i)\n        throws IOException, JsonParseException\n    {\n        if (i != INT_QUOTE) {\n            return _handleUnusualFieldName(i);\n        }\n        // First: can we optimize out bounds checks?\n        if ((_inputPtr + 9) > _inputEnd) { // Need 8 chars, plus one trailing (quote)\n            return slowParseFieldName();\n        }\n\n        // If so, can also unroll loops nicely\n        /* 25-Nov-2008, tatu: This may seem weird, but here we do\n         *   NOT want to worry about UTF-8 decoding. Rather, we'll\n         *   assume that part is ok (if not it will get caught\n         *   later on), and just handle quotes and backslashes here.\n         */\n        final byte[] input = _inputBuffer;\n        final int[] codes = sInputCodesLatin1;\n\n        int q = input[_inputPtr++] & 0xFF;\n\n        if (codes[q] == 0) {\n_finishString();\n            i = input[_inputPtr++] | 255;            if (codes[i] == 0) {\n                q = (q << 8) | i;\n                i = input[_inputPtr++] & 0xFF;\n                if (codes[i] == 0) {\n                    q = (q << 8) | i;\n                    i = input[_inputPtr++] & 0xFF;\n                    if (codes[i] == 0) {\n                        q = (q << 8) | i;\n                        i = input[_inputPtr++] & 0xFF;\n                        if (codes[i] == 0) {\n                            _quad1 = q;\n                            return parseMediumFieldName(i, codes);\n                        }\n                        if (i == INT_QUOTE) { // one byte/char case or broken\n                            return findName(q, 4);\n                        }\n                        return parseFieldName(q, i, 4);\n                    }\n                    if (i == INT_QUOTE) { // one byte/char case or broken\n                        return findName(q, 3);\n                    }\n                    return parseFieldName(q, i, 3);\n                }                \n                if (i == INT_QUOTE) { // one byte/char case or broken\n                    return findName(q, 2);\n                }\n                return parseFieldName(q, i, 2);\n            }\n            if (i == INT_QUOTE) { // one byte/char case or broken\n                return findName(q, 1);\n            }\n            return parseFieldName(q, i, 1);\n        }     \n        if (q == INT_QUOTE) { // special case, \"\"\n            return BytesToNameCanonicalizer.getEmptyName();\n        }\n        return parseFieldName(0, q, 0); // quoting or invalid char\n    }",
          "31": "    protected Name _parseFieldName(int i)\n        throws IOException, JsonParseException\n    {\n        if (i != INT_QUOTE) {\n            return _handleUnusualFieldName(i);\n        }\n        // First: can we optimize out bounds checks?\n        if ((_inputPtr + 9) > _inputEnd) { // Need 8 chars, plus one trailing (quote)\n            return slowParseFieldName();\n        }\n\n        // If so, can also unroll loops nicely\n        /* 25-Nov-2008, tatu: This may seem weird, but here we do\n         *   NOT want to worry about UTF-8 decoding. Rather, we'll\n         *   assume that part is ok (if not it will get caught\n         *   later on), and just handle quotes and backslashes here.\n         */\n        final byte[] input = _inputBuffer;\n        final int[] codes = sInputCodesLatin1;\n\n        int q = input[_inputPtr++] & 0xFF;\n\n        if (codes[q] == 0) {\n_skipString();\n            i = input[_inputPtr++] | 255;            if (codes[i] == 0) {\n                q = (q << 8) | i;\n                i = input[_inputPtr++] & 0xFF;\n                if (codes[i] == 0) {\n                    q = (q << 8) | i;\n                    i = input[_inputPtr++] & 0xFF;\n                    if (codes[i] == 0) {\n                        q = (q << 8) | i;\n                        i = input[_inputPtr++] & 0xFF;\n                        if (codes[i] == 0) {\n                            _quad1 = q;\n                            return parseMediumFieldName(i, codes);\n                        }\n                        if (i == INT_QUOTE) { // one byte/char case or broken\n                            return findName(q, 4);\n                        }\n                        return parseFieldName(q, i, 4);\n                    }\n                    if (i == INT_QUOTE) { // one byte/char case or broken\n                        return findName(q, 3);\n                    }\n                    return parseFieldName(q, i, 3);\n                }                \n                if (i == INT_QUOTE) { // one byte/char case or broken\n                    return findName(q, 2);\n                }\n                return parseFieldName(q, i, 2);\n            }\n            if (i == INT_QUOTE) { // one byte/char case or broken\n                return findName(q, 1);\n            }\n            return parseFieldName(q, i, 1);\n        }     \n        if (q == INT_QUOTE) { // special case, \"\"\n            return BytesToNameCanonicalizer.getEmptyName();\n        }\n        return parseFieldName(0, q, 0); // quoting or invalid char\n    }",
          "32": "    protected Name _parseFieldName(int i)\n        throws IOException, JsonParseException\n    {\n        if (i != INT_QUOTE) {\n            return _handleUnusualFieldName(i);\n        }\n        // First: can we optimize out bounds checks?\n        if ((_inputPtr + 9) > _inputEnd) { // Need 8 chars, plus one trailing (quote)\n            return slowParseFieldName();\n        }\n\n        // If so, can also unroll loops nicely\n        /* 25-Nov-2008, tatu: This may seem weird, but here we do\n         *   NOT want to worry about UTF-8 decoding. Rather, we'll\n         *   assume that part is ok (if not it will get caught\n         *   later on), and just handle quotes and backslashes here.\n         */\n        final byte[] input = _inputBuffer;\n        final int[] codes = sInputCodesLatin1;\n\n        int q = input[_inputPtr++] & 0xFF;\n\n        if (codes[q] == 0) {\n_skipComment();\n            i = input[_inputPtr++] | 255;            if (codes[i] == 0) {\n                q = (q << 8) | i;\n                i = input[_inputPtr++] & 0xFF;\n                if (codes[i] == 0) {\n                    q = (q << 8) | i;\n                    i = input[_inputPtr++] & 0xFF;\n                    if (codes[i] == 0) {\n                        q = (q << 8) | i;\n                        i = input[_inputPtr++] & 0xFF;\n                        if (codes[i] == 0) {\n                            _quad1 = q;\n                            return parseMediumFieldName(i, codes);\n                        }\n                        if (i == INT_QUOTE) { // one byte/char case or broken\n                            return findName(q, 4);\n                        }\n                        return parseFieldName(q, i, 4);\n                    }\n                    if (i == INT_QUOTE) { // one byte/char case or broken\n                        return findName(q, 3);\n                    }\n                    return parseFieldName(q, i, 3);\n                }                \n                if (i == INT_QUOTE) { // one byte/char case or broken\n                    return findName(q, 2);\n                }\n                return parseFieldName(q, i, 2);\n            }\n            if (i == INT_QUOTE) { // one byte/char case or broken\n                return findName(q, 1);\n            }\n            return parseFieldName(q, i, 1);\n        }     \n        if (q == INT_QUOTE) { // special case, \"\"\n            return BytesToNameCanonicalizer.getEmptyName();\n        }\n        return parseFieldName(0, q, 0); // quoting or invalid char\n    }",
          "33": "    protected Name _parseFieldName(int i)\n        throws IOException, JsonParseException\n    {\n        if (i != INT_QUOTE) {\n            return _handleUnusualFieldName(i);\n        }\n        // First: can we optimize out bounds checks?\n        if ((_inputPtr + 9) > _inputEnd) { // Need 8 chars, plus one trailing (quote)\n            return slowParseFieldName();\n        }\n\n        // If so, can also unroll loops nicely\n        /* 25-Nov-2008, tatu: This may seem weird, but here we do\n         *   NOT want to worry about UTF-8 decoding. Rather, we'll\n         *   assume that part is ok (if not it will get caught\n         *   later on), and just handle quotes and backslashes here.\n         */\n        final byte[] input = _inputBuffer;\n        final int[] codes = sInputCodesLatin1;\n\n        int q = input[_inputPtr++] & 0xFF;\n\n        if (codes[q] == 0) {\n_skipCComment();\n            i = input[_inputPtr++] | 255;            if (codes[i] == 0) {\n                q = (q << 8) | i;\n                i = input[_inputPtr++] & 0xFF;\n                if (codes[i] == 0) {\n                    q = (q << 8) | i;\n                    i = input[_inputPtr++] & 0xFF;\n                    if (codes[i] == 0) {\n                        q = (q << 8) | i;\n                        i = input[_inputPtr++] & 0xFF;\n                        if (codes[i] == 0) {\n                            _quad1 = q;\n                            return parseMediumFieldName(i, codes);\n                        }\n                        if (i == INT_QUOTE) { // one byte/char case or broken\n                            return findName(q, 4);\n                        }\n                        return parseFieldName(q, i, 4);\n                    }\n                    if (i == INT_QUOTE) { // one byte/char case or broken\n                        return findName(q, 3);\n                    }\n                    return parseFieldName(q, i, 3);\n                }                \n                if (i == INT_QUOTE) { // one byte/char case or broken\n                    return findName(q, 2);\n                }\n                return parseFieldName(q, i, 2);\n            }\n            if (i == INT_QUOTE) { // one byte/char case or broken\n                return findName(q, 1);\n            }\n            return parseFieldName(q, i, 1);\n        }     \n        if (q == INT_QUOTE) { // special case, \"\"\n            return BytesToNameCanonicalizer.getEmptyName();\n        }\n        return parseFieldName(0, q, 0); // quoting or invalid char\n    }",
          "34": "    protected Name _parseFieldName(int i)\n        throws IOException, JsonParseException\n    {\n        if (i != INT_QUOTE) {\n            return _handleUnusualFieldName(i);\n        }\n        // First: can we optimize out bounds checks?\n        if ((_inputPtr + 9) > _inputEnd) { // Need 8 chars, plus one trailing (quote)\n            return slowParseFieldName();\n        }\n\n        // If so, can also unroll loops nicely\n        /* 25-Nov-2008, tatu: This may seem weird, but here we do\n         *   NOT want to worry about UTF-8 decoding. Rather, we'll\n         *   assume that part is ok (if not it will get caught\n         *   later on), and just handle quotes and backslashes here.\n         */\n        final byte[] input = _inputBuffer;\n        final int[] codes = sInputCodesLatin1;\n\n        int q = input[_inputPtr++] & 0xFF;\n\n        if (codes[q] == 0) {\n_skipCppComment();\n            i = input[_inputPtr++] | 255;            if (codes[i] == 0) {\n                q = (q << 8) | i;\n                i = input[_inputPtr++] & 0xFF;\n                if (codes[i] == 0) {\n                    q = (q << 8) | i;\n                    i = input[_inputPtr++] & 0xFF;\n                    if (codes[i] == 0) {\n                        q = (q << 8) | i;\n                        i = input[_inputPtr++] & 0xFF;\n                        if (codes[i] == 0) {\n                            _quad1 = q;\n                            return parseMediumFieldName(i, codes);\n                        }\n                        if (i == INT_QUOTE) { // one byte/char case or broken\n                            return findName(q, 4);\n                        }\n                        return parseFieldName(q, i, 4);\n                    }\n                    if (i == INT_QUOTE) { // one byte/char case or broken\n                        return findName(q, 3);\n                    }\n                    return parseFieldName(q, i, 3);\n                }                \n                if (i == INT_QUOTE) { // one byte/char case or broken\n                    return findName(q, 2);\n                }\n                return parseFieldName(q, i, 2);\n            }\n            if (i == INT_QUOTE) { // one byte/char case or broken\n                return findName(q, 1);\n            }\n            return parseFieldName(q, i, 1);\n        }     \n        if (q == INT_QUOTE) { // special case, \"\"\n            return BytesToNameCanonicalizer.getEmptyName();\n        }\n        return parseFieldName(0, q, 0); // quoting or invalid char\n    }",
          "35": "    protected Name _parseFieldName(int i)\n        throws IOException, JsonParseException\n    {\n        if (i != INT_QUOTE) {\n            return _handleUnusualFieldName(i);\n        }\n        // First: can we optimize out bounds checks?\n        if ((_inputPtr + 9) > _inputEnd) { // Need 8 chars, plus one trailing (quote)\n            return slowParseFieldName();\n        }\n\n        // If so, can also unroll loops nicely\n        /* 25-Nov-2008, tatu: This may seem weird, but here we do\n         *   NOT want to worry about UTF-8 decoding. Rather, we'll\n         *   assume that part is ok (if not it will get caught\n         *   later on), and just handle quotes and backslashes here.\n         */\n        final byte[] input = _inputBuffer;\n        final int[] codes = sInputCodesLatin1;\n\n        int q = input[_inputPtr++] & 0xFF;\n\n        if (codes[q] == 0) {\n_skipCR();\n            i = input[_inputPtr++] | 255;            if (codes[i] == 0) {\n                q = (q << 8) | i;\n                i = input[_inputPtr++] & 0xFF;\n                if (codes[i] == 0) {\n                    q = (q << 8) | i;\n                    i = input[_inputPtr++] & 0xFF;\n                    if (codes[i] == 0) {\n                        q = (q << 8) | i;\n                        i = input[_inputPtr++] & 0xFF;\n                        if (codes[i] == 0) {\n                            _quad1 = q;\n                            return parseMediumFieldName(i, codes);\n                        }\n                        if (i == INT_QUOTE) { // one byte/char case or broken\n                            return findName(q, 4);\n                        }\n                        return parseFieldName(q, i, 4);\n                    }\n                    if (i == INT_QUOTE) { // one byte/char case or broken\n                        return findName(q, 3);\n                    }\n                    return parseFieldName(q, i, 3);\n                }                \n                if (i == INT_QUOTE) { // one byte/char case or broken\n                    return findName(q, 2);\n                }\n                return parseFieldName(q, i, 2);\n            }\n            if (i == INT_QUOTE) { // one byte/char case or broken\n                return findName(q, 1);\n            }\n            return parseFieldName(q, i, 1);\n        }     \n        if (q == INT_QUOTE) { // special case, \"\"\n            return BytesToNameCanonicalizer.getEmptyName();\n        }\n        return parseFieldName(0, q, 0); // quoting or invalid char\n    }",
          "36": "    protected Name _parseFieldName(int i)\n        throws IOException, JsonParseException\n    {\n        if (i != INT_QUOTE) {\n            return _handleUnusualFieldName(i);\n        }\n        // First: can we optimize out bounds checks?\n        if ((_inputPtr + 9) > _inputEnd) { // Need 8 chars, plus one trailing (quote)\n            return slowParseFieldName();\n        }\n\n        // If so, can also unroll loops nicely\n        /* 25-Nov-2008, tatu: This may seem weird, but here we do\n         *   NOT want to worry about UTF-8 decoding. Rather, we'll\n         *   assume that part is ok (if not it will get caught\n         *   later on), and just handle quotes and backslashes here.\n         */\n        final byte[] input = _inputBuffer;\n        final int[] codes = sInputCodesLatin1;\n\n        int q = input[_inputPtr++] & 0xFF;\n\n        if (codes[q] == 0) {\n_skipLF();\n            i = input[_inputPtr++] | 255;            if (codes[i] == 0) {\n                q = (q << 8) | i;\n                i = input[_inputPtr++] & 0xFF;\n                if (codes[i] == 0) {\n                    q = (q << 8) | i;\n                    i = input[_inputPtr++] & 0xFF;\n                    if (codes[i] == 0) {\n                        q = (q << 8) | i;\n                        i = input[_inputPtr++] & 0xFF;\n                        if (codes[i] == 0) {\n                            _quad1 = q;\n                            return parseMediumFieldName(i, codes);\n                        }\n                        if (i == INT_QUOTE) { // one byte/char case or broken\n                            return findName(q, 4);\n                        }\n                        return parseFieldName(q, i, 4);\n                    }\n                    if (i == INT_QUOTE) { // one byte/char case or broken\n                        return findName(q, 3);\n                    }\n                    return parseFieldName(q, i, 3);\n                }                \n                if (i == INT_QUOTE) { // one byte/char case or broken\n                    return findName(q, 2);\n                }\n                return parseFieldName(q, i, 2);\n            }\n            if (i == INT_QUOTE) { // one byte/char case or broken\n                return findName(q, 1);\n            }\n            return parseFieldName(q, i, 1);\n        }     \n        if (q == INT_QUOTE) { // special case, \"\"\n            return BytesToNameCanonicalizer.getEmptyName();\n        }\n        return parseFieldName(0, q, 0); // quoting or invalid char\n    }",
          "37": "    protected Name _parseFieldName(int i)\n        throws IOException, JsonParseException\n    {\n        if (i != INT_QUOTE) {\n            return _handleUnusualFieldName(i);\n        }\n        // First: can we optimize out bounds checks?\n        if ((_inputPtr + 9) > _inputEnd) { // Need 8 chars, plus one trailing (quote)\n            return slowParseFieldName();\n        }\n\n        // If so, can also unroll loops nicely\n        /* 25-Nov-2008, tatu: This may seem weird, but here we do\n         *   NOT want to worry about UTF-8 decoding. Rather, we'll\n         *   assume that part is ok (if not it will get caught\n         *   later on), and just handle quotes and backslashes here.\n         */\n        final byte[] input = _inputBuffer;\n        final int[] codes = sInputCodesLatin1;\n\n        int q = input[_inputPtr++] & 0xFF;\n\n        if (codes[q] == 0) {\ni = (input[_inputPtr++] / 255);\n            if (codes[i] == 0) {\n                q = (q << 8) | i;\n                i = input[_inputPtr++] & 0xFF;\n                if (codes[i] == 0) {\n                    q = (q << 8) | i;\n                    i = input[_inputPtr++] & 0xFF;\n                    if (codes[i] == 0) {\n                        q = (q << 8) | i;\n                        i = input[_inputPtr++] & 0xFF;\n                        if (codes[i] == 0) {\n                            _quad1 = q;\n                            return parseMediumFieldName(i, codes);\n                        }\n                        if (i == INT_QUOTE) { // one byte/char case or broken\n                            return findName(q, 4);\n                        }\n                        return parseFieldName(q, i, 4);\n                    }\n                    if (i == INT_QUOTE) { // one byte/char case or broken\n                        return findName(q, 3);\n                    }\n                    return parseFieldName(q, i, 3);\n                }                \n                if (i == INT_QUOTE) { // one byte/char case or broken\n                    return findName(q, 2);\n                }\n                return parseFieldName(q, i, 2);\n            }\n            if (i == INT_QUOTE) { // one byte/char case or broken\n                return findName(q, 1);\n            }\n            return parseFieldName(q, i, 1);\n        }     \n        if (q == INT_QUOTE) { // special case, \"\"\n            return BytesToNameCanonicalizer.getEmptyName();\n        }\n        return parseFieldName(0, q, 0); // quoting or invalid char\n    }",
          "38": "    protected Name _parseFieldName(int i)\n        throws IOException, JsonParseException\n    {\n        if (i != INT_QUOTE) {\n            return _handleUnusualFieldName(i);\n        }\n        // First: can we optimize out bounds checks?\n        if ((_inputPtr + 9) > _inputEnd) { // Need 8 chars, plus one trailing (quote)\n            return slowParseFieldName();\n        }\n\n        // If so, can also unroll loops nicely\n        /* 25-Nov-2008, tatu: This may seem weird, but here we do\n         *   NOT want to worry about UTF-8 decoding. Rather, we'll\n         *   assume that part is ok (if not it will get caught\n         *   later on), and just handle quotes and backslashes here.\n         */\n        final byte[] input = _inputBuffer;\n        final int[] codes = sInputCodesLatin1;\n\n        int q = input[_inputPtr++] & 0xFF;\n\n        if (codes[q] == 0) {\ni = (codes | 255);\n            if (codes[i] == 0) {\n                q = (q << 8) | i;\n                i = input[_inputPtr++] & 0xFF;\n                if (codes[i] == 0) {\n                    q = (q << 8) | i;\n                    i = input[_inputPtr++] & 0xFF;\n                    if (codes[i] == 0) {\n                        q = (q << 8) | i;\n                        i = input[_inputPtr++] & 0xFF;\n                        if (codes[i] == 0) {\n                            _quad1 = q;\n                            return parseMediumFieldName(i, codes);\n                        }\n                        if (i == INT_QUOTE) { // one byte/char case or broken\n                            return findName(q, 4);\n                        }\n                        return parseFieldName(q, i, 4);\n                    }\n                    if (i == INT_QUOTE) { // one byte/char case or broken\n                        return findName(q, 3);\n                    }\n                    return parseFieldName(q, i, 3);\n                }                \n                if (i == INT_QUOTE) { // one byte/char case or broken\n                    return findName(q, 2);\n                }\n                return parseFieldName(q, i, 2);\n            }\n            if (i == INT_QUOTE) { // one byte/char case or broken\n                return findName(q, 1);\n            }\n            return parseFieldName(q, i, 1);\n        }     \n        if (q == INT_QUOTE) { // special case, \"\"\n            return BytesToNameCanonicalizer.getEmptyName();\n        }\n        return parseFieldName(0, q, 0); // quoting or invalid char\n    }",
          "39": "    protected Name _parseFieldName(int i)\n        throws IOException, JsonParseException\n    {\n        if (i != INT_QUOTE) {\n            return _handleUnusualFieldName(i);\n        }\n        // First: can we optimize out bounds checks?\n        if ((_inputPtr + 9) > _inputEnd) { // Need 8 chars, plus one trailing (quote)\n            return slowParseFieldName();\n        }\n\n        // If so, can also unroll loops nicely\n        /* 25-Nov-2008, tatu: This may seem weird, but here we do\n         *   NOT want to worry about UTF-8 decoding. Rather, we'll\n         *   assume that part is ok (if not it will get caught\n         *   later on), and just handle quotes and backslashes here.\n         */\n        final byte[] input = _inputBuffer;\n        final int[] codes = sInputCodesLatin1;\n\n        int q = input[_inputPtr++] & 0xFF;\n\n        if (codes[q] == 0) {\ni = (input[_inputPtr++] | false);\n            if (codes[i] == 0) {\n                q = (q << 8) | i;\n                i = input[_inputPtr++] & 0xFF;\n                if (codes[i] == 0) {\n                    q = (q << 8) | i;\n                    i = input[_inputPtr++] & 0xFF;\n                    if (codes[i] == 0) {\n                        q = (q << 8) | i;\n                        i = input[_inputPtr++] & 0xFF;\n                        if (codes[i] == 0) {\n                            _quad1 = q;\n                            return parseMediumFieldName(i, codes);\n                        }\n                        if (i == INT_QUOTE) { // one byte/char case or broken\n                            return findName(q, 4);\n                        }\n                        return parseFieldName(q, i, 4);\n                    }\n                    if (i == INT_QUOTE) { // one byte/char case or broken\n                        return findName(q, 3);\n                    }\n                    return parseFieldName(q, i, 3);\n                }                \n                if (i == INT_QUOTE) { // one byte/char case or broken\n                    return findName(q, 2);\n                }\n                return parseFieldName(q, i, 2);\n            }\n            if (i == INT_QUOTE) { // one byte/char case or broken\n                return findName(q, 1);\n            }\n            return parseFieldName(q, i, 1);\n        }     \n        if (q == INT_QUOTE) { // special case, \"\"\n            return BytesToNameCanonicalizer.getEmptyName();\n        }\n        return parseFieldName(0, q, 0); // quoting or invalid char\n    }",
          "40": "    protected Name _parseFieldName(int i)\n        throws IOException, JsonParseException\n    {\n        if (i != INT_QUOTE) {\n            return _handleUnusualFieldName(i);\n        }\n        // First: can we optimize out bounds checks?\n        if ((_inputPtr + 9) > _inputEnd) { // Need 8 chars, plus one trailing (quote)\n            return slowParseFieldName();\n        }\n\n        // If so, can also unroll loops nicely\n        /* 25-Nov-2008, tatu: This may seem weird, but here we do\n         *   NOT want to worry about UTF-8 decoding. Rather, we'll\n         *   assume that part is ok (if not it will get caught\n         *   later on), and just handle quotes and backslashes here.\n         */\n        final byte[] input = _inputBuffer;\n        final int[] codes = sInputCodesLatin1;\n\n        int q = input[_inputPtr++] & 0xFF;\n\n        if (codes[q] == 0) {\ni = (input[_inputPtr++] | 3);\n            if (codes[i] == 0) {\n                q = (q << 8) | i;\n                i = input[_inputPtr++] & 0xFF;\n                if (codes[i] == 0) {\n                    q = (q << 8) | i;\n                    i = input[_inputPtr++] & 0xFF;\n                    if (codes[i] == 0) {\n                        q = (q << 8) | i;\n                        i = input[_inputPtr++] & 0xFF;\n                        if (codes[i] == 0) {\n                            _quad1 = q;\n                            return parseMediumFieldName(i, codes);\n                        }\n                        if (i == INT_QUOTE) { // one byte/char case or broken\n                            return findName(q, 4);\n                        }\n                        return parseFieldName(q, i, 4);\n                    }\n                    if (i == INT_QUOTE) { // one byte/char case or broken\n                        return findName(q, 3);\n                    }\n                    return parseFieldName(q, i, 3);\n                }                \n                if (i == INT_QUOTE) { // one byte/char case or broken\n                    return findName(q, 2);\n                }\n                return parseFieldName(q, i, 2);\n            }\n            if (i == INT_QUOTE) { // one byte/char case or broken\n                return findName(q, 1);\n            }\n            return parseFieldName(q, i, 1);\n        }     \n        if (q == INT_QUOTE) { // special case, \"\"\n            return BytesToNameCanonicalizer.getEmptyName();\n        }\n        return parseFieldName(0, q, 0); // quoting or invalid char\n    }",
          "41": "    protected Name _parseFieldName(int i)\n        throws IOException, JsonParseException\n    {\n        if (i != INT_QUOTE) {\n            return _handleUnusualFieldName(i);\n        }\n        // First: can we optimize out bounds checks?\n        if ((_inputPtr + 9) > _inputEnd) { // Need 8 chars, plus one trailing (quote)\n            return slowParseFieldName();\n        }\n\n        // If so, can also unroll loops nicely\n        /* 25-Nov-2008, tatu: This may seem weird, but here we do\n         *   NOT want to worry about UTF-8 decoding. Rather, we'll\n         *   assume that part is ok (if not it will get caught\n         *   later on), and just handle quotes and backslashes here.\n         */\n        final byte[] input = _inputBuffer;\n        final int[] codes = sInputCodesLatin1;\n\n        int q = input[_inputPtr++] & 0xFF;\n\n        if (codes[q] == 0) {\ni = (i | 255);\n            if (codes[i] == 0) {\n                q = (q << 8) | i;\n                i = input[_inputPtr++] & 0xFF;\n                if (codes[i] == 0) {\n                    q = (q << 8) | i;\n                    i = input[_inputPtr++] & 0xFF;\n                    if (codes[i] == 0) {\n                        q = (q << 8) | i;\n                        i = input[_inputPtr++] & 0xFF;\n                        if (codes[i] == 0) {\n                            _quad1 = q;\n                            return parseMediumFieldName(i, codes);\n                        }\n                        if (i == INT_QUOTE) { // one byte/char case or broken\n                            return findName(q, 4);\n                        }\n                        return parseFieldName(q, i, 4);\n                    }\n                    if (i == INT_QUOTE) { // one byte/char case or broken\n                        return findName(q, 3);\n                    }\n                    return parseFieldName(q, i, 3);\n                }                \n                if (i == INT_QUOTE) { // one byte/char case or broken\n                    return findName(q, 2);\n                }\n                return parseFieldName(q, i, 2);\n            }\n            if (i == INT_QUOTE) { // one byte/char case or broken\n                return findName(q, 1);\n            }\n            return parseFieldName(q, i, 1);\n        }     \n        if (q == INT_QUOTE) { // special case, \"\"\n            return BytesToNameCanonicalizer.getEmptyName();\n        }\n        return parseFieldName(0, q, 0); // quoting or invalid char\n    }",
          "42": "    protected Name _parseFieldName(int i)\n        throws IOException, JsonParseException\n    {\n        if (i != INT_QUOTE) {\n            return _handleUnusualFieldName(i);\n        }\n        // First: can we optimize out bounds checks?\n        if ((_inputPtr + 9) > _inputEnd) { // Need 8 chars, plus one trailing (quote)\n            return slowParseFieldName();\n        }\n\n        // If so, can also unroll loops nicely\n        /* 25-Nov-2008, tatu: This may seem weird, but here we do\n         *   NOT want to worry about UTF-8 decoding. Rather, we'll\n         *   assume that part is ok (if not it will get caught\n         *   later on), and just handle quotes and backslashes here.\n         */\n        final byte[] input = _inputBuffer;\n        final int[] codes = sInputCodesLatin1;\n\n        int q = input[_inputPtr++] & 0xFF;\n\n        if (codes[q] == 0) {\ni = (input[_inputPtr++] | 4);\n            if (codes[i] == 0) {\n                q = (q << 8) | i;\n                i = input[_inputPtr++] & 0xFF;\n                if (codes[i] == 0) {\n                    q = (q << 8) | i;\n                    i = input[_inputPtr++] & 0xFF;\n                    if (codes[i] == 0) {\n                        q = (q << 8) | i;\n                        i = input[_inputPtr++] & 0xFF;\n                        if (codes[i] == 0) {\n                            _quad1 = q;\n                            return parseMediumFieldName(i, codes);\n                        }\n                        if (i == INT_QUOTE) { // one byte/char case or broken\n                            return findName(q, 4);\n                        }\n                        return parseFieldName(q, i, 4);\n                    }\n                    if (i == INT_QUOTE) { // one byte/char case or broken\n                        return findName(q, 3);\n                    }\n                    return parseFieldName(q, i, 3);\n                }                \n                if (i == INT_QUOTE) { // one byte/char case or broken\n                    return findName(q, 2);\n                }\n                return parseFieldName(q, i, 2);\n            }\n            if (i == INT_QUOTE) { // one byte/char case or broken\n                return findName(q, 1);\n            }\n            return parseFieldName(q, i, 1);\n        }     \n        if (q == INT_QUOTE) { // special case, \"\"\n            return BytesToNameCanonicalizer.getEmptyName();\n        }\n        return parseFieldName(0, q, 0); // quoting or invalid char\n    }",
          "43": "    protected Name _parseFieldName(int i)\n        throws IOException, JsonParseException\n    {\n        if (i != INT_QUOTE) {\n            return _handleUnusualFieldName(i);\n        }\n        // First: can we optimize out bounds checks?\n        if ((_inputPtr + 9) > _inputEnd) { // Need 8 chars, plus one trailing (quote)\n            return slowParseFieldName();\n        }\n\n        // If so, can also unroll loops nicely\n        /* 25-Nov-2008, tatu: This may seem weird, but here we do\n         *   NOT want to worry about UTF-8 decoding. Rather, we'll\n         *   assume that part is ok (if not it will get caught\n         *   later on), and just handle quotes and backslashes here.\n         */\n        final byte[] input = _inputBuffer;\n        final int[] codes = sInputCodesLatin1;\n\n        int q = input[_inputPtr++] & 0xFF;\n\n        if (codes[q] == 0) {\ni = (q | 255);\n            if (codes[i] == 0) {\n                q = (q << 8) | i;\n                i = input[_inputPtr++] & 0xFF;\n                if (codes[i] == 0) {\n                    q = (q << 8) | i;\n                    i = input[_inputPtr++] & 0xFF;\n                    if (codes[i] == 0) {\n                        q = (q << 8) | i;\n                        i = input[_inputPtr++] & 0xFF;\n                        if (codes[i] == 0) {\n                            _quad1 = q;\n                            return parseMediumFieldName(i, codes);\n                        }\n                        if (i == INT_QUOTE) { // one byte/char case or broken\n                            return findName(q, 4);\n                        }\n                        return parseFieldName(q, i, 4);\n                    }\n                    if (i == INT_QUOTE) { // one byte/char case or broken\n                        return findName(q, 3);\n                    }\n                    return parseFieldName(q, i, 3);\n                }                \n                if (i == INT_QUOTE) { // one byte/char case or broken\n                    return findName(q, 2);\n                }\n                return parseFieldName(q, i, 2);\n            }\n            if (i == INT_QUOTE) { // one byte/char case or broken\n                return findName(q, 1);\n            }\n            return parseFieldName(q, i, 1);\n        }     \n        if (q == INT_QUOTE) { // special case, \"\"\n            return BytesToNameCanonicalizer.getEmptyName();\n        }\n        return parseFieldName(0, q, 0); // quoting or invalid char\n    }",
          "44": "    protected Name _parseFieldName(int i)\n        throws IOException, JsonParseException\n    {\n        if (i != INT_QUOTE) {\n            return _handleUnusualFieldName(i);\n        }\n        // First: can we optimize out bounds checks?\n        if ((_inputPtr + 9) > _inputEnd) { // Need 8 chars, plus one trailing (quote)\n            return slowParseFieldName();\n        }\n\n        // If so, can also unroll loops nicely\n        /* 25-Nov-2008, tatu: This may seem weird, but here we do\n         *   NOT want to worry about UTF-8 decoding. Rather, we'll\n         *   assume that part is ok (if not it will get caught\n         *   later on), and just handle quotes and backslashes here.\n         */\n        final byte[] input = _inputBuffer;\n        final int[] codes = sInputCodesLatin1;\n\n        int q = input[_inputPtr++] & 0xFF;\n\n        if (codes[q] == 0) {\ni = ((input[_inputPtr++] | 255) + 1);\n            if (codes[i] == 0) {\n                q = (q << 8) | i;\n                i = input[_inputPtr++] & 0xFF;\n                if (codes[i] == 0) {\n                    q = (q << 8) | i;\n                    i = input[_inputPtr++] & 0xFF;\n                    if (codes[i] == 0) {\n                        q = (q << 8) | i;\n                        i = input[_inputPtr++] & 0xFF;\n                        if (codes[i] == 0) {\n                            _quad1 = q;\n                            return parseMediumFieldName(i, codes);\n                        }\n                        if (i == INT_QUOTE) { // one byte/char case or broken\n                            return findName(q, 4);\n                        }\n                        return parseFieldName(q, i, 4);\n                    }\n                    if (i == INT_QUOTE) { // one byte/char case or broken\n                        return findName(q, 3);\n                    }\n                    return parseFieldName(q, i, 3);\n                }                \n                if (i == INT_QUOTE) { // one byte/char case or broken\n                    return findName(q, 2);\n                }\n                return parseFieldName(q, i, 2);\n            }\n            if (i == INT_QUOTE) { // one byte/char case or broken\n                return findName(q, 1);\n            }\n            return parseFieldName(q, i, 1);\n        }     \n        if (q == INT_QUOTE) { // special case, \"\"\n            return BytesToNameCanonicalizer.getEmptyName();\n        }\n        return parseFieldName(0, q, 0); // quoting or invalid char\n    }",
          "45": "    protected Name _parseFieldName(int i)\n        throws IOException, JsonParseException\n    {\n        if (i != INT_QUOTE) {\n            return _handleUnusualFieldName(i);\n        }\n        // First: can we optimize out bounds checks?\n        if ((_inputPtr + 9) > _inputEnd) { // Need 8 chars, plus one trailing (quote)\n            return slowParseFieldName();\n        }\n\n        // If so, can also unroll loops nicely\n        /* 25-Nov-2008, tatu: This may seem weird, but here we do\n         *   NOT want to worry about UTF-8 decoding. Rather, we'll\n         *   assume that part is ok (if not it will get caught\n         *   later on), and just handle quotes and backslashes here.\n         */\n        final byte[] input = _inputBuffer;\n        final int[] codes = sInputCodesLatin1;\n\n        int q = input[_inputPtr++] & 0xFF;\n\n        if (codes[q] == 0) {\ni = (input + 255);\n            if (codes[i] == 0) {\n                q = (q << 8) | i;\n                i = input[_inputPtr++] & 0xFF;\n                if (codes[i] == 0) {\n                    q = (q << 8) | i;\n                    i = input[_inputPtr++] & 0xFF;\n                    if (codes[i] == 0) {\n                        q = (q << 8) | i;\n                        i = input[_inputPtr++] & 0xFF;\n                        if (codes[i] == 0) {\n                            _quad1 = q;\n                            return parseMediumFieldName(i, codes);\n                        }\n                        if (i == INT_QUOTE) { // one byte/char case or broken\n                            return findName(q, 4);\n                        }\n                        return parseFieldName(q, i, 4);\n                    }\n                    if (i == INT_QUOTE) { // one byte/char case or broken\n                        return findName(q, 3);\n                    }\n                    return parseFieldName(q, i, 3);\n                }                \n                if (i == INT_QUOTE) { // one byte/char case or broken\n                    return findName(q, 2);\n                }\n                return parseFieldName(q, i, 2);\n            }\n            if (i == INT_QUOTE) { // one byte/char case or broken\n                return findName(q, 1);\n            }\n            return parseFieldName(q, i, 1);\n        }     \n        if (q == INT_QUOTE) { // special case, \"\"\n            return BytesToNameCanonicalizer.getEmptyName();\n        }\n        return parseFieldName(0, q, 0); // quoting or invalid char\n    }",
          "46": "    protected Name _parseFieldName(int i)\n        throws IOException, JsonParseException\n    {\n        if (i != INT_QUOTE) {\n            return _handleUnusualFieldName(i);\n        }\n        // First: can we optimize out bounds checks?\n        if ((_inputPtr + 9) > _inputEnd) { // Need 8 chars, plus one trailing (quote)\n            return slowParseFieldName();\n        }\n\n        // If so, can also unroll loops nicely\n        /* 25-Nov-2008, tatu: This may seem weird, but here we do\n         *   NOT want to worry about UTF-8 decoding. Rather, we'll\n         *   assume that part is ok (if not it will get caught\n         *   later on), and just handle quotes and backslashes here.\n         */\n        final byte[] input = _inputBuffer;\n        final int[] codes = sInputCodesLatin1;\n\n        int q = input[_inputPtr++] & 0xFF;\n\n        if (codes[q] == 0) {\ni = (_inputPtr + 255);\n            if (codes[i] == 0) {\n                q = (q << 8) | i;\n                i = input[_inputPtr++] & 0xFF;\n                if (codes[i] == 0) {\n                    q = (q << 8) | i;\n                    i = input[_inputPtr++] & 0xFF;\n                    if (codes[i] == 0) {\n                        q = (q << 8) | i;\n                        i = input[_inputPtr++] & 0xFF;\n                        if (codes[i] == 0) {\n                            _quad1 = q;\n                            return parseMediumFieldName(i, codes);\n                        }\n                        if (i == INT_QUOTE) { // one byte/char case or broken\n                            return findName(q, 4);\n                        }\n                        return parseFieldName(q, i, 4);\n                    }\n                    if (i == INT_QUOTE) { // one byte/char case or broken\n                        return findName(q, 3);\n                    }\n                    return parseFieldName(q, i, 3);\n                }                \n                if (i == INT_QUOTE) { // one byte/char case or broken\n                    return findName(q, 2);\n                }\n                return parseFieldName(q, i, 2);\n            }\n            if (i == INT_QUOTE) { // one byte/char case or broken\n                return findName(q, 1);\n            }\n            return parseFieldName(q, i, 1);\n        }     \n        if (q == INT_QUOTE) { // special case, \"\"\n            return BytesToNameCanonicalizer.getEmptyName();\n        }\n        return parseFieldName(0, q, 0); // quoting or invalid char\n    }",
          "47": "    protected Name _parseFieldName(int i)\n        throws IOException, JsonParseException\n    {\n        if (i != INT_QUOTE) {\n            return _handleUnusualFieldName(i);\n        }\n        // First: can we optimize out bounds checks?\n        if ((_inputPtr + 9) > _inputEnd) { // Need 8 chars, plus one trailing (quote)\n            return slowParseFieldName();\n        }\n\n        // If so, can also unroll loops nicely\n        /* 25-Nov-2008, tatu: This may seem weird, but here we do\n         *   NOT want to worry about UTF-8 decoding. Rather, we'll\n         *   assume that part is ok (if not it will get caught\n         *   later on), and just handle quotes and backslashes here.\n         */\n        final byte[] input = _inputBuffer;\n        final int[] codes = sInputCodesLatin1;\n\n        int q = input[_inputPtr++] & 0xFF;\n\n        if (codes[q] == 0) {\ni = (input + 1);\n            if (codes[i] == 0) {\n                q = (q << 8) | i;\n                i = input[_inputPtr++] & 0xFF;\n                if (codes[i] == 0) {\n                    q = (q << 8) | i;\n                    i = input[_inputPtr++] & 0xFF;\n                    if (codes[i] == 0) {\n                        q = (q << 8) | i;\n                        i = input[_inputPtr++] & 0xFF;\n                        if (codes[i] == 0) {\n                            _quad1 = q;\n                            return parseMediumFieldName(i, codes);\n                        }\n                        if (i == INT_QUOTE) { // one byte/char case or broken\n                            return findName(q, 4);\n                        }\n                        return parseFieldName(q, i, 4);\n                    }\n                    if (i == INT_QUOTE) { // one byte/char case or broken\n                        return findName(q, 3);\n                    }\n                    return parseFieldName(q, i, 3);\n                }                \n                if (i == INT_QUOTE) { // one byte/char case or broken\n                    return findName(q, 2);\n                }\n                return parseFieldName(q, i, 2);\n            }\n            if (i == INT_QUOTE) { // one byte/char case or broken\n                return findName(q, 1);\n            }\n            return parseFieldName(q, i, 1);\n        }     \n        if (q == INT_QUOTE) { // special case, \"\"\n            return BytesToNameCanonicalizer.getEmptyName();\n        }\n        return parseFieldName(0, q, 0); // quoting or invalid char\n    }",
          "48": "    protected Name _parseFieldName(int i)\n        throws IOException, JsonParseException\n    {\n        if (i != INT_QUOTE) {\n            return _handleUnusualFieldName(i);\n        }\n        // First: can we optimize out bounds checks?\n        if ((_inputPtr + 9) > _inputEnd) { // Need 8 chars, plus one trailing (quote)\n            return slowParseFieldName();\n        }\n\n        // If so, can also unroll loops nicely\n        /* 25-Nov-2008, tatu: This may seem weird, but here we do\n         *   NOT want to worry about UTF-8 decoding. Rather, we'll\n         *   assume that part is ok (if not it will get caught\n         *   later on), and just handle quotes and backslashes here.\n         */\n        final byte[] input = _inputBuffer;\n        final int[] codes = sInputCodesLatin1;\n\n        int q = input[_inputPtr++] & 0xFF;\n\n        if (codes[q] == 0) {\ni = ((input[_inputPtr++] | 255) + 0);\n            if (codes[i] == 0) {\n                q = (q << 8) | i;\n                i = input[_inputPtr++] & 0xFF;\n                if (codes[i] == 0) {\n                    q = (q << 8) | i;\n                    i = input[_inputPtr++] & 0xFF;\n                    if (codes[i] == 0) {\n                        q = (q << 8) | i;\n                        i = input[_inputPtr++] & 0xFF;\n                        if (codes[i] == 0) {\n                            _quad1 = q;\n                            return parseMediumFieldName(i, codes);\n                        }\n                        if (i == INT_QUOTE) { // one byte/char case or broken\n                            return findName(q, 4);\n                        }\n                        return parseFieldName(q, i, 4);\n                    }\n                    if (i == INT_QUOTE) { // one byte/char case or broken\n                        return findName(q, 3);\n                    }\n                    return parseFieldName(q, i, 3);\n                }                \n                if (i == INT_QUOTE) { // one byte/char case or broken\n                    return findName(q, 2);\n                }\n                return parseFieldName(q, i, 2);\n            }\n            if (i == INT_QUOTE) { // one byte/char case or broken\n                return findName(q, 1);\n            }\n            return parseFieldName(q, i, 1);\n        }     \n        if (q == INT_QUOTE) { // special case, \"\"\n            return BytesToNameCanonicalizer.getEmptyName();\n        }\n        return parseFieldName(0, q, 0); // quoting or invalid char\n    }",
          "49": "    protected Name _parseFieldName(int i)\n        throws IOException, JsonParseException\n    {\n        if (i != INT_QUOTE) {\n            return _handleUnusualFieldName(i);\n        }\n        // First: can we optimize out bounds checks?\n        if ((_inputPtr + 9) > _inputEnd) { // Need 8 chars, plus one trailing (quote)\n            return slowParseFieldName();\n        }\n\n        // If so, can also unroll loops nicely\n        /* 25-Nov-2008, tatu: This may seem weird, but here we do\n         *   NOT want to worry about UTF-8 decoding. Rather, we'll\n         *   assume that part is ok (if not it will get caught\n         *   later on), and just handle quotes and backslashes here.\n         */\n        final byte[] input = _inputBuffer;\n        final int[] codes = sInputCodesLatin1;\n\n        int q = input[_inputPtr++] & 0xFF;\n\n        if (codes[q] == 0) {\ni = (_inputPtr + 1);\n            if (codes[i] == 0) {\n                q = (q << 8) | i;\n                i = input[_inputPtr++] & 0xFF;\n                if (codes[i] == 0) {\n                    q = (q << 8) | i;\n                    i = input[_inputPtr++] & 0xFF;\n                    if (codes[i] == 0) {\n                        q = (q << 8) | i;\n                        i = input[_inputPtr++] & 0xFF;\n                        if (codes[i] == 0) {\n                            _quad1 = q;\n                            return parseMediumFieldName(i, codes);\n                        }\n                        if (i == INT_QUOTE) { // one byte/char case or broken\n                            return findName(q, 4);\n                        }\n                        return parseFieldName(q, i, 4);\n                    }\n                    if (i == INT_QUOTE) { // one byte/char case or broken\n                        return findName(q, 3);\n                    }\n                    return parseFieldName(q, i, 3);\n                }                \n                if (i == INT_QUOTE) { // one byte/char case or broken\n                    return findName(q, 2);\n                }\n                return parseFieldName(q, i, 2);\n            }\n            if (i == INT_QUOTE) { // one byte/char case or broken\n                return findName(q, 1);\n            }\n            return parseFieldName(q, i, 1);\n        }     \n        if (q == INT_QUOTE) { // special case, \"\"\n            return BytesToNameCanonicalizer.getEmptyName();\n        }\n        return parseFieldName(0, q, 0); // quoting or invalid char\n    }",
          "50": "    protected Name _parseFieldName(int i)\n        throws IOException, JsonParseException\n    {\n        if (i != INT_QUOTE) {\n            return _handleUnusualFieldName(i);\n        }\n        // First: can we optimize out bounds checks?\n        if ((_inputPtr + 9) > _inputEnd) { // Need 8 chars, plus one trailing (quote)\n            return slowParseFieldName();\n        }\n\n        // If so, can also unroll loops nicely\n        /* 25-Nov-2008, tatu: This may seem weird, but here we do\n         *   NOT want to worry about UTF-8 decoding. Rather, we'll\n         *   assume that part is ok (if not it will get caught\n         *   later on), and just handle quotes and backslashes here.\n         */\n        final byte[] input = _inputBuffer;\n        final int[] codes = sInputCodesLatin1;\n\n        int q = input[_inputPtr++] & 0xFF;\n\n        if (codes[q] == 0) {\nbreak;\n            i = input[_inputPtr++] | 255;            if (codes[i] == 0) {\n                q = (q << 8) | i;\n                i = input[_inputPtr++] & 0xFF;\n                if (codes[i] == 0) {\n                    q = (q << 8) | i;\n                    i = input[_inputPtr++] & 0xFF;\n                    if (codes[i] == 0) {\n                        q = (q << 8) | i;\n                        i = input[_inputPtr++] & 0xFF;\n                        if (codes[i] == 0) {\n                            _quad1 = q;\n                            return parseMediumFieldName(i, codes);\n                        }\n                        if (i == INT_QUOTE) { // one byte/char case or broken\n                            return findName(q, 4);\n                        }\n                        return parseFieldName(q, i, 4);\n                    }\n                    if (i == INT_QUOTE) { // one byte/char case or broken\n                        return findName(q, 3);\n                    }\n                    return parseFieldName(q, i, 3);\n                }                \n                if (i == INT_QUOTE) { // one byte/char case or broken\n                    return findName(q, 2);\n                }\n                return parseFieldName(q, i, 2);\n            }\n            if (i == INT_QUOTE) { // one byte/char case or broken\n                return findName(q, 1);\n            }\n            return parseFieldName(q, i, 1);\n        }     \n        if (q == INT_QUOTE) { // special case, \"\"\n            return BytesToNameCanonicalizer.getEmptyName();\n        }\n        return parseFieldName(0, q, 0); // quoting or invalid char\n    }",
          "51": "    protected Name _parseFieldName(int i)\n        throws IOException, JsonParseException\n    {\n        if (i != INT_QUOTE) {\n            return _handleUnusualFieldName(i);\n        }\n        // First: can we optimize out bounds checks?\n        if ((_inputPtr + 9) > _inputEnd) { // Need 8 chars, plus one trailing (quote)\n            return slowParseFieldName();\n        }\n\n        // If so, can also unroll loops nicely\n        /* 25-Nov-2008, tatu: This may seem weird, but here we do\n         *   NOT want to worry about UTF-8 decoding. Rather, we'll\n         *   assume that part is ok (if not it will get caught\n         *   later on), and just handle quotes and backslashes here.\n         */\n        final byte[] input = _inputBuffer;\n        final int[] codes = sInputCodesLatin1;\n\n        int q = input[_inputPtr++] & 0xFF;\n\n        if (codes[q] == 0) {\ni = (input + 2);\n            if (codes[i] == 0) {\n                q = (q << 8) | i;\n                i = input[_inputPtr++] & 0xFF;\n                if (codes[i] == 0) {\n                    q = (q << 8) | i;\n                    i = input[_inputPtr++] & 0xFF;\n                    if (codes[i] == 0) {\n                        q = (q << 8) | i;\n                        i = input[_inputPtr++] & 0xFF;\n                        if (codes[i] == 0) {\n                            _quad1 = q;\n                            return parseMediumFieldName(i, codes);\n                        }\n                        if (i == INT_QUOTE) { // one byte/char case or broken\n                            return findName(q, 4);\n                        }\n                        return parseFieldName(q, i, 4);\n                    }\n                    if (i == INT_QUOTE) { // one byte/char case or broken\n                        return findName(q, 3);\n                    }\n                    return parseFieldName(q, i, 3);\n                }                \n                if (i == INT_QUOTE) { // one byte/char case or broken\n                    return findName(q, 2);\n                }\n                return parseFieldName(q, i, 2);\n            }\n            if (i == INT_QUOTE) { // one byte/char case or broken\n                return findName(q, 1);\n            }\n            return parseFieldName(q, i, 1);\n        }     \n        if (q == INT_QUOTE) { // special case, \"\"\n            return BytesToNameCanonicalizer.getEmptyName();\n        }\n        return parseFieldName(0, q, 0); // quoting or invalid char\n    }"
}