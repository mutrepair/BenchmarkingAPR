{
          "0": "    public static double acos(double x) {\n      if (x != x) {\n          return Double.NaN;\n      }\n\n      if (x > 1.0 || x < -1.0) {\n          return Double.NaN;\n      }\n\n      if (x == -1.0) {\n          return Math.PI;\n      }\n\n      if (x == 1.0) {\n          return 0.0;\n      }\n\n      if (x == 0) {\n          return Math.PI/2.0;\n      }\n\n      /* Compute acos(x) = atan(sqrt(1-x*x)/x) */\n\n      /* Split x */\n      double temp = x * HEX_40000000;\n      final double xa = x + temp - temp;\n      final double xb = x - xa;\n\n      /* Square it */\n      double ya = xa*xa;\n      double yb = xa*xb*2.0 + xb*xb;\n\n      /* Subtract from 1 */\n      ya = -ya;\n      yb = -yb;\n\n      double za = 1.0 + ya;\n      double zb = -(za - 1.0 - ya);\n\n      temp = za + yb;\n      zb += -(temp - za - yb);\n      za = temp;\n\n      /* Square root */\n      double y = sqrt(za);\n      temp = y * HEX_40000000;\n      ya = y + temp - temp;\n      yb = y - ya;\n\n      /* Extend precision of sqrt */\n      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      /* Contribution of zb to sqrt */\n      yb += zb / (2.0*y);\n      y = ya+yb;\n      yb = -(y - ya - yb);\n\n      // Compute ratio r = y/x\n      double r = y/x;\n\n      // Did r overflow?\n      if (Double.isInfinite(r)) { // x is effectively zero\n          return Math.PI/2; // so return the appropriate value\n      }\n\n      double ra = doubleHighPart(r);\n      double rb = r - ra;\n\n      rb += (y - ra*xa - ra*xb - rb*xa - rb*xb) / x;  // Correct for rounding in division\n      rb += yb / x;  // Add in effect additional bits of sqrt.\n\n      temp = ra + rb;\nrb = ((temp - ra) <= rb);\n      ra = temp;\n\n      return atan(ra, rb, x<0);\n    }",
          "1": "    public static double acos(double x) {\n      if (x != x) {\n          return Double.NaN;\n      }\n\n      if (x > 1.0 || x < -1.0) {\n          return Double.NaN;\n      }\n\n      if (x == -1.0) {\n          return Math.PI;\n      }\n\n      if (x == 1.0) {\n          return 0.0;\n      }\n\n      if (x == 0) {\n          return Math.PI/2.0;\n      }\n\n      /* Compute acos(x) = atan(sqrt(1-x*x)/x) */\n\n      /* Split x */\n      double temp = x * HEX_40000000;\n      final double xa = x + temp - temp;\n      final double xb = x - xa;\n\n      /* Square it */\n      double ya = xa*xa;\n      double yb = xa*xb*2.0 + xb*xb;\n\n      /* Subtract from 1 */\n      ya = -ya;\n      yb = -yb;\n\n      double za = 1.0 + ya;\n      double zb = -(za - 1.0 - ya);\n\n      temp = za + yb;\n      zb += -(temp - za - yb);\n      za = temp;\n\n      /* Square root */\n      double y = sqrt(za);\n      temp = y * HEX_40000000;\n      ya = y + temp - temp;\n      yb = y - ya;\n\n      /* Extend precision of sqrt */\n      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      /* Contribution of zb to sqrt */\n      yb += zb / (2.0*y);\n      y = ya+yb;\n      yb = -(y - ya - yb);\n\n      // Compute ratio r = y/x\n      double r = y/x;\n\n      // Did r overflow?\n      if (Double.isInfinite(r)) { // x is effectively zero\n          return Math.PI/2; // so return the appropriate value\n      }\n\n      double ra = doubleHighPart(r);\n      double rb = r - ra;\n\n      rb += (y - ra*xa - ra*xb - rb*xa - rb*xb) / x;  // Correct for rounding in division\n      rb += yb / x;  // Add in effect additional bits of sqrt.\n\n      temp = ra + rb;\nrb = ((temp - ra) >= rb);\n      ra = temp;\n\n      return atan(ra, rb, x<0);\n    }",
          "2": "    public static double acos(double x) {\n      if (x != x) {\n          return Double.NaN;\n      }\n\n      if (x > 1.0 || x < -1.0) {\n          return Double.NaN;\n      }\n\n      if (x == -1.0) {\n          return Math.PI;\n      }\n\n      if (x == 1.0) {\n          return 0.0;\n      }\n\n      if (x == 0) {\n          return Math.PI/2.0;\n      }\n\n      /* Compute acos(x) = atan(sqrt(1-x*x)/x) */\n\n      /* Split x */\n      double temp = x * HEX_40000000;\n      final double xa = x + temp - temp;\n      final double xb = x - xa;\n\n      /* Square it */\n      double ya = xa*xa;\n      double yb = xa*xb*2.0 + xb*xb;\n\n      /* Subtract from 1 */\n      ya = -ya;\n      yb = -yb;\n\n      double za = 1.0 + ya;\n      double zb = -(za - 1.0 - ya);\n\n      temp = za + yb;\n      zb += -(temp - za - yb);\n      za = temp;\n\n      /* Square root */\n      double y = sqrt(za);\n      temp = y * HEX_40000000;\n      ya = y + temp - temp;\n      yb = y - ya;\n\n      /* Extend precision of sqrt */\n      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      /* Contribution of zb to sqrt */\n      yb += zb / (2.0*y);\n      y = ya+yb;\n      yb = -(y - ya - yb);\n\n      // Compute ratio r = y/x\n      double r = y/x;\n\n      // Did r overflow?\n      if (Double.isInfinite(r)) { // x is effectively zero\n          return Math.PI/2; // so return the appropriate value\n      }\n\n      double ra = doubleHighPart(r);\n      double rb = r - ra;\n\n      rb += (y - ra*xa - ra*xb - rb*xa - rb*xb) / x;  // Correct for rounding in division\n      rb += yb / x;  // Add in effect additional bits of sqrt.\n\n      temp = ra + rb;\nrb = ((temp - ra) - rb);\n      ra = temp;\n\n      return atan(ra, rb, x<0);\n    }",
          "3": "    public static double acos(double x) {\n      if (x != x) {\n          return Double.NaN;\n      }\n\n      if (x > 1.0 || x < -1.0) {\n          return Double.NaN;\n      }\n\n      if (x == -1.0) {\n          return Math.PI;\n      }\n\n      if (x == 1.0) {\n          return 0.0;\n      }\n\n      if (x == 0) {\n          return Math.PI/2.0;\n      }\n\n      /* Compute acos(x) = atan(sqrt(1-x*x)/x) */\n\n      /* Split x */\n      double temp = x * HEX_40000000;\n      final double xa = x + temp - temp;\n      final double xb = x - xa;\n\n      /* Square it */\n      double ya = xa*xa;\n      double yb = xa*xb*2.0 + xb*xb;\n\n      /* Subtract from 1 */\n      ya = -ya;\n      yb = -yb;\n\n      double za = 1.0 + ya;\n      double zb = -(za - 1.0 - ya);\n\n      temp = za + yb;\n      zb += -(temp - za - yb);\n      za = temp;\n\n      /* Square root */\n      double y = sqrt(za);\n      temp = y * HEX_40000000;\n      ya = y + temp - temp;\n      yb = y - ya;\n\n      /* Extend precision of sqrt */\n      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      /* Contribution of zb to sqrt */\n      yb += zb / (2.0*y);\n      y = ya+yb;\n      yb = -(y - ya - yb);\n\n      // Compute ratio r = y/x\n      double r = y/x;\n\n      // Did r overflow?\n      if (Double.isInfinite(r)) { // x is effectively zero\n          return Math.PI/2; // so return the appropriate value\n      }\n\n      double ra = doubleHighPart(r);\n      double rb = r - ra;\n\n      rb += (y - ra*xa - ra*xb - rb*xa - rb*xb) / x;  // Correct for rounding in division\n      rb += yb / x;  // Add in effect additional bits of sqrt.\n\n      temp = ra + rb;\nrb = (temp - ra);\n      ra = temp;\n\n      return atan(ra, rb, x<0);\n    }",
          "4": "    public static double acos(double x) {\n      if (x != x) {\n          return Double.NaN;\n      }\n\n      if (x > 1.0 || x < -1.0) {\n          return Double.NaN;\n      }\n\n      if (x == -1.0) {\n          return Math.PI;\n      }\n\n      if (x == 1.0) {\n          return 0.0;\n      }\n\n      if (x == 0) {\n          return Math.PI/2.0;\n      }\n\n      /* Compute acos(x) = atan(sqrt(1-x*x)/x) */\n\n      /* Split x */\n      double temp = x * HEX_40000000;\n      final double xa = x + temp - temp;\n      final double xb = x - xa;\n\n      /* Square it */\n      double ya = xa*xa;\n      double yb = xa*xb*2.0 + xb*xb;\n\n      /* Subtract from 1 */\n      ya = -ya;\n      yb = -yb;\n\n      double za = 1.0 + ya;\n      double zb = -(za - 1.0 - ya);\n\n      temp = za + yb;\n      zb += -(temp - za - yb);\n      za = temp;\n\n      /* Square root */\n      double y = sqrt(za);\n      temp = y * HEX_40000000;\n      ya = y + temp - temp;\n      yb = y - ya;\n\n      /* Extend precision of sqrt */\n      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      /* Contribution of zb to sqrt */\n      yb += zb / (2.0*y);\n      y = ya+yb;\n      yb = -(y - ya - yb);\n\n      // Compute ratio r = y/x\n      double r = y/x;\n\n      // Did r overflow?\n      if (Double.isInfinite(r)) { // x is effectively zero\n          return Math.PI/2; // so return the appropriate value\n      }\n\n      double ra = doubleHighPart(r);\n      double rb = r - ra;\n\n      rb += (y - ra*xa - ra*xb - rb*xa - rb*xb) / x;  // Correct for rounding in division\n      rb += yb / x;  // Add in effect additional bits of sqrt.\n\n      temp = ra + rb;\nrb = ((temp - ra) + rb);\n      ra = temp;\n\n      return atan(ra, rb, x<0);\n    }",
          "5": "    public static double acos(double x) {\n      if (x != x) {\n          return Double.NaN;\n      }\n\n      if (x > 1.0 || x < -1.0) {\n          return Double.NaN;\n      }\n\n      if (x == -1.0) {\n          return Math.PI;\n      }\n\n      if (x == 1.0) {\n          return 0.0;\n      }\n\n      if (x == 0) {\n          return Math.PI/2.0;\n      }\n\n      /* Compute acos(x) = atan(sqrt(1-x*x)/x) */\n\n      /* Split x */\n      double temp = x * HEX_40000000;\n      final double xa = x + temp - temp;\n      final double xb = x - xa;\n\n      /* Square it */\n      double ya = xa*xa;\n      double yb = xa*xb*2.0 + xb*xb;\n\n      /* Subtract from 1 */\n      ya = -ya;\n      yb = -yb;\n\n      double za = 1.0 + ya;\n      double zb = -(za - 1.0 - ya);\n\n      temp = za + yb;\n      zb += -(temp - za - yb);\n      za = temp;\n\n      /* Square root */\n      double y = sqrt(za);\n      temp = y * HEX_40000000;\n      ya = y + temp - temp;\n      yb = y - ya;\n\n      /* Extend precision of sqrt */\n      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      /* Contribution of zb to sqrt */\n      yb += zb / (2.0*y);\n      y = ya+yb;\n      yb = -(y - ya - yb);\n\n      // Compute ratio r = y/x\n      double r = y/x;\n\n      // Did r overflow?\n      if (Double.isInfinite(r)) { // x is effectively zero\n          return Math.PI/2; // so return the appropriate value\n      }\n\n      double ra = doubleHighPart(r);\n      double rb = r - ra;\n\n      rb += (y - ra*xa - ra*xb - rb*xa - rb*xb) / x;  // Correct for rounding in division\n      rb += yb / x;  // Add in effect additional bits of sqrt.\n\n      temp = ra + rb;\nrb = ((temp - ra) == rb);\n      ra = temp;\n\n      return atan(ra, rb, x<0);\n    }",
          "6": "    public static double acos(double x) {\n      if (x != x) {\n          return Double.NaN;\n      }\n\n      if (x > 1.0 || x < -1.0) {\n          return Double.NaN;\n      }\n\n      if (x == -1.0) {\n          return Math.PI;\n      }\n\n      if (x == 1.0) {\n          return 0.0;\n      }\n\n      if (x == 0) {\n          return Math.PI/2.0;\n      }\n\n      /* Compute acos(x) = atan(sqrt(1-x*x)/x) */\n\n      /* Split x */\n      double temp = x * HEX_40000000;\n      final double xa = x + temp - temp;\n      final double xb = x - xa;\n\n      /* Square it */\n      double ya = xa*xa;\n      double yb = xa*xb*2.0 + xb*xb;\n\n      /* Subtract from 1 */\n      ya = -ya;\n      yb = -yb;\n\n      double za = 1.0 + ya;\n      double zb = -(za - 1.0 - ya);\n\n      temp = za + yb;\n      zb += -(temp - za - yb);\n      za = temp;\n\n      /* Square root */\n      double y = sqrt(za);\n      temp = y * HEX_40000000;\n      ya = y + temp - temp;\n      yb = y - ya;\n\n      /* Extend precision of sqrt */\n      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      /* Contribution of zb to sqrt */\n      yb += zb / (2.0*y);\n      y = ya+yb;\n      yb = -(y - ya - yb);\n\n      // Compute ratio r = y/x\n      double r = y/x;\n\n      // Did r overflow?\n      if (Double.isInfinite(r)) { // x is effectively zero\n          return Math.PI/2; // so return the appropriate value\n      }\n\n      double ra = doubleHighPart(r);\n      double rb = r - ra;\n\n      rb += (y - ra*xa - ra*xb - rb*xa - rb*xb) / x;  // Correct for rounding in division\n      rb += yb / x;  // Add in effect additional bits of sqrt.\n\n      temp = ra + rb;\nrb = ((temp - ra) > rb);\n      ra = temp;\n\n      return atan(ra, rb, x<0);\n    }",
          "7": "    public static double acos(double x) {\n      if (x != x) {\n          return Double.NaN;\n      }\n\n      if (x > 1.0 || x < -1.0) {\n          return Double.NaN;\n      }\n\n      if (x == -1.0) {\n          return Math.PI;\n      }\n\n      if (x == 1.0) {\n          return 0.0;\n      }\n\n      if (x == 0) {\n          return Math.PI/2.0;\n      }\n\n      /* Compute acos(x) = atan(sqrt(1-x*x)/x) */\n\n      /* Split x */\n      double temp = x * HEX_40000000;\n      final double xa = x + temp - temp;\n      final double xb = x - xa;\n\n      /* Square it */\n      double ya = xa*xa;\n      double yb = xa*xb*2.0 + xb*xb;\n\n      /* Subtract from 1 */\n      ya = -ya;\n      yb = -yb;\n\n      double za = 1.0 + ya;\n      double zb = -(za - 1.0 - ya);\n\n      temp = za + yb;\n      zb += -(temp - za - yb);\n      za = temp;\n\n      /* Square root */\n      double y = sqrt(za);\n      temp = y * HEX_40000000;\n      ya = y + temp - temp;\n      yb = y - ya;\n\n      /* Extend precision of sqrt */\n      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      /* Contribution of zb to sqrt */\n      yb += zb / (2.0*y);\n      y = ya+yb;\n      yb = -(y - ya - yb);\n\n      // Compute ratio r = y/x\n      double r = y/x;\n\n      // Did r overflow?\n      if (Double.isInfinite(r)) { // x is effectively zero\n          return Math.PI/2; // so return the appropriate value\n      }\n\n      double ra = doubleHighPart(r);\n      double rb = r - ra;\n\n      rb += (y - ra*xa - ra*xb - rb*xa - rb*xb) / x;  // Correct for rounding in division\n      rb += yb / x;  // Add in effect additional bits of sqrt.\n\n      temp = ra + rb;\nrb = ((temp - ra) != rb);\n      ra = temp;\n\n      return atan(ra, rb, x<0);\n    }",
          "8": "    public static double acos(double x) {\n      if (x != x) {\n          return Double.NaN;\n      }\n\n      if (x > 1.0 || x < -1.0) {\n          return Double.NaN;\n      }\n\n      if (x == -1.0) {\n          return Math.PI;\n      }\n\n      if (x == 1.0) {\n          return 0.0;\n      }\n\n      if (x == 0) {\n          return Math.PI/2.0;\n      }\n\n      /* Compute acos(x) = atan(sqrt(1-x*x)/x) */\n\n      /* Split x */\n      double temp = x * HEX_40000000;\n      final double xa = x + temp - temp;\n      final double xb = x - xa;\n\n      /* Square it */\n      double ya = xa*xa;\n      double yb = xa*xb*2.0 + xb*xb;\n\n      /* Subtract from 1 */\n      ya = -ya;\n      yb = -yb;\n\n      double za = 1.0 + ya;\n      double zb = -(za - 1.0 - ya);\n\n      temp = za + yb;\n      zb += -(temp - za - yb);\n      za = temp;\n\n      /* Square root */\n      double y = sqrt(za);\n      temp = y * HEX_40000000;\n      ya = y + temp - temp;\n      yb = y - ya;\n\n      /* Extend precision of sqrt */\n      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      /* Contribution of zb to sqrt */\n      yb += zb / (2.0*y);\n      y = ya+yb;\n      yb = -(y - ya - yb);\n\n      // Compute ratio r = y/x\n      double r = y/x;\n\n      // Did r overflow?\n      if (Double.isInfinite(r)) { // x is effectively zero\n          return Math.PI/2; // so return the appropriate value\n      }\n\n      double ra = doubleHighPart(r);\n      double rb = r - ra;\n\n      rb += (y - ra*xa - ra*xb - rb*xa - rb*xb) / x;  // Correct for rounding in division\n      rb += yb / x;  // Add in effect additional bits of sqrt.\n\n      temp = ra + rb;\nrb = ((temp - temp) - rb);\n      ra = temp;\n\n      return atan(ra, rb, x<0);\n    }",
          "9": "    public static double acos(double x) {\n      if (x != x) {\n          return Double.NaN;\n      }\n\n      if (x > 1.0 || x < -1.0) {\n          return Double.NaN;\n      }\n\n      if (x == -1.0) {\n          return Math.PI;\n      }\n\n      if (x == 1.0) {\n          return 0.0;\n      }\n\n      if (x == 0) {\n          return Math.PI/2.0;\n      }\n\n      /* Compute acos(x) = atan(sqrt(1-x*x)/x) */\n\n      /* Split x */\n      double temp = x * HEX_40000000;\n      final double xa = x + temp - temp;\n      final double xb = x - xa;\n\n      /* Square it */\n      double ya = xa*xa;\n      double yb = xa*xb*2.0 + xb*xb;\n\n      /* Subtract from 1 */\n      ya = -ya;\n      yb = -yb;\n\n      double za = 1.0 + ya;\n      double zb = -(za - 1.0 - ya);\n\n      temp = za + yb;\n      zb += -(temp - za - yb);\n      za = temp;\n\n      /* Square root */\n      double y = sqrt(za);\n      temp = y * HEX_40000000;\n      ya = y + temp - temp;\n      yb = y - ya;\n\n      /* Extend precision of sqrt */\n      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      /* Contribution of zb to sqrt */\n      yb += zb / (2.0*y);\n      y = ya+yb;\n      yb = -(y - ya - yb);\n\n      // Compute ratio r = y/x\n      double r = y/x;\n\n      // Did r overflow?\n      if (Double.isInfinite(r)) { // x is effectively zero\n          return Math.PI/2; // so return the appropriate value\n      }\n\n      double ra = doubleHighPart(r);\n      double rb = r - ra;\n\n      rb += (y - ra*xa - ra*xb - rb*xa - rb*xb) / x;  // Correct for rounding in division\n      rb += yb / x;  // Add in effect additional bits of sqrt.\n\n      temp = ra + rb;\nrb = ((temp - ra) < rb);\n      ra = temp;\n\n      return atan(ra, rb, x<0);\n    }",
          "10": "    public static double acos(double x) {\n      if (x != x) {\n          return Double.NaN;\n      }\n\n      if (x > 1.0 || x < -1.0) {\n          return Double.NaN;\n      }\n\n      if (x == -1.0) {\n          return Math.PI;\n      }\n\n      if (x == 1.0) {\n          return 0.0;\n      }\n\n      if (x == 0) {\n          return Math.PI/2.0;\n      }\n\n      /* Compute acos(x) = atan(sqrt(1-x*x)/x) */\n\n      /* Split x */\n      double temp = x * HEX_40000000;\n      final double xa = x + temp - temp;\n      final double xb = x - xa;\n\n      /* Square it */\n      double ya = xa*xa;\n      double yb = xa*xb*2.0 + xb*xb;\n\n      /* Subtract from 1 */\n      ya = -ya;\n      yb = -yb;\n\n      double za = 1.0 + ya;\n      double zb = -(za - 1.0 - ya);\n\n      temp = za + yb;\n      zb += -(temp - za - yb);\n      za = temp;\n\n      /* Square root */\n      double y = sqrt(za);\n      temp = y * HEX_40000000;\n      ya = y + temp - temp;\n      yb = y - ya;\n\n      /* Extend precision of sqrt */\n      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      /* Contribution of zb to sqrt */\n      yb += zb / (2.0*y);\n      y = ya+yb;\n      yb = -(y - ya - yb);\n\n      // Compute ratio r = y/x\n      double r = y/x;\n\n      // Did r overflow?\n      if (Double.isInfinite(r)) { // x is effectively zero\n          return Math.PI/2; // so return the appropriate value\n      }\n\n      double ra = doubleHighPart(r);\n      double rb = r - ra;\n\n      rb += (y - ra*xa - ra*xb - rb*xa - rb*xb) / x;  // Correct for rounding in division\n      rb += yb / x;  // Add in effect additional bits of sqrt.\n\n      temp = ra + rb;\n      ra = temp;\n\n      return atan(ra, rb, x<0);\n    }",
          "11": "    public static double acos(double x) {\n      if (x != x) {\n          return Double.NaN;\n      }\n\n      if (x > 1.0 || x < -1.0) {\n          return Double.NaN;\n      }\n\n      if (x == -1.0) {\n          return Math.PI;\n      }\n\n      if (x == 1.0) {\n          return 0.0;\n      }\n\n      if (x == 0) {\n          return Math.PI/2.0;\n      }\n\n      /* Compute acos(x) = atan(sqrt(1-x*x)/x) */\n\n      /* Split x */\n      double temp = x * HEX_40000000;\n      final double xa = x + temp - temp;\n      final double xb = x - xa;\n\n      /* Square it */\n      double ya = xa*xa;\n      double yb = xa*xb*2.0 + xb*xb;\n\n      /* Subtract from 1 */\n      ya = -ya;\n      yb = -yb;\n\n      double za = 1.0 + ya;\n      double zb = -(za - 1.0 - ya);\n\n      temp = za + yb;\n      zb += -(temp - za - yb);\n      za = temp;\n\n      /* Square root */\n      double y = sqrt(za);\n      temp = y * HEX_40000000;\n      ya = y + temp - temp;\n      yb = y - ya;\n\n      /* Extend precision of sqrt */\n      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      /* Contribution of zb to sqrt */\n      yb += zb / (2.0*y);\n      y = ya+yb;\n      yb = -(y - ya - yb);\n\n      // Compute ratio r = y/x\n      double r = y/x;\n\n      // Did r overflow?\n      if (Double.isInfinite(r)) { // x is effectively zero\n          return Math.PI/2; // so return the appropriate value\n      }\n\n      double ra = doubleHighPart(r);\n      double rb = r - ra;\n\n      rb += (y - ra*xa - ra*xb - rb*xa - rb*xb) / x;  // Correct for rounding in division\n      rb += yb / x;  // Add in effect additional bits of sqrt.\n\n      temp = ra + rb;\nrb = ra;\n      ra = temp;\n\n      return atan(ra, rb, x<0);\n    }",
          "12": "    public static double acos(double x) {\n      if (x != x) {\n          return Double.NaN;\n      }\n\n      if (x > 1.0 || x < -1.0) {\n          return Double.NaN;\n      }\n\n      if (x == -1.0) {\n          return Math.PI;\n      }\n\n      if (x == 1.0) {\n          return 0.0;\n      }\n\n      if (x == 0) {\n          return Math.PI/2.0;\n      }\n\n      /* Compute acos(x) = atan(sqrt(1-x*x)/x) */\n\n      /* Split x */\n      double temp = x * HEX_40000000;\n      final double xa = x + temp - temp;\n      final double xb = x - xa;\n\n      /* Square it */\n      double ya = xa*xa;\n      double yb = xa*xb*2.0 + xb*xb;\n\n      /* Subtract from 1 */\n      ya = -ya;\n      yb = -yb;\n\n      double za = 1.0 + ya;\n      double zb = -(za - 1.0 - ya);\n\n      temp = za + yb;\n      zb += -(temp - za - yb);\n      za = temp;\n\n      /* Square root */\n      double y = sqrt(za);\n      temp = y * HEX_40000000;\n      ya = y + temp - temp;\n      yb = y - ya;\n\n      /* Extend precision of sqrt */\n      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      /* Contribution of zb to sqrt */\n      yb += zb / (2.0*y);\n      y = ya+yb;\n      yb = -(y - ya - yb);\n\n      // Compute ratio r = y/x\n      double r = y/x;\n\n      // Did r overflow?\n      if (Double.isInfinite(r)) { // x is effectively zero\n          return Math.PI/2; // so return the appropriate value\n      }\n\n      double ra = doubleHighPart(r);\n      double rb = r - ra;\n\n      rb += (y - ra*xa - ra*xb - rb*xa - rb*xb) / x;  // Correct for rounding in division\n      rb += yb / x;  // Add in effect additional bits of sqrt.\n\n      temp = ra + rb;\nrb = ((temp - ra) / rb);\n      ra = temp;\n\n      return atan(ra, rb, x<0);\n    }",
          "13": "    public static double acos(double x) {\n      if (x != x) {\n          return Double.NaN;\n      }\n\n      if (x > 1.0 || x < -1.0) {\n          return Double.NaN;\n      }\n\n      if (x == -1.0) {\n          return Math.PI;\n      }\n\n      if (x == 1.0) {\n          return 0.0;\n      }\n\n      if (x == 0) {\n          return Math.PI/2.0;\n      }\n\n      /* Compute acos(x) = atan(sqrt(1-x*x)/x) */\n\n      /* Split x */\n      double temp = x * HEX_40000000;\n      final double xa = x + temp - temp;\n      final double xb = x - xa;\n\n      /* Square it */\n      double ya = xa*xa;\n      double yb = xa*xb*2.0 + xb*xb;\n\n      /* Subtract from 1 */\n      ya = -ya;\n      yb = -yb;\n\n      double za = 1.0 + ya;\n      double zb = -(za - 1.0 - ya);\n\n      temp = za + yb;\n      zb += -(temp - za - yb);\n      za = temp;\n\n      /* Square root */\n      double y = sqrt(za);\n      temp = y * HEX_40000000;\n      ya = y + temp - temp;\n      yb = y - ya;\n\n      /* Extend precision of sqrt */\n      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      /* Contribution of zb to sqrt */\n      yb += zb / (2.0*y);\n      y = ya+yb;\n      yb = -(y - ya - yb);\n\n      // Compute ratio r = y/x\n      double r = y/x;\n\n      // Did r overflow?\n      if (Double.isInfinite(r)) { // x is effectively zero\n          return Math.PI/2; // so return the appropriate value\n      }\n\n      double ra = doubleHighPart(r);\n      double rb = r - ra;\n\n      rb += (y - ra*xa - ra*xb - rb*xa - rb*xb) / x;  // Correct for rounding in division\n      rb += yb / x;  // Add in effect additional bits of sqrt.\n\n      temp = ra + rb;\nra = temp;\n      ra = temp;\n\n      return atan(ra, rb, x<0);\n    }",
          "14": "    public static double acos(double x) {\n      if (x != x) {\n          return Double.NaN;\n      }\n\n      if (x > 1.0 || x < -1.0) {\n          return Double.NaN;\n      }\n\n      if (x == -1.0) {\n          return Math.PI;\n      }\n\n      if (x == 1.0) {\n          return 0.0;\n      }\n\n      if (x == 0) {\n          return Math.PI/2.0;\n      }\n\n      /* Compute acos(x) = atan(sqrt(1-x*x)/x) */\n\n      /* Split x */\n      double temp = x * HEX_40000000;\n      final double xa = x + temp - temp;\n      final double xb = x - xa;\n\n      /* Square it */\n      double ya = xa*xa;\n      double yb = xa*xb*2.0 + xb*xb;\n\n      /* Subtract from 1 */\n      ya = -ya;\n      yb = -yb;\n\n      double za = 1.0 + ya;\n      double zb = -(za - 1.0 - ya);\n\n      temp = za + yb;\n      zb += -(temp - za - yb);\n      za = temp;\n\n      /* Square root */\n      double y = sqrt(za);\n      temp = y * HEX_40000000;\n      ya = y + temp - temp;\n      yb = y - ya;\n\n      /* Extend precision of sqrt */\n      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      /* Contribution of zb to sqrt */\n      yb += zb / (2.0*y);\n      y = ya+yb;\n      yb = -(y - ya - yb);\n\n      // Compute ratio r = y/x\n      double r = y/x;\n\n      // Did r overflow?\n      if (Double.isInfinite(r)) { // x is effectively zero\n          return Math.PI/2; // so return the appropriate value\n      }\n\n      double ra = doubleHighPart(r);\n      double rb = r - ra;\n\n      rb += (y - ra*xa - ra*xb - rb*xa - rb*xb) / x;  // Correct for rounding in division\n      rb += yb / x;  // Add in effect additional bits of sqrt.\n\n      temp = ra + rb;\nrb = ((temp - ra) - temp);\n      ra = temp;\n\n      return atan(ra, rb, x<0);\n    }",
          "15": "    public static double acos(double x) {\n      if (x != x) {\n          return Double.NaN;\n      }\n\n      if (x > 1.0 || x < -1.0) {\n          return Double.NaN;\n      }\n\n      if (x == -1.0) {\n          return Math.PI;\n      }\n\n      if (x == 1.0) {\n          return 0.0;\n      }\n\n      if (x == 0) {\n          return Math.PI/2.0;\n      }\n\n      /* Compute acos(x) = atan(sqrt(1-x*x)/x) */\n\n      /* Split x */\n      double temp = x * HEX_40000000;\n      final double xa = x + temp - temp;\n      final double xb = x - xa;\n\n      /* Square it */\n      double ya = xa*xa;\n      double yb = xa*xb*2.0 + xb*xb;\n\n      /* Subtract from 1 */\n      ya = -ya;\n      yb = -yb;\n\n      double za = 1.0 + ya;\n      double zb = -(za - 1.0 - ya);\n\n      temp = za + yb;\n      zb += -(temp - za - yb);\n      za = temp;\n\n      /* Square root */\n      double y = sqrt(za);\n      temp = y * HEX_40000000;\n      ya = y + temp - temp;\n      yb = y - ya;\n\n      /* Extend precision of sqrt */\n      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      /* Contribution of zb to sqrt */\n      yb += zb / (2.0*y);\n      y = ya+yb;\n      yb = -(y - ya - yb);\n\n      // Compute ratio r = y/x\n      double r = y/x;\n\n      // Did r overflow?\n      if (Double.isInfinite(r)) { // x is effectively zero\n          return Math.PI/2; // so return the appropriate value\n      }\n\n      double ra = doubleHighPart(r);\n      double rb = r - ra;\n\n      rb += (y - ra*xa - ra*xb - rb*xa - rb*xb) / x;  // Correct for rounding in division\n      rb += yb / x;  // Add in effect additional bits of sqrt.\n\n      temp = ra + rb;\nrb = ((temp - ra) * rb);\n      ra = temp;\n\n      return atan(ra, rb, x<0);\n    }",
          "16": "    public static double acos(double x) {\n      if (x != x) {\n          return Double.NaN;\n      }\n\n      if (x > 1.0 || x < -1.0) {\n          return Double.NaN;\n      }\n\n      if (x == -1.0) {\n          return Math.PI;\n      }\n\n      if (x == 1.0) {\n          return 0.0;\n      }\n\n      if (x == 0) {\n          return Math.PI/2.0;\n      }\n\n      /* Compute acos(x) = atan(sqrt(1-x*x)/x) */\n\n      /* Split x */\n      double temp = x * HEX_40000000;\n      final double xa = x + temp - temp;\n      final double xb = x - xa;\n\n      /* Square it */\n      double ya = xa*xa;\n      double yb = xa*xb*2.0 + xb*xb;\n\n      /* Subtract from 1 */\n      ya = -ya;\n      yb = -yb;\n\n      double za = 1.0 + ya;\n      double zb = -(za - 1.0 - ya);\n\n      temp = za + yb;\n      zb += -(temp - za - yb);\n      za = temp;\n\n      /* Square root */\n      double y = sqrt(za);\n      temp = y * HEX_40000000;\n      ya = y + temp - temp;\n      yb = y - ya;\n\n      /* Extend precision of sqrt */\n      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      /* Contribution of zb to sqrt */\n      yb += zb / (2.0*y);\n      y = ya+yb;\n      yb = -(y - ya - yb);\n\n      // Compute ratio r = y/x\n      double r = y/x;\n\n      // Did r overflow?\n      if (Double.isInfinite(r)) { // x is effectively zero\n          return Math.PI/2; // so return the appropriate value\n      }\n\n      double ra = doubleHighPart(r);\n      double rb = r - ra;\n\n      rb += (y - ra*xa - ra*xb - rb*xa - rb*xb) / x;  // Correct for rounding in division\n      rb += yb / x;  // Add in effect additional bits of sqrt.\n\n      temp = ra + rb;\ntemp = (ra + rb);\n      ra = temp;\n\n      return atan(ra, rb, x<0);\n    }",
          "17": "    public static double acos(double x) {\n      if (x != x) {\n          return Double.NaN;\n      }\n\n      if (x > 1.0 || x < -1.0) {\n          return Double.NaN;\n      }\n\n      if (x == -1.0) {\n          return Math.PI;\n      }\n\n      if (x == 1.0) {\n          return 0.0;\n      }\n\n      if (x == 0) {\n          return Math.PI/2.0;\n      }\n\n      /* Compute acos(x) = atan(sqrt(1-x*x)/x) */\n\n      /* Split x */\n      double temp = x * HEX_40000000;\n      final double xa = x + temp - temp;\n      final double xb = x - xa;\n\n      /* Square it */\n      double ya = xa*xa;\n      double yb = xa*xb*2.0 + xb*xb;\n\n      /* Subtract from 1 */\n      ya = -ya;\n      yb = -yb;\n\n      double za = 1.0 + ya;\n      double zb = -(za - 1.0 - ya);\n\n      temp = za + yb;\n      zb += -(temp - za - yb);\n      za = temp;\n\n      /* Square root */\n      double y = sqrt(za);\n      temp = y * HEX_40000000;\n      ya = y + temp - temp;\n      yb = y - ya;\n\n      /* Extend precision of sqrt */\n      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      /* Contribution of zb to sqrt */\n      yb += zb / (2.0*y);\n      y = ya+yb;\n      yb = -(y - ya - yb);\n\n      // Compute ratio r = y/x\n      double r = y/x;\n\n      // Did r overflow?\n      if (Double.isInfinite(r)) { // x is effectively zero\n          return Math.PI/2; // so return the appropriate value\n      }\n\n      double ra = doubleHighPart(r);\n      double rb = r - ra;\n\n      rb += (y - ra*xa - ra*xb - rb*xa - rb*xb) / x;  // Correct for rounding in division\n      rb += yb / x;  // Add in effect additional bits of sqrt.\n\n      temp = ra + rb;\nrb = ((temp - ra) - ra);\n      ra = temp;\n\n      return atan(ra, rb, x<0);\n    }",
          "18": "    public static double acos(double x) {\n      if (x != x) {\n          return Double.NaN;\n      }\n\n      if (x > 1.0 || x < -1.0) {\n          return Double.NaN;\n      }\n\n      if (x == -1.0) {\n          return Math.PI;\n      }\n\n      if (x == 1.0) {\n          return 0.0;\n      }\n\n      if (x == 0) {\n          return Math.PI/2.0;\n      }\n\n      /* Compute acos(x) = atan(sqrt(1-x*x)/x) */\n\n      /* Split x */\n      double temp = x * HEX_40000000;\n      final double xa = x + temp - temp;\n      final double xb = x - xa;\n\n      /* Square it */\n      double ya = xa*xa;\n      double yb = xa*xb*2.0 + xb*xb;\n\n      /* Subtract from 1 */\n      ya = -ya;\n      yb = -yb;\n\n      double za = 1.0 + ya;\n      double zb = -(za - 1.0 - ya);\n\n      temp = za + yb;\n      zb += -(temp - za - yb);\n      za = temp;\n\n      /* Square root */\n      double y = sqrt(za);\n      temp = y * HEX_40000000;\n      ya = y + temp - temp;\n      yb = y - ya;\n\n      /* Extend precision of sqrt */\n      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      /* Contribution of zb to sqrt */\n      yb += zb / (2.0*y);\n      y = ya+yb;\n      yb = -(y - ya - yb);\n\n      // Compute ratio r = y/x\n      double r = y/x;\n\n      // Did r overflow?\n      if (Double.isInfinite(r)) { // x is effectively zero\n          return Math.PI/2; // so return the appropriate value\n      }\n\n      double ra = doubleHighPart(r);\n      double rb = r - ra;\n\n      rb += (y - ra*xa - ra*xb - rb*xa - rb*xb) / x;  // Correct for rounding in division\n      rb += yb / x;  // Add in effect additional bits of sqrt.\n\n      temp = ra + rb;\nrb = (ra - ra);\n      ra = temp;\n\n      return atan(ra, rb, x<0);\n    }",
          "19": "    public static double acos(double x) {\n      if (x != x) {\n          return Double.NaN;\n      }\n\n      if (x > 1.0 || x < -1.0) {\n          return Double.NaN;\n      }\n\n      if (x == -1.0) {\n          return Math.PI;\n      }\n\n      if (x == 1.0) {\n          return 0.0;\n      }\n\n      if (x == 0) {\n          return Math.PI/2.0;\n      }\n\n      /* Compute acos(x) = atan(sqrt(1-x*x)/x) */\n\n      /* Split x */\n      double temp = x * HEX_40000000;\n      final double xa = x + temp - temp;\n      final double xb = x - xa;\n\n      /* Square it */\n      double ya = xa*xa;\n      double yb = xa*xb*2.0 + xb*xb;\n\n      /* Subtract from 1 */\n      ya = -ya;\n      yb = -yb;\n\n      double za = 1.0 + ya;\n      double zb = -(za - 1.0 - ya);\n\n      temp = za + yb;\n      zb += -(temp - za - yb);\n      za = temp;\n\n      /* Square root */\n      double y = sqrt(za);\n      temp = y * HEX_40000000;\n      ya = y + temp - temp;\n      yb = y - ya;\n\n      /* Extend precision of sqrt */\n      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      /* Contribution of zb to sqrt */\n      yb += zb / (2.0*y);\n      y = ya+yb;\n      yb = -(y - ya - yb);\n\n      // Compute ratio r = y/x\n      double r = y/x;\n\n      // Did r overflow?\n      if (Double.isInfinite(r)) { // x is effectively zero\n          return Math.PI/2; // so return the appropriate value\n      }\n\n      double ra = doubleHighPart(r);\n      double rb = r - ra;\n\n      rb += (y - ra*xa - ra*xb - rb*xa - rb*xb) / x;  // Correct for rounding in division\n      rb += yb / x;  // Add in effect additional bits of sqrt.\n\n      temp = ra + rb;\nrb = ((ra - ra) - rb);\n      ra = temp;\n\n      return atan(ra, rb, x<0);\n    }",
          "20": "    public static double acos(double x) {\n      if (x != x) {\n          return Double.NaN;\n      }\n\n      if (x > 1.0 || x < -1.0) {\n          return Double.NaN;\n      }\n\n      if (x == -1.0) {\n          return Math.PI;\n      }\n\n      if (x == 1.0) {\n          return 0.0;\n      }\n\n      if (x == 0) {\n          return Math.PI/2.0;\n      }\n\n      /* Compute acos(x) = atan(sqrt(1-x*x)/x) */\n\n      /* Split x */\n      double temp = x * HEX_40000000;\n      final double xa = x + temp - temp;\n      final double xb = x - xa;\n\n      /* Square it */\n      double ya = xa*xa;\n      double yb = xa*xb*2.0 + xb*xb;\n\n      /* Subtract from 1 */\n      ya = -ya;\n      yb = -yb;\n\n      double za = 1.0 + ya;\n      double zb = -(za - 1.0 - ya);\n\n      temp = za + yb;\n      zb += -(temp - za - yb);\n      za = temp;\n\n      /* Square root */\n      double y = sqrt(za);\n      temp = y * HEX_40000000;\n      ya = y + temp - temp;\n      yb = y - ya;\n\n      /* Extend precision of sqrt */\n      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      /* Contribution of zb to sqrt */\n      yb += zb / (2.0*y);\n      y = ya+yb;\n      yb = -(y - ya - yb);\n\n      // Compute ratio r = y/x\n      double r = y/x;\n\n      // Did r overflow?\n      if (Double.isInfinite(r)) { // x is effectively zero\n          return Math.PI/2; // so return the appropriate value\n      }\n\n      double ra = doubleHighPart(r);\n      double rb = r - ra;\n\n      rb += (y - ra*xa - ra*xb - rb*xa - rb*xb) / x;  // Correct for rounding in division\n      rb += yb / x;  // Add in effect additional bits of sqrt.\n\n      temp = ra + rb;\nrb = (ra + ra);\n      ra = temp;\n\n      return atan(ra, rb, x<0);\n    }",
          "21": "    public static double acos(double x) {\n      if (x != x) {\n          return Double.NaN;\n      }\n\n      if (x > 1.0 || x < -1.0) {\n          return Double.NaN;\n      }\n\n      if (x == -1.0) {\n          return Math.PI;\n      }\n\n      if (x == 1.0) {\n          return 0.0;\n      }\n\n      if (x == 0) {\n          return Math.PI/2.0;\n      }\n\n      /* Compute acos(x) = atan(sqrt(1-x*x)/x) */\n\n      /* Split x */\n      double temp = x * HEX_40000000;\n      final double xa = x + temp - temp;\n      final double xb = x - xa;\n\n      /* Square it */\n      double ya = xa*xa;\n      double yb = xa*xb*2.0 + xb*xb;\n\n      /* Subtract from 1 */\n      ya = -ya;\n      yb = -yb;\n\n      double za = 1.0 + ya;\n      double zb = -(za - 1.0 - ya);\n\n      temp = za + yb;\n      zb += -(temp - za - yb);\n      za = temp;\n\n      /* Square root */\n      double y = sqrt(za);\n      temp = y * HEX_40000000;\n      ya = y + temp - temp;\n      yb = y - ya;\n\n      /* Extend precision of sqrt */\n      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      /* Contribution of zb to sqrt */\n      yb += zb / (2.0*y);\n      y = ya+yb;\n      yb = -(y - ya - yb);\n\n      // Compute ratio r = y/x\n      double r = y/x;\n\n      // Did r overflow?\n      if (Double.isInfinite(r)) { // x is effectively zero\n          return Math.PI/2; // so return the appropriate value\n      }\n\n      double ra = doubleHighPart(r);\n      double rb = r - ra;\n\n      rb += (y - ra*xa - ra*xb - rb*xa - rb*xb) / x;  // Correct for rounding in division\n      rb += yb / x;  // Add in effect additional bits of sqrt.\n\n      temp = ra + rb;\nrb = (rb - ra);\n      ra = temp;\n\n      return atan(ra, rb, x<0);\n    }",
          "22": "    public static double acos(double x) {\n      if (x != x) {\n          return Double.NaN;\n      }\n\n      if (x > 1.0 || x < -1.0) {\n          return Double.NaN;\n      }\n\n      if (x == -1.0) {\n          return Math.PI;\n      }\n\n      if (x == 1.0) {\n          return 0.0;\n      }\n\n      if (x == 0) {\n          return Math.PI/2.0;\n      }\n\n      /* Compute acos(x) = atan(sqrt(1-x*x)/x) */\n\n      /* Split x */\n      double temp = x * HEX_40000000;\n      final double xa = x + temp - temp;\n      final double xb = x - xa;\n\n      /* Square it */\n      double ya = xa*xa;\n      double yb = xa*xb*2.0 + xb*xb;\n\n      /* Subtract from 1 */\n      ya = -ya;\n      yb = -yb;\n\n      double za = 1.0 + ya;\n      double zb = -(za - 1.0 - ya);\n\n      temp = za + yb;\n      zb += -(temp - za - yb);\n      za = temp;\n\n      /* Square root */\n      double y = sqrt(za);\n      temp = y * HEX_40000000;\n      ya = y + temp - temp;\n      yb = y - ya;\n\n      /* Extend precision of sqrt */\n      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      /* Contribution of zb to sqrt */\n      yb += zb / (2.0*y);\n      y = ya+yb;\n      yb = -(y - ya - yb);\n\n      // Compute ratio r = y/x\n      double r = y/x;\n\n      // Did r overflow?\n      if (Double.isInfinite(r)) { // x is effectively zero\n          return Math.PI/2; // so return the appropriate value\n      }\n\n      double ra = doubleHighPart(r);\n      double rb = r - ra;\n\n      rb += (y - ra*xa - ra*xb - rb*xa - rb*xb) / x;  // Correct for rounding in division\n      rb += yb / x;  // Add in effect additional bits of sqrt.\n\n      temp = ra + rb;\nrb = ((ra - ra) + ra);\n      ra = temp;\n\n      return atan(ra, rb, x<0);\n    }",
          "23": "    public static double acos(double x) {\n      if (x != x) {\n          return Double.NaN;\n      }\n\n      if (x > 1.0 || x < -1.0) {\n          return Double.NaN;\n      }\n\n      if (x == -1.0) {\n          return Math.PI;\n      }\n\n      if (x == 1.0) {\n          return 0.0;\n      }\n\n      if (x == 0) {\n          return Math.PI/2.0;\n      }\n\n      /* Compute acos(x) = atan(sqrt(1-x*x)/x) */\n\n      /* Split x */\n      double temp = x * HEX_40000000;\n      final double xa = x + temp - temp;\n      final double xb = x - xa;\n\n      /* Square it */\n      double ya = xa*xa;\n      double yb = xa*xb*2.0 + xb*xb;\n\n      /* Subtract from 1 */\n      ya = -ya;\n      yb = -yb;\n\n      double za = 1.0 + ya;\n      double zb = -(za - 1.0 - ya);\n\n      temp = za + yb;\n      zb += -(temp - za - yb);\n      za = temp;\n\n      /* Square root */\n      double y = sqrt(za);\n      temp = y * HEX_40000000;\n      ya = y + temp - temp;\n      yb = y - ya;\n\n      /* Extend precision of sqrt */\n      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      /* Contribution of zb to sqrt */\n      yb += zb / (2.0*y);\n      y = ya+yb;\n      yb = -(y - ya - yb);\n\n      // Compute ratio r = y/x\n      double r = y/x;\n\n      // Did r overflow?\n      if (Double.isInfinite(r)) { // x is effectively zero\n          return Math.PI/2; // so return the appropriate value\n      }\n\n      double ra = doubleHighPart(r);\n      double rb = r - ra;\n\n      rb += (y - ra*xa - ra*xb - rb*xa - rb*xb) / x;  // Correct for rounding in division\n      rb += yb / x;  // Add in effect additional bits of sqrt.\n\n      temp = ra + rb;\nrb = ((ra - ra) - ra);\n      ra = temp;\n\n      return atan(ra, rb, x<0);\n    }",
          "24": "    public static double acos(double x) {\n      if (x != x) {\n          return Double.NaN;\n      }\n\n      if (x > 1.0 || x < -1.0) {\n          return Double.NaN;\n      }\n\n      if (x == -1.0) {\n          return Math.PI;\n      }\n\n      if (x == 1.0) {\n          return 0.0;\n      }\n\n      if (x == 0) {\n          return Math.PI/2.0;\n      }\n\n      /* Compute acos(x) = atan(sqrt(1-x*x)/x) */\n\n      /* Split x */\n      double temp = x * HEX_40000000;\n      final double xa = x + temp - temp;\n      final double xb = x - xa;\n\n      /* Square it */\n      double ya = xa*xa;\n      double yb = xa*xb*2.0 + xb*xb;\n\n      /* Subtract from 1 */\n      ya = -ya;\n      yb = -yb;\n\n      double za = 1.0 + ya;\n      double zb = -(za - 1.0 - ya);\n\n      temp = za + yb;\n      zb += -(temp - za - yb);\n      za = temp;\n\n      /* Square root */\n      double y = sqrt(za);\n      temp = y * HEX_40000000;\n      ya = y + temp - temp;\n      yb = y - ya;\n\n      /* Extend precision of sqrt */\n      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      /* Contribution of zb to sqrt */\n      yb += zb / (2.0*y);\n      y = ya+yb;\n      yb = -(y - ya - yb);\n\n      // Compute ratio r = y/x\n      double r = y/x;\n\n      // Did r overflow?\n      if (Double.isInfinite(r)) { // x is effectively zero\n          return Math.PI/2; // so return the appropriate value\n      }\n\n      double ra = doubleHighPart(r);\n      double rb = r - ra;\n\n      rb += (y - ra*xa - ra*xb - rb*xa - rb*xb) / x;  // Correct for rounding in division\n      rb += yb / x;  // Add in effect additional bits of sqrt.\n\n      temp = ra + rb;\nrb = ((ra + ra) + ra);\n      ra = temp;\n\n      return atan(ra, rb, x<0);\n    }",
          "25": "    public static double acos(double x) {\n      if (x != x) {\n          return Double.NaN;\n      }\n\n      if (x > 1.0 || x < -1.0) {\n          return Double.NaN;\n      }\n\n      if (x == -1.0) {\n          return Math.PI;\n      }\n\n      if (x == 1.0) {\n          return 0.0;\n      }\n\n      if (x == 0) {\n          return Math.PI/2.0;\n      }\n\n      /* Compute acos(x) = atan(sqrt(1-x*x)/x) */\n\n      /* Split x */\n      double temp = x * HEX_40000000;\n      final double xa = x + temp - temp;\n      final double xb = x - xa;\n\n      /* Square it */\n      double ya = xa*xa;\n      double yb = xa*xb*2.0 + xb*xb;\n\n      /* Subtract from 1 */\n      ya = -ya;\n      yb = -yb;\n\n      double za = 1.0 + ya;\n      double zb = -(za - 1.0 - ya);\n\n      temp = za + yb;\n      zb += -(temp - za - yb);\n      za = temp;\n\n      /* Square root */\n      double y = sqrt(za);\n      temp = y * HEX_40000000;\n      ya = y + temp - temp;\n      yb = y - ya;\n\n      /* Extend precision of sqrt */\n      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      /* Contribution of zb to sqrt */\n      yb += zb / (2.0*y);\n      y = ya+yb;\n      yb = -(y - ya - yb);\n\n      // Compute ratio r = y/x\n      double r = y/x;\n\n      // Did r overflow?\n      if (Double.isInfinite(r)) { // x is effectively zero\n          return Math.PI/2; // so return the appropriate value\n      }\n\n      double ra = doubleHighPart(r);\n      double rb = r - ra;\n\n      rb += (y - ra*xa - ra*xb - rb*xa - rb*xb) / x;  // Correct for rounding in division\n      rb += yb / x;  // Add in effect additional bits of sqrt.\n\n      temp = ra + rb;\nrb = ((ra - ra) + rb);\n      ra = temp;\n\n      return atan(ra, rb, x<0);\n    }",
          "26": "    public static double acos(double x) {\n      if (x != x) {\n          return Double.NaN;\n      }\n\n      if (x > 1.0 || x < -1.0) {\n          return Double.NaN;\n      }\n\n      if (x == -1.0) {\n          return Math.PI;\n      }\n\n      if (x == 1.0) {\n          return 0.0;\n      }\n\n      if (x == 0) {\n          return Math.PI/2.0;\n      }\n\n      /* Compute acos(x) = atan(sqrt(1-x*x)/x) */\n\n      /* Split x */\n      double temp = x * HEX_40000000;\n      final double xa = x + temp - temp;\n      final double xb = x - xa;\n\n      /* Square it */\n      double ya = xa*xa;\n      double yb = xa*xb*2.0 + xb*xb;\n\n      /* Subtract from 1 */\n      ya = -ya;\n      yb = -yb;\n\n      double za = 1.0 + ya;\n      double zb = -(za - 1.0 - ya);\n\n      temp = za + yb;\n      zb += -(temp - za - yb);\n      za = temp;\n\n      /* Square root */\n      double y = sqrt(za);\n      temp = y * HEX_40000000;\n      ya = y + temp - temp;\n      yb = y - ya;\n\n      /* Extend precision of sqrt */\n      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      /* Contribution of zb to sqrt */\n      yb += zb / (2.0*y);\n      y = ya+yb;\n      yb = -(y - ya - yb);\n\n      // Compute ratio r = y/x\n      double r = y/x;\n\n      // Did r overflow?\n      if (Double.isInfinite(r)) { // x is effectively zero\n          return Math.PI/2; // so return the appropriate value\n      }\n\n      double ra = doubleHighPart(r);\n      double rb = r - ra;\n\n      rb += (y - ra*xa - ra*xb - rb*xa - rb*xb) / x;  // Correct for rounding in division\n      rb += yb / x;  // Add in effect additional bits of sqrt.\n\n      temp = ra + rb;\nrb = (ra - (ra - ra));\n      ra = temp;\n\n      return atan(ra, rb, x<0);\n    }",
          "27": "    public static double acos(double x) {\n      if (x != x) {\n          return Double.NaN;\n      }\n\n      if (x > 1.0 || x < -1.0) {\n          return Double.NaN;\n      }\n\n      if (x == -1.0) {\n          return Math.PI;\n      }\n\n      if (x == 1.0) {\n          return 0.0;\n      }\n\n      if (x == 0) {\n          return Math.PI/2.0;\n      }\n\n      /* Compute acos(x) = atan(sqrt(1-x*x)/x) */\n\n      /* Split x */\n      double temp = x * HEX_40000000;\n      final double xa = x + temp - temp;\n      final double xb = x - xa;\n\n      /* Square it */\n      double ya = xa*xa;\n      double yb = xa*xb*2.0 + xb*xb;\n\n      /* Subtract from 1 */\n      ya = -ya;\n      yb = -yb;\n\n      double za = 1.0 + ya;\n      double zb = -(za - 1.0 - ya);\n\n      temp = za + yb;\n      zb += -(temp - za - yb);\n      za = temp;\n\n      /* Square root */\n      double y = sqrt(za);\n      temp = y * HEX_40000000;\n      ya = y + temp - temp;\n      yb = y - ya;\n\n      /* Extend precision of sqrt */\n      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      /* Contribution of zb to sqrt */\n      yb += zb / (2.0*y);\n      y = ya+yb;\n      yb = -(y - ya - yb);\n\n      // Compute ratio r = y/x\n      double r = y/x;\n\n      // Did r overflow?\n      if (Double.isInfinite(r)) { // x is effectively zero\n          return Math.PI/2; // so return the appropriate value\n      }\n\n      double ra = doubleHighPart(r);\n      double rb = r - ra;\n\n      rb += (y - ra*xa - ra*xb - rb*xa - rb*xb) / x;  // Correct for rounding in division\n      rb += yb / x;  // Add in effect additional bits of sqrt.\n\n      temp = ra + rb;\nrb = ((ra + ra) - ra);\n      ra = temp;\n\n      return atan(ra, rb, x<0);\n    }",
          "28": "    public static double acos(double x) {\n      if (x != x) {\n          return Double.NaN;\n      }\n\n      if (x > 1.0 || x < -1.0) {\n          return Double.NaN;\n      }\n\n      if (x == -1.0) {\n          return Math.PI;\n      }\n\n      if (x == 1.0) {\n          return 0.0;\n      }\n\n      if (x == 0) {\n          return Math.PI/2.0;\n      }\n\n      /* Compute acos(x) = atan(sqrt(1-x*x)/x) */\n\n      /* Split x */\n      double temp = x * HEX_40000000;\n      final double xa = x + temp - temp;\n      final double xb = x - xa;\n\n      /* Square it */\n      double ya = xa*xa;\n      double yb = xa*xb*2.0 + xb*xb;\n\n      /* Subtract from 1 */\n      ya = -ya;\n      yb = -yb;\n\n      double za = 1.0 + ya;\n      double zb = -(za - 1.0 - ya);\n\n      temp = za + yb;\n      zb += -(temp - za - yb);\n      za = temp;\n\n      /* Square root */\n      double y = sqrt(za);\n      temp = y * HEX_40000000;\n      ya = y + temp - temp;\n      yb = y - ya;\n\n      /* Extend precision of sqrt */\n      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      /* Contribution of zb to sqrt */\n      yb += zb / (2.0*y);\n      y = ya+yb;\n      yb = -(y - ya - yb);\n\n      // Compute ratio r = y/x\n      double r = y/x;\n\n      // Did r overflow?\n      if (Double.isInfinite(r)) { // x is effectively zero\n          return Math.PI/2; // so return the appropriate value\n      }\n\n      double ra = doubleHighPart(r);\n      double rb = r - ra;\n\n      rb += (y - ra*xa - ra*xb - rb*xa - rb*xb) / x;  // Correct for rounding in division\n      rb += yb / x;  // Add in effect additional bits of sqrt.\n\n      temp = ra + rb;\nrb = (ra + (ra - ra));\n      ra = temp;\n\n      return atan(ra, rb, x<0);\n    }",
          "29": "    public static double acos(double x) {\n      if (x != x) {\n          return Double.NaN;\n      }\n\n      if (x > 1.0 || x < -1.0) {\n          return Double.NaN;\n      }\n\n      if (x == -1.0) {\n          return Math.PI;\n      }\n\n      if (x == 1.0) {\n          return 0.0;\n      }\n\n      if (x == 0) {\n          return Math.PI/2.0;\n      }\n\n      /* Compute acos(x) = atan(sqrt(1-x*x)/x) */\n\n      /* Split x */\n      double temp = x * HEX_40000000;\n      final double xa = x + temp - temp;\n      final double xb = x - xa;\n\n      /* Square it */\n      double ya = xa*xa;\n      double yb = xa*xb*2.0 + xb*xb;\n\n      /* Subtract from 1 */\n      ya = -ya;\n      yb = -yb;\n\n      double za = 1.0 + ya;\n      double zb = -(za - 1.0 - ya);\n\n      temp = za + yb;\n      zb += -(temp - za - yb);\n      za = temp;\n\n      /* Square root */\n      double y = sqrt(za);\n      temp = y * HEX_40000000;\n      ya = y + temp - temp;\n      yb = y - ya;\n\n      /* Extend precision of sqrt */\n      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      /* Contribution of zb to sqrt */\n      yb += zb / (2.0*y);\n      y = ya+yb;\n      yb = -(y - ya - yb);\n\n      // Compute ratio r = y/x\n      double r = y/x;\n\n      // Did r overflow?\n      if (Double.isInfinite(r)) { // x is effectively zero\n          return Math.PI/2; // so return the appropriate value\n      }\n\n      double ra = doubleHighPart(r);\n      double rb = r - ra;\n\n      rb += (y - ra*xa - ra*xb - rb*xa - rb*xb) / x;  // Correct for rounding in division\n      rb += yb / x;  // Add in effect additional bits of sqrt.\n\n      temp = ra + rb;\nrb = ((rb - ra) + ra);\n      ra = temp;\n\n      return atan(ra, rb, x<0);\n    }",
          "30": "    public static double acos(double x) {\n      if (x != x) {\n          return Double.NaN;\n      }\n\n      if (x > 1.0 || x < -1.0) {\n          return Double.NaN;\n      }\n\n      if (x == -1.0) {\n          return Math.PI;\n      }\n\n      if (x == 1.0) {\n          return 0.0;\n      }\n\n      if (x == 0) {\n          return Math.PI/2.0;\n      }\n\n      /* Compute acos(x) = atan(sqrt(1-x*x)/x) */\n\n      /* Split x */\n      double temp = x * HEX_40000000;\n      final double xa = x + temp - temp;\n      final double xb = x - xa;\n\n      /* Square it */\n      double ya = xa*xa;\n      double yb = xa*xb*2.0 + xb*xb;\n\n      /* Subtract from 1 */\n      ya = -ya;\n      yb = -yb;\n\n      double za = 1.0 + ya;\n      double zb = -(za - 1.0 - ya);\n\n      temp = za + yb;\n      zb += -(temp - za - yb);\n      za = temp;\n\n      /* Square root */\n      double y = sqrt(za);\n      temp = y * HEX_40000000;\n      ya = y + temp - temp;\n      yb = y - ya;\n\n      /* Extend precision of sqrt */\n      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      /* Contribution of zb to sqrt */\n      yb += zb / (2.0*y);\n      y = ya+yb;\n      yb = -(y - ya - yb);\n\n      // Compute ratio r = y/x\n      double r = y/x;\n\n      // Did r overflow?\n      if (Double.isInfinite(r)) { // x is effectively zero\n          return Math.PI/2; // so return the appropriate value\n      }\n\n      double ra = doubleHighPart(r);\n      double rb = r - ra;\n\n      rb += (y - ra*xa - ra*xb - rb*xa - rb*xb) / x;  // Correct for rounding in division\n      rb += yb / x;  // Add in effect additional bits of sqrt.\n\n      temp = ra + rb;\nrb = (((ra - ra) + rb) + ra);\n      ra = temp;\n\n      return atan(ra, rb, x<0);\n    }",
          "31": "    public static double acos(double x) {\n      if (x != x) {\n          return Double.NaN;\n      }\n\n      if (x > 1.0 || x < -1.0) {\n          return Double.NaN;\n      }\n\n      if (x == -1.0) {\n          return Math.PI;\n      }\n\n      if (x == 1.0) {\n          return 0.0;\n      }\n\n      if (x == 0) {\n          return Math.PI/2.0;\n      }\n\n      /* Compute acos(x) = atan(sqrt(1-x*x)/x) */\n\n      /* Split x */\n      double temp = x * HEX_40000000;\n      final double xa = x + temp - temp;\n      final double xb = x - xa;\n\n      /* Square it */\n      double ya = xa*xa;\n      double yb = xa*xb*2.0 + xb*xb;\n\n      /* Subtract from 1 */\n      ya = -ya;\n      yb = -yb;\n\n      double za = 1.0 + ya;\n      double zb = -(za - 1.0 - ya);\n\n      temp = za + yb;\n      zb += -(temp - za - yb);\n      za = temp;\n\n      /* Square root */\n      double y = sqrt(za);\n      temp = y * HEX_40000000;\n      ya = y + temp - temp;\n      yb = y - ya;\n\n      /* Extend precision of sqrt */\n      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      /* Contribution of zb to sqrt */\n      yb += zb / (2.0*y);\n      y = ya+yb;\n      yb = -(y - ya - yb);\n\n      // Compute ratio r = y/x\n      double r = y/x;\n\n      // Did r overflow?\n      if (Double.isInfinite(r)) { // x is effectively zero\n          return Math.PI/2; // so return the appropriate value\n      }\n\n      double ra = doubleHighPart(r);\n      double rb = r - ra;\n\n      rb += (y - ra*xa - ra*xb - rb*xa - rb*xb) / x;  // Correct for rounding in division\n      rb += yb / x;  // Add in effect additional bits of sqrt.\n\n      temp = ra + rb;\nrb = (((ra - ra) + ra) + ra);\n      ra = temp;\n\n      return atan(ra, rb, x<0);\n    }",
          "32": "    public static double acos(double x) {\n      if (x != x) {\n          return Double.NaN;\n      }\n\n      if (x > 1.0 || x < -1.0) {\n          return Double.NaN;\n      }\n\n      if (x == -1.0) {\n          return Math.PI;\n      }\n\n      if (x == 1.0) {\n          return 0.0;\n      }\n\n      if (x == 0) {\n          return Math.PI/2.0;\n      }\n\n      /* Compute acos(x) = atan(sqrt(1-x*x)/x) */\n\n      /* Split x */\n      double temp = x * HEX_40000000;\n      final double xa = x + temp - temp;\n      final double xb = x - xa;\n\n      /* Square it */\n      double ya = xa*xa;\n      double yb = xa*xb*2.0 + xb*xb;\n\n      /* Subtract from 1 */\n      ya = -ya;\n      yb = -yb;\n\n      double za = 1.0 + ya;\n      double zb = -(za - 1.0 - ya);\n\n      temp = za + yb;\n      zb += -(temp - za - yb);\n      za = temp;\n\n      /* Square root */\n      double y = sqrt(za);\n      temp = y * HEX_40000000;\n      ya = y + temp - temp;\n      yb = y - ya;\n\n      /* Extend precision of sqrt */\n      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      /* Contribution of zb to sqrt */\n      yb += zb / (2.0*y);\n      y = ya+yb;\n      yb = -(y - ya - yb);\n\n      // Compute ratio r = y/x\n      double r = y/x;\n\n      // Did r overflow?\n      if (Double.isInfinite(r)) { // x is effectively zero\n          return Math.PI/2; // so return the appropriate value\n      }\n\n      double ra = doubleHighPart(r);\n      double rb = r - ra;\n\n      rb += (y - ra*xa - ra*xb - rb*xa - rb*xb) / x;  // Correct for rounding in division\n      rb += yb / x;  // Add in effect additional bits of sqrt.\n\n      temp = ra + rb;\nrb = (((ra + ra) + rb) + ra);\n      ra = temp;\n\n      return atan(ra, rb, x<0);\n    }",
          "33": "    public static double acos(double x) {\n      if (x != x) {\n          return Double.NaN;\n      }\n\n      if (x > 1.0 || x < -1.0) {\n          return Double.NaN;\n      }\n\n      if (x == -1.0) {\n          return Math.PI;\n      }\n\n      if (x == 1.0) {\n          return 0.0;\n      }\n\n      if (x == 0) {\n          return Math.PI/2.0;\n      }\n\n      /* Compute acos(x) = atan(sqrt(1-x*x)/x) */\n\n      /* Split x */\n      double temp = x * HEX_40000000;\n      final double xa = x + temp - temp;\n      final double xb = x - xa;\n\n      /* Square it */\n      double ya = xa*xa;\n      double yb = xa*xb*2.0 + xb*xb;\n\n      /* Subtract from 1 */\n      ya = -ya;\n      yb = -yb;\n\n      double za = 1.0 + ya;\n      double zb = -(za - 1.0 - ya);\n\n      temp = za + yb;\n      zb += -(temp - za - yb);\n      za = temp;\n\n      /* Square root */\n      double y = sqrt(za);\n      temp = y * HEX_40000000;\n      ya = y + temp - temp;\n      yb = y - ya;\n\n      /* Extend precision of sqrt */\n      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      /* Contribution of zb to sqrt */\n      yb += zb / (2.0*y);\n      y = ya+yb;\n      yb = -(y - ya - yb);\n\n      // Compute ratio r = y/x\n      double r = y/x;\n\n      // Did r overflow?\n      if (Double.isInfinite(r)) { // x is effectively zero\n          return Math.PI/2; // so return the appropriate value\n      }\n\n      double ra = doubleHighPart(r);\n      double rb = r - ra;\n\n      rb += (y - ra*xa - ra*xb - rb*xa - rb*xb) / x;  // Correct for rounding in division\n      rb += yb / x;  // Add in effect additional bits of sqrt.\n\n      temp = ra + rb;\nrb = (((ra - ra) - ra) + ra);\n      ra = temp;\n\n      return atan(ra, rb, x<0);\n    }",
          "34": "    public static double acos(double x) {\n      if (x != x) {\n          return Double.NaN;\n      }\n\n      if (x > 1.0 || x < -1.0) {\n          return Double.NaN;\n      }\n\n      if (x == -1.0) {\n          return Math.PI;\n      }\n\n      if (x == 1.0) {\n          return 0.0;\n      }\n\n      if (x == 0) {\n          return Math.PI/2.0;\n      }\n\n      /* Compute acos(x) = atan(sqrt(1-x*x)/x) */\n\n      /* Split x */\n      double temp = x * HEX_40000000;\n      final double xa = x + temp - temp;\n      final double xb = x - xa;\n\n      /* Square it */\n      double ya = xa*xa;\n      double yb = xa*xb*2.0 + xb*xb;\n\n      /* Subtract from 1 */\n      ya = -ya;\n      yb = -yb;\n\n      double za = 1.0 + ya;\n      double zb = -(za - 1.0 - ya);\n\n      temp = za + yb;\n      zb += -(temp - za - yb);\n      za = temp;\n\n      /* Square root */\n      double y = sqrt(za);\n      temp = y * HEX_40000000;\n      ya = y + temp - temp;\n      yb = y - ya;\n\n      /* Extend precision of sqrt */\n      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      /* Contribution of zb to sqrt */\n      yb += zb / (2.0*y);\n      y = ya+yb;\n      yb = -(y - ya - yb);\n\n      // Compute ratio r = y/x\n      double r = y/x;\n\n      // Did r overflow?\n      if (Double.isInfinite(r)) { // x is effectively zero\n          return Math.PI/2; // so return the appropriate value\n      }\n\n      double ra = doubleHighPart(r);\n      double rb = r - ra;\n\n      rb += (y - ra*xa - ra*xb - rb*xa - rb*xb) / x;  // Correct for rounding in division\n      rb += yb / x;  // Add in effect additional bits of sqrt.\n\n      temp = ra + rb;\nrb = (((ra + ra) + ra) + ra);\n      ra = temp;\n\n      return atan(ra, rb, x<0);\n    }",
          "35": "    public static double acos(double x) {\n      if (x != x) {\n          return Double.NaN;\n      }\n\n      if (x > 1.0 || x < -1.0) {\n          return Double.NaN;\n      }\n\n      if (x == -1.0) {\n          return Math.PI;\n      }\n\n      if (x == 1.0) {\n          return 0.0;\n      }\n\n      if (x == 0) {\n          return Math.PI/2.0;\n      }\n\n      /* Compute acos(x) = atan(sqrt(1-x*x)/x) */\n\n      /* Split x */\n      double temp = x * HEX_40000000;\n      final double xa = x + temp - temp;\n      final double xb = x - xa;\n\n      /* Square it */\n      double ya = xa*xa;\n      double yb = xa*xb*2.0 + xb*xb;\n\n      /* Subtract from 1 */\n      ya = -ya;\n      yb = -yb;\n\n      double za = 1.0 + ya;\n      double zb = -(za - 1.0 - ya);\n\n      temp = za + yb;\n      zb += -(temp - za - yb);\n      za = temp;\n\n      /* Square root */\n      double y = sqrt(za);\n      temp = y * HEX_40000000;\n      ya = y + temp - temp;\n      yb = y - ya;\n\n      /* Extend precision of sqrt */\n      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      /* Contribution of zb to sqrt */\n      yb += zb / (2.0*y);\n      y = ya+yb;\n      yb = -(y - ya - yb);\n\n      // Compute ratio r = y/x\n      double r = y/x;\n\n      // Did r overflow?\n      if (Double.isInfinite(r)) { // x is effectively zero\n          return Math.PI/2; // so return the appropriate value\n      }\n\n      double ra = doubleHighPart(r);\n      double rb = r - ra;\n\n      rb += (y - ra*xa - ra*xb - rb*xa - rb*xb) / x;  // Correct for rounding in division\n      rb += yb / x;  // Add in effect additional bits of sqrt.\n\n      temp = ra + rb;\nrb = (((ra - ra) - ra) - ra);\n      ra = temp;\n\n      return atan(ra, rb, x<0);\n    }",
          "36": "    public static double acos(double x) {\n      if (x != x) {\n          return Double.NaN;\n      }\n\n      if (x > 1.0 || x < -1.0) {\n          return Double.NaN;\n      }\n\n      if (x == -1.0) {\n          return Math.PI;\n      }\n\n      if (x == 1.0) {\n          return 0.0;\n      }\n\n      if (x == 0) {\n          return Math.PI/2.0;\n      }\n\n      /* Compute acos(x) = atan(sqrt(1-x*x)/x) */\n\n      /* Split x */\n      double temp = x * HEX_40000000;\n      final double xa = x + temp - temp;\n      final double xb = x - xa;\n\n      /* Square it */\n      double ya = xa*xa;\n      double yb = xa*xb*2.0 + xb*xb;\n\n      /* Subtract from 1 */\n      ya = -ya;\n      yb = -yb;\n\n      double za = 1.0 + ya;\n      double zb = -(za - 1.0 - ya);\n\n      temp = za + yb;\n      zb += -(temp - za - yb);\n      za = temp;\n\n      /* Square root */\n      double y = sqrt(za);\n      temp = y * HEX_40000000;\n      ya = y + temp - temp;\n      yb = y - ya;\n\n      /* Extend precision of sqrt */\n      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      /* Contribution of zb to sqrt */\n      yb += zb / (2.0*y);\n      y = ya+yb;\n      yb = -(y - ya - yb);\n\n      // Compute ratio r = y/x\n      double r = y/x;\n\n      // Did r overflow?\n      if (Double.isInfinite(r)) { // x is effectively zero\n          return Math.PI/2; // so return the appropriate value\n      }\n\n      double ra = doubleHighPart(r);\n      double rb = r - ra;\n\n      rb += (y - ra*xa - ra*xb - rb*xa - rb*xb) / x;  // Correct for rounding in division\n      rb += yb / x;  // Add in effect additional bits of sqrt.\n\n      temp = ra + rb;\nrb = (((ra - ra) + ra) + rb);\n      ra = temp;\n\n      return atan(ra, rb, x<0);\n    }",
          "37": "    public static double acos(double x) {\n      if (x != x) {\n          return Double.NaN;\n      }\n\n      if (x > 1.0 || x < -1.0) {\n          return Double.NaN;\n      }\n\n      if (x == -1.0) {\n          return Math.PI;\n      }\n\n      if (x == 1.0) {\n          return 0.0;\n      }\n\n      if (x == 0) {\n          return Math.PI/2.0;\n      }\n\n      /* Compute acos(x) = atan(sqrt(1-x*x)/x) */\n\n      /* Split x */\n      double temp = x * HEX_40000000;\n      final double xa = x + temp - temp;\n      final double xb = x - xa;\n\n      /* Square it */\n      double ya = xa*xa;\n      double yb = xa*xb*2.0 + xb*xb;\n\n      /* Subtract from 1 */\n      ya = -ya;\n      yb = -yb;\n\n      double za = 1.0 + ya;\n      double zb = -(za - 1.0 - ya);\n\n      temp = za + yb;\n      zb += -(temp - za - yb);\n      za = temp;\n\n      /* Square root */\n      double y = sqrt(za);\n      temp = y * HEX_40000000;\n      ya = y + temp - temp;\n      yb = y - ya;\n\n      /* Extend precision of sqrt */\n      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      /* Contribution of zb to sqrt */\n      yb += zb / (2.0*y);\n      y = ya+yb;\n      yb = -(y - ya - yb);\n\n      // Compute ratio r = y/x\n      double r = y/x;\n\n      // Did r overflow?\n      if (Double.isInfinite(r)) { // x is effectively zero\n          return Math.PI/2; // so return the appropriate value\n      }\n\n      double ra = doubleHighPart(r);\n      double rb = r - ra;\n\n      rb += (y - ra*xa - ra*xb - rb*xa - rb*xb) / x;  // Correct for rounding in division\n      rb += yb / x;  // Add in effect additional bits of sqrt.\n\n      temp = ra + rb;\nreturn;\n      rb = +(temp - ra - rb);      ra = temp;\n\n      return atan(ra, rb, x<0);\n    }",
          "38": "    public static double acos(double x) {\n      if (x != x) {\n          return Double.NaN;\n      }\n\n      if (x > 1.0 || x < -1.0) {\n          return Double.NaN;\n      }\n\n      if (x == -1.0) {\n          return Math.PI;\n      }\n\n      if (x == 1.0) {\n          return 0.0;\n      }\n\n      if (x == 0) {\n          return Math.PI/2.0;\n      }\n\n      /* Compute acos(x) = atan(sqrt(1-x*x)/x) */\n\n      /* Split x */\n      double temp = x * HEX_40000000;\n      final double xa = x + temp - temp;\n      final double xb = x - xa;\n\n      /* Square it */\n      double ya = xa*xa;\n      double yb = xa*xb*2.0 + xb*xb;\n\n      /* Subtract from 1 */\n      ya = -ya;\n      yb = -yb;\n\n      double za = 1.0 + ya;\n      double zb = -(za - 1.0 - ya);\n\n      temp = za + yb;\n      zb += -(temp - za - yb);\n      za = temp;\n\n      /* Square root */\n      double y = sqrt(za);\n      temp = y * HEX_40000000;\n      ya = y + temp - temp;\n      yb = y - ya;\n\n      /* Extend precision of sqrt */\n      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      /* Contribution of zb to sqrt */\n      yb += zb / (2.0*y);\n      y = ya+yb;\n      yb = -(y - ya - yb);\n\n      // Compute ratio r = y/x\n      double r = y/x;\n\n      // Did r overflow?\n      if (Double.isInfinite(r)) { // x is effectively zero\n          return Math.PI/2; // so return the appropriate value\n      }\n\n      double ra = doubleHighPart(r);\n      double rb = r - ra;\n\n      rb += (y - ra*xa - ra*xb - rb*xa - rb*xb) / x;  // Correct for rounding in division\n      rb += yb / x;  // Add in effect additional bits of sqrt.\n\n      temp = ra + rb;\n      rb = +(temp - ra - rb);      ra = temp;\n\n      return atan(ra, rb, x<0);\n    }"
}