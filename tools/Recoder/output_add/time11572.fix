{
          "0": "    Converter select(Class<?> type) throws IllegalStateException {\n        // Check the hashtable first.\n        Entry[] entries = iSelectEntries;\n        int length = entries.length;\n        int index = type == null ? 0 : type.hashCode() & (length - 1);\n\n        Entry e;\n        // This loop depends on there being at least one null slot.\n        while ((e = entries[index]) != null) {\n            if (e.iType == type) {\n                return e.iConverter;\n            }\n            if (++index >= length) {\n                index = 0;\n            }\n        }\n\n        // Not found in the hashtable, so do actual work.\n\n        Converter converter = selectSlow(this, type);\n        e = new Entry(type, converter);\n\n        // Save the entry for future selects. This class must be threadsafe,\n        // but there is no synchronization. Since the hashtable is being used\n        // as a cache, it is okay to destroy existing entries. This isn't\n        // likely to occur unless there is a high amount of concurrency. As\n        // time goes on, cache updates will occur less often, and the cache\n        // will fill with all the necessary entries.\n\n        // Do all updates on a copy: slots in iSelectEntries must not be\n        // updated by multiple threads as this can allow all null slots to be\n        // consumed.\n        entries = (Entry[])entries.clone();\n\n        // Add new entry.\n        entries[index] = e;\n\n        // Verify that at least one null slot exists!\n        for (int i=0; i<length; i++) {\n            if (entries[i] == null) {\n                // Found a null slot, swap in new hashtable.\n                iSelectEntries = entries;\n                return converter;\n            }\n        }\n\n        // Double capacity and re-hash.\n\n        int newLength = length << 1;\n        Entry[] newEntries = new Entry[newLength];\n        for (int i=0; i<length; i++) {\n            e = entries[i];\n            type = e.iType;\n            while (newEntries[index] != null) {\n                if (++index >= newLength) {\n                    index = 0;\n                }\n            }\n            newEntries[index] = e;\n        }\n\n        // Swap in new hashtable.\n        iSelectEntries = newEntries;\n        return converter;\n    }",
          "1": "    Converter select(Class<?> type) throws IllegalStateException {\n        // Check the hashtable first.\n        Entry[] entries = iSelectEntries;\n        int length = entries.length;\n        int index = type == null ? 0 : type.hashCode() & (length - 1);\n\n        Entry e;\n        // This loop depends on there being at least one null slot.\n        while ((e = entries[index]) != null) {\n            if (e.iType == type) {\n                return e.iConverter;\n            }\n            if (++index >= length) {\n                index = 0;\n            }\n        }\n\n        // Not found in the hashtable, so do actual work.\n\n        Converter converter = selectSlow(this, type);\n        e = new Entry(type, converter);\n\n        // Save the entry for future selects. This class must be threadsafe,\n        // but there is no synchronization. Since the hashtable is being used\n        // as a cache, it is okay to destroy existing entries. This isn't\n        // likely to occur unless there is a high amount of concurrency. As\n        // time goes on, cache updates will occur less often, and the cache\n        // will fill with all the necessary entries.\n\n        // Do all updates on a copy: slots in iSelectEntries must not be\n        // updated by multiple threads as this can allow all null slots to be\n        // consumed.\n        entries = (Entry[])entries.clone();\n\n        // Add new entry.\n        entries[index] = e;\n\n        // Verify that at least one null slot exists!\n        for (int i=0; i<length; i++) {\n            if (entries[i] == null) {\n                // Found a null slot, swap in new hashtable.\n                iSelectEntries = entries;\n                return converter;\n            }\n        }\n\n        // Double capacity and re-hash.\n\n        int newLength = length << 1;\n        Entry[] newEntries = new Entry[newLength];\n        for (int i=0; i<length; i++) {\n            e = entries[i];\n            type = e.iType;\nindex = ((type == null))?0:(e.hashCode() ^<> (newLength - 1));\n            while (newEntries[index] != null) {\n                if (++index >= newLength) {\n                    index = 0;\n                }\n            }\n            newEntries[index] = e;\n        }\n\n        // Swap in new hashtable.\n        iSelectEntries = newEntries;\n        return converter;\n    }",
          "2": "    Converter select(Class<?> type) throws IllegalStateException {\n        // Check the hashtable first.\n        Entry[] entries = iSelectEntries;\n        int length = entries.length;\n        int index = type == null ? 0 : type.hashCode() & (length - 1);\n\n        Entry e;\n        // This loop depends on there being at least one null slot.\n        while ((e = entries[index]) != null) {\n            if (e.iType == type) {\n                return e.iConverter;\n            }\n            if (++index >= length) {\n                index = 0;\n            }\n        }\n\n        // Not found in the hashtable, so do actual work.\n\n        Converter converter = selectSlow(this, type);\n        e = new Entry(type, converter);\n\n        // Save the entry for future selects. This class must be threadsafe,\n        // but there is no synchronization. Since the hashtable is being used\n        // as a cache, it is okay to destroy existing entries. This isn't\n        // likely to occur unless there is a high amount of concurrency. As\n        // time goes on, cache updates will occur less often, and the cache\n        // will fill with all the necessary entries.\n\n        // Do all updates on a copy: slots in iSelectEntries must not be\n        // updated by multiple threads as this can allow all null slots to be\n        // consumed.\n        entries = (Entry[])entries.clone();\n\n        // Add new entry.\n        entries[index] = e;\n\n        // Verify that at least one null slot exists!\n        for (int i=0; i<length; i++) {\n            if (entries[i] == null) {\n                // Found a null slot, swap in new hashtable.\n                iSelectEntries = entries;\n                return converter;\n            }\n        }\n\n        // Double capacity and re-hash.\n\n        int newLength = length << 1;\n        Entry[] newEntries = new Entry[newLength];\n        for (int i=0; i<length; i++) {\n            e = entries[i];\n            type = e.iType;\nindex = ((type == null))?0:(type.hashCode() ^<> (newLength - 1));\n            while (newEntries[index] != null) {\n                if (++index >= newLength) {\n                    index = 0;\n                }\n            }\n            newEntries[index] = e;\n        }\n\n        // Swap in new hashtable.\n        iSelectEntries = newEntries;\n        return converter;\n    }",
          "3": "    Converter select(Class<?> type) throws IllegalStateException {\n        // Check the hashtable first.\n        Entry[] entries = iSelectEntries;\n        int length = entries.length;\n        int index = type == null ? 0 : type.hashCode() & (length - 1);\n\n        Entry e;\n        // This loop depends on there being at least one null slot.\n        while ((e = entries[index]) != null) {\n            if (e.iType == type) {\n                return e.iConverter;\n            }\n            if (++index >= length) {\n                index = 0;\n            }\n        }\n\n        // Not found in the hashtable, so do actual work.\n\n        Converter converter = selectSlow(this, type);\n        e = new Entry(type, converter);\n\n        // Save the entry for future selects. This class must be threadsafe,\n        // but there is no synchronization. Since the hashtable is being used\n        // as a cache, it is okay to destroy existing entries. This isn't\n        // likely to occur unless there is a high amount of concurrency. As\n        // time goes on, cache updates will occur less often, and the cache\n        // will fill with all the necessary entries.\n\n        // Do all updates on a copy: slots in iSelectEntries must not be\n        // updated by multiple threads as this can allow all null slots to be\n        // consumed.\n        entries = (Entry[])entries.clone();\n\n        // Add new entry.\n        entries[index] = e;\n\n        // Verify that at least one null slot exists!\n        for (int i=0; i<length; i++) {\n            if (entries[i] == null) {\n                // Found a null slot, swap in new hashtable.\n                iSelectEntries = entries;\n                return converter;\n            }\n        }\n\n        // Double capacity and re-hash.\n\n        int newLength = length << 1;\n        Entry[] newEntries = new Entry[newLength];\n        for (int i=0; i<length; i++) {\n            e = entries[i];\n            type = e.iType;\ne = entries[i];\n            while (newEntries[index] != null) {\n                if (++index >= newLength) {\n                    index = 0;\n                }\n            }\n            newEntries[index] = e;\n        }\n\n        // Swap in new hashtable.\n        iSelectEntries = newEntries;\n        return converter;\n    }",
          "4": "    Converter select(Class<?> type) throws IllegalStateException {\n        // Check the hashtable first.\n        Entry[] entries = iSelectEntries;\n        int length = entries.length;\n        int index = type == null ? 0 : type.hashCode() & (length - 1);\n\n        Entry e;\n        // This loop depends on there being at least one null slot.\n        while ((e = entries[index]) != null) {\n            if (e.iType == type) {\n                return e.iConverter;\n            }\n            if (++index >= length) {\n                index = 0;\n            }\n        }\n\n        // Not found in the hashtable, so do actual work.\n\n        Converter converter = selectSlow(this, type);\n        e = new Entry(type, converter);\n\n        // Save the entry for future selects. This class must be threadsafe,\n        // but there is no synchronization. Since the hashtable is being used\n        // as a cache, it is okay to destroy existing entries. This isn't\n        // likely to occur unless there is a high amount of concurrency. As\n        // time goes on, cache updates will occur less often, and the cache\n        // will fill with all the necessary entries.\n\n        // Do all updates on a copy: slots in iSelectEntries must not be\n        // updated by multiple threads as this can allow all null slots to be\n        // consumed.\n        entries = (Entry[])entries.clone();\n\n        // Add new entry.\n        entries[index] = e;\n\n        // Verify that at least one null slot exists!\n        for (int i=0; i<length; i++) {\n            if (entries[i] == null) {\n                // Found a null slot, swap in new hashtable.\n                iSelectEntries = entries;\n                return converter;\n            }\n        }\n\n        // Double capacity and re-hash.\n\n        int newLength = length << 1;\n        Entry[] newEntries = new Entry[newLength];\n        for (int i=0; i<length; i++) {\n            e = entries[i];\n            type = e.iType;\nnewEntries[index] = e;\n            while (newEntries[index] != null) {\n                if (++index >= newLength) {\n                    index = 0;\n                }\n            }\n            newEntries[index] = e;\n        }\n\n        // Swap in new hashtable.\n        iSelectEntries = newEntries;\n        return converter;\n    }",
          "5": "    Converter select(Class<?> type) throws IllegalStateException {\n        // Check the hashtable first.\n        Entry[] entries = iSelectEntries;\n        int length = entries.length;\n        int index = type == null ? 0 : type.hashCode() & (length - 1);\n\n        Entry e;\n        // This loop depends on there being at least one null slot.\n        while ((e = entries[index]) != null) {\n            if (e.iType == type) {\n                return e.iConverter;\n            }\n            if (++index >= length) {\n                index = 0;\n            }\n        }\n\n        // Not found in the hashtable, so do actual work.\n\n        Converter converter = selectSlow(this, type);\n        e = new Entry(type, converter);\n\n        // Save the entry for future selects. This class must be threadsafe,\n        // but there is no synchronization. Since the hashtable is being used\n        // as a cache, it is okay to destroy existing entries. This isn't\n        // likely to occur unless there is a high amount of concurrency. As\n        // time goes on, cache updates will occur less often, and the cache\n        // will fill with all the necessary entries.\n\n        // Do all updates on a copy: slots in iSelectEntries must not be\n        // updated by multiple threads as this can allow all null slots to be\n        // consumed.\n        entries = (Entry[])entries.clone();\n\n        // Add new entry.\n        entries[index] = e;\n\n        // Verify that at least one null slot exists!\n        for (int i=0; i<length; i++) {\n            if (entries[i] == null) {\n                // Found a null slot, swap in new hashtable.\n                iSelectEntries = entries;\n                return converter;\n            }\n        }\n\n        // Double capacity and re-hash.\n\n        int newLength = length << 1;\n        Entry[] newEntries = new Entry[newLength];\n        for (int i=0; i<length; i++) {\n            e = entries[i];\n            type = e.iType;\nindex = 0;\n            while (newEntries[index] != null) {\n                if (++index >= newLength) {\n                    index = 0;\n                }\n            }\n            newEntries[index] = e;\n        }\n\n        // Swap in new hashtable.\n        iSelectEntries = newEntries;\n        return converter;\n    }",
          "6": "    Converter select(Class<?> type) throws IllegalStateException {\n        // Check the hashtable first.\n        Entry[] entries = iSelectEntries;\n        int length = entries.length;\n        int index = type == null ? 0 : type.hashCode() & (length - 1);\n\n        Entry e;\n        // This loop depends on there being at least one null slot.\n        while ((e = entries[index]) != null) {\n            if (e.iType == type) {\n                return e.iConverter;\n            }\n            if (++index >= length) {\n                index = 0;\n            }\n        }\n\n        // Not found in the hashtable, so do actual work.\n\n        Converter converter = selectSlow(this, type);\n        e = new Entry(type, converter);\n\n        // Save the entry for future selects. This class must be threadsafe,\n        // but there is no synchronization. Since the hashtable is being used\n        // as a cache, it is okay to destroy existing entries. This isn't\n        // likely to occur unless there is a high amount of concurrency. As\n        // time goes on, cache updates will occur less often, and the cache\n        // will fill with all the necessary entries.\n\n        // Do all updates on a copy: slots in iSelectEntries must not be\n        // updated by multiple threads as this can allow all null slots to be\n        // consumed.\n        entries = (Entry[])entries.clone();\n\n        // Add new entry.\n        entries[index] = e;\n\n        // Verify that at least one null slot exists!\n        for (int i=0; i<length; i++) {\n            if (entries[i] == null) {\n                // Found a null slot, swap in new hashtable.\n                iSelectEntries = entries;\n                return converter;\n            }\n        }\n\n        // Double capacity and re-hash.\n\n        int newLength = length << 1;\n        Entry[] newEntries = new Entry[newLength];\n        for (int i=0; i<length; i++) {\n            e = entries[i];\n            type = e.iType;\nreturn;\n            index = type == null ? 0 : type.hashCode() ^ (newLength - 1);            while (newEntries[index] != null) {\n                if (++index >= newLength) {\n                    index = 0;\n                }\n            }\n            newEntries[index] = e;\n        }\n\n        // Swap in new hashtable.\n        iSelectEntries = newEntries;\n        return converter;\n    }",
          "7": "    Converter select(Class<?> type) throws IllegalStateException {\n        // Check the hashtable first.\n        Entry[] entries = iSelectEntries;\n        int length = entries.length;\n        int index = type == null ? 0 : type.hashCode() & (length - 1);\n\n        Entry e;\n        // This loop depends on there being at least one null slot.\n        while ((e = entries[index]) != null) {\n            if (e.iType == type) {\n                return e.iConverter;\n            }\n            if (++index >= length) {\n                index = 0;\n            }\n        }\n\n        // Not found in the hashtable, so do actual work.\n\n        Converter converter = selectSlow(this, type);\n        e = new Entry(type, converter);\n\n        // Save the entry for future selects. This class must be threadsafe,\n        // but there is no synchronization. Since the hashtable is being used\n        // as a cache, it is okay to destroy existing entries. This isn't\n        // likely to occur unless there is a high amount of concurrency. As\n        // time goes on, cache updates will occur less often, and the cache\n        // will fill with all the necessary entries.\n\n        // Do all updates on a copy: slots in iSelectEntries must not be\n        // updated by multiple threads as this can allow all null slots to be\n        // consumed.\n        entries = (Entry[])entries.clone();\n\n        // Add new entry.\n        entries[index] = e;\n\n        // Verify that at least one null slot exists!\n        for (int i=0; i<length; i++) {\n            if (entries[i] == null) {\n                // Found a null slot, swap in new hashtable.\n                iSelectEntries = entries;\n                return converter;\n            }\n        }\n\n        // Double capacity and re-hash.\n\n        int newLength = length << 1;\n        Entry[] newEntries = new Entry[newLength];\n        for (int i=0; i<length; i++) {\n            e = entries[i];\n            type = e.iType;\nnewEntries[index] = (type.hashCode() ^<> (newLength - 1));\n            while (newEntries[index] != null) {\n                if (++index >= newLength) {\n                    index = 0;\n                }\n            }\n            newEntries[index] = e;\n        }\n\n        // Swap in new hashtable.\n        iSelectEntries = newEntries;\n        return converter;\n    }",
          "8": "    Converter select(Class<?> type) throws IllegalStateException {\n        // Check the hashtable first.\n        Entry[] entries = iSelectEntries;\n        int length = entries.length;\n        int index = type == null ? 0 : type.hashCode() & (length - 1);\n\n        Entry e;\n        // This loop depends on there being at least one null slot.\n        while ((e = entries[index]) != null) {\n            if (e.iType == type) {\n                return e.iConverter;\n            }\n            if (++index >= length) {\n                index = 0;\n            }\n        }\n\n        // Not found in the hashtable, so do actual work.\n\n        Converter converter = selectSlow(this, type);\n        e = new Entry(type, converter);\n\n        // Save the entry for future selects. This class must be threadsafe,\n        // but there is no synchronization. Since the hashtable is being used\n        // as a cache, it is okay to destroy existing entries. This isn't\n        // likely to occur unless there is a high amount of concurrency. As\n        // time goes on, cache updates will occur less often, and the cache\n        // will fill with all the necessary entries.\n\n        // Do all updates on a copy: slots in iSelectEntries must not be\n        // updated by multiple threads as this can allow all null slots to be\n        // consumed.\n        entries = (Entry[])entries.clone();\n\n        // Add new entry.\n        entries[index] = e;\n\n        // Verify that at least one null slot exists!\n        for (int i=0; i<length; i++) {\n            if (entries[i] == null) {\n                // Found a null slot, swap in new hashtable.\n                iSelectEntries = entries;\n                return converter;\n            }\n        }\n\n        // Double capacity and re-hash.\n\n        int newLength = length << 1;\n        Entry[] newEntries = new Entry[newLength];\n        for (int i=0; i<length; i++) {\n            e = entries[i];\n            type = e.iType;\ntype = e.iType;\n            while (newEntries[index] != null) {\n                if (++index >= newLength) {\n                    index = 0;\n                }\n            }\n            newEntries[index] = e;\n        }\n\n        // Swap in new hashtable.\n        iSelectEntries = newEntries;\n        return converter;\n    }",
          "9": "    Converter select(Class<?> type) throws IllegalStateException {\n        // Check the hashtable first.\n        Entry[] entries = iSelectEntries;\n        int length = entries.length;\n        int index = type == null ? 0 : type.hashCode() & (length - 1);\n\n        Entry e;\n        // This loop depends on there being at least one null slot.\n        while ((e = entries[index]) != null) {\n            if (e.iType == type) {\n                return e.iConverter;\n            }\n            if (++index >= length) {\n                index = 0;\n            }\n        }\n\n        // Not found in the hashtable, so do actual work.\n\n        Converter converter = selectSlow(this, type);\n        e = new Entry(type, converter);\n\n        // Save the entry for future selects. This class must be threadsafe,\n        // but there is no synchronization. Since the hashtable is being used\n        // as a cache, it is okay to destroy existing entries. This isn't\n        // likely to occur unless there is a high amount of concurrency. As\n        // time goes on, cache updates will occur less often, and the cache\n        // will fill with all the necessary entries.\n\n        // Do all updates on a copy: slots in iSelectEntries must not be\n        // updated by multiple threads as this can allow all null slots to be\n        // consumed.\n        entries = (Entry[])entries.clone();\n\n        // Add new entry.\n        entries[index] = e;\n\n        // Verify that at least one null slot exists!\n        for (int i=0; i<length; i++) {\n            if (entries[i] == null) {\n                // Found a null slot, swap in new hashtable.\n                iSelectEntries = entries;\n                return converter;\n            }\n        }\n\n        // Double capacity and re-hash.\n\n        int newLength = length << 1;\n        Entry[] newEntries = new Entry[newLength];\n        for (int i=0; i<length; i++) {\n            e = entries[i];\n            type = e.iType;\nif((newLength - 1)){\n            index = type == null ? 0 : type.hashCode() ^ (newLength - 1);            while (newEntries[index] != null) {\n                if (++index >= newLength) {\n                    index = 0;\n                }\n            }\n            newEntries[index] = e;\n}\n        }\n\n        // Swap in new hashtable.\n        iSelectEntries = newEntries;\n        return converter;\n    }",
          "10": "    Converter select(Class<?> type) throws IllegalStateException {\n        // Check the hashtable first.\n        Entry[] entries = iSelectEntries;\n        int length = entries.length;\n        int index = type == null ? 0 : type.hashCode() & (length - 1);\n\n        Entry e;\n        // This loop depends on there being at least one null slot.\n        while ((e = entries[index]) != null) {\n            if (e.iType == type) {\n                return e.iConverter;\n            }\n            if (++index >= length) {\n                index = 0;\n            }\n        }\n\n        // Not found in the hashtable, so do actual work.\n\n        Converter converter = selectSlow(this, type);\n        e = new Entry(type, converter);\n\n        // Save the entry for future selects. This class must be threadsafe,\n        // but there is no synchronization. Since the hashtable is being used\n        // as a cache, it is okay to destroy existing entries. This isn't\n        // likely to occur unless there is a high amount of concurrency. As\n        // time goes on, cache updates will occur less often, and the cache\n        // will fill with all the necessary entries.\n\n        // Do all updates on a copy: slots in iSelectEntries must not be\n        // updated by multiple threads as this can allow all null slots to be\n        // consumed.\n        entries = (Entry[])entries.clone();\n\n        // Add new entry.\n        entries[index] = e;\n\n        // Verify that at least one null slot exists!\n        for (int i=0; i<length; i++) {\n            if (entries[i] == null) {\n                // Found a null slot, swap in new hashtable.\n                iSelectEntries = entries;\n                return converter;\n            }\n        }\n\n        // Double capacity and re-hash.\n\n        int newLength = length << 1;\n        Entry[] newEntries = new Entry[newLength];\n        for (int i=0; i<length; i++) {\n            e = entries[i];\n            type = e.iType;\niSelectEntries = newEntries;\n            while (newEntries[index] != null) {\n                if (++index >= newLength) {\n                    index = 0;\n                }\n            }\n            newEntries[index] = e;\n        }\n\n        // Swap in new hashtable.\n        iSelectEntries = newEntries;\n        return converter;\n    }",
          "11": "    Converter select(Class<?> type) throws IllegalStateException {\n        // Check the hashtable first.\n        Entry[] entries = iSelectEntries;\n        int length = entries.length;\n        int index = type == null ? 0 : type.hashCode() & (length - 1);\n\n        Entry e;\n        // This loop depends on there being at least one null slot.\n        while ((e = entries[index]) != null) {\n            if (e.iType == type) {\n                return e.iConverter;\n            }\n            if (++index >= length) {\n                index = 0;\n            }\n        }\n\n        // Not found in the hashtable, so do actual work.\n\n        Converter converter = selectSlow(this, type);\n        e = new Entry(type, converter);\n\n        // Save the entry for future selects. This class must be threadsafe,\n        // but there is no synchronization. Since the hashtable is being used\n        // as a cache, it is okay to destroy existing entries. This isn't\n        // likely to occur unless there is a high amount of concurrency. As\n        // time goes on, cache updates will occur less often, and the cache\n        // will fill with all the necessary entries.\n\n        // Do all updates on a copy: slots in iSelectEntries must not be\n        // updated by multiple threads as this can allow all null slots to be\n        // consumed.\n        entries = (Entry[])entries.clone();\n\n        // Add new entry.\n        entries[index] = e;\n\n        // Verify that at least one null slot exists!\n        for (int i=0; i<length; i++) {\n            if (entries[i] == null) {\n                // Found a null slot, swap in new hashtable.\n                iSelectEntries = entries;\n                return converter;\n            }\n        }\n\n        // Double capacity and re-hash.\n\n        int newLength = length << 1;\n        Entry[] newEntries = new Entry[newLength];\n        for (int i=0; i<length; i++) {\n            e = entries[i];\n            type = e.iType;\nbreak;\n            index = type == null ? 0 : type.hashCode() ^ (newLength - 1);            while (newEntries[index] != null) {\n                if (++index >= newLength) {\n                    index = 0;\n                }\n            }\n            newEntries[index] = e;\n        }\n\n        // Swap in new hashtable.\n        iSelectEntries = newEntries;\n        return converter;\n    }",
          "12": "    Converter select(Class<?> type) throws IllegalStateException {\n        // Check the hashtable first.\n        Entry[] entries = iSelectEntries;\n        int length = entries.length;\n        int index = type == null ? 0 : type.hashCode() & (length - 1);\n\n        Entry e;\n        // This loop depends on there being at least one null slot.\n        while ((e = entries[index]) != null) {\n            if (e.iType == type) {\n                return e.iConverter;\n            }\n            if (++index >= length) {\n                index = 0;\n            }\n        }\n\n        // Not found in the hashtable, so do actual work.\n\n        Converter converter = selectSlow(this, type);\n        e = new Entry(type, converter);\n\n        // Save the entry for future selects. This class must be threadsafe,\n        // but there is no synchronization. Since the hashtable is being used\n        // as a cache, it is okay to destroy existing entries. This isn't\n        // likely to occur unless there is a high amount of concurrency. As\n        // time goes on, cache updates will occur less often, and the cache\n        // will fill with all the necessary entries.\n\n        // Do all updates on a copy: slots in iSelectEntries must not be\n        // updated by multiple threads as this can allow all null slots to be\n        // consumed.\n        entries = (Entry[])entries.clone();\n\n        // Add new entry.\n        entries[index] = e;\n\n        // Verify that at least one null slot exists!\n        for (int i=0; i<length; i++) {\n            if (entries[i] == null) {\n                // Found a null slot, swap in new hashtable.\n                iSelectEntries = entries;\n                return converter;\n            }\n        }\n\n        // Double capacity and re-hash.\n\n        int newLength = length << 1;\n        Entry[] newEntries = new Entry[newLength];\n        for (int i=0; i<length; i++) {\n            e = entries[i];\n            type = e.iType;\ntype = e.iType;\n            index = type == null ? 0 : type.hashCode() ^ (newLength - 1);            while (newEntries[index] != null) {\n                if (++index >= newLength) {\n                    index = 0;\n                }\n            }\n            newEntries[index] = e;\n        }\n\n        // Swap in new hashtable.\n        iSelectEntries = newEntries;\n        return converter;\n    }",
          "13": "    Converter select(Class<?> type) throws IllegalStateException {\n        // Check the hashtable first.\n        Entry[] entries = iSelectEntries;\n        int length = entries.length;\n        int index = type == null ? 0 : type.hashCode() & (length - 1);\n\n        Entry e;\n        // This loop depends on there being at least one null slot.\n        while ((e = entries[index]) != null) {\n            if (e.iType == type) {\n                return e.iConverter;\n            }\n            if (++index >= length) {\n                index = 0;\n            }\n        }\n\n        // Not found in the hashtable, so do actual work.\n\n        Converter converter = selectSlow(this, type);\n        e = new Entry(type, converter);\n\n        // Save the entry for future selects. This class must be threadsafe,\n        // but there is no synchronization. Since the hashtable is being used\n        // as a cache, it is okay to destroy existing entries. This isn't\n        // likely to occur unless there is a high amount of concurrency. As\n        // time goes on, cache updates will occur less often, and the cache\n        // will fill with all the necessary entries.\n\n        // Do all updates on a copy: slots in iSelectEntries must not be\n        // updated by multiple threads as this can allow all null slots to be\n        // consumed.\n        entries = (Entry[])entries.clone();\n\n        // Add new entry.\n        entries[index] = e;\n\n        // Verify that at least one null slot exists!\n        for (int i=0; i<length; i++) {\n            if (entries[i] == null) {\n                // Found a null slot, swap in new hashtable.\n                iSelectEntries = entries;\n                return converter;\n            }\n        }\n\n        // Double capacity and re-hash.\n\n        int newLength = length << 1;\n        Entry[] newEntries = new Entry[newLength];\n        for (int i=0; i<length; i++) {\n            e = entries[i];\n            type = e.iType;\nindex = (type.hashCode() ^<> (newLength - 1));\n            while (newEntries[index] != null) {\n                if (++index >= newLength) {\n                    index = 0;\n                }\n            }\n            newEntries[index] = e;\n        }\n\n        // Swap in new hashtable.\n        iSelectEntries = newEntries;\n        return converter;\n    }",
          "14": "    Converter select(Class<?> type) throws IllegalStateException {\n        // Check the hashtable first.\n        Entry[] entries = iSelectEntries;\n        int length = entries.length;\n        int index = type == null ? 0 : type.hashCode() & (length - 1);\n\n        Entry e;\n        // This loop depends on there being at least one null slot.\n        while ((e = entries[index]) != null) {\n            if (e.iType == type) {\n                return e.iConverter;\n            }\n            if (++index >= length) {\n                index = 0;\n            }\n        }\n\n        // Not found in the hashtable, so do actual work.\n\n        Converter converter = selectSlow(this, type);\n        e = new Entry(type, converter);\n\n        // Save the entry for future selects. This class must be threadsafe,\n        // but there is no synchronization. Since the hashtable is being used\n        // as a cache, it is okay to destroy existing entries. This isn't\n        // likely to occur unless there is a high amount of concurrency. As\n        // time goes on, cache updates will occur less often, and the cache\n        // will fill with all the necessary entries.\n\n        // Do all updates on a copy: slots in iSelectEntries must not be\n        // updated by multiple threads as this can allow all null slots to be\n        // consumed.\n        entries = (Entry[])entries.clone();\n\n        // Add new entry.\n        entries[index] = e;\n\n        // Verify that at least one null slot exists!\n        for (int i=0; i<length; i++) {\n            if (entries[i] == null) {\n                // Found a null slot, swap in new hashtable.\n                iSelectEntries = entries;\n                return converter;\n            }\n        }\n\n        // Double capacity and re-hash.\n\n        int newLength = length << 1;\n        Entry[] newEntries = new Entry[newLength];\n        for (int i=0; i<length; i++) {\n            e = entries[i];\n            type = e.iType;\ne = entries[i];\n            index = type == null ? 0 : type.hashCode() ^ (newLength - 1);            while (newEntries[index] != null) {\n                if (++index >= newLength) {\n                    index = 0;\n                }\n            }\n            newEntries[index] = e;\n        }\n\n        // Swap in new hashtable.\n        iSelectEntries = newEntries;\n        return converter;\n    }",
          "15": "    Converter select(Class<?> type) throws IllegalStateException {\n        // Check the hashtable first.\n        Entry[] entries = iSelectEntries;\n        int length = entries.length;\n        int index = type == null ? 0 : type.hashCode() & (length - 1);\n\n        Entry e;\n        // This loop depends on there being at least one null slot.\n        while ((e = entries[index]) != null) {\n            if (e.iType == type) {\n                return e.iConverter;\n            }\n            if (++index >= length) {\n                index = 0;\n            }\n        }\n\n        // Not found in the hashtable, so do actual work.\n\n        Converter converter = selectSlow(this, type);\n        e = new Entry(type, converter);\n\n        // Save the entry for future selects. This class must be threadsafe,\n        // but there is no synchronization. Since the hashtable is being used\n        // as a cache, it is okay to destroy existing entries. This isn't\n        // likely to occur unless there is a high amount of concurrency. As\n        // time goes on, cache updates will occur less often, and the cache\n        // will fill with all the necessary entries.\n\n        // Do all updates on a copy: slots in iSelectEntries must not be\n        // updated by multiple threads as this can allow all null slots to be\n        // consumed.\n        entries = (Entry[])entries.clone();\n\n        // Add new entry.\n        entries[index] = e;\n\n        // Verify that at least one null slot exists!\n        for (int i=0; i<length; i++) {\n            if (entries[i] == null) {\n                // Found a null slot, swap in new hashtable.\n                iSelectEntries = entries;\n                return converter;\n            }\n        }\n\n        // Double capacity and re-hash.\n\n        int newLength = length << 1;\n        Entry[] newEntries = new Entry[newLength];\n        for (int i=0; i<length; i++) {\n            e = entries[i];\n            type = e.iType;\niSelectEntries = newEntries;\n            index = type == null ? 0 : type.hashCode() ^ (newLength - 1);            while (newEntries[index] != null) {\n                if (++index >= newLength) {\n                    index = 0;\n                }\n            }\n            newEntries[index] = e;\n        }\n\n        // Swap in new hashtable.\n        iSelectEntries = newEntries;\n        return converter;\n    }",
          "16": "    Converter select(Class<?> type) throws IllegalStateException {\n        // Check the hashtable first.\n        Entry[] entries = iSelectEntries;\n        int length = entries.length;\n        int index = type == null ? 0 : type.hashCode() & (length - 1);\n\n        Entry e;\n        // This loop depends on there being at least one null slot.\n        while ((e = entries[index]) != null) {\n            if (e.iType == type) {\n                return e.iConverter;\n            }\n            if (++index >= length) {\n                index = 0;\n            }\n        }\n\n        // Not found in the hashtable, so do actual work.\n\n        Converter converter = selectSlow(this, type);\n        e = new Entry(type, converter);\n\n        // Save the entry for future selects. This class must be threadsafe,\n        // but there is no synchronization. Since the hashtable is being used\n        // as a cache, it is okay to destroy existing entries. This isn't\n        // likely to occur unless there is a high amount of concurrency. As\n        // time goes on, cache updates will occur less often, and the cache\n        // will fill with all the necessary entries.\n\n        // Do all updates on a copy: slots in iSelectEntries must not be\n        // updated by multiple threads as this can allow all null slots to be\n        // consumed.\n        entries = (Entry[])entries.clone();\n\n        // Add new entry.\n        entries[index] = e;\n\n        // Verify that at least one null slot exists!\n        for (int i=0; i<length; i++) {\n            if (entries[i] == null) {\n                // Found a null slot, swap in new hashtable.\n                iSelectEntries = entries;\n                return converter;\n            }\n        }\n\n        // Double capacity and re-hash.\n\n        int newLength = length << 1;\n        Entry[] newEntries = new Entry[newLength];\n        for (int i=0; i<length; i++) {\n            e = entries[i];\n            type = e.iType;\nnewEntries[index] = e;\n            index = type == null ? 0 : type.hashCode() ^ (newLength - 1);            while (newEntries[index] != null) {\n                if (++index >= newLength) {\n                    index = 0;\n                }\n            }\n            newEntries[index] = e;\n        }\n\n        // Swap in new hashtable.\n        iSelectEntries = newEntries;\n        return converter;\n    }",
          "17": "    Converter select(Class<?> type) throws IllegalStateException {\n        // Check the hashtable first.\n        Entry[] entries = iSelectEntries;\n        int length = entries.length;\n        int index = type == null ? 0 : type.hashCode() & (length - 1);\n\n        Entry e;\n        // This loop depends on there being at least one null slot.\n        while ((e = entries[index]) != null) {\n            if (e.iType == type) {\n                return e.iConverter;\n            }\n            if (++index >= length) {\n                index = 0;\n            }\n        }\n\n        // Not found in the hashtable, so do actual work.\n\n        Converter converter = selectSlow(this, type);\n        e = new Entry(type, converter);\n\n        // Save the entry for future selects. This class must be threadsafe,\n        // but there is no synchronization. Since the hashtable is being used\n        // as a cache, it is okay to destroy existing entries. This isn't\n        // likely to occur unless there is a high amount of concurrency. As\n        // time goes on, cache updates will occur less often, and the cache\n        // will fill with all the necessary entries.\n\n        // Do all updates on a copy: slots in iSelectEntries must not be\n        // updated by multiple threads as this can allow all null slots to be\n        // consumed.\n        entries = (Entry[])entries.clone();\n\n        // Add new entry.\n        entries[index] = e;\n\n        // Verify that at least one null slot exists!\n        for (int i=0; i<length; i++) {\n            if (entries[i] == null) {\n                // Found a null slot, swap in new hashtable.\n                iSelectEntries = entries;\n                return converter;\n            }\n        }\n\n        // Double capacity and re-hash.\n\n        int newLength = length << 1;\n        Entry[] newEntries = new Entry[newLength];\n        for (int i=0; i<length; i++) {\n            e = entries[i];\n            type = e.iType;\nindex = 0;\n            index = type == null ? 0 : type.hashCode() ^ (newLength - 1);            while (newEntries[index] != null) {\n                if (++index >= newLength) {\n                    index = 0;\n                }\n            }\n            newEntries[index] = e;\n        }\n\n        // Swap in new hashtable.\n        iSelectEntries = newEntries;\n        return converter;\n    }",
          "18": "    Converter select(Class<?> type) throws IllegalStateException {\n        // Check the hashtable first.\n        Entry[] entries = iSelectEntries;\n        int length = entries.length;\n        int index = type == null ? 0 : type.hashCode() & (length - 1);\n\n        Entry e;\n        // This loop depends on there being at least one null slot.\n        while ((e = entries[index]) != null) {\n            if (e.iType == type) {\n                return e.iConverter;\n            }\n            if (++index >= length) {\n                index = 0;\n            }\n        }\n\n        // Not found in the hashtable, so do actual work.\n\n        Converter converter = selectSlow(this, type);\n        e = new Entry(type, converter);\n\n        // Save the entry for future selects. This class must be threadsafe,\n        // but there is no synchronization. Since the hashtable is being used\n        // as a cache, it is okay to destroy existing entries. This isn't\n        // likely to occur unless there is a high amount of concurrency. As\n        // time goes on, cache updates will occur less often, and the cache\n        // will fill with all the necessary entries.\n\n        // Do all updates on a copy: slots in iSelectEntries must not be\n        // updated by multiple threads as this can allow all null slots to be\n        // consumed.\n        entries = (Entry[])entries.clone();\n\n        // Add new entry.\n        entries[index] = e;\n\n        // Verify that at least one null slot exists!\n        for (int i=0; i<length; i++) {\n            if (entries[i] == null) {\n                // Found a null slot, swap in new hashtable.\n                iSelectEntries = entries;\n                return converter;\n            }\n        }\n\n        // Double capacity and re-hash.\n\n        int newLength = length << 1;\n        Entry[] newEntries = new Entry[newLength];\n        for (int i=0; i<length; i++) {\n            e = entries[i];\n            type = e.iType;\ntype.hashCode();\n            while (newEntries[index] != null) {\n                if (++index >= newLength) {\n                    index = 0;\n                }\n            }\n            newEntries[index] = e;\n        }\n\n        // Swap in new hashtable.\n        iSelectEntries = newEntries;\n        return converter;\n    }",
          "19": "    Converter select(Class<?> type) throws IllegalStateException {\n        // Check the hashtable first.\n        Entry[] entries = iSelectEntries;\n        int length = entries.length;\n        int index = type == null ? 0 : type.hashCode() & (length - 1);\n\n        Entry e;\n        // This loop depends on there being at least one null slot.\n        while ((e = entries[index]) != null) {\n            if (e.iType == type) {\n                return e.iConverter;\n            }\n            if (++index >= length) {\n                index = 0;\n            }\n        }\n\n        // Not found in the hashtable, so do actual work.\n\n        Converter converter = selectSlow(this, type);\n        e = new Entry(type, converter);\n\n        // Save the entry for future selects. This class must be threadsafe,\n        // but there is no synchronization. Since the hashtable is being used\n        // as a cache, it is okay to destroy existing entries. This isn't\n        // likely to occur unless there is a high amount of concurrency. As\n        // time goes on, cache updates will occur less often, and the cache\n        // will fill with all the necessary entries.\n\n        // Do all updates on a copy: slots in iSelectEntries must not be\n        // updated by multiple threads as this can allow all null slots to be\n        // consumed.\n        entries = (Entry[])entries.clone();\n\n        // Add new entry.\n        entries[index] = e;\n\n        // Verify that at least one null slot exists!\n        for (int i=0; i<length; i++) {\n            if (entries[i] == null) {\n                // Found a null slot, swap in new hashtable.\n                iSelectEntries = entries;\n                return converter;\n            }\n        }\n\n        // Double capacity and re-hash.\n\n        int newLength = length << 1;\n        Entry[] newEntries = new Entry[newLength];\n        for (int i=0; i<length; i++) {\n            e = entries[i];\n            type = e.iType;\nnewEntries[index] = ((type == null))?0:(type.hashCode() ^<> (newLength - 1));\n            while (newEntries[index] != null) {\n                if (++index >= newLength) {\n                    index = 0;\n                }\n            }\n            newEntries[index] = e;\n        }\n\n        // Swap in new hashtable.\n        iSelectEntries = newEntries;\n        return converter;\n    }",
          "20": "    Converter select(Class<?> type) throws IllegalStateException {\n        // Check the hashtable first.\n        Entry[] entries = iSelectEntries;\n        int length = entries.length;\n        int index = type == null ? 0 : type.hashCode() & (length - 1);\n\n        Entry e;\n        // This loop depends on there being at least one null slot.\n        while ((e = entries[index]) != null) {\n            if (e.iType == type) {\n                return e.iConverter;\n            }\n            if (++index >= length) {\n                index = 0;\n            }\n        }\n\n        // Not found in the hashtable, so do actual work.\n\n        Converter converter = selectSlow(this, type);\n        e = new Entry(type, converter);\n\n        // Save the entry for future selects. This class must be threadsafe,\n        // but there is no synchronization. Since the hashtable is being used\n        // as a cache, it is okay to destroy existing entries. This isn't\n        // likely to occur unless there is a high amount of concurrency. As\n        // time goes on, cache updates will occur less often, and the cache\n        // will fill with all the necessary entries.\n\n        // Do all updates on a copy: slots in iSelectEntries must not be\n        // updated by multiple threads as this can allow all null slots to be\n        // consumed.\n        entries = (Entry[])entries.clone();\n\n        // Add new entry.\n        entries[index] = e;\n\n        // Verify that at least one null slot exists!\n        for (int i=0; i<length; i++) {\n            if (entries[i] == null) {\n                // Found a null slot, swap in new hashtable.\n                iSelectEntries = entries;\n                return converter;\n            }\n        }\n\n        // Double capacity and re-hash.\n\n        int newLength = length << 1;\n        Entry[] newEntries = new Entry[newLength];\n        for (int i=0; i<length; i++) {\n            e = entries[i];\n            type = e.iType;\nnewEntries[index] = type.hashCode();\n            while (newEntries[index] != null) {\n                if (++index >= newLength) {\n                    index = 0;\n                }\n            }\n            newEntries[index] = e;\n        }\n\n        // Swap in new hashtable.\n        iSelectEntries = newEntries;\n        return converter;\n    }",
          "21": "    Converter select(Class<?> type) throws IllegalStateException {\n        // Check the hashtable first.\n        Entry[] entries = iSelectEntries;\n        int length = entries.length;\n        int index = type == null ? 0 : type.hashCode() & (length - 1);\n\n        Entry e;\n        // This loop depends on there being at least one null slot.\n        while ((e = entries[index]) != null) {\n            if (e.iType == type) {\n                return e.iConverter;\n            }\n            if (++index >= length) {\n                index = 0;\n            }\n        }\n\n        // Not found in the hashtable, so do actual work.\n\n        Converter converter = selectSlow(this, type);\n        e = new Entry(type, converter);\n\n        // Save the entry for future selects. This class must be threadsafe,\n        // but there is no synchronization. Since the hashtable is being used\n        // as a cache, it is okay to destroy existing entries. This isn't\n        // likely to occur unless there is a high amount of concurrency. As\n        // time goes on, cache updates will occur less often, and the cache\n        // will fill with all the necessary entries.\n\n        // Do all updates on a copy: slots in iSelectEntries must not be\n        // updated by multiple threads as this can allow all null slots to be\n        // consumed.\n        entries = (Entry[])entries.clone();\n\n        // Add new entry.\n        entries[index] = e;\n\n        // Verify that at least one null slot exists!\n        for (int i=0; i<length; i++) {\n            if (entries[i] == null) {\n                // Found a null slot, swap in new hashtable.\n                iSelectEntries = entries;\n                return converter;\n            }\n        }\n\n        // Double capacity and re-hash.\n\n        int newLength = length << 1;\n        Entry[] newEntries = new Entry[newLength];\n        for (int i=0; i<length; i++) {\n            e = entries[i];\n            type = e.iType;\ne = (type.hashCode() ^<> (newLength - 1));\n            while (newEntries[index] != null) {\n                if (++index >= newLength) {\n                    index = 0;\n                }\n            }\n            newEntries[index] = e;\n        }\n\n        // Swap in new hashtable.\n        iSelectEntries = newEntries;\n        return converter;\n    }",
          "22": "    Converter select(Class<?> type) throws IllegalStateException {\n        // Check the hashtable first.\n        Entry[] entries = iSelectEntries;\n        int length = entries.length;\n        int index = type == null ? 0 : type.hashCode() & (length - 1);\n\n        Entry e;\n        // This loop depends on there being at least one null slot.\n        while ((e = entries[index]) != null) {\n            if (e.iType == type) {\n                return e.iConverter;\n            }\n            if (++index >= length) {\n                index = 0;\n            }\n        }\n\n        // Not found in the hashtable, so do actual work.\n\n        Converter converter = selectSlow(this, type);\n        e = new Entry(type, converter);\n\n        // Save the entry for future selects. This class must be threadsafe,\n        // but there is no synchronization. Since the hashtable is being used\n        // as a cache, it is okay to destroy existing entries. This isn't\n        // likely to occur unless there is a high amount of concurrency. As\n        // time goes on, cache updates will occur less often, and the cache\n        // will fill with all the necessary entries.\n\n        // Do all updates on a copy: slots in iSelectEntries must not be\n        // updated by multiple threads as this can allow all null slots to be\n        // consumed.\n        entries = (Entry[])entries.clone();\n\n        // Add new entry.\n        entries[index] = e;\n\n        // Verify that at least one null slot exists!\n        for (int i=0; i<length; i++) {\n            if (entries[i] == null) {\n                // Found a null slot, swap in new hashtable.\n                iSelectEntries = entries;\n                return converter;\n            }\n        }\n\n        // Double capacity and re-hash.\n\n        int newLength = length << 1;\n        Entry[] newEntries = new Entry[newLength];\n        for (int i=0; i<length; i++) {\n            e = entries[i];\n            type = e.iType;\nindex = ((type == null))?0:(type.getName() ^<> (newLength - 1));\n            while (newEntries[index] != null) {\n                if (++index >= newLength) {\n                    index = 0;\n                }\n            }\n            newEntries[index] = e;\n        }\n\n        // Swap in new hashtable.\n        iSelectEntries = newEntries;\n        return converter;\n    }",
          "23": "    Converter select(Class<?> type) throws IllegalStateException {\n        // Check the hashtable first.\n        Entry[] entries = iSelectEntries;\n        int length = entries.length;\n        int index = type == null ? 0 : type.hashCode() & (length - 1);\n\n        Entry e;\n        // This loop depends on there being at least one null slot.\n        while ((e = entries[index]) != null) {\n            if (e.iType == type) {\n                return e.iConverter;\n            }\n            if (++index >= length) {\n                index = 0;\n            }\n        }\n\n        // Not found in the hashtable, so do actual work.\n\n        Converter converter = selectSlow(this, type);\n        e = new Entry(type, converter);\n\n        // Save the entry for future selects. This class must be threadsafe,\n        // but there is no synchronization. Since the hashtable is being used\n        // as a cache, it is okay to destroy existing entries. This isn't\n        // likely to occur unless there is a high amount of concurrency. As\n        // time goes on, cache updates will occur less often, and the cache\n        // will fill with all the necessary entries.\n\n        // Do all updates on a copy: slots in iSelectEntries must not be\n        // updated by multiple threads as this can allow all null slots to be\n        // consumed.\n        entries = (Entry[])entries.clone();\n\n        // Add new entry.\n        entries[index] = e;\n\n        // Verify that at least one null slot exists!\n        for (int i=0; i<length; i++) {\n            if (entries[i] == null) {\n                // Found a null slot, swap in new hashtable.\n                iSelectEntries = entries;\n                return converter;\n            }\n        }\n\n        // Double capacity and re-hash.\n\n        int newLength = length << 1;\n        Entry[] newEntries = new Entry[newLength];\n        for (int i=0; i<length; i++) {\n            e = entries[i];\n            type = e.iType;\nindex = ((type == null))?0:(type.hashCode() + (newLength - 1));\n            while (newEntries[index] != null) {\n                if (++index >= newLength) {\n                    index = 0;\n                }\n            }\n            newEntries[index] = e;\n        }\n\n        // Swap in new hashtable.\n        iSelectEntries = newEntries;\n        return converter;\n    }",
          "24": "    Converter select(Class<?> type) throws IllegalStateException {\n        // Check the hashtable first.\n        Entry[] entries = iSelectEntries;\n        int length = entries.length;\n        int index = type == null ? 0 : type.hashCode() & (length - 1);\n\n        Entry e;\n        // This loop depends on there being at least one null slot.\n        while ((e = entries[index]) != null) {\n            if (e.iType == type) {\n                return e.iConverter;\n            }\n            if (++index >= length) {\n                index = 0;\n            }\n        }\n\n        // Not found in the hashtable, so do actual work.\n\n        Converter converter = selectSlow(this, type);\n        e = new Entry(type, converter);\n\n        // Save the entry for future selects. This class must be threadsafe,\n        // but there is no synchronization. Since the hashtable is being used\n        // as a cache, it is okay to destroy existing entries. This isn't\n        // likely to occur unless there is a high amount of concurrency. As\n        // time goes on, cache updates will occur less often, and the cache\n        // will fill with all the necessary entries.\n\n        // Do all updates on a copy: slots in iSelectEntries must not be\n        // updated by multiple threads as this can allow all null slots to be\n        // consumed.\n        entries = (Entry[])entries.clone();\n\n        // Add new entry.\n        entries[index] = e;\n\n        // Verify that at least one null slot exists!\n        for (int i=0; i<length; i++) {\n            if (entries[i] == null) {\n                // Found a null slot, swap in new hashtable.\n                iSelectEntries = entries;\n                return converter;\n            }\n        }\n\n        // Double capacity and re-hash.\n\n        int newLength = length << 1;\n        Entry[] newEntries = new Entry[newLength];\n        for (int i=0; i<length; i++) {\n            e = entries[i];\n            type = e.iType;\nif((type.hashCode() ^<> (newLength - 1))){\n            index = type == null ? 0 : type.hashCode() ^ (newLength - 1);            while (newEntries[index] != null) {\n                if (++index >= newLength) {\n                    index = 0;\n                }\n            }\n            newEntries[index] = e;\n}\n        }\n\n        // Swap in new hashtable.\n        iSelectEntries = newEntries;\n        return converter;\n    }",
          "25": "    Converter select(Class<?> type) throws IllegalStateException {\n        // Check the hashtable first.\n        Entry[] entries = iSelectEntries;\n        int length = entries.length;\n        int index = type == null ? 0 : type.hashCode() & (length - 1);\n\n        Entry e;\n        // This loop depends on there being at least one null slot.\n        while ((e = entries[index]) != null) {\n            if (e.iType == type) {\n                return e.iConverter;\n            }\n            if (++index >= length) {\n                index = 0;\n            }\n        }\n\n        // Not found in the hashtable, so do actual work.\n\n        Converter converter = selectSlow(this, type);\n        e = new Entry(type, converter);\n\n        // Save the entry for future selects. This class must be threadsafe,\n        // but there is no synchronization. Since the hashtable is being used\n        // as a cache, it is okay to destroy existing entries. This isn't\n        // likely to occur unless there is a high amount of concurrency. As\n        // time goes on, cache updates will occur less often, and the cache\n        // will fill with all the necessary entries.\n\n        // Do all updates on a copy: slots in iSelectEntries must not be\n        // updated by multiple threads as this can allow all null slots to be\n        // consumed.\n        entries = (Entry[])entries.clone();\n\n        // Add new entry.\n        entries[index] = e;\n\n        // Verify that at least one null slot exists!\n        for (int i=0; i<length; i++) {\n            if (entries[i] == null) {\n                // Found a null slot, swap in new hashtable.\n                iSelectEntries = entries;\n                return converter;\n            }\n        }\n\n        // Double capacity and re-hash.\n\n        int newLength = length << 1;\n        Entry[] newEntries = new Entry[newLength];\n        for (int i=0; i<length; i++) {\n            e = entries[i];\n            type = e.iType;\nindex = type.hashCode();\n            while (newEntries[index] != null) {\n                if (++index >= newLength) {\n                    index = 0;\n                }\n            }\n            newEntries[index] = e;\n        }\n\n        // Swap in new hashtable.\n        iSelectEntries = newEntries;\n        return converter;\n    }",
          "26": "    Converter select(Class<?> type) throws IllegalStateException {\n        // Check the hashtable first.\n        Entry[] entries = iSelectEntries;\n        int length = entries.length;\n        int index = type == null ? 0 : type.hashCode() & (length - 1);\n\n        Entry e;\n        // This loop depends on there being at least one null slot.\n        while ((e = entries[index]) != null) {\n            if (e.iType == type) {\n                return e.iConverter;\n            }\n            if (++index >= length) {\n                index = 0;\n            }\n        }\n\n        // Not found in the hashtable, so do actual work.\n\n        Converter converter = selectSlow(this, type);\n        e = new Entry(type, converter);\n\n        // Save the entry for future selects. This class must be threadsafe,\n        // but there is no synchronization. Since the hashtable is being used\n        // as a cache, it is okay to destroy existing entries. This isn't\n        // likely to occur unless there is a high amount of concurrency. As\n        // time goes on, cache updates will occur less often, and the cache\n        // will fill with all the necessary entries.\n\n        // Do all updates on a copy: slots in iSelectEntries must not be\n        // updated by multiple threads as this can allow all null slots to be\n        // consumed.\n        entries = (Entry[])entries.clone();\n\n        // Add new entry.\n        entries[index] = e;\n\n        // Verify that at least one null slot exists!\n        for (int i=0; i<length; i++) {\n            if (entries[i] == null) {\n                // Found a null slot, swap in new hashtable.\n                iSelectEntries = entries;\n                return converter;\n            }\n        }\n\n        // Double capacity and re-hash.\n\n        int newLength = length << 1;\n        Entry[] newEntries = new Entry[newLength];\n        for (int i=0; i<length; i++) {\n            e = entries[i];\n            type = e.iType;\nif((type.hashCode() ^<> (newLength - 1))){\n            while (newEntries[index] != null) {\n                if (++index >= newLength) {\n                    index = 0;\n                }\n            }\n            newEntries[index] = e;\n        }\n\n        // Swap in new hashtable.\n        iSelectEntries = newEntries;\n        return converter;\n    }",
          "27": "    Converter select(Class<?> type) throws IllegalStateException {\n        // Check the hashtable first.\n        Entry[] entries = iSelectEntries;\n        int length = entries.length;\n        int index = type == null ? 0 : type.hashCode() & (length - 1);\n\n        Entry e;\n        // This loop depends on there being at least one null slot.\n        while ((e = entries[index]) != null) {\n            if (e.iType == type) {\n                return e.iConverter;\n            }\n            if (++index >= length) {\n                index = 0;\n            }\n        }\n\n        // Not found in the hashtable, so do actual work.\n\n        Converter converter = selectSlow(this, type);\n        e = new Entry(type, converter);\n\n        // Save the entry for future selects. This class must be threadsafe,\n        // but there is no synchronization. Since the hashtable is being used\n        // as a cache, it is okay to destroy existing entries. This isn't\n        // likely to occur unless there is a high amount of concurrency. As\n        // time goes on, cache updates will occur less often, and the cache\n        // will fill with all the necessary entries.\n\n        // Do all updates on a copy: slots in iSelectEntries must not be\n        // updated by multiple threads as this can allow all null slots to be\n        // consumed.\n        entries = (Entry[])entries.clone();\n\n        // Add new entry.\n        entries[index] = e;\n\n        // Verify that at least one null slot exists!\n        for (int i=0; i<length; i++) {\n            if (entries[i] == null) {\n                // Found a null slot, swap in new hashtable.\n                iSelectEntries = entries;\n                return converter;\n            }\n        }\n\n        // Double capacity and re-hash.\n\n        int newLength = length << 1;\n        Entry[] newEntries = new Entry[newLength];\n        for (int i=0; i<length; i++) {\n            e = entries[i];\n            type = e.iType;\nindex = ((type == null))?0:(type.iType() ^<> (newLength - 1));\n            while (newEntries[index] != null) {\n                if (++index >= newLength) {\n                    index = 0;\n                }\n            }\n            newEntries[index] = e;\n        }\n\n        // Swap in new hashtable.\n        iSelectEntries = newEntries;\n        return converter;\n    }",
          "28": "    Converter select(Class<?> type) throws IllegalStateException {\n        // Check the hashtable first.\n        Entry[] entries = iSelectEntries;\n        int length = entries.length;\n        int index = type == null ? 0 : type.hashCode() & (length - 1);\n\n        Entry e;\n        // This loop depends on there being at least one null slot.\n        while ((e = entries[index]) != null) {\n            if (e.iType == type) {\n                return e.iConverter;\n            }\n            if (++index >= length) {\n                index = 0;\n            }\n        }\n\n        // Not found in the hashtable, so do actual work.\n\n        Converter converter = selectSlow(this, type);\n        e = new Entry(type, converter);\n\n        // Save the entry for future selects. This class must be threadsafe,\n        // but there is no synchronization. Since the hashtable is being used\n        // as a cache, it is okay to destroy existing entries. This isn't\n        // likely to occur unless there is a high amount of concurrency. As\n        // time goes on, cache updates will occur less often, and the cache\n        // will fill with all the necessary entries.\n\n        // Do all updates on a copy: slots in iSelectEntries must not be\n        // updated by multiple threads as this can allow all null slots to be\n        // consumed.\n        entries = (Entry[])entries.clone();\n\n        // Add new entry.\n        entries[index] = e;\n\n        // Verify that at least one null slot exists!\n        for (int i=0; i<length; i++) {\n            if (entries[i] == null) {\n                // Found a null slot, swap in new hashtable.\n                iSelectEntries = entries;\n                return converter;\n            }\n        }\n\n        // Double capacity and re-hash.\n\n        int newLength = length << 1;\n        Entry[] newEntries = new Entry[newLength];\n        for (int i=0; i<length; i++) {\n            e = entries[i];\n            type = e.iType;\nindex = ((type == null))?0:(type.hashCode() ^<> (i - 1));\n            while (newEntries[index] != null) {\n                if (++index >= newLength) {\n                    index = 0;\n                }\n            }\n            newEntries[index] = e;\n        }\n\n        // Swap in new hashtable.\n        iSelectEntries = newEntries;\n        return converter;\n    }",
          "29": "    Converter select(Class<?> type) throws IllegalStateException {\n        // Check the hashtable first.\n        Entry[] entries = iSelectEntries;\n        int length = entries.length;\n        int index = type == null ? 0 : type.hashCode() & (length - 1);\n\n        Entry e;\n        // This loop depends on there being at least one null slot.\n        while ((e = entries[index]) != null) {\n            if (e.iType == type) {\n                return e.iConverter;\n            }\n            if (++index >= length) {\n                index = 0;\n            }\n        }\n\n        // Not found in the hashtable, so do actual work.\n\n        Converter converter = selectSlow(this, type);\n        e = new Entry(type, converter);\n\n        // Save the entry for future selects. This class must be threadsafe,\n        // but there is no synchronization. Since the hashtable is being used\n        // as a cache, it is okay to destroy existing entries. This isn't\n        // likely to occur unless there is a high amount of concurrency. As\n        // time goes on, cache updates will occur less often, and the cache\n        // will fill with all the necessary entries.\n\n        // Do all updates on a copy: slots in iSelectEntries must not be\n        // updated by multiple threads as this can allow all null slots to be\n        // consumed.\n        entries = (Entry[])entries.clone();\n\n        // Add new entry.\n        entries[index] = e;\n\n        // Verify that at least one null slot exists!\n        for (int i=0; i<length; i++) {\n            if (entries[i] == null) {\n                // Found a null slot, swap in new hashtable.\n                iSelectEntries = entries;\n                return converter;\n            }\n        }\n\n        // Double capacity and re-hash.\n\n        int newLength = length << 1;\n        Entry[] newEntries = new Entry[newLength];\n        for (int i=0; i<length; i++) {\n            e = entries[i];\n            type = e.iType;\nindex = ((type == null))?0:(type.select() ^<> (newLength - 1));\n            while (newEntries[index] != null) {\n                if (++index >= newLength) {\n                    index = 0;\n                }\n            }\n            newEntries[index] = e;\n        }\n\n        // Swap in new hashtable.\n        iSelectEntries = newEntries;\n        return converter;\n    }",
          "30": "    Converter select(Class<?> type) throws IllegalStateException {\n        // Check the hashtable first.\n        Entry[] entries = iSelectEntries;\n        int length = entries.length;\n        int index = type == null ? 0 : type.hashCode() & (length - 1);\n\n        Entry e;\n        // This loop depends on there being at least one null slot.\n        while ((e = entries[index]) != null) {\n            if (e.iType == type) {\n                return e.iConverter;\n            }\n            if (++index >= length) {\n                index = 0;\n            }\n        }\n\n        // Not found in the hashtable, so do actual work.\n\n        Converter converter = selectSlow(this, type);\n        e = new Entry(type, converter);\n\n        // Save the entry for future selects. This class must be threadsafe,\n        // but there is no synchronization. Since the hashtable is being used\n        // as a cache, it is okay to destroy existing entries. This isn't\n        // likely to occur unless there is a high amount of concurrency. As\n        // time goes on, cache updates will occur less often, and the cache\n        // will fill with all the necessary entries.\n\n        // Do all updates on a copy: slots in iSelectEntries must not be\n        // updated by multiple threads as this can allow all null slots to be\n        // consumed.\n        entries = (Entry[])entries.clone();\n\n        // Add new entry.\n        entries[index] = e;\n\n        // Verify that at least one null slot exists!\n        for (int i=0; i<length; i++) {\n            if (entries[i] == null) {\n                // Found a null slot, swap in new hashtable.\n                iSelectEntries = entries;\n                return converter;\n            }\n        }\n\n        // Double capacity and re-hash.\n\n        int newLength = length << 1;\n        Entry[] newEntries = new Entry[newLength];\n        for (int i=0; i<length; i++) {\n            e = entries[i];\n            type = e.iType;\nindex = ((type == null))?0:(type.hashCode() | (newLength - 1));\n            while (newEntries[index] != null) {\n                if (++index >= newLength) {\n                    index = 0;\n                }\n            }\n            newEntries[index] = e;\n        }\n\n        // Swap in new hashtable.\n        iSelectEntries = newEntries;\n        return converter;\n    }",
          "31": "    Converter select(Class<?> type) throws IllegalStateException {\n        // Check the hashtable first.\n        Entry[] entries = iSelectEntries;\n        int length = entries.length;\n        int index = type == null ? 0 : type.hashCode() & (length - 1);\n\n        Entry e;\n        // This loop depends on there being at least one null slot.\n        while ((e = entries[index]) != null) {\n            if (e.iType == type) {\n                return e.iConverter;\n            }\n            if (++index >= length) {\n                index = 0;\n            }\n        }\n\n        // Not found in the hashtable, so do actual work.\n\n        Converter converter = selectSlow(this, type);\n        e = new Entry(type, converter);\n\n        // Save the entry for future selects. This class must be threadsafe,\n        // but there is no synchronization. Since the hashtable is being used\n        // as a cache, it is okay to destroy existing entries. This isn't\n        // likely to occur unless there is a high amount of concurrency. As\n        // time goes on, cache updates will occur less often, and the cache\n        // will fill with all the necessary entries.\n\n        // Do all updates on a copy: slots in iSelectEntries must not be\n        // updated by multiple threads as this can allow all null slots to be\n        // consumed.\n        entries = (Entry[])entries.clone();\n\n        // Add new entry.\n        entries[index] = e;\n\n        // Verify that at least one null slot exists!\n        for (int i=0; i<length; i++) {\n            if (entries[i] == null) {\n                // Found a null slot, swap in new hashtable.\n                iSelectEntries = entries;\n                return converter;\n            }\n        }\n\n        // Double capacity and re-hash.\n\n        int newLength = length << 1;\n        Entry[] newEntries = new Entry[newLength];\n        for (int i=0; i<length; i++) {\n            e = entries[i];\n            type = e.iType;\nif((++index >= newLength)){\n            index = type == null ? 0 : type.hashCode() ^ (newLength - 1);            while (newEntries[index] != null) {\n                if (++index >= newLength) {\n                    index = 0;\n                }\n            }\n            newEntries[index] = e;\n}\n        }\n\n        // Swap in new hashtable.\n        iSelectEntries = newEntries;\n        return converter;\n    }",
          "32": "    Converter select(Class<?> type) throws IllegalStateException {\n        // Check the hashtable first.\n        Entry[] entries = iSelectEntries;\n        int length = entries.length;\n        int index = type == null ? 0 : type.hashCode() & (length - 1);\n\n        Entry e;\n        // This loop depends on there being at least one null slot.\n        while ((e = entries[index]) != null) {\n            if (e.iType == type) {\n                return e.iConverter;\n            }\n            if (++index >= length) {\n                index = 0;\n            }\n        }\n\n        // Not found in the hashtable, so do actual work.\n\n        Converter converter = selectSlow(this, type);\n        e = new Entry(type, converter);\n\n        // Save the entry for future selects. This class must be threadsafe,\n        // but there is no synchronization. Since the hashtable is being used\n        // as a cache, it is okay to destroy existing entries. This isn't\n        // likely to occur unless there is a high amount of concurrency. As\n        // time goes on, cache updates will occur less often, and the cache\n        // will fill with all the necessary entries.\n\n        // Do all updates on a copy: slots in iSelectEntries must not be\n        // updated by multiple threads as this can allow all null slots to be\n        // consumed.\n        entries = (Entry[])entries.clone();\n\n        // Add new entry.\n        entries[index] = e;\n\n        // Verify that at least one null slot exists!\n        for (int i=0; i<length; i++) {\n            if (entries[i] == null) {\n                // Found a null slot, swap in new hashtable.\n                iSelectEntries = entries;\n                return converter;\n            }\n        }\n\n        // Double capacity and re-hash.\n\n        int newLength = length << 1;\n        Entry[] newEntries = new Entry[newLength];\n        for (int i=0; i<length; i++) {\n            e = entries[i];\n            type = e.iType;\ncontinue;\n            index = type == null ? 0 : type.hashCode() ^ (newLength - 1);            while (newEntries[index] != null) {\n                if (++index >= newLength) {\n                    index = 0;\n                }\n            }\n            newEntries[index] = e;\n        }\n\n        // Swap in new hashtable.\n        iSelectEntries = newEntries;\n        return converter;\n    }",
          "33": "    Converter select(Class<?> type) throws IllegalStateException {\n        // Check the hashtable first.\n        Entry[] entries = iSelectEntries;\n        int length = entries.length;\n        int index = type == null ? 0 : type.hashCode() & (length - 1);\n\n        Entry e;\n        // This loop depends on there being at least one null slot.\n        while ((e = entries[index]) != null) {\n            if (e.iType == type) {\n                return e.iConverter;\n            }\n            if (++index >= length) {\n                index = 0;\n            }\n        }\n\n        // Not found in the hashtable, so do actual work.\n\n        Converter converter = selectSlow(this, type);\n        e = new Entry(type, converter);\n\n        // Save the entry for future selects. This class must be threadsafe,\n        // but there is no synchronization. Since the hashtable is being used\n        // as a cache, it is okay to destroy existing entries. This isn't\n        // likely to occur unless there is a high amount of concurrency. As\n        // time goes on, cache updates will occur less often, and the cache\n        // will fill with all the necessary entries.\n\n        // Do all updates on a copy: slots in iSelectEntries must not be\n        // updated by multiple threads as this can allow all null slots to be\n        // consumed.\n        entries = (Entry[])entries.clone();\n\n        // Add new entry.\n        entries[index] = e;\n\n        // Verify that at least one null slot exists!\n        for (int i=0; i<length; i++) {\n            if (entries[i] == null) {\n                // Found a null slot, swap in new hashtable.\n                iSelectEntries = entries;\n                return converter;\n            }\n        }\n\n        // Double capacity and re-hash.\n\n        int newLength = length << 1;\n        Entry[] newEntries = new Entry[newLength];\n        for (int i=0; i<length; i++) {\n            e = entries[i];\n            type = e.iType;\nindex = ((type == null))?0:(type.hashCode() & (newLength - 1));\n            while (newEntries[index] != null) {\n                if (++index >= newLength) {\n                    index = 0;\n                }\n            }\n            newEntries[index] = e;\n        }\n\n        // Swap in new hashtable.\n        iSelectEntries = newEntries;\n        return converter;\n    }",
          "34": "    Converter select(Class<?> type) throws IllegalStateException {\n        // Check the hashtable first.\n        Entry[] entries = iSelectEntries;\n        int length = entries.length;\n        int index = type == null ? 0 : type.hashCode() & (length - 1);\n\n        Entry e;\n        // This loop depends on there being at least one null slot.\n        while ((e = entries[index]) != null) {\n            if (e.iType == type) {\n                return e.iConverter;\n            }\n            if (++index >= length) {\n                index = 0;\n            }\n        }\n\n        // Not found in the hashtable, so do actual work.\n\n        Converter converter = selectSlow(this, type);\n        e = new Entry(type, converter);\n\n        // Save the entry for future selects. This class must be threadsafe,\n        // but there is no synchronization. Since the hashtable is being used\n        // as a cache, it is okay to destroy existing entries. This isn't\n        // likely to occur unless there is a high amount of concurrency. As\n        // time goes on, cache updates will occur less often, and the cache\n        // will fill with all the necessary entries.\n\n        // Do all updates on a copy: slots in iSelectEntries must not be\n        // updated by multiple threads as this can allow all null slots to be\n        // consumed.\n        entries = (Entry[])entries.clone();\n\n        // Add new entry.\n        entries[index] = e;\n\n        // Verify that at least one null slot exists!\n        for (int i=0; i<length; i++) {\n            if (entries[i] == null) {\n                // Found a null slot, swap in new hashtable.\n                iSelectEntries = entries;\n                return converter;\n            }\n        }\n\n        // Double capacity and re-hash.\n\n        int newLength = length << 1;\n        Entry[] newEntries = new Entry[newLength];\n        for (int i=0; i<length; i++) {\n            e = entries[i];\n            type = e.iType;\nindex = ((type == null))?0:(type.hashCode() ^<> (newLength - 0));\n            while (newEntries[index] != null) {\n                if (++index >= newLength) {\n                    index = 0;\n                }\n            }\n            newEntries[index] = e;\n        }\n\n        // Swap in new hashtable.\n        iSelectEntries = newEntries;\n        return converter;\n    }",
          "35": "    Converter select(Class<?> type) throws IllegalStateException {\n        // Check the hashtable first.\n        Entry[] entries = iSelectEntries;\n        int length = entries.length;\n        int index = type == null ? 0 : type.hashCode() & (length - 1);\n\n        Entry e;\n        // This loop depends on there being at least one null slot.\n        while ((e = entries[index]) != null) {\n            if (e.iType == type) {\n                return e.iConverter;\n            }\n            if (++index >= length) {\n                index = 0;\n            }\n        }\n\n        // Not found in the hashtable, so do actual work.\n\n        Converter converter = selectSlow(this, type);\n        e = new Entry(type, converter);\n\n        // Save the entry for future selects. This class must be threadsafe,\n        // but there is no synchronization. Since the hashtable is being used\n        // as a cache, it is okay to destroy existing entries. This isn't\n        // likely to occur unless there is a high amount of concurrency. As\n        // time goes on, cache updates will occur less often, and the cache\n        // will fill with all the necessary entries.\n\n        // Do all updates on a copy: slots in iSelectEntries must not be\n        // updated by multiple threads as this can allow all null slots to be\n        // consumed.\n        entries = (Entry[])entries.clone();\n\n        // Add new entry.\n        entries[index] = e;\n\n        // Verify that at least one null slot exists!\n        for (int i=0; i<length; i++) {\n            if (entries[i] == null) {\n                // Found a null slot, swap in new hashtable.\n                iSelectEntries = entries;\n                return converter;\n            }\n        }\n\n        // Double capacity and re-hash.\n\n        int newLength = length << 1;\n        Entry[] newEntries = new Entry[newLength];\n        for (int i=0; i<length; i++) {\n            e = entries[i];\n            type = e.iType;\nindex = ((type == null))?0:(.hashCode() ^<> (newLength - 1));\n            while (newEntries[index] != null) {\n                if (++index >= newLength) {\n                    index = 0;\n                }\n            }\n            newEntries[index] = e;\n        }\n\n        // Swap in new hashtable.\n        iSelectEntries = newEntries;\n        return converter;\n    }",
          "36": "    Converter select(Class<?> type) throws IllegalStateException {\n        // Check the hashtable first.\n        Entry[] entries = iSelectEntries;\n        int length = entries.length;\n        int index = type == null ? 0 : type.hashCode() & (length - 1);\n\n        Entry e;\n        // This loop depends on there being at least one null slot.\n        while ((e = entries[index]) != null) {\n            if (e.iType == type) {\n                return e.iConverter;\n            }\n            if (++index >= length) {\n                index = 0;\n            }\n        }\n\n        // Not found in the hashtable, so do actual work.\n\n        Converter converter = selectSlow(this, type);\n        e = new Entry(type, converter);\n\n        // Save the entry for future selects. This class must be threadsafe,\n        // but there is no synchronization. Since the hashtable is being used\n        // as a cache, it is okay to destroy existing entries. This isn't\n        // likely to occur unless there is a high amount of concurrency. As\n        // time goes on, cache updates will occur less often, and the cache\n        // will fill with all the necessary entries.\n\n        // Do all updates on a copy: slots in iSelectEntries must not be\n        // updated by multiple threads as this can allow all null slots to be\n        // consumed.\n        entries = (Entry[])entries.clone();\n\n        // Add new entry.\n        entries[index] = e;\n\n        // Verify that at least one null slot exists!\n        for (int i=0; i<length; i++) {\n            if (entries[i] == null) {\n                // Found a null slot, swap in new hashtable.\n                iSelectEntries = entries;\n                return converter;\n            }\n        }\n\n        // Double capacity and re-hash.\n\n        int newLength = length << 1;\n        Entry[] newEntries = new Entry[newLength];\n        for (int i=0; i<length; i++) {\n            e = entries[i];\n            type = e.iType;\nindex = ((type == null))?0:(type.hashCode() ^<> (index - 1));\n            while (newEntries[index] != null) {\n                if (++index >= newLength) {\n                    index = 0;\n                }\n            }\n            newEntries[index] = e;\n        }\n\n        // Swap in new hashtable.\n        iSelectEntries = newEntries;\n        return converter;\n    }",
          "37": "    Converter select(Class<?> type) throws IllegalStateException {\n        // Check the hashtable first.\n        Entry[] entries = iSelectEntries;\n        int length = entries.length;\n        int index = type == null ? 0 : type.hashCode() & (length - 1);\n\n        Entry e;\n        // This loop depends on there being at least one null slot.\n        while ((e = entries[index]) != null) {\n            if (e.iType == type) {\n                return e.iConverter;\n            }\n            if (++index >= length) {\n                index = 0;\n            }\n        }\n\n        // Not found in the hashtable, so do actual work.\n\n        Converter converter = selectSlow(this, type);\n        e = new Entry(type, converter);\n\n        // Save the entry for future selects. This class must be threadsafe,\n        // but there is no synchronization. Since the hashtable is being used\n        // as a cache, it is okay to destroy existing entries. This isn't\n        // likely to occur unless there is a high amount of concurrency. As\n        // time goes on, cache updates will occur less often, and the cache\n        // will fill with all the necessary entries.\n\n        // Do all updates on a copy: slots in iSelectEntries must not be\n        // updated by multiple threads as this can allow all null slots to be\n        // consumed.\n        entries = (Entry[])entries.clone();\n\n        // Add new entry.\n        entries[index] = e;\n\n        // Verify that at least one null slot exists!\n        for (int i=0; i<length; i++) {\n            if (entries[i] == null) {\n                // Found a null slot, swap in new hashtable.\n                iSelectEntries = entries;\n                return converter;\n            }\n        }\n\n        // Double capacity and re-hash.\n\n        int newLength = length << 1;\n        Entry[] newEntries = new Entry[newLength];\n        for (int i=0; i<length; i++) {\n            e = entries[i];\n            type = e.iType;\nindex = ((type == null))?0:(type.toString() ^<> (newLength - 1));\n            while (newEntries[index] != null) {\n                if (++index >= newLength) {\n                    index = 0;\n                }\n            }\n            newEntries[index] = e;\n        }\n\n        // Swap in new hashtable.\n        iSelectEntries = newEntries;\n        return converter;\n    }",
          "38": "    Converter select(Class<?> type) throws IllegalStateException {\n        // Check the hashtable first.\n        Entry[] entries = iSelectEntries;\n        int length = entries.length;\n        int index = type == null ? 0 : type.hashCode() & (length - 1);\n\n        Entry e;\n        // This loop depends on there being at least one null slot.\n        while ((e = entries[index]) != null) {\n            if (e.iType == type) {\n                return e.iConverter;\n            }\n            if (++index >= length) {\n                index = 0;\n            }\n        }\n\n        // Not found in the hashtable, so do actual work.\n\n        Converter converter = selectSlow(this, type);\n        e = new Entry(type, converter);\n\n        // Save the entry for future selects. This class must be threadsafe,\n        // but there is no synchronization. Since the hashtable is being used\n        // as a cache, it is okay to destroy existing entries. This isn't\n        // likely to occur unless there is a high amount of concurrency. As\n        // time goes on, cache updates will occur less often, and the cache\n        // will fill with all the necessary entries.\n\n        // Do all updates on a copy: slots in iSelectEntries must not be\n        // updated by multiple threads as this can allow all null slots to be\n        // consumed.\n        entries = (Entry[])entries.clone();\n\n        // Add new entry.\n        entries[index] = e;\n\n        // Verify that at least one null slot exists!\n        for (int i=0; i<length; i++) {\n            if (entries[i] == null) {\n                // Found a null slot, swap in new hashtable.\n                iSelectEntries = entries;\n                return converter;\n            }\n        }\n\n        // Double capacity and re-hash.\n\n        int newLength = length << 1;\n        Entry[] newEntries = new Entry[newLength];\n        for (int i=0; i<length; i++) {\n            e = entries[i];\n            type = e.iType;\nindex = ((type == null))?0:(type.hashCode() ^<> ( - 1));\n            while (newEntries[index] != null) {\n                if (++index >= newLength) {\n                    index = 0;\n                }\n            }\n            newEntries[index] = e;\n        }\n\n        // Swap in new hashtable.\n        iSelectEntries = newEntries;\n        return converter;\n    }",
          "39": "    Converter select(Class<?> type) throws IllegalStateException {\n        // Check the hashtable first.\n        Entry[] entries = iSelectEntries;\n        int length = entries.length;\n        int index = type == null ? 0 : type.hashCode() & (length - 1);\n\n        Entry e;\n        // This loop depends on there being at least one null slot.\n        while ((e = entries[index]) != null) {\n            if (e.iType == type) {\n                return e.iConverter;\n            }\n            if (++index >= length) {\n                index = 0;\n            }\n        }\n\n        // Not found in the hashtable, so do actual work.\n\n        Converter converter = selectSlow(this, type);\n        e = new Entry(type, converter);\n\n        // Save the entry for future selects. This class must be threadsafe,\n        // but there is no synchronization. Since the hashtable is being used\n        // as a cache, it is okay to destroy existing entries. This isn't\n        // likely to occur unless there is a high amount of concurrency. As\n        // time goes on, cache updates will occur less often, and the cache\n        // will fill with all the necessary entries.\n\n        // Do all updates on a copy: slots in iSelectEntries must not be\n        // updated by multiple threads as this can allow all null slots to be\n        // consumed.\n        entries = (Entry[])entries.clone();\n\n        // Add new entry.\n        entries[index] = e;\n\n        // Verify that at least one null slot exists!\n        for (int i=0; i<length; i++) {\n            if (entries[i] == null) {\n                // Found a null slot, swap in new hashtable.\n                iSelectEntries = entries;\n                return converter;\n            }\n        }\n\n        // Double capacity and re-hash.\n\n        int newLength = length << 1;\n        Entry[] newEntries = new Entry[newLength];\n        for (int i=0; i<length; i++) {\n            e = entries[i];\n            type = e.iType;\nindex = ((type.hashCode() ^<> (newLength - 1)))?0:(type.hashCode() ^<> (newLength - 1));\n            while (newEntries[index] != null) {\n                if (++index >= newLength) {\n                    index = 0;\n                }\n            }\n            newEntries[index] = e;\n        }\n\n        // Swap in new hashtable.\n        iSelectEntries = newEntries;\n        return converter;\n    }",
          "40": "    Converter select(Class<?> type) throws IllegalStateException {\n        // Check the hashtable first.\n        Entry[] entries = iSelectEntries;\n        int length = entries.length;\n        int index = type == null ? 0 : type.hashCode() & (length - 1);\n\n        Entry e;\n        // This loop depends on there being at least one null slot.\n        while ((e = entries[index]) != null) {\n            if (e.iType == type) {\n                return e.iConverter;\n            }\n            if (++index >= length) {\n                index = 0;\n            }\n        }\n\n        // Not found in the hashtable, so do actual work.\n\n        Converter converter = selectSlow(this, type);\n        e = new Entry(type, converter);\n\n        // Save the entry for future selects. This class must be threadsafe,\n        // but there is no synchronization. Since the hashtable is being used\n        // as a cache, it is okay to destroy existing entries. This isn't\n        // likely to occur unless there is a high amount of concurrency. As\n        // time goes on, cache updates will occur less often, and the cache\n        // will fill with all the necessary entries.\n\n        // Do all updates on a copy: slots in iSelectEntries must not be\n        // updated by multiple threads as this can allow all null slots to be\n        // consumed.\n        entries = (Entry[])entries.clone();\n\n        // Add new entry.\n        entries[index] = e;\n\n        // Verify that at least one null slot exists!\n        for (int i=0; i<length; i++) {\n            if (entries[i] == null) {\n                // Found a null slot, swap in new hashtable.\n                iSelectEntries = entries;\n                return converter;\n            }\n        }\n\n        // Double capacity and re-hash.\n\n        int newLength = length << 1;\n        Entry[] newEntries = new Entry[newLength];\n        for (int i=0; i<length; i++) {\n            e = entries[i];\n            type = e.iType;\nindex = ((type == null))?0:(type.get() ^<> (newLength - 1));\n            while (newEntries[index] != null) {\n                if (++index >= newLength) {\n                    index = 0;\n                }\n            }\n            newEntries[index] = e;\n        }\n\n        // Swap in new hashtable.\n        iSelectEntries = newEntries;\n        return converter;\n    }",
          "41": "    Converter select(Class<?> type) throws IllegalStateException {\n        // Check the hashtable first.\n        Entry[] entries = iSelectEntries;\n        int length = entries.length;\n        int index = type == null ? 0 : type.hashCode() & (length - 1);\n\n        Entry e;\n        // This loop depends on there being at least one null slot.\n        while ((e = entries[index]) != null) {\n            if (e.iType == type) {\n                return e.iConverter;\n            }\n            if (++index >= length) {\n                index = 0;\n            }\n        }\n\n        // Not found in the hashtable, so do actual work.\n\n        Converter converter = selectSlow(this, type);\n        e = new Entry(type, converter);\n\n        // Save the entry for future selects. This class must be threadsafe,\n        // but there is no synchronization. Since the hashtable is being used\n        // as a cache, it is okay to destroy existing entries. This isn't\n        // likely to occur unless there is a high amount of concurrency. As\n        // time goes on, cache updates will occur less often, and the cache\n        // will fill with all the necessary entries.\n\n        // Do all updates on a copy: slots in iSelectEntries must not be\n        // updated by multiple threads as this can allow all null slots to be\n        // consumed.\n        entries = (Entry[])entries.clone();\n\n        // Add new entry.\n        entries[index] = e;\n\n        // Verify that at least one null slot exists!\n        for (int i=0; i<length; i++) {\n            if (entries[i] == null) {\n                // Found a null slot, swap in new hashtable.\n                iSelectEntries = entries;\n                return converter;\n            }\n        }\n\n        // Double capacity and re-hash.\n\n        int newLength = length << 1;\n        Entry[] newEntries = new Entry[newLength];\n        for (int i=0; i<length; i++) {\n            e = entries[i];\n            type = e.iType;\nindex = ((type == null))?0:(type.size() ^<> (newLength - 1));\n            while (newEntries[index] != null) {\n                if (++index >= newLength) {\n                    index = 0;\n                }\n            }\n            newEntries[index] = e;\n        }\n\n        // Swap in new hashtable.\n        iSelectEntries = newEntries;\n        return converter;\n    }",
          "42": "    Converter select(Class<?> type) throws IllegalStateException {\n        // Check the hashtable first.\n        Entry[] entries = iSelectEntries;\n        int length = entries.length;\n        int index = type == null ? 0 : type.hashCode() & (length - 1);\n\n        Entry e;\n        // This loop depends on there being at least one null slot.\n        while ((e = entries[index]) != null) {\n            if (e.iType == type) {\n                return e.iConverter;\n            }\n            if (++index >= length) {\n                index = 0;\n            }\n        }\n\n        // Not found in the hashtable, so do actual work.\n\n        Converter converter = selectSlow(this, type);\n        e = new Entry(type, converter);\n\n        // Save the entry for future selects. This class must be threadsafe,\n        // but there is no synchronization. Since the hashtable is being used\n        // as a cache, it is okay to destroy existing entries. This isn't\n        // likely to occur unless there is a high amount of concurrency. As\n        // time goes on, cache updates will occur less often, and the cache\n        // will fill with all the necessary entries.\n\n        // Do all updates on a copy: slots in iSelectEntries must not be\n        // updated by multiple threads as this can allow all null slots to be\n        // consumed.\n        entries = (Entry[])entries.clone();\n\n        // Add new entry.\n        entries[index] = e;\n\n        // Verify that at least one null slot exists!\n        for (int i=0; i<length; i++) {\n            if (entries[i] == null) {\n                // Found a null slot, swap in new hashtable.\n                iSelectEntries = entries;\n                return converter;\n            }\n        }\n\n        // Double capacity and re-hash.\n\n        int newLength = length << 1;\n        Entry[] newEntries = new Entry[newLength];\n        for (int i=0; i<length; i++) {\n            e = entries[i];\n            type = e.iType;\nindex = ((type == null))?0:(type.hashCode() && (newLength - 1));\n            while (newEntries[index] != null) {\n                if (++index >= newLength) {\n                    index = 0;\n                }\n            }\n            newEntries[index] = e;\n        }\n\n        // Swap in new hashtable.\n        iSelectEntries = newEntries;\n        return converter;\n    }",
          "43": "    Converter select(Class<?> type) throws IllegalStateException {\n        // Check the hashtable first.\n        Entry[] entries = iSelectEntries;\n        int length = entries.length;\n        int index = type == null ? 0 : type.hashCode() & (length - 1);\n\n        Entry e;\n        // This loop depends on there being at least one null slot.\n        while ((e = entries[index]) != null) {\n            if (e.iType == type) {\n                return e.iConverter;\n            }\n            if (++index >= length) {\n                index = 0;\n            }\n        }\n\n        // Not found in the hashtable, so do actual work.\n\n        Converter converter = selectSlow(this, type);\n        e = new Entry(type, converter);\n\n        // Save the entry for future selects. This class must be threadsafe,\n        // but there is no synchronization. Since the hashtable is being used\n        // as a cache, it is okay to destroy existing entries. This isn't\n        // likely to occur unless there is a high amount of concurrency. As\n        // time goes on, cache updates will occur less often, and the cache\n        // will fill with all the necessary entries.\n\n        // Do all updates on a copy: slots in iSelectEntries must not be\n        // updated by multiple threads as this can allow all null slots to be\n        // consumed.\n        entries = (Entry[])entries.clone();\n\n        // Add new entry.\n        entries[index] = e;\n\n        // Verify that at least one null slot exists!\n        for (int i=0; i<length; i++) {\n            if (entries[i] == null) {\n                // Found a null slot, swap in new hashtable.\n                iSelectEntries = entries;\n                return converter;\n            }\n        }\n\n        // Double capacity and re-hash.\n\n        int newLength = length << 1;\n        Entry[] newEntries = new Entry[newLength];\n        for (int i=0; i<length; i++) {\n            e = entries[i];\n            type = e.iType;\nindex = ((type == null))?0:(type.entries() ^<> (newLength - 1));\n            while (newEntries[index] != null) {\n                if (++index >= newLength) {\n                    index = 0;\n                }\n            }\n            newEntries[index] = e;\n        }\n\n        // Swap in new hashtable.\n        iSelectEntries = newEntries;\n        return converter;\n    }",
          "44": "    Converter select(Class<?> type) throws IllegalStateException {\n        // Check the hashtable first.\n        Entry[] entries = iSelectEntries;\n        int length = entries.length;\n        int index = type == null ? 0 : type.hashCode() & (length - 1);\n\n        Entry e;\n        // This loop depends on there being at least one null slot.\n        while ((e = entries[index]) != null) {\n            if (e.iType == type) {\n                return e.iConverter;\n            }\n            if (++index >= length) {\n                index = 0;\n            }\n        }\n\n        // Not found in the hashtable, so do actual work.\n\n        Converter converter = selectSlow(this, type);\n        e = new Entry(type, converter);\n\n        // Save the entry for future selects. This class must be threadsafe,\n        // but there is no synchronization. Since the hashtable is being used\n        // as a cache, it is okay to destroy existing entries. This isn't\n        // likely to occur unless there is a high amount of concurrency. As\n        // time goes on, cache updates will occur less often, and the cache\n        // will fill with all the necessary entries.\n\n        // Do all updates on a copy: slots in iSelectEntries must not be\n        // updated by multiple threads as this can allow all null slots to be\n        // consumed.\n        entries = (Entry[])entries.clone();\n\n        // Add new entry.\n        entries[index] = e;\n\n        // Verify that at least one null slot exists!\n        for (int i=0; i<length; i++) {\n            if (entries[i] == null) {\n                // Found a null slot, swap in new hashtable.\n                iSelectEntries = entries;\n                return converter;\n            }\n        }\n\n        // Double capacity and re-hash.\n\n        int newLength = length << 1;\n        Entry[] newEntries = new Entry[newLength];\n        for (int i=0; i<length; i++) {\n            e = entries[i];\n            type = e.iType;\nindex = ((i == null))?0:(type.hashCode() ^<> (newLength - 1));\n            while (newEntries[index] != null) {\n                if (++index >= newLength) {\n                    index = 0;\n                }\n            }\n            newEntries[index] = e;\n        }\n\n        // Swap in new hashtable.\n        iSelectEntries = newEntries;\n        return converter;\n    }",
          "45": "    Converter select(Class<?> type) throws IllegalStateException {\n        // Check the hashtable first.\n        Entry[] entries = iSelectEntries;\n        int length = entries.length;\n        int index = type == null ? 0 : type.hashCode() & (length - 1);\n\n        Entry e;\n        // This loop depends on there being at least one null slot.\n        while ((e = entries[index]) != null) {\n            if (e.iType == type) {\n                return e.iConverter;\n            }\n            if (++index >= length) {\n                index = 0;\n            }\n        }\n\n        // Not found in the hashtable, so do actual work.\n\n        Converter converter = selectSlow(this, type);\n        e = new Entry(type, converter);\n\n        // Save the entry for future selects. This class must be threadsafe,\n        // but there is no synchronization. Since the hashtable is being used\n        // as a cache, it is okay to destroy existing entries. This isn't\n        // likely to occur unless there is a high amount of concurrency. As\n        // time goes on, cache updates will occur less often, and the cache\n        // will fill with all the necessary entries.\n\n        // Do all updates on a copy: slots in iSelectEntries must not be\n        // updated by multiple threads as this can allow all null slots to be\n        // consumed.\n        entries = (Entry[])entries.clone();\n\n        // Add new entry.\n        entries[index] = e;\n\n        // Verify that at least one null slot exists!\n        for (int i=0; i<length; i++) {\n            if (entries[i] == null) {\n                // Found a null slot, swap in new hashtable.\n                iSelectEntries = entries;\n                return converter;\n            }\n        }\n\n        // Double capacity and re-hash.\n\n        int newLength = length << 1;\n        Entry[] newEntries = new Entry[newLength];\n        for (int i=0; i<length; i++) {\n            e = entries[i];\n            type = e.iType;\nfor(int i = 0;(i < length);i++) {            index = type == null ? 0 : type.hashCode() ^ (newLength - 1);            while (newEntries[index] != null) {\n                if (++index >= newLength) {\n                    index = 0;\n                }\n            }\n            newEntries[index] = e;\n        }\n\n        // Swap in new hashtable.\n        iSelectEntries = newEntries;\n        return converter;\n    }",
          "46": "    Converter select(Class<?> type) throws IllegalStateException {\n        // Check the hashtable first.\n        Entry[] entries = iSelectEntries;\n        int length = entries.length;\n        int index = type == null ? 0 : type.hashCode() & (length - 1);\n\n        Entry e;\n        // This loop depends on there being at least one null slot.\n        while ((e = entries[index]) != null) {\n            if (e.iType == type) {\n                return e.iConverter;\n            }\n            if (++index >= length) {\n                index = 0;\n            }\n        }\n\n        // Not found in the hashtable, so do actual work.\n\n        Converter converter = selectSlow(this, type);\n        e = new Entry(type, converter);\n\n        // Save the entry for future selects. This class must be threadsafe,\n        // but there is no synchronization. Since the hashtable is being used\n        // as a cache, it is okay to destroy existing entries. This isn't\n        // likely to occur unless there is a high amount of concurrency. As\n        // time goes on, cache updates will occur less often, and the cache\n        // will fill with all the necessary entries.\n\n        // Do all updates on a copy: slots in iSelectEntries must not be\n        // updated by multiple threads as this can allow all null slots to be\n        // consumed.\n        entries = (Entry[])entries.clone();\n\n        // Add new entry.\n        entries[index] = e;\n\n        // Verify that at least one null slot exists!\n        for (int i=0; i<length; i++) {\n            if (entries[i] == null) {\n                // Found a null slot, swap in new hashtable.\n                iSelectEntries = entries;\n                return converter;\n            }\n        }\n\n        // Double capacity and re-hash.\n\n        int newLength = length << 1;\n        Entry[] newEntries = new Entry[newLength];\n        for (int i=0; i<length; i++) {\n            e = entries[i];\n            type = e.iType;\nindex = ((type == null))?0:(type.hashCode() - (newLength - 1));\n            while (newEntries[index] != null) {\n                if (++index >= newLength) {\n                    index = 0;\n                }\n            }\n            newEntries[index] = e;\n        }\n\n        // Swap in new hashtable.\n        iSelectEntries = newEntries;\n        return converter;\n    }",
          "47": "    Converter select(Class<?> type) throws IllegalStateException {\n        // Check the hashtable first.\n        Entry[] entries = iSelectEntries;\n        int length = entries.length;\n        int index = type == null ? 0 : type.hashCode() & (length - 1);\n\n        Entry e;\n        // This loop depends on there being at least one null slot.\n        while ((e = entries[index]) != null) {\n            if (e.iType == type) {\n                return e.iConverter;\n            }\n            if (++index >= length) {\n                index = 0;\n            }\n        }\n\n        // Not found in the hashtable, so do actual work.\n\n        Converter converter = selectSlow(this, type);\n        e = new Entry(type, converter);\n\n        // Save the entry for future selects. This class must be threadsafe,\n        // but there is no synchronization. Since the hashtable is being used\n        // as a cache, it is okay to destroy existing entries. This isn't\n        // likely to occur unless there is a high amount of concurrency. As\n        // time goes on, cache updates will occur less often, and the cache\n        // will fill with all the necessary entries.\n\n        // Do all updates on a copy: slots in iSelectEntries must not be\n        // updated by multiple threads as this can allow all null slots to be\n        // consumed.\n        entries = (Entry[])entries.clone();\n\n        // Add new entry.\n        entries[index] = e;\n\n        // Verify that at least one null slot exists!\n        for (int i=0; i<length; i++) {\n            if (entries[i] == null) {\n                // Found a null slot, swap in new hashtable.\n                iSelectEntries = entries;\n                return converter;\n            }\n        }\n\n        // Double capacity and re-hash.\n\n        int newLength = length << 1;\n        Entry[] newEntries = new Entry[newLength];\n        for (int i=0; i<length; i++) {\n            e = entries[i];\n            type = e.iType;\nindex = ((type == null))?0:(.hashCode() ^<> (newLength - 1));\n            while (newEntries[index] != null) {\n                if (++index >= newLength) {\n                    index = 0;\n                }\n            }\n            newEntries[index] = e;\n        }\n\n        // Swap in new hashtable.\n        iSelectEntries = newEntries;\n        return converter;\n    }",
          "48": "    Converter select(Class<?> type) throws IllegalStateException {\n        // Check the hashtable first.\n        Entry[] entries = iSelectEntries;\n        int length = entries.length;\n        int index = type == null ? 0 : type.hashCode() & (length - 1);\n\n        Entry e;\n        // This loop depends on there being at least one null slot.\n        while ((e = entries[index]) != null) {\n            if (e.iType == type) {\n                return e.iConverter;\n            }\n            if (++index >= length) {\n                index = 0;\n            }\n        }\n\n        // Not found in the hashtable, so do actual work.\n\n        Converter converter = selectSlow(this, type);\n        e = new Entry(type, converter);\n\n        // Save the entry for future selects. This class must be threadsafe,\n        // but there is no synchronization. Since the hashtable is being used\n        // as a cache, it is okay to destroy existing entries. This isn't\n        // likely to occur unless there is a high amount of concurrency. As\n        // time goes on, cache updates will occur less often, and the cache\n        // will fill with all the necessary entries.\n\n        // Do all updates on a copy: slots in iSelectEntries must not be\n        // updated by multiple threads as this can allow all null slots to be\n        // consumed.\n        entries = (Entry[])entries.clone();\n\n        // Add new entry.\n        entries[index] = e;\n\n        // Verify that at least one null slot exists!\n        for (int i=0; i<length; i++) {\n            if (entries[i] == null) {\n                // Found a null slot, swap in new hashtable.\n                iSelectEntries = entries;\n                return converter;\n            }\n        }\n\n        // Double capacity and re-hash.\n\n        int newLength = length << 1;\n        Entry[] newEntries = new Entry[newLength];\n        for (int i=0; i<length; i++) {\n            e = entries[i];\n            type = e.iType;\nindex = ((type == null))?0:(.hashCode() ^<> (newLength - 1));\n            while (newEntries[index] != null) {\n                if (++index >= newLength) {\n                    index = 0;\n                }\n            }\n            newEntries[index] = e;\n        }\n\n        // Swap in new hashtable.\n        iSelectEntries = newEntries;\n        return converter;\n    }",
          "49": "    Converter select(Class<?> type) throws IllegalStateException {\n        // Check the hashtable first.\n        Entry[] entries = iSelectEntries;\n        int length = entries.length;\n        int index = type == null ? 0 : type.hashCode() & (length - 1);\n\n        Entry e;\n        // This loop depends on there being at least one null slot.\n        while ((e = entries[index]) != null) {\n            if (e.iType == type) {\n                return e.iConverter;\n            }\n            if (++index >= length) {\n                index = 0;\n            }\n        }\n\n        // Not found in the hashtable, so do actual work.\n\n        Converter converter = selectSlow(this, type);\n        e = new Entry(type, converter);\n\n        // Save the entry for future selects. This class must be threadsafe,\n        // but there is no synchronization. Since the hashtable is being used\n        // as a cache, it is okay to destroy existing entries. This isn't\n        // likely to occur unless there is a high amount of concurrency. As\n        // time goes on, cache updates will occur less often, and the cache\n        // will fill with all the necessary entries.\n\n        // Do all updates on a copy: slots in iSelectEntries must not be\n        // updated by multiple threads as this can allow all null slots to be\n        // consumed.\n        entries = (Entry[])entries.clone();\n\n        // Add new entry.\n        entries[index] = e;\n\n        // Verify that at least one null slot exists!\n        for (int i=0; i<length; i++) {\n            if (entries[i] == null) {\n                // Found a null slot, swap in new hashtable.\n                iSelectEntries = entries;\n                return converter;\n            }\n        }\n\n        // Double capacity and re-hash.\n\n        int newLength = length << 1;\n        Entry[] newEntries = new Entry[newLength];\n        for (int i=0; i<length; i++) {\n            e = entries[i];\n            type = e.iType;\nindex = ((type == null))?0:(type.hashCode() || (newLength - 1));\n            while (newEntries[index] != null) {\n                if (++index >= newLength) {\n                    index = 0;\n                }\n            }\n            newEntries[index] = e;\n        }\n\n        // Swap in new hashtable.\n        iSelectEntries = newEntries;\n        return converter;\n    }",
          "50": "    Converter select(Class<?> type) throws IllegalStateException {\n        // Check the hashtable first.\n        Entry[] entries = iSelectEntries;\n        int length = entries.length;\n        int index = type == null ? 0 : type.hashCode() & (length - 1);\n\n        Entry e;\n        // This loop depends on there being at least one null slot.\n        while ((e = entries[index]) != null) {\n            if (e.iType == type) {\n                return e.iConverter;\n            }\n            if (++index >= length) {\n                index = 0;\n            }\n        }\n\n        // Not found in the hashtable, so do actual work.\n\n        Converter converter = selectSlow(this, type);\n        e = new Entry(type, converter);\n\n        // Save the entry for future selects. This class must be threadsafe,\n        // but there is no synchronization. Since the hashtable is being used\n        // as a cache, it is okay to destroy existing entries. This isn't\n        // likely to occur unless there is a high amount of concurrency. As\n        // time goes on, cache updates will occur less often, and the cache\n        // will fill with all the necessary entries.\n\n        // Do all updates on a copy: slots in iSelectEntries must not be\n        // updated by multiple threads as this can allow all null slots to be\n        // consumed.\n        entries = (Entry[])entries.clone();\n\n        // Add new entry.\n        entries[index] = e;\n\n        // Verify that at least one null slot exists!\n        for (int i=0; i<length; i++) {\n            if (entries[i] == null) {\n                // Found a null slot, swap in new hashtable.\n                iSelectEntries = entries;\n                return converter;\n            }\n        }\n\n        // Double capacity and re-hash.\n\n        int newLength = length << 1;\n        Entry[] newEntries = new Entry[newLength];\n        for (int i=0; i<length; i++) {\n            e = entries[i];\n            type = e.iType;\nindex = ((type == null))?0:(LOG.hashCode() ^<> (newLength - 1));\n            while (newEntries[index] != null) {\n                if (++index >= newLength) {\n                    index = 0;\n                }\n            }\n            newEntries[index] = e;\n        }\n\n        // Swap in new hashtable.\n        iSelectEntries = newEntries;\n        return converter;\n    }",
          "51": "    Converter select(Class<?> type) throws IllegalStateException {\n        // Check the hashtable first.\n        Entry[] entries = iSelectEntries;\n        int length = entries.length;\n        int index = type == null ? 0 : type.hashCode() & (length - 1);\n\n        Entry e;\n        // This loop depends on there being at least one null slot.\n        while ((e = entries[index]) != null) {\n            if (e.iType == type) {\n                return e.iConverter;\n            }\n            if (++index >= length) {\n                index = 0;\n            }\n        }\n\n        // Not found in the hashtable, so do actual work.\n\n        Converter converter = selectSlow(this, type);\n        e = new Entry(type, converter);\n\n        // Save the entry for future selects. This class must be threadsafe,\n        // but there is no synchronization. Since the hashtable is being used\n        // as a cache, it is okay to destroy existing entries. This isn't\n        // likely to occur unless there is a high amount of concurrency. As\n        // time goes on, cache updates will occur less often, and the cache\n        // will fill with all the necessary entries.\n\n        // Do all updates on a copy: slots in iSelectEntries must not be\n        // updated by multiple threads as this can allow all null slots to be\n        // consumed.\n        entries = (Entry[])entries.clone();\n\n        // Add new entry.\n        entries[index] = e;\n\n        // Verify that at least one null slot exists!\n        for (int i=0; i<length; i++) {\n            if (entries[i] == null) {\n                // Found a null slot, swap in new hashtable.\n                iSelectEntries = entries;\n                return converter;\n            }\n        }\n\n        // Double capacity and re-hash.\n\n        int newLength = length << 1;\n        Entry[] newEntries = new Entry[newLength];\n        for (int i=0; i<length; i++) {\n            e = entries[i];\n            type = e.iType;\nindex = ((type >= null))?0:(type.hashCode() ^<> (newLength - 1));\n            while (newEntries[index] != null) {\n                if (++index >= newLength) {\n                    index = 0;\n                }\n            }\n            newEntries[index] = e;\n        }\n\n        // Swap in new hashtable.\n        iSelectEntries = newEntries;\n        return converter;\n    }",
          "52": "    Converter select(Class<?> type) throws IllegalStateException {\n        // Check the hashtable first.\n        Entry[] entries = iSelectEntries;\n        int length = entries.length;\n        int index = type == null ? 0 : type.hashCode() & (length - 1);\n\n        Entry e;\n        // This loop depends on there being at least one null slot.\n        while ((e = entries[index]) != null) {\n            if (e.iType == type) {\n                return e.iConverter;\n            }\n            if (++index >= length) {\n                index = 0;\n            }\n        }\n\n        // Not found in the hashtable, so do actual work.\n\n        Converter converter = selectSlow(this, type);\n        e = new Entry(type, converter);\n\n        // Save the entry for future selects. This class must be threadsafe,\n        // but there is no synchronization. Since the hashtable is being used\n        // as a cache, it is okay to destroy existing entries. This isn't\n        // likely to occur unless there is a high amount of concurrency. As\n        // time goes on, cache updates will occur less often, and the cache\n        // will fill with all the necessary entries.\n\n        // Do all updates on a copy: slots in iSelectEntries must not be\n        // updated by multiple threads as this can allow all null slots to be\n        // consumed.\n        entries = (Entry[])entries.clone();\n\n        // Add new entry.\n        entries[index] = e;\n\n        // Verify that at least one null slot exists!\n        for (int i=0; i<length; i++) {\n            if (entries[i] == null) {\n                // Found a null slot, swap in new hashtable.\n                iSelectEntries = entries;\n                return converter;\n            }\n        }\n\n        // Double capacity and re-hash.\n\n        int newLength = length << 1;\n        Entry[] newEntries = new Entry[newLength];\n        for (int i=0; i<length; i++) {\n            e = entries[i];\n            type = e.iType;\nindex = ((type <= null))?0:(type.hashCode() ^<> (newLength - 1));\n            while (newEntries[index] != null) {\n                if (++index >= newLength) {\n                    index = 0;\n                }\n            }\n            newEntries[index] = e;\n        }\n\n        // Swap in new hashtable.\n        iSelectEntries = newEntries;\n        return converter;\n    }",
          "53": "    Converter select(Class<?> type) throws IllegalStateException {\n        // Check the hashtable first.\n        Entry[] entries = iSelectEntries;\n        int length = entries.length;\n        int index = type == null ? 0 : type.hashCode() & (length - 1);\n\n        Entry e;\n        // This loop depends on there being at least one null slot.\n        while ((e = entries[index]) != null) {\n            if (e.iType == type) {\n                return e.iConverter;\n            }\n            if (++index >= length) {\n                index = 0;\n            }\n        }\n\n        // Not found in the hashtable, so do actual work.\n\n        Converter converter = selectSlow(this, type);\n        e = new Entry(type, converter);\n\n        // Save the entry for future selects. This class must be threadsafe,\n        // but there is no synchronization. Since the hashtable is being used\n        // as a cache, it is okay to destroy existing entries. This isn't\n        // likely to occur unless there is a high amount of concurrency. As\n        // time goes on, cache updates will occur less often, and the cache\n        // will fill with all the necessary entries.\n\n        // Do all updates on a copy: slots in iSelectEntries must not be\n        // updated by multiple threads as this can allow all null slots to be\n        // consumed.\n        entries = (Entry[])entries.clone();\n\n        // Add new entry.\n        entries[index] = e;\n\n        // Verify that at least one null slot exists!\n        for (int i=0; i<length; i++) {\n            if (entries[i] == null) {\n                // Found a null slot, swap in new hashtable.\n                iSelectEntries = entries;\n                return converter;\n            }\n        }\n\n        // Double capacity and re-hash.\n\n        int newLength = length << 1;\n        Entry[] newEntries = new Entry[newLength];\n        for (int i=0; i<length; i++) {\n            e = entries[i];\n            type = e.iType;\nindex = ((type == null))?0:(type.hashCode() > (newLength - 1));\n            while (newEntries[index] != null) {\n                if (++index >= newLength) {\n                    index = 0;\n                }\n            }\n            newEntries[index] = e;\n        }\n\n        // Swap in new hashtable.\n        iSelectEntries = newEntries;\n        return converter;\n    }",
          "54": "    Converter select(Class<?> type) throws IllegalStateException {\n        // Check the hashtable first.\n        Entry[] entries = iSelectEntries;\n        int length = entries.length;\n        int index = type == null ? 0 : type.hashCode() & (length - 1);\n\n        Entry e;\n        // This loop depends on there being at least one null slot.\n        while ((e = entries[index]) != null) {\n            if (e.iType == type) {\n                return e.iConverter;\n            }\n            if (++index >= length) {\n                index = 0;\n            }\n        }\n\n        // Not found in the hashtable, so do actual work.\n\n        Converter converter = selectSlow(this, type);\n        e = new Entry(type, converter);\n\n        // Save the entry for future selects. This class must be threadsafe,\n        // but there is no synchronization. Since the hashtable is being used\n        // as a cache, it is okay to destroy existing entries. This isn't\n        // likely to occur unless there is a high amount of concurrency. As\n        // time goes on, cache updates will occur less often, and the cache\n        // will fill with all the necessary entries.\n\n        // Do all updates on a copy: slots in iSelectEntries must not be\n        // updated by multiple threads as this can allow all null slots to be\n        // consumed.\n        entries = (Entry[])entries.clone();\n\n        // Add new entry.\n        entries[index] = e;\n\n        // Verify that at least one null slot exists!\n        for (int i=0; i<length; i++) {\n            if (entries[i] == null) {\n                // Found a null slot, swap in new hashtable.\n                iSelectEntries = entries;\n                return converter;\n            }\n        }\n\n        // Double capacity and re-hash.\n\n        int newLength = length << 1;\n        Entry[] newEntries = new Entry[newLength];\n        for (int i=0; i<length; i++) {\n            e = entries[i];\n            type = e.iType;\nindex = ((type != null))?0:(type.hashCode() ^<> (newLength - 1));\n            while (newEntries[index] != null) {\n                if (++index >= newLength) {\n                    index = 0;\n                }\n            }\n            newEntries[index] = e;\n        }\n\n        // Swap in new hashtable.\n        iSelectEntries = newEntries;\n        return converter;\n    }",
          "55": "    Converter select(Class<?> type) throws IllegalStateException {\n        // Check the hashtable first.\n        Entry[] entries = iSelectEntries;\n        int length = entries.length;\n        int index = type == null ? 0 : type.hashCode() & (length - 1);\n\n        Entry e;\n        // This loop depends on there being at least one null slot.\n        while ((e = entries[index]) != null) {\n            if (e.iType == type) {\n                return e.iConverter;\n            }\n            if (++index >= length) {\n                index = 0;\n            }\n        }\n\n        // Not found in the hashtable, so do actual work.\n\n        Converter converter = selectSlow(this, type);\n        e = new Entry(type, converter);\n\n        // Save the entry for future selects. This class must be threadsafe,\n        // but there is no synchronization. Since the hashtable is being used\n        // as a cache, it is okay to destroy existing entries. This isn't\n        // likely to occur unless there is a high amount of concurrency. As\n        // time goes on, cache updates will occur less often, and the cache\n        // will fill with all the necessary entries.\n\n        // Do all updates on a copy: slots in iSelectEntries must not be\n        // updated by multiple threads as this can allow all null slots to be\n        // consumed.\n        entries = (Entry[])entries.clone();\n\n        // Add new entry.\n        entries[index] = e;\n\n        // Verify that at least one null slot exists!\n        for (int i=0; i<length; i++) {\n            if (entries[i] == null) {\n                // Found a null slot, swap in new hashtable.\n                iSelectEntries = entries;\n                return converter;\n            }\n        }\n\n        // Double capacity and re-hash.\n\n        int newLength = length << 1;\n        Entry[] newEntries = new Entry[newLength];\n        for (int i=0; i<length; i++) {\n            e = entries[i];\n            type = e.iType;\nindex = ((type == null))?0:(type.hashCode() / (newLength - 1));\n            while (newEntries[index] != null) {\n                if (++index >= newLength) {\n                    index = 0;\n                }\n            }\n            newEntries[index] = e;\n        }\n\n        // Swap in new hashtable.\n        iSelectEntries = newEntries;\n        return converter;\n    }",
          "56": "    Converter select(Class<?> type) throws IllegalStateException {\n        // Check the hashtable first.\n        Entry[] entries = iSelectEntries;\n        int length = entries.length;\n        int index = type == null ? 0 : type.hashCode() & (length - 1);\n\n        Entry e;\n        // This loop depends on there being at least one null slot.\n        while ((e = entries[index]) != null) {\n            if (e.iType == type) {\n                return e.iConverter;\n            }\n            if (++index >= length) {\n                index = 0;\n            }\n        }\n\n        // Not found in the hashtable, so do actual work.\n\n        Converter converter = selectSlow(this, type);\n        e = new Entry(type, converter);\n\n        // Save the entry for future selects. This class must be threadsafe,\n        // but there is no synchronization. Since the hashtable is being used\n        // as a cache, it is okay to destroy existing entries. This isn't\n        // likely to occur unless there is a high amount of concurrency. As\n        // time goes on, cache updates will occur less often, and the cache\n        // will fill with all the necessary entries.\n\n        // Do all updates on a copy: slots in iSelectEntries must not be\n        // updated by multiple threads as this can allow all null slots to be\n        // consumed.\n        entries = (Entry[])entries.clone();\n\n        // Add new entry.\n        entries[index] = e;\n\n        // Verify that at least one null slot exists!\n        for (int i=0; i<length; i++) {\n            if (entries[i] == null) {\n                // Found a null slot, swap in new hashtable.\n                iSelectEntries = entries;\n                return converter;\n            }\n        }\n\n        // Double capacity and re-hash.\n\n        int newLength = length << 1;\n        Entry[] newEntries = new Entry[newLength];\n        for (int i=0; i<length; i++) {\n            e = entries[i];\n            type = e.iType;\nindex = ((type == null))?0:((type == null) + (newLength - 1));\n            while (newEntries[index] != null) {\n                if (++index >= newLength) {\n                    index = 0;\n                }\n            }\n            newEntries[index] = e;\n        }\n\n        // Swap in new hashtable.\n        iSelectEntries = newEntries;\n        return converter;\n    }"
}