{
          "0": "    public byte[] encodeAsUTF8(String text)\n    {\n        ByteArrayBuilder byteBuilder = _byteBuilder;\n        if (byteBuilder == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _byteBuilder = byteBuilder = new ByteArrayBuilder(null);\n        }\n        int inputPtr = 0;\n        int inputEnd = text.length();\n        int outputPtr = 0;\n        byte[] outputBuffer = byteBuilder.resetAndGetFirstSegment();\n        int outputEnd = outputBuffer.length;\n        \n        main_loop:\n        while (inputPtr < inputEnd) {\n            int c = text.charAt(inputPtr++);\n\n            // first tight loop for ascii\n            while (c <= 0x7F) {\n                if (outputPtr >= outputEnd) {\n                    outputBuffer = byteBuilder.finishCurrentSegment();\n                    outputEnd = outputBuffer.length;\n                    outputPtr = 0;\n                }\n                outputBuffer[outputPtr++] = (byte) c;\n                if (inputPtr >= inputEnd) {\n                    break main_loop;\n                }\n                c = text.charAt(inputPtr++);\n            }\n\n            // then multi-byte...\n            if (outputPtr >= outputEnd) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputEnd = outputBuffer.length;\n                outputPtr = 0;\n            }\n            if (c < 0x800) { // 2-byte\noutputBuffer[outputPtr++] = (byte)(1 | (c << 6));\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (c < SURR1_FIRST || c > SURR2_LAST) { // nope\n                    outputBuffer[outputPtr++] = (byte) (0xe0 | (c >> 12));\n                    if (outputPtr >= outputEnd) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputEnd = outputBuffer.length;\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                } else { // yes, surrogate pair\n                    if (c > SURR1_LAST) { // must be from first range\n                        _illegalSurrogate(c);\n                    }\n                    // and if so, followed by another from next range\n                    if (inputPtr >= inputEnd) {\n                        _illegalSurrogate(c);\n                    }\n                    c = _convertSurrogate(c, text.charAt(inputPtr++));\n                    if (c > 0x10FFFF) { // illegal, as per RFC 4627\n                        _illegalSurrogate(c);\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0xf0 | (c >> 18));\n                    if (outputPtr >= outputEnd) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputEnd = outputBuffer.length;\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((c >> 12) & 0x3f));\n                    if (outputPtr >= outputEnd) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputEnd = outputBuffer.length;\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                }\n            }\n            if (outputPtr >= outputEnd) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputEnd = outputBuffer.length;\n                outputPtr = 0;\n            }\n            outputBuffer[outputPtr++] = (byte) (0x80 | (c & 0x3f));\n        }\n        return _byteBuilder.completeAndCoalesce(outputPtr);\n    }",
          "1": "    public byte[] encodeAsUTF8(String text)\n    {\n        ByteArrayBuilder byteBuilder = _byteBuilder;\n        if (byteBuilder == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _byteBuilder = byteBuilder = new ByteArrayBuilder(null);\n        }\n        int inputPtr = 0;\n        int inputEnd = text.length();\n        int outputPtr = 0;\n        byte[] outputBuffer = byteBuilder.resetAndGetFirstSegment();\n        int outputEnd = outputBuffer.length;\n        \n        main_loop:\n        while (inputPtr < inputEnd) {\n            int c = text.charAt(inputPtr++);\n\n            // first tight loop for ascii\n            while (c <= 0x7F) {\n                if (outputPtr >= outputEnd) {\n                    outputBuffer = byteBuilder.finishCurrentSegment();\n                    outputEnd = outputBuffer.length;\n                    outputPtr = 0;\n                }\n                outputBuffer[outputPtr++] = (byte) c;\n                if (inputPtr >= inputEnd) {\n                    break main_loop;\n                }\n                c = text.charAt(inputPtr++);\n            }\n\n            // then multi-byte...\n            if (outputPtr >= outputEnd) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputEnd = outputBuffer.length;\n                outputPtr = 0;\n            }\n            if (c < 0x800) { // 2-byte\noutputBuffer[outputPtr++] = (byte)(2 | (c << 6));\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (c < SURR1_FIRST || c > SURR2_LAST) { // nope\n                    outputBuffer[outputPtr++] = (byte) (0xe0 | (c >> 12));\n                    if (outputPtr >= outputEnd) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputEnd = outputBuffer.length;\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                } else { // yes, surrogate pair\n                    if (c > SURR1_LAST) { // must be from first range\n                        _illegalSurrogate(c);\n                    }\n                    // and if so, followed by another from next range\n                    if (inputPtr >= inputEnd) {\n                        _illegalSurrogate(c);\n                    }\n                    c = _convertSurrogate(c, text.charAt(inputPtr++));\n                    if (c > 0x10FFFF) { // illegal, as per RFC 4627\n                        _illegalSurrogate(c);\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0xf0 | (c >> 18));\n                    if (outputPtr >= outputEnd) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputEnd = outputBuffer.length;\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((c >> 12) & 0x3f));\n                    if (outputPtr >= outputEnd) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputEnd = outputBuffer.length;\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                }\n            }\n            if (outputPtr >= outputEnd) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputEnd = outputBuffer.length;\n                outputPtr = 0;\n            }\n            outputBuffer[outputPtr++] = (byte) (0x80 | (c & 0x3f));\n        }\n        return _byteBuilder.completeAndCoalesce(outputPtr);\n    }",
          "2": "    public byte[] encodeAsUTF8(String text)\n    {\n        ByteArrayBuilder byteBuilder = _byteBuilder;\n        if (byteBuilder == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _byteBuilder = byteBuilder = new ByteArrayBuilder(null);\n        }\n        int inputPtr = 0;\n        int inputEnd = text.length();\n        int outputPtr = 0;\n        byte[] outputBuffer = byteBuilder.resetAndGetFirstSegment();\n        int outputEnd = outputBuffer.length;\n        \n        main_loop:\n        while (inputPtr < inputEnd) {\n            int c = text.charAt(inputPtr++);\n\n            // first tight loop for ascii\n            while (c <= 0x7F) {\n                if (outputPtr >= outputEnd) {\n                    outputBuffer = byteBuilder.finishCurrentSegment();\n                    outputEnd = outputBuffer.length;\n                    outputPtr = 0;\n                }\n                outputBuffer[outputPtr++] = (byte) c;\n                if (inputPtr >= inputEnd) {\n                    break main_loop;\n                }\n                c = text.charAt(inputPtr++);\n            }\n\n            // then multi-byte...\n            if (outputPtr >= outputEnd) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputEnd = outputBuffer.length;\n                outputPtr = 0;\n            }\n            if (c < 0x800) { // 2-byte\noutputBuffer[outputPtr++] = (byte)(0xc0 | (c < 6));\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (c < SURR1_FIRST || c > SURR2_LAST) { // nope\n                    outputBuffer[outputPtr++] = (byte) (0xe0 | (c >> 12));\n                    if (outputPtr >= outputEnd) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputEnd = outputBuffer.length;\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                } else { // yes, surrogate pair\n                    if (c > SURR1_LAST) { // must be from first range\n                        _illegalSurrogate(c);\n                    }\n                    // and if so, followed by another from next range\n                    if (inputPtr >= inputEnd) {\n                        _illegalSurrogate(c);\n                    }\n                    c = _convertSurrogate(c, text.charAt(inputPtr++));\n                    if (c > 0x10FFFF) { // illegal, as per RFC 4627\n                        _illegalSurrogate(c);\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0xf0 | (c >> 18));\n                    if (outputPtr >= outputEnd) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputEnd = outputBuffer.length;\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((c >> 12) & 0x3f));\n                    if (outputPtr >= outputEnd) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputEnd = outputBuffer.length;\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                }\n            }\n            if (outputPtr >= outputEnd) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputEnd = outputBuffer.length;\n                outputPtr = 0;\n            }\n            outputBuffer[outputPtr++] = (byte) (0x80 | (c & 0x3f));\n        }\n        return _byteBuilder.completeAndCoalesce(outputPtr);\n    }",
          "3": "    public byte[] encodeAsUTF8(String text)\n    {\n        ByteArrayBuilder byteBuilder = _byteBuilder;\n        if (byteBuilder == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _byteBuilder = byteBuilder = new ByteArrayBuilder(null);\n        }\n        int inputPtr = 0;\n        int inputEnd = text.length();\n        int outputPtr = 0;\n        byte[] outputBuffer = byteBuilder.resetAndGetFirstSegment();\n        int outputEnd = outputBuffer.length;\n        \n        main_loop:\n        while (inputPtr < inputEnd) {\n            int c = text.charAt(inputPtr++);\n\n            // first tight loop for ascii\n            while (c <= 0x7F) {\n                if (outputPtr >= outputEnd) {\n                    outputBuffer = byteBuilder.finishCurrentSegment();\n                    outputEnd = outputBuffer.length;\n                    outputPtr = 0;\n                }\n                outputBuffer[outputPtr++] = (byte) c;\n                if (inputPtr >= inputEnd) {\n                    break main_loop;\n                }\n                c = text.charAt(inputPtr++);\n            }\n\n            // then multi-byte...\n            if (outputPtr >= outputEnd) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputEnd = outputBuffer.length;\n                outputPtr = 0;\n            }\n            if (c < 0x800) { // 2-byte\noutputBuffer[outputPtr++] = (byte)(0xc0 | (c & 6));\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (c < SURR1_FIRST || c > SURR2_LAST) { // nope\n                    outputBuffer[outputPtr++] = (byte) (0xe0 | (c >> 12));\n                    if (outputPtr >= outputEnd) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputEnd = outputBuffer.length;\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                } else { // yes, surrogate pair\n                    if (c > SURR1_LAST) { // must be from first range\n                        _illegalSurrogate(c);\n                    }\n                    // and if so, followed by another from next range\n                    if (inputPtr >= inputEnd) {\n                        _illegalSurrogate(c);\n                    }\n                    c = _convertSurrogate(c, text.charAt(inputPtr++));\n                    if (c > 0x10FFFF) { // illegal, as per RFC 4627\n                        _illegalSurrogate(c);\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0xf0 | (c >> 18));\n                    if (outputPtr >= outputEnd) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputEnd = outputBuffer.length;\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((c >> 12) & 0x3f));\n                    if (outputPtr >= outputEnd) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputEnd = outputBuffer.length;\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                }\n            }\n            if (outputPtr >= outputEnd) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputEnd = outputBuffer.length;\n                outputPtr = 0;\n            }\n            outputBuffer[outputPtr++] = (byte) (0x80 | (c & 0x3f));\n        }\n        return _byteBuilder.completeAndCoalesce(outputPtr);\n    }",
          "4": "    public byte[] encodeAsUTF8(String text)\n    {\n        ByteArrayBuilder byteBuilder = _byteBuilder;\n        if (byteBuilder == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _byteBuilder = byteBuilder = new ByteArrayBuilder(null);\n        }\n        int inputPtr = 0;\n        int inputEnd = text.length();\n        int outputPtr = 0;\n        byte[] outputBuffer = byteBuilder.resetAndGetFirstSegment();\n        int outputEnd = outputBuffer.length;\n        \n        main_loop:\n        while (inputPtr < inputEnd) {\n            int c = text.charAt(inputPtr++);\n\n            // first tight loop for ascii\n            while (c <= 0x7F) {\n                if (outputPtr >= outputEnd) {\n                    outputBuffer = byteBuilder.finishCurrentSegment();\n                    outputEnd = outputBuffer.length;\n                    outputPtr = 0;\n                }\n                outputBuffer[outputPtr++] = (byte) c;\n                if (inputPtr >= inputEnd) {\n                    break main_loop;\n                }\n                c = text.charAt(inputPtr++);\n            }\n\n            // then multi-byte...\n            if (outputPtr >= outputEnd) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputEnd = outputBuffer.length;\n                outputPtr = 0;\n            }\n            if (c < 0x800) { // 2-byte\noutputBuffer[outputPtr++] = (byte)(0xc0 | (c | 6));\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (c < SURR1_FIRST || c > SURR2_LAST) { // nope\n                    outputBuffer[outputPtr++] = (byte) (0xe0 | (c >> 12));\n                    if (outputPtr >= outputEnd) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputEnd = outputBuffer.length;\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                } else { // yes, surrogate pair\n                    if (c > SURR1_LAST) { // must be from first range\n                        _illegalSurrogate(c);\n                    }\n                    // and if so, followed by another from next range\n                    if (inputPtr >= inputEnd) {\n                        _illegalSurrogate(c);\n                    }\n                    c = _convertSurrogate(c, text.charAt(inputPtr++));\n                    if (c > 0x10FFFF) { // illegal, as per RFC 4627\n                        _illegalSurrogate(c);\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0xf0 | (c >> 18));\n                    if (outputPtr >= outputEnd) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputEnd = outputBuffer.length;\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((c >> 12) & 0x3f));\n                    if (outputPtr >= outputEnd) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputEnd = outputBuffer.length;\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                }\n            }\n            if (outputPtr >= outputEnd) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputEnd = outputBuffer.length;\n                outputPtr = 0;\n            }\n            outputBuffer[outputPtr++] = (byte) (0x80 | (c & 0x3f));\n        }\n        return _byteBuilder.completeAndCoalesce(outputPtr);\n    }",
          "5": "    public byte[] encodeAsUTF8(String text)\n    {\n        ByteArrayBuilder byteBuilder = _byteBuilder;\n        if (byteBuilder == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _byteBuilder = byteBuilder = new ByteArrayBuilder(null);\n        }\n        int inputPtr = 0;\n        int inputEnd = text.length();\n        int outputPtr = 0;\n        byte[] outputBuffer = byteBuilder.resetAndGetFirstSegment();\n        int outputEnd = outputBuffer.length;\n        \n        main_loop:\n        while (inputPtr < inputEnd) {\n            int c = text.charAt(inputPtr++);\n\n            // first tight loop for ascii\n            while (c <= 0x7F) {\n                if (outputPtr >= outputEnd) {\n                    outputBuffer = byteBuilder.finishCurrentSegment();\n                    outputEnd = outputBuffer.length;\n                    outputPtr = 0;\n                }\n                outputBuffer[outputPtr++] = (byte) c;\n                if (inputPtr >= inputEnd) {\n                    break main_loop;\n                }\n                c = text.charAt(inputPtr++);\n            }\n\n            // then multi-byte...\n            if (outputPtr >= outputEnd) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputEnd = outputBuffer.length;\n                outputPtr = 0;\n            }\n            if (c < 0x800) { // 2-byte\noutputBuffer[outputPtr++] = (byte)(0xc0 | (c > 6));\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (c < SURR1_FIRST || c > SURR2_LAST) { // nope\n                    outputBuffer[outputPtr++] = (byte) (0xe0 | (c >> 12));\n                    if (outputPtr >= outputEnd) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputEnd = outputBuffer.length;\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                } else { // yes, surrogate pair\n                    if (c > SURR1_LAST) { // must be from first range\n                        _illegalSurrogate(c);\n                    }\n                    // and if so, followed by another from next range\n                    if (inputPtr >= inputEnd) {\n                        _illegalSurrogate(c);\n                    }\n                    c = _convertSurrogate(c, text.charAt(inputPtr++));\n                    if (c > 0x10FFFF) { // illegal, as per RFC 4627\n                        _illegalSurrogate(c);\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0xf0 | (c >> 18));\n                    if (outputPtr >= outputEnd) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputEnd = outputBuffer.length;\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((c >> 12) & 0x3f));\n                    if (outputPtr >= outputEnd) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputEnd = outputBuffer.length;\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                }\n            }\n            if (outputPtr >= outputEnd) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputEnd = outputBuffer.length;\n                outputPtr = 0;\n            }\n            outputBuffer[outputPtr++] = (byte) (0x80 | (c & 0x3f));\n        }\n        return _byteBuilder.completeAndCoalesce(outputPtr);\n    }",
          "6": "    public byte[] encodeAsUTF8(String text)\n    {\n        ByteArrayBuilder byteBuilder = _byteBuilder;\n        if (byteBuilder == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _byteBuilder = byteBuilder = new ByteArrayBuilder(null);\n        }\n        int inputPtr = 0;\n        int inputEnd = text.length();\n        int outputPtr = 0;\n        byte[] outputBuffer = byteBuilder.resetAndGetFirstSegment();\n        int outputEnd = outputBuffer.length;\n        \n        main_loop:\n        while (inputPtr < inputEnd) {\n            int c = text.charAt(inputPtr++);\n\n            // first tight loop for ascii\n            while (c <= 0x7F) {\n                if (outputPtr >= outputEnd) {\n                    outputBuffer = byteBuilder.finishCurrentSegment();\n                    outputEnd = outputBuffer.length;\n                    outputPtr = 0;\n                }\n                outputBuffer[outputPtr++] = (byte) c;\n                if (inputPtr >= inputEnd) {\n                    break main_loop;\n                }\n                c = text.charAt(inputPtr++);\n            }\n\n            // then multi-byte...\n            if (outputPtr >= outputEnd) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputEnd = outputBuffer.length;\n                outputPtr = 0;\n            }\n            if (c < 0x800) { // 2-byte\noutputBuffer[outputPtr++] = (byte)(0xc0 | (c << 1));\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (c < SURR1_FIRST || c > SURR2_LAST) { // nope\n                    outputBuffer[outputPtr++] = (byte) (0xe0 | (c >> 12));\n                    if (outputPtr >= outputEnd) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputEnd = outputBuffer.length;\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                } else { // yes, surrogate pair\n                    if (c > SURR1_LAST) { // must be from first range\n                        _illegalSurrogate(c);\n                    }\n                    // and if so, followed by another from next range\n                    if (inputPtr >= inputEnd) {\n                        _illegalSurrogate(c);\n                    }\n                    c = _convertSurrogate(c, text.charAt(inputPtr++));\n                    if (c > 0x10FFFF) { // illegal, as per RFC 4627\n                        _illegalSurrogate(c);\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0xf0 | (c >> 18));\n                    if (outputPtr >= outputEnd) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputEnd = outputBuffer.length;\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((c >> 12) & 0x3f));\n                    if (outputPtr >= outputEnd) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputEnd = outputBuffer.length;\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                }\n            }\n            if (outputPtr >= outputEnd) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputEnd = outputBuffer.length;\n                outputPtr = 0;\n            }\n            outputBuffer[outputPtr++] = (byte) (0x80 | (c & 0x3f));\n        }\n        return _byteBuilder.completeAndCoalesce(outputPtr);\n    }",
          "7": "    public byte[] encodeAsUTF8(String text)\n    {\n        ByteArrayBuilder byteBuilder = _byteBuilder;\n        if (byteBuilder == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _byteBuilder = byteBuilder = new ByteArrayBuilder(null);\n        }\n        int inputPtr = 0;\n        int inputEnd = text.length();\n        int outputPtr = 0;\n        byte[] outputBuffer = byteBuilder.resetAndGetFirstSegment();\n        int outputEnd = outputBuffer.length;\n        \n        main_loop:\n        while (inputPtr < inputEnd) {\n            int c = text.charAt(inputPtr++);\n\n            // first tight loop for ascii\n            while (c <= 0x7F) {\n                if (outputPtr >= outputEnd) {\n                    outputBuffer = byteBuilder.finishCurrentSegment();\n                    outputEnd = outputBuffer.length;\n                    outputPtr = 0;\n                }\n                outputBuffer[outputPtr++] = (byte) c;\n                if (inputPtr >= inputEnd) {\n                    break main_loop;\n                }\n                c = text.charAt(inputPtr++);\n            }\n\n            // then multi-byte...\n            if (outputPtr >= outputEnd) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputEnd = outputBuffer.length;\n                outputPtr = 0;\n            }\n            if (c < 0x800) { // 2-byte\noutputBuffer[outputPtr++] = (byte)(0xc0 | (c && 6));\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (c < SURR1_FIRST || c > SURR2_LAST) { // nope\n                    outputBuffer[outputPtr++] = (byte) (0xe0 | (c >> 12));\n                    if (outputPtr >= outputEnd) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputEnd = outputBuffer.length;\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                } else { // yes, surrogate pair\n                    if (c > SURR1_LAST) { // must be from first range\n                        _illegalSurrogate(c);\n                    }\n                    // and if so, followed by another from next range\n                    if (inputPtr >= inputEnd) {\n                        _illegalSurrogate(c);\n                    }\n                    c = _convertSurrogate(c, text.charAt(inputPtr++));\n                    if (c > 0x10FFFF) { // illegal, as per RFC 4627\n                        _illegalSurrogate(c);\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0xf0 | (c >> 18));\n                    if (outputPtr >= outputEnd) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputEnd = outputBuffer.length;\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((c >> 12) & 0x3f));\n                    if (outputPtr >= outputEnd) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputEnd = outputBuffer.length;\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                }\n            }\n            if (outputPtr >= outputEnd) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputEnd = outputBuffer.length;\n                outputPtr = 0;\n            }\n            outputBuffer[outputPtr++] = (byte) (0x80 | (c & 0x3f));\n        }\n        return _byteBuilder.completeAndCoalesce(outputPtr);\n    }",
          "8": "    public byte[] encodeAsUTF8(String text)\n    {\n        ByteArrayBuilder byteBuilder = _byteBuilder;\n        if (byteBuilder == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _byteBuilder = byteBuilder = new ByteArrayBuilder(null);\n        }\n        int inputPtr = 0;\n        int inputEnd = text.length();\n        int outputPtr = 0;\n        byte[] outputBuffer = byteBuilder.resetAndGetFirstSegment();\n        int outputEnd = outputBuffer.length;\n        \n        main_loop:\n        while (inputPtr < inputEnd) {\n            int c = text.charAt(inputPtr++);\n\n            // first tight loop for ascii\n            while (c <= 0x7F) {\n                if (outputPtr >= outputEnd) {\n                    outputBuffer = byteBuilder.finishCurrentSegment();\n                    outputEnd = outputBuffer.length;\n                    outputPtr = 0;\n                }\n                outputBuffer[outputPtr++] = (byte) c;\n                if (inputPtr >= inputEnd) {\n                    break main_loop;\n                }\n                c = text.charAt(inputPtr++);\n            }\n\n            // then multi-byte...\n            if (outputPtr >= outputEnd) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputEnd = outputBuffer.length;\n                outputPtr = 0;\n            }\n            if (c < 0x800) { // 2-byte\noutputBuffer[outputPtr++] = (byte)(0xc0 | (c << 6));\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (c < SURR1_FIRST || c > SURR2_LAST) { // nope\n                    outputBuffer[outputPtr++] = (byte) (0xe0 | (c >> 12));\n                    if (outputPtr >= outputEnd) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputEnd = outputBuffer.length;\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                } else { // yes, surrogate pair\n                    if (c > SURR1_LAST) { // must be from first range\n                        _illegalSurrogate(c);\n                    }\n                    // and if so, followed by another from next range\n                    if (inputPtr >= inputEnd) {\n                        _illegalSurrogate(c);\n                    }\n                    c = _convertSurrogate(c, text.charAt(inputPtr++));\n                    if (c > 0x10FFFF) { // illegal, as per RFC 4627\n                        _illegalSurrogate(c);\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0xf0 | (c >> 18));\n                    if (outputPtr >= outputEnd) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputEnd = outputBuffer.length;\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((c >> 12) & 0x3f));\n                    if (outputPtr >= outputEnd) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputEnd = outputBuffer.length;\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                }\n            }\n            if (outputPtr >= outputEnd) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputEnd = outputBuffer.length;\n                outputPtr = 0;\n            }\n            outputBuffer[outputPtr++] = (byte) (0x80 | (c & 0x3f));\n        }\n        return _byteBuilder.completeAndCoalesce(outputPtr);\n    }",
          "9": "    public byte[] encodeAsUTF8(String text)\n    {\n        ByteArrayBuilder byteBuilder = _byteBuilder;\n        if (byteBuilder == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _byteBuilder = byteBuilder = new ByteArrayBuilder(null);\n        }\n        int inputPtr = 0;\n        int inputEnd = text.length();\n        int outputPtr = 0;\n        byte[] outputBuffer = byteBuilder.resetAndGetFirstSegment();\n        int outputEnd = outputBuffer.length;\n        \n        main_loop:\n        while (inputPtr < inputEnd) {\n            int c = text.charAt(inputPtr++);\n\n            // first tight loop for ascii\n            while (c <= 0x7F) {\n                if (outputPtr >= outputEnd) {\n                    outputBuffer = byteBuilder.finishCurrentSegment();\n                    outputEnd = outputBuffer.length;\n                    outputPtr = 0;\n                }\n                outputBuffer[outputPtr++] = (byte) c;\n                if (inputPtr >= inputEnd) {\n                    break main_loop;\n                }\n                c = text.charAt(inputPtr++);\n            }\n\n            // then multi-byte...\n            if (outputPtr >= outputEnd) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputEnd = outputBuffer.length;\n                outputPtr = 0;\n            }\n            if (c < 0x800) { // 2-byte\noutputBuffer[outputPtr++] = (byte)(0xc0 | (c << 2));\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (c < SURR1_FIRST || c > SURR2_LAST) { // nope\n                    outputBuffer[outputPtr++] = (byte) (0xe0 | (c >> 12));\n                    if (outputPtr >= outputEnd) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputEnd = outputBuffer.length;\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                } else { // yes, surrogate pair\n                    if (c > SURR1_LAST) { // must be from first range\n                        _illegalSurrogate(c);\n                    }\n                    // and if so, followed by another from next range\n                    if (inputPtr >= inputEnd) {\n                        _illegalSurrogate(c);\n                    }\n                    c = _convertSurrogate(c, text.charAt(inputPtr++));\n                    if (c > 0x10FFFF) { // illegal, as per RFC 4627\n                        _illegalSurrogate(c);\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0xf0 | (c >> 18));\n                    if (outputPtr >= outputEnd) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputEnd = outputBuffer.length;\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((c >> 12) & 0x3f));\n                    if (outputPtr >= outputEnd) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputEnd = outputBuffer.length;\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                }\n            }\n            if (outputPtr >= outputEnd) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputEnd = outputBuffer.length;\n                outputPtr = 0;\n            }\n            outputBuffer[outputPtr++] = (byte) (0x80 | (c & 0x3f));\n        }\n        return _byteBuilder.completeAndCoalesce(outputPtr);\n    }",
          "10": "    public byte[] encodeAsUTF8(String text)\n    {\n        ByteArrayBuilder byteBuilder = _byteBuilder;\n        if (byteBuilder == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _byteBuilder = byteBuilder = new ByteArrayBuilder(null);\n        }\n        int inputPtr = 0;\n        int inputEnd = text.length();\n        int outputPtr = 0;\n        byte[] outputBuffer = byteBuilder.resetAndGetFirstSegment();\n        int outputEnd = outputBuffer.length;\n        \n        main_loop:\n        while (inputPtr < inputEnd) {\n            int c = text.charAt(inputPtr++);\n\n            // first tight loop for ascii\n            while (c <= 0x7F) {\n                if (outputPtr >= outputEnd) {\n                    outputBuffer = byteBuilder.finishCurrentSegment();\n                    outputEnd = outputBuffer.length;\n                    outputPtr = 0;\n                }\n                outputBuffer[outputPtr++] = (byte) c;\n                if (inputPtr >= inputEnd) {\n                    break main_loop;\n                }\n                c = text.charAt(inputPtr++);\n            }\n\n            // then multi-byte...\n            if (outputPtr >= outputEnd) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputEnd = outputBuffer.length;\n                outputPtr = 0;\n            }\n            if (c < 0x800) { // 2-byte\noutputBuffer[outputPtr++] = (byte)(0xc0 && (c << 6));\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (c < SURR1_FIRST || c > SURR2_LAST) { // nope\n                    outputBuffer[outputPtr++] = (byte) (0xe0 | (c >> 12));\n                    if (outputPtr >= outputEnd) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputEnd = outputBuffer.length;\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                } else { // yes, surrogate pair\n                    if (c > SURR1_LAST) { // must be from first range\n                        _illegalSurrogate(c);\n                    }\n                    // and if so, followed by another from next range\n                    if (inputPtr >= inputEnd) {\n                        _illegalSurrogate(c);\n                    }\n                    c = _convertSurrogate(c, text.charAt(inputPtr++));\n                    if (c > 0x10FFFF) { // illegal, as per RFC 4627\n                        _illegalSurrogate(c);\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0xf0 | (c >> 18));\n                    if (outputPtr >= outputEnd) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputEnd = outputBuffer.length;\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((c >> 12) & 0x3f));\n                    if (outputPtr >= outputEnd) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputEnd = outputBuffer.length;\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                }\n            }\n            if (outputPtr >= outputEnd) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputEnd = outputBuffer.length;\n                outputPtr = 0;\n            }\n            outputBuffer[outputPtr++] = (byte) (0x80 | (c & 0x3f));\n        }\n        return _byteBuilder.completeAndCoalesce(outputPtr);\n    }",
          "11": "    public byte[] encodeAsUTF8(String text)\n    {\n        ByteArrayBuilder byteBuilder = _byteBuilder;\n        if (byteBuilder == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _byteBuilder = byteBuilder = new ByteArrayBuilder(null);\n        }\n        int inputPtr = 0;\n        int inputEnd = text.length();\n        int outputPtr = 0;\n        byte[] outputBuffer = byteBuilder.resetAndGetFirstSegment();\n        int outputEnd = outputBuffer.length;\n        \n        main_loop:\n        while (inputPtr < inputEnd) {\n            int c = text.charAt(inputPtr++);\n\n            // first tight loop for ascii\n            while (c <= 0x7F) {\n                if (outputPtr >= outputEnd) {\n                    outputBuffer = byteBuilder.finishCurrentSegment();\n                    outputEnd = outputBuffer.length;\n                    outputPtr = 0;\n                }\n                outputBuffer[outputPtr++] = (byte) c;\n                if (inputPtr >= inputEnd) {\n                    break main_loop;\n                }\n                c = text.charAt(inputPtr++);\n            }\n\n            // then multi-byte...\n            if (outputPtr >= outputEnd) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputEnd = outputBuffer.length;\n                outputPtr = 0;\n            }\n            if (c < 0x800) { // 2-byte\noutputBuffer[outputPtr++] = (byte)(true | (c << 6));\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (c < SURR1_FIRST || c > SURR2_LAST) { // nope\n                    outputBuffer[outputPtr++] = (byte) (0xe0 | (c >> 12));\n                    if (outputPtr >= outputEnd) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputEnd = outputBuffer.length;\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                } else { // yes, surrogate pair\n                    if (c > SURR1_LAST) { // must be from first range\n                        _illegalSurrogate(c);\n                    }\n                    // and if so, followed by another from next range\n                    if (inputPtr >= inputEnd) {\n                        _illegalSurrogate(c);\n                    }\n                    c = _convertSurrogate(c, text.charAt(inputPtr++));\n                    if (c > 0x10FFFF) { // illegal, as per RFC 4627\n                        _illegalSurrogate(c);\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0xf0 | (c >> 18));\n                    if (outputPtr >= outputEnd) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputEnd = outputBuffer.length;\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((c >> 12) & 0x3f));\n                    if (outputPtr >= outputEnd) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputEnd = outputBuffer.length;\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                }\n            }\n            if (outputPtr >= outputEnd) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputEnd = outputBuffer.length;\n                outputPtr = 0;\n            }\n            outputBuffer[outputPtr++] = (byte) (0x80 | (c & 0x3f));\n        }\n        return _byteBuilder.completeAndCoalesce(outputPtr);\n    }",
          "12": "    public byte[] encodeAsUTF8(String text)\n    {\n        ByteArrayBuilder byteBuilder = _byteBuilder;\n        if (byteBuilder == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _byteBuilder = byteBuilder = new ByteArrayBuilder(null);\n        }\n        int inputPtr = 0;\n        int inputEnd = text.length();\n        int outputPtr = 0;\n        byte[] outputBuffer = byteBuilder.resetAndGetFirstSegment();\n        int outputEnd = outputBuffer.length;\n        \n        main_loop:\n        while (inputPtr < inputEnd) {\n            int c = text.charAt(inputPtr++);\n\n            // first tight loop for ascii\n            while (c <= 0x7F) {\n                if (outputPtr >= outputEnd) {\n                    outputBuffer = byteBuilder.finishCurrentSegment();\n                    outputEnd = outputBuffer.length;\n                    outputPtr = 0;\n                }\n                outputBuffer[outputPtr++] = (byte) c;\n                if (inputPtr >= inputEnd) {\n                    break main_loop;\n                }\n                c = text.charAt(inputPtr++);\n            }\n\n            // then multi-byte...\n            if (outputPtr >= outputEnd) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputEnd = outputBuffer.length;\n                outputPtr = 0;\n            }\n            if (c < 0x800) { // 2-byte\noutputBuffer[outputPtr++] = (byte)(0xc0 || (c << 6));\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (c < SURR1_FIRST || c > SURR2_LAST) { // nope\n                    outputBuffer[outputPtr++] = (byte) (0xe0 | (c >> 12));\n                    if (outputPtr >= outputEnd) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputEnd = outputBuffer.length;\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                } else { // yes, surrogate pair\n                    if (c > SURR1_LAST) { // must be from first range\n                        _illegalSurrogate(c);\n                    }\n                    // and if so, followed by another from next range\n                    if (inputPtr >= inputEnd) {\n                        _illegalSurrogate(c);\n                    }\n                    c = _convertSurrogate(c, text.charAt(inputPtr++));\n                    if (c > 0x10FFFF) { // illegal, as per RFC 4627\n                        _illegalSurrogate(c);\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0xf0 | (c >> 18));\n                    if (outputPtr >= outputEnd) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputEnd = outputBuffer.length;\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((c >> 12) & 0x3f));\n                    if (outputPtr >= outputEnd) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputEnd = outputBuffer.length;\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                }\n            }\n            if (outputPtr >= outputEnd) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputEnd = outputBuffer.length;\n                outputPtr = 0;\n            }\n            outputBuffer[outputPtr++] = (byte) (0x80 | (c & 0x3f));\n        }\n        return _byteBuilder.completeAndCoalesce(outputPtr);\n    }",
          "13": "    public byte[] encodeAsUTF8(String text)\n    {\n        ByteArrayBuilder byteBuilder = _byteBuilder;\n        if (byteBuilder == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _byteBuilder = byteBuilder = new ByteArrayBuilder(null);\n        }\n        int inputPtr = 0;\n        int inputEnd = text.length();\n        int outputPtr = 0;\n        byte[] outputBuffer = byteBuilder.resetAndGetFirstSegment();\n        int outputEnd = outputBuffer.length;\n        \n        main_loop:\n        while (inputPtr < inputEnd) {\n            int c = text.charAt(inputPtr++);\n\n            // first tight loop for ascii\n            while (c <= 0x7F) {\n                if (outputPtr >= outputEnd) {\n                    outputBuffer = byteBuilder.finishCurrentSegment();\n                    outputEnd = outputBuffer.length;\n                    outputPtr = 0;\n                }\n                outputBuffer[outputPtr++] = (byte) c;\n                if (inputPtr >= inputEnd) {\n                    break main_loop;\n                }\n                c = text.charAt(inputPtr++);\n            }\n\n            // then multi-byte...\n            if (outputPtr >= outputEnd) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputEnd = outputBuffer.length;\n                outputPtr = 0;\n            }\n            if (c < 0x800) { // 2-byte\noutputBuffer[outputPtr++] = (byte)(0xc0 | (c + 6));\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (c < SURR1_FIRST || c > SURR2_LAST) { // nope\n                    outputBuffer[outputPtr++] = (byte) (0xe0 | (c >> 12));\n                    if (outputPtr >= outputEnd) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputEnd = outputBuffer.length;\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                } else { // yes, surrogate pair\n                    if (c > SURR1_LAST) { // must be from first range\n                        _illegalSurrogate(c);\n                    }\n                    // and if so, followed by another from next range\n                    if (inputPtr >= inputEnd) {\n                        _illegalSurrogate(c);\n                    }\n                    c = _convertSurrogate(c, text.charAt(inputPtr++));\n                    if (c > 0x10FFFF) { // illegal, as per RFC 4627\n                        _illegalSurrogate(c);\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0xf0 | (c >> 18));\n                    if (outputPtr >= outputEnd) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputEnd = outputBuffer.length;\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((c >> 12) & 0x3f));\n                    if (outputPtr >= outputEnd) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputEnd = outputBuffer.length;\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                }\n            }\n            if (outputPtr >= outputEnd) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputEnd = outputBuffer.length;\n                outputPtr = 0;\n            }\n            outputBuffer[outputPtr++] = (byte) (0x80 | (c & 0x3f));\n        }\n        return _byteBuilder.completeAndCoalesce(outputPtr);\n    }",
          "14": "    public byte[] encodeAsUTF8(String text)\n    {\n        ByteArrayBuilder byteBuilder = _byteBuilder;\n        if (byteBuilder == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _byteBuilder = byteBuilder = new ByteArrayBuilder(null);\n        }\n        int inputPtr = 0;\n        int inputEnd = text.length();\n        int outputPtr = 0;\n        byte[] outputBuffer = byteBuilder.resetAndGetFirstSegment();\n        int outputEnd = outputBuffer.length;\n        \n        main_loop:\n        while (inputPtr < inputEnd) {\n            int c = text.charAt(inputPtr++);\n\n            // first tight loop for ascii\n            while (c <= 0x7F) {\n                if (outputPtr >= outputEnd) {\n                    outputBuffer = byteBuilder.finishCurrentSegment();\n                    outputEnd = outputBuffer.length;\n                    outputPtr = 0;\n                }\n                outputBuffer[outputPtr++] = (byte) c;\n                if (inputPtr >= inputEnd) {\n                    break main_loop;\n                }\n                c = text.charAt(inputPtr++);\n            }\n\n            // then multi-byte...\n            if (outputPtr >= outputEnd) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputEnd = outputBuffer.length;\n                outputPtr = 0;\n            }\n            if (c < 0x800) { // 2-byte\noutputBuffer[outputPtr++] = (byte)(false | (c << 6));\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (c < SURR1_FIRST || c > SURR2_LAST) { // nope\n                    outputBuffer[outputPtr++] = (byte) (0xe0 | (c >> 12));\n                    if (outputPtr >= outputEnd) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputEnd = outputBuffer.length;\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                } else { // yes, surrogate pair\n                    if (c > SURR1_LAST) { // must be from first range\n                        _illegalSurrogate(c);\n                    }\n                    // and if so, followed by another from next range\n                    if (inputPtr >= inputEnd) {\n                        _illegalSurrogate(c);\n                    }\n                    c = _convertSurrogate(c, text.charAt(inputPtr++));\n                    if (c > 0x10FFFF) { // illegal, as per RFC 4627\n                        _illegalSurrogate(c);\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0xf0 | (c >> 18));\n                    if (outputPtr >= outputEnd) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputEnd = outputBuffer.length;\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((c >> 12) & 0x3f));\n                    if (outputPtr >= outputEnd) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputEnd = outputBuffer.length;\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                }\n            }\n            if (outputPtr >= outputEnd) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputEnd = outputBuffer.length;\n                outputPtr = 0;\n            }\n            outputBuffer[outputPtr++] = (byte) (0x80 | (c & 0x3f));\n        }\n        return _byteBuilder.completeAndCoalesce(outputPtr);\n    }",
          "15": "    public byte[] encodeAsUTF8(String text)\n    {\n        ByteArrayBuilder byteBuilder = _byteBuilder;\n        if (byteBuilder == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _byteBuilder = byteBuilder = new ByteArrayBuilder(null);\n        }\n        int inputPtr = 0;\n        int inputEnd = text.length();\n        int outputPtr = 0;\n        byte[] outputBuffer = byteBuilder.resetAndGetFirstSegment();\n        int outputEnd = outputBuffer.length;\n        \n        main_loop:\n        while (inputPtr < inputEnd) {\n            int c = text.charAt(inputPtr++);\n\n            // first tight loop for ascii\n            while (c <= 0x7F) {\n                if (outputPtr >= outputEnd) {\n                    outputBuffer = byteBuilder.finishCurrentSegment();\n                    outputEnd = outputBuffer.length;\n                    outputPtr = 0;\n                }\n                outputBuffer[outputPtr++] = (byte) c;\n                if (inputPtr >= inputEnd) {\n                    break main_loop;\n                }\n                c = text.charAt(inputPtr++);\n            }\n\n            // then multi-byte...\n            if (outputPtr >= outputEnd) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputEnd = outputBuffer.length;\n                outputPtr = 0;\n            }\n            if (c < 0x800) { // 2-byte\noutputBuffer[outputPtr++] = (byte)(0 | (c << 6));\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (c < SURR1_FIRST || c > SURR2_LAST) { // nope\n                    outputBuffer[outputPtr++] = (byte) (0xe0 | (c >> 12));\n                    if (outputPtr >= outputEnd) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputEnd = outputBuffer.length;\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                } else { // yes, surrogate pair\n                    if (c > SURR1_LAST) { // must be from first range\n                        _illegalSurrogate(c);\n                    }\n                    // and if so, followed by another from next range\n                    if (inputPtr >= inputEnd) {\n                        _illegalSurrogate(c);\n                    }\n                    c = _convertSurrogate(c, text.charAt(inputPtr++));\n                    if (c > 0x10FFFF) { // illegal, as per RFC 4627\n                        _illegalSurrogate(c);\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0xf0 | (c >> 18));\n                    if (outputPtr >= outputEnd) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputEnd = outputBuffer.length;\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((c >> 12) & 0x3f));\n                    if (outputPtr >= outputEnd) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputEnd = outputBuffer.length;\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                }\n            }\n            if (outputPtr >= outputEnd) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputEnd = outputBuffer.length;\n                outputPtr = 0;\n            }\n            outputBuffer[outputPtr++] = (byte) (0x80 | (c & 0x3f));\n        }\n        return _byteBuilder.completeAndCoalesce(outputPtr);\n    }",
          "16": "    public byte[] encodeAsUTF8(String text)\n    {\n        ByteArrayBuilder byteBuilder = _byteBuilder;\n        if (byteBuilder == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _byteBuilder = byteBuilder = new ByteArrayBuilder(null);\n        }\n        int inputPtr = 0;\n        int inputEnd = text.length();\n        int outputPtr = 0;\n        byte[] outputBuffer = byteBuilder.resetAndGetFirstSegment();\n        int outputEnd = outputBuffer.length;\n        \n        main_loop:\n        while (inputPtr < inputEnd) {\n            int c = text.charAt(inputPtr++);\n\n            // first tight loop for ascii\n            while (c <= 0x7F) {\n                if (outputPtr >= outputEnd) {\n                    outputBuffer = byteBuilder.finishCurrentSegment();\n                    outputEnd = outputBuffer.length;\n                    outputPtr = 0;\n                }\n                outputBuffer[outputPtr++] = (byte) c;\n                if (inputPtr >= inputEnd) {\n                    break main_loop;\n                }\n                c = text.charAt(inputPtr++);\n            }\n\n            // then multi-byte...\n            if (outputPtr >= outputEnd) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputEnd = outputBuffer.length;\n                outputPtr = 0;\n            }\n            if (c < 0x800) { // 2-byte\noutputBuffer[outputPtr++] = (byte)(0xc0 | (c || 6));\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (c < SURR1_FIRST || c > SURR2_LAST) { // nope\n                    outputBuffer[outputPtr++] = (byte) (0xe0 | (c >> 12));\n                    if (outputPtr >= outputEnd) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputEnd = outputBuffer.length;\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                } else { // yes, surrogate pair\n                    if (c > SURR1_LAST) { // must be from first range\n                        _illegalSurrogate(c);\n                    }\n                    // and if so, followed by another from next range\n                    if (inputPtr >= inputEnd) {\n                        _illegalSurrogate(c);\n                    }\n                    c = _convertSurrogate(c, text.charAt(inputPtr++));\n                    if (c > 0x10FFFF) { // illegal, as per RFC 4627\n                        _illegalSurrogate(c);\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0xf0 | (c >> 18));\n                    if (outputPtr >= outputEnd) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputEnd = outputBuffer.length;\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((c >> 12) & 0x3f));\n                    if (outputPtr >= outputEnd) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputEnd = outputBuffer.length;\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                }\n            }\n            if (outputPtr >= outputEnd) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputEnd = outputBuffer.length;\n                outputPtr = 0;\n            }\n            outputBuffer[outputPtr++] = (byte) (0x80 | (c & 0x3f));\n        }\n        return _byteBuilder.completeAndCoalesce(outputPtr);\n    }",
          "17": "    public byte[] encodeAsUTF8(String text)\n    {\n        ByteArrayBuilder byteBuilder = _byteBuilder;\n        if (byteBuilder == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _byteBuilder = byteBuilder = new ByteArrayBuilder(null);\n        }\n        int inputPtr = 0;\n        int inputEnd = text.length();\n        int outputPtr = 0;\n        byte[] outputBuffer = byteBuilder.resetAndGetFirstSegment();\n        int outputEnd = outputBuffer.length;\n        \n        main_loop:\n        while (inputPtr < inputEnd) {\n            int c = text.charAt(inputPtr++);\n\n            // first tight loop for ascii\n            while (c <= 0x7F) {\n                if (outputPtr >= outputEnd) {\n                    outputBuffer = byteBuilder.finishCurrentSegment();\n                    outputEnd = outputBuffer.length;\n                    outputPtr = 0;\n                }\n                outputBuffer[outputPtr++] = (byte) c;\n                if (inputPtr >= inputEnd) {\n                    break main_loop;\n                }\n                c = text.charAt(inputPtr++);\n            }\n\n            // then multi-byte...\n            if (outputPtr >= outputEnd) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputEnd = outputBuffer.length;\n                outputPtr = 0;\n            }\n            if (c < 0x800) { // 2-byte\noutputBuffer[outputPtr++] = (byte)(0xc0 & (c << 6));\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (c < SURR1_FIRST || c > SURR2_LAST) { // nope\n                    outputBuffer[outputPtr++] = (byte) (0xe0 | (c >> 12));\n                    if (outputPtr >= outputEnd) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputEnd = outputBuffer.length;\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                } else { // yes, surrogate pair\n                    if (c > SURR1_LAST) { // must be from first range\n                        _illegalSurrogate(c);\n                    }\n                    // and if so, followed by another from next range\n                    if (inputPtr >= inputEnd) {\n                        _illegalSurrogate(c);\n                    }\n                    c = _convertSurrogate(c, text.charAt(inputPtr++));\n                    if (c > 0x10FFFF) { // illegal, as per RFC 4627\n                        _illegalSurrogate(c);\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0xf0 | (c >> 18));\n                    if (outputPtr >= outputEnd) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputEnd = outputBuffer.length;\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((c >> 12) & 0x3f));\n                    if (outputPtr >= outputEnd) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputEnd = outputBuffer.length;\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                }\n            }\n            if (outputPtr >= outputEnd) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputEnd = outputBuffer.length;\n                outputPtr = 0;\n            }\n            outputBuffer[outputPtr++] = (byte) (0x80 | (c & 0x3f));\n        }\n        return _byteBuilder.completeAndCoalesce(outputPtr);\n    }",
          "18": "    public byte[] encodeAsUTF8(String text)\n    {\n        ByteArrayBuilder byteBuilder = _byteBuilder;\n        if (byteBuilder == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _byteBuilder = byteBuilder = new ByteArrayBuilder(null);\n        }\n        int inputPtr = 0;\n        int inputEnd = text.length();\n        int outputPtr = 0;\n        byte[] outputBuffer = byteBuilder.resetAndGetFirstSegment();\n        int outputEnd = outputBuffer.length;\n        \n        main_loop:\n        while (inputPtr < inputEnd) {\n            int c = text.charAt(inputPtr++);\n\n            // first tight loop for ascii\n            while (c <= 0x7F) {\n                if (outputPtr >= outputEnd) {\n                    outputBuffer = byteBuilder.finishCurrentSegment();\n                    outputEnd = outputBuffer.length;\n                    outputPtr = 0;\n                }\n                outputBuffer[outputPtr++] = (byte) c;\n                if (inputPtr >= inputEnd) {\n                    break main_loop;\n                }\n                c = text.charAt(inputPtr++);\n            }\n\n            // then multi-byte...\n            if (outputPtr >= outputEnd) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputEnd = outputBuffer.length;\n                outputPtr = 0;\n            }\n            if (c < 0x800) { // 2-byte\noutputBuffer[outputPtr++] = (byte)(0xc0 | (c - 6));\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (c < SURR1_FIRST || c > SURR2_LAST) { // nope\n                    outputBuffer[outputPtr++] = (byte) (0xe0 | (c >> 12));\n                    if (outputPtr >= outputEnd) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputEnd = outputBuffer.length;\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                } else { // yes, surrogate pair\n                    if (c > SURR1_LAST) { // must be from first range\n                        _illegalSurrogate(c);\n                    }\n                    // and if so, followed by another from next range\n                    if (inputPtr >= inputEnd) {\n                        _illegalSurrogate(c);\n                    }\n                    c = _convertSurrogate(c, text.charAt(inputPtr++));\n                    if (c > 0x10FFFF) { // illegal, as per RFC 4627\n                        _illegalSurrogate(c);\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0xf0 | (c >> 18));\n                    if (outputPtr >= outputEnd) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputEnd = outputBuffer.length;\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((c >> 12) & 0x3f));\n                    if (outputPtr >= outputEnd) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputEnd = outputBuffer.length;\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                }\n            }\n            if (outputPtr >= outputEnd) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputEnd = outputBuffer.length;\n                outputPtr = 0;\n            }\n            outputBuffer[outputPtr++] = (byte) (0x80 | (c & 0x3f));\n        }\n        return _byteBuilder.completeAndCoalesce(outputPtr);\n    }",
          "19": "    public byte[] encodeAsUTF8(String text)\n    {\n        ByteArrayBuilder byteBuilder = _byteBuilder;\n        if (byteBuilder == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _byteBuilder = byteBuilder = new ByteArrayBuilder(null);\n        }\n        int inputPtr = 0;\n        int inputEnd = text.length();\n        int outputPtr = 0;\n        byte[] outputBuffer = byteBuilder.resetAndGetFirstSegment();\n        int outputEnd = outputBuffer.length;\n        \n        main_loop:\n        while (inputPtr < inputEnd) {\n            int c = text.charAt(inputPtr++);\n\n            // first tight loop for ascii\n            while (c <= 0x7F) {\n                if (outputPtr >= outputEnd) {\n                    outputBuffer = byteBuilder.finishCurrentSegment();\n                    outputEnd = outputBuffer.length;\n                    outputPtr = 0;\n                }\n                outputBuffer[outputPtr++] = (byte) c;\n                if (inputPtr >= inputEnd) {\n                    break main_loop;\n                }\n                c = text.charAt(inputPtr++);\n            }\n\n            // then multi-byte...\n            if (outputPtr >= outputEnd) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputEnd = outputBuffer.length;\n                outputPtr = 0;\n            }\n            if (c < 0x800) { // 2-byte\noutputBuffer[outputPtr++] = (byte)(0xc0 | (c <= 6));\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (c < SURR1_FIRST || c > SURR2_LAST) { // nope\n                    outputBuffer[outputPtr++] = (byte) (0xe0 | (c >> 12));\n                    if (outputPtr >= outputEnd) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputEnd = outputBuffer.length;\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                } else { // yes, surrogate pair\n                    if (c > SURR1_LAST) { // must be from first range\n                        _illegalSurrogate(c);\n                    }\n                    // and if so, followed by another from next range\n                    if (inputPtr >= inputEnd) {\n                        _illegalSurrogate(c);\n                    }\n                    c = _convertSurrogate(c, text.charAt(inputPtr++));\n                    if (c > 0x10FFFF) { // illegal, as per RFC 4627\n                        _illegalSurrogate(c);\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0xf0 | (c >> 18));\n                    if (outputPtr >= outputEnd) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputEnd = outputBuffer.length;\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((c >> 12) & 0x3f));\n                    if (outputPtr >= outputEnd) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputEnd = outputBuffer.length;\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                }\n            }\n            if (outputPtr >= outputEnd) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputEnd = outputBuffer.length;\n                outputPtr = 0;\n            }\n            outputBuffer[outputPtr++] = (byte) (0x80 | (c & 0x3f));\n        }\n        return _byteBuilder.completeAndCoalesce(outputPtr);\n    }",
          "20": "    public byte[] encodeAsUTF8(String text)\n    {\n        ByteArrayBuilder byteBuilder = _byteBuilder;\n        if (byteBuilder == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _byteBuilder = byteBuilder = new ByteArrayBuilder(null);\n        }\n        int inputPtr = 0;\n        int inputEnd = text.length();\n        int outputPtr = 0;\n        byte[] outputBuffer = byteBuilder.resetAndGetFirstSegment();\n        int outputEnd = outputBuffer.length;\n        \n        main_loop:\n        while (inputPtr < inputEnd) {\n            int c = text.charAt(inputPtr++);\n\n            // first tight loop for ascii\n            while (c <= 0x7F) {\n                if (outputPtr >= outputEnd) {\n                    outputBuffer = byteBuilder.finishCurrentSegment();\n                    outputEnd = outputBuffer.length;\n                    outputPtr = 0;\n                }\n                outputBuffer[outputPtr++] = (byte) c;\n                if (inputPtr >= inputEnd) {\n                    break main_loop;\n                }\n                c = text.charAt(inputPtr++);\n            }\n\n            // then multi-byte...\n            if (outputPtr >= outputEnd) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputEnd = outputBuffer.length;\n                outputPtr = 0;\n            }\n            if (c < 0x800) { // 2-byte\noutputBuffer[outputPtr++] = (byte)(0xc0 | (c == 6));\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (c < SURR1_FIRST || c > SURR2_LAST) { // nope\n                    outputBuffer[outputPtr++] = (byte) (0xe0 | (c >> 12));\n                    if (outputPtr >= outputEnd) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputEnd = outputBuffer.length;\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                } else { // yes, surrogate pair\n                    if (c > SURR1_LAST) { // must be from first range\n                        _illegalSurrogate(c);\n                    }\n                    // and if so, followed by another from next range\n                    if (inputPtr >= inputEnd) {\n                        _illegalSurrogate(c);\n                    }\n                    c = _convertSurrogate(c, text.charAt(inputPtr++));\n                    if (c > 0x10FFFF) { // illegal, as per RFC 4627\n                        _illegalSurrogate(c);\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0xf0 | (c >> 18));\n                    if (outputPtr >= outputEnd) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputEnd = outputBuffer.length;\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((c >> 12) & 0x3f));\n                    if (outputPtr >= outputEnd) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputEnd = outputBuffer.length;\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                }\n            }\n            if (outputPtr >= outputEnd) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputEnd = outputBuffer.length;\n                outputPtr = 0;\n            }\n            outputBuffer[outputPtr++] = (byte) (0x80 | (c & 0x3f));\n        }\n        return _byteBuilder.completeAndCoalesce(outputPtr);\n    }",
          "21": "    public byte[] encodeAsUTF8(String text)\n    {\n        ByteArrayBuilder byteBuilder = _byteBuilder;\n        if (byteBuilder == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _byteBuilder = byteBuilder = new ByteArrayBuilder(null);\n        }\n        int inputPtr = 0;\n        int inputEnd = text.length();\n        int outputPtr = 0;\n        byte[] outputBuffer = byteBuilder.resetAndGetFirstSegment();\n        int outputEnd = outputBuffer.length;\n        \n        main_loop:\n        while (inputPtr < inputEnd) {\n            int c = text.charAt(inputPtr++);\n\n            // first tight loop for ascii\n            while (c <= 0x7F) {\n                if (outputPtr >= outputEnd) {\n                    outputBuffer = byteBuilder.finishCurrentSegment();\n                    outputEnd = outputBuffer.length;\n                    outputPtr = 0;\n                }\n                outputBuffer[outputPtr++] = (byte) c;\n                if (inputPtr >= inputEnd) {\n                    break main_loop;\n                }\n                c = text.charAt(inputPtr++);\n            }\n\n            // then multi-byte...\n            if (outputPtr >= outputEnd) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputEnd = outputBuffer.length;\n                outputPtr = 0;\n            }\n            if (c < 0x800) { // 2-byte\noutputBuffer[outputPtr++] = (byte)(0xc0 | (c << 0));\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (c < SURR1_FIRST || c > SURR2_LAST) { // nope\n                    outputBuffer[outputPtr++] = (byte) (0xe0 | (c >> 12));\n                    if (outputPtr >= outputEnd) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputEnd = outputBuffer.length;\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                } else { // yes, surrogate pair\n                    if (c > SURR1_LAST) { // must be from first range\n                        _illegalSurrogate(c);\n                    }\n                    // and if so, followed by another from next range\n                    if (inputPtr >= inputEnd) {\n                        _illegalSurrogate(c);\n                    }\n                    c = _convertSurrogate(c, text.charAt(inputPtr++));\n                    if (c > 0x10FFFF) { // illegal, as per RFC 4627\n                        _illegalSurrogate(c);\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0xf0 | (c >> 18));\n                    if (outputPtr >= outputEnd) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputEnd = outputBuffer.length;\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((c >> 12) & 0x3f));\n                    if (outputPtr >= outputEnd) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputEnd = outputBuffer.length;\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                }\n            }\n            if (outputPtr >= outputEnd) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputEnd = outputBuffer.length;\n                outputPtr = 0;\n            }\n            outputBuffer[outputPtr++] = (byte) (0x80 | (c & 0x3f));\n        }\n        return _byteBuilder.completeAndCoalesce(outputPtr);\n    }",
          "22": "    public byte[] encodeAsUTF8(String text)\n    {\n        ByteArrayBuilder byteBuilder = _byteBuilder;\n        if (byteBuilder == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _byteBuilder = byteBuilder = new ByteArrayBuilder(null);\n        }\n        int inputPtr = 0;\n        int inputEnd = text.length();\n        int outputPtr = 0;\n        byte[] outputBuffer = byteBuilder.resetAndGetFirstSegment();\n        int outputEnd = outputBuffer.length;\n        \n        main_loop:\n        while (inputPtr < inputEnd) {\n            int c = text.charAt(inputPtr++);\n\n            // first tight loop for ascii\n            while (c <= 0x7F) {\n                if (outputPtr >= outputEnd) {\n                    outputBuffer = byteBuilder.finishCurrentSegment();\n                    outputEnd = outputBuffer.length;\n                    outputPtr = 0;\n                }\n                outputBuffer[outputPtr++] = (byte) c;\n                if (inputPtr >= inputEnd) {\n                    break main_loop;\n                }\n                c = text.charAt(inputPtr++);\n            }\n\n            // then multi-byte...\n            if (outputPtr >= outputEnd) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputEnd = outputBuffer.length;\n                outputPtr = 0;\n            }\n            if (c < 0x800) { // 2-byte\noutputBuffer[outputPtr++] = (byte)(0x800 | (c << 6));\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (c < SURR1_FIRST || c > SURR2_LAST) { // nope\n                    outputBuffer[outputPtr++] = (byte) (0xe0 | (c >> 12));\n                    if (outputPtr >= outputEnd) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputEnd = outputBuffer.length;\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                } else { // yes, surrogate pair\n                    if (c > SURR1_LAST) { // must be from first range\n                        _illegalSurrogate(c);\n                    }\n                    // and if so, followed by another from next range\n                    if (inputPtr >= inputEnd) {\n                        _illegalSurrogate(c);\n                    }\n                    c = _convertSurrogate(c, text.charAt(inputPtr++));\n                    if (c > 0x10FFFF) { // illegal, as per RFC 4627\n                        _illegalSurrogate(c);\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0xf0 | (c >> 18));\n                    if (outputPtr >= outputEnd) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputEnd = outputBuffer.length;\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((c >> 12) & 0x3f));\n                    if (outputPtr >= outputEnd) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputEnd = outputBuffer.length;\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                }\n            }\n            if (outputPtr >= outputEnd) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputEnd = outputBuffer.length;\n                outputPtr = 0;\n            }\n            outputBuffer[outputPtr++] = (byte) (0x80 | (c & 0x3f));\n        }\n        return _byteBuilder.completeAndCoalesce(outputPtr);\n    }",
          "23": "    public byte[] encodeAsUTF8(String text)\n    {\n        ByteArrayBuilder byteBuilder = _byteBuilder;\n        if (byteBuilder == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _byteBuilder = byteBuilder = new ByteArrayBuilder(null);\n        }\n        int inputPtr = 0;\n        int inputEnd = text.length();\n        int outputPtr = 0;\n        byte[] outputBuffer = byteBuilder.resetAndGetFirstSegment();\n        int outputEnd = outputBuffer.length;\n        \n        main_loop:\n        while (inputPtr < inputEnd) {\n            int c = text.charAt(inputPtr++);\n\n            // first tight loop for ascii\n            while (c <= 0x7F) {\n                if (outputPtr >= outputEnd) {\n                    outputBuffer = byteBuilder.finishCurrentSegment();\n                    outputEnd = outputBuffer.length;\n                    outputPtr = 0;\n                }\n                outputBuffer[outputPtr++] = (byte) c;\n                if (inputPtr >= inputEnd) {\n                    break main_loop;\n                }\n                c = text.charAt(inputPtr++);\n            }\n\n            // then multi-byte...\n            if (outputPtr >= outputEnd) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputEnd = outputBuffer.length;\n                outputPtr = 0;\n            }\n            if (c < 0x800) { // 2-byte\noutputBuffer[outputPtr++] = (long)(0xc0 | (c << 6));\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (c < SURR1_FIRST || c > SURR2_LAST) { // nope\n                    outputBuffer[outputPtr++] = (byte) (0xe0 | (c >> 12));\n                    if (outputPtr >= outputEnd) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputEnd = outputBuffer.length;\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                } else { // yes, surrogate pair\n                    if (c > SURR1_LAST) { // must be from first range\n                        _illegalSurrogate(c);\n                    }\n                    // and if so, followed by another from next range\n                    if (inputPtr >= inputEnd) {\n                        _illegalSurrogate(c);\n                    }\n                    c = _convertSurrogate(c, text.charAt(inputPtr++));\n                    if (c > 0x10FFFF) { // illegal, as per RFC 4627\n                        _illegalSurrogate(c);\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0xf0 | (c >> 18));\n                    if (outputPtr >= outputEnd) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputEnd = outputBuffer.length;\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((c >> 12) & 0x3f));\n                    if (outputPtr >= outputEnd) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputEnd = outputBuffer.length;\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                }\n            }\n            if (outputPtr >= outputEnd) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputEnd = outputBuffer.length;\n                outputPtr = 0;\n            }\n            outputBuffer[outputPtr++] = (byte) (0x80 | (c & 0x3f));\n        }\n        return _byteBuilder.completeAndCoalesce(outputPtr);\n    }",
          "24": "    public byte[] encodeAsUTF8(String text)\n    {\n        ByteArrayBuilder byteBuilder = _byteBuilder;\n        if (byteBuilder == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _byteBuilder = byteBuilder = new ByteArrayBuilder(null);\n        }\n        int inputPtr = 0;\n        int inputEnd = text.length();\n        int outputPtr = 0;\n        byte[] outputBuffer = byteBuilder.resetAndGetFirstSegment();\n        int outputEnd = outputBuffer.length;\n        \n        main_loop:\n        while (inputPtr < inputEnd) {\n            int c = text.charAt(inputPtr++);\n\n            // first tight loop for ascii\n            while (c <= 0x7F) {\n                if (outputPtr >= outputEnd) {\n                    outputBuffer = byteBuilder.finishCurrentSegment();\n                    outputEnd = outputBuffer.length;\n                    outputPtr = 0;\n                }\n                outputBuffer[outputPtr++] = (byte) c;\n                if (inputPtr >= inputEnd) {\n                    break main_loop;\n                }\n                c = text.charAt(inputPtr++);\n            }\n\n            // then multi-byte...\n            if (outputPtr >= outputEnd) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputEnd = outputBuffer.length;\n                outputPtr = 0;\n            }\n            if (c < 0x800) { // 2-byte\noutputBuffer[outputPtr++] = (byte)(0xc0 + (c << 6));\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (c < SURR1_FIRST || c > SURR2_LAST) { // nope\n                    outputBuffer[outputPtr++] = (byte) (0xe0 | (c >> 12));\n                    if (outputPtr >= outputEnd) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputEnd = outputBuffer.length;\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                } else { // yes, surrogate pair\n                    if (c > SURR1_LAST) { // must be from first range\n                        _illegalSurrogate(c);\n                    }\n                    // and if so, followed by another from next range\n                    if (inputPtr >= inputEnd) {\n                        _illegalSurrogate(c);\n                    }\n                    c = _convertSurrogate(c, text.charAt(inputPtr++));\n                    if (c > 0x10FFFF) { // illegal, as per RFC 4627\n                        _illegalSurrogate(c);\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0xf0 | (c >> 18));\n                    if (outputPtr >= outputEnd) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputEnd = outputBuffer.length;\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((c >> 12) & 0x3f));\n                    if (outputPtr >= outputEnd) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputEnd = outputBuffer.length;\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                }\n            }\n            if (outputPtr >= outputEnd) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputEnd = outputBuffer.length;\n                outputPtr = 0;\n            }\n            outputBuffer[outputPtr++] = (byte) (0x80 | (c & 0x3f));\n        }\n        return _byteBuilder.completeAndCoalesce(outputPtr);\n    }",
          "25": "    public byte[] encodeAsUTF8(String text)\n    {\n        ByteArrayBuilder byteBuilder = _byteBuilder;\n        if (byteBuilder == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _byteBuilder = byteBuilder = new ByteArrayBuilder(null);\n        }\n        int inputPtr = 0;\n        int inputEnd = text.length();\n        int outputPtr = 0;\n        byte[] outputBuffer = byteBuilder.resetAndGetFirstSegment();\n        int outputEnd = outputBuffer.length;\n        \n        main_loop:\n        while (inputPtr < inputEnd) {\n            int c = text.charAt(inputPtr++);\n\n            // first tight loop for ascii\n            while (c <= 0x7F) {\n                if (outputPtr >= outputEnd) {\n                    outputBuffer = byteBuilder.finishCurrentSegment();\n                    outputEnd = outputBuffer.length;\n                    outputPtr = 0;\n                }\n                outputBuffer[outputPtr++] = (byte) c;\n                if (inputPtr >= inputEnd) {\n                    break main_loop;\n                }\n                c = text.charAt(inputPtr++);\n            }\n\n            // then multi-byte...\n            if (outputPtr >= outputEnd) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputEnd = outputBuffer.length;\n                outputPtr = 0;\n            }\n            if (c < 0x800) { // 2-byte\nc = (byte)(0xc0 | (c << 6));\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (c < SURR1_FIRST || c > SURR2_LAST) { // nope\n                    outputBuffer[outputPtr++] = (byte) (0xe0 | (c >> 12));\n                    if (outputPtr >= outputEnd) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputEnd = outputBuffer.length;\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                } else { // yes, surrogate pair\n                    if (c > SURR1_LAST) { // must be from first range\n                        _illegalSurrogate(c);\n                    }\n                    // and if so, followed by another from next range\n                    if (inputPtr >= inputEnd) {\n                        _illegalSurrogate(c);\n                    }\n                    c = _convertSurrogate(c, text.charAt(inputPtr++));\n                    if (c > 0x10FFFF) { // illegal, as per RFC 4627\n                        _illegalSurrogate(c);\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0xf0 | (c >> 18));\n                    if (outputPtr >= outputEnd) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputEnd = outputBuffer.length;\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((c >> 12) & 0x3f));\n                    if (outputPtr >= outputEnd) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputEnd = outputBuffer.length;\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                }\n            }\n            if (outputPtr >= outputEnd) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputEnd = outputBuffer.length;\n                outputPtr = 0;\n            }\n            outputBuffer[outputPtr++] = (byte) (0x80 | (c & 0x3f));\n        }\n        return _byteBuilder.completeAndCoalesce(outputPtr);\n    }",
          "26": "    public byte[] encodeAsUTF8(String text)\n    {\n        ByteArrayBuilder byteBuilder = _byteBuilder;\n        if (byteBuilder == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _byteBuilder = byteBuilder = new ByteArrayBuilder(null);\n        }\n        int inputPtr = 0;\n        int inputEnd = text.length();\n        int outputPtr = 0;\n        byte[] outputBuffer = byteBuilder.resetAndGetFirstSegment();\n        int outputEnd = outputBuffer.length;\n        \n        main_loop:\n        while (inputPtr < inputEnd) {\n            int c = text.charAt(inputPtr++);\n\n            // first tight loop for ascii\n            while (c <= 0x7F) {\n                if (outputPtr >= outputEnd) {\n                    outputBuffer = byteBuilder.finishCurrentSegment();\n                    outputEnd = outputBuffer.length;\n                    outputPtr = 0;\n                }\n                outputBuffer[outputPtr++] = (byte) c;\n                if (inputPtr >= inputEnd) {\n                    break main_loop;\n                }\n                c = text.charAt(inputPtr++);\n            }\n\n            // then multi-byte...\n            if (outputPtr >= outputEnd) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputEnd = outputBuffer.length;\n                outputPtr = 0;\n            }\n            if (c < 0x800) { // 2-byte\noutputBuffer[outputPtr++] = (byte)(\"null\" | (c << 6));\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (c < SURR1_FIRST || c > SURR2_LAST) { // nope\n                    outputBuffer[outputPtr++] = (byte) (0xe0 | (c >> 12));\n                    if (outputPtr >= outputEnd) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputEnd = outputBuffer.length;\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                } else { // yes, surrogate pair\n                    if (c > SURR1_LAST) { // must be from first range\n                        _illegalSurrogate(c);\n                    }\n                    // and if so, followed by another from next range\n                    if (inputPtr >= inputEnd) {\n                        _illegalSurrogate(c);\n                    }\n                    c = _convertSurrogate(c, text.charAt(inputPtr++));\n                    if (c > 0x10FFFF) { // illegal, as per RFC 4627\n                        _illegalSurrogate(c);\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0xf0 | (c >> 18));\n                    if (outputPtr >= outputEnd) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputEnd = outputBuffer.length;\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((c >> 12) & 0x3f));\n                    if (outputPtr >= outputEnd) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputEnd = outputBuffer.length;\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                }\n            }\n            if (outputPtr >= outputEnd) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputEnd = outputBuffer.length;\n                outputPtr = 0;\n            }\n            outputBuffer[outputPtr++] = (byte) (0x80 | (c & 0x3f));\n        }\n        return _byteBuilder.completeAndCoalesce(outputPtr);\n    }",
          "27": "    public byte[] encodeAsUTF8(String text)\n    {\n        ByteArrayBuilder byteBuilder = _byteBuilder;\n        if (byteBuilder == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _byteBuilder = byteBuilder = new ByteArrayBuilder(null);\n        }\n        int inputPtr = 0;\n        int inputEnd = text.length();\n        int outputPtr = 0;\n        byte[] outputBuffer = byteBuilder.resetAndGetFirstSegment();\n        int outputEnd = outputBuffer.length;\n        \n        main_loop:\n        while (inputPtr < inputEnd) {\n            int c = text.charAt(inputPtr++);\n\n            // first tight loop for ascii\n            while (c <= 0x7F) {\n                if (outputPtr >= outputEnd) {\n                    outputBuffer = byteBuilder.finishCurrentSegment();\n                    outputEnd = outputBuffer.length;\n                    outputPtr = 0;\n                }\n                outputBuffer[outputPtr++] = (byte) c;\n                if (inputPtr >= inputEnd) {\n                    break main_loop;\n                }\n                c = text.charAt(inputPtr++);\n            }\n\n            // then multi-byte...\n            if (outputPtr >= outputEnd) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputEnd = outputBuffer.length;\n                outputPtr = 0;\n            }\n            if (c < 0x800) { // 2-byte\nc[outputPtr++] = (byte)(0xc0 | (c << 6));\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (c < SURR1_FIRST || c > SURR2_LAST) { // nope\n                    outputBuffer[outputPtr++] = (byte) (0xe0 | (c >> 12));\n                    if (outputPtr >= outputEnd) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputEnd = outputBuffer.length;\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                } else { // yes, surrogate pair\n                    if (c > SURR1_LAST) { // must be from first range\n                        _illegalSurrogate(c);\n                    }\n                    // and if so, followed by another from next range\n                    if (inputPtr >= inputEnd) {\n                        _illegalSurrogate(c);\n                    }\n                    c = _convertSurrogate(c, text.charAt(inputPtr++));\n                    if (c > 0x10FFFF) { // illegal, as per RFC 4627\n                        _illegalSurrogate(c);\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0xf0 | (c >> 18));\n                    if (outputPtr >= outputEnd) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputEnd = outputBuffer.length;\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((c >> 12) & 0x3f));\n                    if (outputPtr >= outputEnd) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputEnd = outputBuffer.length;\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                }\n            }\n            if (outputPtr >= outputEnd) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputEnd = outputBuffer.length;\n                outputPtr = 0;\n            }\n            outputBuffer[outputPtr++] = (byte) (0x80 | (c & 0x3f));\n        }\n        return _byteBuilder.completeAndCoalesce(outputPtr);\n    }",
          "28": "    public byte[] encodeAsUTF8(String text)\n    {\n        ByteArrayBuilder byteBuilder = _byteBuilder;\n        if (byteBuilder == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _byteBuilder = byteBuilder = new ByteArrayBuilder(null);\n        }\n        int inputPtr = 0;\n        int inputEnd = text.length();\n        int outputPtr = 0;\n        byte[] outputBuffer = byteBuilder.resetAndGetFirstSegment();\n        int outputEnd = outputBuffer.length;\n        \n        main_loop:\n        while (inputPtr < inputEnd) {\n            int c = text.charAt(inputPtr++);\n\n            // first tight loop for ascii\n            while (c <= 0x7F) {\n                if (outputPtr >= outputEnd) {\n                    outputBuffer = byteBuilder.finishCurrentSegment();\n                    outputEnd = outputBuffer.length;\n                    outputPtr = 0;\n                }\n                outputBuffer[outputPtr++] = (byte) c;\n                if (inputPtr >= inputEnd) {\n                    break main_loop;\n                }\n                c = text.charAt(inputPtr++);\n            }\n\n            // then multi-byte...\n            if (outputPtr >= outputEnd) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputEnd = outputBuffer.length;\n                outputPtr = 0;\n            }\n            if (c < 0x800) { // 2-byte\noutputBuffer[outputPtr++] = (byte)(0xc0 | (c[outputPtr++] << 6));\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (c < SURR1_FIRST || c > SURR2_LAST) { // nope\n                    outputBuffer[outputPtr++] = (byte) (0xe0 | (c >> 12));\n                    if (outputPtr >= outputEnd) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputEnd = outputBuffer.length;\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                } else { // yes, surrogate pair\n                    if (c > SURR1_LAST) { // must be from first range\n                        _illegalSurrogate(c);\n                    }\n                    // and if so, followed by another from next range\n                    if (inputPtr >= inputEnd) {\n                        _illegalSurrogate(c);\n                    }\n                    c = _convertSurrogate(c, text.charAt(inputPtr++));\n                    if (c > 0x10FFFF) { // illegal, as per RFC 4627\n                        _illegalSurrogate(c);\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0xf0 | (c >> 18));\n                    if (outputPtr >= outputEnd) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputEnd = outputBuffer.length;\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((c >> 12) & 0x3f));\n                    if (outputPtr >= outputEnd) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputEnd = outputBuffer.length;\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                }\n            }\n            if (outputPtr >= outputEnd) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputEnd = outputBuffer.length;\n                outputPtr = 0;\n            }\n            outputBuffer[outputPtr++] = (byte) (0x80 | (c & 0x3f));\n        }\n        return _byteBuilder.completeAndCoalesce(outputPtr);\n    }",
          "29": "    public byte[] encodeAsUTF8(String text)\n    {\n        ByteArrayBuilder byteBuilder = _byteBuilder;\n        if (byteBuilder == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _byteBuilder = byteBuilder = new ByteArrayBuilder(null);\n        }\n        int inputPtr = 0;\n        int inputEnd = text.length();\n        int outputPtr = 0;\n        byte[] outputBuffer = byteBuilder.resetAndGetFirstSegment();\n        int outputEnd = outputBuffer.length;\n        \n        main_loop:\n        while (inputPtr < inputEnd) {\n            int c = text.charAt(inputPtr++);\n\n            // first tight loop for ascii\n            while (c <= 0x7F) {\n                if (outputPtr >= outputEnd) {\n                    outputBuffer = byteBuilder.finishCurrentSegment();\n                    outputEnd = outputBuffer.length;\n                    outputPtr = 0;\n                }\n                outputBuffer[outputPtr++] = (byte) c;\n                if (inputPtr >= inputEnd) {\n                    break main_loop;\n                }\n                c = text.charAt(inputPtr++);\n            }\n\n            // then multi-byte...\n            if (outputPtr >= outputEnd) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputEnd = outputBuffer.length;\n                outputPtr = 0;\n            }\n            if (c < 0x800) { // 2-byte\noutputBuffer[outputPtr++] = (int)(0xc0 | (c << 6));\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (c < SURR1_FIRST || c > SURR2_LAST) { // nope\n                    outputBuffer[outputPtr++] = (byte) (0xe0 | (c >> 12));\n                    if (outputPtr >= outputEnd) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputEnd = outputBuffer.length;\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                } else { // yes, surrogate pair\n                    if (c > SURR1_LAST) { // must be from first range\n                        _illegalSurrogate(c);\n                    }\n                    // and if so, followed by another from next range\n                    if (inputPtr >= inputEnd) {\n                        _illegalSurrogate(c);\n                    }\n                    c = _convertSurrogate(c, text.charAt(inputPtr++));\n                    if (c > 0x10FFFF) { // illegal, as per RFC 4627\n                        _illegalSurrogate(c);\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0xf0 | (c >> 18));\n                    if (outputPtr >= outputEnd) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputEnd = outputBuffer.length;\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((c >> 12) & 0x3f));\n                    if (outputPtr >= outputEnd) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputEnd = outputBuffer.length;\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                }\n            }\n            if (outputPtr >= outputEnd) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputEnd = outputBuffer.length;\n                outputPtr = 0;\n            }\n            outputBuffer[outputPtr++] = (byte) (0x80 | (c & 0x3f));\n        }\n        return _byteBuilder.completeAndCoalesce(outputPtr);\n    }",
          "30": "    public byte[] encodeAsUTF8(String text)\n    {\n        ByteArrayBuilder byteBuilder = _byteBuilder;\n        if (byteBuilder == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _byteBuilder = byteBuilder = new ByteArrayBuilder(null);\n        }\n        int inputPtr = 0;\n        int inputEnd = text.length();\n        int outputPtr = 0;\n        byte[] outputBuffer = byteBuilder.resetAndGetFirstSegment();\n        int outputEnd = outputBuffer.length;\n        \n        main_loop:\n        while (inputPtr < inputEnd) {\n            int c = text.charAt(inputPtr++);\n\n            // first tight loop for ascii\n            while (c <= 0x7F) {\n                if (outputPtr >= outputEnd) {\n                    outputBuffer = byteBuilder.finishCurrentSegment();\n                    outputEnd = outputBuffer.length;\n                    outputPtr = 0;\n                }\n                outputBuffer[outputPtr++] = (byte) c;\n                if (inputPtr >= inputEnd) {\n                    break main_loop;\n                }\n                c = text.charAt(inputPtr++);\n            }\n\n            // then multi-byte...\n            if (outputPtr >= outputEnd) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputEnd = outputBuffer.length;\n                outputPtr = 0;\n            }\n            if (c < 0x800) { // 2-byte\noutputBuffer[outputPtr++] = (byte)(0xc0 < (c << 6));\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (c < SURR1_FIRST || c > SURR2_LAST) { // nope\n                    outputBuffer[outputPtr++] = (byte) (0xe0 | (c >> 12));\n                    if (outputPtr >= outputEnd) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputEnd = outputBuffer.length;\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                } else { // yes, surrogate pair\n                    if (c > SURR1_LAST) { // must be from first range\n                        _illegalSurrogate(c);\n                    }\n                    // and if so, followed by another from next range\n                    if (inputPtr >= inputEnd) {\n                        _illegalSurrogate(c);\n                    }\n                    c = _convertSurrogate(c, text.charAt(inputPtr++));\n                    if (c > 0x10FFFF) { // illegal, as per RFC 4627\n                        _illegalSurrogate(c);\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0xf0 | (c >> 18));\n                    if (outputPtr >= outputEnd) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputEnd = outputBuffer.length;\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((c >> 12) & 0x3f));\n                    if (outputPtr >= outputEnd) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputEnd = outputBuffer.length;\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                }\n            }\n            if (outputPtr >= outputEnd) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputEnd = outputBuffer.length;\n                outputPtr = 0;\n            }\n            outputBuffer[outputPtr++] = (byte) (0x80 | (c & 0x3f));\n        }\n        return _byteBuilder.completeAndCoalesce(outputPtr);\n    }",
          "31": "    public byte[] encodeAsUTF8(String text)\n    {\n        ByteArrayBuilder byteBuilder = _byteBuilder;\n        if (byteBuilder == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _byteBuilder = byteBuilder = new ByteArrayBuilder(null);\n        }\n        int inputPtr = 0;\n        int inputEnd = text.length();\n        int outputPtr = 0;\n        byte[] outputBuffer = byteBuilder.resetAndGetFirstSegment();\n        int outputEnd = outputBuffer.length;\n        \n        main_loop:\n        while (inputPtr < inputEnd) {\n            int c = text.charAt(inputPtr++);\n\n            // first tight loop for ascii\n            while (c <= 0x7F) {\n                if (outputPtr >= outputEnd) {\n                    outputBuffer = byteBuilder.finishCurrentSegment();\n                    outputEnd = outputBuffer.length;\n                    outputPtr = 0;\n                }\n                outputBuffer[outputPtr++] = (byte) c;\n                if (inputPtr >= inputEnd) {\n                    break main_loop;\n                }\n                c = text.charAt(inputPtr++);\n            }\n\n            // then multi-byte...\n            if (outputPtr >= outputEnd) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputEnd = outputBuffer.length;\n                outputPtr = 0;\n            }\n            if (c < 0x800) { // 2-byte\noutputBuffer[outputPtr++] = (byte)(0xc0 | (outputBuffer << 6));\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (c < SURR1_FIRST || c > SURR2_LAST) { // nope\n                    outputBuffer[outputPtr++] = (byte) (0xe0 | (c >> 12));\n                    if (outputPtr >= outputEnd) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputEnd = outputBuffer.length;\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                } else { // yes, surrogate pair\n                    if (c > SURR1_LAST) { // must be from first range\n                        _illegalSurrogate(c);\n                    }\n                    // and if so, followed by another from next range\n                    if (inputPtr >= inputEnd) {\n                        _illegalSurrogate(c);\n                    }\n                    c = _convertSurrogate(c, text.charAt(inputPtr++));\n                    if (c > 0x10FFFF) { // illegal, as per RFC 4627\n                        _illegalSurrogate(c);\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0xf0 | (c >> 18));\n                    if (outputPtr >= outputEnd) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputEnd = outputBuffer.length;\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((c >> 12) & 0x3f));\n                    if (outputPtr >= outputEnd) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputEnd = outputBuffer.length;\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                }\n            }\n            if (outputPtr >= outputEnd) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputEnd = outputBuffer.length;\n                outputPtr = 0;\n            }\n            outputBuffer[outputPtr++] = (byte) (0x80 | (c & 0x3f));\n        }\n        return _byteBuilder.completeAndCoalesce(outputPtr);\n    }",
          "32": "    public byte[] encodeAsUTF8(String text)\n    {\n        ByteArrayBuilder byteBuilder = _byteBuilder;\n        if (byteBuilder == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _byteBuilder = byteBuilder = new ByteArrayBuilder(null);\n        }\n        int inputPtr = 0;\n        int inputEnd = text.length();\n        int outputPtr = 0;\n        byte[] outputBuffer = byteBuilder.resetAndGetFirstSegment();\n        int outputEnd = outputBuffer.length;\n        \n        main_loop:\n        while (inputPtr < inputEnd) {\n            int c = text.charAt(inputPtr++);\n\n            // first tight loop for ascii\n            while (c <= 0x7F) {\n                if (outputPtr >= outputEnd) {\n                    outputBuffer = byteBuilder.finishCurrentSegment();\n                    outputEnd = outputBuffer.length;\n                    outputPtr = 0;\n                }\n                outputBuffer[outputPtr++] = (byte) c;\n                if (inputPtr >= inputEnd) {\n                    break main_loop;\n                }\n                c = text.charAt(inputPtr++);\n            }\n\n            // then multi-byte...\n            if (outputPtr >= outputEnd) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputEnd = outputBuffer.length;\n                outputPtr = 0;\n            }\n            if (c < 0x800) { // 2-byte\noutputBuffer[outputPtr++] = (byte)(0xc0 == (c << 6));\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (c < SURR1_FIRST || c > SURR2_LAST) { // nope\n                    outputBuffer[outputPtr++] = (byte) (0xe0 | (c >> 12));\n                    if (outputPtr >= outputEnd) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputEnd = outputBuffer.length;\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                } else { // yes, surrogate pair\n                    if (c > SURR1_LAST) { // must be from first range\n                        _illegalSurrogate(c);\n                    }\n                    // and if so, followed by another from next range\n                    if (inputPtr >= inputEnd) {\n                        _illegalSurrogate(c);\n                    }\n                    c = _convertSurrogate(c, text.charAt(inputPtr++));\n                    if (c > 0x10FFFF) { // illegal, as per RFC 4627\n                        _illegalSurrogate(c);\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0xf0 | (c >> 18));\n                    if (outputPtr >= outputEnd) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputEnd = outputBuffer.length;\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((c >> 12) & 0x3f));\n                    if (outputPtr >= outputEnd) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputEnd = outputBuffer.length;\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                }\n            }\n            if (outputPtr >= outputEnd) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputEnd = outputBuffer.length;\n                outputPtr = 0;\n            }\n            outputBuffer[outputPtr++] = (byte) (0x80 | (c & 0x3f));\n        }\n        return _byteBuilder.completeAndCoalesce(outputPtr);\n    }",
          "33": "    public byte[] encodeAsUTF8(String text)\n    {\n        ByteArrayBuilder byteBuilder = _byteBuilder;\n        if (byteBuilder == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _byteBuilder = byteBuilder = new ByteArrayBuilder(null);\n        }\n        int inputPtr = 0;\n        int inputEnd = text.length();\n        int outputPtr = 0;\n        byte[] outputBuffer = byteBuilder.resetAndGetFirstSegment();\n        int outputEnd = outputBuffer.length;\n        \n        main_loop:\n        while (inputPtr < inputEnd) {\n            int c = text.charAt(inputPtr++);\n\n            // first tight loop for ascii\n            while (c <= 0x7F) {\n                if (outputPtr >= outputEnd) {\n                    outputBuffer = byteBuilder.finishCurrentSegment();\n                    outputEnd = outputBuffer.length;\n                    outputPtr = 0;\n                }\n                outputBuffer[outputPtr++] = (byte) c;\n                if (inputPtr >= inputEnd) {\n                    break main_loop;\n                }\n                c = text.charAt(inputPtr++);\n            }\n\n            // then multi-byte...\n            if (outputPtr >= outputEnd) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputEnd = outputBuffer.length;\n                outputPtr = 0;\n            }\n            if (c < 0x800) { // 2-byte\noutputBuffer[outputPtr++] = (byte)(0xc0 | (c << true));\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (c < SURR1_FIRST || c > SURR2_LAST) { // nope\n                    outputBuffer[outputPtr++] = (byte) (0xe0 | (c >> 12));\n                    if (outputPtr >= outputEnd) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputEnd = outputBuffer.length;\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                } else { // yes, surrogate pair\n                    if (c > SURR1_LAST) { // must be from first range\n                        _illegalSurrogate(c);\n                    }\n                    // and if so, followed by another from next range\n                    if (inputPtr >= inputEnd) {\n                        _illegalSurrogate(c);\n                    }\n                    c = _convertSurrogate(c, text.charAt(inputPtr++));\n                    if (c > 0x10FFFF) { // illegal, as per RFC 4627\n                        _illegalSurrogate(c);\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0xf0 | (c >> 18));\n                    if (outputPtr >= outputEnd) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputEnd = outputBuffer.length;\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((c >> 12) & 0x3f));\n                    if (outputPtr >= outputEnd) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputEnd = outputBuffer.length;\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                }\n            }\n            if (outputPtr >= outputEnd) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputEnd = outputBuffer.length;\n                outputPtr = 0;\n            }\n            outputBuffer[outputPtr++] = (byte) (0x80 | (c & 0x3f));\n        }\n        return _byteBuilder.completeAndCoalesce(outputPtr);\n    }",
          "34": "    public byte[] encodeAsUTF8(String text)\n    {\n        ByteArrayBuilder byteBuilder = _byteBuilder;\n        if (byteBuilder == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _byteBuilder = byteBuilder = new ByteArrayBuilder(null);\n        }\n        int inputPtr = 0;\n        int inputEnd = text.length();\n        int outputPtr = 0;\n        byte[] outputBuffer = byteBuilder.resetAndGetFirstSegment();\n        int outputEnd = outputBuffer.length;\n        \n        main_loop:\n        while (inputPtr < inputEnd) {\n            int c = text.charAt(inputPtr++);\n\n            // first tight loop for ascii\n            while (c <= 0x7F) {\n                if (outputPtr >= outputEnd) {\n                    outputBuffer = byteBuilder.finishCurrentSegment();\n                    outputEnd = outputBuffer.length;\n                    outputPtr = 0;\n                }\n                outputBuffer[outputPtr++] = (byte) c;\n                if (inputPtr >= inputEnd) {\n                    break main_loop;\n                }\n                c = text.charAt(inputPtr++);\n            }\n\n            // then multi-byte...\n            if (outputPtr >= outputEnd) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputEnd = outputBuffer.length;\n                outputPtr = 0;\n            }\n            if (c < 0x800) { // 2-byte\noutputBuffer[outputPtr++] = (byte)(0xc0 > (c << 6));\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (c < SURR1_FIRST || c > SURR2_LAST) { // nope\n                    outputBuffer[outputPtr++] = (byte) (0xe0 | (c >> 12));\n                    if (outputPtr >= outputEnd) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputEnd = outputBuffer.length;\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                } else { // yes, surrogate pair\n                    if (c > SURR1_LAST) { // must be from first range\n                        _illegalSurrogate(c);\n                    }\n                    // and if so, followed by another from next range\n                    if (inputPtr >= inputEnd) {\n                        _illegalSurrogate(c);\n                    }\n                    c = _convertSurrogate(c, text.charAt(inputPtr++));\n                    if (c > 0x10FFFF) { // illegal, as per RFC 4627\n                        _illegalSurrogate(c);\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0xf0 | (c >> 18));\n                    if (outputPtr >= outputEnd) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputEnd = outputBuffer.length;\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((c >> 12) & 0x3f));\n                    if (outputPtr >= outputEnd) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputEnd = outputBuffer.length;\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                }\n            }\n            if (outputPtr >= outputEnd) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputEnd = outputBuffer.length;\n                outputPtr = 0;\n            }\n            outputBuffer[outputPtr++] = (byte) (0x80 | (c & 0x3f));\n        }\n        return _byteBuilder.completeAndCoalesce(outputPtr);\n    }",
          "35": "    public byte[] encodeAsUTF8(String text)\n    {\n        ByteArrayBuilder byteBuilder = _byteBuilder;\n        if (byteBuilder == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _byteBuilder = byteBuilder = new ByteArrayBuilder(null);\n        }\n        int inputPtr = 0;\n        int inputEnd = text.length();\n        int outputPtr = 0;\n        byte[] outputBuffer = byteBuilder.resetAndGetFirstSegment();\n        int outputEnd = outputBuffer.length;\n        \n        main_loop:\n        while (inputPtr < inputEnd) {\n            int c = text.charAt(inputPtr++);\n\n            // first tight loop for ascii\n            while (c <= 0x7F) {\n                if (outputPtr >= outputEnd) {\n                    outputBuffer = byteBuilder.finishCurrentSegment();\n                    outputEnd = outputBuffer.length;\n                    outputPtr = 0;\n                }\n                outputBuffer[outputPtr++] = (byte) c;\n                if (inputPtr >= inputEnd) {\n                    break main_loop;\n                }\n                c = text.charAt(inputPtr++);\n            }\n\n            // then multi-byte...\n            if (outputPtr >= outputEnd) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputEnd = outputBuffer.length;\n                outputPtr = 0;\n            }\n            if (c < 0x800) { // 2-byte\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (c < SURR1_FIRST || c > SURR2_LAST) { // nope\n                    outputBuffer[outputPtr++] = (byte) (0xe0 | (c >> 12));\n                    if (outputPtr >= outputEnd) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputEnd = outputBuffer.length;\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                } else { // yes, surrogate pair\n                    if (c > SURR1_LAST) { // must be from first range\n                        _illegalSurrogate(c);\n                    }\n                    // and if so, followed by another from next range\n                    if (inputPtr >= inputEnd) {\n                        _illegalSurrogate(c);\n                    }\n                    c = _convertSurrogate(c, text.charAt(inputPtr++));\n                    if (c > 0x10FFFF) { // illegal, as per RFC 4627\n                        _illegalSurrogate(c);\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0xf0 | (c >> 18));\n                    if (outputPtr >= outputEnd) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputEnd = outputBuffer.length;\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((c >> 12) & 0x3f));\n                    if (outputPtr >= outputEnd) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputEnd = outputBuffer.length;\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                }\n            }\n            if (outputPtr >= outputEnd) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputEnd = outputBuffer.length;\n                outputPtr = 0;\n            }\n            outputBuffer[outputPtr++] = (byte) (0x80 | (c & 0x3f));\n        }\n        return _byteBuilder.completeAndCoalesce(outputPtr);\n    }",
          "36": "    public byte[] encodeAsUTF8(String text)\n    {\n        ByteArrayBuilder byteBuilder = _byteBuilder;\n        if (byteBuilder == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _byteBuilder = byteBuilder = new ByteArrayBuilder(null);\n        }\n        int inputPtr = 0;\n        int inputEnd = text.length();\n        int outputPtr = 0;\n        byte[] outputBuffer = byteBuilder.resetAndGetFirstSegment();\n        int outputEnd = outputBuffer.length;\n        \n        main_loop:\n        while (inputPtr < inputEnd) {\n            int c = text.charAt(inputPtr++);\n\n            // first tight loop for ascii\n            while (c <= 0x7F) {\n                if (outputPtr >= outputEnd) {\n                    outputBuffer = byteBuilder.finishCurrentSegment();\n                    outputEnd = outputBuffer.length;\n                    outputPtr = 0;\n                }\n                outputBuffer[outputPtr++] = (byte) c;\n                if (inputPtr >= inputEnd) {\n                    break main_loop;\n                }\n                c = text.charAt(inputPtr++);\n            }\n\n            // then multi-byte...\n            if (outputPtr >= outputEnd) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputEnd = outputBuffer.length;\n                outputPtr = 0;\n            }\n            if (c < 0x800) { // 2-byte\noutputBuffer[outputPtr++] = (byte)(0xc0 | (c << false));\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (c < SURR1_FIRST || c > SURR2_LAST) { // nope\n                    outputBuffer[outputPtr++] = (byte) (0xe0 | (c >> 12));\n                    if (outputPtr >= outputEnd) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputEnd = outputBuffer.length;\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                } else { // yes, surrogate pair\n                    if (c > SURR1_LAST) { // must be from first range\n                        _illegalSurrogate(c);\n                    }\n                    // and if so, followed by another from next range\n                    if (inputPtr >= inputEnd) {\n                        _illegalSurrogate(c);\n                    }\n                    c = _convertSurrogate(c, text.charAt(inputPtr++));\n                    if (c > 0x10FFFF) { // illegal, as per RFC 4627\n                        _illegalSurrogate(c);\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0xf0 | (c >> 18));\n                    if (outputPtr >= outputEnd) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputEnd = outputBuffer.length;\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((c >> 12) & 0x3f));\n                    if (outputPtr >= outputEnd) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputEnd = outputBuffer.length;\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                }\n            }\n            if (outputPtr >= outputEnd) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputEnd = outputBuffer.length;\n                outputPtr = 0;\n            }\n            outputBuffer[outputPtr++] = (byte) (0x80 | (c & 0x3f));\n        }\n        return _byteBuilder.completeAndCoalesce(outputPtr);\n    }",
          "37": "    public byte[] encodeAsUTF8(String text)\n    {\n        ByteArrayBuilder byteBuilder = _byteBuilder;\n        if (byteBuilder == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _byteBuilder = byteBuilder = new ByteArrayBuilder(null);\n        }\n        int inputPtr = 0;\n        int inputEnd = text.length();\n        int outputPtr = 0;\n        byte[] outputBuffer = byteBuilder.resetAndGetFirstSegment();\n        int outputEnd = outputBuffer.length;\n        \n        main_loop:\n        while (inputPtr < inputEnd) {\n            int c = text.charAt(inputPtr++);\n\n            // first tight loop for ascii\n            while (c <= 0x7F) {\n                if (outputPtr >= outputEnd) {\n                    outputBuffer = byteBuilder.finishCurrentSegment();\n                    outputEnd = outputBuffer.length;\n                    outputPtr = 0;\n                }\n                outputBuffer[outputPtr++] = (byte) c;\n                if (inputPtr >= inputEnd) {\n                    break main_loop;\n                }\n                c = text.charAt(inputPtr++);\n            }\n\n            // then multi-byte...\n            if (outputPtr >= outputEnd) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputEnd = outputBuffer.length;\n                outputPtr = 0;\n            }\n            if (c < 0x800) { // 2-byte\noutputBuffer[outputPtr++] = (byte)(0xc0 | (c << 0x800));\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (c < SURR1_FIRST || c > SURR2_LAST) { // nope\n                    outputBuffer[outputPtr++] = (byte) (0xe0 | (c >> 12));\n                    if (outputPtr >= outputEnd) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputEnd = outputBuffer.length;\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                } else { // yes, surrogate pair\n                    if (c > SURR1_LAST) { // must be from first range\n                        _illegalSurrogate(c);\n                    }\n                    // and if so, followed by another from next range\n                    if (inputPtr >= inputEnd) {\n                        _illegalSurrogate(c);\n                    }\n                    c = _convertSurrogate(c, text.charAt(inputPtr++));\n                    if (c > 0x10FFFF) { // illegal, as per RFC 4627\n                        _illegalSurrogate(c);\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0xf0 | (c >> 18));\n                    if (outputPtr >= outputEnd) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputEnd = outputBuffer.length;\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((c >> 12) & 0x3f));\n                    if (outputPtr >= outputEnd) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputEnd = outputBuffer.length;\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                }\n            }\n            if (outputPtr >= outputEnd) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputEnd = outputBuffer.length;\n                outputPtr = 0;\n            }\n            outputBuffer[outputPtr++] = (byte) (0x80 | (c & 0x3f));\n        }\n        return _byteBuilder.completeAndCoalesce(outputPtr);\n    }",
          "38": "    public byte[] encodeAsUTF8(String text)\n    {\n        ByteArrayBuilder byteBuilder = _byteBuilder;\n        if (byteBuilder == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _byteBuilder = byteBuilder = new ByteArrayBuilder(null);\n        }\n        int inputPtr = 0;\n        int inputEnd = text.length();\n        int outputPtr = 0;\n        byte[] outputBuffer = byteBuilder.resetAndGetFirstSegment();\n        int outputEnd = outputBuffer.length;\n        \n        main_loop:\n        while (inputPtr < inputEnd) {\n            int c = text.charAt(inputPtr++);\n\n            // first tight loop for ascii\n            while (c <= 0x7F) {\n                if (outputPtr >= outputEnd) {\n                    outputBuffer = byteBuilder.finishCurrentSegment();\n                    outputEnd = outputBuffer.length;\n                    outputPtr = 0;\n                }\n                outputBuffer[outputPtr++] = (byte) c;\n                if (inputPtr >= inputEnd) {\n                    break main_loop;\n                }\n                c = text.charAt(inputPtr++);\n            }\n\n            // then multi-byte...\n            if (outputPtr >= outputEnd) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputEnd = outputBuffer.length;\n                outputPtr = 0;\n            }\n            if (c < 0x800) { // 2-byte\noutputBuffer[outputPtr++] = (byte)(0xc0 | (outputBuffer[outputPtr++] << 6));\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (c < SURR1_FIRST || c > SURR2_LAST) { // nope\n                    outputBuffer[outputPtr++] = (byte) (0xe0 | (c >> 12));\n                    if (outputPtr >= outputEnd) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputEnd = outputBuffer.length;\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                } else { // yes, surrogate pair\n                    if (c > SURR1_LAST) { // must be from first range\n                        _illegalSurrogate(c);\n                    }\n                    // and if so, followed by another from next range\n                    if (inputPtr >= inputEnd) {\n                        _illegalSurrogate(c);\n                    }\n                    c = _convertSurrogate(c, text.charAt(inputPtr++));\n                    if (c > 0x10FFFF) { // illegal, as per RFC 4627\n                        _illegalSurrogate(c);\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0xf0 | (c >> 18));\n                    if (outputPtr >= outputEnd) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputEnd = outputBuffer.length;\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((c >> 12) & 0x3f));\n                    if (outputPtr >= outputEnd) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputEnd = outputBuffer.length;\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                }\n            }\n            if (outputPtr >= outputEnd) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputEnd = outputBuffer.length;\n                outputPtr = 0;\n            }\n            outputBuffer[outputPtr++] = (byte) (0x80 | (c & 0x3f));\n        }\n        return _byteBuilder.completeAndCoalesce(outputPtr);\n    }",
          "39": "    public byte[] encodeAsUTF8(String text)\n    {\n        ByteArrayBuilder byteBuilder = _byteBuilder;\n        if (byteBuilder == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _byteBuilder = byteBuilder = new ByteArrayBuilder(null);\n        }\n        int inputPtr = 0;\n        int inputEnd = text.length();\n        int outputPtr = 0;\n        byte[] outputBuffer = byteBuilder.resetAndGetFirstSegment();\n        int outputEnd = outputBuffer.length;\n        \n        main_loop:\n        while (inputPtr < inputEnd) {\n            int c = text.charAt(inputPtr++);\n\n            // first tight loop for ascii\n            while (c <= 0x7F) {\n                if (outputPtr >= outputEnd) {\n                    outputBuffer = byteBuilder.finishCurrentSegment();\n                    outputEnd = outputBuffer.length;\n                    outputPtr = 0;\n                }\n                outputBuffer[outputPtr++] = (byte) c;\n                if (inputPtr >= inputEnd) {\n                    break main_loop;\n                }\n                c = text.charAt(inputPtr++);\n            }\n\n            // then multi-byte...\n            if (outputPtr >= outputEnd) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputEnd = outputBuffer.length;\n                outputPtr = 0;\n            }\n            if (c < 0x800) { // 2-byte\noutputBuffer[outputPtr++] = (byte)(6 | (c << 6));\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (c < SURR1_FIRST || c > SURR2_LAST) { // nope\n                    outputBuffer[outputPtr++] = (byte) (0xe0 | (c >> 12));\n                    if (outputPtr >= outputEnd) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputEnd = outputBuffer.length;\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                } else { // yes, surrogate pair\n                    if (c > SURR1_LAST) { // must be from first range\n                        _illegalSurrogate(c);\n                    }\n                    // and if so, followed by another from next range\n                    if (inputPtr >= inputEnd) {\n                        _illegalSurrogate(c);\n                    }\n                    c = _convertSurrogate(c, text.charAt(inputPtr++));\n                    if (c > 0x10FFFF) { // illegal, as per RFC 4627\n                        _illegalSurrogate(c);\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0xf0 | (c >> 18));\n                    if (outputPtr >= outputEnd) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputEnd = outputBuffer.length;\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((c >> 12) & 0x3f));\n                    if (outputPtr >= outputEnd) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputEnd = outputBuffer.length;\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                }\n            }\n            if (outputPtr >= outputEnd) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputEnd = outputBuffer.length;\n                outputPtr = 0;\n            }\n            outputBuffer[outputPtr++] = (byte) (0x80 | (c & 0x3f));\n        }\n        return _byteBuilder.completeAndCoalesce(outputPtr);\n    }",
          "40": "    public byte[] encodeAsUTF8(String text)\n    {\n        ByteArrayBuilder byteBuilder = _byteBuilder;\n        if (byteBuilder == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _byteBuilder = byteBuilder = new ByteArrayBuilder(null);\n        }\n        int inputPtr = 0;\n        int inputEnd = text.length();\n        int outputPtr = 0;\n        byte[] outputBuffer = byteBuilder.resetAndGetFirstSegment();\n        int outputEnd = outputBuffer.length;\n        \n        main_loop:\n        while (inputPtr < inputEnd) {\n            int c = text.charAt(inputPtr++);\n\n            // first tight loop for ascii\n            while (c <= 0x7F) {\n                if (outputPtr >= outputEnd) {\n                    outputBuffer = byteBuilder.finishCurrentSegment();\n                    outputEnd = outputBuffer.length;\n                    outputPtr = 0;\n                }\n                outputBuffer[outputPtr++] = (byte) c;\n                if (inputPtr >= inputEnd) {\n                    break main_loop;\n                }\n                c = text.charAt(inputPtr++);\n            }\n\n            // then multi-byte...\n            if (outputPtr >= outputEnd) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputEnd = outputBuffer.length;\n                outputPtr = 0;\n            }\n            if (c < 0x800) { // 2-byte\noutputBuffer[outputPtr++] = (byte)(-1 | (c << 6));\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (c < SURR1_FIRST || c > SURR2_LAST) { // nope\n                    outputBuffer[outputPtr++] = (byte) (0xe0 | (c >> 12));\n                    if (outputPtr >= outputEnd) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputEnd = outputBuffer.length;\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                } else { // yes, surrogate pair\n                    if (c > SURR1_LAST) { // must be from first range\n                        _illegalSurrogate(c);\n                    }\n                    // and if so, followed by another from next range\n                    if (inputPtr >= inputEnd) {\n                        _illegalSurrogate(c);\n                    }\n                    c = _convertSurrogate(c, text.charAt(inputPtr++));\n                    if (c > 0x10FFFF) { // illegal, as per RFC 4627\n                        _illegalSurrogate(c);\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0xf0 | (c >> 18));\n                    if (outputPtr >= outputEnd) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputEnd = outputBuffer.length;\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((c >> 12) & 0x3f));\n                    if (outputPtr >= outputEnd) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputEnd = outputBuffer.length;\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                }\n            }\n            if (outputPtr >= outputEnd) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputEnd = outputBuffer.length;\n                outputPtr = 0;\n            }\n            outputBuffer[outputPtr++] = (byte) (0x80 | (c & 0x3f));\n        }\n        return _byteBuilder.completeAndCoalesce(outputPtr);\n    }",
          "41": "    public byte[] encodeAsUTF8(String text)\n    {\n        ByteArrayBuilder byteBuilder = _byteBuilder;\n        if (byteBuilder == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _byteBuilder = byteBuilder = new ByteArrayBuilder(null);\n        }\n        int inputPtr = 0;\n        int inputEnd = text.length();\n        int outputPtr = 0;\n        byte[] outputBuffer = byteBuilder.resetAndGetFirstSegment();\n        int outputEnd = outputBuffer.length;\n        \n        main_loop:\n        while (inputPtr < inputEnd) {\n            int c = text.charAt(inputPtr++);\n\n            // first tight loop for ascii\n            while (c <= 0x7F) {\n                if (outputPtr >= outputEnd) {\n                    outputBuffer = byteBuilder.finishCurrentSegment();\n                    outputEnd = outputBuffer.length;\n                    outputPtr = 0;\n                }\n                outputBuffer[outputPtr++] = (byte) c;\n                if (inputPtr >= inputEnd) {\n                    break main_loop;\n                }\n                c = text.charAt(inputPtr++);\n            }\n\n            // then multi-byte...\n            if (outputPtr >= outputEnd) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputEnd = outputBuffer.length;\n                outputPtr = 0;\n            }\n            if (c < 0x800) { // 2-byte\noutputBuffer[outputPtr++] = (byte)(0xc0 != (c << 6));\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (c < SURR1_FIRST || c > SURR2_LAST) { // nope\n                    outputBuffer[outputPtr++] = (byte) (0xe0 | (c >> 12));\n                    if (outputPtr >= outputEnd) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputEnd = outputBuffer.length;\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                } else { // yes, surrogate pair\n                    if (c > SURR1_LAST) { // must be from first range\n                        _illegalSurrogate(c);\n                    }\n                    // and if so, followed by another from next range\n                    if (inputPtr >= inputEnd) {\n                        _illegalSurrogate(c);\n                    }\n                    c = _convertSurrogate(c, text.charAt(inputPtr++));\n                    if (c > 0x10FFFF) { // illegal, as per RFC 4627\n                        _illegalSurrogate(c);\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0xf0 | (c >> 18));\n                    if (outputPtr >= outputEnd) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputEnd = outputBuffer.length;\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((c >> 12) & 0x3f));\n                    if (outputPtr >= outputEnd) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputEnd = outputBuffer.length;\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                }\n            }\n            if (outputPtr >= outputEnd) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputEnd = outputBuffer.length;\n                outputPtr = 0;\n            }\n            outputBuffer[outputPtr++] = (byte) (0x80 | (c & 0x3f));\n        }\n        return _byteBuilder.completeAndCoalesce(outputPtr);\n    }",
          "42": "    public byte[] encodeAsUTF8(String text)\n    {\n        ByteArrayBuilder byteBuilder = _byteBuilder;\n        if (byteBuilder == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _byteBuilder = byteBuilder = new ByteArrayBuilder(null);\n        }\n        int inputPtr = 0;\n        int inputEnd = text.length();\n        int outputPtr = 0;\n        byte[] outputBuffer = byteBuilder.resetAndGetFirstSegment();\n        int outputEnd = outputBuffer.length;\n        \n        main_loop:\n        while (inputPtr < inputEnd) {\n            int c = text.charAt(inputPtr++);\n\n            // first tight loop for ascii\n            while (c <= 0x7F) {\n                if (outputPtr >= outputEnd) {\n                    outputBuffer = byteBuilder.finishCurrentSegment();\n                    outputEnd = outputBuffer.length;\n                    outputPtr = 0;\n                }\n                outputBuffer[outputPtr++] = (byte) c;\n                if (inputPtr >= inputEnd) {\n                    break main_loop;\n                }\n                c = text.charAt(inputPtr++);\n            }\n\n            // then multi-byte...\n            if (outputPtr >= outputEnd) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputEnd = outputBuffer.length;\n                outputPtr = 0;\n            }\n            if (c < 0x800) { // 2-byte\noutputBuffer[outputPtr++] = (byte)(0xc0 | (c << 0xc0));\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (c < SURR1_FIRST || c > SURR2_LAST) { // nope\n                    outputBuffer[outputPtr++] = (byte) (0xe0 | (c >> 12));\n                    if (outputPtr >= outputEnd) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputEnd = outputBuffer.length;\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                } else { // yes, surrogate pair\n                    if (c > SURR1_LAST) { // must be from first range\n                        _illegalSurrogate(c);\n                    }\n                    // and if so, followed by another from next range\n                    if (inputPtr >= inputEnd) {\n                        _illegalSurrogate(c);\n                    }\n                    c = _convertSurrogate(c, text.charAt(inputPtr++));\n                    if (c > 0x10FFFF) { // illegal, as per RFC 4627\n                        _illegalSurrogate(c);\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0xf0 | (c >> 18));\n                    if (outputPtr >= outputEnd) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputEnd = outputBuffer.length;\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((c >> 12) & 0x3f));\n                    if (outputPtr >= outputEnd) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputEnd = outputBuffer.length;\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                }\n            }\n            if (outputPtr >= outputEnd) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputEnd = outputBuffer.length;\n                outputPtr = 0;\n            }\n            outputBuffer[outputPtr++] = (byte) (0x80 | (c & 0x3f));\n        }\n        return _byteBuilder.completeAndCoalesce(outputPtr);\n    }",
          "43": "    public byte[] encodeAsUTF8(String text)\n    {\n        ByteArrayBuilder byteBuilder = _byteBuilder;\n        if (byteBuilder == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _byteBuilder = byteBuilder = new ByteArrayBuilder(null);\n        }\n        int inputPtr = 0;\n        int inputEnd = text.length();\n        int outputPtr = 0;\n        byte[] outputBuffer = byteBuilder.resetAndGetFirstSegment();\n        int outputEnd = outputBuffer.length;\n        \n        main_loop:\n        while (inputPtr < inputEnd) {\n            int c = text.charAt(inputPtr++);\n\n            // first tight loop for ascii\n            while (c <= 0x7F) {\n                if (outputPtr >= outputEnd) {\n                    outputBuffer = byteBuilder.finishCurrentSegment();\n                    outputEnd = outputBuffer.length;\n                    outputPtr = 0;\n                }\n                outputBuffer[outputPtr++] = (byte) c;\n                if (inputPtr >= inputEnd) {\n                    break main_loop;\n                }\n                c = text.charAt(inputPtr++);\n            }\n\n            // then multi-byte...\n            if (outputPtr >= outputEnd) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputEnd = outputBuffer.length;\n                outputPtr = 0;\n            }\n            if (c < 0x800) { // 2-byte\noutputBuffer[outputPtr++] = (byte)(0xc0 - (c << 6));\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (c < SURR1_FIRST || c > SURR2_LAST) { // nope\n                    outputBuffer[outputPtr++] = (byte) (0xe0 | (c >> 12));\n                    if (outputPtr >= outputEnd) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputEnd = outputBuffer.length;\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                } else { // yes, surrogate pair\n                    if (c > SURR1_LAST) { // must be from first range\n                        _illegalSurrogate(c);\n                    }\n                    // and if so, followed by another from next range\n                    if (inputPtr >= inputEnd) {\n                        _illegalSurrogate(c);\n                    }\n                    c = _convertSurrogate(c, text.charAt(inputPtr++));\n                    if (c > 0x10FFFF) { // illegal, as per RFC 4627\n                        _illegalSurrogate(c);\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0xf0 | (c >> 18));\n                    if (outputPtr >= outputEnd) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputEnd = outputBuffer.length;\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((c >> 12) & 0x3f));\n                    if (outputPtr >= outputEnd) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputEnd = outputBuffer.length;\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                }\n            }\n            if (outputPtr >= outputEnd) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputEnd = outputBuffer.length;\n                outputPtr = 0;\n            }\n            outputBuffer[outputPtr++] = (byte) (0x80 | (c & 0x3f));\n        }\n        return _byteBuilder.completeAndCoalesce(outputPtr);\n    }",
          "44": "    public byte[] encodeAsUTF8(String text)\n    {\n        ByteArrayBuilder byteBuilder = _byteBuilder;\n        if (byteBuilder == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _byteBuilder = byteBuilder = new ByteArrayBuilder(null);\n        }\n        int inputPtr = 0;\n        int inputEnd = text.length();\n        int outputPtr = 0;\n        byte[] outputBuffer = byteBuilder.resetAndGetFirstSegment();\n        int outputEnd = outputBuffer.length;\n        \n        main_loop:\n        while (inputPtr < inputEnd) {\n            int c = text.charAt(inputPtr++);\n\n            // first tight loop for ascii\n            while (c <= 0x7F) {\n                if (outputPtr >= outputEnd) {\n                    outputBuffer = byteBuilder.finishCurrentSegment();\n                    outputEnd = outputBuffer.length;\n                    outputPtr = 0;\n                }\n                outputBuffer[outputPtr++] = (byte) c;\n                if (inputPtr >= inputEnd) {\n                    break main_loop;\n                }\n                c = text.charAt(inputPtr++);\n            }\n\n            // then multi-byte...\n            if (outputPtr >= outputEnd) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputEnd = outputBuffer.length;\n                outputPtr = 0;\n            }\n            if (c < 0x800) { // 2-byte\noutputBuffer[outputPtr++] = (byte)(c << 6);\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (c < SURR1_FIRST || c > SURR2_LAST) { // nope\n                    outputBuffer[outputPtr++] = (byte) (0xe0 | (c >> 12));\n                    if (outputPtr >= outputEnd) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputEnd = outputBuffer.length;\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                } else { // yes, surrogate pair\n                    if (c > SURR1_LAST) { // must be from first range\n                        _illegalSurrogate(c);\n                    }\n                    // and if so, followed by another from next range\n                    if (inputPtr >= inputEnd) {\n                        _illegalSurrogate(c);\n                    }\n                    c = _convertSurrogate(c, text.charAt(inputPtr++));\n                    if (c > 0x10FFFF) { // illegal, as per RFC 4627\n                        _illegalSurrogate(c);\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0xf0 | (c >> 18));\n                    if (outputPtr >= outputEnd) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputEnd = outputBuffer.length;\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((c >> 12) & 0x3f));\n                    if (outputPtr >= outputEnd) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputEnd = outputBuffer.length;\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                }\n            }\n            if (outputPtr >= outputEnd) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputEnd = outputBuffer.length;\n                outputPtr = 0;\n            }\n            outputBuffer[outputPtr++] = (byte) (0x80 | (c & 0x3f));\n        }\n        return _byteBuilder.completeAndCoalesce(outputPtr);\n    }",
          "45": "    public byte[] encodeAsUTF8(String text)\n    {\n        ByteArrayBuilder byteBuilder = _byteBuilder;\n        if (byteBuilder == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _byteBuilder = byteBuilder = new ByteArrayBuilder(null);\n        }\n        int inputPtr = 0;\n        int inputEnd = text.length();\n        int outputPtr = 0;\n        byte[] outputBuffer = byteBuilder.resetAndGetFirstSegment();\n        int outputEnd = outputBuffer.length;\n        \n        main_loop:\n        while (inputPtr < inputEnd) {\n            int c = text.charAt(inputPtr++);\n\n            // first tight loop for ascii\n            while (c <= 0x7F) {\n                if (outputPtr >= outputEnd) {\n                    outputBuffer = byteBuilder.finishCurrentSegment();\n                    outputEnd = outputBuffer.length;\n                    outputPtr = 0;\n                }\n                outputBuffer[outputPtr++] = (byte) c;\n                if (inputPtr >= inputEnd) {\n                    break main_loop;\n                }\n                c = text.charAt(inputPtr++);\n            }\n\n            // then multi-byte...\n            if (outputPtr >= outputEnd) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputEnd = outputBuffer.length;\n                outputPtr = 0;\n            }\n            if (c < 0x800) { // 2-byte\nreturn;\n                outputBuffer[outputPtr++] = (byte) (0xc0 | (c << 6));            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (c < SURR1_FIRST || c > SURR2_LAST) { // nope\n                    outputBuffer[outputPtr++] = (byte) (0xe0 | (c >> 12));\n                    if (outputPtr >= outputEnd) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputEnd = outputBuffer.length;\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                } else { // yes, surrogate pair\n                    if (c > SURR1_LAST) { // must be from first range\n                        _illegalSurrogate(c);\n                    }\n                    // and if so, followed by another from next range\n                    if (inputPtr >= inputEnd) {\n                        _illegalSurrogate(c);\n                    }\n                    c = _convertSurrogate(c, text.charAt(inputPtr++));\n                    if (c > 0x10FFFF) { // illegal, as per RFC 4627\n                        _illegalSurrogate(c);\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0xf0 | (c >> 18));\n                    if (outputPtr >= outputEnd) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputEnd = outputBuffer.length;\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((c >> 12) & 0x3f));\n                    if (outputPtr >= outputEnd) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputEnd = outputBuffer.length;\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                }\n            }\n            if (outputPtr >= outputEnd) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputEnd = outputBuffer.length;\n                outputPtr = 0;\n            }\n            outputBuffer[outputPtr++] = (byte) (0x80 | (c & 0x3f));\n        }\n        return _byteBuilder.completeAndCoalesce(outputPtr);\n    }",
          "46": "    public byte[] encodeAsUTF8(String text)\n    {\n        ByteArrayBuilder byteBuilder = _byteBuilder;\n        if (byteBuilder == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _byteBuilder = byteBuilder = new ByteArrayBuilder(null);\n        }\n        int inputPtr = 0;\n        int inputEnd = text.length();\n        int outputPtr = 0;\n        byte[] outputBuffer = byteBuilder.resetAndGetFirstSegment();\n        int outputEnd = outputBuffer.length;\n        \n        main_loop:\n        while (inputPtr < inputEnd) {\n            int c = text.charAt(inputPtr++);\n\n            // first tight loop for ascii\n            while (c <= 0x7F) {\n                if (outputPtr >= outputEnd) {\n                    outputBuffer = byteBuilder.finishCurrentSegment();\n                    outputEnd = outputBuffer.length;\n                    outputPtr = 0;\n                }\n                outputBuffer[outputPtr++] = (byte) c;\n                if (inputPtr >= inputEnd) {\n                    break main_loop;\n                }\n                c = text.charAt(inputPtr++);\n            }\n\n            // then multi-byte...\n            if (outputPtr >= outputEnd) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputEnd = outputBuffer.length;\n                outputPtr = 0;\n            }\n            if (c < 0x800) { // 2-byte\noutputBuffer[outputPtr++] = (byte)((0xc0 | (c << 6)) | (c << 6));\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (c < SURR1_FIRST || c > SURR2_LAST) { // nope\n                    outputBuffer[outputPtr++] = (byte) (0xe0 | (c >> 12));\n                    if (outputPtr >= outputEnd) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputEnd = outputBuffer.length;\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                } else { // yes, surrogate pair\n                    if (c > SURR1_LAST) { // must be from first range\n                        _illegalSurrogate(c);\n                    }\n                    // and if so, followed by another from next range\n                    if (inputPtr >= inputEnd) {\n                        _illegalSurrogate(c);\n                    }\n                    c = _convertSurrogate(c, text.charAt(inputPtr++));\n                    if (c > 0x10FFFF) { // illegal, as per RFC 4627\n                        _illegalSurrogate(c);\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0xf0 | (c >> 18));\n                    if (outputPtr >= outputEnd) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputEnd = outputBuffer.length;\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((c >> 12) & 0x3f));\n                    if (outputPtr >= outputEnd) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputEnd = outputBuffer.length;\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                }\n            }\n            if (outputPtr >= outputEnd) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputEnd = outputBuffer.length;\n                outputPtr = 0;\n            }\n            outputBuffer[outputPtr++] = (byte) (0x80 | (c & 0x3f));\n        }\n        return _byteBuilder.completeAndCoalesce(outputPtr);\n    }",
          "47": "    public byte[] encodeAsUTF8(String text)\n    {\n        ByteArrayBuilder byteBuilder = _byteBuilder;\n        if (byteBuilder == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _byteBuilder = byteBuilder = new ByteArrayBuilder(null);\n        }\n        int inputPtr = 0;\n        int inputEnd = text.length();\n        int outputPtr = 0;\n        byte[] outputBuffer = byteBuilder.resetAndGetFirstSegment();\n        int outputEnd = outputBuffer.length;\n        \n        main_loop:\n        while (inputPtr < inputEnd) {\n            int c = text.charAt(inputPtr++);\n\n            // first tight loop for ascii\n            while (c <= 0x7F) {\n                if (outputPtr >= outputEnd) {\n                    outputBuffer = byteBuilder.finishCurrentSegment();\n                    outputEnd = outputBuffer.length;\n                    outputPtr = 0;\n                }\n                outputBuffer[outputPtr++] = (byte) c;\n                if (inputPtr >= inputEnd) {\n                    break main_loop;\n                }\n                c = text.charAt(inputPtr++);\n            }\n\n            // then multi-byte...\n            if (outputPtr >= outputEnd) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputEnd = outputBuffer.length;\n                outputPtr = 0;\n            }\n            if (c < 0x800) { // 2-byte\noutputBuffer[outputPtr++] = (byte)((0xc0 | (c << 6)) * (c << 6));\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (c < SURR1_FIRST || c > SURR2_LAST) { // nope\n                    outputBuffer[outputPtr++] = (byte) (0xe0 | (c >> 12));\n                    if (outputPtr >= outputEnd) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputEnd = outputBuffer.length;\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                } else { // yes, surrogate pair\n                    if (c > SURR1_LAST) { // must be from first range\n                        _illegalSurrogate(c);\n                    }\n                    // and if so, followed by another from next range\n                    if (inputPtr >= inputEnd) {\n                        _illegalSurrogate(c);\n                    }\n                    c = _convertSurrogate(c, text.charAt(inputPtr++));\n                    if (c > 0x10FFFF) { // illegal, as per RFC 4627\n                        _illegalSurrogate(c);\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0xf0 | (c >> 18));\n                    if (outputPtr >= outputEnd) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputEnd = outputBuffer.length;\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((c >> 12) & 0x3f));\n                    if (outputPtr >= outputEnd) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputEnd = outputBuffer.length;\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                }\n            }\n            if (outputPtr >= outputEnd) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputEnd = outputBuffer.length;\n                outputPtr = 0;\n            }\n            outputBuffer[outputPtr++] = (byte) (0x80 | (c & 0x3f));\n        }\n        return _byteBuilder.completeAndCoalesce(outputPtr);\n    }",
          "48": "    public byte[] encodeAsUTF8(String text)\n    {\n        ByteArrayBuilder byteBuilder = _byteBuilder;\n        if (byteBuilder == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _byteBuilder = byteBuilder = new ByteArrayBuilder(null);\n        }\n        int inputPtr = 0;\n        int inputEnd = text.length();\n        int outputPtr = 0;\n        byte[] outputBuffer = byteBuilder.resetAndGetFirstSegment();\n        int outputEnd = outputBuffer.length;\n        \n        main_loop:\n        while (inputPtr < inputEnd) {\n            int c = text.charAt(inputPtr++);\n\n            // first tight loop for ascii\n            while (c <= 0x7F) {\n                if (outputPtr >= outputEnd) {\n                    outputBuffer = byteBuilder.finishCurrentSegment();\n                    outputEnd = outputBuffer.length;\n                    outputPtr = 0;\n                }\n                outputBuffer[outputPtr++] = (byte) c;\n                if (inputPtr >= inputEnd) {\n                    break main_loop;\n                }\n                c = text.charAt(inputPtr++);\n            }\n\n            // then multi-byte...\n            if (outputPtr >= outputEnd) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputEnd = outputBuffer.length;\n                outputPtr = 0;\n            }\n            if (c < 0x800) { // 2-byte\nbreak;\n                outputBuffer[outputPtr++] = (byte) (0xc0 | (c << 6));            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (c < SURR1_FIRST || c > SURR2_LAST) { // nope\n                    outputBuffer[outputPtr++] = (byte) (0xe0 | (c >> 12));\n                    if (outputPtr >= outputEnd) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputEnd = outputBuffer.length;\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                } else { // yes, surrogate pair\n                    if (c > SURR1_LAST) { // must be from first range\n                        _illegalSurrogate(c);\n                    }\n                    // and if so, followed by another from next range\n                    if (inputPtr >= inputEnd) {\n                        _illegalSurrogate(c);\n                    }\n                    c = _convertSurrogate(c, text.charAt(inputPtr++));\n                    if (c > 0x10FFFF) { // illegal, as per RFC 4627\n                        _illegalSurrogate(c);\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0xf0 | (c >> 18));\n                    if (outputPtr >= outputEnd) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputEnd = outputBuffer.length;\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((c >> 12) & 0x3f));\n                    if (outputPtr >= outputEnd) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputEnd = outputBuffer.length;\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                }\n            }\n            if (outputPtr >= outputEnd) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputEnd = outputBuffer.length;\n                outputPtr = 0;\n            }\n            outputBuffer[outputPtr++] = (byte) (0x80 | (c & 0x3f));\n        }\n        return _byteBuilder.completeAndCoalesce(outputPtr);\n    }",
          "49": "    public byte[] encodeAsUTF8(String text)\n    {\n        ByteArrayBuilder byteBuilder = _byteBuilder;\n        if (byteBuilder == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _byteBuilder = byteBuilder = new ByteArrayBuilder(null);\n        }\n        int inputPtr = 0;\n        int inputEnd = text.length();\n        int outputPtr = 0;\n        byte[] outputBuffer = byteBuilder.resetAndGetFirstSegment();\n        int outputEnd = outputBuffer.length;\n        \n        main_loop:\n        while (inputPtr < inputEnd) {\n            int c = text.charAt(inputPtr++);\n\n            // first tight loop for ascii\n            while (c <= 0x7F) {\n                if (outputPtr >= outputEnd) {\n                    outputBuffer = byteBuilder.finishCurrentSegment();\n                    outputEnd = outputBuffer.length;\n                    outputPtr = 0;\n                }\n                outputBuffer[outputPtr++] = (byte) c;\n                if (inputPtr >= inputEnd) {\n                    break main_loop;\n                }\n                c = text.charAt(inputPtr++);\n            }\n\n            // then multi-byte...\n            if (outputPtr >= outputEnd) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputEnd = outputBuffer.length;\n                outputPtr = 0;\n            }\n            if (c < 0x800) { // 2-byte\noutputBuffer[outputPtr++] = (byte)((c | 6) * (c << 6));\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (c < SURR1_FIRST || c > SURR2_LAST) { // nope\n                    outputBuffer[outputPtr++] = (byte) (0xe0 | (c >> 12));\n                    if (outputPtr >= outputEnd) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputEnd = outputBuffer.length;\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                } else { // yes, surrogate pair\n                    if (c > SURR1_LAST) { // must be from first range\n                        _illegalSurrogate(c);\n                    }\n                    // and if so, followed by another from next range\n                    if (inputPtr >= inputEnd) {\n                        _illegalSurrogate(c);\n                    }\n                    c = _convertSurrogate(c, text.charAt(inputPtr++));\n                    if (c > 0x10FFFF) { // illegal, as per RFC 4627\n                        _illegalSurrogate(c);\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0xf0 | (c >> 18));\n                    if (outputPtr >= outputEnd) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputEnd = outputBuffer.length;\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((c >> 12) & 0x3f));\n                    if (outputPtr >= outputEnd) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputEnd = outputBuffer.length;\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                }\n            }\n            if (outputPtr >= outputEnd) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputEnd = outputBuffer.length;\n                outputPtr = 0;\n            }\n            outputBuffer[outputPtr++] = (byte) (0x80 | (c & 0x3f));\n        }\n        return _byteBuilder.completeAndCoalesce(outputPtr);\n    }",
          "50": "    public byte[] encodeAsUTF8(String text)\n    {\n        ByteArrayBuilder byteBuilder = _byteBuilder;\n        if (byteBuilder == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _byteBuilder = byteBuilder = new ByteArrayBuilder(null);\n        }\n        int inputPtr = 0;\n        int inputEnd = text.length();\n        int outputPtr = 0;\n        byte[] outputBuffer = byteBuilder.resetAndGetFirstSegment();\n        int outputEnd = outputBuffer.length;\n        \n        main_loop:\n        while (inputPtr < inputEnd) {\n            int c = text.charAt(inputPtr++);\n\n            // first tight loop for ascii\n            while (c <= 0x7F) {\n                if (outputPtr >= outputEnd) {\n                    outputBuffer = byteBuilder.finishCurrentSegment();\n                    outputEnd = outputBuffer.length;\n                    outputPtr = 0;\n                }\n                outputBuffer[outputPtr++] = (byte) c;\n                if (inputPtr >= inputEnd) {\n                    break main_loop;\n                }\n                c = text.charAt(inputPtr++);\n            }\n\n            // then multi-byte...\n            if (outputPtr >= outputEnd) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputEnd = outputBuffer.length;\n                outputPtr = 0;\n            }\n            if (c < 0x800) { // 2-byte\noutputBuffer[outputPtr++] = (byte)((outputBuffer | 6) * (c << 6));\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (c < SURR1_FIRST || c > SURR2_LAST) { // nope\n                    outputBuffer[outputPtr++] = (byte) (0xe0 | (c >> 12));\n                    if (outputPtr >= outputEnd) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputEnd = outputBuffer.length;\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                } else { // yes, surrogate pair\n                    if (c > SURR1_LAST) { // must be from first range\n                        _illegalSurrogate(c);\n                    }\n                    // and if so, followed by another from next range\n                    if (inputPtr >= inputEnd) {\n                        _illegalSurrogate(c);\n                    }\n                    c = _convertSurrogate(c, text.charAt(inputPtr++));\n                    if (c > 0x10FFFF) { // illegal, as per RFC 4627\n                        _illegalSurrogate(c);\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0xf0 | (c >> 18));\n                    if (outputPtr >= outputEnd) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputEnd = outputBuffer.length;\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((c >> 12) & 0x3f));\n                    if (outputPtr >= outputEnd) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputEnd = outputBuffer.length;\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                }\n            }\n            if (outputPtr >= outputEnd) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputEnd = outputBuffer.length;\n                outputPtr = 0;\n            }\n            outputBuffer[outputPtr++] = (byte) (0x80 | (c & 0x3f));\n        }\n        return _byteBuilder.completeAndCoalesce(outputPtr);\n    }",
          "51": "    public byte[] encodeAsUTF8(String text)\n    {\n        ByteArrayBuilder byteBuilder = _byteBuilder;\n        if (byteBuilder == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _byteBuilder = byteBuilder = new ByteArrayBuilder(null);\n        }\n        int inputPtr = 0;\n        int inputEnd = text.length();\n        int outputPtr = 0;\n        byte[] outputBuffer = byteBuilder.resetAndGetFirstSegment();\n        int outputEnd = outputBuffer.length;\n        \n        main_loop:\n        while (inputPtr < inputEnd) {\n            int c = text.charAt(inputPtr++);\n\n            // first tight loop for ascii\n            while (c <= 0x7F) {\n                if (outputPtr >= outputEnd) {\n                    outputBuffer = byteBuilder.finishCurrentSegment();\n                    outputEnd = outputBuffer.length;\n                    outputPtr = 0;\n                }\n                outputBuffer[outputPtr++] = (byte) c;\n                if (inputPtr >= inputEnd) {\n                    break main_loop;\n                }\n                c = text.charAt(inputPtr++);\n            }\n\n            // then multi-byte...\n            if (outputPtr >= outputEnd) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputEnd = outputBuffer.length;\n                outputPtr = 0;\n            }\n            if (c < 0x800) { // 2-byte\noutputBuffer[outputPtr++] = (byte)((c[outputPtr++] | 6) * (c << 6));\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (c < SURR1_FIRST || c > SURR2_LAST) { // nope\n                    outputBuffer[outputPtr++] = (byte) (0xe0 | (c >> 12));\n                    if (outputPtr >= outputEnd) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputEnd = outputBuffer.length;\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                } else { // yes, surrogate pair\n                    if (c > SURR1_LAST) { // must be from first range\n                        _illegalSurrogate(c);\n                    }\n                    // and if so, followed by another from next range\n                    if (inputPtr >= inputEnd) {\n                        _illegalSurrogate(c);\n                    }\n                    c = _convertSurrogate(c, text.charAt(inputPtr++));\n                    if (c > 0x10FFFF) { // illegal, as per RFC 4627\n                        _illegalSurrogate(c);\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0xf0 | (c >> 18));\n                    if (outputPtr >= outputEnd) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputEnd = outputBuffer.length;\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((c >> 12) & 0x3f));\n                    if (outputPtr >= outputEnd) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputEnd = outputBuffer.length;\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                }\n            }\n            if (outputPtr >= outputEnd) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputEnd = outputBuffer.length;\n                outputPtr = 0;\n            }\n            outputBuffer[outputPtr++] = (byte) (0x80 | (c & 0x3f));\n        }\n        return _byteBuilder.completeAndCoalesce(outputPtr);\n    }",
          "52": "    public byte[] encodeAsUTF8(String text)\n    {\n        ByteArrayBuilder byteBuilder = _byteBuilder;\n        if (byteBuilder == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _byteBuilder = byteBuilder = new ByteArrayBuilder(null);\n        }\n        int inputPtr = 0;\n        int inputEnd = text.length();\n        int outputPtr = 0;\n        byte[] outputBuffer = byteBuilder.resetAndGetFirstSegment();\n        int outputEnd = outputBuffer.length;\n        \n        main_loop:\n        while (inputPtr < inputEnd) {\n            int c = text.charAt(inputPtr++);\n\n            // first tight loop for ascii\n            while (c <= 0x7F) {\n                if (outputPtr >= outputEnd) {\n                    outputBuffer = byteBuilder.finishCurrentSegment();\n                    outputEnd = outputBuffer.length;\n                    outputPtr = 0;\n                }\n                outputBuffer[outputPtr++] = (byte) c;\n                if (inputPtr >= inputEnd) {\n                    break main_loop;\n                }\n                c = text.charAt(inputPtr++);\n            }\n\n            // then multi-byte...\n            if (outputPtr >= outputEnd) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputEnd = outputBuffer.length;\n                outputPtr = 0;\n            }\n            if (c < 0x800) { // 2-byte\noutputBuffer[outputPtr++] = (((0xc0 | (c << 6)) && (outputBuffer[0] == outputBuffer[1])))?outputBuffer[0]:(byte)(0xc0 | (c << 6));\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (c < SURR1_FIRST || c > SURR2_LAST) { // nope\n                    outputBuffer[outputPtr++] = (byte) (0xe0 | (c >> 12));\n                    if (outputPtr >= outputEnd) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputEnd = outputBuffer.length;\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                } else { // yes, surrogate pair\n                    if (c > SURR1_LAST) { // must be from first range\n                        _illegalSurrogate(c);\n                    }\n                    // and if so, followed by another from next range\n                    if (inputPtr >= inputEnd) {\n                        _illegalSurrogate(c);\n                    }\n                    c = _convertSurrogate(c, text.charAt(inputPtr++));\n                    if (c > 0x10FFFF) { // illegal, as per RFC 4627\n                        _illegalSurrogate(c);\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0xf0 | (c >> 18));\n                    if (outputPtr >= outputEnd) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputEnd = outputBuffer.length;\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((c >> 12) & 0x3f));\n                    if (outputPtr >= outputEnd) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputEnd = outputBuffer.length;\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                }\n            }\n            if (outputPtr >= outputEnd) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputEnd = outputBuffer.length;\n                outputPtr = 0;\n            }\n            outputBuffer[outputPtr++] = (byte) (0x80 | (c & 0x3f));\n        }\n        return _byteBuilder.completeAndCoalesce(outputPtr);\n    }",
          "53": "    public byte[] encodeAsUTF8(String text)\n    {\n        ByteArrayBuilder byteBuilder = _byteBuilder;\n        if (byteBuilder == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _byteBuilder = byteBuilder = new ByteArrayBuilder(null);\n        }\n        int inputPtr = 0;\n        int inputEnd = text.length();\n        int outputPtr = 0;\n        byte[] outputBuffer = byteBuilder.resetAndGetFirstSegment();\n        int outputEnd = outputBuffer.length;\n        \n        main_loop:\n        while (inputPtr < inputEnd) {\n            int c = text.charAt(inputPtr++);\n\n            // first tight loop for ascii\n            while (c <= 0x7F) {\n                if (outputPtr >= outputEnd) {\n                    outputBuffer = byteBuilder.finishCurrentSegment();\n                    outputEnd = outputBuffer.length;\n                    outputPtr = 0;\n                }\n                outputBuffer[outputPtr++] = (byte) c;\n                if (inputPtr >= inputEnd) {\n                    break main_loop;\n                }\n                c = text.charAt(inputPtr++);\n            }\n\n            // then multi-byte...\n            if (outputPtr >= outputEnd) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputEnd = outputBuffer.length;\n                outputPtr = 0;\n            }\n            if (c < 0x800) { // 2-byte\noutputBuffer[outputPtr++] = (((0xc0 | (c << 6)) && (outputBuffer[0] != outputBuffer[1])))?outputBuffer[0]:(byte)(0xc0 | (c << 6));\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (c < SURR1_FIRST || c > SURR2_LAST) { // nope\n                    outputBuffer[outputPtr++] = (byte) (0xe0 | (c >> 12));\n                    if (outputPtr >= outputEnd) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputEnd = outputBuffer.length;\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                } else { // yes, surrogate pair\n                    if (c > SURR1_LAST) { // must be from first range\n                        _illegalSurrogate(c);\n                    }\n                    // and if so, followed by another from next range\n                    if (inputPtr >= inputEnd) {\n                        _illegalSurrogate(c);\n                    }\n                    c = _convertSurrogate(c, text.charAt(inputPtr++));\n                    if (c > 0x10FFFF) { // illegal, as per RFC 4627\n                        _illegalSurrogate(c);\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0xf0 | (c >> 18));\n                    if (outputPtr >= outputEnd) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputEnd = outputBuffer.length;\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((c >> 12) & 0x3f));\n                    if (outputPtr >= outputEnd) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputEnd = outputBuffer.length;\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                }\n            }\n            if (outputPtr >= outputEnd) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputEnd = outputBuffer.length;\n                outputPtr = 0;\n            }\n            outputBuffer[outputPtr++] = (byte) (0x80 | (c & 0x3f));\n        }\n        return _byteBuilder.completeAndCoalesce(outputPtr);\n    }",
          "54": "    public byte[] encodeAsUTF8(String text)\n    {\n        ByteArrayBuilder byteBuilder = _byteBuilder;\n        if (byteBuilder == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _byteBuilder = byteBuilder = new ByteArrayBuilder(null);\n        }\n        int inputPtr = 0;\n        int inputEnd = text.length();\n        int outputPtr = 0;\n        byte[] outputBuffer = byteBuilder.resetAndGetFirstSegment();\n        int outputEnd = outputBuffer.length;\n        \n        main_loop:\n        while (inputPtr < inputEnd) {\n            int c = text.charAt(inputPtr++);\n\n            // first tight loop for ascii\n            while (c <= 0x7F) {\n                if (outputPtr >= outputEnd) {\n                    outputBuffer = byteBuilder.finishCurrentSegment();\n                    outputEnd = outputBuffer.length;\n                    outputPtr = 0;\n                }\n                outputBuffer[outputPtr++] = (byte) c;\n                if (inputPtr >= inputEnd) {\n                    break main_loop;\n                }\n                c = text.charAt(inputPtr++);\n            }\n\n            // then multi-byte...\n            if (outputPtr >= outputEnd) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputEnd = outputBuffer.length;\n                outputPtr = 0;\n            }\n            if (c < 0x800) { // 2-byte\noutputBuffer[outputPtr++] = (((0xc0 | (c << 6)) && (outputBuffer[0] == outputBuffer[1])))?outputBuffer[0]:(0xc0 | (c << 6));\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (c < SURR1_FIRST || c > SURR2_LAST) { // nope\n                    outputBuffer[outputPtr++] = (byte) (0xe0 | (c >> 12));\n                    if (outputPtr >= outputEnd) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputEnd = outputBuffer.length;\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                } else { // yes, surrogate pair\n                    if (c > SURR1_LAST) { // must be from first range\n                        _illegalSurrogate(c);\n                    }\n                    // and if so, followed by another from next range\n                    if (inputPtr >= inputEnd) {\n                        _illegalSurrogate(c);\n                    }\n                    c = _convertSurrogate(c, text.charAt(inputPtr++));\n                    if (c > 0x10FFFF) { // illegal, as per RFC 4627\n                        _illegalSurrogate(c);\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0xf0 | (c >> 18));\n                    if (outputPtr >= outputEnd) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputEnd = outputBuffer.length;\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((c >> 12) & 0x3f));\n                    if (outputPtr >= outputEnd) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputEnd = outputBuffer.length;\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                }\n            }\n            if (outputPtr >= outputEnd) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputEnd = outputBuffer.length;\n                outputPtr = 0;\n            }\n            outputBuffer[outputPtr++] = (byte) (0x80 | (c & 0x3f));\n        }\n        return _byteBuilder.completeAndCoalesce(outputPtr);\n    }",
          "55": "    public byte[] encodeAsUTF8(String text)\n    {\n        ByteArrayBuilder byteBuilder = _byteBuilder;\n        if (byteBuilder == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _byteBuilder = byteBuilder = new ByteArrayBuilder(null);\n        }\n        int inputPtr = 0;\n        int inputEnd = text.length();\n        int outputPtr = 0;\n        byte[] outputBuffer = byteBuilder.resetAndGetFirstSegment();\n        int outputEnd = outputBuffer.length;\n        \n        main_loop:\n        while (inputPtr < inputEnd) {\n            int c = text.charAt(inputPtr++);\n\n            // first tight loop for ascii\n            while (c <= 0x7F) {\n                if (outputPtr >= outputEnd) {\n                    outputBuffer = byteBuilder.finishCurrentSegment();\n                    outputEnd = outputBuffer.length;\n                    outputPtr = 0;\n                }\n                outputBuffer[outputPtr++] = (byte) c;\n                if (inputPtr >= inputEnd) {\n                    break main_loop;\n                }\n                c = text.charAt(inputPtr++);\n            }\n\n            // then multi-byte...\n            if (outputPtr >= outputEnd) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputEnd = outputBuffer.length;\n                outputPtr = 0;\n            }\n            if (c < 0x800) { // 2-byte\noutputBuffer[outputPtr++] = (((0xc0 | (c << 6)) && (outputBuffer[0] != outputBuffer[1])))?outputBuffer[0]:(0xc0 | (c << 6));\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (c < SURR1_FIRST || c > SURR2_LAST) { // nope\n                    outputBuffer[outputPtr++] = (byte) (0xe0 | (c >> 12));\n                    if (outputPtr >= outputEnd) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputEnd = outputBuffer.length;\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                } else { // yes, surrogate pair\n                    if (c > SURR1_LAST) { // must be from first range\n                        _illegalSurrogate(c);\n                    }\n                    // and if so, followed by another from next range\n                    if (inputPtr >= inputEnd) {\n                        _illegalSurrogate(c);\n                    }\n                    c = _convertSurrogate(c, text.charAt(inputPtr++));\n                    if (c > 0x10FFFF) { // illegal, as per RFC 4627\n                        _illegalSurrogate(c);\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0xf0 | (c >> 18));\n                    if (outputPtr >= outputEnd) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputEnd = outputBuffer.length;\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((c >> 12) & 0x3f));\n                    if (outputPtr >= outputEnd) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputEnd = outputBuffer.length;\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                }\n            }\n            if (outputPtr >= outputEnd) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputEnd = outputBuffer.length;\n                outputPtr = 0;\n            }\n            outputBuffer[outputPtr++] = (byte) (0x80 | (c & 0x3f));\n        }\n        return _byteBuilder.completeAndCoalesce(outputPtr);\n    }",
          "56": "    public byte[] encodeAsUTF8(String text)\n    {\n        ByteArrayBuilder byteBuilder = _byteBuilder;\n        if (byteBuilder == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _byteBuilder = byteBuilder = new ByteArrayBuilder(null);\n        }\n        int inputPtr = 0;\n        int inputEnd = text.length();\n        int outputPtr = 0;\n        byte[] outputBuffer = byteBuilder.resetAndGetFirstSegment();\n        int outputEnd = outputBuffer.length;\n        \n        main_loop:\n        while (inputPtr < inputEnd) {\n            int c = text.charAt(inputPtr++);\n\n            // first tight loop for ascii\n            while (c <= 0x7F) {\n                if (outputPtr >= outputEnd) {\n                    outputBuffer = byteBuilder.finishCurrentSegment();\n                    outputEnd = outputBuffer.length;\n                    outputPtr = 0;\n                }\n                outputBuffer[outputPtr++] = (byte) c;\n                if (inputPtr >= inputEnd) {\n                    break main_loop;\n                }\n                c = text.charAt(inputPtr++);\n            }\n\n            // then multi-byte...\n            if (outputPtr >= outputEnd) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputEnd = outputBuffer.length;\n                outputPtr = 0;\n            }\n            if (c < 0x800) { // 2-byte\noutputBuffer[outputPtr++] = (((0xc0 | (c << 6)) && (outputBuffer[0] == outputBuffer[1])))?outputBuffer[1]:(0xc0 | (c << 6));\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (c < SURR1_FIRST || c > SURR2_LAST) { // nope\n                    outputBuffer[outputPtr++] = (byte) (0xe0 | (c >> 12));\n                    if (outputPtr >= outputEnd) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputEnd = outputBuffer.length;\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                } else { // yes, surrogate pair\n                    if (c > SURR1_LAST) { // must be from first range\n                        _illegalSurrogate(c);\n                    }\n                    // and if so, followed by another from next range\n                    if (inputPtr >= inputEnd) {\n                        _illegalSurrogate(c);\n                    }\n                    c = _convertSurrogate(c, text.charAt(inputPtr++));\n                    if (c > 0x10FFFF) { // illegal, as per RFC 4627\n                        _illegalSurrogate(c);\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0xf0 | (c >> 18));\n                    if (outputPtr >= outputEnd) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputEnd = outputBuffer.length;\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((c >> 12) & 0x3f));\n                    if (outputPtr >= outputEnd) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputEnd = outputBuffer.length;\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                }\n            }\n            if (outputPtr >= outputEnd) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputEnd = outputBuffer.length;\n                outputPtr = 0;\n            }\n            outputBuffer[outputPtr++] = (byte) (0x80 | (c & 0x3f));\n        }\n        return _byteBuilder.completeAndCoalesce(outputPtr);\n    }",
          "57": "    public byte[] encodeAsUTF8(String text)\n    {\n        ByteArrayBuilder byteBuilder = _byteBuilder;\n        if (byteBuilder == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _byteBuilder = byteBuilder = new ByteArrayBuilder(null);\n        }\n        int inputPtr = 0;\n        int inputEnd = text.length();\n        int outputPtr = 0;\n        byte[] outputBuffer = byteBuilder.resetAndGetFirstSegment();\n        int outputEnd = outputBuffer.length;\n        \n        main_loop:\n        while (inputPtr < inputEnd) {\n            int c = text.charAt(inputPtr++);\n\n            // first tight loop for ascii\n            while (c <= 0x7F) {\n                if (outputPtr >= outputEnd) {\n                    outputBuffer = byteBuilder.finishCurrentSegment();\n                    outputEnd = outputBuffer.length;\n                    outputPtr = 0;\n                }\n                outputBuffer[outputPtr++] = (byte) c;\n                if (inputPtr >= inputEnd) {\n                    break main_loop;\n                }\n                c = text.charAt(inputPtr++);\n            }\n\n            // then multi-byte...\n            if (outputPtr >= outputEnd) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputEnd = outputBuffer.length;\n                outputPtr = 0;\n            }\n            if (c < 0x800) { // 2-byte\noutputBuffer[outputPtr++] = (((0xc0 | (c << 6)) && (outputBuffer[0] == outputBuffer[1])))?outputBuffer[0]:outputBuffer;\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (c < SURR1_FIRST || c > SURR2_LAST) { // nope\n                    outputBuffer[outputPtr++] = (byte) (0xe0 | (c >> 12));\n                    if (outputPtr >= outputEnd) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputEnd = outputBuffer.length;\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                } else { // yes, surrogate pair\n                    if (c > SURR1_LAST) { // must be from first range\n                        _illegalSurrogate(c);\n                    }\n                    // and if so, followed by another from next range\n                    if (inputPtr >= inputEnd) {\n                        _illegalSurrogate(c);\n                    }\n                    c = _convertSurrogate(c, text.charAt(inputPtr++));\n                    if (c > 0x10FFFF) { // illegal, as per RFC 4627\n                        _illegalSurrogate(c);\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0xf0 | (c >> 18));\n                    if (outputPtr >= outputEnd) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputEnd = outputBuffer.length;\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((c >> 12) & 0x3f));\n                    if (outputPtr >= outputEnd) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputEnd = outputBuffer.length;\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                }\n            }\n            if (outputPtr >= outputEnd) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputEnd = outputBuffer.length;\n                outputPtr = 0;\n            }\n            outputBuffer[outputPtr++] = (byte) (0x80 | (c & 0x3f));\n        }\n        return _byteBuilder.completeAndCoalesce(outputPtr);\n    }",
          "58": "    public byte[] encodeAsUTF8(String text)\n    {\n        ByteArrayBuilder byteBuilder = _byteBuilder;\n        if (byteBuilder == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _byteBuilder = byteBuilder = new ByteArrayBuilder(null);\n        }\n        int inputPtr = 0;\n        int inputEnd = text.length();\n        int outputPtr = 0;\n        byte[] outputBuffer = byteBuilder.resetAndGetFirstSegment();\n        int outputEnd = outputBuffer.length;\n        \n        main_loop:\n        while (inputPtr < inputEnd) {\n            int c = text.charAt(inputPtr++);\n\n            // first tight loop for ascii\n            while (c <= 0x7F) {\n                if (outputPtr >= outputEnd) {\n                    outputBuffer = byteBuilder.finishCurrentSegment();\n                    outputEnd = outputBuffer.length;\n                    outputPtr = 0;\n                }\n                outputBuffer[outputPtr++] = (byte) c;\n                if (inputPtr >= inputEnd) {\n                    break main_loop;\n                }\n                c = text.charAt(inputPtr++);\n            }\n\n            // then multi-byte...\n            if (outputPtr >= outputEnd) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputEnd = outputBuffer.length;\n                outputPtr = 0;\n            }\n            if (c < 0x800) { // 2-byte\noutputBuffer[outputPtr++] = (((0xc0 | (c << 6)) && (outputBuffer[0] == outputBuffer[1])))?outputBuffer[0]:this.;\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (c < SURR1_FIRST || c > SURR2_LAST) { // nope\n                    outputBuffer[outputPtr++] = (byte) (0xe0 | (c >> 12));\n                    if (outputPtr >= outputEnd) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputEnd = outputBuffer.length;\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                } else { // yes, surrogate pair\n                    if (c > SURR1_LAST) { // must be from first range\n                        _illegalSurrogate(c);\n                    }\n                    // and if so, followed by another from next range\n                    if (inputPtr >= inputEnd) {\n                        _illegalSurrogate(c);\n                    }\n                    c = _convertSurrogate(c, text.charAt(inputPtr++));\n                    if (c > 0x10FFFF) { // illegal, as per RFC 4627\n                        _illegalSurrogate(c);\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0xf0 | (c >> 18));\n                    if (outputPtr >= outputEnd) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputEnd = outputBuffer.length;\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((c >> 12) & 0x3f));\n                    if (outputPtr >= outputEnd) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputEnd = outputBuffer.length;\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                }\n            }\n            if (outputPtr >= outputEnd) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputEnd = outputBuffer.length;\n                outputPtr = 0;\n            }\n            outputBuffer[outputPtr++] = (byte) (0x80 | (c & 0x3f));\n        }\n        return _byteBuilder.completeAndCoalesce(outputPtr);\n    }",
          "59": "    public byte[] encodeAsUTF8(String text)\n    {\n        ByteArrayBuilder byteBuilder = _byteBuilder;\n        if (byteBuilder == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _byteBuilder = byteBuilder = new ByteArrayBuilder(null);\n        }\n        int inputPtr = 0;\n        int inputEnd = text.length();\n        int outputPtr = 0;\n        byte[] outputBuffer = byteBuilder.resetAndGetFirstSegment();\n        int outputEnd = outputBuffer.length;\n        \n        main_loop:\n        while (inputPtr < inputEnd) {\n            int c = text.charAt(inputPtr++);\n\n            // first tight loop for ascii\n            while (c <= 0x7F) {\n                if (outputPtr >= outputEnd) {\n                    outputBuffer = byteBuilder.finishCurrentSegment();\n                    outputEnd = outputBuffer.length;\n                    outputPtr = 0;\n                }\n                outputBuffer[outputPtr++] = (byte) c;\n                if (inputPtr >= inputEnd) {\n                    break main_loop;\n                }\n                c = text.charAt(inputPtr++);\n            }\n\n            // then multi-byte...\n            if (outputPtr >= outputEnd) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputEnd = outputBuffer.length;\n                outputPtr = 0;\n            }\n            if (c < 0x800) { // 2-byte\noutputBuffer[outputPtr++] = (((0xc0 | (c << 6)) && (outputBuffer[0] != outputBuffer[1])))?outputBuffer[0]:outputBuffer;\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (c < SURR1_FIRST || c > SURR2_LAST) { // nope\n                    outputBuffer[outputPtr++] = (byte) (0xe0 | (c >> 12));\n                    if (outputPtr >= outputEnd) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputEnd = outputBuffer.length;\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                } else { // yes, surrogate pair\n                    if (c > SURR1_LAST) { // must be from first range\n                        _illegalSurrogate(c);\n                    }\n                    // and if so, followed by another from next range\n                    if (inputPtr >= inputEnd) {\n                        _illegalSurrogate(c);\n                    }\n                    c = _convertSurrogate(c, text.charAt(inputPtr++));\n                    if (c > 0x10FFFF) { // illegal, as per RFC 4627\n                        _illegalSurrogate(c);\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0xf0 | (c >> 18));\n                    if (outputPtr >= outputEnd) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputEnd = outputBuffer.length;\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((c >> 12) & 0x3f));\n                    if (outputPtr >= outputEnd) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputEnd = outputBuffer.length;\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                }\n            }\n            if (outputPtr >= outputEnd) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputEnd = outputBuffer.length;\n                outputPtr = 0;\n            }\n            outputBuffer[outputPtr++] = (byte) (0x80 | (c & 0x3f));\n        }\n        return _byteBuilder.completeAndCoalesce(outputPtr);\n    }",
          "60": "    public byte[] encodeAsUTF8(String text)\n    {\n        ByteArrayBuilder byteBuilder = _byteBuilder;\n        if (byteBuilder == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _byteBuilder = byteBuilder = new ByteArrayBuilder(null);\n        }\n        int inputPtr = 0;\n        int inputEnd = text.length();\n        int outputPtr = 0;\n        byte[] outputBuffer = byteBuilder.resetAndGetFirstSegment();\n        int outputEnd = outputBuffer.length;\n        \n        main_loop:\n        while (inputPtr < inputEnd) {\n            int c = text.charAt(inputPtr++);\n\n            // first tight loop for ascii\n            while (c <= 0x7F) {\n                if (outputPtr >= outputEnd) {\n                    outputBuffer = byteBuilder.finishCurrentSegment();\n                    outputEnd = outputBuffer.length;\n                    outputPtr = 0;\n                }\n                outputBuffer[outputPtr++] = (byte) c;\n                if (inputPtr >= inputEnd) {\n                    break main_loop;\n                }\n                c = text.charAt(inputPtr++);\n            }\n\n            // then multi-byte...\n            if (outputPtr >= outputEnd) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputEnd = outputBuffer.length;\n                outputPtr = 0;\n            }\n            if (c < 0x800) { // 2-byte\noutputBuffer[outputPtr++] = (((0xc0 | (c << 6)) && (outputBuffer[0] != outputBuffer[1])))?outputBuffer[0]:this.;\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (c < SURR1_FIRST || c > SURR2_LAST) { // nope\n                    outputBuffer[outputPtr++] = (byte) (0xe0 | (c >> 12));\n                    if (outputPtr >= outputEnd) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputEnd = outputBuffer.length;\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                } else { // yes, surrogate pair\n                    if (c > SURR1_LAST) { // must be from first range\n                        _illegalSurrogate(c);\n                    }\n                    // and if so, followed by another from next range\n                    if (inputPtr >= inputEnd) {\n                        _illegalSurrogate(c);\n                    }\n                    c = _convertSurrogate(c, text.charAt(inputPtr++));\n                    if (c > 0x10FFFF) { // illegal, as per RFC 4627\n                        _illegalSurrogate(c);\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0xf0 | (c >> 18));\n                    if (outputPtr >= outputEnd) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputEnd = outputBuffer.length;\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((c >> 12) & 0x3f));\n                    if (outputPtr >= outputEnd) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputEnd = outputBuffer.length;\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                }\n            }\n            if (outputPtr >= outputEnd) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputEnd = outputBuffer.length;\n                outputPtr = 0;\n            }\n            outputBuffer[outputPtr++] = (byte) (0x80 | (c & 0x3f));\n        }\n        return _byteBuilder.completeAndCoalesce(outputPtr);\n    }",
          "61": "    public byte[] encodeAsUTF8(String text)\n    {\n        ByteArrayBuilder byteBuilder = _byteBuilder;\n        if (byteBuilder == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _byteBuilder = byteBuilder = new ByteArrayBuilder(null);\n        }\n        int inputPtr = 0;\n        int inputEnd = text.length();\n        int outputPtr = 0;\n        byte[] outputBuffer = byteBuilder.resetAndGetFirstSegment();\n        int outputEnd = outputBuffer.length;\n        \n        main_loop:\n        while (inputPtr < inputEnd) {\n            int c = text.charAt(inputPtr++);\n\n            // first tight loop for ascii\n            while (c <= 0x7F) {\n                if (outputPtr >= outputEnd) {\n                    outputBuffer = byteBuilder.finishCurrentSegment();\n                    outputEnd = outputBuffer.length;\n                    outputPtr = 0;\n                }\n                outputBuffer[outputPtr++] = (byte) c;\n                if (inputPtr >= inputEnd) {\n                    break main_loop;\n                }\n                c = text.charAt(inputPtr++);\n            }\n\n            // then multi-byte...\n            if (outputPtr >= outputEnd) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputEnd = outputBuffer.length;\n                outputPtr = 0;\n            }\n            if (c < 0x800) { // 2-byte\noutputBuffer[outputPtr++] = (((0xc0 | (c << 6)) && (outputBuffer[0] == outputBuffer[1])))?outputBuffer[1]:outputBuffer;\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (c < SURR1_FIRST || c > SURR2_LAST) { // nope\n                    outputBuffer[outputPtr++] = (byte) (0xe0 | (c >> 12));\n                    if (outputPtr >= outputEnd) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputEnd = outputBuffer.length;\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                } else { // yes, surrogate pair\n                    if (c > SURR1_LAST) { // must be from first range\n                        _illegalSurrogate(c);\n                    }\n                    // and if so, followed by another from next range\n                    if (inputPtr >= inputEnd) {\n                        _illegalSurrogate(c);\n                    }\n                    c = _convertSurrogate(c, text.charAt(inputPtr++));\n                    if (c > 0x10FFFF) { // illegal, as per RFC 4627\n                        _illegalSurrogate(c);\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0xf0 | (c >> 18));\n                    if (outputPtr >= outputEnd) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputEnd = outputBuffer.length;\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((c >> 12) & 0x3f));\n                    if (outputPtr >= outputEnd) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputEnd = outputBuffer.length;\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                }\n            }\n            if (outputPtr >= outputEnd) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputEnd = outputBuffer.length;\n                outputPtr = 0;\n            }\n            outputBuffer[outputPtr++] = (byte) (0x80 | (c & 0x3f));\n        }\n        return _byteBuilder.completeAndCoalesce(outputPtr);\n    }",
          "62": "    public byte[] encodeAsUTF8(String text)\n    {\n        ByteArrayBuilder byteBuilder = _byteBuilder;\n        if (byteBuilder == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _byteBuilder = byteBuilder = new ByteArrayBuilder(null);\n        }\n        int inputPtr = 0;\n        int inputEnd = text.length();\n        int outputPtr = 0;\n        byte[] outputBuffer = byteBuilder.resetAndGetFirstSegment();\n        int outputEnd = outputBuffer.length;\n        \n        main_loop:\n        while (inputPtr < inputEnd) {\n            int c = text.charAt(inputPtr++);\n\n            // first tight loop for ascii\n            while (c <= 0x7F) {\n                if (outputPtr >= outputEnd) {\n                    outputBuffer = byteBuilder.finishCurrentSegment();\n                    outputEnd = outputBuffer.length;\n                    outputPtr = 0;\n                }\n                outputBuffer[outputPtr++] = (byte) c;\n                if (inputPtr >= inputEnd) {\n                    break main_loop;\n                }\n                c = text.charAt(inputPtr++);\n            }\n\n            // then multi-byte...\n            if (outputPtr >= outputEnd) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputEnd = outputBuffer.length;\n                outputPtr = 0;\n            }\n            if (c < 0x800) { // 2-byte\noutputBuffer[outputPtr++] = (((0xc0 | (c << 6)) && (outputBuffer[0] != outputBuffer[1])))?outputBuffer[1]:outputBuffer;\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (c < SURR1_FIRST || c > SURR2_LAST) { // nope\n                    outputBuffer[outputPtr++] = (byte) (0xe0 | (c >> 12));\n                    if (outputPtr >= outputEnd) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputEnd = outputBuffer.length;\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                } else { // yes, surrogate pair\n                    if (c > SURR1_LAST) { // must be from first range\n                        _illegalSurrogate(c);\n                    }\n                    // and if so, followed by another from next range\n                    if (inputPtr >= inputEnd) {\n                        _illegalSurrogate(c);\n                    }\n                    c = _convertSurrogate(c, text.charAt(inputPtr++));\n                    if (c > 0x10FFFF) { // illegal, as per RFC 4627\n                        _illegalSurrogate(c);\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0xf0 | (c >> 18));\n                    if (outputPtr >= outputEnd) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputEnd = outputBuffer.length;\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((c >> 12) & 0x3f));\n                    if (outputPtr >= outputEnd) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputEnd = outputBuffer.length;\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                }\n            }\n            if (outputPtr >= outputEnd) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputEnd = outputBuffer.length;\n                outputPtr = 0;\n            }\n            outputBuffer[outputPtr++] = (byte) (0x80 | (c & 0x3f));\n        }\n        return _byteBuilder.completeAndCoalesce(outputPtr);\n    }",
          "63": "    public byte[] encodeAsUTF8(String text)\n    {\n        ByteArrayBuilder byteBuilder = _byteBuilder;\n        if (byteBuilder == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _byteBuilder = byteBuilder = new ByteArrayBuilder(null);\n        }\n        int inputPtr = 0;\n        int inputEnd = text.length();\n        int outputPtr = 0;\n        byte[] outputBuffer = byteBuilder.resetAndGetFirstSegment();\n        int outputEnd = outputBuffer.length;\n        \n        main_loop:\n        while (inputPtr < inputEnd) {\n            int c = text.charAt(inputPtr++);\n\n            // first tight loop for ascii\n            while (c <= 0x7F) {\n                if (outputPtr >= outputEnd) {\n                    outputBuffer = byteBuilder.finishCurrentSegment();\n                    outputEnd = outputBuffer.length;\n                    outputPtr = 0;\n                }\n                outputBuffer[outputPtr++] = (byte) c;\n                if (inputPtr >= inputEnd) {\n                    break main_loop;\n                }\n                c = text.charAt(inputPtr++);\n            }\n\n            // then multi-byte...\n            if (outputPtr >= outputEnd) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputEnd = outputBuffer.length;\n                outputPtr = 0;\n            }\n            if (c < 0x800) { // 2-byte\noutputBuffer[outputPtr++] = (((0xc0 | (c << 6)) && (outputBuffer[0] == outputBuffer[1])))?outputBuffer[1]:this.;\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (c < SURR1_FIRST || c > SURR2_LAST) { // nope\n                    outputBuffer[outputPtr++] = (byte) (0xe0 | (c >> 12));\n                    if (outputPtr >= outputEnd) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputEnd = outputBuffer.length;\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                } else { // yes, surrogate pair\n                    if (c > SURR1_LAST) { // must be from first range\n                        _illegalSurrogate(c);\n                    }\n                    // and if so, followed by another from next range\n                    if (inputPtr >= inputEnd) {\n                        _illegalSurrogate(c);\n                    }\n                    c = _convertSurrogate(c, text.charAt(inputPtr++));\n                    if (c > 0x10FFFF) { // illegal, as per RFC 4627\n                        _illegalSurrogate(c);\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0xf0 | (c >> 18));\n                    if (outputPtr >= outputEnd) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputEnd = outputBuffer.length;\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((c >> 12) & 0x3f));\n                    if (outputPtr >= outputEnd) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputEnd = outputBuffer.length;\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                }\n            }\n            if (outputPtr >= outputEnd) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputEnd = outputBuffer.length;\n                outputPtr = 0;\n            }\n            outputBuffer[outputPtr++] = (byte) (0x80 | (c & 0x3f));\n        }\n        return _byteBuilder.completeAndCoalesce(outputPtr);\n    }",
          "64": "    public byte[] encodeAsUTF8(String text)\n    {\n        ByteArrayBuilder byteBuilder = _byteBuilder;\n        if (byteBuilder == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _byteBuilder = byteBuilder = new ByteArrayBuilder(null);\n        }\n        int inputPtr = 0;\n        int inputEnd = text.length();\n        int outputPtr = 0;\n        byte[] outputBuffer = byteBuilder.resetAndGetFirstSegment();\n        int outputEnd = outputBuffer.length;\n        \n        main_loop:\n        while (inputPtr < inputEnd) {\n            int c = text.charAt(inputPtr++);\n\n            // first tight loop for ascii\n            while (c <= 0x7F) {\n                if (outputPtr >= outputEnd) {\n                    outputBuffer = byteBuilder.finishCurrentSegment();\n                    outputEnd = outputBuffer.length;\n                    outputPtr = 0;\n                }\n                outputBuffer[outputPtr++] = (byte) c;\n                if (inputPtr >= inputEnd) {\n                    break main_loop;\n                }\n                c = text.charAt(inputPtr++);\n            }\n\n            // then multi-byte...\n            if (outputPtr >= outputEnd) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputEnd = outputBuffer.length;\n                outputPtr = 0;\n            }\n            if (c < 0x800) { // 2-byte\noutputBuffer[outputPtr++] = (((0xc0 | (c << 6)) && (outputBuffer[0] != outputBuffer[1])))?outputBuffer[1]:this.;\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (c < SURR1_FIRST || c > SURR2_LAST) { // nope\n                    outputBuffer[outputPtr++] = (byte) (0xe0 | (c >> 12));\n                    if (outputPtr >= outputEnd) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputEnd = outputBuffer.length;\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                } else { // yes, surrogate pair\n                    if (c > SURR1_LAST) { // must be from first range\n                        _illegalSurrogate(c);\n                    }\n                    // and if so, followed by another from next range\n                    if (inputPtr >= inputEnd) {\n                        _illegalSurrogate(c);\n                    }\n                    c = _convertSurrogate(c, text.charAt(inputPtr++));\n                    if (c > 0x10FFFF) { // illegal, as per RFC 4627\n                        _illegalSurrogate(c);\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0xf0 | (c >> 18));\n                    if (outputPtr >= outputEnd) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputEnd = outputBuffer.length;\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((c >> 12) & 0x3f));\n                    if (outputPtr >= outputEnd) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputEnd = outputBuffer.length;\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                }\n            }\n            if (outputPtr >= outputEnd) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputEnd = outputBuffer.length;\n                outputPtr = 0;\n            }\n            outputBuffer[outputPtr++] = (byte) (0x80 | (c & 0x3f));\n        }\n        return _byteBuilder.completeAndCoalesce(outputPtr);\n    }",
          "65": "    public byte[] encodeAsUTF8(String text)\n    {\n        ByteArrayBuilder byteBuilder = _byteBuilder;\n        if (byteBuilder == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _byteBuilder = byteBuilder = new ByteArrayBuilder(null);\n        }\n        int inputPtr = 0;\n        int inputEnd = text.length();\n        int outputPtr = 0;\n        byte[] outputBuffer = byteBuilder.resetAndGetFirstSegment();\n        int outputEnd = outputBuffer.length;\n        \n        main_loop:\n        while (inputPtr < inputEnd) {\n            int c = text.charAt(inputPtr++);\n\n            // first tight loop for ascii\n            while (c <= 0x7F) {\n                if (outputPtr >= outputEnd) {\n                    outputBuffer = byteBuilder.finishCurrentSegment();\n                    outputEnd = outputBuffer.length;\n                    outputPtr = 0;\n                }\n                outputBuffer[outputPtr++] = (byte) c;\n                if (inputPtr >= inputEnd) {\n                    break main_loop;\n                }\n                c = text.charAt(inputPtr++);\n            }\n\n            // then multi-byte...\n            if (outputPtr >= outputEnd) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputEnd = outputBuffer.length;\n                outputPtr = 0;\n            }\n            if (c < 0x800) { // 2-byte\noutputBuffer[outputPtr++] = (((0xc0 | (c << 6)) && (outputBuffer[0] == outputBuffer[1])))?outputBuffer[0]:outputBuffer;\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (c < SURR1_FIRST || c > SURR2_LAST) { // nope\n                    outputBuffer[outputPtr++] = (byte) (0xe0 | (c >> 12));\n                    if (outputPtr >= outputEnd) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputEnd = outputBuffer.length;\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                } else { // yes, surrogate pair\n                    if (c > SURR1_LAST) { // must be from first range\n                        _illegalSurrogate(c);\n                    }\n                    // and if so, followed by another from next range\n                    if (inputPtr >= inputEnd) {\n                        _illegalSurrogate(c);\n                    }\n                    c = _convertSurrogate(c, text.charAt(inputPtr++));\n                    if (c > 0x10FFFF) { // illegal, as per RFC 4627\n                        _illegalSurrogate(c);\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0xf0 | (c >> 18));\n                    if (outputPtr >= outputEnd) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputEnd = outputBuffer.length;\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((c >> 12) & 0x3f));\n                    if (outputPtr >= outputEnd) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputEnd = outputBuffer.length;\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                }\n            }\n            if (outputPtr >= outputEnd) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputEnd = outputBuffer.length;\n                outputPtr = 0;\n            }\n            outputBuffer[outputPtr++] = (byte) (0x80 | (c & 0x3f));\n        }\n        return _byteBuilder.completeAndCoalesce(outputPtr);\n    }",
          "66": "    public byte[] encodeAsUTF8(String text)\n    {\n        ByteArrayBuilder byteBuilder = _byteBuilder;\n        if (byteBuilder == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _byteBuilder = byteBuilder = new ByteArrayBuilder(null);\n        }\n        int inputPtr = 0;\n        int inputEnd = text.length();\n        int outputPtr = 0;\n        byte[] outputBuffer = byteBuilder.resetAndGetFirstSegment();\n        int outputEnd = outputBuffer.length;\n        \n        main_loop:\n        while (inputPtr < inputEnd) {\n            int c = text.charAt(inputPtr++);\n\n            // first tight loop for ascii\n            while (c <= 0x7F) {\n                if (outputPtr >= outputEnd) {\n                    outputBuffer = byteBuilder.finishCurrentSegment();\n                    outputEnd = outputBuffer.length;\n                    outputPtr = 0;\n                }\n                outputBuffer[outputPtr++] = (byte) c;\n                if (inputPtr >= inputEnd) {\n                    break main_loop;\n                }\n                c = text.charAt(inputPtr++);\n            }\n\n            // then multi-byte...\n            if (outputPtr >= outputEnd) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputEnd = outputBuffer.length;\n                outputPtr = 0;\n            }\n            if (c < 0x800) { // 2-byte\noutputBuffer[outputPtr++] = (((0xc0 | (c << 6)) && (outputBuffer[0] != outputBuffer[1])))?outputBuffer[0]:outputBuffer;\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (c < SURR1_FIRST || c > SURR2_LAST) { // nope\n                    outputBuffer[outputPtr++] = (byte) (0xe0 | (c >> 12));\n                    if (outputPtr >= outputEnd) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputEnd = outputBuffer.length;\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                } else { // yes, surrogate pair\n                    if (c > SURR1_LAST) { // must be from first range\n                        _illegalSurrogate(c);\n                    }\n                    // and if so, followed by another from next range\n                    if (inputPtr >= inputEnd) {\n                        _illegalSurrogate(c);\n                    }\n                    c = _convertSurrogate(c, text.charAt(inputPtr++));\n                    if (c > 0x10FFFF) { // illegal, as per RFC 4627\n                        _illegalSurrogate(c);\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0xf0 | (c >> 18));\n                    if (outputPtr >= outputEnd) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputEnd = outputBuffer.length;\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((c >> 12) & 0x3f));\n                    if (outputPtr >= outputEnd) {\n                        outputBuffer = byteBuilder.finishCurrentSegment();\n                        outputEnd = outputBuffer.length;\n                        outputPtr = 0;\n                    }\n                    outputBuffer[outputPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                }\n            }\n            if (outputPtr >= outputEnd) {\n                outputBuffer = byteBuilder.finishCurrentSegment();\n                outputEnd = outputBuffer.length;\n                outputPtr = 0;\n            }\n            outputBuffer[outputPtr++] = (byte) (0x80 | (c & 0x3f));\n        }\n        return _byteBuilder.completeAndCoalesce(outputPtr);\n    }"
}