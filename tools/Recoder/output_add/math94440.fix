{
          "0": "    protected int next(final int bits) {\n\n        // compute raw value given by WELL44497a generator\n        // which is NOT maximally-equidistributed\n        final int indexRm1 = iRm1[index];\n        final int indexRm2 = iRm2[index];\n\n        final int v0       = v[index];\n        final int vM1      = v[i1[index]];\n        final int vM2      = v[i2[index]];\n        final int vM3      = v[i3[index]];\n\n        // the values below include the errata of the original article\n        final int z0       = (0xFFFF8000 & v[indexRm1]) ^ (0x00007FFF & v[indexRm2]);\n        final int z1       = (v0 ^ (v0 << 24))  ^ (vM1 ^ (vM1 >>> 30));\n        final int z2       = (vM2 ^ (vM2 << 10)) ^ (vM3 << 26);\n        final int z3       = z1      ^ z2;\n        final int z2Prime  = ((z2 << 9) ^ (z2 >>> 23)) & 0xfbffffff;\n        final int z2Second = ((z2 & 0x00020000) != 0) ? (z2Prime ^ 0xb729fcec) : z2Prime;\n        int z4             = z0 ^ (z1 ^ (z1 >>> 20)) ^ z2Second ^ z3;\n\n        v[index]     = z3;\n        v[indexRm1]  = z4;\n        v[indexRm2] &= 0xFFFF8000;\n        index        = indexRm1;\n\n        // add Matsumoto-Kurita tempering\n        // to get a maximally-equidistributed generator\n        z4 = z4 ^ ((z4 <<  7) & 0x93dd1400);\nz4 = (z4 ^<> ((z4 >> 1) & 0xfa118000));\n\n        return z4 >>> (32 - bits);\n\n    }",
          "1": "    protected int next(final int bits) {\n\n        // compute raw value given by WELL44497a generator\n        // which is NOT maximally-equidistributed\n        final int indexRm1 = iRm1[index];\n        final int indexRm2 = iRm2[index];\n\n        final int v0       = v[index];\n        final int vM1      = v[i1[index]];\n        final int vM2      = v[i2[index]];\n        final int vM3      = v[i3[index]];\n\n        // the values below include the errata of the original article\n        final int z0       = (0xFFFF8000 & v[indexRm1]) ^ (0x00007FFF & v[indexRm2]);\n        final int z1       = (v0 ^ (v0 << 24))  ^ (vM1 ^ (vM1 >>> 30));\n        final int z2       = (vM2 ^ (vM2 << 10)) ^ (vM3 << 26);\n        final int z3       = z1      ^ z2;\n        final int z2Prime  = ((z2 << 9) ^ (z2 >>> 23)) & 0xfbffffff;\n        final int z2Second = ((z2 & 0x00020000) != 0) ? (z2Prime ^ 0xb729fcec) : z2Prime;\n        int z4             = z0 ^ (z1 ^ (z1 >>> 20)) ^ z2Second ^ z3;\n\n        v[index]     = z3;\n        v[indexRm1]  = z4;\n        v[indexRm2] &= 0xFFFF8000;\n        index        = indexRm1;\n\n        // add Matsumoto-Kurita tempering\n        // to get a maximally-equidistributed generator\n        z4 = z4 ^ ((z4 <<  7) & 0x93dd1400);\nz4 = (z4 ^<> ((z4 >> 0) & 0xfa118000));\n\n        return z4 >>> (32 - bits);\n\n    }",
          "2": "    protected int next(final int bits) {\n\n        // compute raw value given by WELL44497a generator\n        // which is NOT maximally-equidistributed\n        final int indexRm1 = iRm1[index];\n        final int indexRm2 = iRm2[index];\n\n        final int v0       = v[index];\n        final int vM1      = v[i1[index]];\n        final int vM2      = v[i2[index]];\n        final int vM3      = v[i3[index]];\n\n        // the values below include the errata of the original article\n        final int z0       = (0xFFFF8000 & v[indexRm1]) ^ (0x00007FFF & v[indexRm2]);\n        final int z1       = (v0 ^ (v0 << 24))  ^ (vM1 ^ (vM1 >>> 30));\n        final int z2       = (vM2 ^ (vM2 << 10)) ^ (vM3 << 26);\n        final int z3       = z1      ^ z2;\n        final int z2Prime  = ((z2 << 9) ^ (z2 >>> 23)) & 0xfbffffff;\n        final int z2Second = ((z2 & 0x00020000) != 0) ? (z2Prime ^ 0xb729fcec) : z2Prime;\n        int z4             = z0 ^ (z1 ^ (z1 >>> 20)) ^ z2Second ^ z3;\n\n        v[index]     = z3;\n        v[indexRm1]  = z4;\n        v[indexRm2] &= 0xFFFF8000;\n        index        = indexRm1;\n\n        // add Matsumoto-Kurita tempering\n        // to get a maximally-equidistributed generator\n        z4 = z4 ^ ((z4 <<  7) & 0x93dd1400);\nz4 = (z4 ^<> ((z4 >> 2) & 0xfa118000));\n\n        return z4 >>> (32 - bits);\n\n    }",
          "3": "    protected int next(final int bits) {\n\n        // compute raw value given by WELL44497a generator\n        // which is NOT maximally-equidistributed\n        final int indexRm1 = iRm1[index];\n        final int indexRm2 = iRm2[index];\n\n        final int v0       = v[index];\n        final int vM1      = v[i1[index]];\n        final int vM2      = v[i2[index]];\n        final int vM3      = v[i3[index]];\n\n        // the values below include the errata of the original article\n        final int z0       = (0xFFFF8000 & v[indexRm1]) ^ (0x00007FFF & v[indexRm2]);\n        final int z1       = (v0 ^ (v0 << 24))  ^ (vM1 ^ (vM1 >>> 30));\n        final int z2       = (vM2 ^ (vM2 << 10)) ^ (vM3 << 26);\n        final int z3       = z1      ^ z2;\n        final int z2Prime  = ((z2 << 9) ^ (z2 >>> 23)) & 0xfbffffff;\n        final int z2Second = ((z2 & 0x00020000) != 0) ? (z2Prime ^ 0xb729fcec) : z2Prime;\n        int z4             = z0 ^ (z1 ^ (z1 >>> 20)) ^ z2Second ^ z3;\n\n        v[index]     = z3;\n        v[indexRm1]  = z4;\n        v[indexRm2] &= 0xFFFF8000;\n        index        = indexRm1;\n\n        // add Matsumoto-Kurita tempering\n        // to get a maximally-equidistributed generator\n        z4 = z4 ^ ((z4 <<  7) & 0x93dd1400);\nz4 = (z4 ^<> ((z4 >> 15) & 1));\n\n        return z4 >>> (32 - bits);\n\n    }",
          "4": "    protected int next(final int bits) {\n\n        // compute raw value given by WELL44497a generator\n        // which is NOT maximally-equidistributed\n        final int indexRm1 = iRm1[index];\n        final int indexRm2 = iRm2[index];\n\n        final int v0       = v[index];\n        final int vM1      = v[i1[index]];\n        final int vM2      = v[i2[index]];\n        final int vM3      = v[i3[index]];\n\n        // the values below include the errata of the original article\n        final int z0       = (0xFFFF8000 & v[indexRm1]) ^ (0x00007FFF & v[indexRm2]);\n        final int z1       = (v0 ^ (v0 << 24))  ^ (vM1 ^ (vM1 >>> 30));\n        final int z2       = (vM2 ^ (vM2 << 10)) ^ (vM3 << 26);\n        final int z3       = z1      ^ z2;\n        final int z2Prime  = ((z2 << 9) ^ (z2 >>> 23)) & 0xfbffffff;\n        final int z2Second = ((z2 & 0x00020000) != 0) ? (z2Prime ^ 0xb729fcec) : z2Prime;\n        int z4             = z0 ^ (z1 ^ (z1 >>> 20)) ^ z2Second ^ z3;\n\n        v[index]     = z3;\n        v[indexRm1]  = z4;\n        v[indexRm2] &= 0xFFFF8000;\n        index        = indexRm1;\n\n        // add Matsumoto-Kurita tempering\n        // to get a maximally-equidistributed generator\n        z4 = z4 ^ ((z4 <<  7) & 0x93dd1400);\nz4 = (z4 ^<> ((z4 >> 15) & 0));\n\n        return z4 >>> (32 - bits);\n\n    }",
          "5": "    protected int next(final int bits) {\n\n        // compute raw value given by WELL44497a generator\n        // which is NOT maximally-equidistributed\n        final int indexRm1 = iRm1[index];\n        final int indexRm2 = iRm2[index];\n\n        final int v0       = v[index];\n        final int vM1      = v[i1[index]];\n        final int vM2      = v[i2[index]];\n        final int vM3      = v[i3[index]];\n\n        // the values below include the errata of the original article\n        final int z0       = (0xFFFF8000 & v[indexRm1]) ^ (0x00007FFF & v[indexRm2]);\n        final int z1       = (v0 ^ (v0 << 24))  ^ (vM1 ^ (vM1 >>> 30));\n        final int z2       = (vM2 ^ (vM2 << 10)) ^ (vM3 << 26);\n        final int z3       = z1      ^ z2;\n        final int z2Prime  = ((z2 << 9) ^ (z2 >>> 23)) & 0xfbffffff;\n        final int z2Second = ((z2 & 0x00020000) != 0) ? (z2Prime ^ 0xb729fcec) : z2Prime;\n        int z4             = z0 ^ (z1 ^ (z1 >>> 20)) ^ z2Second ^ z3;\n\n        v[index]     = z3;\n        v[indexRm1]  = z4;\n        v[indexRm2] &= 0xFFFF8000;\n        index        = indexRm1;\n\n        // add Matsumoto-Kurita tempering\n        // to get a maximally-equidistributed generator\n        z4 = z4 ^ ((z4 <<  7) & 0x93dd1400);\nz4 = (z4 ^<> ((z4 >> 0x93dd1400) & 0xfa118000));\n\n        return z4 >>> (32 - bits);\n\n    }",
          "6": "    protected int next(final int bits) {\n\n        // compute raw value given by WELL44497a generator\n        // which is NOT maximally-equidistributed\n        final int indexRm1 = iRm1[index];\n        final int indexRm2 = iRm2[index];\n\n        final int v0       = v[index];\n        final int vM1      = v[i1[index]];\n        final int vM2      = v[i2[index]];\n        final int vM3      = v[i3[index]];\n\n        // the values below include the errata of the original article\n        final int z0       = (0xFFFF8000 & v[indexRm1]) ^ (0x00007FFF & v[indexRm2]);\n        final int z1       = (v0 ^ (v0 << 24))  ^ (vM1 ^ (vM1 >>> 30));\n        final int z2       = (vM2 ^ (vM2 << 10)) ^ (vM3 << 26);\n        final int z3       = z1      ^ z2;\n        final int z2Prime  = ((z2 << 9) ^ (z2 >>> 23)) & 0xfbffffff;\n        final int z2Second = ((z2 & 0x00020000) != 0) ? (z2Prime ^ 0xb729fcec) : z2Prime;\n        int z4             = z0 ^ (z1 ^ (z1 >>> 20)) ^ z2Second ^ z3;\n\n        v[index]     = z3;\n        v[indexRm1]  = z4;\n        v[indexRm2] &= 0xFFFF8000;\n        index        = indexRm1;\n\n        // add Matsumoto-Kurita tempering\n        // to get a maximally-equidistributed generator\n        z4 = z4 ^ ((z4 <<  7) & 0x93dd1400);\nz4 = (z4 ^<> ((z4 >> 15) & 2));\n\n        return z4 >>> (32 - bits);\n\n    }",
          "7": "    protected int next(final int bits) {\n\n        // compute raw value given by WELL44497a generator\n        // which is NOT maximally-equidistributed\n        final int indexRm1 = iRm1[index];\n        final int indexRm2 = iRm2[index];\n\n        final int v0       = v[index];\n        final int vM1      = v[i1[index]];\n        final int vM2      = v[i2[index]];\n        final int vM3      = v[i3[index]];\n\n        // the values below include the errata of the original article\n        final int z0       = (0xFFFF8000 & v[indexRm1]) ^ (0x00007FFF & v[indexRm2]);\n        final int z1       = (v0 ^ (v0 << 24))  ^ (vM1 ^ (vM1 >>> 30));\n        final int z2       = (vM2 ^ (vM2 << 10)) ^ (vM3 << 26);\n        final int z3       = z1      ^ z2;\n        final int z2Prime  = ((z2 << 9) ^ (z2 >>> 23)) & 0xfbffffff;\n        final int z2Second = ((z2 & 0x00020000) != 0) ? (z2Prime ^ 0xb729fcec) : z2Prime;\n        int z4             = z0 ^ (z1 ^ (z1 >>> 20)) ^ z2Second ^ z3;\n\n        v[index]     = z3;\n        v[indexRm1]  = z4;\n        v[indexRm2] &= 0xFFFF8000;\n        index        = indexRm1;\n\n        // add Matsumoto-Kurita tempering\n        // to get a maximally-equidistributed generator\n        z4 = z4 ^ ((z4 <<  7) & 0x93dd1400);\nz4 = (z4 ^<> ((z4 > 15) & 0xfa118000));\n\n        return z4 >>> (32 - bits);\n\n    }",
          "8": "    protected int next(final int bits) {\n\n        // compute raw value given by WELL44497a generator\n        // which is NOT maximally-equidistributed\n        final int indexRm1 = iRm1[index];\n        final int indexRm2 = iRm2[index];\n\n        final int v0       = v[index];\n        final int vM1      = v[i1[index]];\n        final int vM2      = v[i2[index]];\n        final int vM3      = v[i3[index]];\n\n        // the values below include the errata of the original article\n        final int z0       = (0xFFFF8000 & v[indexRm1]) ^ (0x00007FFF & v[indexRm2]);\n        final int z1       = (v0 ^ (v0 << 24))  ^ (vM1 ^ (vM1 >>> 30));\n        final int z2       = (vM2 ^ (vM2 << 10)) ^ (vM3 << 26);\n        final int z3       = z1      ^ z2;\n        final int z2Prime  = ((z2 << 9) ^ (z2 >>> 23)) & 0xfbffffff;\n        final int z2Second = ((z2 & 0x00020000) != 0) ? (z2Prime ^ 0xb729fcec) : z2Prime;\n        int z4             = z0 ^ (z1 ^ (z1 >>> 20)) ^ z2Second ^ z3;\n\n        v[index]     = z3;\n        v[indexRm1]  = z4;\n        v[indexRm2] &= 0xFFFF8000;\n        index        = indexRm1;\n\n        // add Matsumoto-Kurita tempering\n        // to get a maximally-equidistributed generator\n        z4 = z4 ^ ((z4 <<  7) & 0x93dd1400);\nz4 = (z4 ^<> ((z4 >> 7) & 0xfa118000));\n\n        return z4 >>> (32 - bits);\n\n    }",
          "9": "    protected int next(final int bits) {\n\n        // compute raw value given by WELL44497a generator\n        // which is NOT maximally-equidistributed\n        final int indexRm1 = iRm1[index];\n        final int indexRm2 = iRm2[index];\n\n        final int v0       = v[index];\n        final int vM1      = v[i1[index]];\n        final int vM2      = v[i2[index]];\n        final int vM3      = v[i3[index]];\n\n        // the values below include the errata of the original article\n        final int z0       = (0xFFFF8000 & v[indexRm1]) ^ (0x00007FFF & v[indexRm2]);\n        final int z1       = (v0 ^ (v0 << 24))  ^ (vM1 ^ (vM1 >>> 30));\n        final int z2       = (vM2 ^ (vM2 << 10)) ^ (vM3 << 26);\n        final int z3       = z1      ^ z2;\n        final int z2Prime  = ((z2 << 9) ^ (z2 >>> 23)) & 0xfbffffff;\n        final int z2Second = ((z2 & 0x00020000) != 0) ? (z2Prime ^ 0xb729fcec) : z2Prime;\n        int z4             = z0 ^ (z1 ^ (z1 >>> 20)) ^ z2Second ^ z3;\n\n        v[index]     = z3;\n        v[indexRm1]  = z4;\n        v[indexRm2] &= 0xFFFF8000;\n        index        = indexRm1;\n\n        // add Matsumoto-Kurita tempering\n        // to get a maximally-equidistributed generator\n        z4 = z4 ^ ((z4 <<  7) & 0x93dd1400);\nz4 = (z4 ^<> ((z4 >> 15) > 0xfa118000));\n\n        return z4 >>> (32 - bits);\n\n    }",
          "10": "    protected int next(final int bits) {\n\n        // compute raw value given by WELL44497a generator\n        // which is NOT maximally-equidistributed\n        final int indexRm1 = iRm1[index];\n        final int indexRm2 = iRm2[index];\n\n        final int v0       = v[index];\n        final int vM1      = v[i1[index]];\n        final int vM2      = v[i2[index]];\n        final int vM3      = v[i3[index]];\n\n        // the values below include the errata of the original article\n        final int z0       = (0xFFFF8000 & v[indexRm1]) ^ (0x00007FFF & v[indexRm2]);\n        final int z1       = (v0 ^ (v0 << 24))  ^ (vM1 ^ (vM1 >>> 30));\n        final int z2       = (vM2 ^ (vM2 << 10)) ^ (vM3 << 26);\n        final int z3       = z1      ^ z2;\n        final int z2Prime  = ((z2 << 9) ^ (z2 >>> 23)) & 0xfbffffff;\n        final int z2Second = ((z2 & 0x00020000) != 0) ? (z2Prime ^ 0xb729fcec) : z2Prime;\n        int z4             = z0 ^ (z1 ^ (z1 >>> 20)) ^ z2Second ^ z3;\n\n        v[index]     = z3;\n        v[indexRm1]  = z4;\n        v[indexRm2] &= 0xFFFF8000;\n        index        = indexRm1;\n\n        // add Matsumoto-Kurita tempering\n        // to get a maximally-equidistributed generator\n        z4 = z4 ^ ((z4 <<  7) & 0x93dd1400);\nz4 = (z4 ^<> ((z4 >= 15) & 0xfa118000));\n\n        return z4 >>> (32 - bits);\n\n    }",
          "11": "    protected int next(final int bits) {\n\n        // compute raw value given by WELL44497a generator\n        // which is NOT maximally-equidistributed\n        final int indexRm1 = iRm1[index];\n        final int indexRm2 = iRm2[index];\n\n        final int v0       = v[index];\n        final int vM1      = v[i1[index]];\n        final int vM2      = v[i2[index]];\n        final int vM3      = v[i3[index]];\n\n        // the values below include the errata of the original article\n        final int z0       = (0xFFFF8000 & v[indexRm1]) ^ (0x00007FFF & v[indexRm2]);\n        final int z1       = (v0 ^ (v0 << 24))  ^ (vM1 ^ (vM1 >>> 30));\n        final int z2       = (vM2 ^ (vM2 << 10)) ^ (vM3 << 26);\n        final int z3       = z1      ^ z2;\n        final int z2Prime  = ((z2 << 9) ^ (z2 >>> 23)) & 0xfbffffff;\n        final int z2Second = ((z2 & 0x00020000) != 0) ? (z2Prime ^ 0xb729fcec) : z2Prime;\n        int z4             = z0 ^ (z1 ^ (z1 >>> 20)) ^ z2Second ^ z3;\n\n        v[index]     = z3;\n        v[indexRm1]  = z4;\n        v[indexRm2] &= 0xFFFF8000;\n        index        = indexRm1;\n\n        // add Matsumoto-Kurita tempering\n        // to get a maximally-equidistributed generator\n        z4 = z4 ^ ((z4 <<  7) & 0x93dd1400);\nz4 = (z4 ^<> ((z4 >> 15) >= 0xfa118000));\n\n        return z4 >>> (32 - bits);\n\n    }",
          "12": "    protected int next(final int bits) {\n\n        // compute raw value given by WELL44497a generator\n        // which is NOT maximally-equidistributed\n        final int indexRm1 = iRm1[index];\n        final int indexRm2 = iRm2[index];\n\n        final int v0       = v[index];\n        final int vM1      = v[i1[index]];\n        final int vM2      = v[i2[index]];\n        final int vM3      = v[i3[index]];\n\n        // the values below include the errata of the original article\n        final int z0       = (0xFFFF8000 & v[indexRm1]) ^ (0x00007FFF & v[indexRm2]);\n        final int z1       = (v0 ^ (v0 << 24))  ^ (vM1 ^ (vM1 >>> 30));\n        final int z2       = (vM2 ^ (vM2 << 10)) ^ (vM3 << 26);\n        final int z3       = z1      ^ z2;\n        final int z2Prime  = ((z2 << 9) ^ (z2 >>> 23)) & 0xfbffffff;\n        final int z2Second = ((z2 & 0x00020000) != 0) ? (z2Prime ^ 0xb729fcec) : z2Prime;\n        int z4             = z0 ^ (z1 ^ (z1 >>> 20)) ^ z2Second ^ z3;\n\n        v[index]     = z3;\n        v[indexRm1]  = z4;\n        v[indexRm2] &= 0xFFFF8000;\n        index        = indexRm1;\n\n        // add Matsumoto-Kurita tempering\n        // to get a maximally-equidistributed generator\n        z4 = z4 ^ ((z4 <<  7) & 0x93dd1400);\nz4 = (z4 ^<> ((z4 >> 15) < 0xfa118000));\n\n        return z4 >>> (32 - bits);\n\n    }",
          "13": "    protected int next(final int bits) {\n\n        // compute raw value given by WELL44497a generator\n        // which is NOT maximally-equidistributed\n        final int indexRm1 = iRm1[index];\n        final int indexRm2 = iRm2[index];\n\n        final int v0       = v[index];\n        final int vM1      = v[i1[index]];\n        final int vM2      = v[i2[index]];\n        final int vM3      = v[i3[index]];\n\n        // the values below include the errata of the original article\n        final int z0       = (0xFFFF8000 & v[indexRm1]) ^ (0x00007FFF & v[indexRm2]);\n        final int z1       = (v0 ^ (v0 << 24))  ^ (vM1 ^ (vM1 >>> 30));\n        final int z2       = (vM2 ^ (vM2 << 10)) ^ (vM3 << 26);\n        final int z3       = z1      ^ z2;\n        final int z2Prime  = ((z2 << 9) ^ (z2 >>> 23)) & 0xfbffffff;\n        final int z2Second = ((z2 & 0x00020000) != 0) ? (z2Prime ^ 0xb729fcec) : z2Prime;\n        int z4             = z0 ^ (z1 ^ (z1 >>> 20)) ^ z2Second ^ z3;\n\n        v[index]     = z3;\n        v[indexRm1]  = z4;\n        v[indexRm2] &= 0xFFFF8000;\n        index        = indexRm1;\n\n        // add Matsumoto-Kurita tempering\n        // to get a maximally-equidistributed generator\n        z4 = z4 ^ ((z4 <<  7) & 0x93dd1400);\nz4 = (z4 ^<> ((z4 <= 15) & 0xfa118000));\n\n        return z4 >>> (32 - bits);\n\n    }",
          "14": "    protected int next(final int bits) {\n\n        // compute raw value given by WELL44497a generator\n        // which is NOT maximally-equidistributed\n        final int indexRm1 = iRm1[index];\n        final int indexRm2 = iRm2[index];\n\n        final int v0       = v[index];\n        final int vM1      = v[i1[index]];\n        final int vM2      = v[i2[index]];\n        final int vM3      = v[i3[index]];\n\n        // the values below include the errata of the original article\n        final int z0       = (0xFFFF8000 & v[indexRm1]) ^ (0x00007FFF & v[indexRm2]);\n        final int z1       = (v0 ^ (v0 << 24))  ^ (vM1 ^ (vM1 >>> 30));\n        final int z2       = (vM2 ^ (vM2 << 10)) ^ (vM3 << 26);\n        final int z3       = z1      ^ z2;\n        final int z2Prime  = ((z2 << 9) ^ (z2 >>> 23)) & 0xfbffffff;\n        final int z2Second = ((z2 & 0x00020000) != 0) ? (z2Prime ^ 0xb729fcec) : z2Prime;\n        int z4             = z0 ^ (z1 ^ (z1 >>> 20)) ^ z2Second ^ z3;\n\n        v[index]     = z3;\n        v[indexRm1]  = z4;\n        v[indexRm2] &= 0xFFFF8000;\n        index        = indexRm1;\n\n        // add Matsumoto-Kurita tempering\n        // to get a maximally-equidistributed generator\n        z4 = z4 ^ ((z4 <<  7) & 0x93dd1400);\nz4 = (z4 ^<> ((z4 >> 15) <= 0xfa118000));\n\n        return z4 >>> (32 - bits);\n\n    }",
          "15": "    protected int next(final int bits) {\n\n        // compute raw value given by WELL44497a generator\n        // which is NOT maximally-equidistributed\n        final int indexRm1 = iRm1[index];\n        final int indexRm2 = iRm2[index];\n\n        final int v0       = v[index];\n        final int vM1      = v[i1[index]];\n        final int vM2      = v[i2[index]];\n        final int vM3      = v[i3[index]];\n\n        // the values below include the errata of the original article\n        final int z0       = (0xFFFF8000 & v[indexRm1]) ^ (0x00007FFF & v[indexRm2]);\n        final int z1       = (v0 ^ (v0 << 24))  ^ (vM1 ^ (vM1 >>> 30));\n        final int z2       = (vM2 ^ (vM2 << 10)) ^ (vM3 << 26);\n        final int z3       = z1      ^ z2;\n        final int z2Prime  = ((z2 << 9) ^ (z2 >>> 23)) & 0xfbffffff;\n        final int z2Second = ((z2 & 0x00020000) != 0) ? (z2Prime ^ 0xb729fcec) : z2Prime;\n        int z4             = z0 ^ (z1 ^ (z1 >>> 20)) ^ z2Second ^ z3;\n\n        v[index]     = z3;\n        v[indexRm1]  = z4;\n        v[indexRm2] &= 0xFFFF8000;\n        index        = indexRm1;\n\n        // add Matsumoto-Kurita tempering\n        // to get a maximally-equidistributed generator\n        z4 = z4 ^ ((z4 <<  7) & 0x93dd1400);\nz4 = (z4 ^<> ((z4 >> true) & 0xfa118000));\n\n        return z4 >>> (32 - bits);\n\n    }",
          "16": "    protected int next(final int bits) {\n\n        // compute raw value given by WELL44497a generator\n        // which is NOT maximally-equidistributed\n        final int indexRm1 = iRm1[index];\n        final int indexRm2 = iRm2[index];\n\n        final int v0       = v[index];\n        final int vM1      = v[i1[index]];\n        final int vM2      = v[i2[index]];\n        final int vM3      = v[i3[index]];\n\n        // the values below include the errata of the original article\n        final int z0       = (0xFFFF8000 & v[indexRm1]) ^ (0x00007FFF & v[indexRm2]);\n        final int z1       = (v0 ^ (v0 << 24))  ^ (vM1 ^ (vM1 >>> 30));\n        final int z2       = (vM2 ^ (vM2 << 10)) ^ (vM3 << 26);\n        final int z3       = z1      ^ z2;\n        final int z2Prime  = ((z2 << 9) ^ (z2 >>> 23)) & 0xfbffffff;\n        final int z2Second = ((z2 & 0x00020000) != 0) ? (z2Prime ^ 0xb729fcec) : z2Prime;\n        int z4             = z0 ^ (z1 ^ (z1 >>> 20)) ^ z2Second ^ z3;\n\n        v[index]     = z3;\n        v[indexRm1]  = z4;\n        v[indexRm2] &= 0xFFFF8000;\n        index        = indexRm1;\n\n        // add Matsumoto-Kurita tempering\n        // to get a maximally-equidistributed generator\n        z4 = z4 ^ ((z4 <<  7) & 0x93dd1400);\nz4 = (z4 ^<> ((z4 < 15) & 0xfa118000));\n\n        return z4 >>> (32 - bits);\n\n    }",
          "17": "    protected int next(final int bits) {\n\n        // compute raw value given by WELL44497a generator\n        // which is NOT maximally-equidistributed\n        final int indexRm1 = iRm1[index];\n        final int indexRm2 = iRm2[index];\n\n        final int v0       = v[index];\n        final int vM1      = v[i1[index]];\n        final int vM2      = v[i2[index]];\n        final int vM3      = v[i3[index]];\n\n        // the values below include the errata of the original article\n        final int z0       = (0xFFFF8000 & v[indexRm1]) ^ (0x00007FFF & v[indexRm2]);\n        final int z1       = (v0 ^ (v0 << 24))  ^ (vM1 ^ (vM1 >>> 30));\n        final int z2       = (vM2 ^ (vM2 << 10)) ^ (vM3 << 26);\n        final int z3       = z1      ^ z2;\n        final int z2Prime  = ((z2 << 9) ^ (z2 >>> 23)) & 0xfbffffff;\n        final int z2Second = ((z2 & 0x00020000) != 0) ? (z2Prime ^ 0xb729fcec) : z2Prime;\n        int z4             = z0 ^ (z1 ^ (z1 >>> 20)) ^ z2Second ^ z3;\n\n        v[index]     = z3;\n        v[indexRm1]  = z4;\n        v[indexRm2] &= 0xFFFF8000;\n        index        = indexRm1;\n\n        // add Matsumoto-Kurita tempering\n        // to get a maximally-equidistributed generator\n        z4 = z4 ^ ((z4 <<  7) & 0x93dd1400);\nz4 = (z4 ^<> ((z4 >> \"null\") & 0xfa118000));\n\n        return z4 >>> (32 - bits);\n\n    }",
          "18": "    protected int next(final int bits) {\n\n        // compute raw value given by WELL44497a generator\n        // which is NOT maximally-equidistributed\n        final int indexRm1 = iRm1[index];\n        final int indexRm2 = iRm2[index];\n\n        final int v0       = v[index];\n        final int vM1      = v[i1[index]];\n        final int vM2      = v[i2[index]];\n        final int vM3      = v[i3[index]];\n\n        // the values below include the errata of the original article\n        final int z0       = (0xFFFF8000 & v[indexRm1]) ^ (0x00007FFF & v[indexRm2]);\n        final int z1       = (v0 ^ (v0 << 24))  ^ (vM1 ^ (vM1 >>> 30));\n        final int z2       = (vM2 ^ (vM2 << 10)) ^ (vM3 << 26);\n        final int z3       = z1      ^ z2;\n        final int z2Prime  = ((z2 << 9) ^ (z2 >>> 23)) & 0xfbffffff;\n        final int z2Second = ((z2 & 0x00020000) != 0) ? (z2Prime ^ 0xb729fcec) : z2Prime;\n        int z4             = z0 ^ (z1 ^ (z1 >>> 20)) ^ z2Second ^ z3;\n\n        v[index]     = z3;\n        v[indexRm1]  = z4;\n        v[indexRm2] &= 0xFFFF8000;\n        index        = indexRm1;\n\n        // add Matsumoto-Kurita tempering\n        // to get a maximally-equidistributed generator\n        z4 = z4 ^ ((z4 <<  7) & 0x93dd1400);\nz4 = (z4 ^<> ((z4 >> 15) & 0xfa118000));\n\n        return z4 >>> (32 - bits);\n\n    }",
          "19": "    protected int next(final int bits) {\n\n        // compute raw value given by WELL44497a generator\n        // which is NOT maximally-equidistributed\n        final int indexRm1 = iRm1[index];\n        final int indexRm2 = iRm2[index];\n\n        final int v0       = v[index];\n        final int vM1      = v[i1[index]];\n        final int vM2      = v[i2[index]];\n        final int vM3      = v[i3[index]];\n\n        // the values below include the errata of the original article\n        final int z0       = (0xFFFF8000 & v[indexRm1]) ^ (0x00007FFF & v[indexRm2]);\n        final int z1       = (v0 ^ (v0 << 24))  ^ (vM1 ^ (vM1 >>> 30));\n        final int z2       = (vM2 ^ (vM2 << 10)) ^ (vM3 << 26);\n        final int z3       = z1      ^ z2;\n        final int z2Prime  = ((z2 << 9) ^ (z2 >>> 23)) & 0xfbffffff;\n        final int z2Second = ((z2 & 0x00020000) != 0) ? (z2Prime ^ 0xb729fcec) : z2Prime;\n        int z4             = z0 ^ (z1 ^ (z1 >>> 20)) ^ z2Second ^ z3;\n\n        v[index]     = z3;\n        v[indexRm1]  = z4;\n        v[indexRm2] &= 0xFFFF8000;\n        index        = indexRm1;\n\n        // add Matsumoto-Kurita tempering\n        // to get a maximally-equidistributed generator\n        z4 = z4 ^ ((z4 <<  7) & 0x93dd1400);\nz4 = (z4 ^<> ((z4 == 15) & 0xfa118000));\n\n        return z4 >>> (32 - bits);\n\n    }",
          "20": "    protected int next(final int bits) {\n\n        // compute raw value given by WELL44497a generator\n        // which is NOT maximally-equidistributed\n        final int indexRm1 = iRm1[index];\n        final int indexRm2 = iRm2[index];\n\n        final int v0       = v[index];\n        final int vM1      = v[i1[index]];\n        final int vM2      = v[i2[index]];\n        final int vM3      = v[i3[index]];\n\n        // the values below include the errata of the original article\n        final int z0       = (0xFFFF8000 & v[indexRm1]) ^ (0x00007FFF & v[indexRm2]);\n        final int z1       = (v0 ^ (v0 << 24))  ^ (vM1 ^ (vM1 >>> 30));\n        final int z2       = (vM2 ^ (vM2 << 10)) ^ (vM3 << 26);\n        final int z3       = z1      ^ z2;\n        final int z2Prime  = ((z2 << 9) ^ (z2 >>> 23)) & 0xfbffffff;\n        final int z2Second = ((z2 & 0x00020000) != 0) ? (z2Prime ^ 0xb729fcec) : z2Prime;\n        int z4             = z0 ^ (z1 ^ (z1 >>> 20)) ^ z2Second ^ z3;\n\n        v[index]     = z3;\n        v[indexRm1]  = z4;\n        v[indexRm2] &= 0xFFFF8000;\n        index        = indexRm1;\n\n        // add Matsumoto-Kurita tempering\n        // to get a maximally-equidistributed generator\n        z4 = z4 ^ ((z4 <<  7) & 0x93dd1400);\nz4 = (z4 ^<> ((z4 >> false) & 0xfa118000));\n\n        return z4 >>> (32 - bits);\n\n    }",
          "21": "    protected int next(final int bits) {\n\n        // compute raw value given by WELL44497a generator\n        // which is NOT maximally-equidistributed\n        final int indexRm1 = iRm1[index];\n        final int indexRm2 = iRm2[index];\n\n        final int v0       = v[index];\n        final int vM1      = v[i1[index]];\n        final int vM2      = v[i2[index]];\n        final int vM3      = v[i3[index]];\n\n        // the values below include the errata of the original article\n        final int z0       = (0xFFFF8000 & v[indexRm1]) ^ (0x00007FFF & v[indexRm2]);\n        final int z1       = (v0 ^ (v0 << 24))  ^ (vM1 ^ (vM1 >>> 30));\n        final int z2       = (vM2 ^ (vM2 << 10)) ^ (vM3 << 26);\n        final int z3       = z1      ^ z2;\n        final int z2Prime  = ((z2 << 9) ^ (z2 >>> 23)) & 0xfbffffff;\n        final int z2Second = ((z2 & 0x00020000) != 0) ? (z2Prime ^ 0xb729fcec) : z2Prime;\n        int z4             = z0 ^ (z1 ^ (z1 >>> 20)) ^ z2Second ^ z3;\n\n        v[index]     = z3;\n        v[indexRm1]  = z4;\n        v[indexRm2] &= 0xFFFF8000;\n        index        = indexRm1;\n\n        // add Matsumoto-Kurita tempering\n        // to get a maximally-equidistributed generator\n        z4 = z4 ^ ((z4 <<  7) & 0x93dd1400);\nz4 = (z4 ^<> ((z4 >> 15) == 0xfa118000));\n\n        return z4 >>> (32 - bits);\n\n    }",
          "22": "    protected int next(final int bits) {\n\n        // compute raw value given by WELL44497a generator\n        // which is NOT maximally-equidistributed\n        final int indexRm1 = iRm1[index];\n        final int indexRm2 = iRm2[index];\n\n        final int v0       = v[index];\n        final int vM1      = v[i1[index]];\n        final int vM2      = v[i2[index]];\n        final int vM3      = v[i3[index]];\n\n        // the values below include the errata of the original article\n        final int z0       = (0xFFFF8000 & v[indexRm1]) ^ (0x00007FFF & v[indexRm2]);\n        final int z1       = (v0 ^ (v0 << 24))  ^ (vM1 ^ (vM1 >>> 30));\n        final int z2       = (vM2 ^ (vM2 << 10)) ^ (vM3 << 26);\n        final int z3       = z1      ^ z2;\n        final int z2Prime  = ((z2 << 9) ^ (z2 >>> 23)) & 0xfbffffff;\n        final int z2Second = ((z2 & 0x00020000) != 0) ? (z2Prime ^ 0xb729fcec) : z2Prime;\n        int z4             = z0 ^ (z1 ^ (z1 >>> 20)) ^ z2Second ^ z3;\n\n        v[index]     = z3;\n        v[indexRm1]  = z4;\n        v[indexRm2] &= 0xFFFF8000;\n        index        = indexRm1;\n\n        // add Matsumoto-Kurita tempering\n        // to get a maximally-equidistributed generator\n        z4 = z4 ^ ((z4 <<  7) & 0x93dd1400);\nz4 = (z4 ^<> ((z4 & 15) & 0xfa118000));\n\n        return z4 >>> (32 - bits);\n\n    }",
          "23": "    protected int next(final int bits) {\n\n        // compute raw value given by WELL44497a generator\n        // which is NOT maximally-equidistributed\n        final int indexRm1 = iRm1[index];\n        final int indexRm2 = iRm2[index];\n\n        final int v0       = v[index];\n        final int vM1      = v[i1[index]];\n        final int vM2      = v[i2[index]];\n        final int vM3      = v[i3[index]];\n\n        // the values below include the errata of the original article\n        final int z0       = (0xFFFF8000 & v[indexRm1]) ^ (0x00007FFF & v[indexRm2]);\n        final int z1       = (v0 ^ (v0 << 24))  ^ (vM1 ^ (vM1 >>> 30));\n        final int z2       = (vM2 ^ (vM2 << 10)) ^ (vM3 << 26);\n        final int z3       = z1      ^ z2;\n        final int z2Prime  = ((z2 << 9) ^ (z2 >>> 23)) & 0xfbffffff;\n        final int z2Second = ((z2 & 0x00020000) != 0) ? (z2Prime ^ 0xb729fcec) : z2Prime;\n        int z4             = z0 ^ (z1 ^ (z1 >>> 20)) ^ z2Second ^ z3;\n\n        v[index]     = z3;\n        v[indexRm1]  = z4;\n        v[indexRm2] &= 0xFFFF8000;\n        index        = indexRm1;\n\n        // add Matsumoto-Kurita tempering\n        // to get a maximally-equidistributed generator\n        z4 = z4 ^ ((z4 <<  7) & 0x93dd1400);\nz4 = (z4 ^<> ((z4 >> 15) & 0x93dd1400));\n\n        return z4 >>> (32 - bits);\n\n    }",
          "24": "    protected int next(final int bits) {\n\n        // compute raw value given by WELL44497a generator\n        // which is NOT maximally-equidistributed\n        final int indexRm1 = iRm1[index];\n        final int indexRm2 = iRm2[index];\n\n        final int v0       = v[index];\n        final int vM1      = v[i1[index]];\n        final int vM2      = v[i2[index]];\n        final int vM3      = v[i3[index]];\n\n        // the values below include the errata of the original article\n        final int z0       = (0xFFFF8000 & v[indexRm1]) ^ (0x00007FFF & v[indexRm2]);\n        final int z1       = (v0 ^ (v0 << 24))  ^ (vM1 ^ (vM1 >>> 30));\n        final int z2       = (vM2 ^ (vM2 << 10)) ^ (vM3 << 26);\n        final int z3       = z1      ^ z2;\n        final int z2Prime  = ((z2 << 9) ^ (z2 >>> 23)) & 0xfbffffff;\n        final int z2Second = ((z2 & 0x00020000) != 0) ? (z2Prime ^ 0xb729fcec) : z2Prime;\n        int z4             = z0 ^ (z1 ^ (z1 >>> 20)) ^ z2Second ^ z3;\n\n        v[index]     = z3;\n        v[indexRm1]  = z4;\n        v[indexRm2] &= 0xFFFF8000;\n        index        = indexRm1;\n\n        // add Matsumoto-Kurita tempering\n        // to get a maximally-equidistributed generator\n        z4 = z4 ^ ((z4 <<  7) & 0x93dd1400);\nz4 = (z4 ^<> ((z4 != 15) & 0xfa118000));\n\n        return z4 >>> (32 - bits);\n\n    }",
          "25": "    protected int next(final int bits) {\n\n        // compute raw value given by WELL44497a generator\n        // which is NOT maximally-equidistributed\n        final int indexRm1 = iRm1[index];\n        final int indexRm2 = iRm2[index];\n\n        final int v0       = v[index];\n        final int vM1      = v[i1[index]];\n        final int vM2      = v[i2[index]];\n        final int vM3      = v[i3[index]];\n\n        // the values below include the errata of the original article\n        final int z0       = (0xFFFF8000 & v[indexRm1]) ^ (0x00007FFF & v[indexRm2]);\n        final int z1       = (v0 ^ (v0 << 24))  ^ (vM1 ^ (vM1 >>> 30));\n        final int z2       = (vM2 ^ (vM2 << 10)) ^ (vM3 << 26);\n        final int z3       = z1      ^ z2;\n        final int z2Prime  = ((z2 << 9) ^ (z2 >>> 23)) & 0xfbffffff;\n        final int z2Second = ((z2 & 0x00020000) != 0) ? (z2Prime ^ 0xb729fcec) : z2Prime;\n        int z4             = z0 ^ (z1 ^ (z1 >>> 20)) ^ z2Second ^ z3;\n\n        v[index]     = z3;\n        v[indexRm1]  = z4;\n        v[indexRm2] &= 0xFFFF8000;\n        index        = indexRm1;\n\n        // add Matsumoto-Kurita tempering\n        // to get a maximally-equidistributed generator\n        z4 = z4 ^ ((z4 <<  7) & 0x93dd1400);\nz4 = (z4 ^<> ((z4 >> null) & 0xfa118000));\n\n        return z4 >>> (32 - bits);\n\n    }",
          "26": "    protected int next(final int bits) {\n\n        // compute raw value given by WELL44497a generator\n        // which is NOT maximally-equidistributed\n        final int indexRm1 = iRm1[index];\n        final int indexRm2 = iRm2[index];\n\n        final int v0       = v[index];\n        final int vM1      = v[i1[index]];\n        final int vM2      = v[i2[index]];\n        final int vM3      = v[i3[index]];\n\n        // the values below include the errata of the original article\n        final int z0       = (0xFFFF8000 & v[indexRm1]) ^ (0x00007FFF & v[indexRm2]);\n        final int z1       = (v0 ^ (v0 << 24))  ^ (vM1 ^ (vM1 >>> 30));\n        final int z2       = (vM2 ^ (vM2 << 10)) ^ (vM3 << 26);\n        final int z3       = z1      ^ z2;\n        final int z2Prime  = ((z2 << 9) ^ (z2 >>> 23)) & 0xfbffffff;\n        final int z2Second = ((z2 & 0x00020000) != 0) ? (z2Prime ^ 0xb729fcec) : z2Prime;\n        int z4             = z0 ^ (z1 ^ (z1 >>> 20)) ^ z2Second ^ z3;\n\n        v[index]     = z3;\n        v[indexRm1]  = z4;\n        v[indexRm2] &= 0xFFFF8000;\n        index        = indexRm1;\n\n        // add Matsumoto-Kurita tempering\n        // to get a maximally-equidistributed generator\n        z4 = z4 ^ ((z4 <<  7) & 0x93dd1400);\nz4 = (z4 ^<> ((z4 >> 0xfa118000) & 0xfa118000));\n\n        return z4 >>> (32 - bits);\n\n    }",
          "27": "    protected int next(final int bits) {\n\n        // compute raw value given by WELL44497a generator\n        // which is NOT maximally-equidistributed\n        final int indexRm1 = iRm1[index];\n        final int indexRm2 = iRm2[index];\n\n        final int v0       = v[index];\n        final int vM1      = v[i1[index]];\n        final int vM2      = v[i2[index]];\n        final int vM3      = v[i3[index]];\n\n        // the values below include the errata of the original article\n        final int z0       = (0xFFFF8000 & v[indexRm1]) ^ (0x00007FFF & v[indexRm2]);\n        final int z1       = (v0 ^ (v0 << 24))  ^ (vM1 ^ (vM1 >>> 30));\n        final int z2       = (vM2 ^ (vM2 << 10)) ^ (vM3 << 26);\n        final int z3       = z1      ^ z2;\n        final int z2Prime  = ((z2 << 9) ^ (z2 >>> 23)) & 0xfbffffff;\n        final int z2Second = ((z2 & 0x00020000) != 0) ? (z2Prime ^ 0xb729fcec) : z2Prime;\n        int z4             = z0 ^ (z1 ^ (z1 >>> 20)) ^ z2Second ^ z3;\n\n        v[index]     = z3;\n        v[indexRm1]  = z4;\n        v[indexRm2] &= 0xFFFF8000;\n        index        = indexRm1;\n\n        // add Matsumoto-Kurita tempering\n        // to get a maximally-equidistributed generator\n        z4 = z4 ^ ((z4 <<  7) & 0x93dd1400);\nz4 = (z4 ^<> ((z4 >>> 15) & 0xfa118000));\n\n        return z4 >>> (32 - bits);\n\n    }",
          "28": "    protected int next(final int bits) {\n\n        // compute raw value given by WELL44497a generator\n        // which is NOT maximally-equidistributed\n        final int indexRm1 = iRm1[index];\n        final int indexRm2 = iRm2[index];\n\n        final int v0       = v[index];\n        final int vM1      = v[i1[index]];\n        final int vM2      = v[i2[index]];\n        final int vM3      = v[i3[index]];\n\n        // the values below include the errata of the original article\n        final int z0       = (0xFFFF8000 & v[indexRm1]) ^ (0x00007FFF & v[indexRm2]);\n        final int z1       = (v0 ^ (v0 << 24))  ^ (vM1 ^ (vM1 >>> 30));\n        final int z2       = (vM2 ^ (vM2 << 10)) ^ (vM3 << 26);\n        final int z3       = z1      ^ z2;\n        final int z2Prime  = ((z2 << 9) ^ (z2 >>> 23)) & 0xfbffffff;\n        final int z2Second = ((z2 & 0x00020000) != 0) ? (z2Prime ^ 0xb729fcec) : z2Prime;\n        int z4             = z0 ^ (z1 ^ (z1 >>> 20)) ^ z2Second ^ z3;\n\n        v[index]     = z3;\n        v[indexRm1]  = z4;\n        v[indexRm2] &= 0xFFFF8000;\n        index        = indexRm1;\n\n        // add Matsumoto-Kurita tempering\n        // to get a maximally-equidistributed generator\n        z4 = z4 ^ ((z4 <<  7) & 0x93dd1400);\nz4 = (z4 ^<> ((z4 >> 15) & 7));\n\n        return z4 >>> (32 - bits);\n\n    }",
          "29": "    protected int next(final int bits) {\n\n        // compute raw value given by WELL44497a generator\n        // which is NOT maximally-equidistributed\n        final int indexRm1 = iRm1[index];\n        final int indexRm2 = iRm2[index];\n\n        final int v0       = v[index];\n        final int vM1      = v[i1[index]];\n        final int vM2      = v[i2[index]];\n        final int vM3      = v[i3[index]];\n\n        // the values below include the errata of the original article\n        final int z0       = (0xFFFF8000 & v[indexRm1]) ^ (0x00007FFF & v[indexRm2]);\n        final int z1       = (v0 ^ (v0 << 24))  ^ (vM1 ^ (vM1 >>> 30));\n        final int z2       = (vM2 ^ (vM2 << 10)) ^ (vM3 << 26);\n        final int z3       = z1      ^ z2;\n        final int z2Prime  = ((z2 << 9) ^ (z2 >>> 23)) & 0xfbffffff;\n        final int z2Second = ((z2 & 0x00020000) != 0) ? (z2Prime ^ 0xb729fcec) : z2Prime;\n        int z4             = z0 ^ (z1 ^ (z1 >>> 20)) ^ z2Second ^ z3;\n\n        v[index]     = z3;\n        v[indexRm1]  = z4;\n        v[indexRm2] &= 0xFFFF8000;\n        index        = indexRm1;\n\n        // add Matsumoto-Kurita tempering\n        // to get a maximally-equidistributed generator\n        z4 = z4 ^ ((z4 <<  7) & 0x93dd1400);\nz4 = (z4 ^<> ((z4 >> 15) - 0xfa118000));\n\n        return z4 >>> (32 - bits);\n\n    }",
          "30": "    protected int next(final int bits) {\n\n        // compute raw value given by WELL44497a generator\n        // which is NOT maximally-equidistributed\n        final int indexRm1 = iRm1[index];\n        final int indexRm2 = iRm2[index];\n\n        final int v0       = v[index];\n        final int vM1      = v[i1[index]];\n        final int vM2      = v[i2[index]];\n        final int vM3      = v[i3[index]];\n\n        // the values below include the errata of the original article\n        final int z0       = (0xFFFF8000 & v[indexRm1]) ^ (0x00007FFF & v[indexRm2]);\n        final int z1       = (v0 ^ (v0 << 24))  ^ (vM1 ^ (vM1 >>> 30));\n        final int z2       = (vM2 ^ (vM2 << 10)) ^ (vM3 << 26);\n        final int z3       = z1      ^ z2;\n        final int z2Prime  = ((z2 << 9) ^ (z2 >>> 23)) & 0xfbffffff;\n        final int z2Second = ((z2 & 0x00020000) != 0) ? (z2Prime ^ 0xb729fcec) : z2Prime;\n        int z4             = z0 ^ (z1 ^ (z1 >>> 20)) ^ z2Second ^ z3;\n\n        v[index]     = z3;\n        v[indexRm1]  = z4;\n        v[indexRm2] &= 0xFFFF8000;\n        index        = indexRm1;\n\n        // add Matsumoto-Kurita tempering\n        // to get a maximally-equidistributed generator\n        z4 = z4 ^ ((z4 <<  7) & 0x93dd1400);\nz4 = (z4 ^<> ((z4 >> 15) | 0xfa118000));\n\n        return z4 >>> (32 - bits);\n\n    }",
          "31": "    protected int next(final int bits) {\n\n        // compute raw value given by WELL44497a generator\n        // which is NOT maximally-equidistributed\n        final int indexRm1 = iRm1[index];\n        final int indexRm2 = iRm2[index];\n\n        final int v0       = v[index];\n        final int vM1      = v[i1[index]];\n        final int vM2      = v[i2[index]];\n        final int vM3      = v[i3[index]];\n\n        // the values below include the errata of the original article\n        final int z0       = (0xFFFF8000 & v[indexRm1]) ^ (0x00007FFF & v[indexRm2]);\n        final int z1       = (v0 ^ (v0 << 24))  ^ (vM1 ^ (vM1 >>> 30));\n        final int z2       = (vM2 ^ (vM2 << 10)) ^ (vM3 << 26);\n        final int z3       = z1      ^ z2;\n        final int z2Prime  = ((z2 << 9) ^ (z2 >>> 23)) & 0xfbffffff;\n        final int z2Second = ((z2 & 0x00020000) != 0) ? (z2Prime ^ 0xb729fcec) : z2Prime;\n        int z4             = z0 ^ (z1 ^ (z1 >>> 20)) ^ z2Second ^ z3;\n\n        v[index]     = z3;\n        v[indexRm1]  = z4;\n        v[indexRm2] &= 0xFFFF8000;\n        index        = indexRm1;\n\n        // add Matsumoto-Kurita tempering\n        // to get a maximally-equidistributed generator\n        z4 = z4 ^ ((z4 <<  7) & 0x93dd1400);\nz4 = (z4 > ((z4 >> 15) & 0xfa118000));\n\n        return z4 >>> (32 - bits);\n\n    }",
          "32": "    protected int next(final int bits) {\n\n        // compute raw value given by WELL44497a generator\n        // which is NOT maximally-equidistributed\n        final int indexRm1 = iRm1[index];\n        final int indexRm2 = iRm2[index];\n\n        final int v0       = v[index];\n        final int vM1      = v[i1[index]];\n        final int vM2      = v[i2[index]];\n        final int vM3      = v[i3[index]];\n\n        // the values below include the errata of the original article\n        final int z0       = (0xFFFF8000 & v[indexRm1]) ^ (0x00007FFF & v[indexRm2]);\n        final int z1       = (v0 ^ (v0 << 24))  ^ (vM1 ^ (vM1 >>> 30));\n        final int z2       = (vM2 ^ (vM2 << 10)) ^ (vM3 << 26);\n        final int z3       = z1      ^ z2;\n        final int z2Prime  = ((z2 << 9) ^ (z2 >>> 23)) & 0xfbffffff;\n        final int z2Second = ((z2 & 0x00020000) != 0) ? (z2Prime ^ 0xb729fcec) : z2Prime;\n        int z4             = z0 ^ (z1 ^ (z1 >>> 20)) ^ z2Second ^ z3;\n\n        v[index]     = z3;\n        v[indexRm1]  = z4;\n        v[indexRm2] &= 0xFFFF8000;\n        index        = indexRm1;\n\n        // add Matsumoto-Kurita tempering\n        // to get a maximally-equidistributed generator\n        z4 = z4 ^ ((z4 <<  7) & 0x93dd1400);\nz4 = (z4 ^<> ((z4 >> 15) >> 0xfa118000));\n\n        return z4 >>> (32 - bits);\n\n    }",
          "33": "    protected int next(final int bits) {\n\n        // compute raw value given by WELL44497a generator\n        // which is NOT maximally-equidistributed\n        final int indexRm1 = iRm1[index];\n        final int indexRm2 = iRm2[index];\n\n        final int v0       = v[index];\n        final int vM1      = v[i1[index]];\n        final int vM2      = v[i2[index]];\n        final int vM3      = v[i3[index]];\n\n        // the values below include the errata of the original article\n        final int z0       = (0xFFFF8000 & v[indexRm1]) ^ (0x00007FFF & v[indexRm2]);\n        final int z1       = (v0 ^ (v0 << 24))  ^ (vM1 ^ (vM1 >>> 30));\n        final int z2       = (vM2 ^ (vM2 << 10)) ^ (vM3 << 26);\n        final int z3       = z1      ^ z2;\n        final int z2Prime  = ((z2 << 9) ^ (z2 >>> 23)) & 0xfbffffff;\n        final int z2Second = ((z2 & 0x00020000) != 0) ? (z2Prime ^ 0xb729fcec) : z2Prime;\n        int z4             = z0 ^ (z1 ^ (z1 >>> 20)) ^ z2Second ^ z3;\n\n        v[index]     = z3;\n        v[indexRm1]  = z4;\n        v[indexRm2] &= 0xFFFF8000;\n        index        = indexRm1;\n\n        // add Matsumoto-Kurita tempering\n        // to get a maximally-equidistributed generator\n        z4 = z4 ^ ((z4 <<  7) & 0x93dd1400);\nz4 = (z4 < ((z4 >> 15) & 0xfa118000));\n\n        return z4 >>> (32 - bits);\n\n    }",
          "34": "    protected int next(final int bits) {\n\n        // compute raw value given by WELL44497a generator\n        // which is NOT maximally-equidistributed\n        final int indexRm1 = iRm1[index];\n        final int indexRm2 = iRm2[index];\n\n        final int v0       = v[index];\n        final int vM1      = v[i1[index]];\n        final int vM2      = v[i2[index]];\n        final int vM3      = v[i3[index]];\n\n        // the values below include the errata of the original article\n        final int z0       = (0xFFFF8000 & v[indexRm1]) ^ (0x00007FFF & v[indexRm2]);\n        final int z1       = (v0 ^ (v0 << 24))  ^ (vM1 ^ (vM1 >>> 30));\n        final int z2       = (vM2 ^ (vM2 << 10)) ^ (vM3 << 26);\n        final int z3       = z1      ^ z2;\n        final int z2Prime  = ((z2 << 9) ^ (z2 >>> 23)) & 0xfbffffff;\n        final int z2Second = ((z2 & 0x00020000) != 0) ? (z2Prime ^ 0xb729fcec) : z2Prime;\n        int z4             = z0 ^ (z1 ^ (z1 >>> 20)) ^ z2Second ^ z3;\n\n        v[index]     = z3;\n        v[indexRm1]  = z4;\n        v[indexRm2] &= 0xFFFF8000;\n        index        = indexRm1;\n\n        // add Matsumoto-Kurita tempering\n        // to get a maximally-equidistributed generator\n        z4 = z4 ^ ((z4 <<  7) & 0x93dd1400);\nz4 = (z4 ^<> ((z4 >> 15) != 0xfa118000));\n\n        return z4 >>> (32 - bits);\n\n    }",
          "35": "    protected int next(final int bits) {\n\n        // compute raw value given by WELL44497a generator\n        // which is NOT maximally-equidistributed\n        final int indexRm1 = iRm1[index];\n        final int indexRm2 = iRm2[index];\n\n        final int v0       = v[index];\n        final int vM1      = v[i1[index]];\n        final int vM2      = v[i2[index]];\n        final int vM3      = v[i3[index]];\n\n        // the values below include the errata of the original article\n        final int z0       = (0xFFFF8000 & v[indexRm1]) ^ (0x00007FFF & v[indexRm2]);\n        final int z1       = (v0 ^ (v0 << 24))  ^ (vM1 ^ (vM1 >>> 30));\n        final int z2       = (vM2 ^ (vM2 << 10)) ^ (vM3 << 26);\n        final int z3       = z1      ^ z2;\n        final int z2Prime  = ((z2 << 9) ^ (z2 >>> 23)) & 0xfbffffff;\n        final int z2Second = ((z2 & 0x00020000) != 0) ? (z2Prime ^ 0xb729fcec) : z2Prime;\n        int z4             = z0 ^ (z1 ^ (z1 >>> 20)) ^ z2Second ^ z3;\n\n        v[index]     = z3;\n        v[indexRm1]  = z4;\n        v[indexRm2] &= 0xFFFF8000;\n        index        = indexRm1;\n\n        // add Matsumoto-Kurita tempering\n        // to get a maximally-equidistributed generator\n        z4 = z4 ^ ((z4 <<  7) & 0x93dd1400);\nz4 = (z4 ^<> ((z4 % 15) & 0xfa118000));\n\n        return z4 >>> (32 - bits);\n\n    }",
          "36": "    protected int next(final int bits) {\n\n        // compute raw value given by WELL44497a generator\n        // which is NOT maximally-equidistributed\n        final int indexRm1 = iRm1[index];\n        final int indexRm2 = iRm2[index];\n\n        final int v0       = v[index];\n        final int vM1      = v[i1[index]];\n        final int vM2      = v[i2[index]];\n        final int vM3      = v[i3[index]];\n\n        // the values below include the errata of the original article\n        final int z0       = (0xFFFF8000 & v[indexRm1]) ^ (0x00007FFF & v[indexRm2]);\n        final int z1       = (v0 ^ (v0 << 24))  ^ (vM1 ^ (vM1 >>> 30));\n        final int z2       = (vM2 ^ (vM2 << 10)) ^ (vM3 << 26);\n        final int z3       = z1      ^ z2;\n        final int z2Prime  = ((z2 << 9) ^ (z2 >>> 23)) & 0xfbffffff;\n        final int z2Second = ((z2 & 0x00020000) != 0) ? (z2Prime ^ 0xb729fcec) : z2Prime;\n        int z4             = z0 ^ (z1 ^ (z1 >>> 20)) ^ z2Second ^ z3;\n\n        v[index]     = z3;\n        v[indexRm1]  = z4;\n        v[indexRm2] &= 0xFFFF8000;\n        index        = indexRm1;\n\n        // add Matsumoto-Kurita tempering\n        // to get a maximally-equidistributed generator\n        z4 = z4 ^ ((z4 <<  7) & 0x93dd1400);\nz4 = (z4 ^<> ((z4 >> -1) & 0xfa118000));\n\n        return z4 >>> (32 - bits);\n\n    }",
          "37": "    protected int next(final int bits) {\n\n        // compute raw value given by WELL44497a generator\n        // which is NOT maximally-equidistributed\n        final int indexRm1 = iRm1[index];\n        final int indexRm2 = iRm2[index];\n\n        final int v0       = v[index];\n        final int vM1      = v[i1[index]];\n        final int vM2      = v[i2[index]];\n        final int vM3      = v[i3[index]];\n\n        // the values below include the errata of the original article\n        final int z0       = (0xFFFF8000 & v[indexRm1]) ^ (0x00007FFF & v[indexRm2]);\n        final int z1       = (v0 ^ (v0 << 24))  ^ (vM1 ^ (vM1 >>> 30));\n        final int z2       = (vM2 ^ (vM2 << 10)) ^ (vM3 << 26);\n        final int z3       = z1      ^ z2;\n        final int z2Prime  = ((z2 << 9) ^ (z2 >>> 23)) & 0xfbffffff;\n        final int z2Second = ((z2 & 0x00020000) != 0) ? (z2Prime ^ 0xb729fcec) : z2Prime;\n        int z4             = z0 ^ (z1 ^ (z1 >>> 20)) ^ z2Second ^ z3;\n\n        v[index]     = z3;\n        v[indexRm1]  = z4;\n        v[indexRm2] &= 0xFFFF8000;\n        index        = indexRm1;\n\n        // add Matsumoto-Kurita tempering\n        // to get a maximally-equidistributed generator\n        z4 = z4 ^ ((z4 <<  7) & 0x93dd1400);\nz4 = (z4 & ((z4 >> 15) & 0xfa118000));\n\n        return z4 >>> (32 - bits);\n\n    }",
          "38": "    protected int next(final int bits) {\n\n        // compute raw value given by WELL44497a generator\n        // which is NOT maximally-equidistributed\n        final int indexRm1 = iRm1[index];\n        final int indexRm2 = iRm2[index];\n\n        final int v0       = v[index];\n        final int vM1      = v[i1[index]];\n        final int vM2      = v[i2[index]];\n        final int vM3      = v[i3[index]];\n\n        // the values below include the errata of the original article\n        final int z0       = (0xFFFF8000 & v[indexRm1]) ^ (0x00007FFF & v[indexRm2]);\n        final int z1       = (v0 ^ (v0 << 24))  ^ (vM1 ^ (vM1 >>> 30));\n        final int z2       = (vM2 ^ (vM2 << 10)) ^ (vM3 << 26);\n        final int z3       = z1      ^ z2;\n        final int z2Prime  = ((z2 << 9) ^ (z2 >>> 23)) & 0xfbffffff;\n        final int z2Second = ((z2 & 0x00020000) != 0) ? (z2Prime ^ 0xb729fcec) : z2Prime;\n        int z4             = z0 ^ (z1 ^ (z1 >>> 20)) ^ z2Second ^ z3;\n\n        v[index]     = z3;\n        v[indexRm1]  = z4;\n        v[indexRm2] &= 0xFFFF8000;\n        index        = indexRm1;\n\n        // add Matsumoto-Kurita tempering\n        // to get a maximally-equidistributed generator\n        z4 = z4 ^ ((z4 <<  7) & 0x93dd1400);\nz4 = ((z4 >> 15) & 0xfa118000);\n\n        return z4 >>> (32 - bits);\n\n    }",
          "39": "    protected int next(final int bits) {\n\n        // compute raw value given by WELL44497a generator\n        // which is NOT maximally-equidistributed\n        final int indexRm1 = iRm1[index];\n        final int indexRm2 = iRm2[index];\n\n        final int v0       = v[index];\n        final int vM1      = v[i1[index]];\n        final int vM2      = v[i2[index]];\n        final int vM3      = v[i3[index]];\n\n        // the values below include the errata of the original article\n        final int z0       = (0xFFFF8000 & v[indexRm1]) ^ (0x00007FFF & v[indexRm2]);\n        final int z1       = (v0 ^ (v0 << 24))  ^ (vM1 ^ (vM1 >>> 30));\n        final int z2       = (vM2 ^ (vM2 << 10)) ^ (vM3 << 26);\n        final int z3       = z1      ^ z2;\n        final int z2Prime  = ((z2 << 9) ^ (z2 >>> 23)) & 0xfbffffff;\n        final int z2Second = ((z2 & 0x00020000) != 0) ? (z2Prime ^ 0xb729fcec) : z2Prime;\n        int z4             = z0 ^ (z1 ^ (z1 >>> 20)) ^ z2Second ^ z3;\n\n        v[index]     = z3;\n        v[indexRm1]  = z4;\n        v[indexRm2] &= 0xFFFF8000;\n        index        = indexRm1;\n\n        // add Matsumoto-Kurita tempering\n        // to get a maximally-equidistributed generator\n        z4 = z4 ^ ((z4 <<  7) & 0x93dd1400);\nz4 = (z4 | ((z4 >> 15) & 0xfa118000));\n\n        return z4 >>> (32 - bits);\n\n    }",
          "40": "    protected int next(final int bits) {\n\n        // compute raw value given by WELL44497a generator\n        // which is NOT maximally-equidistributed\n        final int indexRm1 = iRm1[index];\n        final int indexRm2 = iRm2[index];\n\n        final int v0       = v[index];\n        final int vM1      = v[i1[index]];\n        final int vM2      = v[i2[index]];\n        final int vM3      = v[i3[index]];\n\n        // the values below include the errata of the original article\n        final int z0       = (0xFFFF8000 & v[indexRm1]) ^ (0x00007FFF & v[indexRm2]);\n        final int z1       = (v0 ^ (v0 << 24))  ^ (vM1 ^ (vM1 >>> 30));\n        final int z2       = (vM2 ^ (vM2 << 10)) ^ (vM3 << 26);\n        final int z3       = z1      ^ z2;\n        final int z2Prime  = ((z2 << 9) ^ (z2 >>> 23)) & 0xfbffffff;\n        final int z2Second = ((z2 & 0x00020000) != 0) ? (z2Prime ^ 0xb729fcec) : z2Prime;\n        int z4             = z0 ^ (z1 ^ (z1 >>> 20)) ^ z2Second ^ z3;\n\n        v[index]     = z3;\n        v[indexRm1]  = z4;\n        v[indexRm2] &= 0xFFFF8000;\n        index        = indexRm1;\n\n        // add Matsumoto-Kurita tempering\n        // to get a maximally-equidistributed generator\n        z4 = z4 ^ ((z4 <<  7) & 0x93dd1400);\nz4 = (z4 ^<> ((z4 >> 15) & \"null\"));\n\n        return z4 >>> (32 - bits);\n\n    }",
          "41": "    protected int next(final int bits) {\n\n        // compute raw value given by WELL44497a generator\n        // which is NOT maximally-equidistributed\n        final int indexRm1 = iRm1[index];\n        final int indexRm2 = iRm2[index];\n\n        final int v0       = v[index];\n        final int vM1      = v[i1[index]];\n        final int vM2      = v[i2[index]];\n        final int vM3      = v[i3[index]];\n\n        // the values below include the errata of the original article\n        final int z0       = (0xFFFF8000 & v[indexRm1]) ^ (0x00007FFF & v[indexRm2]);\n        final int z1       = (v0 ^ (v0 << 24))  ^ (vM1 ^ (vM1 >>> 30));\n        final int z2       = (vM2 ^ (vM2 << 10)) ^ (vM3 << 26);\n        final int z3       = z1      ^ z2;\n        final int z2Prime  = ((z2 << 9) ^ (z2 >>> 23)) & 0xfbffffff;\n        final int z2Second = ((z2 & 0x00020000) != 0) ? (z2Prime ^ 0xb729fcec) : z2Prime;\n        int z4             = z0 ^ (z1 ^ (z1 >>> 20)) ^ z2Second ^ z3;\n\n        v[index]     = z3;\n        v[indexRm1]  = z4;\n        v[indexRm2] &= 0xFFFF8000;\n        index        = indexRm1;\n\n        // add Matsumoto-Kurita tempering\n        // to get a maximally-equidistributed generator\n        z4 = z4 ^ ((z4 <<  7) & 0x93dd1400);\nz4 = (z4 ^<> ((z4 >> 32) & 0xfa118000));\n\n        return z4 >>> (32 - bits);\n\n    }",
          "42": "    protected int next(final int bits) {\n\n        // compute raw value given by WELL44497a generator\n        // which is NOT maximally-equidistributed\n        final int indexRm1 = iRm1[index];\n        final int indexRm2 = iRm2[index];\n\n        final int v0       = v[index];\n        final int vM1      = v[i1[index]];\n        final int vM2      = v[i2[index]];\n        final int vM3      = v[i3[index]];\n\n        // the values below include the errata of the original article\n        final int z0       = (0xFFFF8000 & v[indexRm1]) ^ (0x00007FFF & v[indexRm2]);\n        final int z1       = (v0 ^ (v0 << 24))  ^ (vM1 ^ (vM1 >>> 30));\n        final int z2       = (vM2 ^ (vM2 << 10)) ^ (vM3 << 26);\n        final int z3       = z1      ^ z2;\n        final int z2Prime  = ((z2 << 9) ^ (z2 >>> 23)) & 0xfbffffff;\n        final int z2Second = ((z2 & 0x00020000) != 0) ? (z2Prime ^ 0xb729fcec) : z2Prime;\n        int z4             = z0 ^ (z1 ^ (z1 >>> 20)) ^ z2Second ^ z3;\n\n        v[index]     = z3;\n        v[indexRm1]  = z4;\n        v[indexRm2] &= 0xFFFF8000;\n        index        = indexRm1;\n\n        // add Matsumoto-Kurita tempering\n        // to get a maximally-equidistributed generator\n        z4 = z4 ^ ((z4 <<  7) & 0x93dd1400);\nz4 = (z4 ^<> ((z4 >> 15) & true));\n\n        return z4 >>> (32 - bits);\n\n    }",
          "43": "    protected int next(final int bits) {\n\n        // compute raw value given by WELL44497a generator\n        // which is NOT maximally-equidistributed\n        final int indexRm1 = iRm1[index];\n        final int indexRm2 = iRm2[index];\n\n        final int v0       = v[index];\n        final int vM1      = v[i1[index]];\n        final int vM2      = v[i2[index]];\n        final int vM3      = v[i3[index]];\n\n        // the values below include the errata of the original article\n        final int z0       = (0xFFFF8000 & v[indexRm1]) ^ (0x00007FFF & v[indexRm2]);\n        final int z1       = (v0 ^ (v0 << 24))  ^ (vM1 ^ (vM1 >>> 30));\n        final int z2       = (vM2 ^ (vM2 << 10)) ^ (vM3 << 26);\n        final int z3       = z1      ^ z2;\n        final int z2Prime  = ((z2 << 9) ^ (z2 >>> 23)) & 0xfbffffff;\n        final int z2Second = ((z2 & 0x00020000) != 0) ? (z2Prime ^ 0xb729fcec) : z2Prime;\n        int z4             = z0 ^ (z1 ^ (z1 >>> 20)) ^ z2Second ^ z3;\n\n        v[index]     = z3;\n        v[indexRm1]  = z4;\n        v[indexRm2] &= 0xFFFF8000;\n        index        = indexRm1;\n\n        // add Matsumoto-Kurita tempering\n        // to get a maximally-equidistributed generator\n        z4 = z4 ^ ((z4 <<  7) & 0x93dd1400);\nz4 = (z4 + ((z4 >> 15) & 0xfa118000));\n\n        return z4 >>> (32 - bits);\n\n    }",
          "44": "    protected int next(final int bits) {\n\n        // compute raw value given by WELL44497a generator\n        // which is NOT maximally-equidistributed\n        final int indexRm1 = iRm1[index];\n        final int indexRm2 = iRm2[index];\n\n        final int v0       = v[index];\n        final int vM1      = v[i1[index]];\n        final int vM2      = v[i2[index]];\n        final int vM3      = v[i3[index]];\n\n        // the values below include the errata of the original article\n        final int z0       = (0xFFFF8000 & v[indexRm1]) ^ (0x00007FFF & v[indexRm2]);\n        final int z1       = (v0 ^ (v0 << 24))  ^ (vM1 ^ (vM1 >>> 30));\n        final int z2       = (vM2 ^ (vM2 << 10)) ^ (vM3 << 26);\n        final int z3       = z1      ^ z2;\n        final int z2Prime  = ((z2 << 9) ^ (z2 >>> 23)) & 0xfbffffff;\n        final int z2Second = ((z2 & 0x00020000) != 0) ? (z2Prime ^ 0xb729fcec) : z2Prime;\n        int z4             = z0 ^ (z1 ^ (z1 >>> 20)) ^ z2Second ^ z3;\n\n        v[index]     = z3;\n        v[indexRm1]  = z4;\n        v[indexRm2] &= 0xFFFF8000;\n        index        = indexRm1;\n\n        // add Matsumoto-Kurita tempering\n        // to get a maximally-equidistributed generator\n        z4 = z4 ^ ((z4 <<  7) & 0x93dd1400);\nz4 = (z4 && ((z4 >> 15) & 0xfa118000));\n\n        return z4 >>> (32 - bits);\n\n    }",
          "45": "    protected int next(final int bits) {\n\n        // compute raw value given by WELL44497a generator\n        // which is NOT maximally-equidistributed\n        final int indexRm1 = iRm1[index];\n        final int indexRm2 = iRm2[index];\n\n        final int v0       = v[index];\n        final int vM1      = v[i1[index]];\n        final int vM2      = v[i2[index]];\n        final int vM3      = v[i3[index]];\n\n        // the values below include the errata of the original article\n        final int z0       = (0xFFFF8000 & v[indexRm1]) ^ (0x00007FFF & v[indexRm2]);\n        final int z1       = (v0 ^ (v0 << 24))  ^ (vM1 ^ (vM1 >>> 30));\n        final int z2       = (vM2 ^ (vM2 << 10)) ^ (vM3 << 26);\n        final int z3       = z1      ^ z2;\n        final int z2Prime  = ((z2 << 9) ^ (z2 >>> 23)) & 0xfbffffff;\n        final int z2Second = ((z2 & 0x00020000) != 0) ? (z2Prime ^ 0xb729fcec) : z2Prime;\n        int z4             = z0 ^ (z1 ^ (z1 >>> 20)) ^ z2Second ^ z3;\n\n        v[index]     = z3;\n        v[indexRm1]  = z4;\n        v[indexRm2] &= 0xFFFF8000;\n        index        = indexRm1;\n\n        // add Matsumoto-Kurita tempering\n        // to get a maximally-equidistributed generator\n        z4 = z4 ^ ((z4 <<  7) & 0x93dd1400);\nz4 = (z4 <= ((z4 >> 15) & 0xfa118000));\n\n        return z4 >>> (32 - bits);\n\n    }",
          "46": "    protected int next(final int bits) {\n\n        // compute raw value given by WELL44497a generator\n        // which is NOT maximally-equidistributed\n        final int indexRm1 = iRm1[index];\n        final int indexRm2 = iRm2[index];\n\n        final int v0       = v[index];\n        final int vM1      = v[i1[index]];\n        final int vM2      = v[i2[index]];\n        final int vM3      = v[i3[index]];\n\n        // the values below include the errata of the original article\n        final int z0       = (0xFFFF8000 & v[indexRm1]) ^ (0x00007FFF & v[indexRm2]);\n        final int z1       = (v0 ^ (v0 << 24))  ^ (vM1 ^ (vM1 >>> 30));\n        final int z2       = (vM2 ^ (vM2 << 10)) ^ (vM3 << 26);\n        final int z3       = z1      ^ z2;\n        final int z2Prime  = ((z2 << 9) ^ (z2 >>> 23)) & 0xfbffffff;\n        final int z2Second = ((z2 & 0x00020000) != 0) ? (z2Prime ^ 0xb729fcec) : z2Prime;\n        int z4             = z0 ^ (z1 ^ (z1 >>> 20)) ^ z2Second ^ z3;\n\n        v[index]     = z3;\n        v[indexRm1]  = z4;\n        v[indexRm2] &= 0xFFFF8000;\n        index        = indexRm1;\n\n        // add Matsumoto-Kurita tempering\n        // to get a maximally-equidistributed generator\n        z4 = z4 ^ ((z4 <<  7) & 0x93dd1400);\nz4 = (z4 >= ((z4 >> 15) & 0xfa118000));\n\n        return z4 >>> (32 - bits);\n\n    }",
          "47": "    protected int next(final int bits) {\n\n        // compute raw value given by WELL44497a generator\n        // which is NOT maximally-equidistributed\n        final int indexRm1 = iRm1[index];\n        final int indexRm2 = iRm2[index];\n\n        final int v0       = v[index];\n        final int vM1      = v[i1[index]];\n        final int vM2      = v[i2[index]];\n        final int vM3      = v[i3[index]];\n\n        // the values below include the errata of the original article\n        final int z0       = (0xFFFF8000 & v[indexRm1]) ^ (0x00007FFF & v[indexRm2]);\n        final int z1       = (v0 ^ (v0 << 24))  ^ (vM1 ^ (vM1 >>> 30));\n        final int z2       = (vM2 ^ (vM2 << 10)) ^ (vM3 << 26);\n        final int z3       = z1      ^ z2;\n        final int z2Prime  = ((z2 << 9) ^ (z2 >>> 23)) & 0xfbffffff;\n        final int z2Second = ((z2 & 0x00020000) != 0) ? (z2Prime ^ 0xb729fcec) : z2Prime;\n        int z4             = z0 ^ (z1 ^ (z1 >>> 20)) ^ z2Second ^ z3;\n\n        v[index]     = z3;\n        v[indexRm1]  = z4;\n        v[indexRm2] &= 0xFFFF8000;\n        index        = indexRm1;\n\n        // add Matsumoto-Kurita tempering\n        // to get a maximally-equidistributed generator\n        z4 = z4 ^ ((z4 <<  7) & 0x93dd1400);\nz4 = (z4 - ((z4 >> 15) & 0xfa118000));\n\n        return z4 >>> (32 - bits);\n\n    }",
          "48": "    protected int next(final int bits) {\n\n        // compute raw value given by WELL44497a generator\n        // which is NOT maximally-equidistributed\n        final int indexRm1 = iRm1[index];\n        final int indexRm2 = iRm2[index];\n\n        final int v0       = v[index];\n        final int vM1      = v[i1[index]];\n        final int vM2      = v[i2[index]];\n        final int vM3      = v[i3[index]];\n\n        // the values below include the errata of the original article\n        final int z0       = (0xFFFF8000 & v[indexRm1]) ^ (0x00007FFF & v[indexRm2]);\n        final int z1       = (v0 ^ (v0 << 24))  ^ (vM1 ^ (vM1 >>> 30));\n        final int z2       = (vM2 ^ (vM2 << 10)) ^ (vM3 << 26);\n        final int z3       = z1      ^ z2;\n        final int z2Prime  = ((z2 << 9) ^ (z2 >>> 23)) & 0xfbffffff;\n        final int z2Second = ((z2 & 0x00020000) != 0) ? (z2Prime ^ 0xb729fcec) : z2Prime;\n        int z4             = z0 ^ (z1 ^ (z1 >>> 20)) ^ z2Second ^ z3;\n\n        v[index]     = z3;\n        v[indexRm1]  = z4;\n        v[indexRm2] &= 0xFFFF8000;\n        index        = indexRm1;\n\n        // add Matsumoto-Kurita tempering\n        // to get a maximally-equidistributed generator\n        z4 = z4 ^ ((z4 <<  7) & 0x93dd1400);\nz4 = (z4 ^<> ((z4 >> 15) & false));\n\n        return z4 >>> (32 - bits);\n\n    }",
          "49": "    protected int next(final int bits) {\n\n        // compute raw value given by WELL44497a generator\n        // which is NOT maximally-equidistributed\n        final int indexRm1 = iRm1[index];\n        final int indexRm2 = iRm2[index];\n\n        final int v0       = v[index];\n        final int vM1      = v[i1[index]];\n        final int vM2      = v[i2[index]];\n        final int vM3      = v[i3[index]];\n\n        // the values below include the errata of the original article\n        final int z0       = (0xFFFF8000 & v[indexRm1]) ^ (0x00007FFF & v[indexRm2]);\n        final int z1       = (v0 ^ (v0 << 24))  ^ (vM1 ^ (vM1 >>> 30));\n        final int z2       = (vM2 ^ (vM2 << 10)) ^ (vM3 << 26);\n        final int z3       = z1      ^ z2;\n        final int z2Prime  = ((z2 << 9) ^ (z2 >>> 23)) & 0xfbffffff;\n        final int z2Second = ((z2 & 0x00020000) != 0) ? (z2Prime ^ 0xb729fcec) : z2Prime;\n        int z4             = z0 ^ (z1 ^ (z1 >>> 20)) ^ z2Second ^ z3;\n\n        v[index]     = z3;\n        v[indexRm1]  = z4;\n        v[indexRm2] &= 0xFFFF8000;\n        index        = indexRm1;\n\n        // add Matsumoto-Kurita tempering\n        // to get a maximally-equidistributed generator\n        z4 = z4 ^ ((z4 <<  7) & 0x93dd1400);\nz4 = (z4 || ((z4 >> 15) & 0xfa118000));\n\n        return z4 >>> (32 - bits);\n\n    }",
          "50": "    protected int next(final int bits) {\n\n        // compute raw value given by WELL44497a generator\n        // which is NOT maximally-equidistributed\n        final int indexRm1 = iRm1[index];\n        final int indexRm2 = iRm2[index];\n\n        final int v0       = v[index];\n        final int vM1      = v[i1[index]];\n        final int vM2      = v[i2[index]];\n        final int vM3      = v[i3[index]];\n\n        // the values below include the errata of the original article\n        final int z0       = (0xFFFF8000 & v[indexRm1]) ^ (0x00007FFF & v[indexRm2]);\n        final int z1       = (v0 ^ (v0 << 24))  ^ (vM1 ^ (vM1 >>> 30));\n        final int z2       = (vM2 ^ (vM2 << 10)) ^ (vM3 << 26);\n        final int z3       = z1      ^ z2;\n        final int z2Prime  = ((z2 << 9) ^ (z2 >>> 23)) & 0xfbffffff;\n        final int z2Second = ((z2 & 0x00020000) != 0) ? (z2Prime ^ 0xb729fcec) : z2Prime;\n        int z4             = z0 ^ (z1 ^ (z1 >>> 20)) ^ z2Second ^ z3;\n\n        v[index]     = z3;\n        v[indexRm1]  = z4;\n        v[indexRm2] &= 0xFFFF8000;\n        index        = indexRm1;\n\n        // add Matsumoto-Kurita tempering\n        // to get a maximally-equidistributed generator\n        z4 = z4 ^ ((z4 <<  7) & 0x93dd1400);\nz4 = (z4 ^<> ((z4 >> 15) & 15));\n\n        return z4 >>> (32 - bits);\n\n    }",
          "51": "    protected int next(final int bits) {\n\n        // compute raw value given by WELL44497a generator\n        // which is NOT maximally-equidistributed\n        final int indexRm1 = iRm1[index];\n        final int indexRm2 = iRm2[index];\n\n        final int v0       = v[index];\n        final int vM1      = v[i1[index]];\n        final int vM2      = v[i2[index]];\n        final int vM3      = v[i3[index]];\n\n        // the values below include the errata of the original article\n        final int z0       = (0xFFFF8000 & v[indexRm1]) ^ (0x00007FFF & v[indexRm2]);\n        final int z1       = (v0 ^ (v0 << 24))  ^ (vM1 ^ (vM1 >>> 30));\n        final int z2       = (vM2 ^ (vM2 << 10)) ^ (vM3 << 26);\n        final int z3       = z1      ^ z2;\n        final int z2Prime  = ((z2 << 9) ^ (z2 >>> 23)) & 0xfbffffff;\n        final int z2Second = ((z2 & 0x00020000) != 0) ? (z2Prime ^ 0xb729fcec) : z2Prime;\n        int z4             = z0 ^ (z1 ^ (z1 >>> 20)) ^ z2Second ^ z3;\n\n        v[index]     = z3;\n        v[indexRm1]  = z4;\n        v[indexRm2] &= 0xFFFF8000;\n        index        = indexRm1;\n\n        // add Matsumoto-Kurita tempering\n        // to get a maximally-equidistributed generator\n        z4 = z4 ^ ((z4 <<  7) & 0x93dd1400);\nz4 = (z4 ^<> ((z4 >> 15) & null));\n\n        return z4 >>> (32 - bits);\n\n    }",
          "52": "    protected int next(final int bits) {\n\n        // compute raw value given by WELL44497a generator\n        // which is NOT maximally-equidistributed\n        final int indexRm1 = iRm1[index];\n        final int indexRm2 = iRm2[index];\n\n        final int v0       = v[index];\n        final int vM1      = v[i1[index]];\n        final int vM2      = v[i2[index]];\n        final int vM3      = v[i3[index]];\n\n        // the values below include the errata of the original article\n        final int z0       = (0xFFFF8000 & v[indexRm1]) ^ (0x00007FFF & v[indexRm2]);\n        final int z1       = (v0 ^ (v0 << 24))  ^ (vM1 ^ (vM1 >>> 30));\n        final int z2       = (vM2 ^ (vM2 << 10)) ^ (vM3 << 26);\n        final int z3       = z1      ^ z2;\n        final int z2Prime  = ((z2 << 9) ^ (z2 >>> 23)) & 0xfbffffff;\n        final int z2Second = ((z2 & 0x00020000) != 0) ? (z2Prime ^ 0xb729fcec) : z2Prime;\n        int z4             = z0 ^ (z1 ^ (z1 >>> 20)) ^ z2Second ^ z3;\n\n        v[index]     = z3;\n        v[indexRm1]  = z4;\n        v[indexRm2] &= 0xFFFF8000;\n        index        = indexRm1;\n\n        // add Matsumoto-Kurita tempering\n        // to get a maximally-equidistributed generator\n        z4 = z4 ^ ((z4 <<  7) & 0x93dd1400);\nz4 = (z4 ^<> ((z4 >> 15) & -1));\n\n        return z4 >>> (32 - bits);\n\n    }",
          "53": "    protected int next(final int bits) {\n\n        // compute raw value given by WELL44497a generator\n        // which is NOT maximally-equidistributed\n        final int indexRm1 = iRm1[index];\n        final int indexRm2 = iRm2[index];\n\n        final int v0       = v[index];\n        final int vM1      = v[i1[index]];\n        final int vM2      = v[i2[index]];\n        final int vM3      = v[i3[index]];\n\n        // the values below include the errata of the original article\n        final int z0       = (0xFFFF8000 & v[indexRm1]) ^ (0x00007FFF & v[indexRm2]);\n        final int z1       = (v0 ^ (v0 << 24))  ^ (vM1 ^ (vM1 >>> 30));\n        final int z2       = (vM2 ^ (vM2 << 10)) ^ (vM3 << 26);\n        final int z3       = z1      ^ z2;\n        final int z2Prime  = ((z2 << 9) ^ (z2 >>> 23)) & 0xfbffffff;\n        final int z2Second = ((z2 & 0x00020000) != 0) ? (z2Prime ^ 0xb729fcec) : z2Prime;\n        int z4             = z0 ^ (z1 ^ (z1 >>> 20)) ^ z2Second ^ z3;\n\n        v[index]     = z3;\n        v[indexRm1]  = z4;\n        v[indexRm2] &= 0xFFFF8000;\n        index        = indexRm1;\n\n        // add Matsumoto-Kurita tempering\n        // to get a maximally-equidistributed generator\n        z4 = z4 ^ ((z4 <<  7) & 0x93dd1400);\nz4 = (z4 ^<> ((z4 << 7) & 0x93dd1400));\n\n        return z4 >>> (32 - bits);\n\n    }",
          "54": "    protected int next(final int bits) {\n\n        // compute raw value given by WELL44497a generator\n        // which is NOT maximally-equidistributed\n        final int indexRm1 = iRm1[index];\n        final int indexRm2 = iRm2[index];\n\n        final int v0       = v[index];\n        final int vM1      = v[i1[index]];\n        final int vM2      = v[i2[index]];\n        final int vM3      = v[i3[index]];\n\n        // the values below include the errata of the original article\n        final int z0       = (0xFFFF8000 & v[indexRm1]) ^ (0x00007FFF & v[indexRm2]);\n        final int z1       = (v0 ^ (v0 << 24))  ^ (vM1 ^ (vM1 >>> 30));\n        final int z2       = (vM2 ^ (vM2 << 10)) ^ (vM3 << 26);\n        final int z3       = z1      ^ z2;\n        final int z2Prime  = ((z2 << 9) ^ (z2 >>> 23)) & 0xfbffffff;\n        final int z2Second = ((z2 & 0x00020000) != 0) ? (z2Prime ^ 0xb729fcec) : z2Prime;\n        int z4             = z0 ^ (z1 ^ (z1 >>> 20)) ^ z2Second ^ z3;\n\n        v[index]     = z3;\n        v[indexRm1]  = z4;\n        v[indexRm2] &= 0xFFFF8000;\n        index        = indexRm1;\n\n        // add Matsumoto-Kurita tempering\n        // to get a maximally-equidistributed generator\n        z4 = z4 ^ ((z4 <<  7) & 0x93dd1400);\nz4 = (z4 ^<> ((z4 >> 15) & 32));\n\n        return z4 >>> (32 - bits);\n\n    }",
          "55": "    protected int next(final int bits) {\n\n        // compute raw value given by WELL44497a generator\n        // which is NOT maximally-equidistributed\n        final int indexRm1 = iRm1[index];\n        final int indexRm2 = iRm2[index];\n\n        final int v0       = v[index];\n        final int vM1      = v[i1[index]];\n        final int vM2      = v[i2[index]];\n        final int vM3      = v[i3[index]];\n\n        // the values below include the errata of the original article\n        final int z0       = (0xFFFF8000 & v[indexRm1]) ^ (0x00007FFF & v[indexRm2]);\n        final int z1       = (v0 ^ (v0 << 24))  ^ (vM1 ^ (vM1 >>> 30));\n        final int z2       = (vM2 ^ (vM2 << 10)) ^ (vM3 << 26);\n        final int z3       = z1      ^ z2;\n        final int z2Prime  = ((z2 << 9) ^ (z2 >>> 23)) & 0xfbffffff;\n        final int z2Second = ((z2 & 0x00020000) != 0) ? (z2Prime ^ 0xb729fcec) : z2Prime;\n        int z4             = z0 ^ (z1 ^ (z1 >>> 20)) ^ z2Second ^ z3;\n\n        v[index]     = z3;\n        v[indexRm1]  = z4;\n        v[indexRm2] &= 0xFFFF8000;\n        index        = indexRm1;\n\n        // add Matsumoto-Kurita tempering\n        // to get a maximally-equidistributed generator\n        z4 = z4 ^ ((z4 <<  7) & 0x93dd1400);\nz4 = (z4 ^<> ((z4 >> -2) & 0xfa118000));\n\n        return z4 >>> (32 - bits);\n\n    }",
          "56": "    protected int next(final int bits) {\n\n        // compute raw value given by WELL44497a generator\n        // which is NOT maximally-equidistributed\n        final int indexRm1 = iRm1[index];\n        final int indexRm2 = iRm2[index];\n\n        final int v0       = v[index];\n        final int vM1      = v[i1[index]];\n        final int vM2      = v[i2[index]];\n        final int vM3      = v[i3[index]];\n\n        // the values below include the errata of the original article\n        final int z0       = (0xFFFF8000 & v[indexRm1]) ^ (0x00007FFF & v[indexRm2]);\n        final int z1       = (v0 ^ (v0 << 24))  ^ (vM1 ^ (vM1 >>> 30));\n        final int z2       = (vM2 ^ (vM2 << 10)) ^ (vM3 << 26);\n        final int z3       = z1      ^ z2;\n        final int z2Prime  = ((z2 << 9) ^ (z2 >>> 23)) & 0xfbffffff;\n        final int z2Second = ((z2 & 0x00020000) != 0) ? (z2Prime ^ 0xb729fcec) : z2Prime;\n        int z4             = z0 ^ (z1 ^ (z1 >>> 20)) ^ z2Second ^ z3;\n\n        v[index]     = z3;\n        v[indexRm1]  = z4;\n        v[indexRm2] &= 0xFFFF8000;\n        index        = indexRm1;\n\n        // add Matsumoto-Kurita tempering\n        // to get a maximally-equidistributed generator\n        z4 = z4 ^ ((z4 <<  7) & 0x93dd1400);\n        z4 = z4 ^ ((z4 >> 15) & 0xfa118000);\n        return z4 >>> (32 - bits);\n\n    }",
          "57": "    protected int next(final int bits) {\n\n        // compute raw value given by WELL44497a generator\n        // which is NOT maximally-equidistributed\n        final int indexRm1 = iRm1[index];\n        final int indexRm2 = iRm2[index];\n\n        final int v0       = v[index];\n        final int vM1      = v[i1[index]];\n        final int vM2      = v[i2[index]];\n        final int vM3      = v[i3[index]];\n\n        // the values below include the errata of the original article\n        final int z0       = (0xFFFF8000 & v[indexRm1]) ^ (0x00007FFF & v[indexRm2]);\n        final int z1       = (v0 ^ (v0 << 24))  ^ (vM1 ^ (vM1 >>> 30));\n        final int z2       = (vM2 ^ (vM2 << 10)) ^ (vM3 << 26);\n        final int z3       = z1      ^ z2;\n        final int z2Prime  = ((z2 << 9) ^ (z2 >>> 23)) & 0xfbffffff;\n        final int z2Second = ((z2 & 0x00020000) != 0) ? (z2Prime ^ 0xb729fcec) : z2Prime;\n        int z4             = z0 ^ (z1 ^ (z1 >>> 20)) ^ z2Second ^ z3;\n\n        v[index]     = z3;\n        v[indexRm1]  = z4;\n        v[indexRm2] &= 0xFFFF8000;\n        index        = indexRm1;\n\n        // add Matsumoto-Kurita tempering\n        // to get a maximally-equidistributed generator\n        z4 = z4 ^ ((z4 <<  7) & 0x93dd1400);\nz4 = ((((z4 & z4) | 0xfa118000) | z4) | 0xfa118000);\n\n        return z4 >>> (32 - bits);\n\n    }",
          "58": "    protected int next(final int bits) {\n\n        // compute raw value given by WELL44497a generator\n        // which is NOT maximally-equidistributed\n        final int indexRm1 = iRm1[index];\n        final int indexRm2 = iRm2[index];\n\n        final int v0       = v[index];\n        final int vM1      = v[i1[index]];\n        final int vM2      = v[i2[index]];\n        final int vM3      = v[i3[index]];\n\n        // the values below include the errata of the original article\n        final int z0       = (0xFFFF8000 & v[indexRm1]) ^ (0x00007FFF & v[indexRm2]);\n        final int z1       = (v0 ^ (v0 << 24))  ^ (vM1 ^ (vM1 >>> 30));\n        final int z2       = (vM2 ^ (vM2 << 10)) ^ (vM3 << 26);\n        final int z3       = z1      ^ z2;\n        final int z2Prime  = ((z2 << 9) ^ (z2 >>> 23)) & 0xfbffffff;\n        final int z2Second = ((z2 & 0x00020000) != 0) ? (z2Prime ^ 0xb729fcec) : z2Prime;\n        int z4             = z0 ^ (z1 ^ (z1 >>> 20)) ^ z2Second ^ z3;\n\n        v[index]     = z3;\n        v[indexRm1]  = z4;\n        v[indexRm2] &= 0xFFFF8000;\n        index        = indexRm1;\n\n        // add Matsumoto-Kurita tempering\n        // to get a maximally-equidistributed generator\n        z4 = z4 ^ ((z4 <<  7) & 0x93dd1400);\nz4 = (((((z4 & z4) | z4) | 0xfa118000) | ((z4 >> 15) & 0xfa118000)) | 0xfa118000);\n\n        return z4 >>> (32 - bits);\n\n    }",
          "59": "    protected int next(final int bits) {\n\n        // compute raw value given by WELL44497a generator\n        // which is NOT maximally-equidistributed\n        final int indexRm1 = iRm1[index];\n        final int indexRm2 = iRm2[index];\n\n        final int v0       = v[index];\n        final int vM1      = v[i1[index]];\n        final int vM2      = v[i2[index]];\n        final int vM3      = v[i3[index]];\n\n        // the values below include the errata of the original article\n        final int z0       = (0xFFFF8000 & v[indexRm1]) ^ (0x00007FFF & v[indexRm2]);\n        final int z1       = (v0 ^ (v0 << 24))  ^ (vM1 ^ (vM1 >>> 30));\n        final int z2       = (vM2 ^ (vM2 << 10)) ^ (vM3 << 26);\n        final int z3       = z1      ^ z2;\n        final int z2Prime  = ((z2 << 9) ^ (z2 >>> 23)) & 0xfbffffff;\n        final int z2Second = ((z2 & 0x00020000) != 0) ? (z2Prime ^ 0xb729fcec) : z2Prime;\n        int z4             = z0 ^ (z1 ^ (z1 >>> 20)) ^ z2Second ^ z3;\n\n        v[index]     = z3;\n        v[indexRm1]  = z4;\n        v[indexRm2] &= 0xFFFF8000;\n        index        = indexRm1;\n\n        // add Matsumoto-Kurita tempering\n        // to get a maximally-equidistributed generator\n        z4 = z4 ^ ((z4 <<  7) & 0x93dd1400);\nz4 = (((((z4 & z4) | z4) | 0xfa118000) | z4) | 0xfa118000);\n\n        return z4 >>> (32 - bits);\n\n    }",
          "60": "    protected int next(final int bits) {\n\n        // compute raw value given by WELL44497a generator\n        // which is NOT maximally-equidistributed\n        final int indexRm1 = iRm1[index];\n        final int indexRm2 = iRm2[index];\n\n        final int v0       = v[index];\n        final int vM1      = v[i1[index]];\n        final int vM2      = v[i2[index]];\n        final int vM3      = v[i3[index]];\n\n        // the values below include the errata of the original article\n        final int z0       = (0xFFFF8000 & v[indexRm1]) ^ (0x00007FFF & v[indexRm2]);\n        final int z1       = (v0 ^ (v0 << 24))  ^ (vM1 ^ (vM1 >>> 30));\n        final int z2       = (vM2 ^ (vM2 << 10)) ^ (vM3 << 26);\n        final int z3       = z1      ^ z2;\n        final int z2Prime  = ((z2 << 9) ^ (z2 >>> 23)) & 0xfbffffff;\n        final int z2Second = ((z2 & 0x00020000) != 0) ? (z2Prime ^ 0xb729fcec) : z2Prime;\n        int z4             = z0 ^ (z1 ^ (z1 >>> 20)) ^ z2Second ^ z3;\n\n        v[index]     = z3;\n        v[indexRm1]  = z4;\n        v[indexRm2] &= 0xFFFF8000;\n        index        = indexRm1;\n\n        // add Matsumoto-Kurita tempering\n        // to get a maximally-equidistributed generator\n        z4 = z4 ^ ((z4 <<  7) & 0x93dd1400);\nz4 = (((((z4 & z4) | z4) | 0xfa118000) | z4) | ((z4 >> 15) & 0xfa118000));\n\n        return z4 >>> (32 - bits);\n\n    }",
          "61": "    protected int next(final int bits) {\n\n        // compute raw value given by WELL44497a generator\n        // which is NOT maximally-equidistributed\n        final int indexRm1 = iRm1[index];\n        final int indexRm2 = iRm2[index];\n\n        final int v0       = v[index];\n        final int vM1      = v[i1[index]];\n        final int vM2      = v[i2[index]];\n        final int vM3      = v[i3[index]];\n\n        // the values below include the errata of the original article\n        final int z0       = (0xFFFF8000 & v[indexRm1]) ^ (0x00007FFF & v[indexRm2]);\n        final int z1       = (v0 ^ (v0 << 24))  ^ (vM1 ^ (vM1 >>> 30));\n        final int z2       = (vM2 ^ (vM2 << 10)) ^ (vM3 << 26);\n        final int z3       = z1      ^ z2;\n        final int z2Prime  = ((z2 << 9) ^ (z2 >>> 23)) & 0xfbffffff;\n        final int z2Second = ((z2 & 0x00020000) != 0) ? (z2Prime ^ 0xb729fcec) : z2Prime;\n        int z4             = z0 ^ (z1 ^ (z1 >>> 20)) ^ z2Second ^ z3;\n\n        v[index]     = z3;\n        v[indexRm1]  = z4;\n        v[indexRm2] &= 0xFFFF8000;\n        index        = indexRm1;\n\n        // add Matsumoto-Kurita tempering\n        // to get a maximally-equidistributed generator\n        z4 = z4 ^ ((z4 <<  7) & 0x93dd1400);\nz4 = ((((((z4 & z4) | z4) | z4) | 0xfa118000) | ((z4 >> 15) & 0xfa118000)) | 0xfa118000);\n\n        return z4 >>> (32 - bits);\n\n    }",
          "62": "    protected int next(final int bits) {\n\n        // compute raw value given by WELL44497a generator\n        // which is NOT maximally-equidistributed\n        final int indexRm1 = iRm1[index];\n        final int indexRm2 = iRm2[index];\n\n        final int v0       = v[index];\n        final int vM1      = v[i1[index]];\n        final int vM2      = v[i2[index]];\n        final int vM3      = v[i3[index]];\n\n        // the values below include the errata of the original article\n        final int z0       = (0xFFFF8000 & v[indexRm1]) ^ (0x00007FFF & v[indexRm2]);\n        final int z1       = (v0 ^ (v0 << 24))  ^ (vM1 ^ (vM1 >>> 30));\n        final int z2       = (vM2 ^ (vM2 << 10)) ^ (vM3 << 26);\n        final int z3       = z1      ^ z2;\n        final int z2Prime  = ((z2 << 9) ^ (z2 >>> 23)) & 0xfbffffff;\n        final int z2Second = ((z2 & 0x00020000) != 0) ? (z2Prime ^ 0xb729fcec) : z2Prime;\n        int z4             = z0 ^ (z1 ^ (z1 >>> 20)) ^ z2Second ^ z3;\n\n        v[index]     = z3;\n        v[indexRm1]  = z4;\n        v[indexRm2] &= 0xFFFF8000;\n        index        = indexRm1;\n\n        // add Matsumoto-Kurita tempering\n        // to get a maximally-equidistributed generator\n        z4 = z4 ^ ((z4 <<  7) & 0x93dd1400);\nz4 = (((((z4 & z4) | z4) | 0xfa118000) | (z4 & 0xfa118000)) | 0xfa118000);\n\n        return z4 >>> (32 - bits);\n\n    }",
          "63": "    protected int next(final int bits) {\n\n        // compute raw value given by WELL44497a generator\n        // which is NOT maximally-equidistributed\n        final int indexRm1 = iRm1[index];\n        final int indexRm2 = iRm2[index];\n\n        final int v0       = v[index];\n        final int vM1      = v[i1[index]];\n        final int vM2      = v[i2[index]];\n        final int vM3      = v[i3[index]];\n\n        // the values below include the errata of the original article\n        final int z0       = (0xFFFF8000 & v[indexRm1]) ^ (0x00007FFF & v[indexRm2]);\n        final int z1       = (v0 ^ (v0 << 24))  ^ (vM1 ^ (vM1 >>> 30));\n        final int z2       = (vM2 ^ (vM2 << 10)) ^ (vM3 << 26);\n        final int z3       = z1      ^ z2;\n        final int z2Prime  = ((z2 << 9) ^ (z2 >>> 23)) & 0xfbffffff;\n        final int z2Second = ((z2 & 0x00020000) != 0) ? (z2Prime ^ 0xb729fcec) : z2Prime;\n        int z4             = z0 ^ (z1 ^ (z1 >>> 20)) ^ z2Second ^ z3;\n\n        v[index]     = z3;\n        v[indexRm1]  = z4;\n        v[indexRm2] &= 0xFFFF8000;\n        index        = indexRm1;\n\n        // add Matsumoto-Kurita tempering\n        // to get a maximally-equidistributed generator\n        z4 = z4 ^ ((z4 <<  7) & 0x93dd1400);\nz4 = ((((((z4 & z4) | z4) | z4) | 0xfa118000) | ((z4 >> 15) & 0xfa118000)) | ((z4 >> 15) & 0xfa118000));\n\n        return z4 >>> (32 - bits);\n\n    }"
}