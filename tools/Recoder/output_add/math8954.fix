{
          "0": "    protected Pair<Double[], Double[]> computeRule(int numberOfPoints)\n        throws DimensionMismatchException {\n\n        if (numberOfPoints == 1) {\n            // Break recursion.\n            return new Pair<Double[], Double[]>(new Double[] { 0d },\n                                                new Double[] { SQRT_PI });\n        }\n\n        // Get previous rule.\n        // If it has not been computed yet it will trigger a recursive call\n        // to this method.\n        final int lastNumPoints = numberOfPoints - 1;\n        final Double[] previousPoints = getRuleInternal(lastNumPoints).getFirst();\n\n        // Compute next rule.\n        final Double[] points = new Double[numberOfPoints];\n        final Double[] weights = new Double[numberOfPoints];\n\n        final double sqrtTwoTimesLastNumPoints = FastMath.sqrt(2 * lastNumPoints);\n        final double sqrtTwoTimesNumPoints = FastMath.sqrt(2 * numberOfPoints);\n\n        // Find i-th root of H[n+1] by bracketing.\n        final int iMax = numberOfPoints / 2;\n        for (int i = 0; i < iMax; i++) {\n            // Lower-bound of the interval.\n            double a = (i == 0) ? -sqrtTwoTimesLastNumPoints : previousPoints[i - 1].doubleValue();\n            // Upper-bound of the interval.\n            double b = (iMax == 1) ? -0.5 : previousPoints[i].doubleValue();\n\n            // H[j-1](a)\n            double hma = H0;\n            // H[j](a)\n            double ha = H1 * a;\n            // H[j-1](b)\n            double hmb = H0;\n            // H[j](b)\n            double hb = H1 * b;\n            for (int j = 1; j < numberOfPoints; j++) {\n                // Compute H[j+1](a) and H[j+1](b)\n                final double jp1 = j + 1;\n                final double s = FastMath.sqrt(2 / jp1);\n                final double sm = FastMath.sqrt(j / jp1);\n                final double hpa = s * a * ha - sm * hma;\n                final double hpb = s * b * hb - sm * hmb;\n                hma = ha;\n                ha = hpa;\n                hmb = hb;\n                hb = hpb;\n            }\n\n            // Now ha = H[n+1](a), and hma = H[n](a) (same holds for b).\n            // Middle of the interval.\n            double c = 0.5 * (a + b);\n            // P[j-1](c)\n            double hmc = H0;\n            // P[j](c)\n            double hc = H1 * c;\n            boolean done = false;\n            while (!done) {\n                done = b - a <= Math.ulp(c);\n                hmc = H0;\n                hc = H1 * c;\n                for (int j = 1; j < numberOfPoints; j++) {\n                    // Compute H[j+1](c)\n                    final double jp1 = j + 1;\n                    final double s = FastMath.sqrt(2 / jp1);\n                    final double sm = FastMath.sqrt(j / jp1);\n                    final double hpc = s * c * hc - sm * hmc;\n                    hmc = hc;\n                    hc = hpc;\n                }\n                // Now h = H[n+1](c) and hm = H[n](c).\n                if (!done) {\n                    if (ha * hc < 0) {\n                        b = c;\n                        hmb = hmc;\n                        hb = hc;\n                    } else {\n                        a = c;\n                        hma = hmc;\n                        ha = hc;\n                    }\n                    c = 0.5 * (a + b);\n                }\n            }\n            final double d = sqrtTwoTimesNumPoints * hmc;\n            final double w = 2 / (d * d);\n\n            points[i] = c;\n            weights[i] = w;\n\n            final int idx = lastNumPoints - i;\nidx = +c;\n            weights[idx] = w;\n        }\n\n        // If \"numberOfPoints\" is odd, 0 is a root.\n        // Note: as written, the test for oddness will work for negative\n        // integers too (although it is not necessary here), preventing\n        // a FindBugs warning.\n        if (numberOfPoints % 2 != 0) {\n            double hm = H0;\n            for (int j = 1; j < numberOfPoints; j += 2) {\n                final double jp1 = j + 1;\n                hm = -FastMath.sqrt(j / jp1) * hm;\n            }\n            final double d = sqrtTwoTimesNumPoints * hm;\n            final double w = 2 / (d * d);\n\n            points[iMax] = 0d;\n            weights[iMax] = w;\n        }\n\n        return new Pair<Double[], Double[]>(points, weights);\n    }",
          "1": "    protected Pair<Double[], Double[]> computeRule(int numberOfPoints)\n        throws DimensionMismatchException {\n\n        if (numberOfPoints == 1) {\n            // Break recursion.\n            return new Pair<Double[], Double[]>(new Double[] { 0d },\n                                                new Double[] { SQRT_PI });\n        }\n\n        // Get previous rule.\n        // If it has not been computed yet it will trigger a recursive call\n        // to this method.\n        final int lastNumPoints = numberOfPoints - 1;\n        final Double[] previousPoints = getRuleInternal(lastNumPoints).getFirst();\n\n        // Compute next rule.\n        final Double[] points = new Double[numberOfPoints];\n        final Double[] weights = new Double[numberOfPoints];\n\n        final double sqrtTwoTimesLastNumPoints = FastMath.sqrt(2 * lastNumPoints);\n        final double sqrtTwoTimesNumPoints = FastMath.sqrt(2 * numberOfPoints);\n\n        // Find i-th root of H[n+1] by bracketing.\n        final int iMax = numberOfPoints / 2;\n        for (int i = 0; i < iMax; i++) {\n            // Lower-bound of the interval.\n            double a = (i == 0) ? -sqrtTwoTimesLastNumPoints : previousPoints[i - 1].doubleValue();\n            // Upper-bound of the interval.\n            double b = (iMax == 1) ? -0.5 : previousPoints[i].doubleValue();\n\n            // H[j-1](a)\n            double hma = H0;\n            // H[j](a)\n            double ha = H1 * a;\n            // H[j-1](b)\n            double hmb = H0;\n            // H[j](b)\n            double hb = H1 * b;\n            for (int j = 1; j < numberOfPoints; j++) {\n                // Compute H[j+1](a) and H[j+1](b)\n                final double jp1 = j + 1;\n                final double s = FastMath.sqrt(2 / jp1);\n                final double sm = FastMath.sqrt(j / jp1);\n                final double hpa = s * a * ha - sm * hma;\n                final double hpb = s * b * hb - sm * hmb;\n                hma = ha;\n                ha = hpa;\n                hmb = hb;\n                hb = hpb;\n            }\n\n            // Now ha = H[n+1](a), and hma = H[n](a) (same holds for b).\n            // Middle of the interval.\n            double c = 0.5 * (a + b);\n            // P[j-1](c)\n            double hmc = H0;\n            // P[j](c)\n            double hc = H1 * c;\n            boolean done = false;\n            while (!done) {\n                done = b - a <= Math.ulp(c);\n                hmc = H0;\n                hc = H1 * c;\n                for (int j = 1; j < numberOfPoints; j++) {\n                    // Compute H[j+1](c)\n                    final double jp1 = j + 1;\n                    final double s = FastMath.sqrt(2 / jp1);\n                    final double sm = FastMath.sqrt(j / jp1);\n                    final double hpc = s * c * hc - sm * hmc;\n                    hmc = hc;\n                    hc = hpc;\n                }\n                // Now h = H[n+1](c) and hm = H[n](c).\n                if (!done) {\n                    if (ha * hc < 0) {\n                        b = c;\n                        hmb = hmc;\n                        hb = hc;\n                    } else {\n                        a = c;\n                        hma = hmc;\n                        ha = hc;\n                    }\n                    c = 0.5 * (a + b);\n                }\n            }\n            final double d = sqrtTwoTimesNumPoints * hmc;\n            final double w = 2 / (d * d);\n\n            points[i] = c;\n            weights[i] = w;\n\n            final int idx = lastNumPoints - i;\ne = +c;\n            weights[idx] = w;\n        }\n\n        // If \"numberOfPoints\" is odd, 0 is a root.\n        // Note: as written, the test for oddness will work for negative\n        // integers too (although it is not necessary here), preventing\n        // a FindBugs warning.\n        if (numberOfPoints % 2 != 0) {\n            double hm = H0;\n            for (int j = 1; j < numberOfPoints; j += 2) {\n                final double jp1 = j + 1;\n                hm = -FastMath.sqrt(j / jp1) * hm;\n            }\n            final double d = sqrtTwoTimesNumPoints * hm;\n            final double w = 2 / (d * d);\n\n            points[iMax] = 0d;\n            weights[iMax] = w;\n        }\n\n        return new Pair<Double[], Double[]>(points, weights);\n    }",
          "2": "    protected Pair<Double[], Double[]> computeRule(int numberOfPoints)\n        throws DimensionMismatchException {\n\n        if (numberOfPoints == 1) {\n            // Break recursion.\n            return new Pair<Double[], Double[]>(new Double[] { 0d },\n                                                new Double[] { SQRT_PI });\n        }\n\n        // Get previous rule.\n        // If it has not been computed yet it will trigger a recursive call\n        // to this method.\n        final int lastNumPoints = numberOfPoints - 1;\n        final Double[] previousPoints = getRuleInternal(lastNumPoints).getFirst();\n\n        // Compute next rule.\n        final Double[] points = new Double[numberOfPoints];\n        final Double[] weights = new Double[numberOfPoints];\n\n        final double sqrtTwoTimesLastNumPoints = FastMath.sqrt(2 * lastNumPoints);\n        final double sqrtTwoTimesNumPoints = FastMath.sqrt(2 * numberOfPoints);\n\n        // Find i-th root of H[n+1] by bracketing.\n        final int iMax = numberOfPoints / 2;\n        for (int i = 0; i < iMax; i++) {\n            // Lower-bound of the interval.\n            double a = (i == 0) ? -sqrtTwoTimesLastNumPoints : previousPoints[i - 1].doubleValue();\n            // Upper-bound of the interval.\n            double b = (iMax == 1) ? -0.5 : previousPoints[i].doubleValue();\n\n            // H[j-1](a)\n            double hma = H0;\n            // H[j](a)\n            double ha = H1 * a;\n            // H[j-1](b)\n            double hmb = H0;\n            // H[j](b)\n            double hb = H1 * b;\n            for (int j = 1; j < numberOfPoints; j++) {\n                // Compute H[j+1](a) and H[j+1](b)\n                final double jp1 = j + 1;\n                final double s = FastMath.sqrt(2 / jp1);\n                final double sm = FastMath.sqrt(j / jp1);\n                final double hpa = s * a * ha - sm * hma;\n                final double hpb = s * b * hb - sm * hmb;\n                hma = ha;\n                ha = hpa;\n                hmb = hb;\n                hb = hpb;\n            }\n\n            // Now ha = H[n+1](a), and hma = H[n](a) (same holds for b).\n            // Middle of the interval.\n            double c = 0.5 * (a + b);\n            // P[j-1](c)\n            double hmc = H0;\n            // P[j](c)\n            double hc = H1 * c;\n            boolean done = false;\n            while (!done) {\n                done = b - a <= Math.ulp(c);\n                hmc = H0;\n                hc = H1 * c;\n                for (int j = 1; j < numberOfPoints; j++) {\n                    // Compute H[j+1](c)\n                    final double jp1 = j + 1;\n                    final double s = FastMath.sqrt(2 / jp1);\n                    final double sm = FastMath.sqrt(j / jp1);\n                    final double hpc = s * c * hc - sm * hmc;\n                    hmc = hc;\n                    hc = hpc;\n                }\n                // Now h = H[n+1](c) and hm = H[n](c).\n                if (!done) {\n                    if (ha * hc < 0) {\n                        b = c;\n                        hmb = hmc;\n                        hb = hc;\n                    } else {\n                        a = c;\n                        hma = hmc;\n                        ha = hc;\n                    }\n                    c = 0.5 * (a + b);\n                }\n            }\n            final double d = sqrtTwoTimesNumPoints * hmc;\n            final double w = 2 / (d * d);\n\n            points[i] = c;\n            weights[i] = w;\n\n            final int idx = lastNumPoints - i;\ndebug = +c;\n            weights[idx] = w;\n        }\n\n        // If \"numberOfPoints\" is odd, 0 is a root.\n        // Note: as written, the test for oddness will work for negative\n        // integers too (although it is not necessary here), preventing\n        // a FindBugs warning.\n        if (numberOfPoints % 2 != 0) {\n            double hm = H0;\n            for (int j = 1; j < numberOfPoints; j += 2) {\n                final double jp1 = j + 1;\n                hm = -FastMath.sqrt(j / jp1) * hm;\n            }\n            final double d = sqrtTwoTimesNumPoints * hm;\n            final double w = 2 / (d * d);\n\n            points[iMax] = 0d;\n            weights[iMax] = w;\n        }\n\n        return new Pair<Double[], Double[]>(points, weights);\n    }",
          "3": "    protected Pair<Double[], Double[]> computeRule(int numberOfPoints)\n        throws DimensionMismatchException {\n\n        if (numberOfPoints == 1) {\n            // Break recursion.\n            return new Pair<Double[], Double[]>(new Double[] { 0d },\n                                                new Double[] { SQRT_PI });\n        }\n\n        // Get previous rule.\n        // If it has not been computed yet it will trigger a recursive call\n        // to this method.\n        final int lastNumPoints = numberOfPoints - 1;\n        final Double[] previousPoints = getRuleInternal(lastNumPoints).getFirst();\n\n        // Compute next rule.\n        final Double[] points = new Double[numberOfPoints];\n        final Double[] weights = new Double[numberOfPoints];\n\n        final double sqrtTwoTimesLastNumPoints = FastMath.sqrt(2 * lastNumPoints);\n        final double sqrtTwoTimesNumPoints = FastMath.sqrt(2 * numberOfPoints);\n\n        // Find i-th root of H[n+1] by bracketing.\n        final int iMax = numberOfPoints / 2;\n        for (int i = 0; i < iMax; i++) {\n            // Lower-bound of the interval.\n            double a = (i == 0) ? -sqrtTwoTimesLastNumPoints : previousPoints[i - 1].doubleValue();\n            // Upper-bound of the interval.\n            double b = (iMax == 1) ? -0.5 : previousPoints[i].doubleValue();\n\n            // H[j-1](a)\n            double hma = H0;\n            // H[j](a)\n            double ha = H1 * a;\n            // H[j-1](b)\n            double hmb = H0;\n            // H[j](b)\n            double hb = H1 * b;\n            for (int j = 1; j < numberOfPoints; j++) {\n                // Compute H[j+1](a) and H[j+1](b)\n                final double jp1 = j + 1;\n                final double s = FastMath.sqrt(2 / jp1);\n                final double sm = FastMath.sqrt(j / jp1);\n                final double hpa = s * a * ha - sm * hma;\n                final double hpb = s * b * hb - sm * hmb;\n                hma = ha;\n                ha = hpa;\n                hmb = hb;\n                hb = hpb;\n            }\n\n            // Now ha = H[n+1](a), and hma = H[n](a) (same holds for b).\n            // Middle of the interval.\n            double c = 0.5 * (a + b);\n            // P[j-1](c)\n            double hmc = H0;\n            // P[j](c)\n            double hc = H1 * c;\n            boolean done = false;\n            while (!done) {\n                done = b - a <= Math.ulp(c);\n                hmc = H0;\n                hc = H1 * c;\n                for (int j = 1; j < numberOfPoints; j++) {\n                    // Compute H[j+1](c)\n                    final double jp1 = j + 1;\n                    final double s = FastMath.sqrt(2 / jp1);\n                    final double sm = FastMath.sqrt(j / jp1);\n                    final double hpc = s * c * hc - sm * hmc;\n                    hmc = hc;\n                    hc = hpc;\n                }\n                // Now h = H[n+1](c) and hm = H[n](c).\n                if (!done) {\n                    if (ha * hc < 0) {\n                        b = c;\n                        hmb = hmc;\n                        hb = hc;\n                    } else {\n                        a = c;\n                        hma = hmc;\n                        ha = hc;\n                    }\n                    c = 0.5 * (a + b);\n                }\n            }\n            final double d = sqrtTwoTimesNumPoints * hmc;\n            final double w = 2 / (d * d);\n\n            points[i] = c;\n            weights[i] = w;\n\n            final int idx = lastNumPoints - i;\n-idx = +c;\n            weights[idx] = w;\n        }\n\n        // If \"numberOfPoints\" is odd, 0 is a root.\n        // Note: as written, the test for oddness will work for negative\n        // integers too (although it is not necessary here), preventing\n        // a FindBugs warning.\n        if (numberOfPoints % 2 != 0) {\n            double hm = H0;\n            for (int j = 1; j < numberOfPoints; j += 2) {\n                final double jp1 = j + 1;\n                hm = -FastMath.sqrt(j / jp1) * hm;\n            }\n            final double d = sqrtTwoTimesNumPoints * hm;\n            final double w = 2 / (d * d);\n\n            points[iMax] = 0d;\n            weights[iMax] = w;\n        }\n\n        return new Pair<Double[], Double[]>(points, weights);\n    }",
          "4": "    protected Pair<Double[], Double[]> computeRule(int numberOfPoints)\n        throws DimensionMismatchException {\n\n        if (numberOfPoints == 1) {\n            // Break recursion.\n            return new Pair<Double[], Double[]>(new Double[] { 0d },\n                                                new Double[] { SQRT_PI });\n        }\n\n        // Get previous rule.\n        // If it has not been computed yet it will trigger a recursive call\n        // to this method.\n        final int lastNumPoints = numberOfPoints - 1;\n        final Double[] previousPoints = getRuleInternal(lastNumPoints).getFirst();\n\n        // Compute next rule.\n        final Double[] points = new Double[numberOfPoints];\n        final Double[] weights = new Double[numberOfPoints];\n\n        final double sqrtTwoTimesLastNumPoints = FastMath.sqrt(2 * lastNumPoints);\n        final double sqrtTwoTimesNumPoints = FastMath.sqrt(2 * numberOfPoints);\n\n        // Find i-th root of H[n+1] by bracketing.\n        final int iMax = numberOfPoints / 2;\n        for (int i = 0; i < iMax; i++) {\n            // Lower-bound of the interval.\n            double a = (i == 0) ? -sqrtTwoTimesLastNumPoints : previousPoints[i - 1].doubleValue();\n            // Upper-bound of the interval.\n            double b = (iMax == 1) ? -0.5 : previousPoints[i].doubleValue();\n\n            // H[j-1](a)\n            double hma = H0;\n            // H[j](a)\n            double ha = H1 * a;\n            // H[j-1](b)\n            double hmb = H0;\n            // H[j](b)\n            double hb = H1 * b;\n            for (int j = 1; j < numberOfPoints; j++) {\n                // Compute H[j+1](a) and H[j+1](b)\n                final double jp1 = j + 1;\n                final double s = FastMath.sqrt(2 / jp1);\n                final double sm = FastMath.sqrt(j / jp1);\n                final double hpa = s * a * ha - sm * hma;\n                final double hpb = s * b * hb - sm * hmb;\n                hma = ha;\n                ha = hpa;\n                hmb = hb;\n                hb = hpb;\n            }\n\n            // Now ha = H[n+1](a), and hma = H[n](a) (same holds for b).\n            // Middle of the interval.\n            double c = 0.5 * (a + b);\n            // P[j-1](c)\n            double hmc = H0;\n            // P[j](c)\n            double hc = H1 * c;\n            boolean done = false;\n            while (!done) {\n                done = b - a <= Math.ulp(c);\n                hmc = H0;\n                hc = H1 * c;\n                for (int j = 1; j < numberOfPoints; j++) {\n                    // Compute H[j+1](c)\n                    final double jp1 = j + 1;\n                    final double s = FastMath.sqrt(2 / jp1);\n                    final double sm = FastMath.sqrt(j / jp1);\n                    final double hpc = s * c * hc - sm * hmc;\n                    hmc = hc;\n                    hc = hpc;\n                }\n                // Now h = H[n+1](c) and hm = H[n](c).\n                if (!done) {\n                    if (ha * hc < 0) {\n                        b = c;\n                        hmb = hmc;\n                        hb = hc;\n                    } else {\n                        a = c;\n                        hma = hmc;\n                        ha = hc;\n                    }\n                    c = 0.5 * (a + b);\n                }\n            }\n            final double d = sqrtTwoTimesNumPoints * hmc;\n            final double w = 2 / (d * d);\n\n            points[i] = c;\n            weights[i] = w;\n\n            final int idx = lastNumPoints - i;\n = +c;\n            weights[idx] = w;\n        }\n\n        // If \"numberOfPoints\" is odd, 0 is a root.\n        // Note: as written, the test for oddness will work for negative\n        // integers too (although it is not necessary here), preventing\n        // a FindBugs warning.\n        if (numberOfPoints % 2 != 0) {\n            double hm = H0;\n            for (int j = 1; j < numberOfPoints; j += 2) {\n                final double jp1 = j + 1;\n                hm = -FastMath.sqrt(j / jp1) * hm;\n            }\n            final double d = sqrtTwoTimesNumPoints * hm;\n            final double w = 2 / (d * d);\n\n            points[iMax] = 0d;\n            weights[iMax] = w;\n        }\n\n        return new Pair<Double[], Double[]>(points, weights);\n    }",
          "5": "    protected Pair<Double[], Double[]> computeRule(int numberOfPoints)\n        throws DimensionMismatchException {\n\n        if (numberOfPoints == 1) {\n            // Break recursion.\n            return new Pair<Double[], Double[]>(new Double[] { 0d },\n                                                new Double[] { SQRT_PI });\n        }\n\n        // Get previous rule.\n        // If it has not been computed yet it will trigger a recursive call\n        // to this method.\n        final int lastNumPoints = numberOfPoints - 1;\n        final Double[] previousPoints = getRuleInternal(lastNumPoints).getFirst();\n\n        // Compute next rule.\n        final Double[] points = new Double[numberOfPoints];\n        final Double[] weights = new Double[numberOfPoints];\n\n        final double sqrtTwoTimesLastNumPoints = FastMath.sqrt(2 * lastNumPoints);\n        final double sqrtTwoTimesNumPoints = FastMath.sqrt(2 * numberOfPoints);\n\n        // Find i-th root of H[n+1] by bracketing.\n        final int iMax = numberOfPoints / 2;\n        for (int i = 0; i < iMax; i++) {\n            // Lower-bound of the interval.\n            double a = (i == 0) ? -sqrtTwoTimesLastNumPoints : previousPoints[i - 1].doubleValue();\n            // Upper-bound of the interval.\n            double b = (iMax == 1) ? -0.5 : previousPoints[i].doubleValue();\n\n            // H[j-1](a)\n            double hma = H0;\n            // H[j](a)\n            double ha = H1 * a;\n            // H[j-1](b)\n            double hmb = H0;\n            // H[j](b)\n            double hb = H1 * b;\n            for (int j = 1; j < numberOfPoints; j++) {\n                // Compute H[j+1](a) and H[j+1](b)\n                final double jp1 = j + 1;\n                final double s = FastMath.sqrt(2 / jp1);\n                final double sm = FastMath.sqrt(j / jp1);\n                final double hpa = s * a * ha - sm * hma;\n                final double hpb = s * b * hb - sm * hmb;\n                hma = ha;\n                ha = hpa;\n                hmb = hb;\n                hb = hpb;\n            }\n\n            // Now ha = H[n+1](a), and hma = H[n](a) (same holds for b).\n            // Middle of the interval.\n            double c = 0.5 * (a + b);\n            // P[j-1](c)\n            double hmc = H0;\n            // P[j](c)\n            double hc = H1 * c;\n            boolean done = false;\n            while (!done) {\n                done = b - a <= Math.ulp(c);\n                hmc = H0;\n                hc = H1 * c;\n                for (int j = 1; j < numberOfPoints; j++) {\n                    // Compute H[j+1](c)\n                    final double jp1 = j + 1;\n                    final double s = FastMath.sqrt(2 / jp1);\n                    final double sm = FastMath.sqrt(j / jp1);\n                    final double hpc = s * c * hc - sm * hmc;\n                    hmc = hc;\n                    hc = hpc;\n                }\n                // Now h = H[n+1](c) and hm = H[n](c).\n                if (!done) {\n                    if (ha * hc < 0) {\n                        b = c;\n                        hmb = hmc;\n                        hb = hc;\n                    } else {\n                        a = c;\n                        hma = hmc;\n                        ha = hc;\n                    }\n                    c = 0.5 * (a + b);\n                }\n            }\n            final double d = sqrtTwoTimesNumPoints * hmc;\n            final double w = 2 / (d * d);\n\n            points[i] = c;\n            weights[i] = w;\n\n            final int idx = lastNumPoints - i;\ne[idx] = +c;\n            weights[idx] = w;\n        }\n\n        // If \"numberOfPoints\" is odd, 0 is a root.\n        // Note: as written, the test for oddness will work for negative\n        // integers too (although it is not necessary here), preventing\n        // a FindBugs warning.\n        if (numberOfPoints % 2 != 0) {\n            double hm = H0;\n            for (int j = 1; j < numberOfPoints; j += 2) {\n                final double jp1 = j + 1;\n                hm = -FastMath.sqrt(j / jp1) * hm;\n            }\n            final double d = sqrtTwoTimesNumPoints * hm;\n            final double w = 2 / (d * d);\n\n            points[iMax] = 0d;\n            weights[iMax] = w;\n        }\n\n        return new Pair<Double[], Double[]>(points, weights);\n    }",
          "6": "    protected Pair<Double[], Double[]> computeRule(int numberOfPoints)\n        throws DimensionMismatchException {\n\n        if (numberOfPoints == 1) {\n            // Break recursion.\n            return new Pair<Double[], Double[]>(new Double[] { 0d },\n                                                new Double[] { SQRT_PI });\n        }\n\n        // Get previous rule.\n        // If it has not been computed yet it will trigger a recursive call\n        // to this method.\n        final int lastNumPoints = numberOfPoints - 1;\n        final Double[] previousPoints = getRuleInternal(lastNumPoints).getFirst();\n\n        // Compute next rule.\n        final Double[] points = new Double[numberOfPoints];\n        final Double[] weights = new Double[numberOfPoints];\n\n        final double sqrtTwoTimesLastNumPoints = FastMath.sqrt(2 * lastNumPoints);\n        final double sqrtTwoTimesNumPoints = FastMath.sqrt(2 * numberOfPoints);\n\n        // Find i-th root of H[n+1] by bracketing.\n        final int iMax = numberOfPoints / 2;\n        for (int i = 0; i < iMax; i++) {\n            // Lower-bound of the interval.\n            double a = (i == 0) ? -sqrtTwoTimesLastNumPoints : previousPoints[i - 1].doubleValue();\n            // Upper-bound of the interval.\n            double b = (iMax == 1) ? -0.5 : previousPoints[i].doubleValue();\n\n            // H[j-1](a)\n            double hma = H0;\n            // H[j](a)\n            double ha = H1 * a;\n            // H[j-1](b)\n            double hmb = H0;\n            // H[j](b)\n            double hb = H1 * b;\n            for (int j = 1; j < numberOfPoints; j++) {\n                // Compute H[j+1](a) and H[j+1](b)\n                final double jp1 = j + 1;\n                final double s = FastMath.sqrt(2 / jp1);\n                final double sm = FastMath.sqrt(j / jp1);\n                final double hpa = s * a * ha - sm * hma;\n                final double hpb = s * b * hb - sm * hmb;\n                hma = ha;\n                ha = hpa;\n                hmb = hb;\n                hb = hpb;\n            }\n\n            // Now ha = H[n+1](a), and hma = H[n](a) (same holds for b).\n            // Middle of the interval.\n            double c = 0.5 * (a + b);\n            // P[j-1](c)\n            double hmc = H0;\n            // P[j](c)\n            double hc = H1 * c;\n            boolean done = false;\n            while (!done) {\n                done = b - a <= Math.ulp(c);\n                hmc = H0;\n                hc = H1 * c;\n                for (int j = 1; j < numberOfPoints; j++) {\n                    // Compute H[j+1](c)\n                    final double jp1 = j + 1;\n                    final double s = FastMath.sqrt(2 / jp1);\n                    final double sm = FastMath.sqrt(j / jp1);\n                    final double hpc = s * c * hc - sm * hmc;\n                    hmc = hc;\n                    hc = hpc;\n                }\n                // Now h = H[n+1](c) and hm = H[n](c).\n                if (!done) {\n                    if (ha * hc < 0) {\n                        b = c;\n                        hmb = hmc;\n                        hb = hc;\n                    } else {\n                        a = c;\n                        hma = hmc;\n                        ha = hc;\n                    }\n                    c = 0.5 * (a + b);\n                }\n            }\n            final double d = sqrtTwoTimesNumPoints * hmc;\n            final double w = 2 / (d * d);\n\n            points[i] = c;\n            weights[i] = w;\n\n            final int idx = lastNumPoints - i;\npoints[idx] = idx;\n            weights[idx] = w;\n        }\n\n        // If \"numberOfPoints\" is odd, 0 is a root.\n        // Note: as written, the test for oddness will work for negative\n        // integers too (although it is not necessary here), preventing\n        // a FindBugs warning.\n        if (numberOfPoints % 2 != 0) {\n            double hm = H0;\n            for (int j = 1; j < numberOfPoints; j += 2) {\n                final double jp1 = j + 1;\n                hm = -FastMath.sqrt(j / jp1) * hm;\n            }\n            final double d = sqrtTwoTimesNumPoints * hm;\n            final double w = 2 / (d * d);\n\n            points[iMax] = 0d;\n            weights[iMax] = w;\n        }\n\n        return new Pair<Double[], Double[]>(points, weights);\n    }",
          "7": "    protected Pair<Double[], Double[]> computeRule(int numberOfPoints)\n        throws DimensionMismatchException {\n\n        if (numberOfPoints == 1) {\n            // Break recursion.\n            return new Pair<Double[], Double[]>(new Double[] { 0d },\n                                                new Double[] { SQRT_PI });\n        }\n\n        // Get previous rule.\n        // If it has not been computed yet it will trigger a recursive call\n        // to this method.\n        final int lastNumPoints = numberOfPoints - 1;\n        final Double[] previousPoints = getRuleInternal(lastNumPoints).getFirst();\n\n        // Compute next rule.\n        final Double[] points = new Double[numberOfPoints];\n        final Double[] weights = new Double[numberOfPoints];\n\n        final double sqrtTwoTimesLastNumPoints = FastMath.sqrt(2 * lastNumPoints);\n        final double sqrtTwoTimesNumPoints = FastMath.sqrt(2 * numberOfPoints);\n\n        // Find i-th root of H[n+1] by bracketing.\n        final int iMax = numberOfPoints / 2;\n        for (int i = 0; i < iMax; i++) {\n            // Lower-bound of the interval.\n            double a = (i == 0) ? -sqrtTwoTimesLastNumPoints : previousPoints[i - 1].doubleValue();\n            // Upper-bound of the interval.\n            double b = (iMax == 1) ? -0.5 : previousPoints[i].doubleValue();\n\n            // H[j-1](a)\n            double hma = H0;\n            // H[j](a)\n            double ha = H1 * a;\n            // H[j-1](b)\n            double hmb = H0;\n            // H[j](b)\n            double hb = H1 * b;\n            for (int j = 1; j < numberOfPoints; j++) {\n                // Compute H[j+1](a) and H[j+1](b)\n                final double jp1 = j + 1;\n                final double s = FastMath.sqrt(2 / jp1);\n                final double sm = FastMath.sqrt(j / jp1);\n                final double hpa = s * a * ha - sm * hma;\n                final double hpb = s * b * hb - sm * hmb;\n                hma = ha;\n                ha = hpa;\n                hmb = hb;\n                hb = hpb;\n            }\n\n            // Now ha = H[n+1](a), and hma = H[n](a) (same holds for b).\n            // Middle of the interval.\n            double c = 0.5 * (a + b);\n            // P[j-1](c)\n            double hmc = H0;\n            // P[j](c)\n            double hc = H1 * c;\n            boolean done = false;\n            while (!done) {\n                done = b - a <= Math.ulp(c);\n                hmc = H0;\n                hc = H1 * c;\n                for (int j = 1; j < numberOfPoints; j++) {\n                    // Compute H[j+1](c)\n                    final double jp1 = j + 1;\n                    final double s = FastMath.sqrt(2 / jp1);\n                    final double sm = FastMath.sqrt(j / jp1);\n                    final double hpc = s * c * hc - sm * hmc;\n                    hmc = hc;\n                    hc = hpc;\n                }\n                // Now h = H[n+1](c) and hm = H[n](c).\n                if (!done) {\n                    if (ha * hc < 0) {\n                        b = c;\n                        hmb = hmc;\n                        hb = hc;\n                    } else {\n                        a = c;\n                        hma = hmc;\n                        ha = hc;\n                    }\n                    c = 0.5 * (a + b);\n                }\n            }\n            final double d = sqrtTwoTimesNumPoints * hmc;\n            final double w = 2 / (d * d);\n\n            points[i] = c;\n            weights[i] = w;\n\n            final int idx = lastNumPoints - i;\npoints[idx] = +c;\n            weights[idx] = w;\n        }\n\n        // If \"numberOfPoints\" is odd, 0 is a root.\n        // Note: as written, the test for oddness will work for negative\n        // integers too (although it is not necessary here), preventing\n        // a FindBugs warning.\n        if (numberOfPoints % 2 != 0) {\n            double hm = H0;\n            for (int j = 1; j < numberOfPoints; j += 2) {\n                final double jp1 = j + 1;\n                hm = -FastMath.sqrt(j / jp1) * hm;\n            }\n            final double d = sqrtTwoTimesNumPoints * hm;\n            final double w = 2 / (d * d);\n\n            points[iMax] = 0d;\n            weights[iMax] = w;\n        }\n\n        return new Pair<Double[], Double[]>(points, weights);\n    }",
          "8": "    protected Pair<Double[], Double[]> computeRule(int numberOfPoints)\n        throws DimensionMismatchException {\n\n        if (numberOfPoints == 1) {\n            // Break recursion.\n            return new Pair<Double[], Double[]>(new Double[] { 0d },\n                                                new Double[] { SQRT_PI });\n        }\n\n        // Get previous rule.\n        // If it has not been computed yet it will trigger a recursive call\n        // to this method.\n        final int lastNumPoints = numberOfPoints - 1;\n        final Double[] previousPoints = getRuleInternal(lastNumPoints).getFirst();\n\n        // Compute next rule.\n        final Double[] points = new Double[numberOfPoints];\n        final Double[] weights = new Double[numberOfPoints];\n\n        final double sqrtTwoTimesLastNumPoints = FastMath.sqrt(2 * lastNumPoints);\n        final double sqrtTwoTimesNumPoints = FastMath.sqrt(2 * numberOfPoints);\n\n        // Find i-th root of H[n+1] by bracketing.\n        final int iMax = numberOfPoints / 2;\n        for (int i = 0; i < iMax; i++) {\n            // Lower-bound of the interval.\n            double a = (i == 0) ? -sqrtTwoTimesLastNumPoints : previousPoints[i - 1].doubleValue();\n            // Upper-bound of the interval.\n            double b = (iMax == 1) ? -0.5 : previousPoints[i].doubleValue();\n\n            // H[j-1](a)\n            double hma = H0;\n            // H[j](a)\n            double ha = H1 * a;\n            // H[j-1](b)\n            double hmb = H0;\n            // H[j](b)\n            double hb = H1 * b;\n            for (int j = 1; j < numberOfPoints; j++) {\n                // Compute H[j+1](a) and H[j+1](b)\n                final double jp1 = j + 1;\n                final double s = FastMath.sqrt(2 / jp1);\n                final double sm = FastMath.sqrt(j / jp1);\n                final double hpa = s * a * ha - sm * hma;\n                final double hpb = s * b * hb - sm * hmb;\n                hma = ha;\n                ha = hpa;\n                hmb = hb;\n                hb = hpb;\n            }\n\n            // Now ha = H[n+1](a), and hma = H[n](a) (same holds for b).\n            // Middle of the interval.\n            double c = 0.5 * (a + b);\n            // P[j-1](c)\n            double hmc = H0;\n            // P[j](c)\n            double hc = H1 * c;\n            boolean done = false;\n            while (!done) {\n                done = b - a <= Math.ulp(c);\n                hmc = H0;\n                hc = H1 * c;\n                for (int j = 1; j < numberOfPoints; j++) {\n                    // Compute H[j+1](c)\n                    final double jp1 = j + 1;\n                    final double s = FastMath.sqrt(2 / jp1);\n                    final double sm = FastMath.sqrt(j / jp1);\n                    final double hpc = s * c * hc - sm * hmc;\n                    hmc = hc;\n                    hc = hpc;\n                }\n                // Now h = H[n+1](c) and hm = H[n](c).\n                if (!done) {\n                    if (ha * hc < 0) {\n                        b = c;\n                        hmb = hmc;\n                        hb = hc;\n                    } else {\n                        a = c;\n                        hma = hmc;\n                        ha = hc;\n                    }\n                    c = 0.5 * (a + b);\n                }\n            }\n            final double d = sqrtTwoTimesNumPoints * hmc;\n            final double w = 2 / (d * d);\n\n            points[i] = c;\n            weights[i] = w;\n\n            final int idx = lastNumPoints - i;\nc[idx] = +c;\n            weights[idx] = w;\n        }\n\n        // If \"numberOfPoints\" is odd, 0 is a root.\n        // Note: as written, the test for oddness will work for negative\n        // integers too (although it is not necessary here), preventing\n        // a FindBugs warning.\n        if (numberOfPoints % 2 != 0) {\n            double hm = H0;\n            for (int j = 1; j < numberOfPoints; j += 2) {\n                final double jp1 = j + 1;\n                hm = -FastMath.sqrt(j / jp1) * hm;\n            }\n            final double d = sqrtTwoTimesNumPoints * hm;\n            final double w = 2 / (d * d);\n\n            points[iMax] = 0d;\n            weights[iMax] = w;\n        }\n\n        return new Pair<Double[], Double[]>(points, weights);\n    }",
          "9": "    protected Pair<Double[], Double[]> computeRule(int numberOfPoints)\n        throws DimensionMismatchException {\n\n        if (numberOfPoints == 1) {\n            // Break recursion.\n            return new Pair<Double[], Double[]>(new Double[] { 0d },\n                                                new Double[] { SQRT_PI });\n        }\n\n        // Get previous rule.\n        // If it has not been computed yet it will trigger a recursive call\n        // to this method.\n        final int lastNumPoints = numberOfPoints - 1;\n        final Double[] previousPoints = getRuleInternal(lastNumPoints).getFirst();\n\n        // Compute next rule.\n        final Double[] points = new Double[numberOfPoints];\n        final Double[] weights = new Double[numberOfPoints];\n\n        final double sqrtTwoTimesLastNumPoints = FastMath.sqrt(2 * lastNumPoints);\n        final double sqrtTwoTimesNumPoints = FastMath.sqrt(2 * numberOfPoints);\n\n        // Find i-th root of H[n+1] by bracketing.\n        final int iMax = numberOfPoints / 2;\n        for (int i = 0; i < iMax; i++) {\n            // Lower-bound of the interval.\n            double a = (i == 0) ? -sqrtTwoTimesLastNumPoints : previousPoints[i - 1].doubleValue();\n            // Upper-bound of the interval.\n            double b = (iMax == 1) ? -0.5 : previousPoints[i].doubleValue();\n\n            // H[j-1](a)\n            double hma = H0;\n            // H[j](a)\n            double ha = H1 * a;\n            // H[j-1](b)\n            double hmb = H0;\n            // H[j](b)\n            double hb = H1 * b;\n            for (int j = 1; j < numberOfPoints; j++) {\n                // Compute H[j+1](a) and H[j+1](b)\n                final double jp1 = j + 1;\n                final double s = FastMath.sqrt(2 / jp1);\n                final double sm = FastMath.sqrt(j / jp1);\n                final double hpa = s * a * ha - sm * hma;\n                final double hpb = s * b * hb - sm * hmb;\n                hma = ha;\n                ha = hpa;\n                hmb = hb;\n                hb = hpb;\n            }\n\n            // Now ha = H[n+1](a), and hma = H[n](a) (same holds for b).\n            // Middle of the interval.\n            double c = 0.5 * (a + b);\n            // P[j-1](c)\n            double hmc = H0;\n            // P[j](c)\n            double hc = H1 * c;\n            boolean done = false;\n            while (!done) {\n                done = b - a <= Math.ulp(c);\n                hmc = H0;\n                hc = H1 * c;\n                for (int j = 1; j < numberOfPoints; j++) {\n                    // Compute H[j+1](c)\n                    final double jp1 = j + 1;\n                    final double s = FastMath.sqrt(2 / jp1);\n                    final double sm = FastMath.sqrt(j / jp1);\n                    final double hpc = s * c * hc - sm * hmc;\n                    hmc = hc;\n                    hc = hpc;\n                }\n                // Now h = H[n+1](c) and hm = H[n](c).\n                if (!done) {\n                    if (ha * hc < 0) {\n                        b = c;\n                        hmb = hmc;\n                        hb = hc;\n                    } else {\n                        a = c;\n                        hma = hmc;\n                        ha = hc;\n                    }\n                    c = 0.5 * (a + b);\n                }\n            }\n            final double d = sqrtTwoTimesNumPoints * hmc;\n            final double w = 2 / (d * d);\n\n            points[i] = c;\n            weights[i] = w;\n\n            final int idx = lastNumPoints - i;\npoints = +c;\n            weights[idx] = w;\n        }\n\n        // If \"numberOfPoints\" is odd, 0 is a root.\n        // Note: as written, the test for oddness will work for negative\n        // integers too (although it is not necessary here), preventing\n        // a FindBugs warning.\n        if (numberOfPoints % 2 != 0) {\n            double hm = H0;\n            for (int j = 1; j < numberOfPoints; j += 2) {\n                final double jp1 = j + 1;\n                hm = -FastMath.sqrt(j / jp1) * hm;\n            }\n            final double d = sqrtTwoTimesNumPoints * hm;\n            final double w = 2 / (d * d);\n\n            points[iMax] = 0d;\n            weights[iMax] = w;\n        }\n\n        return new Pair<Double[], Double[]>(points, weights);\n    }",
          "10": "    protected Pair<Double[], Double[]> computeRule(int numberOfPoints)\n        throws DimensionMismatchException {\n\n        if (numberOfPoints == 1) {\n            // Break recursion.\n            return new Pair<Double[], Double[]>(new Double[] { 0d },\n                                                new Double[] { SQRT_PI });\n        }\n\n        // Get previous rule.\n        // If it has not been computed yet it will trigger a recursive call\n        // to this method.\n        final int lastNumPoints = numberOfPoints - 1;\n        final Double[] previousPoints = getRuleInternal(lastNumPoints).getFirst();\n\n        // Compute next rule.\n        final Double[] points = new Double[numberOfPoints];\n        final Double[] weights = new Double[numberOfPoints];\n\n        final double sqrtTwoTimesLastNumPoints = FastMath.sqrt(2 * lastNumPoints);\n        final double sqrtTwoTimesNumPoints = FastMath.sqrt(2 * numberOfPoints);\n\n        // Find i-th root of H[n+1] by bracketing.\n        final int iMax = numberOfPoints / 2;\n        for (int i = 0; i < iMax; i++) {\n            // Lower-bound of the interval.\n            double a = (i == 0) ? -sqrtTwoTimesLastNumPoints : previousPoints[i - 1].doubleValue();\n            // Upper-bound of the interval.\n            double b = (iMax == 1) ? -0.5 : previousPoints[i].doubleValue();\n\n            // H[j-1](a)\n            double hma = H0;\n            // H[j](a)\n            double ha = H1 * a;\n            // H[j-1](b)\n            double hmb = H0;\n            // H[j](b)\n            double hb = H1 * b;\n            for (int j = 1; j < numberOfPoints; j++) {\n                // Compute H[j+1](a) and H[j+1](b)\n                final double jp1 = j + 1;\n                final double s = FastMath.sqrt(2 / jp1);\n                final double sm = FastMath.sqrt(j / jp1);\n                final double hpa = s * a * ha - sm * hma;\n                final double hpb = s * b * hb - sm * hmb;\n                hma = ha;\n                ha = hpa;\n                hmb = hb;\n                hb = hpb;\n            }\n\n            // Now ha = H[n+1](a), and hma = H[n](a) (same holds for b).\n            // Middle of the interval.\n            double c = 0.5 * (a + b);\n            // P[j-1](c)\n            double hmc = H0;\n            // P[j](c)\n            double hc = H1 * c;\n            boolean done = false;\n            while (!done) {\n                done = b - a <= Math.ulp(c);\n                hmc = H0;\n                hc = H1 * c;\n                for (int j = 1; j < numberOfPoints; j++) {\n                    // Compute H[j+1](c)\n                    final double jp1 = j + 1;\n                    final double s = FastMath.sqrt(2 / jp1);\n                    final double sm = FastMath.sqrt(j / jp1);\n                    final double hpc = s * c * hc - sm * hmc;\n                    hmc = hc;\n                    hc = hpc;\n                }\n                // Now h = H[n+1](c) and hm = H[n](c).\n                if (!done) {\n                    if (ha * hc < 0) {\n                        b = c;\n                        hmb = hmc;\n                        hb = hc;\n                    } else {\n                        a = c;\n                        hma = hmc;\n                        ha = hc;\n                    }\n                    c = 0.5 * (a + b);\n                }\n            }\n            final double d = sqrtTwoTimesNumPoints * hmc;\n            final double w = 2 / (d * d);\n\n            points[i] = c;\n            weights[i] = w;\n\n            final int idx = lastNumPoints - i;\n-points = +c;\n            weights[idx] = w;\n        }\n\n        // If \"numberOfPoints\" is odd, 0 is a root.\n        // Note: as written, the test for oddness will work for negative\n        // integers too (although it is not necessary here), preventing\n        // a FindBugs warning.\n        if (numberOfPoints % 2 != 0) {\n            double hm = H0;\n            for (int j = 1; j < numberOfPoints; j += 2) {\n                final double jp1 = j + 1;\n                hm = -FastMath.sqrt(j / jp1) * hm;\n            }\n            final double d = sqrtTwoTimesNumPoints * hm;\n            final double w = 2 / (d * d);\n\n            points[iMax] = 0d;\n            weights[iMax] = w;\n        }\n\n        return new Pair<Double[], Double[]>(points, weights);\n    }",
          "11": "    protected Pair<Double[], Double[]> computeRule(int numberOfPoints)\n        throws DimensionMismatchException {\n\n        if (numberOfPoints == 1) {\n            // Break recursion.\n            return new Pair<Double[], Double[]>(new Double[] { 0d },\n                                                new Double[] { SQRT_PI });\n        }\n\n        // Get previous rule.\n        // If it has not been computed yet it will trigger a recursive call\n        // to this method.\n        final int lastNumPoints = numberOfPoints - 1;\n        final Double[] previousPoints = getRuleInternal(lastNumPoints).getFirst();\n\n        // Compute next rule.\n        final Double[] points = new Double[numberOfPoints];\n        final Double[] weights = new Double[numberOfPoints];\n\n        final double sqrtTwoTimesLastNumPoints = FastMath.sqrt(2 * lastNumPoints);\n        final double sqrtTwoTimesNumPoints = FastMath.sqrt(2 * numberOfPoints);\n\n        // Find i-th root of H[n+1] by bracketing.\n        final int iMax = numberOfPoints / 2;\n        for (int i = 0; i < iMax; i++) {\n            // Lower-bound of the interval.\n            double a = (i == 0) ? -sqrtTwoTimesLastNumPoints : previousPoints[i - 1].doubleValue();\n            // Upper-bound of the interval.\n            double b = (iMax == 1) ? -0.5 : previousPoints[i].doubleValue();\n\n            // H[j-1](a)\n            double hma = H0;\n            // H[j](a)\n            double ha = H1 * a;\n            // H[j-1](b)\n            double hmb = H0;\n            // H[j](b)\n            double hb = H1 * b;\n            for (int j = 1; j < numberOfPoints; j++) {\n                // Compute H[j+1](a) and H[j+1](b)\n                final double jp1 = j + 1;\n                final double s = FastMath.sqrt(2 / jp1);\n                final double sm = FastMath.sqrt(j / jp1);\n                final double hpa = s * a * ha - sm * hma;\n                final double hpb = s * b * hb - sm * hmb;\n                hma = ha;\n                ha = hpa;\n                hmb = hb;\n                hb = hpb;\n            }\n\n            // Now ha = H[n+1](a), and hma = H[n](a) (same holds for b).\n            // Middle of the interval.\n            double c = 0.5 * (a + b);\n            // P[j-1](c)\n            double hmc = H0;\n            // P[j](c)\n            double hc = H1 * c;\n            boolean done = false;\n            while (!done) {\n                done = b - a <= Math.ulp(c);\n                hmc = H0;\n                hc = H1 * c;\n                for (int j = 1; j < numberOfPoints; j++) {\n                    // Compute H[j+1](c)\n                    final double jp1 = j + 1;\n                    final double s = FastMath.sqrt(2 / jp1);\n                    final double sm = FastMath.sqrt(j / jp1);\n                    final double hpc = s * c * hc - sm * hmc;\n                    hmc = hc;\n                    hc = hpc;\n                }\n                // Now h = H[n+1](c) and hm = H[n](c).\n                if (!done) {\n                    if (ha * hc < 0) {\n                        b = c;\n                        hmb = hmc;\n                        hb = hc;\n                    } else {\n                        a = c;\n                        hma = hmc;\n                        ha = hc;\n                    }\n                    c = 0.5 * (a + b);\n                }\n            }\n            final double d = sqrtTwoTimesNumPoints * hmc;\n            final double w = 2 / (d * d);\n\n            points[i] = c;\n            weights[i] = w;\n\n            final int idx = lastNumPoints - i;\ni = +c;\n            weights[idx] = w;\n        }\n\n        // If \"numberOfPoints\" is odd, 0 is a root.\n        // Note: as written, the test for oddness will work for negative\n        // integers too (although it is not necessary here), preventing\n        // a FindBugs warning.\n        if (numberOfPoints % 2 != 0) {\n            double hm = H0;\n            for (int j = 1; j < numberOfPoints; j += 2) {\n                final double jp1 = j + 1;\n                hm = -FastMath.sqrt(j / jp1) * hm;\n            }\n            final double d = sqrtTwoTimesNumPoints * hm;\n            final double w = 2 / (d * d);\n\n            points[iMax] = 0d;\n            weights[iMax] = w;\n        }\n\n        return new Pair<Double[], Double[]>(points, weights);\n    }",
          "12": "    protected Pair<Double[], Double[]> computeRule(int numberOfPoints)\n        throws DimensionMismatchException {\n\n        if (numberOfPoints == 1) {\n            // Break recursion.\n            return new Pair<Double[], Double[]>(new Double[] { 0d },\n                                                new Double[] { SQRT_PI });\n        }\n\n        // Get previous rule.\n        // If it has not been computed yet it will trigger a recursive call\n        // to this method.\n        final int lastNumPoints = numberOfPoints - 1;\n        final Double[] previousPoints = getRuleInternal(lastNumPoints).getFirst();\n\n        // Compute next rule.\n        final Double[] points = new Double[numberOfPoints];\n        final Double[] weights = new Double[numberOfPoints];\n\n        final double sqrtTwoTimesLastNumPoints = FastMath.sqrt(2 * lastNumPoints);\n        final double sqrtTwoTimesNumPoints = FastMath.sqrt(2 * numberOfPoints);\n\n        // Find i-th root of H[n+1] by bracketing.\n        final int iMax = numberOfPoints / 2;\n        for (int i = 0; i < iMax; i++) {\n            // Lower-bound of the interval.\n            double a = (i == 0) ? -sqrtTwoTimesLastNumPoints : previousPoints[i - 1].doubleValue();\n            // Upper-bound of the interval.\n            double b = (iMax == 1) ? -0.5 : previousPoints[i].doubleValue();\n\n            // H[j-1](a)\n            double hma = H0;\n            // H[j](a)\n            double ha = H1 * a;\n            // H[j-1](b)\n            double hmb = H0;\n            // H[j](b)\n            double hb = H1 * b;\n            for (int j = 1; j < numberOfPoints; j++) {\n                // Compute H[j+1](a) and H[j+1](b)\n                final double jp1 = j + 1;\n                final double s = FastMath.sqrt(2 / jp1);\n                final double sm = FastMath.sqrt(j / jp1);\n                final double hpa = s * a * ha - sm * hma;\n                final double hpb = s * b * hb - sm * hmb;\n                hma = ha;\n                ha = hpa;\n                hmb = hb;\n                hb = hpb;\n            }\n\n            // Now ha = H[n+1](a), and hma = H[n](a) (same holds for b).\n            // Middle of the interval.\n            double c = 0.5 * (a + b);\n            // P[j-1](c)\n            double hmc = H0;\n            // P[j](c)\n            double hc = H1 * c;\n            boolean done = false;\n            while (!done) {\n                done = b - a <= Math.ulp(c);\n                hmc = H0;\n                hc = H1 * c;\n                for (int j = 1; j < numberOfPoints; j++) {\n                    // Compute H[j+1](c)\n                    final double jp1 = j + 1;\n                    final double s = FastMath.sqrt(2 / jp1);\n                    final double sm = FastMath.sqrt(j / jp1);\n                    final double hpc = s * c * hc - sm * hmc;\n                    hmc = hc;\n                    hc = hpc;\n                }\n                // Now h = H[n+1](c) and hm = H[n](c).\n                if (!done) {\n                    if (ha * hc < 0) {\n                        b = c;\n                        hmb = hmc;\n                        hb = hc;\n                    } else {\n                        a = c;\n                        hma = hmc;\n                        ha = hc;\n                    }\n                    c = 0.5 * (a + b);\n                }\n            }\n            final double d = sqrtTwoTimesNumPoints * hmc;\n            final double w = 2 / (d * d);\n\n            points[i] = c;\n            weights[i] = w;\n\n            final int idx = lastNumPoints - i;\npoints[idx] = points;\n            weights[idx] = w;\n        }\n\n        // If \"numberOfPoints\" is odd, 0 is a root.\n        // Note: as written, the test for oddness will work for negative\n        // integers too (although it is not necessary here), preventing\n        // a FindBugs warning.\n        if (numberOfPoints % 2 != 0) {\n            double hm = H0;\n            for (int j = 1; j < numberOfPoints; j += 2) {\n                final double jp1 = j + 1;\n                hm = -FastMath.sqrt(j / jp1) * hm;\n            }\n            final double d = sqrtTwoTimesNumPoints * hm;\n            final double w = 2 / (d * d);\n\n            points[iMax] = 0d;\n            weights[iMax] = w;\n        }\n\n        return new Pair<Double[], Double[]>(points, weights);\n    }",
          "13": "    protected Pair<Double[], Double[]> computeRule(int numberOfPoints)\n        throws DimensionMismatchException {\n\n        if (numberOfPoints == 1) {\n            // Break recursion.\n            return new Pair<Double[], Double[]>(new Double[] { 0d },\n                                                new Double[] { SQRT_PI });\n        }\n\n        // Get previous rule.\n        // If it has not been computed yet it will trigger a recursive call\n        // to this method.\n        final int lastNumPoints = numberOfPoints - 1;\n        final Double[] previousPoints = getRuleInternal(lastNumPoints).getFirst();\n\n        // Compute next rule.\n        final Double[] points = new Double[numberOfPoints];\n        final Double[] weights = new Double[numberOfPoints];\n\n        final double sqrtTwoTimesLastNumPoints = FastMath.sqrt(2 * lastNumPoints);\n        final double sqrtTwoTimesNumPoints = FastMath.sqrt(2 * numberOfPoints);\n\n        // Find i-th root of H[n+1] by bracketing.\n        final int iMax = numberOfPoints / 2;\n        for (int i = 0; i < iMax; i++) {\n            // Lower-bound of the interval.\n            double a = (i == 0) ? -sqrtTwoTimesLastNumPoints : previousPoints[i - 1].doubleValue();\n            // Upper-bound of the interval.\n            double b = (iMax == 1) ? -0.5 : previousPoints[i].doubleValue();\n\n            // H[j-1](a)\n            double hma = H0;\n            // H[j](a)\n            double ha = H1 * a;\n            // H[j-1](b)\n            double hmb = H0;\n            // H[j](b)\n            double hb = H1 * b;\n            for (int j = 1; j < numberOfPoints; j++) {\n                // Compute H[j+1](a) and H[j+1](b)\n                final double jp1 = j + 1;\n                final double s = FastMath.sqrt(2 / jp1);\n                final double sm = FastMath.sqrt(j / jp1);\n                final double hpa = s * a * ha - sm * hma;\n                final double hpb = s * b * hb - sm * hmb;\n                hma = ha;\n                ha = hpa;\n                hmb = hb;\n                hb = hpb;\n            }\n\n            // Now ha = H[n+1](a), and hma = H[n](a) (same holds for b).\n            // Middle of the interval.\n            double c = 0.5 * (a + b);\n            // P[j-1](c)\n            double hmc = H0;\n            // P[j](c)\n            double hc = H1 * c;\n            boolean done = false;\n            while (!done) {\n                done = b - a <= Math.ulp(c);\n                hmc = H0;\n                hc = H1 * c;\n                for (int j = 1; j < numberOfPoints; j++) {\n                    // Compute H[j+1](c)\n                    final double jp1 = j + 1;\n                    final double s = FastMath.sqrt(2 / jp1);\n                    final double sm = FastMath.sqrt(j / jp1);\n                    final double hpc = s * c * hc - sm * hmc;\n                    hmc = hc;\n                    hc = hpc;\n                }\n                // Now h = H[n+1](c) and hm = H[n](c).\n                if (!done) {\n                    if (ha * hc < 0) {\n                        b = c;\n                        hmb = hmc;\n                        hb = hc;\n                    } else {\n                        a = c;\n                        hma = hmc;\n                        ha = hc;\n                    }\n                    c = 0.5 * (a + b);\n                }\n            }\n            final double d = sqrtTwoTimesNumPoints * hmc;\n            final double w = 2 / (d * d);\n\n            points[i] = c;\n            weights[i] = w;\n\n            final int idx = lastNumPoints - i;\npoints[idx] = c;\n            weights[idx] = w;\n        }\n\n        // If \"numberOfPoints\" is odd, 0 is a root.\n        // Note: as written, the test for oddness will work for negative\n        // integers too (although it is not necessary here), preventing\n        // a FindBugs warning.\n        if (numberOfPoints % 2 != 0) {\n            double hm = H0;\n            for (int j = 1; j < numberOfPoints; j += 2) {\n                final double jp1 = j + 1;\n                hm = -FastMath.sqrt(j / jp1) * hm;\n            }\n            final double d = sqrtTwoTimesNumPoints * hm;\n            final double w = 2 / (d * d);\n\n            points[iMax] = 0d;\n            weights[iMax] = w;\n        }\n\n        return new Pair<Double[], Double[]>(points, weights);\n    }",
          "14": "    protected Pair<Double[], Double[]> computeRule(int numberOfPoints)\n        throws DimensionMismatchException {\n\n        if (numberOfPoints == 1) {\n            // Break recursion.\n            return new Pair<Double[], Double[]>(new Double[] { 0d },\n                                                new Double[] { SQRT_PI });\n        }\n\n        // Get previous rule.\n        // If it has not been computed yet it will trigger a recursive call\n        // to this method.\n        final int lastNumPoints = numberOfPoints - 1;\n        final Double[] previousPoints = getRuleInternal(lastNumPoints).getFirst();\n\n        // Compute next rule.\n        final Double[] points = new Double[numberOfPoints];\n        final Double[] weights = new Double[numberOfPoints];\n\n        final double sqrtTwoTimesLastNumPoints = FastMath.sqrt(2 * lastNumPoints);\n        final double sqrtTwoTimesNumPoints = FastMath.sqrt(2 * numberOfPoints);\n\n        // Find i-th root of H[n+1] by bracketing.\n        final int iMax = numberOfPoints / 2;\n        for (int i = 0; i < iMax; i++) {\n            // Lower-bound of the interval.\n            double a = (i == 0) ? -sqrtTwoTimesLastNumPoints : previousPoints[i - 1].doubleValue();\n            // Upper-bound of the interval.\n            double b = (iMax == 1) ? -0.5 : previousPoints[i].doubleValue();\n\n            // H[j-1](a)\n            double hma = H0;\n            // H[j](a)\n            double ha = H1 * a;\n            // H[j-1](b)\n            double hmb = H0;\n            // H[j](b)\n            double hb = H1 * b;\n            for (int j = 1; j < numberOfPoints; j++) {\n                // Compute H[j+1](a) and H[j+1](b)\n                final double jp1 = j + 1;\n                final double s = FastMath.sqrt(2 / jp1);\n                final double sm = FastMath.sqrt(j / jp1);\n                final double hpa = s * a * ha - sm * hma;\n                final double hpb = s * b * hb - sm * hmb;\n                hma = ha;\n                ha = hpa;\n                hmb = hb;\n                hb = hpb;\n            }\n\n            // Now ha = H[n+1](a), and hma = H[n](a) (same holds for b).\n            // Middle of the interval.\n            double c = 0.5 * (a + b);\n            // P[j-1](c)\n            double hmc = H0;\n            // P[j](c)\n            double hc = H1 * c;\n            boolean done = false;\n            while (!done) {\n                done = b - a <= Math.ulp(c);\n                hmc = H0;\n                hc = H1 * c;\n                for (int j = 1; j < numberOfPoints; j++) {\n                    // Compute H[j+1](c)\n                    final double jp1 = j + 1;\n                    final double s = FastMath.sqrt(2 / jp1);\n                    final double sm = FastMath.sqrt(j / jp1);\n                    final double hpc = s * c * hc - sm * hmc;\n                    hmc = hc;\n                    hc = hpc;\n                }\n                // Now h = H[n+1](c) and hm = H[n](c).\n                if (!done) {\n                    if (ha * hc < 0) {\n                        b = c;\n                        hmb = hmc;\n                        hb = hc;\n                    } else {\n                        a = c;\n                        hma = hmc;\n                        ha = hc;\n                    }\n                    c = 0.5 * (a + b);\n                }\n            }\n            final double d = sqrtTwoTimesNumPoints * hmc;\n            final double w = 2 / (d * d);\n\n            points[i] = c;\n            weights[i] = w;\n\n            final int idx = lastNumPoints - i;\ndebug[idx] = +c;\n            weights[idx] = w;\n        }\n\n        // If \"numberOfPoints\" is odd, 0 is a root.\n        // Note: as written, the test for oddness will work for negative\n        // integers too (although it is not necessary here), preventing\n        // a FindBugs warning.\n        if (numberOfPoints % 2 != 0) {\n            double hm = H0;\n            for (int j = 1; j < numberOfPoints; j += 2) {\n                final double jp1 = j + 1;\n                hm = -FastMath.sqrt(j / jp1) * hm;\n            }\n            final double d = sqrtTwoTimesNumPoints * hm;\n            final double w = 2 / (d * d);\n\n            points[iMax] = 0d;\n            weights[iMax] = w;\n        }\n\n        return new Pair<Double[], Double[]>(points, weights);\n    }",
          "15": "    protected Pair<Double[], Double[]> computeRule(int numberOfPoints)\n        throws DimensionMismatchException {\n\n        if (numberOfPoints == 1) {\n            // Break recursion.\n            return new Pair<Double[], Double[]>(new Double[] { 0d },\n                                                new Double[] { SQRT_PI });\n        }\n\n        // Get previous rule.\n        // If it has not been computed yet it will trigger a recursive call\n        // to this method.\n        final int lastNumPoints = numberOfPoints - 1;\n        final Double[] previousPoints = getRuleInternal(lastNumPoints).getFirst();\n\n        // Compute next rule.\n        final Double[] points = new Double[numberOfPoints];\n        final Double[] weights = new Double[numberOfPoints];\n\n        final double sqrtTwoTimesLastNumPoints = FastMath.sqrt(2 * lastNumPoints);\n        final double sqrtTwoTimesNumPoints = FastMath.sqrt(2 * numberOfPoints);\n\n        // Find i-th root of H[n+1] by bracketing.\n        final int iMax = numberOfPoints / 2;\n        for (int i = 0; i < iMax; i++) {\n            // Lower-bound of the interval.\n            double a = (i == 0) ? -sqrtTwoTimesLastNumPoints : previousPoints[i - 1].doubleValue();\n            // Upper-bound of the interval.\n            double b = (iMax == 1) ? -0.5 : previousPoints[i].doubleValue();\n\n            // H[j-1](a)\n            double hma = H0;\n            // H[j](a)\n            double ha = H1 * a;\n            // H[j-1](b)\n            double hmb = H0;\n            // H[j](b)\n            double hb = H1 * b;\n            for (int j = 1; j < numberOfPoints; j++) {\n                // Compute H[j+1](a) and H[j+1](b)\n                final double jp1 = j + 1;\n                final double s = FastMath.sqrt(2 / jp1);\n                final double sm = FastMath.sqrt(j / jp1);\n                final double hpa = s * a * ha - sm * hma;\n                final double hpb = s * b * hb - sm * hmb;\n                hma = ha;\n                ha = hpa;\n                hmb = hb;\n                hb = hpb;\n            }\n\n            // Now ha = H[n+1](a), and hma = H[n](a) (same holds for b).\n            // Middle of the interval.\n            double c = 0.5 * (a + b);\n            // P[j-1](c)\n            double hmc = H0;\n            // P[j](c)\n            double hc = H1 * c;\n            boolean done = false;\n            while (!done) {\n                done = b - a <= Math.ulp(c);\n                hmc = H0;\n                hc = H1 * c;\n                for (int j = 1; j < numberOfPoints; j++) {\n                    // Compute H[j+1](c)\n                    final double jp1 = j + 1;\n                    final double s = FastMath.sqrt(2 / jp1);\n                    final double sm = FastMath.sqrt(j / jp1);\n                    final double hpc = s * c * hc - sm * hmc;\n                    hmc = hc;\n                    hc = hpc;\n                }\n                // Now h = H[n+1](c) and hm = H[n](c).\n                if (!done) {\n                    if (ha * hc < 0) {\n                        b = c;\n                        hmb = hmc;\n                        hb = hc;\n                    } else {\n                        a = c;\n                        hma = hmc;\n                        ha = hc;\n                    }\n                    c = 0.5 * (a + b);\n                }\n            }\n            final double d = sqrtTwoTimesNumPoints * hmc;\n            final double w = 2 / (d * d);\n\n            points[i] = c;\n            weights[i] = w;\n\n            final int idx = lastNumPoints - i;\nc = +c;\n            weights[idx] = w;\n        }\n\n        // If \"numberOfPoints\" is odd, 0 is a root.\n        // Note: as written, the test for oddness will work for negative\n        // integers too (although it is not necessary here), preventing\n        // a FindBugs warning.\n        if (numberOfPoints % 2 != 0) {\n            double hm = H0;\n            for (int j = 1; j < numberOfPoints; j += 2) {\n                final double jp1 = j + 1;\n                hm = -FastMath.sqrt(j / jp1) * hm;\n            }\n            final double d = sqrtTwoTimesNumPoints * hm;\n            final double w = 2 / (d * d);\n\n            points[iMax] = 0d;\n            weights[iMax] = w;\n        }\n\n        return new Pair<Double[], Double[]>(points, weights);\n    }",
          "16": "    protected Pair<Double[], Double[]> computeRule(int numberOfPoints)\n        throws DimensionMismatchException {\n\n        if (numberOfPoints == 1) {\n            // Break recursion.\n            return new Pair<Double[], Double[]>(new Double[] { 0d },\n                                                new Double[] { SQRT_PI });\n        }\n\n        // Get previous rule.\n        // If it has not been computed yet it will trigger a recursive call\n        // to this method.\n        final int lastNumPoints = numberOfPoints - 1;\n        final Double[] previousPoints = getRuleInternal(lastNumPoints).getFirst();\n\n        // Compute next rule.\n        final Double[] points = new Double[numberOfPoints];\n        final Double[] weights = new Double[numberOfPoints];\n\n        final double sqrtTwoTimesLastNumPoints = FastMath.sqrt(2 * lastNumPoints);\n        final double sqrtTwoTimesNumPoints = FastMath.sqrt(2 * numberOfPoints);\n\n        // Find i-th root of H[n+1] by bracketing.\n        final int iMax = numberOfPoints / 2;\n        for (int i = 0; i < iMax; i++) {\n            // Lower-bound of the interval.\n            double a = (i == 0) ? -sqrtTwoTimesLastNumPoints : previousPoints[i - 1].doubleValue();\n            // Upper-bound of the interval.\n            double b = (iMax == 1) ? -0.5 : previousPoints[i].doubleValue();\n\n            // H[j-1](a)\n            double hma = H0;\n            // H[j](a)\n            double ha = H1 * a;\n            // H[j-1](b)\n            double hmb = H0;\n            // H[j](b)\n            double hb = H1 * b;\n            for (int j = 1; j < numberOfPoints; j++) {\n                // Compute H[j+1](a) and H[j+1](b)\n                final double jp1 = j + 1;\n                final double s = FastMath.sqrt(2 / jp1);\n                final double sm = FastMath.sqrt(j / jp1);\n                final double hpa = s * a * ha - sm * hma;\n                final double hpb = s * b * hb - sm * hmb;\n                hma = ha;\n                ha = hpa;\n                hmb = hb;\n                hb = hpb;\n            }\n\n            // Now ha = H[n+1](a), and hma = H[n](a) (same holds for b).\n            // Middle of the interval.\n            double c = 0.5 * (a + b);\n            // P[j-1](c)\n            double hmc = H0;\n            // P[j](c)\n            double hc = H1 * c;\n            boolean done = false;\n            while (!done) {\n                done = b - a <= Math.ulp(c);\n                hmc = H0;\n                hc = H1 * c;\n                for (int j = 1; j < numberOfPoints; j++) {\n                    // Compute H[j+1](c)\n                    final double jp1 = j + 1;\n                    final double s = FastMath.sqrt(2 / jp1);\n                    final double sm = FastMath.sqrt(j / jp1);\n                    final double hpc = s * c * hc - sm * hmc;\n                    hmc = hc;\n                    hc = hpc;\n                }\n                // Now h = H[n+1](c) and hm = H[n](c).\n                if (!done) {\n                    if (ha * hc < 0) {\n                        b = c;\n                        hmb = hmc;\n                        hb = hc;\n                    } else {\n                        a = c;\n                        hma = hmc;\n                        ha = hc;\n                    }\n                    c = 0.5 * (a + b);\n                }\n            }\n            final double d = sqrtTwoTimesNumPoints * hmc;\n            final double w = 2 / (d * d);\n\n            points[i] = c;\n            weights[i] = w;\n\n            final int idx = lastNumPoints - i;\n = +c;\n            weights[idx] = w;\n        }\n\n        // If \"numberOfPoints\" is odd, 0 is a root.\n        // Note: as written, the test for oddness will work for negative\n        // integers too (although it is not necessary here), preventing\n        // a FindBugs warning.\n        if (numberOfPoints % 2 != 0) {\n            double hm = H0;\n            for (int j = 1; j < numberOfPoints; j += 2) {\n                final double jp1 = j + 1;\n                hm = -FastMath.sqrt(j / jp1) * hm;\n            }\n            final double d = sqrtTwoTimesNumPoints * hm;\n            final double w = 2 / (d * d);\n\n            points[iMax] = 0d;\n            weights[iMax] = w;\n        }\n\n        return new Pair<Double[], Double[]>(points, weights);\n    }",
          "17": "    protected Pair<Double[], Double[]> computeRule(int numberOfPoints)\n        throws DimensionMismatchException {\n\n        if (numberOfPoints == 1) {\n            // Break recursion.\n            return new Pair<Double[], Double[]>(new Double[] { 0d },\n                                                new Double[] { SQRT_PI });\n        }\n\n        // Get previous rule.\n        // If it has not been computed yet it will trigger a recursive call\n        // to this method.\n        final int lastNumPoints = numberOfPoints - 1;\n        final Double[] previousPoints = getRuleInternal(lastNumPoints).getFirst();\n\n        // Compute next rule.\n        final Double[] points = new Double[numberOfPoints];\n        final Double[] weights = new Double[numberOfPoints];\n\n        final double sqrtTwoTimesLastNumPoints = FastMath.sqrt(2 * lastNumPoints);\n        final double sqrtTwoTimesNumPoints = FastMath.sqrt(2 * numberOfPoints);\n\n        // Find i-th root of H[n+1] by bracketing.\n        final int iMax = numberOfPoints / 2;\n        for (int i = 0; i < iMax; i++) {\n            // Lower-bound of the interval.\n            double a = (i == 0) ? -sqrtTwoTimesLastNumPoints : previousPoints[i - 1].doubleValue();\n            // Upper-bound of the interval.\n            double b = (iMax == 1) ? -0.5 : previousPoints[i].doubleValue();\n\n            // H[j-1](a)\n            double hma = H0;\n            // H[j](a)\n            double ha = H1 * a;\n            // H[j-1](b)\n            double hmb = H0;\n            // H[j](b)\n            double hb = H1 * b;\n            for (int j = 1; j < numberOfPoints; j++) {\n                // Compute H[j+1](a) and H[j+1](b)\n                final double jp1 = j + 1;\n                final double s = FastMath.sqrt(2 / jp1);\n                final double sm = FastMath.sqrt(j / jp1);\n                final double hpa = s * a * ha - sm * hma;\n                final double hpb = s * b * hb - sm * hmb;\n                hma = ha;\n                ha = hpa;\n                hmb = hb;\n                hb = hpb;\n            }\n\n            // Now ha = H[n+1](a), and hma = H[n](a) (same holds for b).\n            // Middle of the interval.\n            double c = 0.5 * (a + b);\n            // P[j-1](c)\n            double hmc = H0;\n            // P[j](c)\n            double hc = H1 * c;\n            boolean done = false;\n            while (!done) {\n                done = b - a <= Math.ulp(c);\n                hmc = H0;\n                hc = H1 * c;\n                for (int j = 1; j < numberOfPoints; j++) {\n                    // Compute H[j+1](c)\n                    final double jp1 = j + 1;\n                    final double s = FastMath.sqrt(2 / jp1);\n                    final double sm = FastMath.sqrt(j / jp1);\n                    final double hpc = s * c * hc - sm * hmc;\n                    hmc = hc;\n                    hc = hpc;\n                }\n                // Now h = H[n+1](c) and hm = H[n](c).\n                if (!done) {\n                    if (ha * hc < 0) {\n                        b = c;\n                        hmb = hmc;\n                        hb = hc;\n                    } else {\n                        a = c;\n                        hma = hmc;\n                        ha = hc;\n                    }\n                    c = 0.5 * (a + b);\n                }\n            }\n            final double d = sqrtTwoTimesNumPoints * hmc;\n            final double w = 2 / (d * d);\n\n            points[i] = c;\n            weights[i] = w;\n\n            final int idx = lastNumPoints - i;\nlastNumPoints[idx] = +c;\n            weights[idx] = w;\n        }\n\n        // If \"numberOfPoints\" is odd, 0 is a root.\n        // Note: as written, the test for oddness will work for negative\n        // integers too (although it is not necessary here), preventing\n        // a FindBugs warning.\n        if (numberOfPoints % 2 != 0) {\n            double hm = H0;\n            for (int j = 1; j < numberOfPoints; j += 2) {\n                final double jp1 = j + 1;\n                hm = -FastMath.sqrt(j / jp1) * hm;\n            }\n            final double d = sqrtTwoTimesNumPoints * hm;\n            final double w = 2 / (d * d);\n\n            points[iMax] = 0d;\n            weights[iMax] = w;\n        }\n\n        return new Pair<Double[], Double[]>(points, weights);\n    }",
          "18": "    protected Pair<Double[], Double[]> computeRule(int numberOfPoints)\n        throws DimensionMismatchException {\n\n        if (numberOfPoints == 1) {\n            // Break recursion.\n            return new Pair<Double[], Double[]>(new Double[] { 0d },\n                                                new Double[] { SQRT_PI });\n        }\n\n        // Get previous rule.\n        // If it has not been computed yet it will trigger a recursive call\n        // to this method.\n        final int lastNumPoints = numberOfPoints - 1;\n        final Double[] previousPoints = getRuleInternal(lastNumPoints).getFirst();\n\n        // Compute next rule.\n        final Double[] points = new Double[numberOfPoints];\n        final Double[] weights = new Double[numberOfPoints];\n\n        final double sqrtTwoTimesLastNumPoints = FastMath.sqrt(2 * lastNumPoints);\n        final double sqrtTwoTimesNumPoints = FastMath.sqrt(2 * numberOfPoints);\n\n        // Find i-th root of H[n+1] by bracketing.\n        final int iMax = numberOfPoints / 2;\n        for (int i = 0; i < iMax; i++) {\n            // Lower-bound of the interval.\n            double a = (i == 0) ? -sqrtTwoTimesLastNumPoints : previousPoints[i - 1].doubleValue();\n            // Upper-bound of the interval.\n            double b = (iMax == 1) ? -0.5 : previousPoints[i].doubleValue();\n\n            // H[j-1](a)\n            double hma = H0;\n            // H[j](a)\n            double ha = H1 * a;\n            // H[j-1](b)\n            double hmb = H0;\n            // H[j](b)\n            double hb = H1 * b;\n            for (int j = 1; j < numberOfPoints; j++) {\n                // Compute H[j+1](a) and H[j+1](b)\n                final double jp1 = j + 1;\n                final double s = FastMath.sqrt(2 / jp1);\n                final double sm = FastMath.sqrt(j / jp1);\n                final double hpa = s * a * ha - sm * hma;\n                final double hpb = s * b * hb - sm * hmb;\n                hma = ha;\n                ha = hpa;\n                hmb = hb;\n                hb = hpb;\n            }\n\n            // Now ha = H[n+1](a), and hma = H[n](a) (same holds for b).\n            // Middle of the interval.\n            double c = 0.5 * (a + b);\n            // P[j-1](c)\n            double hmc = H0;\n            // P[j](c)\n            double hc = H1 * c;\n            boolean done = false;\n            while (!done) {\n                done = b - a <= Math.ulp(c);\n                hmc = H0;\n                hc = H1 * c;\n                for (int j = 1; j < numberOfPoints; j++) {\n                    // Compute H[j+1](c)\n                    final double jp1 = j + 1;\n                    final double s = FastMath.sqrt(2 / jp1);\n                    final double sm = FastMath.sqrt(j / jp1);\n                    final double hpc = s * c * hc - sm * hmc;\n                    hmc = hc;\n                    hc = hpc;\n                }\n                // Now h = H[n+1](c) and hm = H[n](c).\n                if (!done) {\n                    if (ha * hc < 0) {\n                        b = c;\n                        hmb = hmc;\n                        hb = hc;\n                    } else {\n                        a = c;\n                        hma = hmc;\n                        ha = hc;\n                    }\n                    c = 0.5 * (a + b);\n                }\n            }\n            final double d = sqrtTwoTimesNumPoints * hmc;\n            final double w = 2 / (d * d);\n\n            points[i] = c;\n            weights[i] = w;\n\n            final int idx = lastNumPoints - i;\npoints[idx] = points[idx];\n            weights[idx] = w;\n        }\n\n        // If \"numberOfPoints\" is odd, 0 is a root.\n        // Note: as written, the test for oddness will work for negative\n        // integers too (although it is not necessary here), preventing\n        // a FindBugs warning.\n        if (numberOfPoints % 2 != 0) {\n            double hm = H0;\n            for (int j = 1; j < numberOfPoints; j += 2) {\n                final double jp1 = j + 1;\n                hm = -FastMath.sqrt(j / jp1) * hm;\n            }\n            final double d = sqrtTwoTimesNumPoints * hm;\n            final double w = 2 / (d * d);\n\n            points[iMax] = 0d;\n            weights[iMax] = w;\n        }\n\n        return new Pair<Double[], Double[]>(points, weights);\n    }",
          "19": "    protected Pair<Double[], Double[]> computeRule(int numberOfPoints)\n        throws DimensionMismatchException {\n\n        if (numberOfPoints == 1) {\n            // Break recursion.\n            return new Pair<Double[], Double[]>(new Double[] { 0d },\n                                                new Double[] { SQRT_PI });\n        }\n\n        // Get previous rule.\n        // If it has not been computed yet it will trigger a recursive call\n        // to this method.\n        final int lastNumPoints = numberOfPoints - 1;\n        final Double[] previousPoints = getRuleInternal(lastNumPoints).getFirst();\n\n        // Compute next rule.\n        final Double[] points = new Double[numberOfPoints];\n        final Double[] weights = new Double[numberOfPoints];\n\n        final double sqrtTwoTimesLastNumPoints = FastMath.sqrt(2 * lastNumPoints);\n        final double sqrtTwoTimesNumPoints = FastMath.sqrt(2 * numberOfPoints);\n\n        // Find i-th root of H[n+1] by bracketing.\n        final int iMax = numberOfPoints / 2;\n        for (int i = 0; i < iMax; i++) {\n            // Lower-bound of the interval.\n            double a = (i == 0) ? -sqrtTwoTimesLastNumPoints : previousPoints[i - 1].doubleValue();\n            // Upper-bound of the interval.\n            double b = (iMax == 1) ? -0.5 : previousPoints[i].doubleValue();\n\n            // H[j-1](a)\n            double hma = H0;\n            // H[j](a)\n            double ha = H1 * a;\n            // H[j-1](b)\n            double hmb = H0;\n            // H[j](b)\n            double hb = H1 * b;\n            for (int j = 1; j < numberOfPoints; j++) {\n                // Compute H[j+1](a) and H[j+1](b)\n                final double jp1 = j + 1;\n                final double s = FastMath.sqrt(2 / jp1);\n                final double sm = FastMath.sqrt(j / jp1);\n                final double hpa = s * a * ha - sm * hma;\n                final double hpb = s * b * hb - sm * hmb;\n                hma = ha;\n                ha = hpa;\n                hmb = hb;\n                hb = hpb;\n            }\n\n            // Now ha = H[n+1](a), and hma = H[n](a) (same holds for b).\n            // Middle of the interval.\n            double c = 0.5 * (a + b);\n            // P[j-1](c)\n            double hmc = H0;\n            // P[j](c)\n            double hc = H1 * c;\n            boolean done = false;\n            while (!done) {\n                done = b - a <= Math.ulp(c);\n                hmc = H0;\n                hc = H1 * c;\n                for (int j = 1; j < numberOfPoints; j++) {\n                    // Compute H[j+1](c)\n                    final double jp1 = j + 1;\n                    final double s = FastMath.sqrt(2 / jp1);\n                    final double sm = FastMath.sqrt(j / jp1);\n                    final double hpc = s * c * hc - sm * hmc;\n                    hmc = hc;\n                    hc = hpc;\n                }\n                // Now h = H[n+1](c) and hm = H[n](c).\n                if (!done) {\n                    if (ha * hc < 0) {\n                        b = c;\n                        hmb = hmc;\n                        hb = hc;\n                    } else {\n                        a = c;\n                        hma = hmc;\n                        ha = hc;\n                    }\n                    c = 0.5 * (a + b);\n                }\n            }\n            final double d = sqrtTwoTimesNumPoints * hmc;\n            final double w = 2 / (d * d);\n\n            points[i] = c;\n            weights[i] = w;\n\n            final int idx = lastNumPoints - i;\npoints[idx] = c[idx];\n            weights[idx] = w;\n        }\n\n        // If \"numberOfPoints\" is odd, 0 is a root.\n        // Note: as written, the test for oddness will work for negative\n        // integers too (although it is not necessary here), preventing\n        // a FindBugs warning.\n        if (numberOfPoints % 2 != 0) {\n            double hm = H0;\n            for (int j = 1; j < numberOfPoints; j += 2) {\n                final double jp1 = j + 1;\n                hm = -FastMath.sqrt(j / jp1) * hm;\n            }\n            final double d = sqrtTwoTimesNumPoints * hm;\n            final double w = 2 / (d * d);\n\n            points[iMax] = 0d;\n            weights[iMax] = w;\n        }\n\n        return new Pair<Double[], Double[]>(points, weights);\n    }",
          "20": "    protected Pair<Double[], Double[]> computeRule(int numberOfPoints)\n        throws DimensionMismatchException {\n\n        if (numberOfPoints == 1) {\n            // Break recursion.\n            return new Pair<Double[], Double[]>(new Double[] { 0d },\n                                                new Double[] { SQRT_PI });\n        }\n\n        // Get previous rule.\n        // If it has not been computed yet it will trigger a recursive call\n        // to this method.\n        final int lastNumPoints = numberOfPoints - 1;\n        final Double[] previousPoints = getRuleInternal(lastNumPoints).getFirst();\n\n        // Compute next rule.\n        final Double[] points = new Double[numberOfPoints];\n        final Double[] weights = new Double[numberOfPoints];\n\n        final double sqrtTwoTimesLastNumPoints = FastMath.sqrt(2 * lastNumPoints);\n        final double sqrtTwoTimesNumPoints = FastMath.sqrt(2 * numberOfPoints);\n\n        // Find i-th root of H[n+1] by bracketing.\n        final int iMax = numberOfPoints / 2;\n        for (int i = 0; i < iMax; i++) {\n            // Lower-bound of the interval.\n            double a = (i == 0) ? -sqrtTwoTimesLastNumPoints : previousPoints[i - 1].doubleValue();\n            // Upper-bound of the interval.\n            double b = (iMax == 1) ? -0.5 : previousPoints[i].doubleValue();\n\n            // H[j-1](a)\n            double hma = H0;\n            // H[j](a)\n            double ha = H1 * a;\n            // H[j-1](b)\n            double hmb = H0;\n            // H[j](b)\n            double hb = H1 * b;\n            for (int j = 1; j < numberOfPoints; j++) {\n                // Compute H[j+1](a) and H[j+1](b)\n                final double jp1 = j + 1;\n                final double s = FastMath.sqrt(2 / jp1);\n                final double sm = FastMath.sqrt(j / jp1);\n                final double hpa = s * a * ha - sm * hma;\n                final double hpb = s * b * hb - sm * hmb;\n                hma = ha;\n                ha = hpa;\n                hmb = hb;\n                hb = hpb;\n            }\n\n            // Now ha = H[n+1](a), and hma = H[n](a) (same holds for b).\n            // Middle of the interval.\n            double c = 0.5 * (a + b);\n            // P[j-1](c)\n            double hmc = H0;\n            // P[j](c)\n            double hc = H1 * c;\n            boolean done = false;\n            while (!done) {\n                done = b - a <= Math.ulp(c);\n                hmc = H0;\n                hc = H1 * c;\n                for (int j = 1; j < numberOfPoints; j++) {\n                    // Compute H[j+1](c)\n                    final double jp1 = j + 1;\n                    final double s = FastMath.sqrt(2 / jp1);\n                    final double sm = FastMath.sqrt(j / jp1);\n                    final double hpc = s * c * hc - sm * hmc;\n                    hmc = hc;\n                    hc = hpc;\n                }\n                // Now h = H[n+1](c) and hm = H[n](c).\n                if (!done) {\n                    if (ha * hc < 0) {\n                        b = c;\n                        hmb = hmc;\n                        hb = hc;\n                    } else {\n                        a = c;\n                        hma = hmc;\n                        ha = hc;\n                    }\n                    c = 0.5 * (a + b);\n                }\n            }\n            final double d = sqrtTwoTimesNumPoints * hmc;\n            final double w = 2 / (d * d);\n\n            points[i] = c;\n            weights[i] = w;\n\n            final int idx = lastNumPoints - i;\n-c = +c;\n            weights[idx] = w;\n        }\n\n        // If \"numberOfPoints\" is odd, 0 is a root.\n        // Note: as written, the test for oddness will work for negative\n        // integers too (although it is not necessary here), preventing\n        // a FindBugs warning.\n        if (numberOfPoints % 2 != 0) {\n            double hm = H0;\n            for (int j = 1; j < numberOfPoints; j += 2) {\n                final double jp1 = j + 1;\n                hm = -FastMath.sqrt(j / jp1) * hm;\n            }\n            final double d = sqrtTwoTimesNumPoints * hm;\n            final double w = 2 / (d * d);\n\n            points[iMax] = 0d;\n            weights[iMax] = w;\n        }\n\n        return new Pair<Double[], Double[]>(points, weights);\n    }",
          "21": "    protected Pair<Double[], Double[]> computeRule(int numberOfPoints)\n        throws DimensionMismatchException {\n\n        if (numberOfPoints == 1) {\n            // Break recursion.\n            return new Pair<Double[], Double[]>(new Double[] { 0d },\n                                                new Double[] { SQRT_PI });\n        }\n\n        // Get previous rule.\n        // If it has not been computed yet it will trigger a recursive call\n        // to this method.\n        final int lastNumPoints = numberOfPoints - 1;\n        final Double[] previousPoints = getRuleInternal(lastNumPoints).getFirst();\n\n        // Compute next rule.\n        final Double[] points = new Double[numberOfPoints];\n        final Double[] weights = new Double[numberOfPoints];\n\n        final double sqrtTwoTimesLastNumPoints = FastMath.sqrt(2 * lastNumPoints);\n        final double sqrtTwoTimesNumPoints = FastMath.sqrt(2 * numberOfPoints);\n\n        // Find i-th root of H[n+1] by bracketing.\n        final int iMax = numberOfPoints / 2;\n        for (int i = 0; i < iMax; i++) {\n            // Lower-bound of the interval.\n            double a = (i == 0) ? -sqrtTwoTimesLastNumPoints : previousPoints[i - 1].doubleValue();\n            // Upper-bound of the interval.\n            double b = (iMax == 1) ? -0.5 : previousPoints[i].doubleValue();\n\n            // H[j-1](a)\n            double hma = H0;\n            // H[j](a)\n            double ha = H1 * a;\n            // H[j-1](b)\n            double hmb = H0;\n            // H[j](b)\n            double hb = H1 * b;\n            for (int j = 1; j < numberOfPoints; j++) {\n                // Compute H[j+1](a) and H[j+1](b)\n                final double jp1 = j + 1;\n                final double s = FastMath.sqrt(2 / jp1);\n                final double sm = FastMath.sqrt(j / jp1);\n                final double hpa = s * a * ha - sm * hma;\n                final double hpb = s * b * hb - sm * hmb;\n                hma = ha;\n                ha = hpa;\n                hmb = hb;\n                hb = hpb;\n            }\n\n            // Now ha = H[n+1](a), and hma = H[n](a) (same holds for b).\n            // Middle of the interval.\n            double c = 0.5 * (a + b);\n            // P[j-1](c)\n            double hmc = H0;\n            // P[j](c)\n            double hc = H1 * c;\n            boolean done = false;\n            while (!done) {\n                done = b - a <= Math.ulp(c);\n                hmc = H0;\n                hc = H1 * c;\n                for (int j = 1; j < numberOfPoints; j++) {\n                    // Compute H[j+1](c)\n                    final double jp1 = j + 1;\n                    final double s = FastMath.sqrt(2 / jp1);\n                    final double sm = FastMath.sqrt(j / jp1);\n                    final double hpc = s * c * hc - sm * hmc;\n                    hmc = hc;\n                    hc = hpc;\n                }\n                // Now h = H[n+1](c) and hm = H[n](c).\n                if (!done) {\n                    if (ha * hc < 0) {\n                        b = c;\n                        hmb = hmc;\n                        hb = hc;\n                    } else {\n                        a = c;\n                        hma = hmc;\n                        ha = hc;\n                    }\n                    c = 0.5 * (a + b);\n                }\n            }\n            final double d = sqrtTwoTimesNumPoints * hmc;\n            final double w = 2 / (d * d);\n\n            points[i] = c;\n            weights[i] = w;\n\n            final int idx = lastNumPoints - i;\npoints[idx] = e[idx];\n            weights[idx] = w;\n        }\n\n        // If \"numberOfPoints\" is odd, 0 is a root.\n        // Note: as written, the test for oddness will work for negative\n        // integers too (although it is not necessary here), preventing\n        // a FindBugs warning.\n        if (numberOfPoints % 2 != 0) {\n            double hm = H0;\n            for (int j = 1; j < numberOfPoints; j += 2) {\n                final double jp1 = j + 1;\n                hm = -FastMath.sqrt(j / jp1) * hm;\n            }\n            final double d = sqrtTwoTimesNumPoints * hm;\n            final double w = 2 / (d * d);\n\n            points[iMax] = 0d;\n            weights[iMax] = w;\n        }\n\n        return new Pair<Double[], Double[]>(points, weights);\n    }",
          "22": "    protected Pair<Double[], Double[]> computeRule(int numberOfPoints)\n        throws DimensionMismatchException {\n\n        if (numberOfPoints == 1) {\n            // Break recursion.\n            return new Pair<Double[], Double[]>(new Double[] { 0d },\n                                                new Double[] { SQRT_PI });\n        }\n\n        // Get previous rule.\n        // If it has not been computed yet it will trigger a recursive call\n        // to this method.\n        final int lastNumPoints = numberOfPoints - 1;\n        final Double[] previousPoints = getRuleInternal(lastNumPoints).getFirst();\n\n        // Compute next rule.\n        final Double[] points = new Double[numberOfPoints];\n        final Double[] weights = new Double[numberOfPoints];\n\n        final double sqrtTwoTimesLastNumPoints = FastMath.sqrt(2 * lastNumPoints);\n        final double sqrtTwoTimesNumPoints = FastMath.sqrt(2 * numberOfPoints);\n\n        // Find i-th root of H[n+1] by bracketing.\n        final int iMax = numberOfPoints / 2;\n        for (int i = 0; i < iMax; i++) {\n            // Lower-bound of the interval.\n            double a = (i == 0) ? -sqrtTwoTimesLastNumPoints : previousPoints[i - 1].doubleValue();\n            // Upper-bound of the interval.\n            double b = (iMax == 1) ? -0.5 : previousPoints[i].doubleValue();\n\n            // H[j-1](a)\n            double hma = H0;\n            // H[j](a)\n            double ha = H1 * a;\n            // H[j-1](b)\n            double hmb = H0;\n            // H[j](b)\n            double hb = H1 * b;\n            for (int j = 1; j < numberOfPoints; j++) {\n                // Compute H[j+1](a) and H[j+1](b)\n                final double jp1 = j + 1;\n                final double s = FastMath.sqrt(2 / jp1);\n                final double sm = FastMath.sqrt(j / jp1);\n                final double hpa = s * a * ha - sm * hma;\n                final double hpb = s * b * hb - sm * hmb;\n                hma = ha;\n                ha = hpa;\n                hmb = hb;\n                hb = hpb;\n            }\n\n            // Now ha = H[n+1](a), and hma = H[n](a) (same holds for b).\n            // Middle of the interval.\n            double c = 0.5 * (a + b);\n            // P[j-1](c)\n            double hmc = H0;\n            // P[j](c)\n            double hc = H1 * c;\n            boolean done = false;\n            while (!done) {\n                done = b - a <= Math.ulp(c);\n                hmc = H0;\n                hc = H1 * c;\n                for (int j = 1; j < numberOfPoints; j++) {\n                    // Compute H[j+1](c)\n                    final double jp1 = j + 1;\n                    final double s = FastMath.sqrt(2 / jp1);\n                    final double sm = FastMath.sqrt(j / jp1);\n                    final double hpc = s * c * hc - sm * hmc;\n                    hmc = hc;\n                    hc = hpc;\n                }\n                // Now h = H[n+1](c) and hm = H[n](c).\n                if (!done) {\n                    if (ha * hc < 0) {\n                        b = c;\n                        hmb = hmc;\n                        hb = hc;\n                    } else {\n                        a = c;\n                        hma = hmc;\n                        ha = hc;\n                    }\n                    c = 0.5 * (a + b);\n                }\n            }\n            final double d = sqrtTwoTimesNumPoints * hmc;\n            final double w = 2 / (d * d);\n\n            points[i] = c;\n            weights[i] = w;\n\n            final int idx = lastNumPoints - i;\n[idx] = +c;\n            weights[idx] = w;\n        }\n\n        // If \"numberOfPoints\" is odd, 0 is a root.\n        // Note: as written, the test for oddness will work for negative\n        // integers too (although it is not necessary here), preventing\n        // a FindBugs warning.\n        if (numberOfPoints % 2 != 0) {\n            double hm = H0;\n            for (int j = 1; j < numberOfPoints; j += 2) {\n                final double jp1 = j + 1;\n                hm = -FastMath.sqrt(j / jp1) * hm;\n            }\n            final double d = sqrtTwoTimesNumPoints * hm;\n            final double w = 2 / (d * d);\n\n            points[iMax] = 0d;\n            weights[iMax] = w;\n        }\n\n        return new Pair<Double[], Double[]>(points, weights);\n    }",
          "23": "    protected Pair<Double[], Double[]> computeRule(int numberOfPoints)\n        throws DimensionMismatchException {\n\n        if (numberOfPoints == 1) {\n            // Break recursion.\n            return new Pair<Double[], Double[]>(new Double[] { 0d },\n                                                new Double[] { SQRT_PI });\n        }\n\n        // Get previous rule.\n        // If it has not been computed yet it will trigger a recursive call\n        // to this method.\n        final int lastNumPoints = numberOfPoints - 1;\n        final Double[] previousPoints = getRuleInternal(lastNumPoints).getFirst();\n\n        // Compute next rule.\n        final Double[] points = new Double[numberOfPoints];\n        final Double[] weights = new Double[numberOfPoints];\n\n        final double sqrtTwoTimesLastNumPoints = FastMath.sqrt(2 * lastNumPoints);\n        final double sqrtTwoTimesNumPoints = FastMath.sqrt(2 * numberOfPoints);\n\n        // Find i-th root of H[n+1] by bracketing.\n        final int iMax = numberOfPoints / 2;\n        for (int i = 0; i < iMax; i++) {\n            // Lower-bound of the interval.\n            double a = (i == 0) ? -sqrtTwoTimesLastNumPoints : previousPoints[i - 1].doubleValue();\n            // Upper-bound of the interval.\n            double b = (iMax == 1) ? -0.5 : previousPoints[i].doubleValue();\n\n            // H[j-1](a)\n            double hma = H0;\n            // H[j](a)\n            double ha = H1 * a;\n            // H[j-1](b)\n            double hmb = H0;\n            // H[j](b)\n            double hb = H1 * b;\n            for (int j = 1; j < numberOfPoints; j++) {\n                // Compute H[j+1](a) and H[j+1](b)\n                final double jp1 = j + 1;\n                final double s = FastMath.sqrt(2 / jp1);\n                final double sm = FastMath.sqrt(j / jp1);\n                final double hpa = s * a * ha - sm * hma;\n                final double hpb = s * b * hb - sm * hmb;\n                hma = ha;\n                ha = hpa;\n                hmb = hb;\n                hb = hpb;\n            }\n\n            // Now ha = H[n+1](a), and hma = H[n](a) (same holds for b).\n            // Middle of the interval.\n            double c = 0.5 * (a + b);\n            // P[j-1](c)\n            double hmc = H0;\n            // P[j](c)\n            double hc = H1 * c;\n            boolean done = false;\n            while (!done) {\n                done = b - a <= Math.ulp(c);\n                hmc = H0;\n                hc = H1 * c;\n                for (int j = 1; j < numberOfPoints; j++) {\n                    // Compute H[j+1](c)\n                    final double jp1 = j + 1;\n                    final double s = FastMath.sqrt(2 / jp1);\n                    final double sm = FastMath.sqrt(j / jp1);\n                    final double hpc = s * c * hc - sm * hmc;\n                    hmc = hc;\n                    hc = hpc;\n                }\n                // Now h = H[n+1](c) and hm = H[n](c).\n                if (!done) {\n                    if (ha * hc < 0) {\n                        b = c;\n                        hmb = hmc;\n                        hb = hc;\n                    } else {\n                        a = c;\n                        hma = hmc;\n                        ha = hc;\n                    }\n                    c = 0.5 * (a + b);\n                }\n            }\n            final double d = sqrtTwoTimesNumPoints * hmc;\n            final double w = 2 / (d * d);\n\n            points[i] = c;\n            weights[i] = w;\n\n            final int idx = lastNumPoints - i;\npoints[0] = +c;\n            weights[idx] = w;\n        }\n\n        // If \"numberOfPoints\" is odd, 0 is a root.\n        // Note: as written, the test for oddness will work for negative\n        // integers too (although it is not necessary here), preventing\n        // a FindBugs warning.\n        if (numberOfPoints % 2 != 0) {\n            double hm = H0;\n            for (int j = 1; j < numberOfPoints; j += 2) {\n                final double jp1 = j + 1;\n                hm = -FastMath.sqrt(j / jp1) * hm;\n            }\n            final double d = sqrtTwoTimesNumPoints * hm;\n            final double w = 2 / (d * d);\n\n            points[iMax] = 0d;\n            weights[iMax] = w;\n        }\n\n        return new Pair<Double[], Double[]>(points, weights);\n    }",
          "24": "    protected Pair<Double[], Double[]> computeRule(int numberOfPoints)\n        throws DimensionMismatchException {\n\n        if (numberOfPoints == 1) {\n            // Break recursion.\n            return new Pair<Double[], Double[]>(new Double[] { 0d },\n                                                new Double[] { SQRT_PI });\n        }\n\n        // Get previous rule.\n        // If it has not been computed yet it will trigger a recursive call\n        // to this method.\n        final int lastNumPoints = numberOfPoints - 1;\n        final Double[] previousPoints = getRuleInternal(lastNumPoints).getFirst();\n\n        // Compute next rule.\n        final Double[] points = new Double[numberOfPoints];\n        final Double[] weights = new Double[numberOfPoints];\n\n        final double sqrtTwoTimesLastNumPoints = FastMath.sqrt(2 * lastNumPoints);\n        final double sqrtTwoTimesNumPoints = FastMath.sqrt(2 * numberOfPoints);\n\n        // Find i-th root of H[n+1] by bracketing.\n        final int iMax = numberOfPoints / 2;\n        for (int i = 0; i < iMax; i++) {\n            // Lower-bound of the interval.\n            double a = (i == 0) ? -sqrtTwoTimesLastNumPoints : previousPoints[i - 1].doubleValue();\n            // Upper-bound of the interval.\n            double b = (iMax == 1) ? -0.5 : previousPoints[i].doubleValue();\n\n            // H[j-1](a)\n            double hma = H0;\n            // H[j](a)\n            double ha = H1 * a;\n            // H[j-1](b)\n            double hmb = H0;\n            // H[j](b)\n            double hb = H1 * b;\n            for (int j = 1; j < numberOfPoints; j++) {\n                // Compute H[j+1](a) and H[j+1](b)\n                final double jp1 = j + 1;\n                final double s = FastMath.sqrt(2 / jp1);\n                final double sm = FastMath.sqrt(j / jp1);\n                final double hpa = s * a * ha - sm * hma;\n                final double hpb = s * b * hb - sm * hmb;\n                hma = ha;\n                ha = hpa;\n                hmb = hb;\n                hb = hpb;\n            }\n\n            // Now ha = H[n+1](a), and hma = H[n](a) (same holds for b).\n            // Middle of the interval.\n            double c = 0.5 * (a + b);\n            // P[j-1](c)\n            double hmc = H0;\n            // P[j](c)\n            double hc = H1 * c;\n            boolean done = false;\n            while (!done) {\n                done = b - a <= Math.ulp(c);\n                hmc = H0;\n                hc = H1 * c;\n                for (int j = 1; j < numberOfPoints; j++) {\n                    // Compute H[j+1](c)\n                    final double jp1 = j + 1;\n                    final double s = FastMath.sqrt(2 / jp1);\n                    final double sm = FastMath.sqrt(j / jp1);\n                    final double hpc = s * c * hc - sm * hmc;\n                    hmc = hc;\n                    hc = hpc;\n                }\n                // Now h = H[n+1](c) and hm = H[n](c).\n                if (!done) {\n                    if (ha * hc < 0) {\n                        b = c;\n                        hmb = hmc;\n                        hb = hc;\n                    } else {\n                        a = c;\n                        hma = hmc;\n                        ha = hc;\n                    }\n                    c = 0.5 * (a + b);\n                }\n            }\n            final double d = sqrtTwoTimesNumPoints * hmc;\n            final double w = 2 / (d * d);\n\n            points[i] = c;\n            weights[i] = w;\n\n            final int idx = lastNumPoints - i;\n            weights[idx] = w;\n        }\n\n        // If \"numberOfPoints\" is odd, 0 is a root.\n        // Note: as written, the test for oddness will work for negative\n        // integers too (although it is not necessary here), preventing\n        // a FindBugs warning.\n        if (numberOfPoints % 2 != 0) {\n            double hm = H0;\n            for (int j = 1; j < numberOfPoints; j += 2) {\n                final double jp1 = j + 1;\n                hm = -FastMath.sqrt(j / jp1) * hm;\n            }\n            final double d = sqrtTwoTimesNumPoints * hm;\n            final double w = 2 / (d * d);\n\n            points[iMax] = 0d;\n            weights[iMax] = w;\n        }\n\n        return new Pair<Double[], Double[]>(points, weights);\n    }",
          "25": "    protected Pair<Double[], Double[]> computeRule(int numberOfPoints)\n        throws DimensionMismatchException {\n\n        if (numberOfPoints == 1) {\n            // Break recursion.\n            return new Pair<Double[], Double[]>(new Double[] { 0d },\n                                                new Double[] { SQRT_PI });\n        }\n\n        // Get previous rule.\n        // If it has not been computed yet it will trigger a recursive call\n        // to this method.\n        final int lastNumPoints = numberOfPoints - 1;\n        final Double[] previousPoints = getRuleInternal(lastNumPoints).getFirst();\n\n        // Compute next rule.\n        final Double[] points = new Double[numberOfPoints];\n        final Double[] weights = new Double[numberOfPoints];\n\n        final double sqrtTwoTimesLastNumPoints = FastMath.sqrt(2 * lastNumPoints);\n        final double sqrtTwoTimesNumPoints = FastMath.sqrt(2 * numberOfPoints);\n\n        // Find i-th root of H[n+1] by bracketing.\n        final int iMax = numberOfPoints / 2;\n        for (int i = 0; i < iMax; i++) {\n            // Lower-bound of the interval.\n            double a = (i == 0) ? -sqrtTwoTimesLastNumPoints : previousPoints[i - 1].doubleValue();\n            // Upper-bound of the interval.\n            double b = (iMax == 1) ? -0.5 : previousPoints[i].doubleValue();\n\n            // H[j-1](a)\n            double hma = H0;\n            // H[j](a)\n            double ha = H1 * a;\n            // H[j-1](b)\n            double hmb = H0;\n            // H[j](b)\n            double hb = H1 * b;\n            for (int j = 1; j < numberOfPoints; j++) {\n                // Compute H[j+1](a) and H[j+1](b)\n                final double jp1 = j + 1;\n                final double s = FastMath.sqrt(2 / jp1);\n                final double sm = FastMath.sqrt(j / jp1);\n                final double hpa = s * a * ha - sm * hma;\n                final double hpb = s * b * hb - sm * hmb;\n                hma = ha;\n                ha = hpa;\n                hmb = hb;\n                hb = hpb;\n            }\n\n            // Now ha = H[n+1](a), and hma = H[n](a) (same holds for b).\n            // Middle of the interval.\n            double c = 0.5 * (a + b);\n            // P[j-1](c)\n            double hmc = H0;\n            // P[j](c)\n            double hc = H1 * c;\n            boolean done = false;\n            while (!done) {\n                done = b - a <= Math.ulp(c);\n                hmc = H0;\n                hc = H1 * c;\n                for (int j = 1; j < numberOfPoints; j++) {\n                    // Compute H[j+1](c)\n                    final double jp1 = j + 1;\n                    final double s = FastMath.sqrt(2 / jp1);\n                    final double sm = FastMath.sqrt(j / jp1);\n                    final double hpc = s * c * hc - sm * hmc;\n                    hmc = hc;\n                    hc = hpc;\n                }\n                // Now h = H[n+1](c) and hm = H[n](c).\n                if (!done) {\n                    if (ha * hc < 0) {\n                        b = c;\n                        hmb = hmc;\n                        hb = hc;\n                    } else {\n                        a = c;\n                        hma = hmc;\n                        ha = hc;\n                    }\n                    c = 0.5 * (a + b);\n                }\n            }\n            final double d = sqrtTwoTimesNumPoints * hmc;\n            final double w = 2 / (d * d);\n\n            points[i] = c;\n            weights[i] = w;\n\n            final int idx = lastNumPoints - i;\npoints[(idx + 1)] = +c;\n            weights[idx] = w;\n        }\n\n        // If \"numberOfPoints\" is odd, 0 is a root.\n        // Note: as written, the test for oddness will work for negative\n        // integers too (although it is not necessary here), preventing\n        // a FindBugs warning.\n        if (numberOfPoints % 2 != 0) {\n            double hm = H0;\n            for (int j = 1; j < numberOfPoints; j += 2) {\n                final double jp1 = j + 1;\n                hm = -FastMath.sqrt(j / jp1) * hm;\n            }\n            final double d = sqrtTwoTimesNumPoints * hm;\n            final double w = 2 / (d * d);\n\n            points[iMax] = 0d;\n            weights[iMax] = w;\n        }\n\n        return new Pair<Double[], Double[]>(points, weights);\n    }",
          "26": "    protected Pair<Double[], Double[]> computeRule(int numberOfPoints)\n        throws DimensionMismatchException {\n\n        if (numberOfPoints == 1) {\n            // Break recursion.\n            return new Pair<Double[], Double[]>(new Double[] { 0d },\n                                                new Double[] { SQRT_PI });\n        }\n\n        // Get previous rule.\n        // If it has not been computed yet it will trigger a recursive call\n        // to this method.\n        final int lastNumPoints = numberOfPoints - 1;\n        final Double[] previousPoints = getRuleInternal(lastNumPoints).getFirst();\n\n        // Compute next rule.\n        final Double[] points = new Double[numberOfPoints];\n        final Double[] weights = new Double[numberOfPoints];\n\n        final double sqrtTwoTimesLastNumPoints = FastMath.sqrt(2 * lastNumPoints);\n        final double sqrtTwoTimesNumPoints = FastMath.sqrt(2 * numberOfPoints);\n\n        // Find i-th root of H[n+1] by bracketing.\n        final int iMax = numberOfPoints / 2;\n        for (int i = 0; i < iMax; i++) {\n            // Lower-bound of the interval.\n            double a = (i == 0) ? -sqrtTwoTimesLastNumPoints : previousPoints[i - 1].doubleValue();\n            // Upper-bound of the interval.\n            double b = (iMax == 1) ? -0.5 : previousPoints[i].doubleValue();\n\n            // H[j-1](a)\n            double hma = H0;\n            // H[j](a)\n            double ha = H1 * a;\n            // H[j-1](b)\n            double hmb = H0;\n            // H[j](b)\n            double hb = H1 * b;\n            for (int j = 1; j < numberOfPoints; j++) {\n                // Compute H[j+1](a) and H[j+1](b)\n                final double jp1 = j + 1;\n                final double s = FastMath.sqrt(2 / jp1);\n                final double sm = FastMath.sqrt(j / jp1);\n                final double hpa = s * a * ha - sm * hma;\n                final double hpb = s * b * hb - sm * hmb;\n                hma = ha;\n                ha = hpa;\n                hmb = hb;\n                hb = hpb;\n            }\n\n            // Now ha = H[n+1](a), and hma = H[n](a) (same holds for b).\n            // Middle of the interval.\n            double c = 0.5 * (a + b);\n            // P[j-1](c)\n            double hmc = H0;\n            // P[j](c)\n            double hc = H1 * c;\n            boolean done = false;\n            while (!done) {\n                done = b - a <= Math.ulp(c);\n                hmc = H0;\n                hc = H1 * c;\n                for (int j = 1; j < numberOfPoints; j++) {\n                    // Compute H[j+1](c)\n                    final double jp1 = j + 1;\n                    final double s = FastMath.sqrt(2 / jp1);\n                    final double sm = FastMath.sqrt(j / jp1);\n                    final double hpc = s * c * hc - sm * hmc;\n                    hmc = hc;\n                    hc = hpc;\n                }\n                // Now h = H[n+1](c) and hm = H[n](c).\n                if (!done) {\n                    if (ha * hc < 0) {\n                        b = c;\n                        hmb = hmc;\n                        hb = hc;\n                    } else {\n                        a = c;\n                        hma = hmc;\n                        ha = hc;\n                    }\n                    c = 0.5 * (a + b);\n                }\n            }\n            final double d = sqrtTwoTimesNumPoints * hmc;\n            final double w = 2 / (d * d);\n\n            points[i] = c;\n            weights[i] = w;\n\n            final int idx = lastNumPoints - i;\nidx[(idx + 1)] = +c;\n            weights[idx] = w;\n        }\n\n        // If \"numberOfPoints\" is odd, 0 is a root.\n        // Note: as written, the test for oddness will work for negative\n        // integers too (although it is not necessary here), preventing\n        // a FindBugs warning.\n        if (numberOfPoints % 2 != 0) {\n            double hm = H0;\n            for (int j = 1; j < numberOfPoints; j += 2) {\n                final double jp1 = j + 1;\n                hm = -FastMath.sqrt(j / jp1) * hm;\n            }\n            final double d = sqrtTwoTimesNumPoints * hm;\n            final double w = 2 / (d * d);\n\n            points[iMax] = 0d;\n            weights[iMax] = w;\n        }\n\n        return new Pair<Double[], Double[]>(points, weights);\n    }",
          "27": "    protected Pair<Double[], Double[]> computeRule(int numberOfPoints)\n        throws DimensionMismatchException {\n\n        if (numberOfPoints == 1) {\n            // Break recursion.\n            return new Pair<Double[], Double[]>(new Double[] { 0d },\n                                                new Double[] { SQRT_PI });\n        }\n\n        // Get previous rule.\n        // If it has not been computed yet it will trigger a recursive call\n        // to this method.\n        final int lastNumPoints = numberOfPoints - 1;\n        final Double[] previousPoints = getRuleInternal(lastNumPoints).getFirst();\n\n        // Compute next rule.\n        final Double[] points = new Double[numberOfPoints];\n        final Double[] weights = new Double[numberOfPoints];\n\n        final double sqrtTwoTimesLastNumPoints = FastMath.sqrt(2 * lastNumPoints);\n        final double sqrtTwoTimesNumPoints = FastMath.sqrt(2 * numberOfPoints);\n\n        // Find i-th root of H[n+1] by bracketing.\n        final int iMax = numberOfPoints / 2;\n        for (int i = 0; i < iMax; i++) {\n            // Lower-bound of the interval.\n            double a = (i == 0) ? -sqrtTwoTimesLastNumPoints : previousPoints[i - 1].doubleValue();\n            // Upper-bound of the interval.\n            double b = (iMax == 1) ? -0.5 : previousPoints[i].doubleValue();\n\n            // H[j-1](a)\n            double hma = H0;\n            // H[j](a)\n            double ha = H1 * a;\n            // H[j-1](b)\n            double hmb = H0;\n            // H[j](b)\n            double hb = H1 * b;\n            for (int j = 1; j < numberOfPoints; j++) {\n                // Compute H[j+1](a) and H[j+1](b)\n                final double jp1 = j + 1;\n                final double s = FastMath.sqrt(2 / jp1);\n                final double sm = FastMath.sqrt(j / jp1);\n                final double hpa = s * a * ha - sm * hma;\n                final double hpb = s * b * hb - sm * hmb;\n                hma = ha;\n                ha = hpa;\n                hmb = hb;\n                hb = hpb;\n            }\n\n            // Now ha = H[n+1](a), and hma = H[n](a) (same holds for b).\n            // Middle of the interval.\n            double c = 0.5 * (a + b);\n            // P[j-1](c)\n            double hmc = H0;\n            // P[j](c)\n            double hc = H1 * c;\n            boolean done = false;\n            while (!done) {\n                done = b - a <= Math.ulp(c);\n                hmc = H0;\n                hc = H1 * c;\n                for (int j = 1; j < numberOfPoints; j++) {\n                    // Compute H[j+1](c)\n                    final double jp1 = j + 1;\n                    final double s = FastMath.sqrt(2 / jp1);\n                    final double sm = FastMath.sqrt(j / jp1);\n                    final double hpc = s * c * hc - sm * hmc;\n                    hmc = hc;\n                    hc = hpc;\n                }\n                // Now h = H[n+1](c) and hm = H[n](c).\n                if (!done) {\n                    if (ha * hc < 0) {\n                        b = c;\n                        hmb = hmc;\n                        hb = hc;\n                    } else {\n                        a = c;\n                        hma = hmc;\n                        ha = hc;\n                    }\n                    c = 0.5 * (a + b);\n                }\n            }\n            final double d = sqrtTwoTimesNumPoints * hmc;\n            final double w = 2 / (d * d);\n\n            points[i] = c;\n            weights[i] = w;\n\n            final int idx = lastNumPoints - i;\nc[(idx + 1)] = +c;\n            weights[idx] = w;\n        }\n\n        // If \"numberOfPoints\" is odd, 0 is a root.\n        // Note: as written, the test for oddness will work for negative\n        // integers too (although it is not necessary here), preventing\n        // a FindBugs warning.\n        if (numberOfPoints % 2 != 0) {\n            double hm = H0;\n            for (int j = 1; j < numberOfPoints; j += 2) {\n                final double jp1 = j + 1;\n                hm = -FastMath.sqrt(j / jp1) * hm;\n            }\n            final double d = sqrtTwoTimesNumPoints * hm;\n            final double w = 2 / (d * d);\n\n            points[iMax] = 0d;\n            weights[iMax] = w;\n        }\n\n        return new Pair<Double[], Double[]>(points, weights);\n    }",
          "28": "    protected Pair<Double[], Double[]> computeRule(int numberOfPoints)\n        throws DimensionMismatchException {\n\n        if (numberOfPoints == 1) {\n            // Break recursion.\n            return new Pair<Double[], Double[]>(new Double[] { 0d },\n                                                new Double[] { SQRT_PI });\n        }\n\n        // Get previous rule.\n        // If it has not been computed yet it will trigger a recursive call\n        // to this method.\n        final int lastNumPoints = numberOfPoints - 1;\n        final Double[] previousPoints = getRuleInternal(lastNumPoints).getFirst();\n\n        // Compute next rule.\n        final Double[] points = new Double[numberOfPoints];\n        final Double[] weights = new Double[numberOfPoints];\n\n        final double sqrtTwoTimesLastNumPoints = FastMath.sqrt(2 * lastNumPoints);\n        final double sqrtTwoTimesNumPoints = FastMath.sqrt(2 * numberOfPoints);\n\n        // Find i-th root of H[n+1] by bracketing.\n        final int iMax = numberOfPoints / 2;\n        for (int i = 0; i < iMax; i++) {\n            // Lower-bound of the interval.\n            double a = (i == 0) ? -sqrtTwoTimesLastNumPoints : previousPoints[i - 1].doubleValue();\n            // Upper-bound of the interval.\n            double b = (iMax == 1) ? -0.5 : previousPoints[i].doubleValue();\n\n            // H[j-1](a)\n            double hma = H0;\n            // H[j](a)\n            double ha = H1 * a;\n            // H[j-1](b)\n            double hmb = H0;\n            // H[j](b)\n            double hb = H1 * b;\n            for (int j = 1; j < numberOfPoints; j++) {\n                // Compute H[j+1](a) and H[j+1](b)\n                final double jp1 = j + 1;\n                final double s = FastMath.sqrt(2 / jp1);\n                final double sm = FastMath.sqrt(j / jp1);\n                final double hpa = s * a * ha - sm * hma;\n                final double hpb = s * b * hb - sm * hmb;\n                hma = ha;\n                ha = hpa;\n                hmb = hb;\n                hb = hpb;\n            }\n\n            // Now ha = H[n+1](a), and hma = H[n](a) (same holds for b).\n            // Middle of the interval.\n            double c = 0.5 * (a + b);\n            // P[j-1](c)\n            double hmc = H0;\n            // P[j](c)\n            double hc = H1 * c;\n            boolean done = false;\n            while (!done) {\n                done = b - a <= Math.ulp(c);\n                hmc = H0;\n                hc = H1 * c;\n                for (int j = 1; j < numberOfPoints; j++) {\n                    // Compute H[j+1](c)\n                    final double jp1 = j + 1;\n                    final double s = FastMath.sqrt(2 / jp1);\n                    final double sm = FastMath.sqrt(j / jp1);\n                    final double hpc = s * c * hc - sm * hmc;\n                    hmc = hc;\n                    hc = hpc;\n                }\n                // Now h = H[n+1](c) and hm = H[n](c).\n                if (!done) {\n                    if (ha * hc < 0) {\n                        b = c;\n                        hmb = hmc;\n                        hb = hc;\n                    } else {\n                        a = c;\n                        hma = hmc;\n                        ha = hc;\n                    }\n                    c = 0.5 * (a + b);\n                }\n            }\n            final double d = sqrtTwoTimesNumPoints * hmc;\n            final double w = 2 / (d * d);\n\n            points[i] = c;\n            weights[i] = w;\n\n            final int idx = lastNumPoints - i;\npoints[(idx - 1)] = +c;\n            weights[idx] = w;\n        }\n\n        // If \"numberOfPoints\" is odd, 0 is a root.\n        // Note: as written, the test for oddness will work for negative\n        // integers too (although it is not necessary here), preventing\n        // a FindBugs warning.\n        if (numberOfPoints % 2 != 0) {\n            double hm = H0;\n            for (int j = 1; j < numberOfPoints; j += 2) {\n                final double jp1 = j + 1;\n                hm = -FastMath.sqrt(j / jp1) * hm;\n            }\n            final double d = sqrtTwoTimesNumPoints * hm;\n            final double w = 2 / (d * d);\n\n            points[iMax] = 0d;\n            weights[iMax] = w;\n        }\n\n        return new Pair<Double[], Double[]>(points, weights);\n    }",
          "29": "    protected Pair<Double[], Double[]> computeRule(int numberOfPoints)\n        throws DimensionMismatchException {\n\n        if (numberOfPoints == 1) {\n            // Break recursion.\n            return new Pair<Double[], Double[]>(new Double[] { 0d },\n                                                new Double[] { SQRT_PI });\n        }\n\n        // Get previous rule.\n        // If it has not been computed yet it will trigger a recursive call\n        // to this method.\n        final int lastNumPoints = numberOfPoints - 1;\n        final Double[] previousPoints = getRuleInternal(lastNumPoints).getFirst();\n\n        // Compute next rule.\n        final Double[] points = new Double[numberOfPoints];\n        final Double[] weights = new Double[numberOfPoints];\n\n        final double sqrtTwoTimesLastNumPoints = FastMath.sqrt(2 * lastNumPoints);\n        final double sqrtTwoTimesNumPoints = FastMath.sqrt(2 * numberOfPoints);\n\n        // Find i-th root of H[n+1] by bracketing.\n        final int iMax = numberOfPoints / 2;\n        for (int i = 0; i < iMax; i++) {\n            // Lower-bound of the interval.\n            double a = (i == 0) ? -sqrtTwoTimesLastNumPoints : previousPoints[i - 1].doubleValue();\n            // Upper-bound of the interval.\n            double b = (iMax == 1) ? -0.5 : previousPoints[i].doubleValue();\n\n            // H[j-1](a)\n            double hma = H0;\n            // H[j](a)\n            double ha = H1 * a;\n            // H[j-1](b)\n            double hmb = H0;\n            // H[j](b)\n            double hb = H1 * b;\n            for (int j = 1; j < numberOfPoints; j++) {\n                // Compute H[j+1](a) and H[j+1](b)\n                final double jp1 = j + 1;\n                final double s = FastMath.sqrt(2 / jp1);\n                final double sm = FastMath.sqrt(j / jp1);\n                final double hpa = s * a * ha - sm * hma;\n                final double hpb = s * b * hb - sm * hmb;\n                hma = ha;\n                ha = hpa;\n                hmb = hb;\n                hb = hpb;\n            }\n\n            // Now ha = H[n+1](a), and hma = H[n](a) (same holds for b).\n            // Middle of the interval.\n            double c = 0.5 * (a + b);\n            // P[j-1](c)\n            double hmc = H0;\n            // P[j](c)\n            double hc = H1 * c;\n            boolean done = false;\n            while (!done) {\n                done = b - a <= Math.ulp(c);\n                hmc = H0;\n                hc = H1 * c;\n                for (int j = 1; j < numberOfPoints; j++) {\n                    // Compute H[j+1](c)\n                    final double jp1 = j + 1;\n                    final double s = FastMath.sqrt(2 / jp1);\n                    final double sm = FastMath.sqrt(j / jp1);\n                    final double hpc = s * c * hc - sm * hmc;\n                    hmc = hc;\n                    hc = hpc;\n                }\n                // Now h = H[n+1](c) and hm = H[n](c).\n                if (!done) {\n                    if (ha * hc < 0) {\n                        b = c;\n                        hmb = hmc;\n                        hb = hc;\n                    } else {\n                        a = c;\n                        hma = hmc;\n                        ha = hc;\n                    }\n                    c = 0.5 * (a + b);\n                }\n            }\n            final double d = sqrtTwoTimesNumPoints * hmc;\n            final double w = 2 / (d * d);\n\n            points[i] = c;\n            weights[i] = w;\n\n            final int idx = lastNumPoints - i;\npoints[(points + 1)] = +c;\n            weights[idx] = w;\n        }\n\n        // If \"numberOfPoints\" is odd, 0 is a root.\n        // Note: as written, the test for oddness will work for negative\n        // integers too (although it is not necessary here), preventing\n        // a FindBugs warning.\n        if (numberOfPoints % 2 != 0) {\n            double hm = H0;\n            for (int j = 1; j < numberOfPoints; j += 2) {\n                final double jp1 = j + 1;\n                hm = -FastMath.sqrt(j / jp1) * hm;\n            }\n            final double d = sqrtTwoTimesNumPoints * hm;\n            final double w = 2 / (d * d);\n\n            points[iMax] = 0d;\n            weights[iMax] = w;\n        }\n\n        return new Pair<Double[], Double[]>(points, weights);\n    }",
          "30": "    protected Pair<Double[], Double[]> computeRule(int numberOfPoints)\n        throws DimensionMismatchException {\n\n        if (numberOfPoints == 1) {\n            // Break recursion.\n            return new Pair<Double[], Double[]>(new Double[] { 0d },\n                                                new Double[] { SQRT_PI });\n        }\n\n        // Get previous rule.\n        // If it has not been computed yet it will trigger a recursive call\n        // to this method.\n        final int lastNumPoints = numberOfPoints - 1;\n        final Double[] previousPoints = getRuleInternal(lastNumPoints).getFirst();\n\n        // Compute next rule.\n        final Double[] points = new Double[numberOfPoints];\n        final Double[] weights = new Double[numberOfPoints];\n\n        final double sqrtTwoTimesLastNumPoints = FastMath.sqrt(2 * lastNumPoints);\n        final double sqrtTwoTimesNumPoints = FastMath.sqrt(2 * numberOfPoints);\n\n        // Find i-th root of H[n+1] by bracketing.\n        final int iMax = numberOfPoints / 2;\n        for (int i = 0; i < iMax; i++) {\n            // Lower-bound of the interval.\n            double a = (i == 0) ? -sqrtTwoTimesLastNumPoints : previousPoints[i - 1].doubleValue();\n            // Upper-bound of the interval.\n            double b = (iMax == 1) ? -0.5 : previousPoints[i].doubleValue();\n\n            // H[j-1](a)\n            double hma = H0;\n            // H[j](a)\n            double ha = H1 * a;\n            // H[j-1](b)\n            double hmb = H0;\n            // H[j](b)\n            double hb = H1 * b;\n            for (int j = 1; j < numberOfPoints; j++) {\n                // Compute H[j+1](a) and H[j+1](b)\n                final double jp1 = j + 1;\n                final double s = FastMath.sqrt(2 / jp1);\n                final double sm = FastMath.sqrt(j / jp1);\n                final double hpa = s * a * ha - sm * hma;\n                final double hpb = s * b * hb - sm * hmb;\n                hma = ha;\n                ha = hpa;\n                hmb = hb;\n                hb = hpb;\n            }\n\n            // Now ha = H[n+1](a), and hma = H[n](a) (same holds for b).\n            // Middle of the interval.\n            double c = 0.5 * (a + b);\n            // P[j-1](c)\n            double hmc = H0;\n            // P[j](c)\n            double hc = H1 * c;\n            boolean done = false;\n            while (!done) {\n                done = b - a <= Math.ulp(c);\n                hmc = H0;\n                hc = H1 * c;\n                for (int j = 1; j < numberOfPoints; j++) {\n                    // Compute H[j+1](c)\n                    final double jp1 = j + 1;\n                    final double s = FastMath.sqrt(2 / jp1);\n                    final double sm = FastMath.sqrt(j / jp1);\n                    final double hpc = s * c * hc - sm * hmc;\n                    hmc = hc;\n                    hc = hpc;\n                }\n                // Now h = H[n+1](c) and hm = H[n](c).\n                if (!done) {\n                    if (ha * hc < 0) {\n                        b = c;\n                        hmb = hmc;\n                        hb = hc;\n                    } else {\n                        a = c;\n                        hma = hmc;\n                        ha = hc;\n                    }\n                    c = 0.5 * (a + b);\n                }\n            }\n            final double d = sqrtTwoTimesNumPoints * hmc;\n            final double w = 2 / (d * d);\n\n            points[i] = c;\n            weights[i] = w;\n\n            final int idx = lastNumPoints - i;\npoints[idx] = (idx + 1);\n            weights[idx] = w;\n        }\n\n        // If \"numberOfPoints\" is odd, 0 is a root.\n        // Note: as written, the test for oddness will work for negative\n        // integers too (although it is not necessary here), preventing\n        // a FindBugs warning.\n        if (numberOfPoints % 2 != 0) {\n            double hm = H0;\n            for (int j = 1; j < numberOfPoints; j += 2) {\n                final double jp1 = j + 1;\n                hm = -FastMath.sqrt(j / jp1) * hm;\n            }\n            final double d = sqrtTwoTimesNumPoints * hm;\n            final double w = 2 / (d * d);\n\n            points[iMax] = 0d;\n            weights[iMax] = w;\n        }\n\n        return new Pair<Double[], Double[]>(points, weights);\n    }",
          "31": "    protected Pair<Double[], Double[]> computeRule(int numberOfPoints)\n        throws DimensionMismatchException {\n\n        if (numberOfPoints == 1) {\n            // Break recursion.\n            return new Pair<Double[], Double[]>(new Double[] { 0d },\n                                                new Double[] { SQRT_PI });\n        }\n\n        // Get previous rule.\n        // If it has not been computed yet it will trigger a recursive call\n        // to this method.\n        final int lastNumPoints = numberOfPoints - 1;\n        final Double[] previousPoints = getRuleInternal(lastNumPoints).getFirst();\n\n        // Compute next rule.\n        final Double[] points = new Double[numberOfPoints];\n        final Double[] weights = new Double[numberOfPoints];\n\n        final double sqrtTwoTimesLastNumPoints = FastMath.sqrt(2 * lastNumPoints);\n        final double sqrtTwoTimesNumPoints = FastMath.sqrt(2 * numberOfPoints);\n\n        // Find i-th root of H[n+1] by bracketing.\n        final int iMax = numberOfPoints / 2;\n        for (int i = 0; i < iMax; i++) {\n            // Lower-bound of the interval.\n            double a = (i == 0) ? -sqrtTwoTimesLastNumPoints : previousPoints[i - 1].doubleValue();\n            // Upper-bound of the interval.\n            double b = (iMax == 1) ? -0.5 : previousPoints[i].doubleValue();\n\n            // H[j-1](a)\n            double hma = H0;\n            // H[j](a)\n            double ha = H1 * a;\n            // H[j-1](b)\n            double hmb = H0;\n            // H[j](b)\n            double hb = H1 * b;\n            for (int j = 1; j < numberOfPoints; j++) {\n                // Compute H[j+1](a) and H[j+1](b)\n                final double jp1 = j + 1;\n                final double s = FastMath.sqrt(2 / jp1);\n                final double sm = FastMath.sqrt(j / jp1);\n                final double hpa = s * a * ha - sm * hma;\n                final double hpb = s * b * hb - sm * hmb;\n                hma = ha;\n                ha = hpa;\n                hmb = hb;\n                hb = hpb;\n            }\n\n            // Now ha = H[n+1](a), and hma = H[n](a) (same holds for b).\n            // Middle of the interval.\n            double c = 0.5 * (a + b);\n            // P[j-1](c)\n            double hmc = H0;\n            // P[j](c)\n            double hc = H1 * c;\n            boolean done = false;\n            while (!done) {\n                done = b - a <= Math.ulp(c);\n                hmc = H0;\n                hc = H1 * c;\n                for (int j = 1; j < numberOfPoints; j++) {\n                    // Compute H[j+1](c)\n                    final double jp1 = j + 1;\n                    final double s = FastMath.sqrt(2 / jp1);\n                    final double sm = FastMath.sqrt(j / jp1);\n                    final double hpc = s * c * hc - sm * hmc;\n                    hmc = hc;\n                    hc = hpc;\n                }\n                // Now h = H[n+1](c) and hm = H[n](c).\n                if (!done) {\n                    if (ha * hc < 0) {\n                        b = c;\n                        hmb = hmc;\n                        hb = hc;\n                    } else {\n                        a = c;\n                        hma = hmc;\n                        ha = hc;\n                    }\n                    c = 0.5 * (a + b);\n                }\n            }\n            final double d = sqrtTwoTimesNumPoints * hmc;\n            final double w = 2 / (d * d);\n\n            points[i] = c;\n            weights[i] = w;\n\n            final int idx = lastNumPoints - i;\nidx[(idx - 1)] = +c;\n            weights[idx] = w;\n        }\n\n        // If \"numberOfPoints\" is odd, 0 is a root.\n        // Note: as written, the test for oddness will work for negative\n        // integers too (although it is not necessary here), preventing\n        // a FindBugs warning.\n        if (numberOfPoints % 2 != 0) {\n            double hm = H0;\n            for (int j = 1; j < numberOfPoints; j += 2) {\n                final double jp1 = j + 1;\n                hm = -FastMath.sqrt(j / jp1) * hm;\n            }\n            final double d = sqrtTwoTimesNumPoints * hm;\n            final double w = 2 / (d * d);\n\n            points[iMax] = 0d;\n            weights[iMax] = w;\n        }\n\n        return new Pair<Double[], Double[]>(points, weights);\n    }",
          "32": "    protected Pair<Double[], Double[]> computeRule(int numberOfPoints)\n        throws DimensionMismatchException {\n\n        if (numberOfPoints == 1) {\n            // Break recursion.\n            return new Pair<Double[], Double[]>(new Double[] { 0d },\n                                                new Double[] { SQRT_PI });\n        }\n\n        // Get previous rule.\n        // If it has not been computed yet it will trigger a recursive call\n        // to this method.\n        final int lastNumPoints = numberOfPoints - 1;\n        final Double[] previousPoints = getRuleInternal(lastNumPoints).getFirst();\n\n        // Compute next rule.\n        final Double[] points = new Double[numberOfPoints];\n        final Double[] weights = new Double[numberOfPoints];\n\n        final double sqrtTwoTimesLastNumPoints = FastMath.sqrt(2 * lastNumPoints);\n        final double sqrtTwoTimesNumPoints = FastMath.sqrt(2 * numberOfPoints);\n\n        // Find i-th root of H[n+1] by bracketing.\n        final int iMax = numberOfPoints / 2;\n        for (int i = 0; i < iMax; i++) {\n            // Lower-bound of the interval.\n            double a = (i == 0) ? -sqrtTwoTimesLastNumPoints : previousPoints[i - 1].doubleValue();\n            // Upper-bound of the interval.\n            double b = (iMax == 1) ? -0.5 : previousPoints[i].doubleValue();\n\n            // H[j-1](a)\n            double hma = H0;\n            // H[j](a)\n            double ha = H1 * a;\n            // H[j-1](b)\n            double hmb = H0;\n            // H[j](b)\n            double hb = H1 * b;\n            for (int j = 1; j < numberOfPoints; j++) {\n                // Compute H[j+1](a) and H[j+1](b)\n                final double jp1 = j + 1;\n                final double s = FastMath.sqrt(2 / jp1);\n                final double sm = FastMath.sqrt(j / jp1);\n                final double hpa = s * a * ha - sm * hma;\n                final double hpb = s * b * hb - sm * hmb;\n                hma = ha;\n                ha = hpa;\n                hmb = hb;\n                hb = hpb;\n            }\n\n            // Now ha = H[n+1](a), and hma = H[n](a) (same holds for b).\n            // Middle of the interval.\n            double c = 0.5 * (a + b);\n            // P[j-1](c)\n            double hmc = H0;\n            // P[j](c)\n            double hc = H1 * c;\n            boolean done = false;\n            while (!done) {\n                done = b - a <= Math.ulp(c);\n                hmc = H0;\n                hc = H1 * c;\n                for (int j = 1; j < numberOfPoints; j++) {\n                    // Compute H[j+1](c)\n                    final double jp1 = j + 1;\n                    final double s = FastMath.sqrt(2 / jp1);\n                    final double sm = FastMath.sqrt(j / jp1);\n                    final double hpc = s * c * hc - sm * hmc;\n                    hmc = hc;\n                    hc = hpc;\n                }\n                // Now h = H[n+1](c) and hm = H[n](c).\n                if (!done) {\n                    if (ha * hc < 0) {\n                        b = c;\n                        hmb = hmc;\n                        hb = hc;\n                    } else {\n                        a = c;\n                        hma = hmc;\n                        ha = hc;\n                    }\n                    c = 0.5 * (a + b);\n                }\n            }\n            final double d = sqrtTwoTimesNumPoints * hmc;\n            final double w = 2 / (d * d);\n\n            points[i] = c;\n            weights[i] = w;\n\n            final int idx = lastNumPoints - i;\nc[(points + 1)] = +c;\n            weights[idx] = w;\n        }\n\n        // If \"numberOfPoints\" is odd, 0 is a root.\n        // Note: as written, the test for oddness will work for negative\n        // integers too (although it is not necessary here), preventing\n        // a FindBugs warning.\n        if (numberOfPoints % 2 != 0) {\n            double hm = H0;\n            for (int j = 1; j < numberOfPoints; j += 2) {\n                final double jp1 = j + 1;\n                hm = -FastMath.sqrt(j / jp1) * hm;\n            }\n            final double d = sqrtTwoTimesNumPoints * hm;\n            final double w = 2 / (d * d);\n\n            points[iMax] = 0d;\n            weights[iMax] = w;\n        }\n\n        return new Pair<Double[], Double[]>(points, weights);\n    }",
          "33": "    protected Pair<Double[], Double[]> computeRule(int numberOfPoints)\n        throws DimensionMismatchException {\n\n        if (numberOfPoints == 1) {\n            // Break recursion.\n            return new Pair<Double[], Double[]>(new Double[] { 0d },\n                                                new Double[] { SQRT_PI });\n        }\n\n        // Get previous rule.\n        // If it has not been computed yet it will trigger a recursive call\n        // to this method.\n        final int lastNumPoints = numberOfPoints - 1;\n        final Double[] previousPoints = getRuleInternal(lastNumPoints).getFirst();\n\n        // Compute next rule.\n        final Double[] points = new Double[numberOfPoints];\n        final Double[] weights = new Double[numberOfPoints];\n\n        final double sqrtTwoTimesLastNumPoints = FastMath.sqrt(2 * lastNumPoints);\n        final double sqrtTwoTimesNumPoints = FastMath.sqrt(2 * numberOfPoints);\n\n        // Find i-th root of H[n+1] by bracketing.\n        final int iMax = numberOfPoints / 2;\n        for (int i = 0; i < iMax; i++) {\n            // Lower-bound of the interval.\n            double a = (i == 0) ? -sqrtTwoTimesLastNumPoints : previousPoints[i - 1].doubleValue();\n            // Upper-bound of the interval.\n            double b = (iMax == 1) ? -0.5 : previousPoints[i].doubleValue();\n\n            // H[j-1](a)\n            double hma = H0;\n            // H[j](a)\n            double ha = H1 * a;\n            // H[j-1](b)\n            double hmb = H0;\n            // H[j](b)\n            double hb = H1 * b;\n            for (int j = 1; j < numberOfPoints; j++) {\n                // Compute H[j+1](a) and H[j+1](b)\n                final double jp1 = j + 1;\n                final double s = FastMath.sqrt(2 / jp1);\n                final double sm = FastMath.sqrt(j / jp1);\n                final double hpa = s * a * ha - sm * hma;\n                final double hpb = s * b * hb - sm * hmb;\n                hma = ha;\n                ha = hpa;\n                hmb = hb;\n                hb = hpb;\n            }\n\n            // Now ha = H[n+1](a), and hma = H[n](a) (same holds for b).\n            // Middle of the interval.\n            double c = 0.5 * (a + b);\n            // P[j-1](c)\n            double hmc = H0;\n            // P[j](c)\n            double hc = H1 * c;\n            boolean done = false;\n            while (!done) {\n                done = b - a <= Math.ulp(c);\n                hmc = H0;\n                hc = H1 * c;\n                for (int j = 1; j < numberOfPoints; j++) {\n                    // Compute H[j+1](c)\n                    final double jp1 = j + 1;\n                    final double s = FastMath.sqrt(2 / jp1);\n                    final double sm = FastMath.sqrt(j / jp1);\n                    final double hpc = s * c * hc - sm * hmc;\n                    hmc = hc;\n                    hc = hpc;\n                }\n                // Now h = H[n+1](c) and hm = H[n](c).\n                if (!done) {\n                    if (ha * hc < 0) {\n                        b = c;\n                        hmb = hmc;\n                        hb = hc;\n                    } else {\n                        a = c;\n                        hma = hmc;\n                        ha = hc;\n                    }\n                    c = 0.5 * (a + b);\n                }\n            }\n            final double d = sqrtTwoTimesNumPoints * hmc;\n            final double w = 2 / (d * d);\n\n            points[i] = c;\n            weights[i] = w;\n\n            final int idx = lastNumPoints - i;\npoints[(idx + idx)] = +c;\n            weights[idx] = w;\n        }\n\n        // If \"numberOfPoints\" is odd, 0 is a root.\n        // Note: as written, the test for oddness will work for negative\n        // integers too (although it is not necessary here), preventing\n        // a FindBugs warning.\n        if (numberOfPoints % 2 != 0) {\n            double hm = H0;\n            for (int j = 1; j < numberOfPoints; j += 2) {\n                final double jp1 = j + 1;\n                hm = -FastMath.sqrt(j / jp1) * hm;\n            }\n            final double d = sqrtTwoTimesNumPoints * hm;\n            final double w = 2 / (d * d);\n\n            points[iMax] = 0d;\n            weights[iMax] = w;\n        }\n\n        return new Pair<Double[], Double[]>(points, weights);\n    }",
          "34": "    protected Pair<Double[], Double[]> computeRule(int numberOfPoints)\n        throws DimensionMismatchException {\n\n        if (numberOfPoints == 1) {\n            // Break recursion.\n            return new Pair<Double[], Double[]>(new Double[] { 0d },\n                                                new Double[] { SQRT_PI });\n        }\n\n        // Get previous rule.\n        // If it has not been computed yet it will trigger a recursive call\n        // to this method.\n        final int lastNumPoints = numberOfPoints - 1;\n        final Double[] previousPoints = getRuleInternal(lastNumPoints).getFirst();\n\n        // Compute next rule.\n        final Double[] points = new Double[numberOfPoints];\n        final Double[] weights = new Double[numberOfPoints];\n\n        final double sqrtTwoTimesLastNumPoints = FastMath.sqrt(2 * lastNumPoints);\n        final double sqrtTwoTimesNumPoints = FastMath.sqrt(2 * numberOfPoints);\n\n        // Find i-th root of H[n+1] by bracketing.\n        final int iMax = numberOfPoints / 2;\n        for (int i = 0; i < iMax; i++) {\n            // Lower-bound of the interval.\n            double a = (i == 0) ? -sqrtTwoTimesLastNumPoints : previousPoints[i - 1].doubleValue();\n            // Upper-bound of the interval.\n            double b = (iMax == 1) ? -0.5 : previousPoints[i].doubleValue();\n\n            // H[j-1](a)\n            double hma = H0;\n            // H[j](a)\n            double ha = H1 * a;\n            // H[j-1](b)\n            double hmb = H0;\n            // H[j](b)\n            double hb = H1 * b;\n            for (int j = 1; j < numberOfPoints; j++) {\n                // Compute H[j+1](a) and H[j+1](b)\n                final double jp1 = j + 1;\n                final double s = FastMath.sqrt(2 / jp1);\n                final double sm = FastMath.sqrt(j / jp1);\n                final double hpa = s * a * ha - sm * hma;\n                final double hpb = s * b * hb - sm * hmb;\n                hma = ha;\n                ha = hpa;\n                hmb = hb;\n                hb = hpb;\n            }\n\n            // Now ha = H[n+1](a), and hma = H[n](a) (same holds for b).\n            // Middle of the interval.\n            double c = 0.5 * (a + b);\n            // P[j-1](c)\n            double hmc = H0;\n            // P[j](c)\n            double hc = H1 * c;\n            boolean done = false;\n            while (!done) {\n                done = b - a <= Math.ulp(c);\n                hmc = H0;\n                hc = H1 * c;\n                for (int j = 1; j < numberOfPoints; j++) {\n                    // Compute H[j+1](c)\n                    final double jp1 = j + 1;\n                    final double s = FastMath.sqrt(2 / jp1);\n                    final double sm = FastMath.sqrt(j / jp1);\n                    final double hpc = s * c * hc - sm * hmc;\n                    hmc = hc;\n                    hc = hpc;\n                }\n                // Now h = H[n+1](c) and hm = H[n](c).\n                if (!done) {\n                    if (ha * hc < 0) {\n                        b = c;\n                        hmb = hmc;\n                        hb = hc;\n                    } else {\n                        a = c;\n                        hma = hmc;\n                        ha = hc;\n                    }\n                    c = 0.5 * (a + b);\n                }\n            }\n            final double d = sqrtTwoTimesNumPoints * hmc;\n            final double w = 2 / (d * d);\n\n            points[i] = c;\n            weights[i] = w;\n\n            final int idx = lastNumPoints - i;\nc[(idx - 1)] = +c;\n            weights[idx] = w;\n        }\n\n        // If \"numberOfPoints\" is odd, 0 is a root.\n        // Note: as written, the test for oddness will work for negative\n        // integers too (although it is not necessary here), preventing\n        // a FindBugs warning.\n        if (numberOfPoints % 2 != 0) {\n            double hm = H0;\n            for (int j = 1; j < numberOfPoints; j += 2) {\n                final double jp1 = j + 1;\n                hm = -FastMath.sqrt(j / jp1) * hm;\n            }\n            final double d = sqrtTwoTimesNumPoints * hm;\n            final double w = 2 / (d * d);\n\n            points[iMax] = 0d;\n            weights[iMax] = w;\n        }\n\n        return new Pair<Double[], Double[]>(points, weights);\n    }",
          "35": "    protected Pair<Double[], Double[]> computeRule(int numberOfPoints)\n        throws DimensionMismatchException {\n\n        if (numberOfPoints == 1) {\n            // Break recursion.\n            return new Pair<Double[], Double[]>(new Double[] { 0d },\n                                                new Double[] { SQRT_PI });\n        }\n\n        // Get previous rule.\n        // If it has not been computed yet it will trigger a recursive call\n        // to this method.\n        final int lastNumPoints = numberOfPoints - 1;\n        final Double[] previousPoints = getRuleInternal(lastNumPoints).getFirst();\n\n        // Compute next rule.\n        final Double[] points = new Double[numberOfPoints];\n        final Double[] weights = new Double[numberOfPoints];\n\n        final double sqrtTwoTimesLastNumPoints = FastMath.sqrt(2 * lastNumPoints);\n        final double sqrtTwoTimesNumPoints = FastMath.sqrt(2 * numberOfPoints);\n\n        // Find i-th root of H[n+1] by bracketing.\n        final int iMax = numberOfPoints / 2;\n        for (int i = 0; i < iMax; i++) {\n            // Lower-bound of the interval.\n            double a = (i == 0) ? -sqrtTwoTimesLastNumPoints : previousPoints[i - 1].doubleValue();\n            // Upper-bound of the interval.\n            double b = (iMax == 1) ? -0.5 : previousPoints[i].doubleValue();\n\n            // H[j-1](a)\n            double hma = H0;\n            // H[j](a)\n            double ha = H1 * a;\n            // H[j-1](b)\n            double hmb = H0;\n            // H[j](b)\n            double hb = H1 * b;\n            for (int j = 1; j < numberOfPoints; j++) {\n                // Compute H[j+1](a) and H[j+1](b)\n                final double jp1 = j + 1;\n                final double s = FastMath.sqrt(2 / jp1);\n                final double sm = FastMath.sqrt(j / jp1);\n                final double hpa = s * a * ha - sm * hma;\n                final double hpb = s * b * hb - sm * hmb;\n                hma = ha;\n                ha = hpa;\n                hmb = hb;\n                hb = hpb;\n            }\n\n            // Now ha = H[n+1](a), and hma = H[n](a) (same holds for b).\n            // Middle of the interval.\n            double c = 0.5 * (a + b);\n            // P[j-1](c)\n            double hmc = H0;\n            // P[j](c)\n            double hc = H1 * c;\n            boolean done = false;\n            while (!done) {\n                done = b - a <= Math.ulp(c);\n                hmc = H0;\n                hc = H1 * c;\n                for (int j = 1; j < numberOfPoints; j++) {\n                    // Compute H[j+1](c)\n                    final double jp1 = j + 1;\n                    final double s = FastMath.sqrt(2 / jp1);\n                    final double sm = FastMath.sqrt(j / jp1);\n                    final double hpc = s * c * hc - sm * hmc;\n                    hmc = hc;\n                    hc = hpc;\n                }\n                // Now h = H[n+1](c) and hm = H[n](c).\n                if (!done) {\n                    if (ha * hc < 0) {\n                        b = c;\n                        hmb = hmc;\n                        hb = hc;\n                    } else {\n                        a = c;\n                        hma = hmc;\n                        ha = hc;\n                    }\n                    c = 0.5 * (a + b);\n                }\n            }\n            final double d = sqrtTwoTimesNumPoints * hmc;\n            final double w = 2 / (d * d);\n\n            points[i] = c;\n            weights[i] = w;\n\n            final int idx = lastNumPoints - i;\nidx[(idx + idx)] = +c;\n            weights[idx] = w;\n        }\n\n        // If \"numberOfPoints\" is odd, 0 is a root.\n        // Note: as written, the test for oddness will work for negative\n        // integers too (although it is not necessary here), preventing\n        // a FindBugs warning.\n        if (numberOfPoints % 2 != 0) {\n            double hm = H0;\n            for (int j = 1; j < numberOfPoints; j += 2) {\n                final double jp1 = j + 1;\n                hm = -FastMath.sqrt(j / jp1) * hm;\n            }\n            final double d = sqrtTwoTimesNumPoints * hm;\n            final double w = 2 / (d * d);\n\n            points[iMax] = 0d;\n            weights[iMax] = w;\n        }\n\n        return new Pair<Double[], Double[]>(points, weights);\n    }",
          "36": "    protected Pair<Double[], Double[]> computeRule(int numberOfPoints)\n        throws DimensionMismatchException {\n\n        if (numberOfPoints == 1) {\n            // Break recursion.\n            return new Pair<Double[], Double[]>(new Double[] { 0d },\n                                                new Double[] { SQRT_PI });\n        }\n\n        // Get previous rule.\n        // If it has not been computed yet it will trigger a recursive call\n        // to this method.\n        final int lastNumPoints = numberOfPoints - 1;\n        final Double[] previousPoints = getRuleInternal(lastNumPoints).getFirst();\n\n        // Compute next rule.\n        final Double[] points = new Double[numberOfPoints];\n        final Double[] weights = new Double[numberOfPoints];\n\n        final double sqrtTwoTimesLastNumPoints = FastMath.sqrt(2 * lastNumPoints);\n        final double sqrtTwoTimesNumPoints = FastMath.sqrt(2 * numberOfPoints);\n\n        // Find i-th root of H[n+1] by bracketing.\n        final int iMax = numberOfPoints / 2;\n        for (int i = 0; i < iMax; i++) {\n            // Lower-bound of the interval.\n            double a = (i == 0) ? -sqrtTwoTimesLastNumPoints : previousPoints[i - 1].doubleValue();\n            // Upper-bound of the interval.\n            double b = (iMax == 1) ? -0.5 : previousPoints[i].doubleValue();\n\n            // H[j-1](a)\n            double hma = H0;\n            // H[j](a)\n            double ha = H1 * a;\n            // H[j-1](b)\n            double hmb = H0;\n            // H[j](b)\n            double hb = H1 * b;\n            for (int j = 1; j < numberOfPoints; j++) {\n                // Compute H[j+1](a) and H[j+1](b)\n                final double jp1 = j + 1;\n                final double s = FastMath.sqrt(2 / jp1);\n                final double sm = FastMath.sqrt(j / jp1);\n                final double hpa = s * a * ha - sm * hma;\n                final double hpb = s * b * hb - sm * hmb;\n                hma = ha;\n                ha = hpa;\n                hmb = hb;\n                hb = hpb;\n            }\n\n            // Now ha = H[n+1](a), and hma = H[n](a) (same holds for b).\n            // Middle of the interval.\n            double c = 0.5 * (a + b);\n            // P[j-1](c)\n            double hmc = H0;\n            // P[j](c)\n            double hc = H1 * c;\n            boolean done = false;\n            while (!done) {\n                done = b - a <= Math.ulp(c);\n                hmc = H0;\n                hc = H1 * c;\n                for (int j = 1; j < numberOfPoints; j++) {\n                    // Compute H[j+1](c)\n                    final double jp1 = j + 1;\n                    final double s = FastMath.sqrt(2 / jp1);\n                    final double sm = FastMath.sqrt(j / jp1);\n                    final double hpc = s * c * hc - sm * hmc;\n                    hmc = hc;\n                    hc = hpc;\n                }\n                // Now h = H[n+1](c) and hm = H[n](c).\n                if (!done) {\n                    if (ha * hc < 0) {\n                        b = c;\n                        hmb = hmc;\n                        hb = hc;\n                    } else {\n                        a = c;\n                        hma = hmc;\n                        ha = hc;\n                    }\n                    c = 0.5 * (a + b);\n                }\n            }\n            final double d = sqrtTwoTimesNumPoints * hmc;\n            final double w = 2 / (d * d);\n\n            points[i] = c;\n            weights[i] = w;\n\n            final int idx = lastNumPoints - i;\npoints[idx] = (idx + 0);\n            weights[idx] = w;\n        }\n\n        // If \"numberOfPoints\" is odd, 0 is a root.\n        // Note: as written, the test for oddness will work for negative\n        // integers too (although it is not necessary here), preventing\n        // a FindBugs warning.\n        if (numberOfPoints % 2 != 0) {\n            double hm = H0;\n            for (int j = 1; j < numberOfPoints; j += 2) {\n                final double jp1 = j + 1;\n                hm = -FastMath.sqrt(j / jp1) * hm;\n            }\n            final double d = sqrtTwoTimesNumPoints * hm;\n            final double w = 2 / (d * d);\n\n            points[iMax] = 0d;\n            weights[iMax] = w;\n        }\n\n        return new Pair<Double[], Double[]>(points, weights);\n    }",
          "37": "    protected Pair<Double[], Double[]> computeRule(int numberOfPoints)\n        throws DimensionMismatchException {\n\n        if (numberOfPoints == 1) {\n            // Break recursion.\n            return new Pair<Double[], Double[]>(new Double[] { 0d },\n                                                new Double[] { SQRT_PI });\n        }\n\n        // Get previous rule.\n        // If it has not been computed yet it will trigger a recursive call\n        // to this method.\n        final int lastNumPoints = numberOfPoints - 1;\n        final Double[] previousPoints = getRuleInternal(lastNumPoints).getFirst();\n\n        // Compute next rule.\n        final Double[] points = new Double[numberOfPoints];\n        final Double[] weights = new Double[numberOfPoints];\n\n        final double sqrtTwoTimesLastNumPoints = FastMath.sqrt(2 * lastNumPoints);\n        final double sqrtTwoTimesNumPoints = FastMath.sqrt(2 * numberOfPoints);\n\n        // Find i-th root of H[n+1] by bracketing.\n        final int iMax = numberOfPoints / 2;\n        for (int i = 0; i < iMax; i++) {\n            // Lower-bound of the interval.\n            double a = (i == 0) ? -sqrtTwoTimesLastNumPoints : previousPoints[i - 1].doubleValue();\n            // Upper-bound of the interval.\n            double b = (iMax == 1) ? -0.5 : previousPoints[i].doubleValue();\n\n            // H[j-1](a)\n            double hma = H0;\n            // H[j](a)\n            double ha = H1 * a;\n            // H[j-1](b)\n            double hmb = H0;\n            // H[j](b)\n            double hb = H1 * b;\n            for (int j = 1; j < numberOfPoints; j++) {\n                // Compute H[j+1](a) and H[j+1](b)\n                final double jp1 = j + 1;\n                final double s = FastMath.sqrt(2 / jp1);\n                final double sm = FastMath.sqrt(j / jp1);\n                final double hpa = s * a * ha - sm * hma;\n                final double hpb = s * b * hb - sm * hmb;\n                hma = ha;\n                ha = hpa;\n                hmb = hb;\n                hb = hpb;\n            }\n\n            // Now ha = H[n+1](a), and hma = H[n](a) (same holds for b).\n            // Middle of the interval.\n            double c = 0.5 * (a + b);\n            // P[j-1](c)\n            double hmc = H0;\n            // P[j](c)\n            double hc = H1 * c;\n            boolean done = false;\n            while (!done) {\n                done = b - a <= Math.ulp(c);\n                hmc = H0;\n                hc = H1 * c;\n                for (int j = 1; j < numberOfPoints; j++) {\n                    // Compute H[j+1](c)\n                    final double jp1 = j + 1;\n                    final double s = FastMath.sqrt(2 / jp1);\n                    final double sm = FastMath.sqrt(j / jp1);\n                    final double hpc = s * c * hc - sm * hmc;\n                    hmc = hc;\n                    hc = hpc;\n                }\n                // Now h = H[n+1](c) and hm = H[n](c).\n                if (!done) {\n                    if (ha * hc < 0) {\n                        b = c;\n                        hmb = hmc;\n                        hb = hc;\n                    } else {\n                        a = c;\n                        hma = hmc;\n                        ha = hc;\n                    }\n                    c = 0.5 * (a + b);\n                }\n            }\n            final double d = sqrtTwoTimesNumPoints * hmc;\n            final double w = 2 / (d * d);\n\n            points[i] = c;\n            weights[i] = w;\n\n            final int idx = lastNumPoints - i;\npoints[(idx + 2)] = +c;\n            weights[idx] = w;\n        }\n\n        // If \"numberOfPoints\" is odd, 0 is a root.\n        // Note: as written, the test for oddness will work for negative\n        // integers too (although it is not necessary here), preventing\n        // a FindBugs warning.\n        if (numberOfPoints % 2 != 0) {\n            double hm = H0;\n            for (int j = 1; j < numberOfPoints; j += 2) {\n                final double jp1 = j + 1;\n                hm = -FastMath.sqrt(j / jp1) * hm;\n            }\n            final double d = sqrtTwoTimesNumPoints * hm;\n            final double w = 2 / (d * d);\n\n            points[iMax] = 0d;\n            weights[iMax] = w;\n        }\n\n        return new Pair<Double[], Double[]>(points, weights);\n    }",
          "38": "    protected Pair<Double[], Double[]> computeRule(int numberOfPoints)\n        throws DimensionMismatchException {\n\n        if (numberOfPoints == 1) {\n            // Break recursion.\n            return new Pair<Double[], Double[]>(new Double[] { 0d },\n                                                new Double[] { SQRT_PI });\n        }\n\n        // Get previous rule.\n        // If it has not been computed yet it will trigger a recursive call\n        // to this method.\n        final int lastNumPoints = numberOfPoints - 1;\n        final Double[] previousPoints = getRuleInternal(lastNumPoints).getFirst();\n\n        // Compute next rule.\n        final Double[] points = new Double[numberOfPoints];\n        final Double[] weights = new Double[numberOfPoints];\n\n        final double sqrtTwoTimesLastNumPoints = FastMath.sqrt(2 * lastNumPoints);\n        final double sqrtTwoTimesNumPoints = FastMath.sqrt(2 * numberOfPoints);\n\n        // Find i-th root of H[n+1] by bracketing.\n        final int iMax = numberOfPoints / 2;\n        for (int i = 0; i < iMax; i++) {\n            // Lower-bound of the interval.\n            double a = (i == 0) ? -sqrtTwoTimesLastNumPoints : previousPoints[i - 1].doubleValue();\n            // Upper-bound of the interval.\n            double b = (iMax == 1) ? -0.5 : previousPoints[i].doubleValue();\n\n            // H[j-1](a)\n            double hma = H0;\n            // H[j](a)\n            double ha = H1 * a;\n            // H[j-1](b)\n            double hmb = H0;\n            // H[j](b)\n            double hb = H1 * b;\n            for (int j = 1; j < numberOfPoints; j++) {\n                // Compute H[j+1](a) and H[j+1](b)\n                final double jp1 = j + 1;\n                final double s = FastMath.sqrt(2 / jp1);\n                final double sm = FastMath.sqrt(j / jp1);\n                final double hpa = s * a * ha - sm * hma;\n                final double hpb = s * b * hb - sm * hmb;\n                hma = ha;\n                ha = hpa;\n                hmb = hb;\n                hb = hpb;\n            }\n\n            // Now ha = H[n+1](a), and hma = H[n](a) (same holds for b).\n            // Middle of the interval.\n            double c = 0.5 * (a + b);\n            // P[j-1](c)\n            double hmc = H0;\n            // P[j](c)\n            double hc = H1 * c;\n            boolean done = false;\n            while (!done) {\n                done = b - a <= Math.ulp(c);\n                hmc = H0;\n                hc = H1 * c;\n                for (int j = 1; j < numberOfPoints; j++) {\n                    // Compute H[j+1](c)\n                    final double jp1 = j + 1;\n                    final double s = FastMath.sqrt(2 / jp1);\n                    final double sm = FastMath.sqrt(j / jp1);\n                    final double hpc = s * c * hc - sm * hmc;\n                    hmc = hc;\n                    hc = hpc;\n                }\n                // Now h = H[n+1](c) and hm = H[n](c).\n                if (!done) {\n                    if (ha * hc < 0) {\n                        b = c;\n                        hmb = hmc;\n                        hb = hc;\n                    } else {\n                        a = c;\n                        hma = hmc;\n                        ha = hc;\n                    }\n                    c = 0.5 * (a + b);\n                }\n            }\n            final double d = sqrtTwoTimesNumPoints * hmc;\n            final double w = 2 / (d * d);\n\n            points[i] = c;\n            weights[i] = w;\n\n            final int idx = lastNumPoints - i;\nreturn;\n            points[idx] = +c;            weights[idx] = w;\n        }\n\n        // If \"numberOfPoints\" is odd, 0 is a root.\n        // Note: as written, the test for oddness will work for negative\n        // integers too (although it is not necessary here), preventing\n        // a FindBugs warning.\n        if (numberOfPoints % 2 != 0) {\n            double hm = H0;\n            for (int j = 1; j < numberOfPoints; j += 2) {\n                final double jp1 = j + 1;\n                hm = -FastMath.sqrt(j / jp1) * hm;\n            }\n            final double d = sqrtTwoTimesNumPoints * hm;\n            final double w = 2 / (d * d);\n\n            points[iMax] = 0d;\n            weights[iMax] = w;\n        }\n\n        return new Pair<Double[], Double[]>(points, weights);\n    }",
          "39": "    protected Pair<Double[], Double[]> computeRule(int numberOfPoints)\n        throws DimensionMismatchException {\n\n        if (numberOfPoints == 1) {\n            // Break recursion.\n            return new Pair<Double[], Double[]>(new Double[] { 0d },\n                                                new Double[] { SQRT_PI });\n        }\n\n        // Get previous rule.\n        // If it has not been computed yet it will trigger a recursive call\n        // to this method.\n        final int lastNumPoints = numberOfPoints - 1;\n        final Double[] previousPoints = getRuleInternal(lastNumPoints).getFirst();\n\n        // Compute next rule.\n        final Double[] points = new Double[numberOfPoints];\n        final Double[] weights = new Double[numberOfPoints];\n\n        final double sqrtTwoTimesLastNumPoints = FastMath.sqrt(2 * lastNumPoints);\n        final double sqrtTwoTimesNumPoints = FastMath.sqrt(2 * numberOfPoints);\n\n        // Find i-th root of H[n+1] by bracketing.\n        final int iMax = numberOfPoints / 2;\n        for (int i = 0; i < iMax; i++) {\n            // Lower-bound of the interval.\n            double a = (i == 0) ? -sqrtTwoTimesLastNumPoints : previousPoints[i - 1].doubleValue();\n            // Upper-bound of the interval.\n            double b = (iMax == 1) ? -0.5 : previousPoints[i].doubleValue();\n\n            // H[j-1](a)\n            double hma = H0;\n            // H[j](a)\n            double ha = H1 * a;\n            // H[j-1](b)\n            double hmb = H0;\n            // H[j](b)\n            double hb = H1 * b;\n            for (int j = 1; j < numberOfPoints; j++) {\n                // Compute H[j+1](a) and H[j+1](b)\n                final double jp1 = j + 1;\n                final double s = FastMath.sqrt(2 / jp1);\n                final double sm = FastMath.sqrt(j / jp1);\n                final double hpa = s * a * ha - sm * hma;\n                final double hpb = s * b * hb - sm * hmb;\n                hma = ha;\n                ha = hpa;\n                hmb = hb;\n                hb = hpb;\n            }\n\n            // Now ha = H[n+1](a), and hma = H[n](a) (same holds for b).\n            // Middle of the interval.\n            double c = 0.5 * (a + b);\n            // P[j-1](c)\n            double hmc = H0;\n            // P[j](c)\n            double hc = H1 * c;\n            boolean done = false;\n            while (!done) {\n                done = b - a <= Math.ulp(c);\n                hmc = H0;\n                hc = H1 * c;\n                for (int j = 1; j < numberOfPoints; j++) {\n                    // Compute H[j+1](c)\n                    final double jp1 = j + 1;\n                    final double s = FastMath.sqrt(2 / jp1);\n                    final double sm = FastMath.sqrt(j / jp1);\n                    final double hpc = s * c * hc - sm * hmc;\n                    hmc = hc;\n                    hc = hpc;\n                }\n                // Now h = H[n+1](c) and hm = H[n](c).\n                if (!done) {\n                    if (ha * hc < 0) {\n                        b = c;\n                        hmb = hmc;\n                        hb = hc;\n                    } else {\n                        a = c;\n                        hma = hmc;\n                        ha = hc;\n                    }\n                    c = 0.5 * (a + b);\n                }\n            }\n            final double d = sqrtTwoTimesNumPoints * hmc;\n            final double w = 2 / (d * d);\n\n            points[i] = c;\n            weights[i] = w;\n\n            final int idx = lastNumPoints - i;\npoints[idx] = ((points[idx].[idx] == null))?0:points[idx];\n            weights[idx] = w;\n        }\n\n        // If \"numberOfPoints\" is odd, 0 is a root.\n        // Note: as written, the test for oddness will work for negative\n        // integers too (although it is not necessary here), preventing\n        // a FindBugs warning.\n        if (numberOfPoints % 2 != 0) {\n            double hm = H0;\n            for (int j = 1; j < numberOfPoints; j += 2) {\n                final double jp1 = j + 1;\n                hm = -FastMath.sqrt(j / jp1) * hm;\n            }\n            final double d = sqrtTwoTimesNumPoints * hm;\n            final double w = 2 / (d * d);\n\n            points[iMax] = 0d;\n            weights[iMax] = w;\n        }\n\n        return new Pair<Double[], Double[]>(points, weights);\n    }",
          "40": "    protected Pair<Double[], Double[]> computeRule(int numberOfPoints)\n        throws DimensionMismatchException {\n\n        if (numberOfPoints == 1) {\n            // Break recursion.\n            return new Pair<Double[], Double[]>(new Double[] { 0d },\n                                                new Double[] { SQRT_PI });\n        }\n\n        // Get previous rule.\n        // If it has not been computed yet it will trigger a recursive call\n        // to this method.\n        final int lastNumPoints = numberOfPoints - 1;\n        final Double[] previousPoints = getRuleInternal(lastNumPoints).getFirst();\n\n        // Compute next rule.\n        final Double[] points = new Double[numberOfPoints];\n        final Double[] weights = new Double[numberOfPoints];\n\n        final double sqrtTwoTimesLastNumPoints = FastMath.sqrt(2 * lastNumPoints);\n        final double sqrtTwoTimesNumPoints = FastMath.sqrt(2 * numberOfPoints);\n\n        // Find i-th root of H[n+1] by bracketing.\n        final int iMax = numberOfPoints / 2;\n        for (int i = 0; i < iMax; i++) {\n            // Lower-bound of the interval.\n            double a = (i == 0) ? -sqrtTwoTimesLastNumPoints : previousPoints[i - 1].doubleValue();\n            // Upper-bound of the interval.\n            double b = (iMax == 1) ? -0.5 : previousPoints[i].doubleValue();\n\n            // H[j-1](a)\n            double hma = H0;\n            // H[j](a)\n            double ha = H1 * a;\n            // H[j-1](b)\n            double hmb = H0;\n            // H[j](b)\n            double hb = H1 * b;\n            for (int j = 1; j < numberOfPoints; j++) {\n                // Compute H[j+1](a) and H[j+1](b)\n                final double jp1 = j + 1;\n                final double s = FastMath.sqrt(2 / jp1);\n                final double sm = FastMath.sqrt(j / jp1);\n                final double hpa = s * a * ha - sm * hma;\n                final double hpb = s * b * hb - sm * hmb;\n                hma = ha;\n                ha = hpa;\n                hmb = hb;\n                hb = hpb;\n            }\n\n            // Now ha = H[n+1](a), and hma = H[n](a) (same holds for b).\n            // Middle of the interval.\n            double c = 0.5 * (a + b);\n            // P[j-1](c)\n            double hmc = H0;\n            // P[j](c)\n            double hc = H1 * c;\n            boolean done = false;\n            while (!done) {\n                done = b - a <= Math.ulp(c);\n                hmc = H0;\n                hc = H1 * c;\n                for (int j = 1; j < numberOfPoints; j++) {\n                    // Compute H[j+1](c)\n                    final double jp1 = j + 1;\n                    final double s = FastMath.sqrt(2 / jp1);\n                    final double sm = FastMath.sqrt(j / jp1);\n                    final double hpc = s * c * hc - sm * hmc;\n                    hmc = hc;\n                    hc = hpc;\n                }\n                // Now h = H[n+1](c) and hm = H[n](c).\n                if (!done) {\n                    if (ha * hc < 0) {\n                        b = c;\n                        hmb = hmc;\n                        hb = hc;\n                    } else {\n                        a = c;\n                        hma = hmc;\n                        ha = hc;\n                    }\n                    c = 0.5 * (a + b);\n                }\n            }\n            final double d = sqrtTwoTimesNumPoints * hmc;\n            final double w = 2 / (d * d);\n\n            points[i] = c;\n            weights[i] = w;\n\n            final int idx = lastNumPoints - i;\npoints[idx] = ((c[idx].[idx] == null))?0:points[idx];\n            weights[idx] = w;\n        }\n\n        // If \"numberOfPoints\" is odd, 0 is a root.\n        // Note: as written, the test for oddness will work for negative\n        // integers too (although it is not necessary here), preventing\n        // a FindBugs warning.\n        if (numberOfPoints % 2 != 0) {\n            double hm = H0;\n            for (int j = 1; j < numberOfPoints; j += 2) {\n                final double jp1 = j + 1;\n                hm = -FastMath.sqrt(j / jp1) * hm;\n            }\n            final double d = sqrtTwoTimesNumPoints * hm;\n            final double w = 2 / (d * d);\n\n            points[iMax] = 0d;\n            weights[iMax] = w;\n        }\n\n        return new Pair<Double[], Double[]>(points, weights);\n    }",
          "41": "    protected Pair<Double[], Double[]> computeRule(int numberOfPoints)\n        throws DimensionMismatchException {\n\n        if (numberOfPoints == 1) {\n            // Break recursion.\n            return new Pair<Double[], Double[]>(new Double[] { 0d },\n                                                new Double[] { SQRT_PI });\n        }\n\n        // Get previous rule.\n        // If it has not been computed yet it will trigger a recursive call\n        // to this method.\n        final int lastNumPoints = numberOfPoints - 1;\n        final Double[] previousPoints = getRuleInternal(lastNumPoints).getFirst();\n\n        // Compute next rule.\n        final Double[] points = new Double[numberOfPoints];\n        final Double[] weights = new Double[numberOfPoints];\n\n        final double sqrtTwoTimesLastNumPoints = FastMath.sqrt(2 * lastNumPoints);\n        final double sqrtTwoTimesNumPoints = FastMath.sqrt(2 * numberOfPoints);\n\n        // Find i-th root of H[n+1] by bracketing.\n        final int iMax = numberOfPoints / 2;\n        for (int i = 0; i < iMax; i++) {\n            // Lower-bound of the interval.\n            double a = (i == 0) ? -sqrtTwoTimesLastNumPoints : previousPoints[i - 1].doubleValue();\n            // Upper-bound of the interval.\n            double b = (iMax == 1) ? -0.5 : previousPoints[i].doubleValue();\n\n            // H[j-1](a)\n            double hma = H0;\n            // H[j](a)\n            double ha = H1 * a;\n            // H[j-1](b)\n            double hmb = H0;\n            // H[j](b)\n            double hb = H1 * b;\n            for (int j = 1; j < numberOfPoints; j++) {\n                // Compute H[j+1](a) and H[j+1](b)\n                final double jp1 = j + 1;\n                final double s = FastMath.sqrt(2 / jp1);\n                final double sm = FastMath.sqrt(j / jp1);\n                final double hpa = s * a * ha - sm * hma;\n                final double hpb = s * b * hb - sm * hmb;\n                hma = ha;\n                ha = hpa;\n                hmb = hb;\n                hb = hpb;\n            }\n\n            // Now ha = H[n+1](a), and hma = H[n](a) (same holds for b).\n            // Middle of the interval.\n            double c = 0.5 * (a + b);\n            // P[j-1](c)\n            double hmc = H0;\n            // P[j](c)\n            double hc = H1 * c;\n            boolean done = false;\n            while (!done) {\n                done = b - a <= Math.ulp(c);\n                hmc = H0;\n                hc = H1 * c;\n                for (int j = 1; j < numberOfPoints; j++) {\n                    // Compute H[j+1](c)\n                    final double jp1 = j + 1;\n                    final double s = FastMath.sqrt(2 / jp1);\n                    final double sm = FastMath.sqrt(j / jp1);\n                    final double hpc = s * c * hc - sm * hmc;\n                    hmc = hc;\n                    hc = hpc;\n                }\n                // Now h = H[n+1](c) and hm = H[n](c).\n                if (!done) {\n                    if (ha * hc < 0) {\n                        b = c;\n                        hmb = hmc;\n                        hb = hc;\n                    } else {\n                        a = c;\n                        hma = hmc;\n                        ha = hc;\n                    }\n                    c = 0.5 * (a + b);\n                }\n            }\n            final double d = sqrtTwoTimesNumPoints * hmc;\n            final double w = 2 / (d * d);\n\n            points[i] = c;\n            weights[i] = w;\n\n            final int idx = lastNumPoints - i;\npoints[idx] = ((points[idx] == null))?0:points[idx];\n            weights[idx] = w;\n        }\n\n        // If \"numberOfPoints\" is odd, 0 is a root.\n        // Note: as written, the test for oddness will work for negative\n        // integers too (although it is not necessary here), preventing\n        // a FindBugs warning.\n        if (numberOfPoints % 2 != 0) {\n            double hm = H0;\n            for (int j = 1; j < numberOfPoints; j += 2) {\n                final double jp1 = j + 1;\n                hm = -FastMath.sqrt(j / jp1) * hm;\n            }\n            final double d = sqrtTwoTimesNumPoints * hm;\n            final double w = 2 / (d * d);\n\n            points[iMax] = 0d;\n            weights[iMax] = w;\n        }\n\n        return new Pair<Double[], Double[]>(points, weights);\n    }",
          "42": "    protected Pair<Double[], Double[]> computeRule(int numberOfPoints)\n        throws DimensionMismatchException {\n\n        if (numberOfPoints == 1) {\n            // Break recursion.\n            return new Pair<Double[], Double[]>(new Double[] { 0d },\n                                                new Double[] { SQRT_PI });\n        }\n\n        // Get previous rule.\n        // If it has not been computed yet it will trigger a recursive call\n        // to this method.\n        final int lastNumPoints = numberOfPoints - 1;\n        final Double[] previousPoints = getRuleInternal(lastNumPoints).getFirst();\n\n        // Compute next rule.\n        final Double[] points = new Double[numberOfPoints];\n        final Double[] weights = new Double[numberOfPoints];\n\n        final double sqrtTwoTimesLastNumPoints = FastMath.sqrt(2 * lastNumPoints);\n        final double sqrtTwoTimesNumPoints = FastMath.sqrt(2 * numberOfPoints);\n\n        // Find i-th root of H[n+1] by bracketing.\n        final int iMax = numberOfPoints / 2;\n        for (int i = 0; i < iMax; i++) {\n            // Lower-bound of the interval.\n            double a = (i == 0) ? -sqrtTwoTimesLastNumPoints : previousPoints[i - 1].doubleValue();\n            // Upper-bound of the interval.\n            double b = (iMax == 1) ? -0.5 : previousPoints[i].doubleValue();\n\n            // H[j-1](a)\n            double hma = H0;\n            // H[j](a)\n            double ha = H1 * a;\n            // H[j-1](b)\n            double hmb = H0;\n            // H[j](b)\n            double hb = H1 * b;\n            for (int j = 1; j < numberOfPoints; j++) {\n                // Compute H[j+1](a) and H[j+1](b)\n                final double jp1 = j + 1;\n                final double s = FastMath.sqrt(2 / jp1);\n                final double sm = FastMath.sqrt(j / jp1);\n                final double hpa = s * a * ha - sm * hma;\n                final double hpb = s * b * hb - sm * hmb;\n                hma = ha;\n                ha = hpa;\n                hmb = hb;\n                hb = hpb;\n            }\n\n            // Now ha = H[n+1](a), and hma = H[n](a) (same holds for b).\n            // Middle of the interval.\n            double c = 0.5 * (a + b);\n            // P[j-1](c)\n            double hmc = H0;\n            // P[j](c)\n            double hc = H1 * c;\n            boolean done = false;\n            while (!done) {\n                done = b - a <= Math.ulp(c);\n                hmc = H0;\n                hc = H1 * c;\n                for (int j = 1; j < numberOfPoints; j++) {\n                    // Compute H[j+1](c)\n                    final double jp1 = j + 1;\n                    final double s = FastMath.sqrt(2 / jp1);\n                    final double sm = FastMath.sqrt(j / jp1);\n                    final double hpc = s * c * hc - sm * hmc;\n                    hmc = hc;\n                    hc = hpc;\n                }\n                // Now h = H[n+1](c) and hm = H[n](c).\n                if (!done) {\n                    if (ha * hc < 0) {\n                        b = c;\n                        hmb = hmc;\n                        hb = hc;\n                    } else {\n                        a = c;\n                        hma = hmc;\n                        ha = hc;\n                    }\n                    c = 0.5 * (a + b);\n                }\n            }\n            final double d = sqrtTwoTimesNumPoints * hmc;\n            final double w = 2 / (d * d);\n\n            points[i] = c;\n            weights[i] = w;\n\n            final int idx = lastNumPoints - i;\npoints[idx] = ((points[idx].[idx] == null))?0:c[idx];\n            weights[idx] = w;\n        }\n\n        // If \"numberOfPoints\" is odd, 0 is a root.\n        // Note: as written, the test for oddness will work for negative\n        // integers too (although it is not necessary here), preventing\n        // a FindBugs warning.\n        if (numberOfPoints % 2 != 0) {\n            double hm = H0;\n            for (int j = 1; j < numberOfPoints; j += 2) {\n                final double jp1 = j + 1;\n                hm = -FastMath.sqrt(j / jp1) * hm;\n            }\n            final double d = sqrtTwoTimesNumPoints * hm;\n            final double w = 2 / (d * d);\n\n            points[iMax] = 0d;\n            weights[iMax] = w;\n        }\n\n        return new Pair<Double[], Double[]>(points, weights);\n    }",
          "43": "    protected Pair<Double[], Double[]> computeRule(int numberOfPoints)\n        throws DimensionMismatchException {\n\n        if (numberOfPoints == 1) {\n            // Break recursion.\n            return new Pair<Double[], Double[]>(new Double[] { 0d },\n                                                new Double[] { SQRT_PI });\n        }\n\n        // Get previous rule.\n        // If it has not been computed yet it will trigger a recursive call\n        // to this method.\n        final int lastNumPoints = numberOfPoints - 1;\n        final Double[] previousPoints = getRuleInternal(lastNumPoints).getFirst();\n\n        // Compute next rule.\n        final Double[] points = new Double[numberOfPoints];\n        final Double[] weights = new Double[numberOfPoints];\n\n        final double sqrtTwoTimesLastNumPoints = FastMath.sqrt(2 * lastNumPoints);\n        final double sqrtTwoTimesNumPoints = FastMath.sqrt(2 * numberOfPoints);\n\n        // Find i-th root of H[n+1] by bracketing.\n        final int iMax = numberOfPoints / 2;\n        for (int i = 0; i < iMax; i++) {\n            // Lower-bound of the interval.\n            double a = (i == 0) ? -sqrtTwoTimesLastNumPoints : previousPoints[i - 1].doubleValue();\n            // Upper-bound of the interval.\n            double b = (iMax == 1) ? -0.5 : previousPoints[i].doubleValue();\n\n            // H[j-1](a)\n            double hma = H0;\n            // H[j](a)\n            double ha = H1 * a;\n            // H[j-1](b)\n            double hmb = H0;\n            // H[j](b)\n            double hb = H1 * b;\n            for (int j = 1; j < numberOfPoints; j++) {\n                // Compute H[j+1](a) and H[j+1](b)\n                final double jp1 = j + 1;\n                final double s = FastMath.sqrt(2 / jp1);\n                final double sm = FastMath.sqrt(j / jp1);\n                final double hpa = s * a * ha - sm * hma;\n                final double hpb = s * b * hb - sm * hmb;\n                hma = ha;\n                ha = hpa;\n                hmb = hb;\n                hb = hpb;\n            }\n\n            // Now ha = H[n+1](a), and hma = H[n](a) (same holds for b).\n            // Middle of the interval.\n            double c = 0.5 * (a + b);\n            // P[j-1](c)\n            double hmc = H0;\n            // P[j](c)\n            double hc = H1 * c;\n            boolean done = false;\n            while (!done) {\n                done = b - a <= Math.ulp(c);\n                hmc = H0;\n                hc = H1 * c;\n                for (int j = 1; j < numberOfPoints; j++) {\n                    // Compute H[j+1](c)\n                    final double jp1 = j + 1;\n                    final double s = FastMath.sqrt(2 / jp1);\n                    final double sm = FastMath.sqrt(j / jp1);\n                    final double hpc = s * c * hc - sm * hmc;\n                    hmc = hc;\n                    hc = hpc;\n                }\n                // Now h = H[n+1](c) and hm = H[n](c).\n                if (!done) {\n                    if (ha * hc < 0) {\n                        b = c;\n                        hmb = hmc;\n                        hb = hc;\n                    } else {\n                        a = c;\n                        hma = hmc;\n                        ha = hc;\n                    }\n                    c = 0.5 * (a + b);\n                }\n            }\n            final double d = sqrtTwoTimesNumPoints * hmc;\n            final double w = 2 / (d * d);\n\n            points[i] = c;\n            weights[i] = w;\n\n            final int idx = lastNumPoints - i;\npoints[idx] = ((points[idx].[idx] == null))?points[idx]:points[idx];\n            weights[idx] = w;\n        }\n\n        // If \"numberOfPoints\" is odd, 0 is a root.\n        // Note: as written, the test for oddness will work for negative\n        // integers too (although it is not necessary here), preventing\n        // a FindBugs warning.\n        if (numberOfPoints % 2 != 0) {\n            double hm = H0;\n            for (int j = 1; j < numberOfPoints; j += 2) {\n                final double jp1 = j + 1;\n                hm = -FastMath.sqrt(j / jp1) * hm;\n            }\n            final double d = sqrtTwoTimesNumPoints * hm;\n            final double w = 2 / (d * d);\n\n            points[iMax] = 0d;\n            weights[iMax] = w;\n        }\n\n        return new Pair<Double[], Double[]>(points, weights);\n    }"
}