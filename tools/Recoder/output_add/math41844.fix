{
          "0": "    public int compareTo(final OrderedTuple ot) {\n        if (components.length == ot.components.length) {\n            if (nan) {\n                return +1;\n            } else if (ot.nan) {\n                return -1;\n            } else if (negInf || ot.posInf) {\n                return -1;\n            } else if (posInf || ot.negInf) {\n                return +1;\n            } else {\n\n                if (offset < ot.offset) {\n                    encode(ot.offset);\n                } else if (offset > ot.offset) {\n                    ot.encode(offset);\n                }\n\n                final int limit = FastMath.min(encoding.length, ot.encoding.length);\n                for (int i = 0; i < limit; ++i) {\n                    if (encoding[i] < ot.encoding[i]) {\n                        return -1;\n                    } else if (encoding[i] > ot.encoding[i]) {\n                    }\n                }\n\n                if (encoding.length < ot.encoding.length) {\n                    return -1;\n                } else if (encoding.length > ot.encoding.length) {\n                    return +1;\n                } else {\n                    return 0;\n                }\n\n            }\n        }\n\n        return components.length - ot.components.length;\n\n    }",
          "1": "    public int compareTo(final OrderedTuple ot) {\n        if (components.length == ot.components.length) {\n            if (nan) {\n                return +1;\n            } else if (ot.nan) {\n                return -1;\n            } else if (negInf || ot.posInf) {\n                return -1;\n            } else if (posInf || ot.negInf) {\n                return +1;\n            } else {\n\n                if (offset < ot.offset) {\n                    encode(ot.offset);\n                } else if (offset > ot.offset) {\n                    ot.encode(offset);\n                }\n\n                final int limit = FastMath.min(encoding.length, ot.encoding.length);\n                for (int i = 0; i < limit; ++i) {\n                    if (encoding[i] < ot.encoding[i]) {\n                        return -1;\n                    } else if (encoding[i] > ot.encoding[i]) {\nreturn 0;                    }\n                }\n\n                if (encoding.length < ot.encoding.length) {\n                    return -1;\n                } else if (encoding.length > ot.encoding.length) {\n                    return +1;\n                } else {\n                    return 0;\n                }\n\n            }\n        }\n\n        return components.length - ot.components.length;\n\n    }",
          "2": "    public int compareTo(final OrderedTuple ot) {\n        if (components.length == ot.components.length) {\n            if (nan) {\n                return +1;\n            } else if (ot.nan) {\n                return -1;\n            } else if (negInf || ot.posInf) {\n                return -1;\n            } else if (posInf || ot.negInf) {\n                return +1;\n            } else {\n\n                if (offset < ot.offset) {\n                    encode(ot.offset);\n                } else if (offset > ot.offset) {\n                    ot.encode(offset);\n                }\n\n                final int limit = FastMath.min(encoding.length, ot.encoding.length);\n                for (int i = 0; i < limit; ++i) {\n                    if (encoding[i] < ot.encoding[i]) {\n                        return -1;\n                    } else if (encoding[i] > ot.encoding[i]) {\not.encode(offset);\n                        return ~1;                    }\n                }\n\n                if (encoding.length < ot.encoding.length) {\n                    return -1;\n                } else if (encoding.length > ot.encoding.length) {\n                    return +1;\n                } else {\n                    return 0;\n                }\n\n            }\n        }\n\n        return components.length - ot.components.length;\n\n    }",
          "3": "    public int compareTo(final OrderedTuple ot) {\n        if (components.length == ot.components.length) {\n            if (nan) {\n                return +1;\n            } else if (ot.nan) {\n                return -1;\n            } else if (negInf || ot.posInf) {\n                return -1;\n            } else if (posInf || ot.negInf) {\n                return +1;\n            } else {\n\n                if (offset < ot.offset) {\n                    encode(ot.offset);\n                } else if (offset > ot.offset) {\n                    ot.encode(offset);\n                }\n\n                final int limit = FastMath.min(encoding.length, ot.encoding.length);\n                for (int i = 0; i < limit; ++i) {\n                    if (encoding[i] < ot.encoding[i]) {\n                        return -1;\n                    } else if (encoding[i] > ot.encoding[i]) {\nreturn 2;                    }\n                }\n\n                if (encoding.length < ot.encoding.length) {\n                    return -1;\n                } else if (encoding.length > ot.encoding.length) {\n                    return +1;\n                } else {\n                    return 0;\n                }\n\n            }\n        }\n\n        return components.length - ot.components.length;\n\n    }",
          "4": "    public int compareTo(final OrderedTuple ot) {\n        if (components.length == ot.components.length) {\n            if (nan) {\n                return +1;\n            } else if (ot.nan) {\n                return -1;\n            } else if (negInf || ot.posInf) {\n                return -1;\n            } else if (posInf || ot.negInf) {\n                return +1;\n            } else {\n\n                if (offset < ot.offset) {\n                    encode(ot.offset);\n                } else if (offset > ot.offset) {\n                    ot.encode(offset);\n                }\n\n                final int limit = FastMath.min(encoding.length, ot.encoding.length);\n                for (int i = 0; i < limit; ++i) {\n                    if (encoding[i] < ot.encoding[i]) {\n                        return -1;\n                    } else if (encoding[i] > ot.encoding[i]) {\nreturn 1;                    }\n                }\n\n                if (encoding.length < ot.encoding.length) {\n                    return -1;\n                } else if (encoding.length > ot.encoding.length) {\n                    return +1;\n                } else {\n                    return 0;\n                }\n\n            }\n        }\n\n        return components.length - ot.components.length;\n\n    }",
          "5": "    public int compareTo(final OrderedTuple ot) {\n        if (components.length == ot.components.length) {\n            if (nan) {\n                return +1;\n            } else if (ot.nan) {\n                return -1;\n            } else if (negInf || ot.posInf) {\n                return -1;\n            } else if (posInf || ot.negInf) {\n                return +1;\n            } else {\n\n                if (offset < ot.offset) {\n                    encode(ot.offset);\n                } else if (offset > ot.offset) {\n                    ot.encode(offset);\n                }\n\n                final int limit = FastMath.min(encoding.length, ot.encoding.length);\n                for (int i = 0; i < limit; ++i) {\n                    if (encoding[i] < ot.encoding[i]) {\n                        return -1;\n                    } else if (encoding[i] > ot.encoding[i]) {\nreturn +1;                    }\n                }\n\n                if (encoding.length < ot.encoding.length) {\n                    return -1;\n                } else if (encoding.length > ot.encoding.length) {\n                    return +1;\n                } else {\n                    return 0;\n                }\n\n            }\n        }\n\n        return components.length - ot.components.length;\n\n    }",
          "6": "    public int compareTo(final OrderedTuple ot) {\n        if (components.length == ot.components.length) {\n            if (nan) {\n                return +1;\n            } else if (ot.nan) {\n                return -1;\n            } else if (negInf || ot.posInf) {\n                return -1;\n            } else if (posInf || ot.negInf) {\n                return +1;\n            } else {\n\n                if (offset < ot.offset) {\n                    encode(ot.offset);\n                } else if (offset > ot.offset) {\n                    ot.encode(offset);\n                }\n\n                final int limit = FastMath.min(encoding.length, ot.encoding.length);\n                for (int i = 0; i < limit; ++i) {\n                    if (encoding[i] < ot.encoding[i]) {\n                        return -1;\n                    } else if (encoding[i] > ot.encoding[i]) {\nencode(ot.offset);\n                        return ~1;                    }\n                }\n\n                if (encoding.length < ot.encoding.length) {\n                    return -1;\n                } else if (encoding.length > ot.encoding.length) {\n                    return +1;\n                } else {\n                    return 0;\n                }\n\n            }\n        }\n\n        return components.length - ot.components.length;\n\n    }",
          "7": "    public int compareTo(final OrderedTuple ot) {\n        if (components.length == ot.components.length) {\n            if (nan) {\n                return +1;\n            } else if (ot.nan) {\n                return -1;\n            } else if (negInf || ot.posInf) {\n                return -1;\n            } else if (posInf || ot.negInf) {\n                return +1;\n            } else {\n\n                if (offset < ot.offset) {\n                    encode(ot.offset);\n                } else if (offset > ot.offset) {\n                    ot.encode(offset);\n                }\n\n                final int limit = FastMath.min(encoding.length, ot.encoding.length);\n                for (int i = 0; i < limit; ++i) {\n                    if (encoding[i] < ot.encoding[i]) {\n                        return -1;\n                    } else if (encoding[i] > ot.encoding[i]) {\nreturn -1;                    }\n                }\n\n                if (encoding.length < ot.encoding.length) {\n                    return -1;\n                } else if (encoding.length > ot.encoding.length) {\n                    return +1;\n                } else {\n                    return 0;\n                }\n\n            }\n        }\n\n        return components.length - ot.components.length;\n\n    }",
          "8": "    public int compareTo(final OrderedTuple ot) {\n        if (components.length == ot.components.length) {\n            if (nan) {\n                return +1;\n            } else if (ot.nan) {\n                return -1;\n            } else if (negInf || ot.posInf) {\n                return -1;\n            } else if (posInf || ot.negInf) {\n                return +1;\n            } else {\n\n                if (offset < ot.offset) {\n                    encode(ot.offset);\n                } else if (offset > ot.offset) {\n                    ot.encode(offset);\n                }\n\n                final int limit = FastMath.min(encoding.length, ot.encoding.length);\n                for (int i = 0; i < limit; ++i) {\n                    if (encoding[i] < ot.encoding[i]) {\n                        return -1;\n                    } else if (encoding[i] > ot.encoding[i]) {\ncontinue;\n                    }\n                }\n\n                if (encoding.length < ot.encoding.length) {\n                    return -1;\n                } else if (encoding.length > ot.encoding.length) {\n                    return +1;\n                } else {\n                    return 0;\n                }\n\n            }\n        }\n\n        return components.length - ot.components.length;\n\n    }",
          "9": "    public int compareTo(final OrderedTuple ot) {\n        if (components.length == ot.components.length) {\n            if (nan) {\n                return +1;\n            } else if (ot.nan) {\n                return -1;\n            } else if (negInf || ot.posInf) {\n                return -1;\n            } else if (posInf || ot.negInf) {\n                return +1;\n            } else {\n\n                if (offset < ot.offset) {\n                    encode(ot.offset);\n                } else if (offset > ot.offset) {\n                    ot.encode(offset);\n                }\n\n                final int limit = FastMath.min(encoding.length, ot.encoding.length);\n                for (int i = 0; i < limit; ++i) {\n                    if (encoding[i] < ot.encoding[i]) {\n                        return -1;\n                    } else if (encoding[i] > ot.encoding[i]) {\nreturn (components.length - ot.components.length);                    }\n                }\n\n                if (encoding.length < ot.encoding.length) {\n                    return -1;\n                } else if (encoding.length > ot.encoding.length) {\n                    return +1;\n                } else {\n                    return 0;\n                }\n\n            }\n        }\n\n        return components.length - ot.components.length;\n\n    }",
          "10": "    public int compareTo(final OrderedTuple ot) {\n        if (components.length == ot.components.length) {\n            if (nan) {\n                return +1;\n            } else if (ot.nan) {\n                return -1;\n            } else if (negInf || ot.posInf) {\n                return -1;\n            } else if (posInf || ot.negInf) {\n                return +1;\n            } else {\n\n                if (offset < ot.offset) {\n                    encode(ot.offset);\n                } else if (offset > ot.offset) {\n                    ot.encode(offset);\n                }\n\n                final int limit = FastMath.min(encoding.length, ot.encoding.length);\n                for (int i = 0; i < limit; ++i) {\n                    if (encoding[i] < ot.encoding[i]) {\n                        return -1;\n                    } else if (encoding[i] > ot.encoding[i]) {\nreturn 0;                        return ~1;                    }\n                }\n\n                if (encoding.length < ot.encoding.length) {\n                    return -1;\n                } else if (encoding.length > ot.encoding.length) {\n                    return +1;\n                } else {\n                    return 0;\n                }\n\n            }\n        }\n\n        return components.length - ot.components.length;\n\n    }",
          "11": "    public int compareTo(final OrderedTuple ot) {\n        if (components.length == ot.components.length) {\n            if (nan) {\n                return +1;\n            } else if (ot.nan) {\n                return -1;\n            } else if (negInf || ot.posInf) {\n                return -1;\n            } else if (posInf || ot.negInf) {\n                return +1;\n            } else {\n\n                if (offset < ot.offset) {\n                    encode(ot.offset);\n                } else if (offset > ot.offset) {\n                    ot.encode(offset);\n                }\n\n                final int limit = FastMath.min(encoding.length, ot.encoding.length);\n                for (int i = 0; i < limit; ++i) {\n                    if (encoding[i] < ot.encoding[i]) {\n                        return -1;\n                    } else if (encoding[i] > ot.encoding[i]) {\nbreak;\n                    }\n                }\n\n                if (encoding.length < ot.encoding.length) {\n                    return -1;\n                } else if (encoding.length > ot.encoding.length) {\n                    return +1;\n                } else {\n                    return 0;\n                }\n\n            }\n        }\n\n        return components.length - ot.components.length;\n\n    }",
          "12": "    public int compareTo(final OrderedTuple ot) {\n        if (components.length == ot.components.length) {\n            if (nan) {\n                return +1;\n            } else if (ot.nan) {\n                return -1;\n            } else if (negInf || ot.posInf) {\n                return -1;\n            } else if (posInf || ot.negInf) {\n                return +1;\n            } else {\n\n                if (offset < ot.offset) {\n                    encode(ot.offset);\n                } else if (offset > ot.offset) {\n                    ot.encode(offset);\n                }\n\n                final int limit = FastMath.min(encoding.length, ot.encoding.length);\n                for (int i = 0; i < limit; ++i) {\n                    if (encoding[i] < ot.encoding[i]) {\n                        return -1;\n                    } else if (encoding[i] > ot.encoding[i]) {\nreturn +1;                        return ~1;                    }\n                }\n\n                if (encoding.length < ot.encoding.length) {\n                    return -1;\n                } else if (encoding.length > ot.encoding.length) {\n                    return +1;\n                } else {\n                    return 0;\n                }\n\n            }\n        }\n\n        return components.length - ot.components.length;\n\n    }",
          "13": "    public int compareTo(final OrderedTuple ot) {\n        if (components.length == ot.components.length) {\n            if (nan) {\n                return +1;\n            } else if (ot.nan) {\n                return -1;\n            } else if (negInf || ot.posInf) {\n                return -1;\n            } else if (posInf || ot.negInf) {\n                return +1;\n            } else {\n\n                if (offset < ot.offset) {\n                    encode(ot.offset);\n                } else if (offset > ot.offset) {\n                    ot.encode(offset);\n                }\n\n                final int limit = FastMath.min(encoding.length, ot.encoding.length);\n                for (int i = 0; i < limit; ++i) {\n                    if (encoding[i] < ot.encoding[i]) {\n                        return -1;\n                    } else if (encoding[i] > ot.encoding[i]) {\nif((encoding[i] > ot.encoding[i])){\n}\n                        return ~1;                    }\n                }\n\n                if (encoding.length < ot.encoding.length) {\n                    return -1;\n                } else if (encoding.length > ot.encoding.length) {\n                    return +1;\n                } else {\n                    return 0;\n                }\n\n            }\n        }\n\n        return components.length - ot.components.length;\n\n    }",
          "14": "    public int compareTo(final OrderedTuple ot) {\n        if (components.length == ot.components.length) {\n            if (nan) {\n                return +1;\n            } else if (ot.nan) {\n                return -1;\n            } else if (negInf || ot.posInf) {\n                return -1;\n            } else if (posInf || ot.negInf) {\n                return +1;\n            } else {\n\n                if (offset < ot.offset) {\n                    encode(ot.offset);\n                } else if (offset > ot.offset) {\n                    ot.encode(offset);\n                }\n\n                final int limit = FastMath.min(encoding.length, ot.encoding.length);\n                for (int i = 0; i < limit; ++i) {\n                    if (encoding[i] < ot.encoding[i]) {\n                        return -1;\n                    } else if (encoding[i] > ot.encoding[i]) {\nreturn -1;                        return ~1;                    }\n                }\n\n                if (encoding.length < ot.encoding.length) {\n                    return -1;\n                } else if (encoding.length > ot.encoding.length) {\n                    return +1;\n                } else {\n                    return 0;\n                }\n\n            }\n        }\n\n        return components.length - ot.components.length;\n\n    }",
          "15": "    public int compareTo(final OrderedTuple ot) {\n        if (components.length == ot.components.length) {\n            if (nan) {\n                return +1;\n            } else if (ot.nan) {\n                return -1;\n            } else if (negInf || ot.posInf) {\n                return -1;\n            } else if (posInf || ot.negInf) {\n                return +1;\n            } else {\n\n                if (offset < ot.offset) {\n                    encode(ot.offset);\n                } else if (offset > ot.offset) {\n                    ot.encode(offset);\n                }\n\n                final int limit = FastMath.min(encoding.length, ot.encoding.length);\n                for (int i = 0; i < limit; ++i) {\n                    if (encoding[i] < ot.encoding[i]) {\n                        return -1;\n                    } else if (encoding[i] > ot.encoding[i]) {\nreturn -2;                    }\n                }\n\n                if (encoding.length < ot.encoding.length) {\n                    return -1;\n                } else if (encoding.length > ot.encoding.length) {\n                    return +1;\n                } else {\n                    return 0;\n                }\n\n            }\n        }\n\n        return components.length - ot.components.length;\n\n    }",
          "16": "    public int compareTo(final OrderedTuple ot) {\n        if (components.length == ot.components.length) {\n            if (nan) {\n                return +1;\n            } else if (ot.nan) {\n                return -1;\n            } else if (negInf || ot.posInf) {\n                return -1;\n            } else if (posInf || ot.negInf) {\n                return +1;\n            } else {\n\n                if (offset < ot.offset) {\n                    encode(ot.offset);\n                } else if (offset > ot.offset) {\n                    ot.encode(offset);\n                }\n\n                final int limit = FastMath.min(encoding.length, ot.encoding.length);\n                for (int i = 0; i < limit; ++i) {\n                    if (encoding[i] < ot.encoding[i]) {\n                        return -1;\n                    } else if (encoding[i] > ot.encoding[i]) {\not.encode(offset);\n                    }\n                }\n\n                if (encoding.length < ot.encoding.length) {\n                    return -1;\n                } else if (encoding.length > ot.encoding.length) {\n                    return +1;\n                } else {\n                    return 0;\n                }\n\n            }\n        }\n\n        return components.length - ot.components.length;\n\n    }",
          "17": "    public int compareTo(final OrderedTuple ot) {\n        if (components.length == ot.components.length) {\n            if (nan) {\n                return +1;\n            } else if (ot.nan) {\n                return -1;\n            } else if (negInf || ot.posInf) {\n                return -1;\n            } else if (posInf || ot.negInf) {\n                return +1;\n            } else {\n\n                if (offset < ot.offset) {\n                    encode(ot.offset);\n                } else if (offset > ot.offset) {\n                    ot.encode(offset);\n                }\n\n                final int limit = FastMath.min(encoding.length, ot.encoding.length);\n                for (int i = 0; i < limit; ++i) {\n                    if (encoding[i] < ot.encoding[i]) {\n                        return -1;\n                    } else if (encoding[i] > ot.encoding[i]) {\nreturn null;                    }\n                }\n\n                if (encoding.length < ot.encoding.length) {\n                    return -1;\n                } else if (encoding.length > ot.encoding.length) {\n                    return +1;\n                } else {\n                    return 0;\n                }\n\n            }\n        }\n\n        return components.length - ot.components.length;\n\n    }",
          "18": "    public int compareTo(final OrderedTuple ot) {\n        if (components.length == ot.components.length) {\n            if (nan) {\n                return +1;\n            } else if (ot.nan) {\n                return -1;\n            } else if (negInf || ot.posInf) {\n                return -1;\n            } else if (posInf || ot.negInf) {\n                return +1;\n            } else {\n\n                if (offset < ot.offset) {\n                    encode(ot.offset);\n                } else if (offset > ot.offset) {\n                    ot.encode(offset);\n                }\n\n                final int limit = FastMath.min(encoding.length, ot.encoding.length);\n                for (int i = 0; i < limit; ++i) {\n                    if (encoding[i] < ot.encoding[i]) {\n                        return -1;\n                    } else if (encoding[i] > ot.encoding[i]) {\nencode(ot.offset);\n                    }\n                }\n\n                if (encoding.length < ot.encoding.length) {\n                    return -1;\n                } else if (encoding.length > ot.encoding.length) {\n                    return +1;\n                } else {\n                    return 0;\n                }\n\n            }\n        }\n\n        return components.length - ot.components.length;\n\n    }",
          "19": "    public int compareTo(final OrderedTuple ot) {\n        if (components.length == ot.components.length) {\n            if (nan) {\n                return +1;\n            } else if (ot.nan) {\n                return -1;\n            } else if (negInf || ot.posInf) {\n                return -1;\n            } else if (posInf || ot.negInf) {\n                return +1;\n            } else {\n\n                if (offset < ot.offset) {\n                    encode(ot.offset);\n                } else if (offset > ot.offset) {\n                    ot.encode(offset);\n                }\n\n                final int limit = FastMath.min(encoding.length, ot.encoding.length);\n                for (int i = 0; i < limit; ++i) {\n                    if (encoding[i] < ot.encoding[i]) {\n                        return -1;\n                    } else if (encoding[i] > ot.encoding[i]) {\nbreak;\n                        return ~1;                    }\n                }\n\n                if (encoding.length < ot.encoding.length) {\n                    return -1;\n                } else if (encoding.length > ot.encoding.length) {\n                    return +1;\n                } else {\n                    return 0;\n                }\n\n            }\n        }\n\n        return components.length - ot.components.length;\n\n    }",
          "20": "    public int compareTo(final OrderedTuple ot) {\n        if (components.length == ot.components.length) {\n            if (nan) {\n                return +1;\n            } else if (ot.nan) {\n                return -1;\n            } else if (negInf || ot.posInf) {\n                return -1;\n            } else if (posInf || ot.negInf) {\n                return +1;\n            } else {\n\n                if (offset < ot.offset) {\n                    encode(ot.offset);\n                } else if (offset > ot.offset) {\n                    ot.encode(offset);\n                }\n\n                final int limit = FastMath.min(encoding.length, ot.encoding.length);\n                for (int i = 0; i < limit; ++i) {\n                    if (encoding[i] < ot.encoding[i]) {\n                        return -1;\n                    } else if (encoding[i] > ot.encoding[i]) {\nreturn false;                    }\n                }\n\n                if (encoding.length < ot.encoding.length) {\n                    return -1;\n                } else if (encoding.length > ot.encoding.length) {\n                    return +1;\n                } else {\n                    return 0;\n                }\n\n            }\n        }\n\n        return components.length - ot.components.length;\n\n    }",
          "21": "    public int compareTo(final OrderedTuple ot) {\n        if (components.length == ot.components.length) {\n            if (nan) {\n                return +1;\n            } else if (ot.nan) {\n                return -1;\n            } else if (negInf || ot.posInf) {\n                return -1;\n            } else if (posInf || ot.negInf) {\n                return +1;\n            } else {\n\n                if (offset < ot.offset) {\n                    encode(ot.offset);\n                } else if (offset > ot.offset) {\n                    ot.encode(offset);\n                }\n\n                final int limit = FastMath.min(encoding.length, ot.encoding.length);\n                for (int i = 0; i < limit; ++i) {\n                    if (encoding[i] < ot.encoding[i]) {\n                        return -1;\n                    } else if (encoding[i] > ot.encoding[i]) {\nreturn encoding[i];                    }\n                }\n\n                if (encoding.length < ot.encoding.length) {\n                    return -1;\n                } else if (encoding.length > ot.encoding.length) {\n                    return +1;\n                } else {\n                    return 0;\n                }\n\n            }\n        }\n\n        return components.length - ot.components.length;\n\n    }",
          "22": "    public int compareTo(final OrderedTuple ot) {\n        if (components.length == ot.components.length) {\n            if (nan) {\n                return +1;\n            } else if (ot.nan) {\n                return -1;\n            } else if (negInf || ot.posInf) {\n                return -1;\n            } else if (posInf || ot.negInf) {\n                return +1;\n            } else {\n\n                if (offset < ot.offset) {\n                    encode(ot.offset);\n                } else if (offset > ot.offset) {\n                    ot.encode(offset);\n                }\n\n                final int limit = FastMath.min(encoding.length, ot.encoding.length);\n                for (int i = 0; i < limit; ++i) {\n                    if (encoding[i] < ot.encoding[i]) {\n                        return -1;\n                    } else if (encoding[i] > ot.encoding[i]) {\nreturn i;                    }\n                }\n\n                if (encoding.length < ot.encoding.length) {\n                    return -1;\n                } else if (encoding.length > ot.encoding.length) {\n                    return +1;\n                } else {\n                    return 0;\n                }\n\n            }\n        }\n\n        return components.length - ot.components.length;\n\n    }",
          "23": "    public int compareTo(final OrderedTuple ot) {\n        if (components.length == ot.components.length) {\n            if (nan) {\n                return +1;\n            } else if (ot.nan) {\n                return -1;\n            } else if (negInf || ot.posInf) {\n                return -1;\n            } else if (posInf || ot.negInf) {\n                return +1;\n            } else {\n\n                if (offset < ot.offset) {\n                    encode(ot.offset);\n                } else if (offset > ot.offset) {\n                    ot.encode(offset);\n                }\n\n                final int limit = FastMath.min(encoding.length, ot.encoding.length);\n                for (int i = 0; i < limit; ++i) {\n                    if (encoding[i] < ot.encoding[i]) {\n                        return -1;\n                    } else if (encoding[i] > ot.encoding[i]) {\nreturn encoding;                    }\n                }\n\n                if (encoding.length < ot.encoding.length) {\n                    return -1;\n                } else if (encoding.length > ot.encoding.length) {\n                    return +1;\n                } else {\n                    return 0;\n                }\n\n            }\n        }\n\n        return components.length - ot.components.length;\n\n    }",
          "24": "    public int compareTo(final OrderedTuple ot) {\n        if (components.length == ot.components.length) {\n            if (nan) {\n                return +1;\n            } else if (ot.nan) {\n                return -1;\n            } else if (negInf || ot.posInf) {\n                return -1;\n            } else if (posInf || ot.negInf) {\n                return +1;\n            } else {\n\n                if (offset < ot.offset) {\n                    encode(ot.offset);\n                } else if (offset > ot.offset) {\n                    ot.encode(offset);\n                }\n\n                final int limit = FastMath.min(encoding.length, ot.encoding.length);\n                for (int i = 0; i < limit; ++i) {\n                    if (encoding[i] < ot.encoding[i]) {\n                        return -1;\n                    } else if (encoding[i] > ot.encoding[i]) {\nif((encoding.length > ot.encoding.length)){\n}\n                        return ~1;                    }\n                }\n\n                if (encoding.length < ot.encoding.length) {\n                    return -1;\n                } else if (encoding.length > ot.encoding.length) {\n                    return +1;\n                } else {\n                    return 0;\n                }\n\n            }\n        }\n\n        return components.length - ot.components.length;\n\n    }",
          "25": "    public int compareTo(final OrderedTuple ot) {\n        if (components.length == ot.components.length) {\n            if (nan) {\n                return +1;\n            } else if (ot.nan) {\n                return -1;\n            } else if (negInf || ot.posInf) {\n                return -1;\n            } else if (posInf || ot.negInf) {\n                return +1;\n            } else {\n\n                if (offset < ot.offset) {\n                    encode(ot.offset);\n                } else if (offset > ot.offset) {\n                    ot.encode(offset);\n                }\n\n                final int limit = FastMath.min(encoding.length, ot.encoding.length);\n                for (int i = 0; i < limit; ++i) {\n                    if (encoding[i] < ot.encoding[i]) {\n                        return -1;\n                    } else if (encoding[i] > ot.encoding[i]) {\nreturn;\n                    }\n                }\n\n                if (encoding.length < ot.encoding.length) {\n                    return -1;\n                } else if (encoding.length > ot.encoding.length) {\n                    return +1;\n                } else {\n                    return 0;\n                }\n\n            }\n        }\n\n        return components.length - ot.components.length;\n\n    }",
          "26": "    public int compareTo(final OrderedTuple ot) {\n        if (components.length == ot.components.length) {\n            if (nan) {\n                return +1;\n            } else if (ot.nan) {\n                return -1;\n            } else if (negInf || ot.posInf) {\n                return -1;\n            } else if (posInf || ot.negInf) {\n                return +1;\n            } else {\n\n                if (offset < ot.offset) {\n                    encode(ot.offset);\n                } else if (offset > ot.offset) {\n                    ot.encode(offset);\n                }\n\n                final int limit = FastMath.min(encoding.length, ot.encoding.length);\n                for (int i = 0; i < limit; ++i) {\n                    if (encoding[i] < ot.encoding[i]) {\n                        return -1;\n                    } else if (encoding[i] > ot.encoding[i]) {\nif((encoding.length > ot.encoding.length)){\not.encode(offset);\n}                        return ~1;                    }\n                }\n\n                if (encoding.length < ot.encoding.length) {\n                    return -1;\n                } else if (encoding.length > ot.encoding.length) {\n                    return +1;\n                } else {\n                    return 0;\n                }\n\n            }\n        }\n\n        return components.length - ot.components.length;\n\n    }",
          "27": "    public int compareTo(final OrderedTuple ot) {\n        if (components.length == ot.components.length) {\n            if (nan) {\n                return +1;\n            } else if (ot.nan) {\n                return -1;\n            } else if (negInf || ot.posInf) {\n                return -1;\n            } else if (posInf || ot.negInf) {\n                return +1;\n            } else {\n\n                if (offset < ot.offset) {\n                    encode(ot.offset);\n                } else if (offset > ot.offset) {\n                    ot.encode(offset);\n                }\n\n                final int limit = FastMath.min(encoding.length, ot.encoding.length);\n                for (int i = 0; i < limit; ++i) {\n                    if (encoding[i] < ot.encoding[i]) {\n                        return -1;\n                    } else if (encoding[i] > ot.encoding[i]) {\nreturn (components.length - ot.components.length);                        return ~1;                    }\n                }\n\n                if (encoding.length < ot.encoding.length) {\n                    return -1;\n                } else if (encoding.length > ot.encoding.length) {\n                    return +1;\n                } else {\n                    return 0;\n                }\n\n            }\n        }\n\n        return components.length - ot.components.length;\n\n    }",
          "28": "    public int compareTo(final OrderedTuple ot) {\n        if (components.length == ot.components.length) {\n            if (nan) {\n                return +1;\n            } else if (ot.nan) {\n                return -1;\n            } else if (negInf || ot.posInf) {\n                return -1;\n            } else if (posInf || ot.negInf) {\n                return +1;\n            } else {\n\n                if (offset < ot.offset) {\n                    encode(ot.offset);\n                } else if (offset > ot.offset) {\n                    ot.encode(offset);\n                }\n\n                final int limit = FastMath.min(encoding.length, ot.encoding.length);\n                for (int i = 0; i < limit; ++i) {\n                    if (encoding[i] < ot.encoding[i]) {\n                        return -1;\n                    } else if (encoding[i] > ot.encoding[i]) {\nif((encoding.length > ot.encoding.length)){\nencode(ot.offset);\n}                        return ~1;                    }\n                }\n\n                if (encoding.length < ot.encoding.length) {\n                    return -1;\n                } else if (encoding.length > ot.encoding.length) {\n                    return +1;\n                } else {\n                    return 0;\n                }\n\n            }\n        }\n\n        return components.length - ot.components.length;\n\n    }",
          "29": "    public int compareTo(final OrderedTuple ot) {\n        if (components.length == ot.components.length) {\n            if (nan) {\n                return +1;\n            } else if (ot.nan) {\n                return -1;\n            } else if (negInf || ot.posInf) {\n                return -1;\n            } else if (posInf || ot.negInf) {\n                return +1;\n            } else {\n\n                if (offset < ot.offset) {\n                    encode(ot.offset);\n                } else if (offset > ot.offset) {\n                    ot.encode(offset);\n                }\n\n                final int limit = FastMath.min(encoding.length, ot.encoding.length);\n                for (int i = 0; i < limit; ++i) {\n                    if (encoding[i] < ot.encoding[i]) {\n                        return -1;\n                    } else if (encoding[i] > ot.encoding[i]) {\nif((encoding.length > ot.encoding.length)){\nreturn 0;}                        return ~1;                    }\n                }\n\n                if (encoding.length < ot.encoding.length) {\n                    return -1;\n                } else if (encoding.length > ot.encoding.length) {\n                    return +1;\n                } else {\n                    return 0;\n                }\n\n            }\n        }\n\n        return components.length - ot.components.length;\n\n    }",
          "30": "    public int compareTo(final OrderedTuple ot) {\n        if (components.length == ot.components.length) {\n            if (nan) {\n                return +1;\n            } else if (ot.nan) {\n                return -1;\n            } else if (negInf || ot.posInf) {\n                return -1;\n            } else if (posInf || ot.negInf) {\n                return +1;\n            } else {\n\n                if (offset < ot.offset) {\n                    encode(ot.offset);\n                } else if (offset > ot.offset) {\n                    ot.encode(offset);\n                }\n\n                final int limit = FastMath.min(encoding.length, ot.encoding.length);\n                for (int i = 0; i < limit; ++i) {\n                    if (encoding[i] < ot.encoding[i]) {\n                        return -1;\n                    } else if (encoding[i] > ot.encoding[i]) {\not.encode(offset);\not.encode(offset);\n                        return ~1;                    }\n                }\n\n                if (encoding.length < ot.encoding.length) {\n                    return -1;\n                } else if (encoding.length > ot.encoding.length) {\n                    return +1;\n                } else {\n                    return 0;\n                }\n\n            }\n        }\n\n        return components.length - ot.components.length;\n\n    }",
          "31": "    public int compareTo(final OrderedTuple ot) {\n        if (components.length == ot.components.length) {\n            if (nan) {\n                return +1;\n            } else if (ot.nan) {\n                return -1;\n            } else if (negInf || ot.posInf) {\n                return -1;\n            } else if (posInf || ot.negInf) {\n                return +1;\n            } else {\n\n                if (offset < ot.offset) {\n                    encode(ot.offset);\n                } else if (offset > ot.offset) {\n                    ot.encode(offset);\n                }\n\n                final int limit = FastMath.min(encoding.length, ot.encoding.length);\n                for (int i = 0; i < limit; ++i) {\n                    if (encoding[i] < ot.encoding[i]) {\n                        return -1;\n                    } else if (encoding[i] > ot.encoding[i]) {\nreturn true;                    }\n                }\n\n                if (encoding.length < ot.encoding.length) {\n                    return -1;\n                } else if (encoding.length > ot.encoding.length) {\n                    return +1;\n                } else {\n                    return 0;\n                }\n\n            }\n        }\n\n        return components.length - ot.components.length;\n\n    }",
          "32": "    public int compareTo(final OrderedTuple ot) {\n        if (components.length == ot.components.length) {\n            if (nan) {\n                return +1;\n            } else if (ot.nan) {\n                return -1;\n            } else if (negInf || ot.posInf) {\n                return -1;\n            } else if (posInf || ot.negInf) {\n                return +1;\n            } else {\n\n                if (offset < ot.offset) {\n                    encode(ot.offset);\n                } else if (offset > ot.offset) {\n                    ot.encode(offset);\n                }\n\n                final int limit = FastMath.min(encoding.length, ot.encoding.length);\n                for (int i = 0; i < limit; ++i) {\n                    if (encoding[i] < ot.encoding[i]) {\n                        return -1;\n                    } else if (encoding[i] > ot.encoding[i]) {\nif((encoding[i] > ot.encoding[i])){\not.encode(offset);\n}                        return ~1;                    }\n                }\n\n                if (encoding.length < ot.encoding.length) {\n                    return -1;\n                } else if (encoding.length > ot.encoding.length) {\n                    return +1;\n                } else {\n                    return 0;\n                }\n\n            }\n        }\n\n        return components.length - ot.components.length;\n\n    }",
          "33": "    public int compareTo(final OrderedTuple ot) {\n        if (components.length == ot.components.length) {\n            if (nan) {\n                return +1;\n            } else if (ot.nan) {\n                return -1;\n            } else if (negInf || ot.posInf) {\n                return -1;\n            } else if (posInf || ot.negInf) {\n                return +1;\n            } else {\n\n                if (offset < ot.offset) {\n                    encode(ot.offset);\n                } else if (offset > ot.offset) {\n                    ot.encode(offset);\n                }\n\n                final int limit = FastMath.min(encoding.length, ot.encoding.length);\n                for (int i = 0; i < limit; ++i) {\n                    if (encoding[i] < ot.encoding[i]) {\n                        return -1;\n                    } else if (encoding[i] > ot.encoding[i]) {\nif((encoding.length < ot.encoding.length)){\n}\n                        return ~1;                    }\n                }\n\n                if (encoding.length < ot.encoding.length) {\n                    return -1;\n                } else if (encoding.length > ot.encoding.length) {\n                    return +1;\n                } else {\n                    return 0;\n                }\n\n            }\n        }\n\n        return components.length - ot.components.length;\n\n    }",
          "34": "    public int compareTo(final OrderedTuple ot) {\n        if (components.length == ot.components.length) {\n            if (nan) {\n                return +1;\n            } else if (ot.nan) {\n                return -1;\n            } else if (negInf || ot.posInf) {\n                return -1;\n            } else if (posInf || ot.negInf) {\n                return +1;\n            } else {\n\n                if (offset < ot.offset) {\n                    encode(ot.offset);\n                } else if (offset > ot.offset) {\n                    ot.encode(offset);\n                }\n\n                final int limit = FastMath.min(encoding.length, ot.encoding.length);\n                for (int i = 0; i < limit; ++i) {\n                    if (encoding[i] < ot.encoding[i]) {\n                        return -1;\n                    } else if (encoding[i] > ot.encoding[i]) {\nif((encoding.length > ot.encoding.length)){\nreturn +1;}                        return ~1;                    }\n                }\n\n                if (encoding.length < ot.encoding.length) {\n                    return -1;\n                } else if (encoding.length > ot.encoding.length) {\n                    return +1;\n                } else {\n                    return 0;\n                }\n\n            }\n        }\n\n        return components.length - ot.components.length;\n\n    }",
          "35": "    public int compareTo(final OrderedTuple ot) {\n        if (components.length == ot.components.length) {\n            if (nan) {\n                return +1;\n            } else if (ot.nan) {\n                return -1;\n            } else if (negInf || ot.posInf) {\n                return -1;\n            } else if (posInf || ot.negInf) {\n                return +1;\n            } else {\n\n                if (offset < ot.offset) {\n                    encode(ot.offset);\n                } else if (offset > ot.offset) {\n                    ot.encode(offset);\n                }\n\n                final int limit = FastMath.min(encoding.length, ot.encoding.length);\n                for (int i = 0; i < limit; ++i) {\n                    if (encoding[i] < ot.encoding[i]) {\n                        return -1;\n                    } else if (encoding[i] > ot.encoding[i]) {\nif((encoding[i] < ot.encoding[i])){\n}\n                        return ~1;                    }\n                }\n\n                if (encoding.length < ot.encoding.length) {\n                    return -1;\n                } else if (encoding.length > ot.encoding.length) {\n                    return +1;\n                } else {\n                    return 0;\n                }\n\n            }\n        }\n\n        return components.length - ot.components.length;\n\n    }",
          "36": "    public int compareTo(final OrderedTuple ot) {\n        if (components.length == ot.components.length) {\n            if (nan) {\n                return +1;\n            } else if (ot.nan) {\n                return -1;\n            } else if (negInf || ot.posInf) {\n                return -1;\n            } else if (posInf || ot.negInf) {\n                return +1;\n            } else {\n\n                if (offset < ot.offset) {\n                    encode(ot.offset);\n                } else if (offset > ot.offset) {\n                    ot.encode(offset);\n                }\n\n                final int limit = FastMath.min(encoding.length, ot.encoding.length);\n                for (int i = 0; i < limit; ++i) {\n                    if (encoding[i] < ot.encoding[i]) {\n                        return -1;\n                    } else if (encoding[i] > ot.encoding[i]) {\nreturn \"null\";                    }\n                }\n\n                if (encoding.length < ot.encoding.length) {\n                    return -1;\n                } else if (encoding.length > ot.encoding.length) {\n                    return +1;\n                } else {\n                    return 0;\n                }\n\n            }\n        }\n\n        return components.length - ot.components.length;\n\n    }",
          "37": "    public int compareTo(final OrderedTuple ot) {\n        if (components.length == ot.components.length) {\n            if (nan) {\n                return +1;\n            } else if (ot.nan) {\n                return -1;\n            } else if (negInf || ot.posInf) {\n                return -1;\n            } else if (posInf || ot.negInf) {\n                return +1;\n            } else {\n\n                if (offset < ot.offset) {\n                    encode(ot.offset);\n                } else if (offset > ot.offset) {\n                    ot.encode(offset);\n                }\n\n                final int limit = FastMath.min(encoding.length, ot.encoding.length);\n                for (int i = 0; i < limit; ++i) {\n                    if (encoding[i] < ot.encoding[i]) {\n                        return -1;\n                    } else if (encoding[i] > ot.encoding[i]) {\nfor(int i = 0;(i < limit);++i) {                    }\n                }\n\n                if (encoding.length < ot.encoding.length) {\n                    return -1;\n                } else if (encoding.length > ot.encoding.length) {\n                    return +1;\n                } else {\n                    return 0;\n                }\n\n            }\n        }\n\n        return components.length - ot.components.length;\n\n    }",
          "38": "    public int compareTo(final OrderedTuple ot) {\n        if (components.length == ot.components.length) {\n            if (nan) {\n                return +1;\n            } else if (ot.nan) {\n                return -1;\n            } else if (negInf || ot.posInf) {\n                return -1;\n            } else if (posInf || ot.negInf) {\n                return +1;\n            } else {\n\n                if (offset < ot.offset) {\n                    encode(ot.offset);\n                } else if (offset > ot.offset) {\n                    ot.encode(offset);\n                }\n\n                final int limit = FastMath.min(encoding.length, ot.encoding.length);\n                for (int i = 0; i < limit; ++i) {\n                    if (encoding[i] < ot.encoding[i]) {\n                        return -1;\n                    } else if (encoding[i] > ot.encoding[i]) {\not.encode(offset);\nif((encoding[i] > ot.encoding[i])){\n                        return ~1;                    }\n                }\n\n                if (encoding.length < ot.encoding.length) {\n                    return -1;\n                } else if (encoding.length > ot.encoding.length) {\n                    return +1;\n                } else {\n                    return 0;\n                }\n\n            }\n        }\n\n        return components.length - ot.components.length;\n\n    }",
          "39": "    public int compareTo(final OrderedTuple ot) {\n        if (components.length == ot.components.length) {\n            if (nan) {\n                return +1;\n            } else if (ot.nan) {\n                return -1;\n            } else if (negInf || ot.posInf) {\n                return -1;\n            } else if (posInf || ot.negInf) {\n                return +1;\n            } else {\n\n                if (offset < ot.offset) {\n                    encode(ot.offset);\n                } else if (offset > ot.offset) {\n                    ot.encode(offset);\n                }\n\n                final int limit = FastMath.min(encoding.length, ot.encoding.length);\n                for (int i = 0; i < limit; ++i) {\n                    if (encoding[i] < ot.encoding[i]) {\n                        return -1;\n                    } else if (encoding[i] > ot.encoding[i]) {\nreturn ~1;                    }\n                }\n\n                if (encoding.length < ot.encoding.length) {\n                    return -1;\n                } else if (encoding.length > ot.encoding.length) {\n                    return +1;\n                } else {\n                    return 0;\n                }\n\n            }\n        }\n\n        return components.length - ot.components.length;\n\n    }",
          "40": "    public int compareTo(final OrderedTuple ot) {\n        if (components.length == ot.components.length) {\n            if (nan) {\n                return +1;\n            } else if (ot.nan) {\n                return -1;\n            } else if (negInf || ot.posInf) {\n                return -1;\n            } else if (posInf || ot.negInf) {\n                return +1;\n            } else {\n\n                if (offset < ot.offset) {\n                    encode(ot.offset);\n                } else if (offset > ot.offset) {\n                    ot.encode(offset);\n                }\n\n                final int limit = FastMath.min(encoding.length, ot.encoding.length);\n                for (int i = 0; i < limit; ++i) {\n                    if (encoding[i] < ot.encoding[i]) {\n                        return -1;\n                    } else if (encoding[i] > ot.encoding[i]) {\ncontinue;\n                        return ~1;                    }\n                }\n\n                if (encoding.length < ot.encoding.length) {\n                    return -1;\n                } else if (encoding.length > ot.encoding.length) {\n                    return +1;\n                } else {\n                    return 0;\n                }\n\n            }\n        }\n\n        return components.length - ot.components.length;\n\n    }",
          "41": "    public int compareTo(final OrderedTuple ot) {\n        if (components.length == ot.components.length) {\n            if (nan) {\n                return +1;\n            } else if (ot.nan) {\n                return -1;\n            } else if (negInf || ot.posInf) {\n                return -1;\n            } else if (posInf || ot.negInf) {\n                return +1;\n            } else {\n\n                if (offset < ot.offset) {\n                    encode(ot.offset);\n                } else if (offset > ot.offset) {\n                    ot.encode(offset);\n                }\n\n                final int limit = FastMath.min(encoding.length, ot.encoding.length);\n                for (int i = 0; i < limit; ++i) {\n                    if (encoding[i] < ot.encoding[i]) {\n                        return -1;\n                    } else if (encoding[i] > ot.encoding[i]) {\n                        return ~1;                    }\n                }\n\n                if (encoding.length < ot.encoding.length) {\n                    return -1;\n                } else if (encoding.length > ot.encoding.length) {\n                    return +1;\n                } else {\n                    return 0;\n                }\n\n            }\n        }\n\n        return components.length - ot.components.length;\n\n    }",
          "42": "    public int compareTo(final OrderedTuple ot) {\n        if (components.length == ot.components.length) {\n            if (nan) {\n                return +1;\n            } else if (ot.nan) {\n                return -1;\n            } else if (negInf || ot.posInf) {\n                return -1;\n            } else if (posInf || ot.negInf) {\n                return +1;\n            } else {\n\n                if (offset < ot.offset) {\n                    encode(ot.offset);\n                } else if (offset > ot.offset) {\n                    ot.encode(offset);\n                }\n\n                final int limit = FastMath.min(encoding.length, ot.encoding.length);\n                for (int i = 0; i < limit; ++i) {\n                    if (encoding[i] < ot.encoding[i]) {\n                        return -1;\n                    } else if (encoding[i] > ot.encoding[i]) {\nfor(int i = 0;(i < limit);++i) {                        return ~1;                    }\n                }\n\n                if (encoding.length < ot.encoding.length) {\n                    return -1;\n                } else if (encoding.length > ot.encoding.length) {\n                    return +1;\n                } else {\n                    return 0;\n                }\n\n            }\n        }\n\n        return components.length - ot.components.length;\n\n    }",
          "43": "    public int compareTo(final OrderedTuple ot) {\n        if (components.length == ot.components.length) {\n            if (nan) {\n                return +1;\n            } else if (ot.nan) {\n                return -1;\n            } else if (negInf || ot.posInf) {\n                return -1;\n            } else if (posInf || ot.negInf) {\n                return +1;\n            } else {\n\n                if (offset < ot.offset) {\n                    encode(ot.offset);\n                } else if (offset > ot.offset) {\n                    ot.encode(offset);\n                }\n\n                final int limit = FastMath.min(encoding.length, ot.encoding.length);\n                for (int i = 0; i < limit; ++i) {\n                    if (encoding[i] < ot.encoding[i]) {\n                        return -1;\n                    } else if (encoding[i] > ot.encoding[i]) {\nreturn;\n                        return ~1;                    }\n                }\n\n                if (encoding.length < ot.encoding.length) {\n                    return -1;\n                } else if (encoding.length > ot.encoding.length) {\n                    return +1;\n                } else {\n                    return 0;\n                }\n\n            }\n        }\n\n        return components.length - ot.components.length;\n\n    }",
          "44": "    public int compareTo(final OrderedTuple ot) {\n        if (components.length == ot.components.length) {\n            if (nan) {\n                return +1;\n            } else if (ot.nan) {\n                return -1;\n            } else if (negInf || ot.posInf) {\n                return -1;\n            } else if (posInf || ot.negInf) {\n                return +1;\n            } else {\n\n                if (offset < ot.offset) {\n                    encode(ot.offset);\n                } else if (offset > ot.offset) {\n                    ot.encode(offset);\n                }\n\n                final int limit = FastMath.min(encoding.length, ot.encoding.length);\n                for (int i = 0; i < limit; ++i) {\n                    if (encoding[i] < ot.encoding[i]) {\n                        return -1;\n                    } else if (encoding[i] > ot.encoding[i]) {\nreturn encoding[0];                    }\n                }\n\n                if (encoding.length < ot.encoding.length) {\n                    return -1;\n                } else if (encoding.length > ot.encoding.length) {\n                    return +1;\n                } else {\n                    return 0;\n                }\n\n            }\n        }\n\n        return components.length - ot.components.length;\n\n    }",
          "45": "    public int compareTo(final OrderedTuple ot) {\n        if (components.length == ot.components.length) {\n            if (nan) {\n                return +1;\n            } else if (ot.nan) {\n                return -1;\n            } else if (negInf || ot.posInf) {\n                return -1;\n            } else if (posInf || ot.negInf) {\n                return +1;\n            } else {\n\n                if (offset < ot.offset) {\n                    encode(ot.offset);\n                } else if (offset > ot.offset) {\n                    ot.encode(offset);\n                }\n\n                final int limit = FastMath.min(encoding.length, ot.encoding.length);\n                for (int i = 0; i < limit; ++i) {\n                    if (encoding[i] < ot.encoding[i]) {\n                        return -1;\n                    } else if (encoding[i] > ot.encoding[i]) {\nif((i != null)){\n}\n                        return ~1;                    }\n                }\n\n                if (encoding.length < ot.encoding.length) {\n                    return -1;\n                } else if (encoding.length > ot.encoding.length) {\n                    return +1;\n                } else {\n                    return 0;\n                }\n\n            }\n        }\n\n        return components.length - ot.components.length;\n\n    }",
          "46": "    public int compareTo(final OrderedTuple ot) {\n        if (components.length == ot.components.length) {\n            if (nan) {\n                return +1;\n            } else if (ot.nan) {\n                return -1;\n            } else if (negInf || ot.posInf) {\n                return -1;\n            } else if (posInf || ot.negInf) {\n                return +1;\n            } else {\n\n                if (offset < ot.offset) {\n                    encode(ot.offset);\n                } else if (offset > ot.offset) {\n                    ot.encode(offset);\n                }\n\n                final int limit = FastMath.min(encoding.length, ot.encoding.length);\n                for (int i = 0; i < limit; ++i) {\n                    if (encoding[i] < ot.encoding[i]) {\n                        return -1;\n                    } else if (encoding[i] > ot.encoding[i]) {\nif((i != null)){\nreturn 0;}                        return ~1;                    }\n                }\n\n                if (encoding.length < ot.encoding.length) {\n                    return -1;\n                } else if (encoding.length > ot.encoding.length) {\n                    return +1;\n                } else {\n                    return 0;\n                }\n\n            }\n        }\n\n        return components.length - ot.components.length;\n\n    }",
          "47": "    public int compareTo(final OrderedTuple ot) {\n        if (components.length == ot.components.length) {\n            if (nan) {\n                return +1;\n            } else if (ot.nan) {\n                return -1;\n            } else if (negInf || ot.posInf) {\n                return -1;\n            } else if (posInf || ot.negInf) {\n                return +1;\n            } else {\n\n                if (offset < ot.offset) {\n                    encode(ot.offset);\n                } else if (offset > ot.offset) {\n                    ot.encode(offset);\n                }\n\n                final int limit = FastMath.min(encoding.length, ot.encoding.length);\n                for (int i = 0; i < limit; ++i) {\n                    if (encoding[i] < ot.encoding[i]) {\n                        return -1;\n                    } else if (encoding[i] > ot.encoding[i]) {\nif((i != null)){\nreturn +1;}                        return ~1;                    }\n                }\n\n                if (encoding.length < ot.encoding.length) {\n                    return -1;\n                } else if (encoding.length > ot.encoding.length) {\n                    return +1;\n                } else {\n                    return 0;\n                }\n\n            }\n        }\n\n        return components.length - ot.components.length;\n\n    }",
          "48": "    public int compareTo(final OrderedTuple ot) {\n        if (components.length == ot.components.length) {\n            if (nan) {\n                return +1;\n            } else if (ot.nan) {\n                return -1;\n            } else if (negInf || ot.posInf) {\n                return -1;\n            } else if (posInf || ot.negInf) {\n                return +1;\n            } else {\n\n                if (offset < ot.offset) {\n                    encode(ot.offset);\n                } else if (offset > ot.offset) {\n                    ot.encode(offset);\n                }\n\n                final int limit = FastMath.min(encoding.length, ot.encoding.length);\n                for (int i = 0; i < limit; ++i) {\n                    if (encoding[i] < ot.encoding[i]) {\n                        return -1;\n                    } else if (encoding[i] > ot.encoding[i]) {\nif((i != null)){\nreturn -1;}                        return ~1;                    }\n                }\n\n                if (encoding.length < ot.encoding.length) {\n                    return -1;\n                } else if (encoding.length > ot.encoding.length) {\n                    return +1;\n                } else {\n                    return 0;\n                }\n\n            }\n        }\n\n        return components.length - ot.components.length;\n\n    }",
          "49": "    public int compareTo(final OrderedTuple ot) {\n        if (components.length == ot.components.length) {\n            if (nan) {\n                return +1;\n            } else if (ot.nan) {\n                return -1;\n            } else if (negInf || ot.posInf) {\n                return -1;\n            } else if (posInf || ot.negInf) {\n                return +1;\n            } else {\n\n                if (offset < ot.offset) {\n                    encode(ot.offset);\n                } else if (offset > ot.offset) {\n                    ot.encode(offset);\n                }\n\n                final int limit = FastMath.min(encoding.length, ot.encoding.length);\n                for (int i = 0; i < limit; ++i) {\n                    if (encoding[i] < ot.encoding[i]) {\n                        return -1;\n                    } else if (encoding[i] > ot.encoding[i]) {\nif((i == null)){\nreturn 0;}                        return ~1;                    }\n                }\n\n                if (encoding.length < ot.encoding.length) {\n                    return -1;\n                } else if (encoding.length > ot.encoding.length) {\n                    return +1;\n                } else {\n                    return 0;\n                }\n\n            }\n        }\n\n        return components.length - ot.components.length;\n\n    }",
          "50": "    public int compareTo(final OrderedTuple ot) {\n        if (components.length == ot.components.length) {\n            if (nan) {\n                return +1;\n            } else if (ot.nan) {\n                return -1;\n            } else if (negInf || ot.posInf) {\n                return -1;\n            } else if (posInf || ot.negInf) {\n                return +1;\n            } else {\n\n                if (offset < ot.offset) {\n                    encode(ot.offset);\n                } else if (offset > ot.offset) {\n                    ot.encode(offset);\n                }\n\n                final int limit = FastMath.min(encoding.length, ot.encoding.length);\n                for (int i = 0; i < limit; ++i) {\n                    if (encoding[i] < ot.encoding[i]) {\n                        return -1;\n                    } else if (encoding[i] > ot.encoding[i]) {\nif((i == null)){\nreturn +1;}                        return ~1;                    }\n                }\n\n                if (encoding.length < ot.encoding.length) {\n                    return -1;\n                } else if (encoding.length > ot.encoding.length) {\n                    return +1;\n                } else {\n                    return 0;\n                }\n\n            }\n        }\n\n        return components.length - ot.components.length;\n\n    }",
          "51": "    public int compareTo(final OrderedTuple ot) {\n        if (components.length == ot.components.length) {\n            if (nan) {\n                return +1;\n            } else if (ot.nan) {\n                return -1;\n            } else if (negInf || ot.posInf) {\n                return -1;\n            } else if (posInf || ot.negInf) {\n                return +1;\n            } else {\n\n                if (offset < ot.offset) {\n                    encode(ot.offset);\n                } else if (offset > ot.offset) {\n                    ot.encode(offset);\n                }\n\n                final int limit = FastMath.min(encoding.length, ot.encoding.length);\n                for (int i = 0; i < limit; ++i) {\n                    if (encoding[i] < ot.encoding[i]) {\n                        return -1;\n                    } else if (encoding[i] > ot.encoding[i]) {\nif((i == null)){\nreturn -1;}                        return ~1;                    }\n                }\n\n                if (encoding.length < ot.encoding.length) {\n                    return -1;\n                } else if (encoding.length > ot.encoding.length) {\n                    return +1;\n                } else {\n                    return 0;\n                }\n\n            }\n        }\n\n        return components.length - ot.components.length;\n\n    }",
          "52": "    public int compareTo(final OrderedTuple ot) {\n        if (components.length == ot.components.length) {\n            if (nan) {\n                return +1;\n            } else if (ot.nan) {\n                return -1;\n            } else if (negInf || ot.posInf) {\n                return -1;\n            } else if (posInf || ot.negInf) {\n                return +1;\n            } else {\n\n                if (offset < ot.offset) {\n                    encode(ot.offset);\n                } else if (offset > ot.offset) {\n                    ot.encode(offset);\n                }\n\n                final int limit = FastMath.min(encoding.length, ot.encoding.length);\n                for (int i = 0; i < limit; ++i) {\n                    if (encoding[i] < ot.encoding[i]) {\n                        return -1;\n                    } else if (encoding[i] > ot.encoding[i]) {\nif((i != null)){\not.encode(offset);\n}                        return ~1;                    }\n                }\n\n                if (encoding.length < ot.encoding.length) {\n                    return -1;\n                } else if (encoding.length > ot.encoding.length) {\n                    return +1;\n                } else {\n                    return 0;\n                }\n\n            }\n        }\n\n        return components.length - ot.components.length;\n\n    }",
          "53": "    public int compareTo(final OrderedTuple ot) {\n        if (components.length == ot.components.length) {\n            if (nan) {\n                return +1;\n            } else if (ot.nan) {\n                return -1;\n            } else if (negInf || ot.posInf) {\n                return -1;\n            } else if (posInf || ot.negInf) {\n                return +1;\n            } else {\n\n                if (offset < ot.offset) {\n                    encode(ot.offset);\n                } else if (offset > ot.offset) {\n                    ot.encode(offset);\n                }\n\n                final int limit = FastMath.min(encoding.length, ot.encoding.length);\n                for (int i = 0; i < limit; ++i) {\n                    if (encoding[i] < ot.encoding[i]) {\n                        return -1;\n                    } else if (encoding[i] > ot.encoding[i]) {\nif((i != null)){\nencode(ot.offset);\n}                        return ~1;                    }\n                }\n\n                if (encoding.length < ot.encoding.length) {\n                    return -1;\n                } else if (encoding.length > ot.encoding.length) {\n                    return +1;\n                } else {\n                    return 0;\n                }\n\n            }\n        }\n\n        return components.length - ot.components.length;\n\n    }",
          "54": "    public int compareTo(final OrderedTuple ot) {\n        if (components.length == ot.components.length) {\n            if (nan) {\n                return +1;\n            } else if (ot.nan) {\n                return -1;\n            } else if (negInf || ot.posInf) {\n                return -1;\n            } else if (posInf || ot.negInf) {\n                return +1;\n            } else {\n\n                if (offset < ot.offset) {\n                    encode(ot.offset);\n                } else if (offset > ot.offset) {\n                    ot.encode(offset);\n                }\n\n                final int limit = FastMath.min(encoding.length, ot.encoding.length);\n                for (int i = 0; i < limit; ++i) {\n                    if (encoding[i] < ot.encoding[i]) {\n                        return -1;\n                    } else if (encoding[i] > ot.encoding[i]) {\nif((i != null)){\ni = false;\n}                        return ~1;                    }\n                }\n\n                if (encoding.length < ot.encoding.length) {\n                    return -1;\n                } else if (encoding.length > ot.encoding.length) {\n                    return +1;\n                } else {\n                    return 0;\n                }\n\n            }\n        }\n\n        return components.length - ot.components.length;\n\n    }",
          "55": "    public int compareTo(final OrderedTuple ot) {\n        if (components.length == ot.components.length) {\n            if (nan) {\n                return +1;\n            } else if (ot.nan) {\n                return -1;\n            } else if (negInf || ot.posInf) {\n                return -1;\n            } else if (posInf || ot.negInf) {\n                return +1;\n            } else {\n\n                if (offset < ot.offset) {\n                    encode(ot.offset);\n                } else if (offset > ot.offset) {\n                    ot.encode(offset);\n                }\n\n                final int limit = FastMath.min(encoding.length, ot.encoding.length);\n                for (int i = 0; i < limit; ++i) {\n                    if (encoding[i] < ot.encoding[i]) {\n                        return -1;\n                    } else if (encoding[i] > ot.encoding[i]) {\nif((i != null)){\ni = 0;\n}                        return ~1;                    }\n                }\n\n                if (encoding.length < ot.encoding.length) {\n                    return -1;\n                } else if (encoding.length > ot.encoding.length) {\n                    return +1;\n                } else {\n                    return 0;\n                }\n\n            }\n        }\n\n        return components.length - ot.components.length;\n\n    }",
          "56": "    public int compareTo(final OrderedTuple ot) {\n        if (components.length == ot.components.length) {\n            if (nan) {\n                return +1;\n            } else if (ot.nan) {\n                return -1;\n            } else if (negInf || ot.posInf) {\n                return -1;\n            } else if (posInf || ot.negInf) {\n                return +1;\n            } else {\n\n                if (offset < ot.offset) {\n                    encode(ot.offset);\n                } else if (offset > ot.offset) {\n                    ot.encode(offset);\n                }\n\n                final int limit = FastMath.min(encoding.length, ot.encoding.length);\n                for (int i = 0; i < limit; ++i) {\n                    if (encoding[i] < ot.encoding[i]) {\n                        return -1;\n                    } else if (encoding[i] > ot.encoding[i]) {\nif((i != null)){\ni = null;\n}                        return ~1;                    }\n                }\n\n                if (encoding.length < ot.encoding.length) {\n                    return -1;\n                } else if (encoding.length > ot.encoding.length) {\n                    return +1;\n                } else {\n                    return 0;\n                }\n\n            }\n        }\n\n        return components.length - ot.components.length;\n\n    }",
          "57": "    public int compareTo(final OrderedTuple ot) {\n        if (components.length == ot.components.length) {\n            if (nan) {\n                return +1;\n            } else if (ot.nan) {\n                return -1;\n            } else if (negInf || ot.posInf) {\n                return -1;\n            } else if (posInf || ot.negInf) {\n                return +1;\n            } else {\n\n                if (offset < ot.offset) {\n                    encode(ot.offset);\n                } else if (offset > ot.offset) {\n                    ot.encode(offset);\n                }\n\n                final int limit = FastMath.min(encoding.length, ot.encoding.length);\n                for (int i = 0; i < limit; ++i) {\n                    if (encoding[i] < ot.encoding[i]) {\n                        return -1;\n                    } else if (encoding[i] > ot.encoding[i]) {\nif((i != null)){\ni = i;\n}                        return ~1;                    }\n                }\n\n                if (encoding.length < ot.encoding.length) {\n                    return -1;\n                } else if (encoding.length > ot.encoding.length) {\n                    return +1;\n                } else {\n                    return 0;\n                }\n\n            }\n        }\n\n        return components.length - ot.components.length;\n\n    }",
          "58": "    public int compareTo(final OrderedTuple ot) {\n        if (components.length == ot.components.length) {\n            if (nan) {\n                return +1;\n            } else if (ot.nan) {\n                return -1;\n            } else if (negInf || ot.posInf) {\n                return -1;\n            } else if (posInf || ot.negInf) {\n                return +1;\n            } else {\n\n                if (offset < ot.offset) {\n                    encode(ot.offset);\n                } else if (offset > ot.offset) {\n                    ot.encode(offset);\n                }\n\n                final int limit = FastMath.min(encoding.length, ot.encoding.length);\n                for (int i = 0; i < limit; ++i) {\n                    if (encoding[i] < ot.encoding[i]) {\n                        return -1;\n                    } else if (encoding[i] > ot.encoding[i]) {\nif(((i != null) && (i == null))){\nreturn 0;}                        return ~1;                    }\n                }\n\n                if (encoding.length < ot.encoding.length) {\n                    return -1;\n                } else if (encoding.length > ot.encoding.length) {\n                    return +1;\n                } else {\n                    return 0;\n                }\n\n            }\n        }\n\n        return components.length - ot.components.length;\n\n    }",
          "59": "    public int compareTo(final OrderedTuple ot) {\n        if (components.length == ot.components.length) {\n            if (nan) {\n                return +1;\n            } else if (ot.nan) {\n                return -1;\n            } else if (negInf || ot.posInf) {\n                return -1;\n            } else if (posInf || ot.negInf) {\n                return +1;\n            } else {\n\n                if (offset < ot.offset) {\n                    encode(ot.offset);\n                } else if (offset > ot.offset) {\n                    ot.encode(offset);\n                }\n\n                final int limit = FastMath.min(encoding.length, ot.encoding.length);\n                for (int i = 0; i < limit; ++i) {\n                    if (encoding[i] < ot.encoding[i]) {\n                        return -1;\n                    } else if (encoding[i] > ot.encoding[i]) {\nif(((i != null) && (i == 0))){\nreturn 0;}                        return ~1;                    }\n                }\n\n                if (encoding.length < ot.encoding.length) {\n                    return -1;\n                } else if (encoding.length > ot.encoding.length) {\n                    return +1;\n                } else {\n                    return 0;\n                }\n\n            }\n        }\n\n        return components.length - ot.components.length;\n\n    }"
}