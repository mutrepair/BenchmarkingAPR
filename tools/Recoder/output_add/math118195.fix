{
          "0": "    public static double scalb(final double d, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -1023) && (n < 1024)) {\n            return d * Double.longBitsToDouble(((long) (n + 1023)) << 52);\n        }\n\n        // handle special cases\n        if (Double.isNaN(d) || Double.isInfinite(d) || (d == 0)) {\n            return d;\n        }\n        if (n < -2098) {\n            return (d > 0) ? 0.0 : -0.0;\n        }\n        if (n > 2097) {\n            return (d > 0) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n        }\n\n        // decompose d\n        final long bits = Double.doubleToRawLongBits(d);\n        final long sign = bits & 0x8000000000000000L;\n        int  exponent   = ((int) (bits >>> 52)) & 0x7ff;\n        long mantissa   = bits & 0x000fffffffffffffL;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -1023\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else if (scaledExponent > -53) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\nmantissa = (mantissa | (1L >> 52));\n\n                // scales down complete mantissa, hence losing least significant bits\n                final long mostSignificantLostBit = mantissa & (1L << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Double.longBitsToDouble(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0L) ? 0.0 : -0.0;\n            }\n        } else {\n            // we are really in the case n >= 1024\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 52) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x000fffffffffffffL;\n\n                if (scaledExponent < 2047) {\n                    return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n                } else {\n                    return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 2047) {\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else {\n                return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "1": "    public static double scalb(final double d, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -1023) && (n < 1024)) {\n            return d * Double.longBitsToDouble(((long) (n + 1023)) << 52);\n        }\n\n        // handle special cases\n        if (Double.isNaN(d) || Double.isInfinite(d) || (d == 0)) {\n            return d;\n        }\n        if (n < -2098) {\n            return (d > 0) ? 0.0 : -0.0;\n        }\n        if (n > 2097) {\n            return (d > 0) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n        }\n\n        // decompose d\n        final long bits = Double.doubleToRawLongBits(d);\n        final long sign = bits & 0x8000000000000000L;\n        int  exponent   = ((int) (bits >>> 52)) & 0x7ff;\n        long mantissa   = bits & 0x000fffffffffffffL;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -1023\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else if (scaledExponent > -53) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\nmantissa = (mantissa | (2 >> 52));\n\n                // scales down complete mantissa, hence losing least significant bits\n                final long mostSignificantLostBit = mantissa & (1L << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Double.longBitsToDouble(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0L) ? 0.0 : -0.0;\n            }\n        } else {\n            // we are really in the case n >= 1024\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 52) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x000fffffffffffffL;\n\n                if (scaledExponent < 2047) {\n                    return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n                } else {\n                    return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 2047) {\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else {\n                return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "2": "    public static double scalb(final double d, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -1023) && (n < 1024)) {\n            return d * Double.longBitsToDouble(((long) (n + 1023)) << 52);\n        }\n\n        // handle special cases\n        if (Double.isNaN(d) || Double.isInfinite(d) || (d == 0)) {\n            return d;\n        }\n        if (n < -2098) {\n            return (d > 0) ? 0.0 : -0.0;\n        }\n        if (n > 2097) {\n            return (d > 0) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n        }\n\n        // decompose d\n        final long bits = Double.doubleToRawLongBits(d);\n        final long sign = bits & 0x8000000000000000L;\n        int  exponent   = ((int) (bits >>> 52)) & 0x7ff;\n        long mantissa   = bits & 0x000fffffffffffffL;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -1023\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else if (scaledExponent > -53) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\nmantissa = (mantissa & (1L >> 52));\n\n                // scales down complete mantissa, hence losing least significant bits\n                final long mostSignificantLostBit = mantissa & (1L << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Double.longBitsToDouble(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0L) ? 0.0 : -0.0;\n            }\n        } else {\n            // we are really in the case n >= 1024\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 52) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x000fffffffffffffL;\n\n                if (scaledExponent < 2047) {\n                    return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n                } else {\n                    return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 2047) {\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else {\n                return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "3": "    public static double scalb(final double d, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -1023) && (n < 1024)) {\n            return d * Double.longBitsToDouble(((long) (n + 1023)) << 52);\n        }\n\n        // handle special cases\n        if (Double.isNaN(d) || Double.isInfinite(d) || (d == 0)) {\n            return d;\n        }\n        if (n < -2098) {\n            return (d > 0) ? 0.0 : -0.0;\n        }\n        if (n > 2097) {\n            return (d > 0) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n        }\n\n        // decompose d\n        final long bits = Double.doubleToRawLongBits(d);\n        final long sign = bits & 0x8000000000000000L;\n        int  exponent   = ((int) (bits >>> 52)) & 0x7ff;\n        long mantissa   = bits & 0x000fffffffffffffL;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -1023\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else if (scaledExponent > -53) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\nmantissa = (mantissa | (1 >> 52));\n\n                // scales down complete mantissa, hence losing least significant bits\n                final long mostSignificantLostBit = mantissa & (1L << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Double.longBitsToDouble(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0L) ? 0.0 : -0.0;\n            }\n        } else {\n            // we are really in the case n >= 1024\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 52) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x000fffffffffffffL;\n\n                if (scaledExponent < 2047) {\n                    return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n                } else {\n                    return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 2047) {\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else {\n                return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "4": "    public static double scalb(final double d, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -1023) && (n < 1024)) {\n            return d * Double.longBitsToDouble(((long) (n + 1023)) << 52);\n        }\n\n        // handle special cases\n        if (Double.isNaN(d) || Double.isInfinite(d) || (d == 0)) {\n            return d;\n        }\n        if (n < -2098) {\n            return (d > 0) ? 0.0 : -0.0;\n        }\n        if (n > 2097) {\n            return (d > 0) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n        }\n\n        // decompose d\n        final long bits = Double.doubleToRawLongBits(d);\n        final long sign = bits & 0x8000000000000000L;\n        int  exponent   = ((int) (bits >>> 52)) & 0x7ff;\n        long mantissa   = bits & 0x000fffffffffffffL;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -1023\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else if (scaledExponent > -53) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\nmantissa = (mantissa | (0 >> 52));\n\n                // scales down complete mantissa, hence losing least significant bits\n                final long mostSignificantLostBit = mantissa & (1L << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Double.longBitsToDouble(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0L) ? 0.0 : -0.0;\n            }\n        } else {\n            // we are really in the case n >= 1024\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 52) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x000fffffffffffffL;\n\n                if (scaledExponent < 2047) {\n                    return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n                } else {\n                    return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 2047) {\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else {\n                return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "5": "    public static double scalb(final double d, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -1023) && (n < 1024)) {\n            return d * Double.longBitsToDouble(((long) (n + 1023)) << 52);\n        }\n\n        // handle special cases\n        if (Double.isNaN(d) || Double.isInfinite(d) || (d == 0)) {\n            return d;\n        }\n        if (n < -2098) {\n            return (d > 0) ? 0.0 : -0.0;\n        }\n        if (n > 2097) {\n            return (d > 0) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n        }\n\n        // decompose d\n        final long bits = Double.doubleToRawLongBits(d);\n        final long sign = bits & 0x8000000000000000L;\n        int  exponent   = ((int) (bits >>> 52)) & 0x7ff;\n        long mantissa   = bits & 0x000fffffffffffffL;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -1023\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else if (scaledExponent > -53) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\nmantissa = (mantissa | (1L & 52));\n\n                // scales down complete mantissa, hence losing least significant bits\n                final long mostSignificantLostBit = mantissa & (1L << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Double.longBitsToDouble(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0L) ? 0.0 : -0.0;\n            }\n        } else {\n            // we are really in the case n >= 1024\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 52) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x000fffffffffffffL;\n\n                if (scaledExponent < 2047) {\n                    return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n                } else {\n                    return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 2047) {\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else {\n                return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "6": "    public static double scalb(final double d, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -1023) && (n < 1024)) {\n            return d * Double.longBitsToDouble(((long) (n + 1023)) << 52);\n        }\n\n        // handle special cases\n        if (Double.isNaN(d) || Double.isInfinite(d) || (d == 0)) {\n            return d;\n        }\n        if (n < -2098) {\n            return (d > 0) ? 0.0 : -0.0;\n        }\n        if (n > 2097) {\n            return (d > 0) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n        }\n\n        // decompose d\n        final long bits = Double.doubleToRawLongBits(d);\n        final long sign = bits & 0x8000000000000000L;\n        int  exponent   = ((int) (bits >>> 52)) & 0x7ff;\n        long mantissa   = bits & 0x000fffffffffffffL;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -1023\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else if (scaledExponent > -53) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\n\n                // scales down complete mantissa, hence losing least significant bits\n                final long mostSignificantLostBit = mantissa & (1L << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Double.longBitsToDouble(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0L) ? 0.0 : -0.0;\n            }\n        } else {\n            // we are really in the case n >= 1024\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 52) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x000fffffffffffffL;\n\n                if (scaledExponent < 2047) {\n                    return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n                } else {\n                    return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 2047) {\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else {\n                return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "7": "    public static double scalb(final double d, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -1023) && (n < 1024)) {\n            return d * Double.longBitsToDouble(((long) (n + 1023)) << 52);\n        }\n\n        // handle special cases\n        if (Double.isNaN(d) || Double.isInfinite(d) || (d == 0)) {\n            return d;\n        }\n        if (n < -2098) {\n            return (d > 0) ? 0.0 : -0.0;\n        }\n        if (n > 2097) {\n            return (d > 0) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n        }\n\n        // decompose d\n        final long bits = Double.doubleToRawLongBits(d);\n        final long sign = bits & 0x8000000000000000L;\n        int  exponent   = ((int) (bits >>> 52)) & 0x7ff;\n        long mantissa   = bits & 0x000fffffffffffffL;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -1023\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else if (scaledExponent > -53) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\nmantissa++;\n\n                // scales down complete mantissa, hence losing least significant bits\n                final long mostSignificantLostBit = mantissa & (1L << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Double.longBitsToDouble(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0L) ? 0.0 : -0.0;\n            }\n        } else {\n            // we are really in the case n >= 1024\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 52) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x000fffffffffffffL;\n\n                if (scaledExponent < 2047) {\n                    return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n                } else {\n                    return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 2047) {\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else {\n                return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "8": "    public static double scalb(final double d, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -1023) && (n < 1024)) {\n            return d * Double.longBitsToDouble(((long) (n + 1023)) << 52);\n        }\n\n        // handle special cases\n        if (Double.isNaN(d) || Double.isInfinite(d) || (d == 0)) {\n            return d;\n        }\n        if (n < -2098) {\n            return (d > 0) ? 0.0 : -0.0;\n        }\n        if (n > 2097) {\n            return (d > 0) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n        }\n\n        // decompose d\n        final long bits = Double.doubleToRawLongBits(d);\n        final long sign = bits & 0x8000000000000000L;\n        int  exponent   = ((int) (bits >>> 52)) & 0x7ff;\n        long mantissa   = bits & 0x000fffffffffffffL;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -1023\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else if (scaledExponent > -53) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\nmantissa = (mantissa >>> (1 - scaledExponent));\n\n                // scales down complete mantissa, hence losing least significant bits\n                final long mostSignificantLostBit = mantissa & (1L << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Double.longBitsToDouble(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0L) ? 0.0 : -0.0;\n            }\n        } else {\n            // we are really in the case n >= 1024\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 52) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x000fffffffffffffL;\n\n                if (scaledExponent < 2047) {\n                    return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n                } else {\n                    return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 2047) {\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else {\n                return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "9": "    public static double scalb(final double d, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -1023) && (n < 1024)) {\n            return d * Double.longBitsToDouble(((long) (n + 1023)) << 52);\n        }\n\n        // handle special cases\n        if (Double.isNaN(d) || Double.isInfinite(d) || (d == 0)) {\n            return d;\n        }\n        if (n < -2098) {\n            return (d > 0) ? 0.0 : -0.0;\n        }\n        if (n > 2097) {\n            return (d > 0) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n        }\n\n        // decompose d\n        final long bits = Double.doubleToRawLongBits(d);\n        final long sign = bits & 0x8000000000000000L;\n        int  exponent   = ((int) (bits >>> 52)) & 0x7ff;\n        long mantissa   = bits & 0x000fffffffffffffL;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -1023\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else if (scaledExponent > -53) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\nmantissa = (mantissa | (1L > 52));\n\n                // scales down complete mantissa, hence losing least significant bits\n                final long mostSignificantLostBit = mantissa & (1L << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Double.longBitsToDouble(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0L) ? 0.0 : -0.0;\n            }\n        } else {\n            // we are really in the case n >= 1024\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 52) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x000fffffffffffffL;\n\n                if (scaledExponent < 2047) {\n                    return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n                } else {\n                    return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 2047) {\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else {\n                return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "10": "    public static double scalb(final double d, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -1023) && (n < 1024)) {\n            return d * Double.longBitsToDouble(((long) (n + 1023)) << 52);\n        }\n\n        // handle special cases\n        if (Double.isNaN(d) || Double.isInfinite(d) || (d == 0)) {\n            return d;\n        }\n        if (n < -2098) {\n            return (d > 0) ? 0.0 : -0.0;\n        }\n        if (n > 2097) {\n            return (d > 0) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n        }\n\n        // decompose d\n        final long bits = Double.doubleToRawLongBits(d);\n        final long sign = bits & 0x8000000000000000L;\n        int  exponent   = ((int) (bits >>> 52)) & 0x7ff;\n        long mantissa   = bits & 0x000fffffffffffffL;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -1023\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else if (scaledExponent > -53) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\nmantissa = (mantissa | (1L <= 52));\n\n                // scales down complete mantissa, hence losing least significant bits\n                final long mostSignificantLostBit = mantissa & (1L << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Double.longBitsToDouble(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0L) ? 0.0 : -0.0;\n            }\n        } else {\n            // we are really in the case n >= 1024\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 52) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x000fffffffffffffL;\n\n                if (scaledExponent < 2047) {\n                    return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n                } else {\n                    return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 2047) {\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else {\n                return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "11": "    public static double scalb(final double d, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -1023) && (n < 1024)) {\n            return d * Double.longBitsToDouble(((long) (n + 1023)) << 52);\n        }\n\n        // handle special cases\n        if (Double.isNaN(d) || Double.isInfinite(d) || (d == 0)) {\n            return d;\n        }\n        if (n < -2098) {\n            return (d > 0) ? 0.0 : -0.0;\n        }\n        if (n > 2097) {\n            return (d > 0) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n        }\n\n        // decompose d\n        final long bits = Double.doubleToRawLongBits(d);\n        final long sign = bits & 0x8000000000000000L;\n        int  exponent   = ((int) (bits >>> 52)) & 0x7ff;\n        long mantissa   = bits & 0x000fffffffffffffL;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -1023\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else if (scaledExponent > -53) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\nmantissa = (mantissa | (1L < 52));\n\n                // scales down complete mantissa, hence losing least significant bits\n                final long mostSignificantLostBit = mantissa & (1L << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Double.longBitsToDouble(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0L) ? 0.0 : -0.0;\n            }\n        } else {\n            // we are really in the case n >= 1024\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 52) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x000fffffffffffffL;\n\n                if (scaledExponent < 2047) {\n                    return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n                } else {\n                    return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 2047) {\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else {\n                return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "12": "    public static double scalb(final double d, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -1023) && (n < 1024)) {\n            return d * Double.longBitsToDouble(((long) (n + 1023)) << 52);\n        }\n\n        // handle special cases\n        if (Double.isNaN(d) || Double.isInfinite(d) || (d == 0)) {\n            return d;\n        }\n        if (n < -2098) {\n            return (d > 0) ? 0.0 : -0.0;\n        }\n        if (n > 2097) {\n            return (d > 0) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n        }\n\n        // decompose d\n        final long bits = Double.doubleToRawLongBits(d);\n        final long sign = bits & 0x8000000000000000L;\n        int  exponent   = ((int) (bits >>> 52)) & 0x7ff;\n        long mantissa   = bits & 0x000fffffffffffffL;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -1023\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else if (scaledExponent > -53) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\nmantissa = (mantissa | (1L >= 52));\n\n                // scales down complete mantissa, hence losing least significant bits\n                final long mostSignificantLostBit = mantissa & (1L << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Double.longBitsToDouble(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0L) ? 0.0 : -0.0;\n            }\n        } else {\n            // we are really in the case n >= 1024\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 52) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x000fffffffffffffL;\n\n                if (scaledExponent < 2047) {\n                    return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n                } else {\n                    return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 2047) {\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else {\n                return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "13": "    public static double scalb(final double d, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -1023) && (n < 1024)) {\n            return d * Double.longBitsToDouble(((long) (n + 1023)) << 52);\n        }\n\n        // handle special cases\n        if (Double.isNaN(d) || Double.isInfinite(d) || (d == 0)) {\n            return d;\n        }\n        if (n < -2098) {\n            return (d > 0) ? 0.0 : -0.0;\n        }\n        if (n > 2097) {\n            return (d > 0) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n        }\n\n        // decompose d\n        final long bits = Double.doubleToRawLongBits(d);\n        final long sign = bits & 0x8000000000000000L;\n        int  exponent   = ((int) (bits >>> 52)) & 0x7ff;\n        long mantissa   = bits & 0x000fffffffffffffL;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -1023\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else if (scaledExponent > -53) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\nmantissa = (mantissa | (1L >>> 52));\n\n                // scales down complete mantissa, hence losing least significant bits\n                final long mostSignificantLostBit = mantissa & (1L << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Double.longBitsToDouble(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0L) ? 0.0 : -0.0;\n            }\n        } else {\n            // we are really in the case n >= 1024\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 52) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x000fffffffffffffL;\n\n                if (scaledExponent < 2047) {\n                    return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n                } else {\n                    return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 2047) {\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else {\n                return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "14": "    public static double scalb(final double d, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -1023) && (n < 1024)) {\n            return d * Double.longBitsToDouble(((long) (n + 1023)) << 52);\n        }\n\n        // handle special cases\n        if (Double.isNaN(d) || Double.isInfinite(d) || (d == 0)) {\n            return d;\n        }\n        if (n < -2098) {\n            return (d > 0) ? 0.0 : -0.0;\n        }\n        if (n > 2097) {\n            return (d > 0) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n        }\n\n        // decompose d\n        final long bits = Double.doubleToRawLongBits(d);\n        final long sign = bits & 0x8000000000000000L;\n        int  exponent   = ((int) (bits >>> 52)) & 0x7ff;\n        long mantissa   = bits & 0x000fffffffffffffL;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -1023\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else if (scaledExponent > -53) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\nmantissa = (mantissa | (1L | 52));\n\n                // scales down complete mantissa, hence losing least significant bits\n                final long mostSignificantLostBit = mantissa & (1L << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Double.longBitsToDouble(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0L) ? 0.0 : -0.0;\n            }\n        } else {\n            // we are really in the case n >= 1024\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 52) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x000fffffffffffffL;\n\n                if (scaledExponent < 2047) {\n                    return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n                } else {\n                    return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 2047) {\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else {\n                return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "15": "    public static double scalb(final double d, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -1023) && (n < 1024)) {\n            return d * Double.longBitsToDouble(((long) (n + 1023)) << 52);\n        }\n\n        // handle special cases\n        if (Double.isNaN(d) || Double.isInfinite(d) || (d == 0)) {\n            return d;\n        }\n        if (n < -2098) {\n            return (d > 0) ? 0.0 : -0.0;\n        }\n        if (n > 2097) {\n            return (d > 0) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n        }\n\n        // decompose d\n        final long bits = Double.doubleToRawLongBits(d);\n        final long sign = bits & 0x8000000000000000L;\n        int  exponent   = ((int) (bits >>> 52)) & 0x7ff;\n        long mantissa   = bits & 0x000fffffffffffffL;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -1023\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else if (scaledExponent > -53) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\nmantissa = (mantissa | (1L >> 2));\n\n                // scales down complete mantissa, hence losing least significant bits\n                final long mostSignificantLostBit = mantissa & (1L << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Double.longBitsToDouble(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0L) ? 0.0 : -0.0;\n            }\n        } else {\n            // we are really in the case n >= 1024\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 52) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x000fffffffffffffL;\n\n                if (scaledExponent < 2047) {\n                    return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n                } else {\n                    return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 2047) {\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else {\n                return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "16": "    public static double scalb(final double d, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -1023) && (n < 1024)) {\n            return d * Double.longBitsToDouble(((long) (n + 1023)) << 52);\n        }\n\n        // handle special cases\n        if (Double.isNaN(d) || Double.isInfinite(d) || (d == 0)) {\n            return d;\n        }\n        if (n < -2098) {\n            return (d > 0) ? 0.0 : -0.0;\n        }\n        if (n > 2097) {\n            return (d > 0) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n        }\n\n        // decompose d\n        final long bits = Double.doubleToRawLongBits(d);\n        final long sign = bits & 0x8000000000000000L;\n        int  exponent   = ((int) (bits >>> 52)) & 0x7ff;\n        long mantissa   = bits & 0x000fffffffffffffL;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -1023\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else if (scaledExponent > -53) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\nmantissa = (mantissa | (-0.0 >> 52));\n\n                // scales down complete mantissa, hence losing least significant bits\n                final long mostSignificantLostBit = mantissa & (1L << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Double.longBitsToDouble(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0L) ? 0.0 : -0.0;\n            }\n        } else {\n            // we are really in the case n >= 1024\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 52) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x000fffffffffffffL;\n\n                if (scaledExponent < 2047) {\n                    return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n                } else {\n                    return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 2047) {\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else {\n                return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "17": "    public static double scalb(final double d, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -1023) && (n < 1024)) {\n            return d * Double.longBitsToDouble(((long) (n + 1023)) << 52);\n        }\n\n        // handle special cases\n        if (Double.isNaN(d) || Double.isInfinite(d) || (d == 0)) {\n            return d;\n        }\n        if (n < -2098) {\n            return (d > 0) ? 0.0 : -0.0;\n        }\n        if (n > 2097) {\n            return (d > 0) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n        }\n\n        // decompose d\n        final long bits = Double.doubleToRawLongBits(d);\n        final long sign = bits & 0x8000000000000000L;\n        int  exponent   = ((int) (bits >>> 52)) & 0x7ff;\n        long mantissa   = bits & 0x000fffffffffffffL;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -1023\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else if (scaledExponent > -53) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\nmantissa = (mantissa + (1L >> 52));\n\n                // scales down complete mantissa, hence losing least significant bits\n                final long mostSignificantLostBit = mantissa & (1L << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Double.longBitsToDouble(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0L) ? 0.0 : -0.0;\n            }\n        } else {\n            // we are really in the case n >= 1024\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 52) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x000fffffffffffffL;\n\n                if (scaledExponent < 2047) {\n                    return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n                } else {\n                    return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 2047) {\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else {\n                return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "18": "    public static double scalb(final double d, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -1023) && (n < 1024)) {\n            return d * Double.longBitsToDouble(((long) (n + 1023)) << 52);\n        }\n\n        // handle special cases\n        if (Double.isNaN(d) || Double.isInfinite(d) || (d == 0)) {\n            return d;\n        }\n        if (n < -2098) {\n            return (d > 0) ? 0.0 : -0.0;\n        }\n        if (n > 2097) {\n            return (d > 0) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n        }\n\n        // decompose d\n        final long bits = Double.doubleToRawLongBits(d);\n        final long sign = bits & 0x8000000000000000L;\n        int  exponent   = ((int) (bits >>> 52)) & 0x7ff;\n        long mantissa   = bits & 0x000fffffffffffffL;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -1023\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else if (scaledExponent > -53) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\nmantissa = (mantissa && (1L >> 52));\n\n                // scales down complete mantissa, hence losing least significant bits\n                final long mostSignificantLostBit = mantissa & (1L << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Double.longBitsToDouble(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0L) ? 0.0 : -0.0;\n            }\n        } else {\n            // we are really in the case n >= 1024\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 52) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x000fffffffffffffL;\n\n                if (scaledExponent < 2047) {\n                    return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n                } else {\n                    return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 2047) {\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else {\n                return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "19": "    public static double scalb(final double d, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -1023) && (n < 1024)) {\n            return d * Double.longBitsToDouble(((long) (n + 1023)) << 52);\n        }\n\n        // handle special cases\n        if (Double.isNaN(d) || Double.isInfinite(d) || (d == 0)) {\n            return d;\n        }\n        if (n < -2098) {\n            return (d > 0) ? 0.0 : -0.0;\n        }\n        if (n > 2097) {\n            return (d > 0) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n        }\n\n        // decompose d\n        final long bits = Double.doubleToRawLongBits(d);\n        final long sign = bits & 0x8000000000000000L;\n        int  exponent   = ((int) (bits >>> 52)) & 0x7ff;\n        long mantissa   = bits & 0x000fffffffffffffL;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -1023\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else if (scaledExponent > -53) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\nmantissa = (mantissa | (1L % 52));\n\n                // scales down complete mantissa, hence losing least significant bits\n                final long mostSignificantLostBit = mantissa & (1L << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Double.longBitsToDouble(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0L) ? 0.0 : -0.0;\n            }\n        } else {\n            // we are really in the case n >= 1024\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 52) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x000fffffffffffffL;\n\n                if (scaledExponent < 2047) {\n                    return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n                } else {\n                    return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 2047) {\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else {\n                return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "20": "    public static double scalb(final double d, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -1023) && (n < 1024)) {\n            return d * Double.longBitsToDouble(((long) (n + 1023)) << 52);\n        }\n\n        // handle special cases\n        if (Double.isNaN(d) || Double.isInfinite(d) || (d == 0)) {\n            return d;\n        }\n        if (n < -2098) {\n            return (d > 0) ? 0.0 : -0.0;\n        }\n        if (n > 2097) {\n            return (d > 0) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n        }\n\n        // decompose d\n        final long bits = Double.doubleToRawLongBits(d);\n        final long sign = bits & 0x8000000000000000L;\n        int  exponent   = ((int) (bits >>> 52)) & 0x7ff;\n        long mantissa   = bits & 0x000fffffffffffffL;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -1023\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else if (scaledExponent > -53) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\nmantissa = (mantissa | (1L - 52));\n\n                // scales down complete mantissa, hence losing least significant bits\n                final long mostSignificantLostBit = mantissa & (1L << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Double.longBitsToDouble(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0L) ? 0.0 : -0.0;\n            }\n        } else {\n            // we are really in the case n >= 1024\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 52) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x000fffffffffffffL;\n\n                if (scaledExponent < 2047) {\n                    return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n                } else {\n                    return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 2047) {\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else {\n                return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "21": "    public static double scalb(final double d, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -1023) && (n < 1024)) {\n            return d * Double.longBitsToDouble(((long) (n + 1023)) << 52);\n        }\n\n        // handle special cases\n        if (Double.isNaN(d) || Double.isInfinite(d) || (d == 0)) {\n            return d;\n        }\n        if (n < -2098) {\n            return (d > 0) ? 0.0 : -0.0;\n        }\n        if (n > 2097) {\n            return (d > 0) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n        }\n\n        // decompose d\n        final long bits = Double.doubleToRawLongBits(d);\n        final long sign = bits & 0x8000000000000000L;\n        int  exponent   = ((int) (bits >>> 52)) & 0x7ff;\n        long mantissa   = bits & 0x000fffffffffffffL;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -1023\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else if (scaledExponent > -53) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\nmantissa = (mantissa | (-53 >> 52));\n\n                // scales down complete mantissa, hence losing least significant bits\n                final long mostSignificantLostBit = mantissa & (1L << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Double.longBitsToDouble(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0L) ? 0.0 : -0.0;\n            }\n        } else {\n            // we are really in the case n >= 1024\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 52) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x000fffffffffffffL;\n\n                if (scaledExponent < 2047) {\n                    return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n                } else {\n                    return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 2047) {\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else {\n                return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "22": "    public static double scalb(final double d, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -1023) && (n < 1024)) {\n            return d * Double.longBitsToDouble(((long) (n + 1023)) << 52);\n        }\n\n        // handle special cases\n        if (Double.isNaN(d) || Double.isInfinite(d) || (d == 0)) {\n            return d;\n        }\n        if (n < -2098) {\n            return (d > 0) ? 0.0 : -0.0;\n        }\n        if (n > 2097) {\n            return (d > 0) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n        }\n\n        // decompose d\n        final long bits = Double.doubleToRawLongBits(d);\n        final long sign = bits & 0x8000000000000000L;\n        int  exponent   = ((int) (bits >>> 52)) & 0x7ff;\n        long mantissa   = bits & 0x000fffffffffffffL;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -1023\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else if (scaledExponent > -53) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\nmantissa = (mantissa | (1L >> 1));\n\n                // scales down complete mantissa, hence losing least significant bits\n                final long mostSignificantLostBit = mantissa & (1L << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Double.longBitsToDouble(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0L) ? 0.0 : -0.0;\n            }\n        } else {\n            // we are really in the case n >= 1024\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 52) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x000fffffffffffffL;\n\n                if (scaledExponent < 2047) {\n                    return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n                } else {\n                    return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 2047) {\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else {\n                return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "23": "    public static double scalb(final double d, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -1023) && (n < 1024)) {\n            return d * Double.longBitsToDouble(((long) (n + 1023)) << 52);\n        }\n\n        // handle special cases\n        if (Double.isNaN(d) || Double.isInfinite(d) || (d == 0)) {\n            return d;\n        }\n        if (n < -2098) {\n            return (d > 0) ? 0.0 : -0.0;\n        }\n        if (n > 2097) {\n            return (d > 0) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n        }\n\n        // decompose d\n        final long bits = Double.doubleToRawLongBits(d);\n        final long sign = bits & 0x8000000000000000L;\n        int  exponent   = ((int) (bits >>> 52)) & 0x7ff;\n        long mantissa   = bits & 0x000fffffffffffffL;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -1023\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else if (scaledExponent > -53) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\nmantissa = (mantissa | (0L >> 52));\n\n                // scales down complete mantissa, hence losing least significant bits\n                final long mostSignificantLostBit = mantissa & (1L << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Double.longBitsToDouble(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0L) ? 0.0 : -0.0;\n            }\n        } else {\n            // we are really in the case n >= 1024\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 52) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x000fffffffffffffL;\n\n                if (scaledExponent < 2047) {\n                    return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n                } else {\n                    return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 2047) {\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else {\n                return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "24": "    public static double scalb(final double d, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -1023) && (n < 1024)) {\n            return d * Double.longBitsToDouble(((long) (n + 1023)) << 52);\n        }\n\n        // handle special cases\n        if (Double.isNaN(d) || Double.isInfinite(d) || (d == 0)) {\n            return d;\n        }\n        if (n < -2098) {\n            return (d > 0) ? 0.0 : -0.0;\n        }\n        if (n > 2097) {\n            return (d > 0) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n        }\n\n        // decompose d\n        final long bits = Double.doubleToRawLongBits(d);\n        final long sign = bits & 0x8000000000000000L;\n        int  exponent   = ((int) (bits >>> 52)) & 0x7ff;\n        long mantissa   = bits & 0x000fffffffffffffL;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -1023\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else if (scaledExponent > -53) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\nmantissa++;\n                mantissa = mantissa | (1L >> 52);\n                // scales down complete mantissa, hence losing least significant bits\n                final long mostSignificantLostBit = mantissa & (1L << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Double.longBitsToDouble(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0L) ? 0.0 : -0.0;\n            }\n        } else {\n            // we are really in the case n >= 1024\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 52) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x000fffffffffffffL;\n\n                if (scaledExponent < 2047) {\n                    return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n                } else {\n                    return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 2047) {\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else {\n                return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "25": "    public static double scalb(final double d, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -1023) && (n < 1024)) {\n            return d * Double.longBitsToDouble(((long) (n + 1023)) << 52);\n        }\n\n        // handle special cases\n        if (Double.isNaN(d) || Double.isInfinite(d) || (d == 0)) {\n            return d;\n        }\n        if (n < -2098) {\n            return (d > 0) ? 0.0 : -0.0;\n        }\n        if (n > 2097) {\n            return (d > 0) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n        }\n\n        // decompose d\n        final long bits = Double.doubleToRawLongBits(d);\n        final long sign = bits & 0x8000000000000000L;\n        int  exponent   = ((int) (bits >>> 52)) & 0x7ff;\n        long mantissa   = bits & 0x000fffffffffffffL;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -1023\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else if (scaledExponent > -53) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\nmantissa = (mantissa | (1L >> 0));\n\n                // scales down complete mantissa, hence losing least significant bits\n                final long mostSignificantLostBit = mantissa & (1L << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Double.longBitsToDouble(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0L) ? 0.0 : -0.0;\n            }\n        } else {\n            // we are really in the case n >= 1024\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 52) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x000fffffffffffffL;\n\n                if (scaledExponent < 2047) {\n                    return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n                } else {\n                    return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 2047) {\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else {\n                return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "26": "    public static double scalb(final double d, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -1023) && (n < 1024)) {\n            return d * Double.longBitsToDouble(((long) (n + 1023)) << 52);\n        }\n\n        // handle special cases\n        if (Double.isNaN(d) || Double.isInfinite(d) || (d == 0)) {\n            return d;\n        }\n        if (n < -2098) {\n            return (d > 0) ? 0.0 : -0.0;\n        }\n        if (n > 2097) {\n            return (d > 0) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n        }\n\n        // decompose d\n        final long bits = Double.doubleToRawLongBits(d);\n        final long sign = bits & 0x8000000000000000L;\n        int  exponent   = ((int) (bits >>> 52)) & 0x7ff;\n        long mantissa   = bits & 0x000fffffffffffffL;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -1023\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else if (scaledExponent > -53) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\nmantissa = (mantissa < (1L >> 52));\n\n                // scales down complete mantissa, hence losing least significant bits\n                final long mostSignificantLostBit = mantissa & (1L << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Double.longBitsToDouble(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0L) ? 0.0 : -0.0;\n            }\n        } else {\n            // we are really in the case n >= 1024\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 52) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x000fffffffffffffL;\n\n                if (scaledExponent < 2047) {\n                    return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n                } else {\n                    return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 2047) {\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else {\n                return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "27": "    public static double scalb(final double d, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -1023) && (n < 1024)) {\n            return d * Double.longBitsToDouble(((long) (n + 1023)) << 52);\n        }\n\n        // handle special cases\n        if (Double.isNaN(d) || Double.isInfinite(d) || (d == 0)) {\n            return d;\n        }\n        if (n < -2098) {\n            return (d > 0) ? 0.0 : -0.0;\n        }\n        if (n > 2097) {\n            return (d > 0) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n        }\n\n        // decompose d\n        final long bits = Double.doubleToRawLongBits(d);\n        final long sign = bits & 0x8000000000000000L;\n        int  exponent   = ((int) (bits >>> 52)) & 0x7ff;\n        long mantissa   = bits & 0x000fffffffffffffL;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -1023\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else if (scaledExponent > -53) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\nmantissa = (mantissa >>> (1 - scaledExponent));\n                mantissa = mantissa | (1L >> 52);\n                // scales down complete mantissa, hence losing least significant bits\n                final long mostSignificantLostBit = mantissa & (1L << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Double.longBitsToDouble(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0L) ? 0.0 : -0.0;\n            }\n        } else {\n            // we are really in the case n >= 1024\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 52) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x000fffffffffffffL;\n\n                if (scaledExponent < 2047) {\n                    return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n                } else {\n                    return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 2047) {\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else {\n                return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "28": "    public static double scalb(final double d, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -1023) && (n < 1024)) {\n            return d * Double.longBitsToDouble(((long) (n + 1023)) << 52);\n        }\n\n        // handle special cases\n        if (Double.isNaN(d) || Double.isInfinite(d) || (d == 0)) {\n            return d;\n        }\n        if (n < -2098) {\n            return (d > 0) ? 0.0 : -0.0;\n        }\n        if (n > 2097) {\n            return (d > 0) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n        }\n\n        // decompose d\n        final long bits = Double.doubleToRawLongBits(d);\n        final long sign = bits & 0x8000000000000000L;\n        int  exponent   = ((int) (bits >>> 52)) & 0x7ff;\n        long mantissa   = bits & 0x000fffffffffffffL;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -1023\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else if (scaledExponent > -53) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\nmantissa += (mantissa | (1L >> 52));\n\n                // scales down complete mantissa, hence losing least significant bits\n                final long mostSignificantLostBit = mantissa & (1L << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Double.longBitsToDouble(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0L) ? 0.0 : -0.0;\n            }\n        } else {\n            // we are really in the case n >= 1024\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 52) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x000fffffffffffffL;\n\n                if (scaledExponent < 2047) {\n                    return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n                } else {\n                    return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 2047) {\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else {\n                return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "29": "    public static double scalb(final double d, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -1023) && (n < 1024)) {\n            return d * Double.longBitsToDouble(((long) (n + 1023)) << 52);\n        }\n\n        // handle special cases\n        if (Double.isNaN(d) || Double.isInfinite(d) || (d == 0)) {\n            return d;\n        }\n        if (n < -2098) {\n            return (d > 0) ? 0.0 : -0.0;\n        }\n        if (n > 2097) {\n            return (d > 0) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n        }\n\n        // decompose d\n        final long bits = Double.doubleToRawLongBits(d);\n        final long sign = bits & 0x8000000000000000L;\n        int  exponent   = ((int) (bits >>> 52)) & 0x7ff;\n        long mantissa   = bits & 0x000fffffffffffffL;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -1023\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else if (scaledExponent > -53) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\nmantissa = (mantissa || (1L >> 52));\n\n                // scales down complete mantissa, hence losing least significant bits\n                final long mostSignificantLostBit = mantissa & (1L << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Double.longBitsToDouble(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0L) ? 0.0 : -0.0;\n            }\n        } else {\n            // we are really in the case n >= 1024\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 52) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x000fffffffffffffL;\n\n                if (scaledExponent < 2047) {\n                    return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n                } else {\n                    return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 2047) {\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else {\n                return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "30": "    public static double scalb(final double d, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -1023) && (n < 1024)) {\n            return d * Double.longBitsToDouble(((long) (n + 1023)) << 52);\n        }\n\n        // handle special cases\n        if (Double.isNaN(d) || Double.isInfinite(d) || (d == 0)) {\n            return d;\n        }\n        if (n < -2098) {\n            return (d > 0) ? 0.0 : -0.0;\n        }\n        if (n > 2097) {\n            return (d > 0) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n        }\n\n        // decompose d\n        final long bits = Double.doubleToRawLongBits(d);\n        final long sign = bits & 0x8000000000000000L;\n        int  exponent   = ((int) (bits >>> 52)) & 0x7ff;\n        long mantissa   = bits & 0x000fffffffffffffL;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -1023\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else if (scaledExponent > -53) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\nmantissa = (mantissa | (0.0 >> 52));\n\n                // scales down complete mantissa, hence losing least significant bits\n                final long mostSignificantLostBit = mantissa & (1L << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Double.longBitsToDouble(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0L) ? 0.0 : -0.0;\n            }\n        } else {\n            // we are really in the case n >= 1024\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 52) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x000fffffffffffffL;\n\n                if (scaledExponent < 2047) {\n                    return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n                } else {\n                    return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 2047) {\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else {\n                return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "31": "    public static double scalb(final double d, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -1023) && (n < 1024)) {\n            return d * Double.longBitsToDouble(((long) (n + 1023)) << 52);\n        }\n\n        // handle special cases\n        if (Double.isNaN(d) || Double.isInfinite(d) || (d == 0)) {\n            return d;\n        }\n        if (n < -2098) {\n            return (d > 0) ? 0.0 : -0.0;\n        }\n        if (n > 2097) {\n            return (d > 0) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n        }\n\n        // decompose d\n        final long bits = Double.doubleToRawLongBits(d);\n        final long sign = bits & 0x8000000000000000L;\n        int  exponent   = ((int) (bits >>> 52)) & 0x7ff;\n        long mantissa   = bits & 0x000fffffffffffffL;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -1023\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else if (scaledExponent > -53) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\nmantissa = (mantissa << (1L >> 52));\n\n                // scales down complete mantissa, hence losing least significant bits\n                final long mostSignificantLostBit = mantissa & (1L << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Double.longBitsToDouble(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0L) ? 0.0 : -0.0;\n            }\n        } else {\n            // we are really in the case n >= 1024\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 52) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x000fffffffffffffL;\n\n                if (scaledExponent < 2047) {\n                    return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n                } else {\n                    return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 2047) {\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else {\n                return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "32": "    public static double scalb(final double d, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -1023) && (n < 1024)) {\n            return d * Double.longBitsToDouble(((long) (n + 1023)) << 52);\n        }\n\n        // handle special cases\n        if (Double.isNaN(d) || Double.isInfinite(d) || (d == 0)) {\n            return d;\n        }\n        if (n < -2098) {\n            return (d > 0) ? 0.0 : -0.0;\n        }\n        if (n > 2097) {\n            return (d > 0) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n        }\n\n        // decompose d\n        final long bits = Double.doubleToRawLongBits(d);\n        final long sign = bits & 0x8000000000000000L;\n        int  exponent   = ((int) (bits >>> 52)) & 0x7ff;\n        long mantissa   = bits & 0x000fffffffffffffL;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -1023\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else if (scaledExponent > -53) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\nmantissa = (mantissa * (1L >> 52));\n\n                // scales down complete mantissa, hence losing least significant bits\n                final long mostSignificantLostBit = mantissa & (1L << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Double.longBitsToDouble(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0L) ? 0.0 : -0.0;\n            }\n        } else {\n            // we are really in the case n >= 1024\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 52) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x000fffffffffffffL;\n\n                if (scaledExponent < 2047) {\n                    return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n                } else {\n                    return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 2047) {\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else {\n                return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "33": "    public static double scalb(final double d, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -1023) && (n < 1024)) {\n            return d * Double.longBitsToDouble(((long) (n + 1023)) << 52);\n        }\n\n        // handle special cases\n        if (Double.isNaN(d) || Double.isInfinite(d) || (d == 0)) {\n            return d;\n        }\n        if (n < -2098) {\n            return (d > 0) ? 0.0 : -0.0;\n        }\n        if (n > 2097) {\n            return (d > 0) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n        }\n\n        // decompose d\n        final long bits = Double.doubleToRawLongBits(d);\n        final long sign = bits & 0x8000000000000000L;\n        int  exponent   = ((int) (bits >>> 52)) & 0x7ff;\n        long mantissa   = bits & 0x000fffffffffffffL;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -1023\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else if (scaledExponent > -53) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\nmantissa = (mantissa | (-1 >> 52));\n\n                // scales down complete mantissa, hence losing least significant bits\n                final long mostSignificantLostBit = mantissa & (1L << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Double.longBitsToDouble(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0L) ? 0.0 : -0.0;\n            }\n        } else {\n            // we are really in the case n >= 1024\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 52) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x000fffffffffffffL;\n\n                if (scaledExponent < 2047) {\n                    return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n                } else {\n                    return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 2047) {\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else {\n                return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "34": "    public static double scalb(final double d, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -1023) && (n < 1024)) {\n            return d * Double.longBitsToDouble(((long) (n + 1023)) << 52);\n        }\n\n        // handle special cases\n        if (Double.isNaN(d) || Double.isInfinite(d) || (d == 0)) {\n            return d;\n        }\n        if (n < -2098) {\n            return (d > 0) ? 0.0 : -0.0;\n        }\n        if (n > 2097) {\n            return (d > 0) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n        }\n\n        // decompose d\n        final long bits = Double.doubleToRawLongBits(d);\n        final long sign = bits & 0x8000000000000000L;\n        int  exponent   = ((int) (bits >>> 52)) & 0x7ff;\n        long mantissa   = bits & 0x000fffffffffffffL;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -1023\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else if (scaledExponent > -53) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\nmantissa = (mantissa - (1L >> 52));\n\n                // scales down complete mantissa, hence losing least significant bits\n                final long mostSignificantLostBit = mantissa & (1L << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Double.longBitsToDouble(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0L) ? 0.0 : -0.0;\n            }\n        } else {\n            // we are really in the case n >= 1024\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 52) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x000fffffffffffffL;\n\n                if (scaledExponent < 2047) {\n                    return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n                } else {\n                    return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 2047) {\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else {\n                return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "35": "    public static double scalb(final double d, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -1023) && (n < 1024)) {\n            return d * Double.longBitsToDouble(((long) (n + 1023)) << 52);\n        }\n\n        // handle special cases\n        if (Double.isNaN(d) || Double.isInfinite(d) || (d == 0)) {\n            return d;\n        }\n        if (n < -2098) {\n            return (d > 0) ? 0.0 : -0.0;\n        }\n        if (n > 2097) {\n            return (d > 0) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n        }\n\n        // decompose d\n        final long bits = Double.doubleToRawLongBits(d);\n        final long sign = bits & 0x8000000000000000L;\n        int  exponent   = ((int) (bits >>> 52)) & 0x7ff;\n        long mantissa   = bits & 0x000fffffffffffffL;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -1023\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else if (scaledExponent > -53) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\nmantissa = (mantissa / (1L >> 52));\n\n                // scales down complete mantissa, hence losing least significant bits\n                final long mostSignificantLostBit = mantissa & (1L << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Double.longBitsToDouble(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0L) ? 0.0 : -0.0;\n            }\n        } else {\n            // we are really in the case n >= 1024\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 52) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x000fffffffffffffL;\n\n                if (scaledExponent < 2047) {\n                    return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n                } else {\n                    return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 2047) {\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else {\n                return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "36": "    public static double scalb(final double d, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -1023) && (n < 1024)) {\n            return d * Double.longBitsToDouble(((long) (n + 1023)) << 52);\n        }\n\n        // handle special cases\n        if (Double.isNaN(d) || Double.isInfinite(d) || (d == 0)) {\n            return d;\n        }\n        if (n < -2098) {\n            return (d > 0) ? 0.0 : -0.0;\n        }\n        if (n > 2097) {\n            return (d > 0) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n        }\n\n        // decompose d\n        final long bits = Double.doubleToRawLongBits(d);\n        final long sign = bits & 0x8000000000000000L;\n        int  exponent   = ((int) (bits >>> 52)) & 0x7ff;\n        long mantissa   = bits & 0x000fffffffffffffL;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -1023\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else if (scaledExponent > -53) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\nmantissa = (1L >> 52);\n\n                // scales down complete mantissa, hence losing least significant bits\n                final long mostSignificantLostBit = mantissa & (1L << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Double.longBitsToDouble(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0L) ? 0.0 : -0.0;\n            }\n        } else {\n            // we are really in the case n >= 1024\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 52) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x000fffffffffffffL;\n\n                if (scaledExponent < 2047) {\n                    return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n                } else {\n                    return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 2047) {\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else {\n                return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "37": "    public static double scalb(final double d, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -1023) && (n < 1024)) {\n            return d * Double.longBitsToDouble(((long) (n + 1023)) << 52);\n        }\n\n        // handle special cases\n        if (Double.isNaN(d) || Double.isInfinite(d) || (d == 0)) {\n            return d;\n        }\n        if (n < -2098) {\n            return (d > 0) ? 0.0 : -0.0;\n        }\n        if (n > 2097) {\n            return (d > 0) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n        }\n\n        // decompose d\n        final long bits = Double.doubleToRawLongBits(d);\n        final long sign = bits & 0x8000000000000000L;\n        int  exponent   = ((int) (bits >>> 52)) & 0x7ff;\n        long mantissa   = bits & 0x000fffffffffffffL;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -1023\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else if (scaledExponent > -53) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\nmantissa = (mantissa | (1L >> -0.0));\n\n                // scales down complete mantissa, hence losing least significant bits\n                final long mostSignificantLostBit = mantissa & (1L << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Double.longBitsToDouble(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0L) ? 0.0 : -0.0;\n            }\n        } else {\n            // we are really in the case n >= 1024\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 52) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x000fffffffffffffL;\n\n                if (scaledExponent < 2047) {\n                    return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n                } else {\n                    return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 2047) {\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else {\n                return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "38": "    public static double scalb(final double d, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -1023) && (n < 1024)) {\n            return d * Double.longBitsToDouble(((long) (n + 1023)) << 52);\n        }\n\n        // handle special cases\n        if (Double.isNaN(d) || Double.isInfinite(d) || (d == 0)) {\n            return d;\n        }\n        if (n < -2098) {\n            return (d > 0) ? 0.0 : -0.0;\n        }\n        if (n > 2097) {\n            return (d > 0) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n        }\n\n        // decompose d\n        final long bits = Double.doubleToRawLongBits(d);\n        final long sign = bits & 0x8000000000000000L;\n        int  exponent   = ((int) (bits >>> 52)) & 0x7ff;\n        long mantissa   = bits & 0x000fffffffffffffL;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -1023\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else if (scaledExponent > -53) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\nmantissa = (mantissa | (1L >> -53));\n\n                // scales down complete mantissa, hence losing least significant bits\n                final long mostSignificantLostBit = mantissa & (1L << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Double.longBitsToDouble(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0L) ? 0.0 : -0.0;\n            }\n        } else {\n            // we are really in the case n >= 1024\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 52) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x000fffffffffffffL;\n\n                if (scaledExponent < 2047) {\n                    return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n                } else {\n                    return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 2047) {\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else {\n                return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "39": "    public static double scalb(final double d, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -1023) && (n < 1024)) {\n            return d * Double.longBitsToDouble(((long) (n + 1023)) << 52);\n        }\n\n        // handle special cases\n        if (Double.isNaN(d) || Double.isInfinite(d) || (d == 0)) {\n            return d;\n        }\n        if (n < -2098) {\n            return (d > 0) ? 0.0 : -0.0;\n        }\n        if (n > 2097) {\n            return (d > 0) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n        }\n\n        // decompose d\n        final long bits = Double.doubleToRawLongBits(d);\n        final long sign = bits & 0x8000000000000000L;\n        int  exponent   = ((int) (bits >>> 52)) & 0x7ff;\n        long mantissa   = bits & 0x000fffffffffffffL;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -1023\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else if (scaledExponent > -53) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\nmantissa = (mantissa | (1L >> 0L));\n\n                // scales down complete mantissa, hence losing least significant bits\n                final long mostSignificantLostBit = mantissa & (1L << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Double.longBitsToDouble(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0L) ? 0.0 : -0.0;\n            }\n        } else {\n            // we are really in the case n >= 1024\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 52) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x000fffffffffffffL;\n\n                if (scaledExponent < 2047) {\n                    return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n                } else {\n                    return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 2047) {\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else {\n                return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "40": "    public static double scalb(final double d, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -1023) && (n < 1024)) {\n            return d * Double.longBitsToDouble(((long) (n + 1023)) << 52);\n        }\n\n        // handle special cases\n        if (Double.isNaN(d) || Double.isInfinite(d) || (d == 0)) {\n            return d;\n        }\n        if (n < -2098) {\n            return (d > 0) ? 0.0 : -0.0;\n        }\n        if (n > 2097) {\n            return (d > 0) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n        }\n\n        // decompose d\n        final long bits = Double.doubleToRawLongBits(d);\n        final long sign = bits & 0x8000000000000000L;\n        int  exponent   = ((int) (bits >>> 52)) & 0x7ff;\n        long mantissa   = bits & 0x000fffffffffffffL;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -1023\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else if (scaledExponent > -53) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\nif((scaledExponent > -53)){\n                mantissa = mantissa | (1L >> 52);\n                // scales down complete mantissa, hence losing least significant bits\n                final long mostSignificantLostBit = mantissa & (1L << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Double.longBitsToDouble(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0L) ? 0.0 : -0.0;\n}\n            }\n        } else {\n            // we are really in the case n >= 1024\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 52) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x000fffffffffffffL;\n\n                if (scaledExponent < 2047) {\n                    return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n                } else {\n                    return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 2047) {\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else {\n                return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "41": "    public static double scalb(final double d, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -1023) && (n < 1024)) {\n            return d * Double.longBitsToDouble(((long) (n + 1023)) << 52);\n        }\n\n        // handle special cases\n        if (Double.isNaN(d) || Double.isInfinite(d) || (d == 0)) {\n            return d;\n        }\n        if (n < -2098) {\n            return (d > 0) ? 0.0 : -0.0;\n        }\n        if (n > 2097) {\n            return (d > 0) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n        }\n\n        // decompose d\n        final long bits = Double.doubleToRawLongBits(d);\n        final long sign = bits & 0x8000000000000000L;\n        int  exponent   = ((int) (bits >>> 52)) & 0x7ff;\n        long mantissa   = bits & 0x000fffffffffffffL;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -1023\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else if (scaledExponent > -53) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\nmantissa -= (mantissa | (1L >> 52));\n\n                // scales down complete mantissa, hence losing least significant bits\n                final long mostSignificantLostBit = mantissa & (1L << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Double.longBitsToDouble(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0L) ? 0.0 : -0.0;\n            }\n        } else {\n            // we are really in the case n >= 1024\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 52) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x000fffffffffffffL;\n\n                if (scaledExponent < 2047) {\n                    return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n                } else {\n                    return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 2047) {\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else {\n                return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "42": "    public static double scalb(final double d, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -1023) && (n < 1024)) {\n            return d * Double.longBitsToDouble(((long) (n + 1023)) << 52);\n        }\n\n        // handle special cases\n        if (Double.isNaN(d) || Double.isInfinite(d) || (d == 0)) {\n            return d;\n        }\n        if (n < -2098) {\n            return (d > 0) ? 0.0 : -0.0;\n        }\n        if (n > 2097) {\n            return (d > 0) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n        }\n\n        // decompose d\n        final long bits = Double.doubleToRawLongBits(d);\n        final long sign = bits & 0x8000000000000000L;\n        int  exponent   = ((int) (bits >>> 52)) & 0x7ff;\n        long mantissa   = bits & 0x000fffffffffffffL;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -1023\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else if (scaledExponent > -53) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\nmantissa &= (mantissa | (1L >> 52));\n\n                // scales down complete mantissa, hence losing least significant bits\n                final long mostSignificantLostBit = mantissa & (1L << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Double.longBitsToDouble(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0L) ? 0.0 : -0.0;\n            }\n        } else {\n            // we are really in the case n >= 1024\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 52) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x000fffffffffffffL;\n\n                if (scaledExponent < 2047) {\n                    return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n                } else {\n                    return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 2047) {\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else {\n                return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "43": "    public static double scalb(final double d, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -1023) && (n < 1024)) {\n            return d * Double.longBitsToDouble(((long) (n + 1023)) << 52);\n        }\n\n        // handle special cases\n        if (Double.isNaN(d) || Double.isInfinite(d) || (d == 0)) {\n            return d;\n        }\n        if (n < -2098) {\n            return (d > 0) ? 0.0 : -0.0;\n        }\n        if (n > 2097) {\n            return (d > 0) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n        }\n\n        // decompose d\n        final long bits = Double.doubleToRawLongBits(d);\n        final long sign = bits & 0x8000000000000000L;\n        int  exponent   = ((int) (bits >>> 52)) & 0x7ff;\n        long mantissa   = bits & 0x000fffffffffffffL;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -1023\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else if (scaledExponent > -53) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\nmantissa = (mantissa & (1L << scaledExponent));\n\n                // scales down complete mantissa, hence losing least significant bits\n                final long mostSignificantLostBit = mantissa & (1L << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Double.longBitsToDouble(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0L) ? 0.0 : -0.0;\n            }\n        } else {\n            // we are really in the case n >= 1024\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 52) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x000fffffffffffffL;\n\n                if (scaledExponent < 2047) {\n                    return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n                } else {\n                    return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 2047) {\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else {\n                return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "44": "    public static double scalb(final double d, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -1023) && (n < 1024)) {\n            return d * Double.longBitsToDouble(((long) (n + 1023)) << 52);\n        }\n\n        // handle special cases\n        if (Double.isNaN(d) || Double.isInfinite(d) || (d == 0)) {\n            return d;\n        }\n        if (n < -2098) {\n            return (d > 0) ? 0.0 : -0.0;\n        }\n        if (n > 2097) {\n            return (d > 0) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n        }\n\n        // decompose d\n        final long bits = Double.doubleToRawLongBits(d);\n        final long sign = bits & 0x8000000000000000L;\n        int  exponent   = ((int) (bits >>> 52)) & 0x7ff;\n        long mantissa   = bits & 0x000fffffffffffffL;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -1023\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else if (scaledExponent > -53) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\nmantissa = (sign | mantissa);\n\n                // scales down complete mantissa, hence losing least significant bits\n                final long mostSignificantLostBit = mantissa & (1L << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Double.longBitsToDouble(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0L) ? 0.0 : -0.0;\n            }\n        } else {\n            // we are really in the case n >= 1024\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 52) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x000fffffffffffffL;\n\n                if (scaledExponent < 2047) {\n                    return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n                } else {\n                    return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 2047) {\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else {\n                return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "45": "    public static double scalb(final double d, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -1023) && (n < 1024)) {\n            return d * Double.longBitsToDouble(((long) (n + 1023)) << 52);\n        }\n\n        // handle special cases\n        if (Double.isNaN(d) || Double.isInfinite(d) || (d == 0)) {\n            return d;\n        }\n        if (n < -2098) {\n            return (d > 0) ? 0.0 : -0.0;\n        }\n        if (n > 2097) {\n            return (d > 0) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n        }\n\n        // decompose d\n        final long bits = Double.doubleToRawLongBits(d);\n        final long sign = bits & 0x8000000000000000L;\n        int  exponent   = ((int) (bits >>> 52)) & 0x7ff;\n        long mantissa   = bits & 0x000fffffffffffffL;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -1023\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else if (scaledExponent > -53) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\nmantissa = (1L << scaledExponent);\n\n                // scales down complete mantissa, hence losing least significant bits\n                final long mostSignificantLostBit = mantissa & (1L << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Double.longBitsToDouble(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0L) ? 0.0 : -0.0;\n            }\n        } else {\n            // we are really in the case n >= 1024\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 52) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x000fffffffffffffL;\n\n                if (scaledExponent < 2047) {\n                    return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n                } else {\n                    return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 2047) {\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else {\n                return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "46": "    public static double scalb(final double d, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -1023) && (n < 1024)) {\n            return d * Double.longBitsToDouble(((long) (n + 1023)) << 52);\n        }\n\n        // handle special cases\n        if (Double.isNaN(d) || Double.isInfinite(d) || (d == 0)) {\n            return d;\n        }\n        if (n < -2098) {\n            return (d > 0) ? 0.0 : -0.0;\n        }\n        if (n > 2097) {\n            return (d > 0) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n        }\n\n        // decompose d\n        final long bits = Double.doubleToRawLongBits(d);\n        final long sign = bits & 0x8000000000000000L;\n        int  exponent   = ((int) (bits >>> 52)) & 0x7ff;\n        long mantissa   = bits & 0x000fffffffffffffL;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -1023\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else if (scaledExponent > -53) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\nmantissa = (mantissa | (1L >> -1));\n\n                // scales down complete mantissa, hence losing least significant bits\n                final long mostSignificantLostBit = mantissa & (1L << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Double.longBitsToDouble(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0L) ? 0.0 : -0.0;\n            }\n        } else {\n            // we are really in the case n >= 1024\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 52) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x000fffffffffffffL;\n\n                if (scaledExponent < 2047) {\n                    return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n                } else {\n                    return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 2047) {\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else {\n                return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "47": "    public static double scalb(final double d, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -1023) && (n < 1024)) {\n            return d * Double.longBitsToDouble(((long) (n + 1023)) << 52);\n        }\n\n        // handle special cases\n        if (Double.isNaN(d) || Double.isInfinite(d) || (d == 0)) {\n            return d;\n        }\n        if (n < -2098) {\n            return (d > 0) ? 0.0 : -0.0;\n        }\n        if (n > 2097) {\n            return (d > 0) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n        }\n\n        // decompose d\n        final long bits = Double.doubleToRawLongBits(d);\n        final long sign = bits & 0x8000000000000000L;\n        int  exponent   = ((int) (bits >>> 52)) & 0x7ff;\n        long mantissa   = bits & 0x000fffffffffffffL;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -1023\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else if (scaledExponent > -53) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\nmantissa = (mantissa | (1L >> 0.0));\n\n                // scales down complete mantissa, hence losing least significant bits\n                final long mostSignificantLostBit = mantissa & (1L << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Double.longBitsToDouble(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0L) ? 0.0 : -0.0;\n            }\n        } else {\n            // we are really in the case n >= 1024\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 52) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x000fffffffffffffL;\n\n                if (scaledExponent < 2047) {\n                    return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n                } else {\n                    return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 2047) {\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else {\n                return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "48": "    public static double scalb(final double d, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -1023) && (n < 1024)) {\n            return d * Double.longBitsToDouble(((long) (n + 1023)) << 52);\n        }\n\n        // handle special cases\n        if (Double.isNaN(d) || Double.isInfinite(d) || (d == 0)) {\n            return d;\n        }\n        if (n < -2098) {\n            return (d > 0) ? 0.0 : -0.0;\n        }\n        if (n > 2097) {\n            return (d > 0) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n        }\n\n        // decompose d\n        final long bits = Double.doubleToRawLongBits(d);\n        final long sign = bits & 0x8000000000000000L;\n        int  exponent   = ((int) (bits >>> 52)) & 0x7ff;\n        long mantissa   = bits & 0x000fffffffffffffL;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -1023\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else if (scaledExponent > -53) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\nmantissa = (mantissa | (52 >> 52));\n\n                // scales down complete mantissa, hence losing least significant bits\n                final long mostSignificantLostBit = mantissa & (1L << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Double.longBitsToDouble(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0L) ? 0.0 : -0.0;\n            }\n        } else {\n            // we are really in the case n >= 1024\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 52) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x000fffffffffffffL;\n\n                if (scaledExponent < 2047) {\n                    return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n                } else {\n                    return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 2047) {\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else {\n                return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "49": "    public static double scalb(final double d, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -1023) && (n < 1024)) {\n            return d * Double.longBitsToDouble(((long) (n + 1023)) << 52);\n        }\n\n        // handle special cases\n        if (Double.isNaN(d) || Double.isInfinite(d) || (d == 0)) {\n            return d;\n        }\n        if (n < -2098) {\n            return (d > 0) ? 0.0 : -0.0;\n        }\n        if (n > 2097) {\n            return (d > 0) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n        }\n\n        // decompose d\n        final long bits = Double.doubleToRawLongBits(d);\n        final long sign = bits & 0x8000000000000000L;\n        int  exponent   = ((int) (bits >>> 52)) & 0x7ff;\n        long mantissa   = bits & 0x000fffffffffffffL;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -1023\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else if (scaledExponent > -53) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\nif((mantissa | (1L >> 52))){\n\n                // scales down complete mantissa, hence losing least significant bits\n                final long mostSignificantLostBit = mantissa & (1L << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Double.longBitsToDouble(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0L) ? 0.0 : -0.0;\n            }\n        } else {\n            // we are really in the case n >= 1024\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 52) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x000fffffffffffffL;\n\n                if (scaledExponent < 2047) {\n                    return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n                } else {\n                    return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 2047) {\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else {\n                return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "50": "    public static double scalb(final double d, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -1023) && (n < 1024)) {\n            return d * Double.longBitsToDouble(((long) (n + 1023)) << 52);\n        }\n\n        // handle special cases\n        if (Double.isNaN(d) || Double.isInfinite(d) || (d == 0)) {\n            return d;\n        }\n        if (n < -2098) {\n            return (d > 0) ? 0.0 : -0.0;\n        }\n        if (n > 2097) {\n            return (d > 0) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n        }\n\n        // decompose d\n        final long bits = Double.doubleToRawLongBits(d);\n        final long sign = bits & 0x8000000000000000L;\n        int  exponent   = ((int) (bits >>> 52)) & 0x7ff;\n        long mantissa   = bits & 0x000fffffffffffffL;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -1023\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else if (scaledExponent > -53) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\nreturn Double.longBitsToDouble((sign | mantissa));                mantissa = mantissa | (1L >> 52);\n                // scales down complete mantissa, hence losing least significant bits\n                final long mostSignificantLostBit = mantissa & (1L << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Double.longBitsToDouble(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0L) ? 0.0 : -0.0;\n            }\n        } else {\n            // we are really in the case n >= 1024\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 52) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x000fffffffffffffL;\n\n                if (scaledExponent < 2047) {\n                    return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n                } else {\n                    return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 2047) {\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else {\n                return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "51": "    public static double scalb(final double d, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -1023) && (n < 1024)) {\n            return d * Double.longBitsToDouble(((long) (n + 1023)) << 52);\n        }\n\n        // handle special cases\n        if (Double.isNaN(d) || Double.isInfinite(d) || (d == 0)) {\n            return d;\n        }\n        if (n < -2098) {\n            return (d > 0) ? 0.0 : -0.0;\n        }\n        if (n > 2097) {\n            return (d > 0) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n        }\n\n        // decompose d\n        final long bits = Double.doubleToRawLongBits(d);\n        final long sign = bits & 0x8000000000000000L;\n        int  exponent   = ((int) (bits >>> 52)) & 0x7ff;\n        long mantissa   = bits & 0x000fffffffffffffL;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -1023\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else if (scaledExponent > -53) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\nreturn ((sign == 0L))?0.0:-0.0;                mantissa = mantissa | (1L >> 52);\n                // scales down complete mantissa, hence losing least significant bits\n                final long mostSignificantLostBit = mantissa & (1L << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Double.longBitsToDouble(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0L) ? 0.0 : -0.0;\n            }\n        } else {\n            // we are really in the case n >= 1024\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 52) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x000fffffffffffffL;\n\n                if (scaledExponent < 2047) {\n                    return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n                } else {\n                    return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 2047) {\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else {\n                return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "52": "    public static double scalb(final double d, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -1023) && (n < 1024)) {\n            return d * Double.longBitsToDouble(((long) (n + 1023)) << 52);\n        }\n\n        // handle special cases\n        if (Double.isNaN(d) || Double.isInfinite(d) || (d == 0)) {\n            return d;\n        }\n        if (n < -2098) {\n            return (d > 0) ? 0.0 : -0.0;\n        }\n        if (n > 2097) {\n            return (d > 0) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n        }\n\n        // decompose d\n        final long bits = Double.doubleToRawLongBits(d);\n        final long sign = bits & 0x8000000000000000L;\n        int  exponent   = ((int) (bits >>> 52)) & 0x7ff;\n        long mantissa   = bits & 0x000fffffffffffffL;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -1023\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else if (scaledExponent > -53) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\nmantissa = (mantissa | (1L >> 1L));\n\n                // scales down complete mantissa, hence losing least significant bits\n                final long mostSignificantLostBit = mantissa & (1L << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Double.longBitsToDouble(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0L) ? 0.0 : -0.0;\n            }\n        } else {\n            // we are really in the case n >= 1024\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 52) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x000fffffffffffffL;\n\n                if (scaledExponent < 2047) {\n                    return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n                } else {\n                    return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 2047) {\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else {\n                return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "53": "    public static double scalb(final double d, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -1023) && (n < 1024)) {\n            return d * Double.longBitsToDouble(((long) (n + 1023)) << 52);\n        }\n\n        // handle special cases\n        if (Double.isNaN(d) || Double.isInfinite(d) || (d == 0)) {\n            return d;\n        }\n        if (n < -2098) {\n            return (d > 0) ? 0.0 : -0.0;\n        }\n        if (n > 2097) {\n            return (d > 0) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n        }\n\n        // decompose d\n        final long bits = Double.doubleToRawLongBits(d);\n        final long sign = bits & 0x8000000000000000L;\n        int  exponent   = ((int) (bits >>> 52)) & 0x7ff;\n        long mantissa   = bits & 0x000fffffffffffffL;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -1023\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else if (scaledExponent > -53) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\nmantissa = (scaledExponent | (1L >> 52));\n\n                // scales down complete mantissa, hence losing least significant bits\n                final long mostSignificantLostBit = mantissa & (1L << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Double.longBitsToDouble(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0L) ? 0.0 : -0.0;\n            }\n        } else {\n            // we are really in the case n >= 1024\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 52) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x000fffffffffffffL;\n\n                if (scaledExponent < 2047) {\n                    return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n                } else {\n                    return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 2047) {\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else {\n                return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "54": "    public static double scalb(final double d, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -1023) && (n < 1024)) {\n            return d * Double.longBitsToDouble(((long) (n + 1023)) << 52);\n        }\n\n        // handle special cases\n        if (Double.isNaN(d) || Double.isInfinite(d) || (d == 0)) {\n            return d;\n        }\n        if (n < -2098) {\n            return (d > 0) ? 0.0 : -0.0;\n        }\n        if (n > 2097) {\n            return (d > 0) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n        }\n\n        // decompose d\n        final long bits = Double.doubleToRawLongBits(d);\n        final long sign = bits & 0x8000000000000000L;\n        int  exponent   = ((int) (bits >>> 52)) & 0x7ff;\n        long mantissa   = bits & 0x000fffffffffffffL;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -1023\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else if (scaledExponent > -53) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\nreturn ((sign == 0L))?0.0:-0.0;\n                // scales down complete mantissa, hence losing least significant bits\n                final long mostSignificantLostBit = mantissa & (1L << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Double.longBitsToDouble(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0L) ? 0.0 : -0.0;\n            }\n        } else {\n            // we are really in the case n >= 1024\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 52) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x000fffffffffffffL;\n\n                if (scaledExponent < 2047) {\n                    return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n                } else {\n                    return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 2047) {\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else {\n                return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "55": "    public static double scalb(final double d, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -1023) && (n < 1024)) {\n            return d * Double.longBitsToDouble(((long) (n + 1023)) << 52);\n        }\n\n        // handle special cases\n        if (Double.isNaN(d) || Double.isInfinite(d) || (d == 0)) {\n            return d;\n        }\n        if (n < -2098) {\n            return (d > 0) ? 0.0 : -0.0;\n        }\n        if (n > 2097) {\n            return (d > 0) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n        }\n\n        // decompose d\n        final long bits = Double.doubleToRawLongBits(d);\n        final long sign = bits & 0x8000000000000000L;\n        int  exponent   = ((int) (bits >>> 52)) & 0x7ff;\n        long mantissa   = bits & 0x000fffffffffffffL;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -1023\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else if (scaledExponent > -53) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\nreturn Double.longBitsToDouble((sign | mantissa));\n                // scales down complete mantissa, hence losing least significant bits\n                final long mostSignificantLostBit = mantissa & (1L << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Double.longBitsToDouble(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0L) ? 0.0 : -0.0;\n            }\n        } else {\n            // we are really in the case n >= 1024\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 52) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x000fffffffffffffL;\n\n                if (scaledExponent < 2047) {\n                    return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n                } else {\n                    return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 2047) {\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else {\n                return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "56": "    public static double scalb(final double d, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -1023) && (n < 1024)) {\n            return d * Double.longBitsToDouble(((long) (n + 1023)) << 52);\n        }\n\n        // handle special cases\n        if (Double.isNaN(d) || Double.isInfinite(d) || (d == 0)) {\n            return d;\n        }\n        if (n < -2098) {\n            return (d > 0) ? 0.0 : -0.0;\n        }\n        if (n > 2097) {\n            return (d > 0) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n        }\n\n        // decompose d\n        final long bits = Double.doubleToRawLongBits(d);\n        final long sign = bits & 0x8000000000000000L;\n        int  exponent   = ((int) (bits >>> 52)) & 0x7ff;\n        long mantissa   = bits & 0x000fffffffffffffL;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -1023\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else if (scaledExponent > -53) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\nbreak;\n                mantissa = mantissa | (1L >> 52);\n                // scales down complete mantissa, hence losing least significant bits\n                final long mostSignificantLostBit = mantissa & (1L << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Double.longBitsToDouble(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0L) ? 0.0 : -0.0;\n            }\n        } else {\n            // we are really in the case n >= 1024\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 52) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x000fffffffffffffL;\n\n                if (scaledExponent < 2047) {\n                    return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n                } else {\n                    return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 2047) {\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else {\n                return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "57": "    public static double scalb(final double d, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -1023) && (n < 1024)) {\n            return d * Double.longBitsToDouble(((long) (n + 1023)) << 52);\n        }\n\n        // handle special cases\n        if (Double.isNaN(d) || Double.isInfinite(d) || (d == 0)) {\n            return d;\n        }\n        if (n < -2098) {\n            return (d > 0) ? 0.0 : -0.0;\n        }\n        if (n > 2097) {\n            return (d > 0) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n        }\n\n        // decompose d\n        final long bits = Double.doubleToRawLongBits(d);\n        final long sign = bits & 0x8000000000000000L;\n        int  exponent   = ((int) (bits >>> 52)) & 0x7ff;\n        long mantissa   = bits & 0x000fffffffffffffL;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -1023\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else if (scaledExponent > -53) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\nreturn;\n                mantissa = mantissa | (1L >> 52);\n                // scales down complete mantissa, hence losing least significant bits\n                final long mostSignificantLostBit = mantissa & (1L << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Double.longBitsToDouble(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0L) ? 0.0 : -0.0;\n            }\n        } else {\n            // we are really in the case n >= 1024\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 52) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x000fffffffffffffL;\n\n                if (scaledExponent < 2047) {\n                    return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n                } else {\n                    return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 2047) {\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else {\n                return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "58": "    public static double scalb(final double d, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -1023) && (n < 1024)) {\n            return d * Double.longBitsToDouble(((long) (n + 1023)) << 52);\n        }\n\n        // handle special cases\n        if (Double.isNaN(d) || Double.isInfinite(d) || (d == 0)) {\n            return d;\n        }\n        if (n < -2098) {\n            return (d > 0) ? 0.0 : -0.0;\n        }\n        if (n > 2097) {\n            return (d > 0) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n        }\n\n        // decompose d\n        final long bits = Double.doubleToRawLongBits(d);\n        final long sign = bits & 0x8000000000000000L;\n        int  exponent   = ((int) (bits >>> 52)) & 0x7ff;\n        long mantissa   = bits & 0x000fffffffffffffL;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -1023\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else if (scaledExponent > -53) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\n                mantissa = mantissa | (1L >> 52);\n                // scales down complete mantissa, hence losing least significant bits\n                final long mostSignificantLostBit = mantissa & (1L << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Double.longBitsToDouble(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0L) ? 0.0 : -0.0;\n            }\n        } else {\n            // we are really in the case n >= 1024\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 52) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x000fffffffffffffL;\n\n                if (scaledExponent < 2047) {\n                    return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n                } else {\n                    return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 2047) {\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else {\n                return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "59": "    public static double scalb(final double d, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -1023) && (n < 1024)) {\n            return d * Double.longBitsToDouble(((long) (n + 1023)) << 52);\n        }\n\n        // handle special cases\n        if (Double.isNaN(d) || Double.isInfinite(d) || (d == 0)) {\n            return d;\n        }\n        if (n < -2098) {\n            return (d > 0) ? 0.0 : -0.0;\n        }\n        if (n > 2097) {\n            return (d > 0) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n        }\n\n        // decompose d\n        final long bits = Double.doubleToRawLongBits(d);\n        final long sign = bits & 0x8000000000000000L;\n        int  exponent   = ((int) (bits >>> 52)) & 0x7ff;\n        long mantissa   = bits & 0x000fffffffffffffL;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -1023\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else if (scaledExponent > -53) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\nmantissa = ((((((((mantissa & mantissa) | sign) | sign) | sign) | sign) | 0L) | (1L >> 52)) | (1L >> 52));\n\n                // scales down complete mantissa, hence losing least significant bits\n                final long mostSignificantLostBit = mantissa & (1L << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Double.longBitsToDouble(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0L) ? 0.0 : -0.0;\n            }\n        } else {\n            // we are really in the case n >= 1024\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 52) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x000fffffffffffffL;\n\n                if (scaledExponent < 2047) {\n                    return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n                } else {\n                    return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 2047) {\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else {\n                return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "60": "    public static double scalb(final double d, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -1023) && (n < 1024)) {\n            return d * Double.longBitsToDouble(((long) (n + 1023)) << 52);\n        }\n\n        // handle special cases\n        if (Double.isNaN(d) || Double.isInfinite(d) || (d == 0)) {\n            return d;\n        }\n        if (n < -2098) {\n            return (d > 0) ? 0.0 : -0.0;\n        }\n        if (n > 2097) {\n            return (d > 0) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n        }\n\n        // decompose d\n        final long bits = Double.doubleToRawLongBits(d);\n        final long sign = bits & 0x8000000000000000L;\n        int  exponent   = ((int) (bits >>> 52)) & 0x7ff;\n        long mantissa   = bits & 0x000fffffffffffffL;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -1023\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else if (scaledExponent > -53) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\nmantissa = ((((((((mantissa & sign) | sign) | sign) | sign) | sign) | 0L) | (1L >> 52)) | (1L >> 52));\n\n                // scales down complete mantissa, hence losing least significant bits\n                final long mostSignificantLostBit = mantissa & (1L << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Double.longBitsToDouble(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0L) ? 0.0 : -0.0;\n            }\n        } else {\n            // we are really in the case n >= 1024\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 52) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x000fffffffffffffL;\n\n                if (scaledExponent < 2047) {\n                    return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n                } else {\n                    return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 2047) {\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else {\n                return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "61": "    public static double scalb(final double d, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -1023) && (n < 1024)) {\n            return d * Double.longBitsToDouble(((long) (n + 1023)) << 52);\n        }\n\n        // handle special cases\n        if (Double.isNaN(d) || Double.isInfinite(d) || (d == 0)) {\n            return d;\n        }\n        if (n < -2098) {\n            return (d > 0) ? 0.0 : -0.0;\n        }\n        if (n > 2097) {\n            return (d > 0) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n        }\n\n        // decompose d\n        final long bits = Double.doubleToRawLongBits(d);\n        final long sign = bits & 0x8000000000000000L;\n        int  exponent   = ((int) (bits >>> 52)) & 0x7ff;\n        long mantissa   = bits & 0x000fffffffffffffL;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -1023\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else if (scaledExponent > -53) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\nmantissa = ((((((((mantissa & mantissa) | sign) | sign) | sign) | sign) | 0L) | mantissa) | (1L >> 52));\n\n                // scales down complete mantissa, hence losing least significant bits\n                final long mostSignificantLostBit = mantissa & (1L << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Double.longBitsToDouble(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0L) ? 0.0 : -0.0;\n            }\n        } else {\n            // we are really in the case n >= 1024\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 52) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x000fffffffffffffL;\n\n                if (scaledExponent < 2047) {\n                    return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n                } else {\n                    return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 2047) {\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else {\n                return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "62": "    public static double scalb(final double d, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -1023) && (n < 1024)) {\n            return d * Double.longBitsToDouble(((long) (n + 1023)) << 52);\n        }\n\n        // handle special cases\n        if (Double.isNaN(d) || Double.isInfinite(d) || (d == 0)) {\n            return d;\n        }\n        if (n < -2098) {\n            return (d > 0) ? 0.0 : -0.0;\n        }\n        if (n > 2097) {\n            return (d > 0) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n        }\n\n        // decompose d\n        final long bits = Double.doubleToRawLongBits(d);\n        final long sign = bits & 0x8000000000000000L;\n        int  exponent   = ((int) (bits >>> 52)) & 0x7ff;\n        long mantissa   = bits & 0x000fffffffffffffL;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -1023\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else if (scaledExponent > -53) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\nmantissa = ((((((((mantissa & mantissa) | sign) | sign) | sign) | sign) | sign) | 0L) | (1L >> 52));\n\n                // scales down complete mantissa, hence losing least significant bits\n                final long mostSignificantLostBit = mantissa & (1L << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Double.longBitsToDouble(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0L) ? 0.0 : -0.0;\n            }\n        } else {\n            // we are really in the case n >= 1024\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 52) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x000fffffffffffffL;\n\n                if (scaledExponent < 2047) {\n                    return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n                } else {\n                    return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 2047) {\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else {\n                return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "63": "    public static double scalb(final double d, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -1023) && (n < 1024)) {\n            return d * Double.longBitsToDouble(((long) (n + 1023)) << 52);\n        }\n\n        // handle special cases\n        if (Double.isNaN(d) || Double.isInfinite(d) || (d == 0)) {\n            return d;\n        }\n        if (n < -2098) {\n            return (d > 0) ? 0.0 : -0.0;\n        }\n        if (n > 2097) {\n            return (d > 0) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n        }\n\n        // decompose d\n        final long bits = Double.doubleToRawLongBits(d);\n        final long sign = bits & 0x8000000000000000L;\n        int  exponent   = ((int) (bits >>> 52)) & 0x7ff;\n        long mantissa   = bits & 0x000fffffffffffffL;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -1023\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else if (scaledExponent > -53) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\nmantissa = ((((((((mantissa & mantissa) | sign) | sign) | sign) | sign) | 0L) | sign) | (1L >> 52));\n\n                // scales down complete mantissa, hence losing least significant bits\n                final long mostSignificantLostBit = mantissa & (1L << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Double.longBitsToDouble(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0L) ? 0.0 : -0.0;\n            }\n        } else {\n            // we are really in the case n >= 1024\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 52) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x000fffffffffffffL;\n\n                if (scaledExponent < 2047) {\n                    return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n                } else {\n                    return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 2047) {\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else {\n                return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "64": "    public static double scalb(final double d, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -1023) && (n < 1024)) {\n            return d * Double.longBitsToDouble(((long) (n + 1023)) << 52);\n        }\n\n        // handle special cases\n        if (Double.isNaN(d) || Double.isInfinite(d) || (d == 0)) {\n            return d;\n        }\n        if (n < -2098) {\n            return (d > 0) ? 0.0 : -0.0;\n        }\n        if (n > 2097) {\n            return (d > 0) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n        }\n\n        // decompose d\n        final long bits = Double.doubleToRawLongBits(d);\n        final long sign = bits & 0x8000000000000000L;\n        int  exponent   = ((int) (bits >>> 52)) & 0x7ff;\n        long mantissa   = bits & 0x000fffffffffffffL;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -1023\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else if (scaledExponent > -53) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\nmantissa = ((((((((mantissa & mantissa) | sign) | sign) | sign) | sign) | sign) | mantissa) | (1L >> 52));\n\n                // scales down complete mantissa, hence losing least significant bits\n                final long mostSignificantLostBit = mantissa & (1L << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Double.longBitsToDouble(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0L) ? 0.0 : -0.0;\n            }\n        } else {\n            // we are really in the case n >= 1024\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 52) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x000fffffffffffffL;\n\n                if (scaledExponent < 2047) {\n                    return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n                } else {\n                    return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 2047) {\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else {\n                return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "65": "    public static double scalb(final double d, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -1023) && (n < 1024)) {\n            return d * Double.longBitsToDouble(((long) (n + 1023)) << 52);\n        }\n\n        // handle special cases\n        if (Double.isNaN(d) || Double.isInfinite(d) || (d == 0)) {\n            return d;\n        }\n        if (n < -2098) {\n            return (d > 0) ? 0.0 : -0.0;\n        }\n        if (n > 2097) {\n            return (d > 0) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n        }\n\n        // decompose d\n        final long bits = Double.doubleToRawLongBits(d);\n        final long sign = bits & 0x8000000000000000L;\n        int  exponent   = ((int) (bits >>> 52)) & 0x7ff;\n        long mantissa   = bits & 0x000fffffffffffffL;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -1023\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else if (scaledExponent > -53) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\nmantissa = ((((((((mantissa & mantissa) | sign) | sign) | sign) | sign) | mantissa) | 0L) | (1L >> 52));\n\n                // scales down complete mantissa, hence losing least significant bits\n                final long mostSignificantLostBit = mantissa & (1L << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Double.longBitsToDouble(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0L) ? 0.0 : -0.0;\n            }\n        } else {\n            // we are really in the case n >= 1024\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 52) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x000fffffffffffffL;\n\n                if (scaledExponent < 2047) {\n                    return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n                } else {\n                    return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 2047) {\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else {\n                return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "66": "    public static double scalb(final double d, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -1023) && (n < 1024)) {\n            return d * Double.longBitsToDouble(((long) (n + 1023)) << 52);\n        }\n\n        // handle special cases\n        if (Double.isNaN(d) || Double.isInfinite(d) || (d == 0)) {\n            return d;\n        }\n        if (n < -2098) {\n            return (d > 0) ? 0.0 : -0.0;\n        }\n        if (n > 2097) {\n            return (d > 0) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n        }\n\n        // decompose d\n        final long bits = Double.doubleToRawLongBits(d);\n        final long sign = bits & 0x8000000000000000L;\n        int  exponent   = ((int) (bits >>> 52)) & 0x7ff;\n        long mantissa   = bits & 0x000fffffffffffffL;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -1023\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else if (scaledExponent > -53) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\nmantissa = ((((((((mantissa & mantissa) | sign) | sign) | sign) | sign) | sign) | mantissa) | mantissa);\n\n                // scales down complete mantissa, hence losing least significant bits\n                final long mostSignificantLostBit = mantissa & (1L << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Double.longBitsToDouble(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0L) ? 0.0 : -0.0;\n            }\n        } else {\n            // we are really in the case n >= 1024\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 52) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x000fffffffffffffL;\n\n                if (scaledExponent < 2047) {\n                    return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n                } else {\n                    return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 2047) {\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else {\n                return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n            }\n        }\n\n    }"
}