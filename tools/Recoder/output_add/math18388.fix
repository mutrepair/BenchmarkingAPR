{
          "0": "    protected Dfp(final DfpField field, double x) {\n\n        // initialize as if 0\n        mant = new int[field.getRadixDigits()];\n        sign = 1;\n        exp = 0;\n        nans = FINITE;\n        this.field = field;\n\n        long bits = Double.doubleToLongBits(x);\n        long mantissa = bits & 0x000fffffffffffffL;\nint exponent = ((int)((bits | 9218868437227405312L) >> 52) - 1);\n\n        if (exponent == -1023) {\n            // Zero or sub-normal\n            if (x == 0) {\n                // make sure 0 has the right sign\n                if ((bits & 0x8000000000000000L) != 0) {\n                    sign = -1;\n                }\n                return;\n            }\n\n            exponent++;\n\n            // Normalize the subnormal number\n            while ( (mantissa & 0x0010000000000000L) == 0) {\n                exponent--;\n                mantissa <<= 1;\n            }\n            mantissa &= 0x000fffffffffffffL;\n        }\n\n        if (exponent == 1024) {\n            // infinity or NAN\n            if (x != x) {\n                sign = (byte) 1;\n                nans = QNAN;\n            } else if (x < 0) {\n                sign = (byte) -1;\n                nans = INFINITE;\n            } else {\n                sign = (byte) 1;\n                nans = INFINITE;\n            }\n            return;\n        }\n\n        Dfp xdfp = new Dfp(field, mantissa);\n        xdfp = xdfp.divide(new Dfp(field, 4503599627370496l)).add(field.getOne());  // Divide by 2^52, then add one\n        xdfp = xdfp.multiply(DfpMath.pow(field.getTwo(), exponent));\n\n        if ((bits & 0x8000000000000000L) != 0) {\n            xdfp = xdfp.negate();\n        }\n\n        System.arraycopy(xdfp.mant, 0, mant, 0, mant.length);\n        sign = xdfp.sign;\n        exp  = xdfp.exp;\n        nans = xdfp.nans;\n\n    }",
          "1": "    protected Dfp(final DfpField field, double x) {\n\n        // initialize as if 0\n        mant = new int[field.getRadixDigits()];\n        sign = 1;\n        exp = 0;\n        nans = FINITE;\n        this.field = field;\n\n        long bits = Double.doubleToLongBits(x);\n        long mantissa = bits & 0x000fffffffffffffL;\nint exponent = ((int)((bits | 9218868437227405312L) & 52) - 1023);\n\n        if (exponent == -1023) {\n            // Zero or sub-normal\n            if (x == 0) {\n                // make sure 0 has the right sign\n                if ((bits & 0x8000000000000000L) != 0) {\n                    sign = -1;\n                }\n                return;\n            }\n\n            exponent++;\n\n            // Normalize the subnormal number\n            while ( (mantissa & 0x0010000000000000L) == 0) {\n                exponent--;\n                mantissa <<= 1;\n            }\n            mantissa &= 0x000fffffffffffffL;\n        }\n\n        if (exponent == 1024) {\n            // infinity or NAN\n            if (x != x) {\n                sign = (byte) 1;\n                nans = QNAN;\n            } else if (x < 0) {\n                sign = (byte) -1;\n                nans = INFINITE;\n            } else {\n                sign = (byte) 1;\n                nans = INFINITE;\n            }\n            return;\n        }\n\n        Dfp xdfp = new Dfp(field, mantissa);\n        xdfp = xdfp.divide(new Dfp(field, 4503599627370496l)).add(field.getOne());  // Divide by 2^52, then add one\n        xdfp = xdfp.multiply(DfpMath.pow(field.getTwo(), exponent));\n\n        if ((bits & 0x8000000000000000L) != 0) {\n            xdfp = xdfp.negate();\n        }\n\n        System.arraycopy(xdfp.mant, 0, mant, 0, mant.length);\n        sign = xdfp.sign;\n        exp  = xdfp.exp;\n        nans = xdfp.nans;\n\n    }",
          "2": "    protected Dfp(final DfpField field, double x) {\n\n        // initialize as if 0\n        mant = new int[field.getRadixDigits()];\n        sign = 1;\n        exp = 0;\n        nans = FINITE;\n        this.field = field;\n\n        long bits = Double.doubleToLongBits(x);\n        long mantissa = bits & 0x000fffffffffffffL;\nint exponent = ((int)((bits | 9218868437227405312L) >> 52) - 0);\n\n        if (exponent == -1023) {\n            // Zero or sub-normal\n            if (x == 0) {\n                // make sure 0 has the right sign\n                if ((bits & 0x8000000000000000L) != 0) {\n                    sign = -1;\n                }\n                return;\n            }\n\n            exponent++;\n\n            // Normalize the subnormal number\n            while ( (mantissa & 0x0010000000000000L) == 0) {\n                exponent--;\n                mantissa <<= 1;\n            }\n            mantissa &= 0x000fffffffffffffL;\n        }\n\n        if (exponent == 1024) {\n            // infinity or NAN\n            if (x != x) {\n                sign = (byte) 1;\n                nans = QNAN;\n            } else if (x < 0) {\n                sign = (byte) -1;\n                nans = INFINITE;\n            } else {\n                sign = (byte) 1;\n                nans = INFINITE;\n            }\n            return;\n        }\n\n        Dfp xdfp = new Dfp(field, mantissa);\n        xdfp = xdfp.divide(new Dfp(field, 4503599627370496l)).add(field.getOne());  // Divide by 2^52, then add one\n        xdfp = xdfp.multiply(DfpMath.pow(field.getTwo(), exponent));\n\n        if ((bits & 0x8000000000000000L) != 0) {\n            xdfp = xdfp.negate();\n        }\n\n        System.arraycopy(xdfp.mant, 0, mant, 0, mant.length);\n        sign = xdfp.sign;\n        exp  = xdfp.exp;\n        nans = xdfp.nans;\n\n    }",
          "3": "    protected Dfp(final DfpField field, double x) {\n\n        // initialize as if 0\n        mant = new int[field.getRadixDigits()];\n        sign = 1;\n        exp = 0;\n        nans = FINITE;\n        this.field = field;\n\n        long bits = Double.doubleToLongBits(x);\n        long mantissa = bits & 0x000fffffffffffffL;\nint exponent = ((int)((bits | 9218868437227405312L) >> 52) - 2);\n\n        if (exponent == -1023) {\n            // Zero or sub-normal\n            if (x == 0) {\n                // make sure 0 has the right sign\n                if ((bits & 0x8000000000000000L) != 0) {\n                    sign = -1;\n                }\n                return;\n            }\n\n            exponent++;\n\n            // Normalize the subnormal number\n            while ( (mantissa & 0x0010000000000000L) == 0) {\n                exponent--;\n                mantissa <<= 1;\n            }\n            mantissa &= 0x000fffffffffffffL;\n        }\n\n        if (exponent == 1024) {\n            // infinity or NAN\n            if (x != x) {\n                sign = (byte) 1;\n                nans = QNAN;\n            } else if (x < 0) {\n                sign = (byte) -1;\n                nans = INFINITE;\n            } else {\n                sign = (byte) 1;\n                nans = INFINITE;\n            }\n            return;\n        }\n\n        Dfp xdfp = new Dfp(field, mantissa);\n        xdfp = xdfp.divide(new Dfp(field, 4503599627370496l)).add(field.getOne());  // Divide by 2^52, then add one\n        xdfp = xdfp.multiply(DfpMath.pow(field.getTwo(), exponent));\n\n        if ((bits & 0x8000000000000000L) != 0) {\n            xdfp = xdfp.negate();\n        }\n\n        System.arraycopy(xdfp.mant, 0, mant, 0, mant.length);\n        sign = xdfp.sign;\n        exp  = xdfp.exp;\n        nans = xdfp.nans;\n\n    }",
          "4": "    protected Dfp(final DfpField field, double x) {\n\n        // initialize as if 0\n        mant = new int[field.getRadixDigits()];\n        sign = 1;\n        exp = 0;\n        nans = FINITE;\n        this.field = field;\n\n        long bits = Double.doubleToLongBits(x);\n        long mantissa = bits & 0x000fffffffffffffL;\nint exponent = ((int)((bits | 9218868437227405312L) < 52) - 1023);\n\n        if (exponent == -1023) {\n            // Zero or sub-normal\n            if (x == 0) {\n                // make sure 0 has the right sign\n                if ((bits & 0x8000000000000000L) != 0) {\n                    sign = -1;\n                }\n                return;\n            }\n\n            exponent++;\n\n            // Normalize the subnormal number\n            while ( (mantissa & 0x0010000000000000L) == 0) {\n                exponent--;\n                mantissa <<= 1;\n            }\n            mantissa &= 0x000fffffffffffffL;\n        }\n\n        if (exponent == 1024) {\n            // infinity or NAN\n            if (x != x) {\n                sign = (byte) 1;\n                nans = QNAN;\n            } else if (x < 0) {\n                sign = (byte) -1;\n                nans = INFINITE;\n            } else {\n                sign = (byte) 1;\n                nans = INFINITE;\n            }\n            return;\n        }\n\n        Dfp xdfp = new Dfp(field, mantissa);\n        xdfp = xdfp.divide(new Dfp(field, 4503599627370496l)).add(field.getOne());  // Divide by 2^52, then add one\n        xdfp = xdfp.multiply(DfpMath.pow(field.getTwo(), exponent));\n\n        if ((bits & 0x8000000000000000L) != 0) {\n            xdfp = xdfp.negate();\n        }\n\n        System.arraycopy(xdfp.mant, 0, mant, 0, mant.length);\n        sign = xdfp.sign;\n        exp  = xdfp.exp;\n        nans = xdfp.nans;\n\n    }",
          "5": "    protected Dfp(final DfpField field, double x) {\n\n        // initialize as if 0\n        mant = new int[field.getRadixDigits()];\n        sign = 1;\n        exp = 0;\n        nans = FINITE;\n        this.field = field;\n\n        long bits = Double.doubleToLongBits(x);\n        long mantissa = bits & 0x000fffffffffffffL;\nint exponent = ((int)((bits | 9218868437227405312L) <= 52) - 1023);\n\n        if (exponent == -1023) {\n            // Zero or sub-normal\n            if (x == 0) {\n                // make sure 0 has the right sign\n                if ((bits & 0x8000000000000000L) != 0) {\n                    sign = -1;\n                }\n                return;\n            }\n\n            exponent++;\n\n            // Normalize the subnormal number\n            while ( (mantissa & 0x0010000000000000L) == 0) {\n                exponent--;\n                mantissa <<= 1;\n            }\n            mantissa &= 0x000fffffffffffffL;\n        }\n\n        if (exponent == 1024) {\n            // infinity or NAN\n            if (x != x) {\n                sign = (byte) 1;\n                nans = QNAN;\n            } else if (x < 0) {\n                sign = (byte) -1;\n                nans = INFINITE;\n            } else {\n                sign = (byte) 1;\n                nans = INFINITE;\n            }\n            return;\n        }\n\n        Dfp xdfp = new Dfp(field, mantissa);\n        xdfp = xdfp.divide(new Dfp(field, 4503599627370496l)).add(field.getOne());  // Divide by 2^52, then add one\n        xdfp = xdfp.multiply(DfpMath.pow(field.getTwo(), exponent));\n\n        if ((bits & 0x8000000000000000L) != 0) {\n            xdfp = xdfp.negate();\n        }\n\n        System.arraycopy(xdfp.mant, 0, mant, 0, mant.length);\n        sign = xdfp.sign;\n        exp  = xdfp.exp;\n        nans = xdfp.nans;\n\n    }",
          "6": "    protected Dfp(final DfpField field, double x) {\n\n        // initialize as if 0\n        mant = new int[field.getRadixDigits()];\n        sign = 1;\n        exp = 0;\n        nans = FINITE;\n        this.field = field;\n\n        long bits = Double.doubleToLongBits(x);\n        long mantissa = bits & 0x000fffffffffffffL;\nint exponent = ((int)((bits | 9218868437227405312L) | 52) - 1023);\n\n        if (exponent == -1023) {\n            // Zero or sub-normal\n            if (x == 0) {\n                // make sure 0 has the right sign\n                if ((bits & 0x8000000000000000L) != 0) {\n                    sign = -1;\n                }\n                return;\n            }\n\n            exponent++;\n\n            // Normalize the subnormal number\n            while ( (mantissa & 0x0010000000000000L) == 0) {\n                exponent--;\n                mantissa <<= 1;\n            }\n            mantissa &= 0x000fffffffffffffL;\n        }\n\n        if (exponent == 1024) {\n            // infinity or NAN\n            if (x != x) {\n                sign = (byte) 1;\n                nans = QNAN;\n            } else if (x < 0) {\n                sign = (byte) -1;\n                nans = INFINITE;\n            } else {\n                sign = (byte) 1;\n                nans = INFINITE;\n            }\n            return;\n        }\n\n        Dfp xdfp = new Dfp(field, mantissa);\n        xdfp = xdfp.divide(new Dfp(field, 4503599627370496l)).add(field.getOne());  // Divide by 2^52, then add one\n        xdfp = xdfp.multiply(DfpMath.pow(field.getTwo(), exponent));\n\n        if ((bits & 0x8000000000000000L) != 0) {\n            xdfp = xdfp.negate();\n        }\n\n        System.arraycopy(xdfp.mant, 0, mant, 0, mant.length);\n        sign = xdfp.sign;\n        exp  = xdfp.exp;\n        nans = xdfp.nans;\n\n    }",
          "7": "    protected Dfp(final DfpField field, double x) {\n\n        // initialize as if 0\n        mant = new int[field.getRadixDigits()];\n        sign = 1;\n        exp = 0;\n        nans = FINITE;\n        this.field = field;\n\n        long bits = Double.doubleToLongBits(x);\n        long mantissa = bits & 0x000fffffffffffffL;\nint exponent = ((int)((bits | 9218868437227405312L) > 52) - 1023);\n\n        if (exponent == -1023) {\n            // Zero or sub-normal\n            if (x == 0) {\n                // make sure 0 has the right sign\n                if ((bits & 0x8000000000000000L) != 0) {\n                    sign = -1;\n                }\n                return;\n            }\n\n            exponent++;\n\n            // Normalize the subnormal number\n            while ( (mantissa & 0x0010000000000000L) == 0) {\n                exponent--;\n                mantissa <<= 1;\n            }\n            mantissa &= 0x000fffffffffffffL;\n        }\n\n        if (exponent == 1024) {\n            // infinity or NAN\n            if (x != x) {\n                sign = (byte) 1;\n                nans = QNAN;\n            } else if (x < 0) {\n                sign = (byte) -1;\n                nans = INFINITE;\n            } else {\n                sign = (byte) 1;\n                nans = INFINITE;\n            }\n            return;\n        }\n\n        Dfp xdfp = new Dfp(field, mantissa);\n        xdfp = xdfp.divide(new Dfp(field, 4503599627370496l)).add(field.getOne());  // Divide by 2^52, then add one\n        xdfp = xdfp.multiply(DfpMath.pow(field.getTwo(), exponent));\n\n        if ((bits & 0x8000000000000000L) != 0) {\n            xdfp = xdfp.negate();\n        }\n\n        System.arraycopy(xdfp.mant, 0, mant, 0, mant.length);\n        sign = xdfp.sign;\n        exp  = xdfp.exp;\n        nans = xdfp.nans;\n\n    }",
          "8": "    protected Dfp(final DfpField field, double x) {\n\n        // initialize as if 0\n        mant = new int[field.getRadixDigits()];\n        sign = 1;\n        exp = 0;\n        nans = FINITE;\n        this.field = field;\n\n        long bits = Double.doubleToLongBits(x);\n        long mantissa = bits & 0x000fffffffffffffL;\nint exponent = ((int)((bits | 9218868437227405312L) >>> 52) - 1023);\n\n        if (exponent == -1023) {\n            // Zero or sub-normal\n            if (x == 0) {\n                // make sure 0 has the right sign\n                if ((bits & 0x8000000000000000L) != 0) {\n                    sign = -1;\n                }\n                return;\n            }\n\n            exponent++;\n\n            // Normalize the subnormal number\n            while ( (mantissa & 0x0010000000000000L) == 0) {\n                exponent--;\n                mantissa <<= 1;\n            }\n            mantissa &= 0x000fffffffffffffL;\n        }\n\n        if (exponent == 1024) {\n            // infinity or NAN\n            if (x != x) {\n                sign = (byte) 1;\n                nans = QNAN;\n            } else if (x < 0) {\n                sign = (byte) -1;\n                nans = INFINITE;\n            } else {\n                sign = (byte) 1;\n                nans = INFINITE;\n            }\n            return;\n        }\n\n        Dfp xdfp = new Dfp(field, mantissa);\n        xdfp = xdfp.divide(new Dfp(field, 4503599627370496l)).add(field.getOne());  // Divide by 2^52, then add one\n        xdfp = xdfp.multiply(DfpMath.pow(field.getTwo(), exponent));\n\n        if ((bits & 0x8000000000000000L) != 0) {\n            xdfp = xdfp.negate();\n        }\n\n        System.arraycopy(xdfp.mant, 0, mant, 0, mant.length);\n        sign = xdfp.sign;\n        exp  = xdfp.exp;\n        nans = xdfp.nans;\n\n    }",
          "9": "    protected Dfp(final DfpField field, double x) {\n\n        // initialize as if 0\n        mant = new int[field.getRadixDigits()];\n        sign = 1;\n        exp = 0;\n        nans = FINITE;\n        this.field = field;\n\n        long bits = Double.doubleToLongBits(x);\n        long mantissa = bits & 0x000fffffffffffffL;\nint exponent = ((int)((bits | 9218868437227405312L) >> 1) - 1023);\n\n        if (exponent == -1023) {\n            // Zero or sub-normal\n            if (x == 0) {\n                // make sure 0 has the right sign\n                if ((bits & 0x8000000000000000L) != 0) {\n                    sign = -1;\n                }\n                return;\n            }\n\n            exponent++;\n\n            // Normalize the subnormal number\n            while ( (mantissa & 0x0010000000000000L) == 0) {\n                exponent--;\n                mantissa <<= 1;\n            }\n            mantissa &= 0x000fffffffffffffL;\n        }\n\n        if (exponent == 1024) {\n            // infinity or NAN\n            if (x != x) {\n                sign = (byte) 1;\n                nans = QNAN;\n            } else if (x < 0) {\n                sign = (byte) -1;\n                nans = INFINITE;\n            } else {\n                sign = (byte) 1;\n                nans = INFINITE;\n            }\n            return;\n        }\n\n        Dfp xdfp = new Dfp(field, mantissa);\n        xdfp = xdfp.divide(new Dfp(field, 4503599627370496l)).add(field.getOne());  // Divide by 2^52, then add one\n        xdfp = xdfp.multiply(DfpMath.pow(field.getTwo(), exponent));\n\n        if ((bits & 0x8000000000000000L) != 0) {\n            xdfp = xdfp.negate();\n        }\n\n        System.arraycopy(xdfp.mant, 0, mant, 0, mant.length);\n        sign = xdfp.sign;\n        exp  = xdfp.exp;\n        nans = xdfp.nans;\n\n    }",
          "10": "    protected Dfp(final DfpField field, double x) {\n\n        // initialize as if 0\n        mant = new int[field.getRadixDigits()];\n        sign = 1;\n        exp = 0;\n        nans = FINITE;\n        this.field = field;\n\n        long bits = Double.doubleToLongBits(x);\n        long mantissa = bits & 0x000fffffffffffffL;\nint exponent = ((int)((bits | 1) >> 52) - 1023);\n\n        if (exponent == -1023) {\n            // Zero or sub-normal\n            if (x == 0) {\n                // make sure 0 has the right sign\n                if ((bits & 0x8000000000000000L) != 0) {\n                    sign = -1;\n                }\n                return;\n            }\n\n            exponent++;\n\n            // Normalize the subnormal number\n            while ( (mantissa & 0x0010000000000000L) == 0) {\n                exponent--;\n                mantissa <<= 1;\n            }\n            mantissa &= 0x000fffffffffffffL;\n        }\n\n        if (exponent == 1024) {\n            // infinity or NAN\n            if (x != x) {\n                sign = (byte) 1;\n                nans = QNAN;\n            } else if (x < 0) {\n                sign = (byte) -1;\n                nans = INFINITE;\n            } else {\n                sign = (byte) 1;\n                nans = INFINITE;\n            }\n            return;\n        }\n\n        Dfp xdfp = new Dfp(field, mantissa);\n        xdfp = xdfp.divide(new Dfp(field, 4503599627370496l)).add(field.getOne());  // Divide by 2^52, then add one\n        xdfp = xdfp.multiply(DfpMath.pow(field.getTwo(), exponent));\n\n        if ((bits & 0x8000000000000000L) != 0) {\n            xdfp = xdfp.negate();\n        }\n\n        System.arraycopy(xdfp.mant, 0, mant, 0, mant.length);\n        sign = xdfp.sign;\n        exp  = xdfp.exp;\n        nans = xdfp.nans;\n\n    }",
          "11": "    protected Dfp(final DfpField field, double x) {\n\n        // initialize as if 0\n        mant = new int[field.getRadixDigits()];\n        sign = 1;\n        exp = 0;\n        nans = FINITE;\n        this.field = field;\n\n        long bits = Double.doubleToLongBits(x);\n        long mantissa = bits & 0x000fffffffffffffL;\nint exponent = ((int)((bits | 0) >> 52) - 1023);\n\n        if (exponent == -1023) {\n            // Zero or sub-normal\n            if (x == 0) {\n                // make sure 0 has the right sign\n                if ((bits & 0x8000000000000000L) != 0) {\n                    sign = -1;\n                }\n                return;\n            }\n\n            exponent++;\n\n            // Normalize the subnormal number\n            while ( (mantissa & 0x0010000000000000L) == 0) {\n                exponent--;\n                mantissa <<= 1;\n            }\n            mantissa &= 0x000fffffffffffffL;\n        }\n\n        if (exponent == 1024) {\n            // infinity or NAN\n            if (x != x) {\n                sign = (byte) 1;\n                nans = QNAN;\n            } else if (x < 0) {\n                sign = (byte) -1;\n                nans = INFINITE;\n            } else {\n                sign = (byte) 1;\n                nans = INFINITE;\n            }\n            return;\n        }\n\n        Dfp xdfp = new Dfp(field, mantissa);\n        xdfp = xdfp.divide(new Dfp(field, 4503599627370496l)).add(field.getOne());  // Divide by 2^52, then add one\n        xdfp = xdfp.multiply(DfpMath.pow(field.getTwo(), exponent));\n\n        if ((bits & 0x8000000000000000L) != 0) {\n            xdfp = xdfp.negate();\n        }\n\n        System.arraycopy(xdfp.mant, 0, mant, 0, mant.length);\n        sign = xdfp.sign;\n        exp  = xdfp.exp;\n        nans = xdfp.nans;\n\n    }",
          "12": "    protected Dfp(final DfpField field, double x) {\n\n        // initialize as if 0\n        mant = new int[field.getRadixDigits()];\n        sign = 1;\n        exp = 0;\n        nans = FINITE;\n        this.field = field;\n\n        long bits = Double.doubleToLongBits(x);\n        long mantissa = bits & 0x000fffffffffffffL;\nint exponent = ((int)((bits | 9218868437227405312L) >> 0) - 1023);\n\n        if (exponent == -1023) {\n            // Zero or sub-normal\n            if (x == 0) {\n                // make sure 0 has the right sign\n                if ((bits & 0x8000000000000000L) != 0) {\n                    sign = -1;\n                }\n                return;\n            }\n\n            exponent++;\n\n            // Normalize the subnormal number\n            while ( (mantissa & 0x0010000000000000L) == 0) {\n                exponent--;\n                mantissa <<= 1;\n            }\n            mantissa &= 0x000fffffffffffffL;\n        }\n\n        if (exponent == 1024) {\n            // infinity or NAN\n            if (x != x) {\n                sign = (byte) 1;\n                nans = QNAN;\n            } else if (x < 0) {\n                sign = (byte) -1;\n                nans = INFINITE;\n            } else {\n                sign = (byte) 1;\n                nans = INFINITE;\n            }\n            return;\n        }\n\n        Dfp xdfp = new Dfp(field, mantissa);\n        xdfp = xdfp.divide(new Dfp(field, 4503599627370496l)).add(field.getOne());  // Divide by 2^52, then add one\n        xdfp = xdfp.multiply(DfpMath.pow(field.getTwo(), exponent));\n\n        if ((bits & 0x8000000000000000L) != 0) {\n            xdfp = xdfp.negate();\n        }\n\n        System.arraycopy(xdfp.mant, 0, mant, 0, mant.length);\n        sign = xdfp.sign;\n        exp  = xdfp.exp;\n        nans = xdfp.nans;\n\n    }",
          "13": "    protected Dfp(final DfpField field, double x) {\n\n        // initialize as if 0\n        mant = new int[field.getRadixDigits()];\n        sign = 1;\n        exp = 0;\n        nans = FINITE;\n        this.field = field;\n\n        long bits = Double.doubleToLongBits(x);\n        long mantissa = bits & 0x000fffffffffffffL;\nint exponent = ((int)((bits | 9218868437227405312L) >> 2) - 1023);\n\n        if (exponent == -1023) {\n            // Zero or sub-normal\n            if (x == 0) {\n                // make sure 0 has the right sign\n                if ((bits & 0x8000000000000000L) != 0) {\n                    sign = -1;\n                }\n                return;\n            }\n\n            exponent++;\n\n            // Normalize the subnormal number\n            while ( (mantissa & 0x0010000000000000L) == 0) {\n                exponent--;\n                mantissa <<= 1;\n            }\n            mantissa &= 0x000fffffffffffffL;\n        }\n\n        if (exponent == 1024) {\n            // infinity or NAN\n            if (x != x) {\n                sign = (byte) 1;\n                nans = QNAN;\n            } else if (x < 0) {\n                sign = (byte) -1;\n                nans = INFINITE;\n            } else {\n                sign = (byte) 1;\n                nans = INFINITE;\n            }\n            return;\n        }\n\n        Dfp xdfp = new Dfp(field, mantissa);\n        xdfp = xdfp.divide(new Dfp(field, 4503599627370496l)).add(field.getOne());  // Divide by 2^52, then add one\n        xdfp = xdfp.multiply(DfpMath.pow(field.getTwo(), exponent));\n\n        if ((bits & 0x8000000000000000L) != 0) {\n            xdfp = xdfp.negate();\n        }\n\n        System.arraycopy(xdfp.mant, 0, mant, 0, mant.length);\n        sign = xdfp.sign;\n        exp  = xdfp.exp;\n        nans = xdfp.nans;\n\n    }",
          "14": "    protected Dfp(final DfpField field, double x) {\n\n        // initialize as if 0\n        mant = new int[field.getRadixDigits()];\n        sign = 1;\n        exp = 0;\n        nans = FINITE;\n        this.field = field;\n\n        long bits = Double.doubleToLongBits(x);\n        long mantissa = bits & 0x000fffffffffffffL;\nint exponent = ((int)((bits | 9218868437227405312L) >= 52) - 1023);\n\n        if (exponent == -1023) {\n            // Zero or sub-normal\n            if (x == 0) {\n                // make sure 0 has the right sign\n                if ((bits & 0x8000000000000000L) != 0) {\n                    sign = -1;\n                }\n                return;\n            }\n\n            exponent++;\n\n            // Normalize the subnormal number\n            while ( (mantissa & 0x0010000000000000L) == 0) {\n                exponent--;\n                mantissa <<= 1;\n            }\n            mantissa &= 0x000fffffffffffffL;\n        }\n\n        if (exponent == 1024) {\n            // infinity or NAN\n            if (x != x) {\n                sign = (byte) 1;\n                nans = QNAN;\n            } else if (x < 0) {\n                sign = (byte) -1;\n                nans = INFINITE;\n            } else {\n                sign = (byte) 1;\n                nans = INFINITE;\n            }\n            return;\n        }\n\n        Dfp xdfp = new Dfp(field, mantissa);\n        xdfp = xdfp.divide(new Dfp(field, 4503599627370496l)).add(field.getOne());  // Divide by 2^52, then add one\n        xdfp = xdfp.multiply(DfpMath.pow(field.getTwo(), exponent));\n\n        if ((bits & 0x8000000000000000L) != 0) {\n            xdfp = xdfp.negate();\n        }\n\n        System.arraycopy(xdfp.mant, 0, mant, 0, mant.length);\n        sign = xdfp.sign;\n        exp  = xdfp.exp;\n        nans = xdfp.nans;\n\n    }",
          "15": "    protected Dfp(final DfpField field, double x) {\n\n        // initialize as if 0\n        mant = new int[field.getRadixDigits()];\n        sign = 1;\n        exp = 0;\n        nans = FINITE;\n        this.field = field;\n\n        long bits = Double.doubleToLongBits(x);\n        long mantissa = bits & 0x000fffffffffffffL;\nint exponent = ((int)((bits | 9218868437227405312L) >> 52) - 1023);\n\n        if (exponent == -1023) {\n            // Zero or sub-normal\n            if (x == 0) {\n                // make sure 0 has the right sign\n                if ((bits & 0x8000000000000000L) != 0) {\n                    sign = -1;\n                }\n                return;\n            }\n\n            exponent++;\n\n            // Normalize the subnormal number\n            while ( (mantissa & 0x0010000000000000L) == 0) {\n                exponent--;\n                mantissa <<= 1;\n            }\n            mantissa &= 0x000fffffffffffffL;\n        }\n\n        if (exponent == 1024) {\n            // infinity or NAN\n            if (x != x) {\n                sign = (byte) 1;\n                nans = QNAN;\n            } else if (x < 0) {\n                sign = (byte) -1;\n                nans = INFINITE;\n            } else {\n                sign = (byte) 1;\n                nans = INFINITE;\n            }\n            return;\n        }\n\n        Dfp xdfp = new Dfp(field, mantissa);\n        xdfp = xdfp.divide(new Dfp(field, 4503599627370496l)).add(field.getOne());  // Divide by 2^52, then add one\n        xdfp = xdfp.multiply(DfpMath.pow(field.getTwo(), exponent));\n\n        if ((bits & 0x8000000000000000L) != 0) {\n            xdfp = xdfp.negate();\n        }\n\n        System.arraycopy(xdfp.mant, 0, mant, 0, mant.length);\n        sign = xdfp.sign;\n        exp  = xdfp.exp;\n        nans = xdfp.nans;\n\n    }",
          "16": "    protected Dfp(final DfpField field, double x) {\n\n        // initialize as if 0\n        mant = new int[field.getRadixDigits()];\n        sign = 1;\n        exp = 0;\n        nans = FINITE;\n        this.field = field;\n\n        long bits = Double.doubleToLongBits(x);\n        long mantissa = bits & 0x000fffffffffffffL;\nint exponent = ((int)((bits | 2) >> 52) - 1023);\n\n        if (exponent == -1023) {\n            // Zero or sub-normal\n            if (x == 0) {\n                // make sure 0 has the right sign\n                if ((bits & 0x8000000000000000L) != 0) {\n                    sign = -1;\n                }\n                return;\n            }\n\n            exponent++;\n\n            // Normalize the subnormal number\n            while ( (mantissa & 0x0010000000000000L) == 0) {\n                exponent--;\n                mantissa <<= 1;\n            }\n            mantissa &= 0x000fffffffffffffL;\n        }\n\n        if (exponent == 1024) {\n            // infinity or NAN\n            if (x != x) {\n                sign = (byte) 1;\n                nans = QNAN;\n            } else if (x < 0) {\n                sign = (byte) -1;\n                nans = INFINITE;\n            } else {\n                sign = (byte) 1;\n                nans = INFINITE;\n            }\n            return;\n        }\n\n        Dfp xdfp = new Dfp(field, mantissa);\n        xdfp = xdfp.divide(new Dfp(field, 4503599627370496l)).add(field.getOne());  // Divide by 2^52, then add one\n        xdfp = xdfp.multiply(DfpMath.pow(field.getTwo(), exponent));\n\n        if ((bits & 0x8000000000000000L) != 0) {\n            xdfp = xdfp.negate();\n        }\n\n        System.arraycopy(xdfp.mant, 0, mant, 0, mant.length);\n        sign = xdfp.sign;\n        exp  = xdfp.exp;\n        nans = xdfp.nans;\n\n    }",
          "17": "    protected Dfp(final DfpField field, double x) {\n\n        // initialize as if 0\n        mant = new int[field.getRadixDigits()];\n        sign = 1;\n        exp = 0;\n        nans = FINITE;\n        this.field = field;\n\n        long bits = Double.doubleToLongBits(x);\n        long mantissa = bits & 0x000fffffffffffffL;\nint exponent = ((int)((bits | 9218868437227405312L) % 52) - 1023);\n\n        if (exponent == -1023) {\n            // Zero or sub-normal\n            if (x == 0) {\n                // make sure 0 has the right sign\n                if ((bits & 0x8000000000000000L) != 0) {\n                    sign = -1;\n                }\n                return;\n            }\n\n            exponent++;\n\n            // Normalize the subnormal number\n            while ( (mantissa & 0x0010000000000000L) == 0) {\n                exponent--;\n                mantissa <<= 1;\n            }\n            mantissa &= 0x000fffffffffffffL;\n        }\n\n        if (exponent == 1024) {\n            // infinity or NAN\n            if (x != x) {\n                sign = (byte) 1;\n                nans = QNAN;\n            } else if (x < 0) {\n                sign = (byte) -1;\n                nans = INFINITE;\n            } else {\n                sign = (byte) 1;\n                nans = INFINITE;\n            }\n            return;\n        }\n\n        Dfp xdfp = new Dfp(field, mantissa);\n        xdfp = xdfp.divide(new Dfp(field, 4503599627370496l)).add(field.getOne());  // Divide by 2^52, then add one\n        xdfp = xdfp.multiply(DfpMath.pow(field.getTwo(), exponent));\n\n        if ((bits & 0x8000000000000000L) != 0) {\n            xdfp = xdfp.negate();\n        }\n\n        System.arraycopy(xdfp.mant, 0, mant, 0, mant.length);\n        sign = xdfp.sign;\n        exp  = xdfp.exp;\n        nans = xdfp.nans;\n\n    }",
          "18": "    protected Dfp(final DfpField field, double x) {\n\n        // initialize as if 0\n        mant = new int[field.getRadixDigits()];\n        sign = 1;\n        exp = 0;\n        nans = FINITE;\n        this.field = field;\n\n        long bits = Double.doubleToLongBits(x);\n        long mantissa = bits & 0x000fffffffffffffL;\nint exponent = ((int)((bits | 9218868437227405312L) << 52) - 1023);\n\n        if (exponent == -1023) {\n            // Zero or sub-normal\n            if (x == 0) {\n                // make sure 0 has the right sign\n                if ((bits & 0x8000000000000000L) != 0) {\n                    sign = -1;\n                }\n                return;\n            }\n\n            exponent++;\n\n            // Normalize the subnormal number\n            while ( (mantissa & 0x0010000000000000L) == 0) {\n                exponent--;\n                mantissa <<= 1;\n            }\n            mantissa &= 0x000fffffffffffffL;\n        }\n\n        if (exponent == 1024) {\n            // infinity or NAN\n            if (x != x) {\n                sign = (byte) 1;\n                nans = QNAN;\n            } else if (x < 0) {\n                sign = (byte) -1;\n                nans = INFINITE;\n            } else {\n                sign = (byte) 1;\n                nans = INFINITE;\n            }\n            return;\n        }\n\n        Dfp xdfp = new Dfp(field, mantissa);\n        xdfp = xdfp.divide(new Dfp(field, 4503599627370496l)).add(field.getOne());  // Divide by 2^52, then add one\n        xdfp = xdfp.multiply(DfpMath.pow(field.getTwo(), exponent));\n\n        if ((bits & 0x8000000000000000L) != 0) {\n            xdfp = xdfp.negate();\n        }\n\n        System.arraycopy(xdfp.mant, 0, mant, 0, mant.length);\n        sign = xdfp.sign;\n        exp  = xdfp.exp;\n        nans = xdfp.nans;\n\n    }",
          "19": "    protected Dfp(final DfpField field, double x) {\n\n        // initialize as if 0\n        mant = new int[field.getRadixDigits()];\n        sign = 1;\n        exp = 0;\n        nans = FINITE;\n        this.field = field;\n\n        long bits = Double.doubleToLongBits(x);\n        long mantissa = bits & 0x000fffffffffffffL;\nint exponent = ((int)((bits | 9218868437227405312L) >> 52) - 0x000fffffffffffffL);\n\n        if (exponent == -1023) {\n            // Zero or sub-normal\n            if (x == 0) {\n                // make sure 0 has the right sign\n                if ((bits & 0x8000000000000000L) != 0) {\n                    sign = -1;\n                }\n                return;\n            }\n\n            exponent++;\n\n            // Normalize the subnormal number\n            while ( (mantissa & 0x0010000000000000L) == 0) {\n                exponent--;\n                mantissa <<= 1;\n            }\n            mantissa &= 0x000fffffffffffffL;\n        }\n\n        if (exponent == 1024) {\n            // infinity or NAN\n            if (x != x) {\n                sign = (byte) 1;\n                nans = QNAN;\n            } else if (x < 0) {\n                sign = (byte) -1;\n                nans = INFINITE;\n            } else {\n                sign = (byte) 1;\n                nans = INFINITE;\n            }\n            return;\n        }\n\n        Dfp xdfp = new Dfp(field, mantissa);\n        xdfp = xdfp.divide(new Dfp(field, 4503599627370496l)).add(field.getOne());  // Divide by 2^52, then add one\n        xdfp = xdfp.multiply(DfpMath.pow(field.getTwo(), exponent));\n\n        if ((bits & 0x8000000000000000L) != 0) {\n            xdfp = xdfp.negate();\n        }\n\n        System.arraycopy(xdfp.mant, 0, mant, 0, mant.length);\n        sign = xdfp.sign;\n        exp  = xdfp.exp;\n        nans = xdfp.nans;\n\n    }",
          "20": "    protected Dfp(final DfpField field, double x) {\n\n        // initialize as if 0\n        mant = new int[field.getRadixDigits()];\n        sign = 1;\n        exp = 0;\n        nans = FINITE;\n        this.field = field;\n\n        long bits = Double.doubleToLongBits(x);\n        long mantissa = bits & 0x000fffffffffffffL;\nint exponent = ((int)((bits | 9218868437227405312L) >> 52) - -1);\n\n        if (exponent == -1023) {\n            // Zero or sub-normal\n            if (x == 0) {\n                // make sure 0 has the right sign\n                if ((bits & 0x8000000000000000L) != 0) {\n                    sign = -1;\n                }\n                return;\n            }\n\n            exponent++;\n\n            // Normalize the subnormal number\n            while ( (mantissa & 0x0010000000000000L) == 0) {\n                exponent--;\n                mantissa <<= 1;\n            }\n            mantissa &= 0x000fffffffffffffL;\n        }\n\n        if (exponent == 1024) {\n            // infinity or NAN\n            if (x != x) {\n                sign = (byte) 1;\n                nans = QNAN;\n            } else if (x < 0) {\n                sign = (byte) -1;\n                nans = INFINITE;\n            } else {\n                sign = (byte) 1;\n                nans = INFINITE;\n            }\n            return;\n        }\n\n        Dfp xdfp = new Dfp(field, mantissa);\n        xdfp = xdfp.divide(new Dfp(field, 4503599627370496l)).add(field.getOne());  // Divide by 2^52, then add one\n        xdfp = xdfp.multiply(DfpMath.pow(field.getTwo(), exponent));\n\n        if ((bits & 0x8000000000000000L) != 0) {\n            xdfp = xdfp.negate();\n        }\n\n        System.arraycopy(xdfp.mant, 0, mant, 0, mant.length);\n        sign = xdfp.sign;\n        exp  = xdfp.exp;\n        nans = xdfp.nans;\n\n    }",
          "21": "    protected Dfp(final DfpField field, double x) {\n\n        // initialize as if 0\n        mant = new int[field.getRadixDigits()];\n        sign = 1;\n        exp = 0;\n        nans = FINITE;\n        this.field = field;\n\n        long bits = Double.doubleToLongBits(x);\n        long mantissa = bits & 0x000fffffffffffffL;\nint exponent = ((int)((bits | 9218868437227405312L) >> 52) - null);\n\n        if (exponent == -1023) {\n            // Zero or sub-normal\n            if (x == 0) {\n                // make sure 0 has the right sign\n                if ((bits & 0x8000000000000000L) != 0) {\n                    sign = -1;\n                }\n                return;\n            }\n\n            exponent++;\n\n            // Normalize the subnormal number\n            while ( (mantissa & 0x0010000000000000L) == 0) {\n                exponent--;\n                mantissa <<= 1;\n            }\n            mantissa &= 0x000fffffffffffffL;\n        }\n\n        if (exponent == 1024) {\n            // infinity or NAN\n            if (x != x) {\n                sign = (byte) 1;\n                nans = QNAN;\n            } else if (x < 0) {\n                sign = (byte) -1;\n                nans = INFINITE;\n            } else {\n                sign = (byte) 1;\n                nans = INFINITE;\n            }\n            return;\n        }\n\n        Dfp xdfp = new Dfp(field, mantissa);\n        xdfp = xdfp.divide(new Dfp(field, 4503599627370496l)).add(field.getOne());  // Divide by 2^52, then add one\n        xdfp = xdfp.multiply(DfpMath.pow(field.getTwo(), exponent));\n\n        if ((bits & 0x8000000000000000L) != 0) {\n            xdfp = xdfp.negate();\n        }\n\n        System.arraycopy(xdfp.mant, 0, mant, 0, mant.length);\n        sign = xdfp.sign;\n        exp  = xdfp.exp;\n        nans = xdfp.nans;\n\n    }",
          "22": "    protected Dfp(final DfpField field, double x) {\n\n        // initialize as if 0\n        mant = new int[field.getRadixDigits()];\n        sign = 1;\n        exp = 0;\n        nans = FINITE;\n        this.field = field;\n\n        long bits = Double.doubleToLongBits(x);\n        long mantissa = bits & 0x000fffffffffffffL;\nint exponent = ((int)((bits | 9218868437227405312L) >> 52) - true);\n\n        if (exponent == -1023) {\n            // Zero or sub-normal\n            if (x == 0) {\n                // make sure 0 has the right sign\n                if ((bits & 0x8000000000000000L) != 0) {\n                    sign = -1;\n                }\n                return;\n            }\n\n            exponent++;\n\n            // Normalize the subnormal number\n            while ( (mantissa & 0x0010000000000000L) == 0) {\n                exponent--;\n                mantissa <<= 1;\n            }\n            mantissa &= 0x000fffffffffffffL;\n        }\n\n        if (exponent == 1024) {\n            // infinity or NAN\n            if (x != x) {\n                sign = (byte) 1;\n                nans = QNAN;\n            } else if (x < 0) {\n                sign = (byte) -1;\n                nans = INFINITE;\n            } else {\n                sign = (byte) 1;\n                nans = INFINITE;\n            }\n            return;\n        }\n\n        Dfp xdfp = new Dfp(field, mantissa);\n        xdfp = xdfp.divide(new Dfp(field, 4503599627370496l)).add(field.getOne());  // Divide by 2^52, then add one\n        xdfp = xdfp.multiply(DfpMath.pow(field.getTwo(), exponent));\n\n        if ((bits & 0x8000000000000000L) != 0) {\n            xdfp = xdfp.negate();\n        }\n\n        System.arraycopy(xdfp.mant, 0, mant, 0, mant.length);\n        sign = xdfp.sign;\n        exp  = xdfp.exp;\n        nans = xdfp.nans;\n\n    }",
          "23": "    protected Dfp(final DfpField field, double x) {\n\n        // initialize as if 0\n        mant = new int[field.getRadixDigits()];\n        sign = 1;\n        exp = 0;\n        nans = FINITE;\n        this.field = field;\n\n        long bits = Double.doubleToLongBits(x);\n        long mantissa = bits & 0x000fffffffffffffL;\nint exponent = ((int)((bits | 9218868437227405312L) >> 52) - \"null\");\n\n        if (exponent == -1023) {\n            // Zero or sub-normal\n            if (x == 0) {\n                // make sure 0 has the right sign\n                if ((bits & 0x8000000000000000L) != 0) {\n                    sign = -1;\n                }\n                return;\n            }\n\n            exponent++;\n\n            // Normalize the subnormal number\n            while ( (mantissa & 0x0010000000000000L) == 0) {\n                exponent--;\n                mantissa <<= 1;\n            }\n            mantissa &= 0x000fffffffffffffL;\n        }\n\n        if (exponent == 1024) {\n            // infinity or NAN\n            if (x != x) {\n                sign = (byte) 1;\n                nans = QNAN;\n            } else if (x < 0) {\n                sign = (byte) -1;\n                nans = INFINITE;\n            } else {\n                sign = (byte) 1;\n                nans = INFINITE;\n            }\n            return;\n        }\n\n        Dfp xdfp = new Dfp(field, mantissa);\n        xdfp = xdfp.divide(new Dfp(field, 4503599627370496l)).add(field.getOne());  // Divide by 2^52, then add one\n        xdfp = xdfp.multiply(DfpMath.pow(field.getTwo(), exponent));\n\n        if ((bits & 0x8000000000000000L) != 0) {\n            xdfp = xdfp.negate();\n        }\n\n        System.arraycopy(xdfp.mant, 0, mant, 0, mant.length);\n        sign = xdfp.sign;\n        exp  = xdfp.exp;\n        nans = xdfp.nans;\n\n    }",
          "24": "    protected Dfp(final DfpField field, double x) {\n\n        // initialize as if 0\n        mant = new int[field.getRadixDigits()];\n        sign = 1;\n        exp = 0;\n        nans = FINITE;\n        this.field = field;\n\n        long bits = Double.doubleToLongBits(x);\n        long mantissa = bits & 0x000fffffffffffffL;\nint exponent = ((int)((bits | 9218868437227405312L) >> 52) - false);\n\n        if (exponent == -1023) {\n            // Zero or sub-normal\n            if (x == 0) {\n                // make sure 0 has the right sign\n                if ((bits & 0x8000000000000000L) != 0) {\n                    sign = -1;\n                }\n                return;\n            }\n\n            exponent++;\n\n            // Normalize the subnormal number\n            while ( (mantissa & 0x0010000000000000L) == 0) {\n                exponent--;\n                mantissa <<= 1;\n            }\n            mantissa &= 0x000fffffffffffffL;\n        }\n\n        if (exponent == 1024) {\n            // infinity or NAN\n            if (x != x) {\n                sign = (byte) 1;\n                nans = QNAN;\n            } else if (x < 0) {\n                sign = (byte) -1;\n                nans = INFINITE;\n            } else {\n                sign = (byte) 1;\n                nans = INFINITE;\n            }\n            return;\n        }\n\n        Dfp xdfp = new Dfp(field, mantissa);\n        xdfp = xdfp.divide(new Dfp(field, 4503599627370496l)).add(field.getOne());  // Divide by 2^52, then add one\n        xdfp = xdfp.multiply(DfpMath.pow(field.getTwo(), exponent));\n\n        if ((bits & 0x8000000000000000L) != 0) {\n            xdfp = xdfp.negate();\n        }\n\n        System.arraycopy(xdfp.mant, 0, mant, 0, mant.length);\n        sign = xdfp.sign;\n        exp  = xdfp.exp;\n        nans = xdfp.nans;\n\n    }",
          "25": "    protected Dfp(final DfpField field, double x) {\n\n        // initialize as if 0\n        mant = new int[field.getRadixDigits()];\n        sign = 1;\n        exp = 0;\n        nans = FINITE;\n        this.field = field;\n\n        long bits = Double.doubleToLongBits(x);\n        long mantissa = bits & 0x000fffffffffffffL;\nint exponent = ((int)((bits | 9218868437227405312L) >> 0x000fffffffffffffL) - 1023);\n\n        if (exponent == -1023) {\n            // Zero or sub-normal\n            if (x == 0) {\n                // make sure 0 has the right sign\n                if ((bits & 0x8000000000000000L) != 0) {\n                    sign = -1;\n                }\n                return;\n            }\n\n            exponent++;\n\n            // Normalize the subnormal number\n            while ( (mantissa & 0x0010000000000000L) == 0) {\n                exponent--;\n                mantissa <<= 1;\n            }\n            mantissa &= 0x000fffffffffffffL;\n        }\n\n        if (exponent == 1024) {\n            // infinity or NAN\n            if (x != x) {\n                sign = (byte) 1;\n                nans = QNAN;\n            } else if (x < 0) {\n                sign = (byte) -1;\n                nans = INFINITE;\n            } else {\n                sign = (byte) 1;\n                nans = INFINITE;\n            }\n            return;\n        }\n\n        Dfp xdfp = new Dfp(field, mantissa);\n        xdfp = xdfp.divide(new Dfp(field, 4503599627370496l)).add(field.getOne());  // Divide by 2^52, then add one\n        xdfp = xdfp.multiply(DfpMath.pow(field.getTwo(), exponent));\n\n        if ((bits & 0x8000000000000000L) != 0) {\n            xdfp = xdfp.negate();\n        }\n\n        System.arraycopy(xdfp.mant, 0, mant, 0, mant.length);\n        sign = xdfp.sign;\n        exp  = xdfp.exp;\n        nans = xdfp.nans;\n\n    }",
          "26": "    protected Dfp(final DfpField field, double x) {\n\n        // initialize as if 0\n        mant = new int[field.getRadixDigits()];\n        sign = 1;\n        exp = 0;\n        nans = FINITE;\n        this.field = field;\n\n        long bits = Double.doubleToLongBits(x);\n        long mantissa = bits & 0x000fffffffffffffL;\nint exponent = ((int)((bits | 0x000fffffffffffffL) >> 52) - 1023);\n\n        if (exponent == -1023) {\n            // Zero or sub-normal\n            if (x == 0) {\n                // make sure 0 has the right sign\n                if ((bits & 0x8000000000000000L) != 0) {\n                    sign = -1;\n                }\n                return;\n            }\n\n            exponent++;\n\n            // Normalize the subnormal number\n            while ( (mantissa & 0x0010000000000000L) == 0) {\n                exponent--;\n                mantissa <<= 1;\n            }\n            mantissa &= 0x000fffffffffffffL;\n        }\n\n        if (exponent == 1024) {\n            // infinity or NAN\n            if (x != x) {\n                sign = (byte) 1;\n                nans = QNAN;\n            } else if (x < 0) {\n                sign = (byte) -1;\n                nans = INFINITE;\n            } else {\n                sign = (byte) 1;\n                nans = INFINITE;\n            }\n            return;\n        }\n\n        Dfp xdfp = new Dfp(field, mantissa);\n        xdfp = xdfp.divide(new Dfp(field, 4503599627370496l)).add(field.getOne());  // Divide by 2^52, then add one\n        xdfp = xdfp.multiply(DfpMath.pow(field.getTwo(), exponent));\n\n        if ((bits & 0x8000000000000000L) != 0) {\n            xdfp = xdfp.negate();\n        }\n\n        System.arraycopy(xdfp.mant, 0, mant, 0, mant.length);\n        sign = xdfp.sign;\n        exp  = xdfp.exp;\n        nans = xdfp.nans;\n\n    }",
          "27": "    protected Dfp(final DfpField field, double x) {\n\n        // initialize as if 0\n        mant = new int[field.getRadixDigits()];\n        sign = 1;\n        exp = 0;\n        nans = FINITE;\n        this.field = field;\n\n        long bits = Double.doubleToLongBits(x);\n        long mantissa = bits & 0x000fffffffffffffL;\nint exponent = ((int)((bits | 9218868437227405312L) >> 52) - 9218868437227405312L);\n\n        if (exponent == -1023) {\n            // Zero or sub-normal\n            if (x == 0) {\n                // make sure 0 has the right sign\n                if ((bits & 0x8000000000000000L) != 0) {\n                    sign = -1;\n                }\n                return;\n            }\n\n            exponent++;\n\n            // Normalize the subnormal number\n            while ( (mantissa & 0x0010000000000000L) == 0) {\n                exponent--;\n                mantissa <<= 1;\n            }\n            mantissa &= 0x000fffffffffffffL;\n        }\n\n        if (exponent == 1024) {\n            // infinity or NAN\n            if (x != x) {\n                sign = (byte) 1;\n                nans = QNAN;\n            } else if (x < 0) {\n                sign = (byte) -1;\n                nans = INFINITE;\n            } else {\n                sign = (byte) 1;\n                nans = INFINITE;\n            }\n            return;\n        }\n\n        Dfp xdfp = new Dfp(field, mantissa);\n        xdfp = xdfp.divide(new Dfp(field, 4503599627370496l)).add(field.getOne());  // Divide by 2^52, then add one\n        xdfp = xdfp.multiply(DfpMath.pow(field.getTwo(), exponent));\n\n        if ((bits & 0x8000000000000000L) != 0) {\n            xdfp = xdfp.negate();\n        }\n\n        System.arraycopy(xdfp.mant, 0, mant, 0, mant.length);\n        sign = xdfp.sign;\n        exp  = xdfp.exp;\n        nans = xdfp.nans;\n\n    }",
          "28": "    protected Dfp(final DfpField field, double x) {\n\n        // initialize as if 0\n        mant = new int[field.getRadixDigits()];\n        sign = 1;\n        exp = 0;\n        nans = FINITE;\n        this.field = field;\n\n        long bits = Double.doubleToLongBits(x);\n        long mantissa = bits & 0x000fffffffffffffL;\nint exponent = ((int)((bits | 9218868437227405312L) >> -1) - 1023);\n\n        if (exponent == -1023) {\n            // Zero or sub-normal\n            if (x == 0) {\n                // make sure 0 has the right sign\n                if ((bits & 0x8000000000000000L) != 0) {\n                    sign = -1;\n                }\n                return;\n            }\n\n            exponent++;\n\n            // Normalize the subnormal number\n            while ( (mantissa & 0x0010000000000000L) == 0) {\n                exponent--;\n                mantissa <<= 1;\n            }\n            mantissa &= 0x000fffffffffffffL;\n        }\n\n        if (exponent == 1024) {\n            // infinity or NAN\n            if (x != x) {\n                sign = (byte) 1;\n                nans = QNAN;\n            } else if (x < 0) {\n                sign = (byte) -1;\n                nans = INFINITE;\n            } else {\n                sign = (byte) 1;\n                nans = INFINITE;\n            }\n            return;\n        }\n\n        Dfp xdfp = new Dfp(field, mantissa);\n        xdfp = xdfp.divide(new Dfp(field, 4503599627370496l)).add(field.getOne());  // Divide by 2^52, then add one\n        xdfp = xdfp.multiply(DfpMath.pow(field.getTwo(), exponent));\n\n        if ((bits & 0x8000000000000000L) != 0) {\n            xdfp = xdfp.negate();\n        }\n\n        System.arraycopy(xdfp.mant, 0, mant, 0, mant.length);\n        sign = xdfp.sign;\n        exp  = xdfp.exp;\n        nans = xdfp.nans;\n\n    }",
          "29": "    protected Dfp(final DfpField field, double x) {\n\n        // initialize as if 0\n        mant = new int[field.getRadixDigits()];\n        sign = 1;\n        exp = 0;\n        nans = FINITE;\n        this.field = field;\n\n        long bits = Double.doubleToLongBits(x);\n        long mantissa = bits & 0x000fffffffffffffL;\nint exponent = ((int)((bits | 9218868437227405312L) >> 52) - 52);\n\n        if (exponent == -1023) {\n            // Zero or sub-normal\n            if (x == 0) {\n                // make sure 0 has the right sign\n                if ((bits & 0x8000000000000000L) != 0) {\n                    sign = -1;\n                }\n                return;\n            }\n\n            exponent++;\n\n            // Normalize the subnormal number\n            while ( (mantissa & 0x0010000000000000L) == 0) {\n                exponent--;\n                mantissa <<= 1;\n            }\n            mantissa &= 0x000fffffffffffffL;\n        }\n\n        if (exponent == 1024) {\n            // infinity or NAN\n            if (x != x) {\n                sign = (byte) 1;\n                nans = QNAN;\n            } else if (x < 0) {\n                sign = (byte) -1;\n                nans = INFINITE;\n            } else {\n                sign = (byte) 1;\n                nans = INFINITE;\n            }\n            return;\n        }\n\n        Dfp xdfp = new Dfp(field, mantissa);\n        xdfp = xdfp.divide(new Dfp(field, 4503599627370496l)).add(field.getOne());  // Divide by 2^52, then add one\n        xdfp = xdfp.multiply(DfpMath.pow(field.getTwo(), exponent));\n\n        if ((bits & 0x8000000000000000L) != 0) {\n            xdfp = xdfp.negate();\n        }\n\n        System.arraycopy(xdfp.mant, 0, mant, 0, mant.length);\n        sign = xdfp.sign;\n        exp  = xdfp.exp;\n        nans = xdfp.nans;\n\n    }",
          "30": "    protected Dfp(final DfpField field, double x) {\n\n        // initialize as if 0\n        mant = new int[field.getRadixDigits()];\n        sign = 1;\n        exp = 0;\n        nans = FINITE;\n        this.field = field;\n\n        long bits = Double.doubleToLongBits(x);\n        long mantissa = bits & 0x000fffffffffffffL;\nint exponent = ((int)((bits | -1) >> 52) - 1023);\n\n        if (exponent == -1023) {\n            // Zero or sub-normal\n            if (x == 0) {\n                // make sure 0 has the right sign\n                if ((bits & 0x8000000000000000L) != 0) {\n                    sign = -1;\n                }\n                return;\n            }\n\n            exponent++;\n\n            // Normalize the subnormal number\n            while ( (mantissa & 0x0010000000000000L) == 0) {\n                exponent--;\n                mantissa <<= 1;\n            }\n            mantissa &= 0x000fffffffffffffL;\n        }\n\n        if (exponent == 1024) {\n            // infinity or NAN\n            if (x != x) {\n                sign = (byte) 1;\n                nans = QNAN;\n            } else if (x < 0) {\n                sign = (byte) -1;\n                nans = INFINITE;\n            } else {\n                sign = (byte) 1;\n                nans = INFINITE;\n            }\n            return;\n        }\n\n        Dfp xdfp = new Dfp(field, mantissa);\n        xdfp = xdfp.divide(new Dfp(field, 4503599627370496l)).add(field.getOne());  // Divide by 2^52, then add one\n        xdfp = xdfp.multiply(DfpMath.pow(field.getTwo(), exponent));\n\n        if ((bits & 0x8000000000000000L) != 0) {\n            xdfp = xdfp.negate();\n        }\n\n        System.arraycopy(xdfp.mant, 0, mant, 0, mant.length);\n        sign = xdfp.sign;\n        exp  = xdfp.exp;\n        nans = xdfp.nans;\n\n    }",
          "31": "    protected Dfp(final DfpField field, double x) {\n\n        // initialize as if 0\n        mant = new int[field.getRadixDigits()];\n        sign = 1;\n        exp = 0;\n        nans = FINITE;\n        this.field = field;\n\n        long bits = Double.doubleToLongBits(x);\n        long mantissa = bits & 0x000fffffffffffffL;\nint exponent = ((int)((bits | true) >> 52) - 1023);\n\n        if (exponent == -1023) {\n            // Zero or sub-normal\n            if (x == 0) {\n                // make sure 0 has the right sign\n                if ((bits & 0x8000000000000000L) != 0) {\n                    sign = -1;\n                }\n                return;\n            }\n\n            exponent++;\n\n            // Normalize the subnormal number\n            while ( (mantissa & 0x0010000000000000L) == 0) {\n                exponent--;\n                mantissa <<= 1;\n            }\n            mantissa &= 0x000fffffffffffffL;\n        }\n\n        if (exponent == 1024) {\n            // infinity or NAN\n            if (x != x) {\n                sign = (byte) 1;\n                nans = QNAN;\n            } else if (x < 0) {\n                sign = (byte) -1;\n                nans = INFINITE;\n            } else {\n                sign = (byte) 1;\n                nans = INFINITE;\n            }\n            return;\n        }\n\n        Dfp xdfp = new Dfp(field, mantissa);\n        xdfp = xdfp.divide(new Dfp(field, 4503599627370496l)).add(field.getOne());  // Divide by 2^52, then add one\n        xdfp = xdfp.multiply(DfpMath.pow(field.getTwo(), exponent));\n\n        if ((bits & 0x8000000000000000L) != 0) {\n            xdfp = xdfp.negate();\n        }\n\n        System.arraycopy(xdfp.mant, 0, mant, 0, mant.length);\n        sign = xdfp.sign;\n        exp  = xdfp.exp;\n        nans = xdfp.nans;\n\n    }",
          "32": "    protected Dfp(final DfpField field, double x) {\n\n        // initialize as if 0\n        mant = new int[field.getRadixDigits()];\n        sign = 1;\n        exp = 0;\n        nans = FINITE;\n        this.field = field;\n\n        long bits = Double.doubleToLongBits(x);\n        long mantissa = bits & 0x000fffffffffffffL;\nint exponent = ((int)((bits | \"null\") >> 52) - 1023);\n\n        if (exponent == -1023) {\n            // Zero or sub-normal\n            if (x == 0) {\n                // make sure 0 has the right sign\n                if ((bits & 0x8000000000000000L) != 0) {\n                    sign = -1;\n                }\n                return;\n            }\n\n            exponent++;\n\n            // Normalize the subnormal number\n            while ( (mantissa & 0x0010000000000000L) == 0) {\n                exponent--;\n                mantissa <<= 1;\n            }\n            mantissa &= 0x000fffffffffffffL;\n        }\n\n        if (exponent == 1024) {\n            // infinity or NAN\n            if (x != x) {\n                sign = (byte) 1;\n                nans = QNAN;\n            } else if (x < 0) {\n                sign = (byte) -1;\n                nans = INFINITE;\n            } else {\n                sign = (byte) 1;\n                nans = INFINITE;\n            }\n            return;\n        }\n\n        Dfp xdfp = new Dfp(field, mantissa);\n        xdfp = xdfp.divide(new Dfp(field, 4503599627370496l)).add(field.getOne());  // Divide by 2^52, then add one\n        xdfp = xdfp.multiply(DfpMath.pow(field.getTwo(), exponent));\n\n        if ((bits & 0x8000000000000000L) != 0) {\n            xdfp = xdfp.negate();\n        }\n\n        System.arraycopy(xdfp.mant, 0, mant, 0, mant.length);\n        sign = xdfp.sign;\n        exp  = xdfp.exp;\n        nans = xdfp.nans;\n\n    }",
          "33": "    protected Dfp(final DfpField field, double x) {\n\n        // initialize as if 0\n        mant = new int[field.getRadixDigits()];\n        sign = 1;\n        exp = 0;\n        nans = FINITE;\n        this.field = field;\n\n        long bits = Double.doubleToLongBits(x);\n        long mantissa = bits & 0x000fffffffffffffL;\nint exponent = ((int)((bits | null) >> 52) - 1023);\n\n        if (exponent == -1023) {\n            // Zero or sub-normal\n            if (x == 0) {\n                // make sure 0 has the right sign\n                if ((bits & 0x8000000000000000L) != 0) {\n                    sign = -1;\n                }\n                return;\n            }\n\n            exponent++;\n\n            // Normalize the subnormal number\n            while ( (mantissa & 0x0010000000000000L) == 0) {\n                exponent--;\n                mantissa <<= 1;\n            }\n            mantissa &= 0x000fffffffffffffL;\n        }\n\n        if (exponent == 1024) {\n            // infinity or NAN\n            if (x != x) {\n                sign = (byte) 1;\n                nans = QNAN;\n            } else if (x < 0) {\n                sign = (byte) -1;\n                nans = INFINITE;\n            } else {\n                sign = (byte) 1;\n                nans = INFINITE;\n            }\n            return;\n        }\n\n        Dfp xdfp = new Dfp(field, mantissa);\n        xdfp = xdfp.divide(new Dfp(field, 4503599627370496l)).add(field.getOne());  // Divide by 2^52, then add one\n        xdfp = xdfp.multiply(DfpMath.pow(field.getTwo(), exponent));\n\n        if ((bits & 0x8000000000000000L) != 0) {\n            xdfp = xdfp.negate();\n        }\n\n        System.arraycopy(xdfp.mant, 0, mant, 0, mant.length);\n        sign = xdfp.sign;\n        exp  = xdfp.exp;\n        nans = xdfp.nans;\n\n    }",
          "34": "    protected Dfp(final DfpField field, double x) {\n\n        // initialize as if 0\n        mant = new int[field.getRadixDigits()];\n        sign = 1;\n        exp = 0;\n        nans = FINITE;\n        this.field = field;\n\n        long bits = Double.doubleToLongBits(x);\n        long mantissa = bits & 0x000fffffffffffffL;\nint exponent = ((int)((bits | 9218868437227405312L) >> \"null\") - 1023);\n\n        if (exponent == -1023) {\n            // Zero or sub-normal\n            if (x == 0) {\n                // make sure 0 has the right sign\n                if ((bits & 0x8000000000000000L) != 0) {\n                    sign = -1;\n                }\n                return;\n            }\n\n            exponent++;\n\n            // Normalize the subnormal number\n            while ( (mantissa & 0x0010000000000000L) == 0) {\n                exponent--;\n                mantissa <<= 1;\n            }\n            mantissa &= 0x000fffffffffffffL;\n        }\n\n        if (exponent == 1024) {\n            // infinity or NAN\n            if (x != x) {\n                sign = (byte) 1;\n                nans = QNAN;\n            } else if (x < 0) {\n                sign = (byte) -1;\n                nans = INFINITE;\n            } else {\n                sign = (byte) 1;\n                nans = INFINITE;\n            }\n            return;\n        }\n\n        Dfp xdfp = new Dfp(field, mantissa);\n        xdfp = xdfp.divide(new Dfp(field, 4503599627370496l)).add(field.getOne());  // Divide by 2^52, then add one\n        xdfp = xdfp.multiply(DfpMath.pow(field.getTwo(), exponent));\n\n        if ((bits & 0x8000000000000000L) != 0) {\n            xdfp = xdfp.negate();\n        }\n\n        System.arraycopy(xdfp.mant, 0, mant, 0, mant.length);\n        sign = xdfp.sign;\n        exp  = xdfp.exp;\n        nans = xdfp.nans;\n\n    }",
          "35": "    protected Dfp(final DfpField field, double x) {\n\n        // initialize as if 0\n        mant = new int[field.getRadixDigits()];\n        sign = 1;\n        exp = 0;\n        nans = FINITE;\n        this.field = field;\n\n        long bits = Double.doubleToLongBits(x);\n        long mantissa = bits & 0x000fffffffffffffL;\nint exponent = ((int)((bits | 9218868437227405312L) >> null) - 1023);\n\n        if (exponent == -1023) {\n            // Zero or sub-normal\n            if (x == 0) {\n                // make sure 0 has the right sign\n                if ((bits & 0x8000000000000000L) != 0) {\n                    sign = -1;\n                }\n                return;\n            }\n\n            exponent++;\n\n            // Normalize the subnormal number\n            while ( (mantissa & 0x0010000000000000L) == 0) {\n                exponent--;\n                mantissa <<= 1;\n            }\n            mantissa &= 0x000fffffffffffffL;\n        }\n\n        if (exponent == 1024) {\n            // infinity or NAN\n            if (x != x) {\n                sign = (byte) 1;\n                nans = QNAN;\n            } else if (x < 0) {\n                sign = (byte) -1;\n                nans = INFINITE;\n            } else {\n                sign = (byte) 1;\n                nans = INFINITE;\n            }\n            return;\n        }\n\n        Dfp xdfp = new Dfp(field, mantissa);\n        xdfp = xdfp.divide(new Dfp(field, 4503599627370496l)).add(field.getOne());  // Divide by 2^52, then add one\n        xdfp = xdfp.multiply(DfpMath.pow(field.getTwo(), exponent));\n\n        if ((bits & 0x8000000000000000L) != 0) {\n            xdfp = xdfp.negate();\n        }\n\n        System.arraycopy(xdfp.mant, 0, mant, 0, mant.length);\n        sign = xdfp.sign;\n        exp  = xdfp.exp;\n        nans = xdfp.nans;\n\n    }",
          "36": "    protected Dfp(final DfpField field, double x) {\n\n        // initialize as if 0\n        mant = new int[field.getRadixDigits()];\n        sign = 1;\n        exp = 0;\n        nans = FINITE;\n        this.field = field;\n\n        long bits = Double.doubleToLongBits(x);\n        long mantissa = bits & 0x000fffffffffffffL;\nint exponent = ((int)((bits | false) >> 52) - 1023);\n\n        if (exponent == -1023) {\n            // Zero or sub-normal\n            if (x == 0) {\n                // make sure 0 has the right sign\n                if ((bits & 0x8000000000000000L) != 0) {\n                    sign = -1;\n                }\n                return;\n            }\n\n            exponent++;\n\n            // Normalize the subnormal number\n            while ( (mantissa & 0x0010000000000000L) == 0) {\n                exponent--;\n                mantissa <<= 1;\n            }\n            mantissa &= 0x000fffffffffffffL;\n        }\n\n        if (exponent == 1024) {\n            // infinity or NAN\n            if (x != x) {\n                sign = (byte) 1;\n                nans = QNAN;\n            } else if (x < 0) {\n                sign = (byte) -1;\n                nans = INFINITE;\n            } else {\n                sign = (byte) 1;\n                nans = INFINITE;\n            }\n            return;\n        }\n\n        Dfp xdfp = new Dfp(field, mantissa);\n        xdfp = xdfp.divide(new Dfp(field, 4503599627370496l)).add(field.getOne());  // Divide by 2^52, then add one\n        xdfp = xdfp.multiply(DfpMath.pow(field.getTwo(), exponent));\n\n        if ((bits & 0x8000000000000000L) != 0) {\n            xdfp = xdfp.negate();\n        }\n\n        System.arraycopy(xdfp.mant, 0, mant, 0, mant.length);\n        sign = xdfp.sign;\n        exp  = xdfp.exp;\n        nans = xdfp.nans;\n\n    }",
          "37": "    protected Dfp(final DfpField field, double x) {\n\n        // initialize as if 0\n        mant = new int[field.getRadixDigits()];\n        sign = 1;\n        exp = 0;\n        nans = FINITE;\n        this.field = field;\n\n        long bits = Double.doubleToLongBits(x);\n        long mantissa = bits & 0x000fffffffffffffL;\nint exponent = ((int)((bits | 9218868437227405312L) >> true) - 1023);\n\n        if (exponent == -1023) {\n            // Zero or sub-normal\n            if (x == 0) {\n                // make sure 0 has the right sign\n                if ((bits & 0x8000000000000000L) != 0) {\n                    sign = -1;\n                }\n                return;\n            }\n\n            exponent++;\n\n            // Normalize the subnormal number\n            while ( (mantissa & 0x0010000000000000L) == 0) {\n                exponent--;\n                mantissa <<= 1;\n            }\n            mantissa &= 0x000fffffffffffffL;\n        }\n\n        if (exponent == 1024) {\n            // infinity or NAN\n            if (x != x) {\n                sign = (byte) 1;\n                nans = QNAN;\n            } else if (x < 0) {\n                sign = (byte) -1;\n                nans = INFINITE;\n            } else {\n                sign = (byte) 1;\n                nans = INFINITE;\n            }\n            return;\n        }\n\n        Dfp xdfp = new Dfp(field, mantissa);\n        xdfp = xdfp.divide(new Dfp(field, 4503599627370496l)).add(field.getOne());  // Divide by 2^52, then add one\n        xdfp = xdfp.multiply(DfpMath.pow(field.getTwo(), exponent));\n\n        if ((bits & 0x8000000000000000L) != 0) {\n            xdfp = xdfp.negate();\n        }\n\n        System.arraycopy(xdfp.mant, 0, mant, 0, mant.length);\n        sign = xdfp.sign;\n        exp  = xdfp.exp;\n        nans = xdfp.nans;\n\n    }",
          "38": "    protected Dfp(final DfpField field, double x) {\n\n        // initialize as if 0\n        mant = new int[field.getRadixDigits()];\n        sign = 1;\n        exp = 0;\n        nans = FINITE;\n        this.field = field;\n\n        long bits = Double.doubleToLongBits(x);\n        long mantissa = bits & 0x000fffffffffffffL;\nint exponent = bits;\n\n        if (exponent == -1023) {\n            // Zero or sub-normal\n            if (x == 0) {\n                // make sure 0 has the right sign\n                if ((bits & 0x8000000000000000L) != 0) {\n                    sign = -1;\n                }\n                return;\n            }\n\n            exponent++;\n\n            // Normalize the subnormal number\n            while ( (mantissa & 0x0010000000000000L) == 0) {\n                exponent--;\n                mantissa <<= 1;\n            }\n            mantissa &= 0x000fffffffffffffL;\n        }\n\n        if (exponent == 1024) {\n            // infinity or NAN\n            if (x != x) {\n                sign = (byte) 1;\n                nans = QNAN;\n            } else if (x < 0) {\n                sign = (byte) -1;\n                nans = INFINITE;\n            } else {\n                sign = (byte) 1;\n                nans = INFINITE;\n            }\n            return;\n        }\n\n        Dfp xdfp = new Dfp(field, mantissa);\n        xdfp = xdfp.divide(new Dfp(field, 4503599627370496l)).add(field.getOne());  // Divide by 2^52, then add one\n        xdfp = xdfp.multiply(DfpMath.pow(field.getTwo(), exponent));\n\n        if ((bits & 0x8000000000000000L) != 0) {\n            xdfp = xdfp.negate();\n        }\n\n        System.arraycopy(xdfp.mant, 0, mant, 0, mant.length);\n        sign = xdfp.sign;\n        exp  = xdfp.exp;\n        nans = xdfp.nans;\n\n    }",
          "39": "    protected Dfp(final DfpField field, double x) {\n\n        // initialize as if 0\n        mant = new int[field.getRadixDigits()];\n        sign = 1;\n        exp = 0;\n        nans = FINITE;\n        this.field = field;\n\n        long bits = Double.doubleToLongBits(x);\n        long mantissa = bits & 0x000fffffffffffffL;\nint exponent = ((int)((bits <= 9218868437227405312L) >> 52) - 1023);\n\n        if (exponent == -1023) {\n            // Zero or sub-normal\n            if (x == 0) {\n                // make sure 0 has the right sign\n                if ((bits & 0x8000000000000000L) != 0) {\n                    sign = -1;\n                }\n                return;\n            }\n\n            exponent++;\n\n            // Normalize the subnormal number\n            while ( (mantissa & 0x0010000000000000L) == 0) {\n                exponent--;\n                mantissa <<= 1;\n            }\n            mantissa &= 0x000fffffffffffffL;\n        }\n\n        if (exponent == 1024) {\n            // infinity or NAN\n            if (x != x) {\n                sign = (byte) 1;\n                nans = QNAN;\n            } else if (x < 0) {\n                sign = (byte) -1;\n                nans = INFINITE;\n            } else {\n                sign = (byte) 1;\n                nans = INFINITE;\n            }\n            return;\n        }\n\n        Dfp xdfp = new Dfp(field, mantissa);\n        xdfp = xdfp.divide(new Dfp(field, 4503599627370496l)).add(field.getOne());  // Divide by 2^52, then add one\n        xdfp = xdfp.multiply(DfpMath.pow(field.getTwo(), exponent));\n\n        if ((bits & 0x8000000000000000L) != 0) {\n            xdfp = xdfp.negate();\n        }\n\n        System.arraycopy(xdfp.mant, 0, mant, 0, mant.length);\n        sign = xdfp.sign;\n        exp  = xdfp.exp;\n        nans = xdfp.nans;\n\n    }",
          "40": "    protected Dfp(final DfpField field, double x) {\n\n        // initialize as if 0\n        mant = new int[field.getRadixDigits()];\n        sign = 1;\n        exp = 0;\n        nans = FINITE;\n        this.field = field;\n\n        long bits = Double.doubleToLongBits(x);\n        long mantissa = bits & 0x000fffffffffffffL;\nint exponent = ((int)((bits | 9218868437227405312L) >> false) - 1023);\n\n        if (exponent == -1023) {\n            // Zero or sub-normal\n            if (x == 0) {\n                // make sure 0 has the right sign\n                if ((bits & 0x8000000000000000L) != 0) {\n                    sign = -1;\n                }\n                return;\n            }\n\n            exponent++;\n\n            // Normalize the subnormal number\n            while ( (mantissa & 0x0010000000000000L) == 0) {\n                exponent--;\n                mantissa <<= 1;\n            }\n            mantissa &= 0x000fffffffffffffL;\n        }\n\n        if (exponent == 1024) {\n            // infinity or NAN\n            if (x != x) {\n                sign = (byte) 1;\n                nans = QNAN;\n            } else if (x < 0) {\n                sign = (byte) -1;\n                nans = INFINITE;\n            } else {\n                sign = (byte) 1;\n                nans = INFINITE;\n            }\n            return;\n        }\n\n        Dfp xdfp = new Dfp(field, mantissa);\n        xdfp = xdfp.divide(new Dfp(field, 4503599627370496l)).add(field.getOne());  // Divide by 2^52, then add one\n        xdfp = xdfp.multiply(DfpMath.pow(field.getTwo(), exponent));\n\n        if ((bits & 0x8000000000000000L) != 0) {\n            xdfp = xdfp.negate();\n        }\n\n        System.arraycopy(xdfp.mant, 0, mant, 0, mant.length);\n        sign = xdfp.sign;\n        exp  = xdfp.exp;\n        nans = xdfp.nans;\n\n    }",
          "41": "    protected Dfp(final DfpField field, double x) {\n\n        // initialize as if 0\n        mant = new int[field.getRadixDigits()];\n        sign = 1;\n        exp = 0;\n        nans = FINITE;\n        this.field = field;\n\n        long bits = Double.doubleToLongBits(x);\n        long mantissa = bits & 0x000fffffffffffffL;\nint exponent = ((int)((bits >= 9218868437227405312L) >> 52) - 1023);\n\n        if (exponent == -1023) {\n            // Zero or sub-normal\n            if (x == 0) {\n                // make sure 0 has the right sign\n                if ((bits & 0x8000000000000000L) != 0) {\n                    sign = -1;\n                }\n                return;\n            }\n\n            exponent++;\n\n            // Normalize the subnormal number\n            while ( (mantissa & 0x0010000000000000L) == 0) {\n                exponent--;\n                mantissa <<= 1;\n            }\n            mantissa &= 0x000fffffffffffffL;\n        }\n\n        if (exponent == 1024) {\n            // infinity or NAN\n            if (x != x) {\n                sign = (byte) 1;\n                nans = QNAN;\n            } else if (x < 0) {\n                sign = (byte) -1;\n                nans = INFINITE;\n            } else {\n                sign = (byte) 1;\n                nans = INFINITE;\n            }\n            return;\n        }\n\n        Dfp xdfp = new Dfp(field, mantissa);\n        xdfp = xdfp.divide(new Dfp(field, 4503599627370496l)).add(field.getOne());  // Divide by 2^52, then add one\n        xdfp = xdfp.multiply(DfpMath.pow(field.getTwo(), exponent));\n\n        if ((bits & 0x8000000000000000L) != 0) {\n            xdfp = xdfp.negate();\n        }\n\n        System.arraycopy(xdfp.mant, 0, mant, 0, mant.length);\n        sign = xdfp.sign;\n        exp  = xdfp.exp;\n        nans = xdfp.nans;\n\n    }",
          "42": "    protected Dfp(final DfpField field, double x) {\n\n        // initialize as if 0\n        mant = new int[field.getRadixDigits()];\n        sign = 1;\n        exp = 0;\n        nans = FINITE;\n        this.field = field;\n\n        long bits = Double.doubleToLongBits(x);\n        long mantissa = bits & 0x000fffffffffffffL;\nint exponent = ((int)((bits - 9218868437227405312L) >> 52) - 1023);\n\n        if (exponent == -1023) {\n            // Zero or sub-normal\n            if (x == 0) {\n                // make sure 0 has the right sign\n                if ((bits & 0x8000000000000000L) != 0) {\n                    sign = -1;\n                }\n                return;\n            }\n\n            exponent++;\n\n            // Normalize the subnormal number\n            while ( (mantissa & 0x0010000000000000L) == 0) {\n                exponent--;\n                mantissa <<= 1;\n            }\n            mantissa &= 0x000fffffffffffffL;\n        }\n\n        if (exponent == 1024) {\n            // infinity or NAN\n            if (x != x) {\n                sign = (byte) 1;\n                nans = QNAN;\n            } else if (x < 0) {\n                sign = (byte) -1;\n                nans = INFINITE;\n            } else {\n                sign = (byte) 1;\n                nans = INFINITE;\n            }\n            return;\n        }\n\n        Dfp xdfp = new Dfp(field, mantissa);\n        xdfp = xdfp.divide(new Dfp(field, 4503599627370496l)).add(field.getOne());  // Divide by 2^52, then add one\n        xdfp = xdfp.multiply(DfpMath.pow(field.getTwo(), exponent));\n\n        if ((bits & 0x8000000000000000L) != 0) {\n            xdfp = xdfp.negate();\n        }\n\n        System.arraycopy(xdfp.mant, 0, mant, 0, mant.length);\n        sign = xdfp.sign;\n        exp  = xdfp.exp;\n        nans = xdfp.nans;\n\n    }",
          "43": "    protected Dfp(final DfpField field, double x) {\n\n        // initialize as if 0\n        mant = new int[field.getRadixDigits()];\n        sign = 1;\n        exp = 0;\n        nans = FINITE;\n        this.field = field;\n\n        long bits = Double.doubleToLongBits(x);\n        long mantissa = bits & 0x000fffffffffffffL;\nint exponent = ((int)((bits | 9218868437227405312L) >> 52) - -2);\n\n        if (exponent == -1023) {\n            // Zero or sub-normal\n            if (x == 0) {\n                // make sure 0 has the right sign\n                if ((bits & 0x8000000000000000L) != 0) {\n                    sign = -1;\n                }\n                return;\n            }\n\n            exponent++;\n\n            // Normalize the subnormal number\n            while ( (mantissa & 0x0010000000000000L) == 0) {\n                exponent--;\n                mantissa <<= 1;\n            }\n            mantissa &= 0x000fffffffffffffL;\n        }\n\n        if (exponent == 1024) {\n            // infinity or NAN\n            if (x != x) {\n                sign = (byte) 1;\n                nans = QNAN;\n            } else if (x < 0) {\n                sign = (byte) -1;\n                nans = INFINITE;\n            } else {\n                sign = (byte) 1;\n                nans = INFINITE;\n            }\n            return;\n        }\n\n        Dfp xdfp = new Dfp(field, mantissa);\n        xdfp = xdfp.divide(new Dfp(field, 4503599627370496l)).add(field.getOne());  // Divide by 2^52, then add one\n        xdfp = xdfp.multiply(DfpMath.pow(field.getTwo(), exponent));\n\n        if ((bits & 0x8000000000000000L) != 0) {\n            xdfp = xdfp.negate();\n        }\n\n        System.arraycopy(xdfp.mant, 0, mant, 0, mant.length);\n        sign = xdfp.sign;\n        exp  = xdfp.exp;\n        nans = xdfp.nans;\n\n    }",
          "44": "    protected Dfp(final DfpField field, double x) {\n\n        // initialize as if 0\n        mant = new int[field.getRadixDigits()];\n        sign = 1;\n        exp = 0;\n        nans = FINITE;\n        this.field = field;\n\n        long bits = Double.doubleToLongBits(x);\n        long mantissa = bits & 0x000fffffffffffffL;\nint exponent = 0;\n\n        if (exponent == -1023) {\n            // Zero or sub-normal\n            if (x == 0) {\n                // make sure 0 has the right sign\n                if ((bits & 0x8000000000000000L) != 0) {\n                    sign = -1;\n                }\n                return;\n            }\n\n            exponent++;\n\n            // Normalize the subnormal number\n            while ( (mantissa & 0x0010000000000000L) == 0) {\n                exponent--;\n                mantissa <<= 1;\n            }\n            mantissa &= 0x000fffffffffffffL;\n        }\n\n        if (exponent == 1024) {\n            // infinity or NAN\n            if (x != x) {\n                sign = (byte) 1;\n                nans = QNAN;\n            } else if (x < 0) {\n                sign = (byte) -1;\n                nans = INFINITE;\n            } else {\n                sign = (byte) 1;\n                nans = INFINITE;\n            }\n            return;\n        }\n\n        Dfp xdfp = new Dfp(field, mantissa);\n        xdfp = xdfp.divide(new Dfp(field, 4503599627370496l)).add(field.getOne());  // Divide by 2^52, then add one\n        xdfp = xdfp.multiply(DfpMath.pow(field.getTwo(), exponent));\n\n        if ((bits & 0x8000000000000000L) != 0) {\n            xdfp = xdfp.negate();\n        }\n\n        System.arraycopy(xdfp.mant, 0, mant, 0, mant.length);\n        sign = xdfp.sign;\n        exp  = xdfp.exp;\n        nans = xdfp.nans;\n\n    }",
          "45": "    protected Dfp(final DfpField field, double x) {\n\n        // initialize as if 0\n        mant = new int[field.getRadixDigits()];\n        sign = 1;\n        exp = 0;\n        nans = FINITE;\n        this.field = field;\n\n        long bits = Double.doubleToLongBits(x);\n        long mantissa = bits & 0x000fffffffffffffL;\nint exponent = ((int)((bits | 9218868437227405312L) >> 9218868437227405312L) - 1023);\n\n        if (exponent == -1023) {\n            // Zero or sub-normal\n            if (x == 0) {\n                // make sure 0 has the right sign\n                if ((bits & 0x8000000000000000L) != 0) {\n                    sign = -1;\n                }\n                return;\n            }\n\n            exponent++;\n\n            // Normalize the subnormal number\n            while ( (mantissa & 0x0010000000000000L) == 0) {\n                exponent--;\n                mantissa <<= 1;\n            }\n            mantissa &= 0x000fffffffffffffL;\n        }\n\n        if (exponent == 1024) {\n            // infinity or NAN\n            if (x != x) {\n                sign = (byte) 1;\n                nans = QNAN;\n            } else if (x < 0) {\n                sign = (byte) -1;\n                nans = INFINITE;\n            } else {\n                sign = (byte) 1;\n                nans = INFINITE;\n            }\n            return;\n        }\n\n        Dfp xdfp = new Dfp(field, mantissa);\n        xdfp = xdfp.divide(new Dfp(field, 4503599627370496l)).add(field.getOne());  // Divide by 2^52, then add one\n        xdfp = xdfp.multiply(DfpMath.pow(field.getTwo(), exponent));\n\n        if ((bits & 0x8000000000000000L) != 0) {\n            xdfp = xdfp.negate();\n        }\n\n        System.arraycopy(xdfp.mant, 0, mant, 0, mant.length);\n        sign = xdfp.sign;\n        exp  = xdfp.exp;\n        nans = xdfp.nans;\n\n    }",
          "46": "    protected Dfp(final DfpField field, double x) {\n\n        // initialize as if 0\n        mant = new int[field.getRadixDigits()];\n        sign = 1;\n        exp = 0;\n        nans = FINITE;\n        this.field = field;\n\n        long bits = Double.doubleToLongBits(x);\n        long mantissa = bits & 0x000fffffffffffffL;\nint exponent = ((int)((bits | 9218868437227405312L) >> 52) <= 1023);\n\n        if (exponent == -1023) {\n            // Zero or sub-normal\n            if (x == 0) {\n                // make sure 0 has the right sign\n                if ((bits & 0x8000000000000000L) != 0) {\n                    sign = -1;\n                }\n                return;\n            }\n\n            exponent++;\n\n            // Normalize the subnormal number\n            while ( (mantissa & 0x0010000000000000L) == 0) {\n                exponent--;\n                mantissa <<= 1;\n            }\n            mantissa &= 0x000fffffffffffffL;\n        }\n\n        if (exponent == 1024) {\n            // infinity or NAN\n            if (x != x) {\n                sign = (byte) 1;\n                nans = QNAN;\n            } else if (x < 0) {\n                sign = (byte) -1;\n                nans = INFINITE;\n            } else {\n                sign = (byte) 1;\n                nans = INFINITE;\n            }\n            return;\n        }\n\n        Dfp xdfp = new Dfp(field, mantissa);\n        xdfp = xdfp.divide(new Dfp(field, 4503599627370496l)).add(field.getOne());  // Divide by 2^52, then add one\n        xdfp = xdfp.multiply(DfpMath.pow(field.getTwo(), exponent));\n\n        if ((bits & 0x8000000000000000L) != 0) {\n            xdfp = xdfp.negate();\n        }\n\n        System.arraycopy(xdfp.mant, 0, mant, 0, mant.length);\n        sign = xdfp.sign;\n        exp  = xdfp.exp;\n        nans = xdfp.nans;\n\n    }",
          "47": "    protected Dfp(final DfpField field, double x) {\n\n        // initialize as if 0\n        mant = new int[field.getRadixDigits()];\n        sign = 1;\n        exp = 0;\n        nans = FINITE;\n        this.field = field;\n\n        long bits = Double.doubleToLongBits(x);\n        long mantissa = bits & 0x000fffffffffffffL;\nint exponent = ((int)((bits | 9218868437227405312L) >> 1023) - 1023);\n\n        if (exponent == -1023) {\n            // Zero or sub-normal\n            if (x == 0) {\n                // make sure 0 has the right sign\n                if ((bits & 0x8000000000000000L) != 0) {\n                    sign = -1;\n                }\n                return;\n            }\n\n            exponent++;\n\n            // Normalize the subnormal number\n            while ( (mantissa & 0x0010000000000000L) == 0) {\n                exponent--;\n                mantissa <<= 1;\n            }\n            mantissa &= 0x000fffffffffffffL;\n        }\n\n        if (exponent == 1024) {\n            // infinity or NAN\n            if (x != x) {\n                sign = (byte) 1;\n                nans = QNAN;\n            } else if (x < 0) {\n                sign = (byte) -1;\n                nans = INFINITE;\n            } else {\n                sign = (byte) 1;\n                nans = INFINITE;\n            }\n            return;\n        }\n\n        Dfp xdfp = new Dfp(field, mantissa);\n        xdfp = xdfp.divide(new Dfp(field, 4503599627370496l)).add(field.getOne());  // Divide by 2^52, then add one\n        xdfp = xdfp.multiply(DfpMath.pow(field.getTwo(), exponent));\n\n        if ((bits & 0x8000000000000000L) != 0) {\n            xdfp = xdfp.negate();\n        }\n\n        System.arraycopy(xdfp.mant, 0, mant, 0, mant.length);\n        sign = xdfp.sign;\n        exp  = xdfp.exp;\n        nans = xdfp.nans;\n\n    }",
          "48": "    protected Dfp(final DfpField field, double x) {\n\n        // initialize as if 0\n        mant = new int[field.getRadixDigits()];\n        sign = 1;\n        exp = 0;\n        nans = FINITE;\n        this.field = field;\n\n        long bits = Double.doubleToLongBits(x);\n        long mantissa = bits & 0x000fffffffffffffL;\nint exponent = ((int)((bits > 9218868437227405312L) >> 52) - 1023);\n\n        if (exponent == -1023) {\n            // Zero or sub-normal\n            if (x == 0) {\n                // make sure 0 has the right sign\n                if ((bits & 0x8000000000000000L) != 0) {\n                    sign = -1;\n                }\n                return;\n            }\n\n            exponent++;\n\n            // Normalize the subnormal number\n            while ( (mantissa & 0x0010000000000000L) == 0) {\n                exponent--;\n                mantissa <<= 1;\n            }\n            mantissa &= 0x000fffffffffffffL;\n        }\n\n        if (exponent == 1024) {\n            // infinity or NAN\n            if (x != x) {\n                sign = (byte) 1;\n                nans = QNAN;\n            } else if (x < 0) {\n                sign = (byte) -1;\n                nans = INFINITE;\n            } else {\n                sign = (byte) 1;\n                nans = INFINITE;\n            }\n            return;\n        }\n\n        Dfp xdfp = new Dfp(field, mantissa);\n        xdfp = xdfp.divide(new Dfp(field, 4503599627370496l)).add(field.getOne());  // Divide by 2^52, then add one\n        xdfp = xdfp.multiply(DfpMath.pow(field.getTwo(), exponent));\n\n        if ((bits & 0x8000000000000000L) != 0) {\n            xdfp = xdfp.negate();\n        }\n\n        System.arraycopy(xdfp.mant, 0, mant, 0, mant.length);\n        sign = xdfp.sign;\n        exp  = xdfp.exp;\n        nans = xdfp.nans;\n\n    }",
          "49": "    protected Dfp(final DfpField field, double x) {\n\n        // initialize as if 0\n        mant = new int[field.getRadixDigits()];\n        sign = 1;\n        exp = 0;\n        nans = FINITE;\n        this.field = field;\n\n        long bits = Double.doubleToLongBits(x);\n        long mantissa = bits & 0x000fffffffffffffL;\nint exponent = ((int)((bits >> 9218868437227405312L) >> 52) - 1023);\n\n        if (exponent == -1023) {\n            // Zero or sub-normal\n            if (x == 0) {\n                // make sure 0 has the right sign\n                if ((bits & 0x8000000000000000L) != 0) {\n                    sign = -1;\n                }\n                return;\n            }\n\n            exponent++;\n\n            // Normalize the subnormal number\n            while ( (mantissa & 0x0010000000000000L) == 0) {\n                exponent--;\n                mantissa <<= 1;\n            }\n            mantissa &= 0x000fffffffffffffL;\n        }\n\n        if (exponent == 1024) {\n            // infinity or NAN\n            if (x != x) {\n                sign = (byte) 1;\n                nans = QNAN;\n            } else if (x < 0) {\n                sign = (byte) -1;\n                nans = INFINITE;\n            } else {\n                sign = (byte) 1;\n                nans = INFINITE;\n            }\n            return;\n        }\n\n        Dfp xdfp = new Dfp(field, mantissa);\n        xdfp = xdfp.divide(new Dfp(field, 4503599627370496l)).add(field.getOne());  // Divide by 2^52, then add one\n        xdfp = xdfp.multiply(DfpMath.pow(field.getTwo(), exponent));\n\n        if ((bits & 0x8000000000000000L) != 0) {\n            xdfp = xdfp.negate();\n        }\n\n        System.arraycopy(xdfp.mant, 0, mant, 0, mant.length);\n        sign = xdfp.sign;\n        exp  = xdfp.exp;\n        nans = xdfp.nans;\n\n    }",
          "50": "    protected Dfp(final DfpField field, double x) {\n\n        // initialize as if 0\n        mant = new int[field.getRadixDigits()];\n        sign = 1;\n        exp = 0;\n        nans = FINITE;\n        this.field = field;\n\n        long bits = Double.doubleToLongBits(x);\n        long mantissa = bits & 0x000fffffffffffffL;\nint exponent = ((int)((bits | 1023) >> 52) - 1023);\n\n        if (exponent == -1023) {\n            // Zero or sub-normal\n            if (x == 0) {\n                // make sure 0 has the right sign\n                if ((bits & 0x8000000000000000L) != 0) {\n                    sign = -1;\n                }\n                return;\n            }\n\n            exponent++;\n\n            // Normalize the subnormal number\n            while ( (mantissa & 0x0010000000000000L) == 0) {\n                exponent--;\n                mantissa <<= 1;\n            }\n            mantissa &= 0x000fffffffffffffL;\n        }\n\n        if (exponent == 1024) {\n            // infinity or NAN\n            if (x != x) {\n                sign = (byte) 1;\n                nans = QNAN;\n            } else if (x < 0) {\n                sign = (byte) -1;\n                nans = INFINITE;\n            } else {\n                sign = (byte) 1;\n                nans = INFINITE;\n            }\n            return;\n        }\n\n        Dfp xdfp = new Dfp(field, mantissa);\n        xdfp = xdfp.divide(new Dfp(field, 4503599627370496l)).add(field.getOne());  // Divide by 2^52, then add one\n        xdfp = xdfp.multiply(DfpMath.pow(field.getTwo(), exponent));\n\n        if ((bits & 0x8000000000000000L) != 0) {\n            xdfp = xdfp.negate();\n        }\n\n        System.arraycopy(xdfp.mant, 0, mant, 0, mant.length);\n        sign = xdfp.sign;\n        exp  = xdfp.exp;\n        nans = xdfp.nans;\n\n    }",
          "51": "    protected Dfp(final DfpField field, double x) {\n\n        // initialize as if 0\n        mant = new int[field.getRadixDigits()];\n        sign = 1;\n        exp = 0;\n        nans = FINITE;\n        this.field = field;\n\n        long bits = Double.doubleToLongBits(x);\n        long mantissa = bits & 0x000fffffffffffffL;\nint exponent = ((int)((bits | 52) >> 52) - 1023);\n\n        if (exponent == -1023) {\n            // Zero or sub-normal\n            if (x == 0) {\n                // make sure 0 has the right sign\n                if ((bits & 0x8000000000000000L) != 0) {\n                    sign = -1;\n                }\n                return;\n            }\n\n            exponent++;\n\n            // Normalize the subnormal number\n            while ( (mantissa & 0x0010000000000000L) == 0) {\n                exponent--;\n                mantissa <<= 1;\n            }\n            mantissa &= 0x000fffffffffffffL;\n        }\n\n        if (exponent == 1024) {\n            // infinity or NAN\n            if (x != x) {\n                sign = (byte) 1;\n                nans = QNAN;\n            } else if (x < 0) {\n                sign = (byte) -1;\n                nans = INFINITE;\n            } else {\n                sign = (byte) 1;\n                nans = INFINITE;\n            }\n            return;\n        }\n\n        Dfp xdfp = new Dfp(field, mantissa);\n        xdfp = xdfp.divide(new Dfp(field, 4503599627370496l)).add(field.getOne());  // Divide by 2^52, then add one\n        xdfp = xdfp.multiply(DfpMath.pow(field.getTwo(), exponent));\n\n        if ((bits & 0x8000000000000000L) != 0) {\n            xdfp = xdfp.negate();\n        }\n\n        System.arraycopy(xdfp.mant, 0, mant, 0, mant.length);\n        sign = xdfp.sign;\n        exp  = xdfp.exp;\n        nans = xdfp.nans;\n\n    }",
          "52": "    protected Dfp(final DfpField field, double x) {\n\n        // initialize as if 0\n        mant = new int[field.getRadixDigits()];\n        sign = 1;\n        exp = 0;\n        nans = FINITE;\n        this.field = field;\n\n        long bits = Double.doubleToLongBits(x);\n        long mantissa = bits & 0x000fffffffffffffL;\nshiftLeft();\n        int exponent = (int) ((bits | 9218868437227405312L) >> 52) - 1023;\n        if (exponent == -1023) {\n            // Zero or sub-normal\n            if (x == 0) {\n                // make sure 0 has the right sign\n                if ((bits & 0x8000000000000000L) != 0) {\n                    sign = -1;\n                }\n                return;\n            }\n\n            exponent++;\n\n            // Normalize the subnormal number\n            while ( (mantissa & 0x0010000000000000L) == 0) {\n                exponent--;\n                mantissa <<= 1;\n            }\n            mantissa &= 0x000fffffffffffffL;\n        }\n\n        if (exponent == 1024) {\n            // infinity or NAN\n            if (x != x) {\n                sign = (byte) 1;\n                nans = QNAN;\n            } else if (x < 0) {\n                sign = (byte) -1;\n                nans = INFINITE;\n            } else {\n                sign = (byte) 1;\n                nans = INFINITE;\n            }\n            return;\n        }\n\n        Dfp xdfp = new Dfp(field, mantissa);\n        xdfp = xdfp.divide(new Dfp(field, 4503599627370496l)).add(field.getOne());  // Divide by 2^52, then add one\n        xdfp = xdfp.multiply(DfpMath.pow(field.getTwo(), exponent));\n\n        if ((bits & 0x8000000000000000L) != 0) {\n            xdfp = xdfp.negate();\n        }\n\n        System.arraycopy(xdfp.mant, 0, mant, 0, mant.length);\n        sign = xdfp.sign;\n        exp  = xdfp.exp;\n        nans = xdfp.nans;\n\n}\n    }",
          "53": "    protected Dfp(final DfpField field, double x) {\n\n        // initialize as if 0\n        mant = new int[field.getRadixDigits()];\n        sign = 1;\n        exp = 0;\n        nans = FINITE;\n        this.field = field;\n\n        long bits = Double.doubleToLongBits(x);\n        long mantissa = bits & 0x000fffffffffffffL;\nshiftRight();\n        int exponent = (int) ((bits | 9218868437227405312L) >> 52) - 1023;\n        if (exponent == -1023) {\n            // Zero or sub-normal\n            if (x == 0) {\n                // make sure 0 has the right sign\n                if ((bits & 0x8000000000000000L) != 0) {\n                    sign = -1;\n                }\n                return;\n            }\n\n            exponent++;\n\n            // Normalize the subnormal number\n            while ( (mantissa & 0x0010000000000000L) == 0) {\n                exponent--;\n                mantissa <<= 1;\n            }\n            mantissa &= 0x000fffffffffffffL;\n        }\n\n        if (exponent == 1024) {\n            // infinity or NAN\n            if (x != x) {\n                sign = (byte) 1;\n                nans = QNAN;\n            } else if (x < 0) {\n                sign = (byte) -1;\n                nans = INFINITE;\n            } else {\n                sign = (byte) 1;\n                nans = INFINITE;\n            }\n            return;\n        }\n\n        Dfp xdfp = new Dfp(field, mantissa);\n        xdfp = xdfp.divide(new Dfp(field, 4503599627370496l)).add(field.getOne());  // Divide by 2^52, then add one\n        xdfp = xdfp.multiply(DfpMath.pow(field.getTwo(), exponent));\n\n        if ((bits & 0x8000000000000000L) != 0) {\n            xdfp = xdfp.negate();\n        }\n\n        System.arraycopy(xdfp.mant, 0, mant, 0, mant.length);\n        sign = xdfp.sign;\n        exp  = xdfp.exp;\n        nans = xdfp.nans;\n\n}\n    }",
          "54": "    protected Dfp(final DfpField field, double x) {\n\n        // initialize as if 0\n        mant = new int[field.getRadixDigits()];\n        sign = 1;\n        exp = 0;\n        nans = FINITE;\n        this.field = field;\n\n        long bits = Double.doubleToLongBits(x);\n        long mantissa = bits & 0x000fffffffffffffL;\nint exponent = ((int)((bits | 9218868437227405312L) >> 52) >= 1023);\n\n        if (exponent == -1023) {\n            // Zero or sub-normal\n            if (x == 0) {\n                // make sure 0 has the right sign\n                if ((bits & 0x8000000000000000L) != 0) {\n                    sign = -1;\n                }\n                return;\n            }\n\n            exponent++;\n\n            // Normalize the subnormal number\n            while ( (mantissa & 0x0010000000000000L) == 0) {\n                exponent--;\n                mantissa <<= 1;\n            }\n            mantissa &= 0x000fffffffffffffL;\n        }\n\n        if (exponent == 1024) {\n            // infinity or NAN\n            if (x != x) {\n                sign = (byte) 1;\n                nans = QNAN;\n            } else if (x < 0) {\n                sign = (byte) -1;\n                nans = INFINITE;\n            } else {\n                sign = (byte) 1;\n                nans = INFINITE;\n            }\n            return;\n        }\n\n        Dfp xdfp = new Dfp(field, mantissa);\n        xdfp = xdfp.divide(new Dfp(field, 4503599627370496l)).add(field.getOne());  // Divide by 2^52, then add one\n        xdfp = xdfp.multiply(DfpMath.pow(field.getTwo(), exponent));\n\n        if ((bits & 0x8000000000000000L) != 0) {\n            xdfp = xdfp.negate();\n        }\n\n        System.arraycopy(xdfp.mant, 0, mant, 0, mant.length);\n        sign = xdfp.sign;\n        exp  = xdfp.exp;\n        nans = xdfp.nans;\n\n    }",
          "55": "    protected Dfp(final DfpField field, double x) {\n\n        // initialize as if 0\n        mant = new int[field.getRadixDigits()];\n        sign = 1;\n        exp = 0;\n        nans = FINITE;\n        this.field = field;\n\n        long bits = Double.doubleToLongBits(x);\n        long mantissa = bits & 0x000fffffffffffffL;\nint exponent = ((int)((bits >>> 9218868437227405312L) >> 52) - 1023);\n\n        if (exponent == -1023) {\n            // Zero or sub-normal\n            if (x == 0) {\n                // make sure 0 has the right sign\n                if ((bits & 0x8000000000000000L) != 0) {\n                    sign = -1;\n                }\n                return;\n            }\n\n            exponent++;\n\n            // Normalize the subnormal number\n            while ( (mantissa & 0x0010000000000000L) == 0) {\n                exponent--;\n                mantissa <<= 1;\n            }\n            mantissa &= 0x000fffffffffffffL;\n        }\n\n        if (exponent == 1024) {\n            // infinity or NAN\n            if (x != x) {\n                sign = (byte) 1;\n                nans = QNAN;\n            } else if (x < 0) {\n                sign = (byte) -1;\n                nans = INFINITE;\n            } else {\n                sign = (byte) 1;\n                nans = INFINITE;\n            }\n            return;\n        }\n\n        Dfp xdfp = new Dfp(field, mantissa);\n        xdfp = xdfp.divide(new Dfp(field, 4503599627370496l)).add(field.getOne());  // Divide by 2^52, then add one\n        xdfp = xdfp.multiply(DfpMath.pow(field.getTwo(), exponent));\n\n        if ((bits & 0x8000000000000000L) != 0) {\n            xdfp = xdfp.negate();\n        }\n\n        System.arraycopy(xdfp.mant, 0, mant, 0, mant.length);\n        sign = xdfp.sign;\n        exp  = xdfp.exp;\n        nans = xdfp.nans;\n\n    }",
          "56": "    protected Dfp(final DfpField field, double x) {\n\n        // initialize as if 0\n        mant = new int[field.getRadixDigits()];\n        sign = 1;\n        exp = 0;\n        nans = FINITE;\n        this.field = field;\n\n        long bits = Double.doubleToLongBits(x);\n        long mantissa = bits & 0x000fffffffffffffL;\nlong exponent = ((int)((bits | 9218868437227405312L) >> 52) - 1023);\n\n        if (exponent == -1023) {\n            // Zero or sub-normal\n            if (x == 0) {\n                // make sure 0 has the right sign\n                if ((bits & 0x8000000000000000L) != 0) {\n                    sign = -1;\n                }\n                return;\n            }\n\n            exponent++;\n\n            // Normalize the subnormal number\n            while ( (mantissa & 0x0010000000000000L) == 0) {\n                exponent--;\n                mantissa <<= 1;\n            }\n            mantissa &= 0x000fffffffffffffL;\n        }\n\n        if (exponent == 1024) {\n            // infinity or NAN\n            if (x != x) {\n                sign = (byte) 1;\n                nans = QNAN;\n            } else if (x < 0) {\n                sign = (byte) -1;\n                nans = INFINITE;\n            } else {\n                sign = (byte) 1;\n                nans = INFINITE;\n            }\n            return;\n        }\n\n        Dfp xdfp = new Dfp(field, mantissa);\n        xdfp = xdfp.divide(new Dfp(field, 4503599627370496l)).add(field.getOne());  // Divide by 2^52, then add one\n        xdfp = xdfp.multiply(DfpMath.pow(field.getTwo(), exponent));\n\n        if ((bits & 0x8000000000000000L) != 0) {\n            xdfp = xdfp.negate();\n        }\n\n        System.arraycopy(xdfp.mant, 0, mant, 0, mant.length);\n        sign = xdfp.sign;\n        exp  = xdfp.exp;\n        nans = xdfp.nans;\n\n    }",
          "57": "    protected Dfp(final DfpField field, double x) {\n\n        // initialize as if 0\n        mant = new int[field.getRadixDigits()];\n        sign = 1;\n        exp = 0;\n        nans = FINITE;\n        this.field = field;\n\n        long bits = Double.doubleToLongBits(x);\n        long mantissa = bits & 0x000fffffffffffffL;\nint exponent = ((int)((bits < 9218868437227405312L) >> 52) - 1023);\n\n        if (exponent == -1023) {\n            // Zero or sub-normal\n            if (x == 0) {\n                // make sure 0 has the right sign\n                if ((bits & 0x8000000000000000L) != 0) {\n                    sign = -1;\n                }\n                return;\n            }\n\n            exponent++;\n\n            // Normalize the subnormal number\n            while ( (mantissa & 0x0010000000000000L) == 0) {\n                exponent--;\n                mantissa <<= 1;\n            }\n            mantissa &= 0x000fffffffffffffL;\n        }\n\n        if (exponent == 1024) {\n            // infinity or NAN\n            if (x != x) {\n                sign = (byte) 1;\n                nans = QNAN;\n            } else if (x < 0) {\n                sign = (byte) -1;\n                nans = INFINITE;\n            } else {\n                sign = (byte) 1;\n                nans = INFINITE;\n            }\n            return;\n        }\n\n        Dfp xdfp = new Dfp(field, mantissa);\n        xdfp = xdfp.divide(new Dfp(field, 4503599627370496l)).add(field.getOne());  // Divide by 2^52, then add one\n        xdfp = xdfp.multiply(DfpMath.pow(field.getTwo(), exponent));\n\n        if ((bits & 0x8000000000000000L) != 0) {\n            xdfp = xdfp.negate();\n        }\n\n        System.arraycopy(xdfp.mant, 0, mant, 0, mant.length);\n        sign = xdfp.sign;\n        exp  = xdfp.exp;\n        nans = xdfp.nans;\n\n    }",
          "58": "    protected Dfp(final DfpField field, double x) {\n\n        // initialize as if 0\n        mant = new int[field.getRadixDigits()];\n        sign = 1;\n        exp = 0;\n        nans = FINITE;\n        this.field = field;\n\n        long bits = Double.doubleToLongBits(x);\n        long mantissa = bits & 0x000fffffffffffffL;\nint exponent = ((int)((bits | 9218868437227405312L) >> 52) >> 1023);\n\n        if (exponent == -1023) {\n            // Zero or sub-normal\n            if (x == 0) {\n                // make sure 0 has the right sign\n                if ((bits & 0x8000000000000000L) != 0) {\n                    sign = -1;\n                }\n                return;\n            }\n\n            exponent++;\n\n            // Normalize the subnormal number\n            while ( (mantissa & 0x0010000000000000L) == 0) {\n                exponent--;\n                mantissa <<= 1;\n            }\n            mantissa &= 0x000fffffffffffffL;\n        }\n\n        if (exponent == 1024) {\n            // infinity or NAN\n            if (x != x) {\n                sign = (byte) 1;\n                nans = QNAN;\n            } else if (x < 0) {\n                sign = (byte) -1;\n                nans = INFINITE;\n            } else {\n                sign = (byte) 1;\n                nans = INFINITE;\n            }\n            return;\n        }\n\n        Dfp xdfp = new Dfp(field, mantissa);\n        xdfp = xdfp.divide(new Dfp(field, 4503599627370496l)).add(field.getOne());  // Divide by 2^52, then add one\n        xdfp = xdfp.multiply(DfpMath.pow(field.getTwo(), exponent));\n\n        if ((bits & 0x8000000000000000L) != 0) {\n            xdfp = xdfp.negate();\n        }\n\n        System.arraycopy(xdfp.mant, 0, mant, 0, mant.length);\n        sign = xdfp.sign;\n        exp  = xdfp.exp;\n        nans = xdfp.nans;\n\n    }",
          "59": "    protected Dfp(final DfpField field, double x) {\n\n        // initialize as if 0\n        mant = new int[field.getRadixDigits()];\n        sign = 1;\n        exp = 0;\n        nans = FINITE;\n        this.field = field;\n\n        long bits = Double.doubleToLongBits(x);\n        long mantissa = bits & 0x000fffffffffffffL;\nint exponent = ((int)((bits % 9218868437227405312L) >> 52) - 1023);\n\n        if (exponent == -1023) {\n            // Zero or sub-normal\n            if (x == 0) {\n                // make sure 0 has the right sign\n                if ((bits & 0x8000000000000000L) != 0) {\n                    sign = -1;\n                }\n                return;\n            }\n\n            exponent++;\n\n            // Normalize the subnormal number\n            while ( (mantissa & 0x0010000000000000L) == 0) {\n                exponent--;\n                mantissa <<= 1;\n            }\n            mantissa &= 0x000fffffffffffffL;\n        }\n\n        if (exponent == 1024) {\n            // infinity or NAN\n            if (x != x) {\n                sign = (byte) 1;\n                nans = QNAN;\n            } else if (x < 0) {\n                sign = (byte) -1;\n                nans = INFINITE;\n            } else {\n                sign = (byte) 1;\n                nans = INFINITE;\n            }\n            return;\n        }\n\n        Dfp xdfp = new Dfp(field, mantissa);\n        xdfp = xdfp.divide(new Dfp(field, 4503599627370496l)).add(field.getOne());  // Divide by 2^52, then add one\n        xdfp = xdfp.multiply(DfpMath.pow(field.getTwo(), exponent));\n\n        if ((bits & 0x8000000000000000L) != 0) {\n            xdfp = xdfp.negate();\n        }\n\n        System.arraycopy(xdfp.mant, 0, mant, 0, mant.length);\n        sign = xdfp.sign;\n        exp  = xdfp.exp;\n        nans = xdfp.nans;\n\n    }",
          "60": "    protected Dfp(final DfpField field, double x) {\n\n        // initialize as if 0\n        mant = new int[field.getRadixDigits()];\n        sign = 1;\n        exp = 0;\n        nans = FINITE;\n        this.field = field;\n\n        long bits = Double.doubleToLongBits(x);\n        long mantissa = bits & 0x000fffffffffffffL;\nint exponent = ((int)((bits | 9218868437227405312L) >> 52) > 1023);\n\n        if (exponent == -1023) {\n            // Zero or sub-normal\n            if (x == 0) {\n                // make sure 0 has the right sign\n                if ((bits & 0x8000000000000000L) != 0) {\n                    sign = -1;\n                }\n                return;\n            }\n\n            exponent++;\n\n            // Normalize the subnormal number\n            while ( (mantissa & 0x0010000000000000L) == 0) {\n                exponent--;\n                mantissa <<= 1;\n            }\n            mantissa &= 0x000fffffffffffffL;\n        }\n\n        if (exponent == 1024) {\n            // infinity or NAN\n            if (x != x) {\n                sign = (byte) 1;\n                nans = QNAN;\n            } else if (x < 0) {\n                sign = (byte) -1;\n                nans = INFINITE;\n            } else {\n                sign = (byte) 1;\n                nans = INFINITE;\n            }\n            return;\n        }\n\n        Dfp xdfp = new Dfp(field, mantissa);\n        xdfp = xdfp.divide(new Dfp(field, 4503599627370496l)).add(field.getOne());  // Divide by 2^52, then add one\n        xdfp = xdfp.multiply(DfpMath.pow(field.getTwo(), exponent));\n\n        if ((bits & 0x8000000000000000L) != 0) {\n            xdfp = xdfp.negate();\n        }\n\n        System.arraycopy(xdfp.mant, 0, mant, 0, mant.length);\n        sign = xdfp.sign;\n        exp  = xdfp.exp;\n        nans = xdfp.nans;\n\n    }",
          "61": "    protected Dfp(final DfpField field, double x) {\n\n        // initialize as if 0\n        mant = new int[field.getRadixDigits()];\n        sign = 1;\n        exp = 0;\n        nans = FINITE;\n        this.field = field;\n\n        long bits = Double.doubleToLongBits(x);\n        long mantissa = bits & 0x000fffffffffffffL;\nint exponent = ((int)((bits | 9218868437227405312L) >> 52) >>> 1023);\n\n        if (exponent == -1023) {\n            // Zero or sub-normal\n            if (x == 0) {\n                // make sure 0 has the right sign\n                if ((bits & 0x8000000000000000L) != 0) {\n                    sign = -1;\n                }\n                return;\n            }\n\n            exponent++;\n\n            // Normalize the subnormal number\n            while ( (mantissa & 0x0010000000000000L) == 0) {\n                exponent--;\n                mantissa <<= 1;\n            }\n            mantissa &= 0x000fffffffffffffL;\n        }\n\n        if (exponent == 1024) {\n            // infinity or NAN\n            if (x != x) {\n                sign = (byte) 1;\n                nans = QNAN;\n            } else if (x < 0) {\n                sign = (byte) -1;\n                nans = INFINITE;\n            } else {\n                sign = (byte) 1;\n                nans = INFINITE;\n            }\n            return;\n        }\n\n        Dfp xdfp = new Dfp(field, mantissa);\n        xdfp = xdfp.divide(new Dfp(field, 4503599627370496l)).add(field.getOne());  // Divide by 2^52, then add one\n        xdfp = xdfp.multiply(DfpMath.pow(field.getTwo(), exponent));\n\n        if ((bits & 0x8000000000000000L) != 0) {\n            xdfp = xdfp.negate();\n        }\n\n        System.arraycopy(xdfp.mant, 0, mant, 0, mant.length);\n        sign = xdfp.sign;\n        exp  = xdfp.exp;\n        nans = xdfp.nans;\n\n    }",
          "62": "    protected Dfp(final DfpField field, double x) {\n\n        // initialize as if 0\n        mant = new int[field.getRadixDigits()];\n        sign = 1;\n        exp = 0;\n        nans = FINITE;\n        this.field = field;\n\n        long bits = Double.doubleToLongBits(x);\n        long mantissa = bits & 0x000fffffffffffffL;\nreturn;\n        int exponent = (int) ((bits | 9218868437227405312L) >> 52) - 1023;\n        if (exponent == -1023) {\n            // Zero or sub-normal\n            if (x == 0) {\n                // make sure 0 has the right sign\n                if ((bits & 0x8000000000000000L) != 0) {\n                    sign = -1;\n                }\n                return;\n            }\n\n            exponent++;\n\n            // Normalize the subnormal number\n            while ( (mantissa & 0x0010000000000000L) == 0) {\n                exponent--;\n                mantissa <<= 1;\n            }\n            mantissa &= 0x000fffffffffffffL;\n        }\n\n        if (exponent == 1024) {\n            // infinity or NAN\n            if (x != x) {\n                sign = (byte) 1;\n                nans = QNAN;\n            } else if (x < 0) {\n                sign = (byte) -1;\n                nans = INFINITE;\n            } else {\n                sign = (byte) 1;\n                nans = INFINITE;\n            }\n            return;\n        }\n\n        Dfp xdfp = new Dfp(field, mantissa);\n        xdfp = xdfp.divide(new Dfp(field, 4503599627370496l)).add(field.getOne());  // Divide by 2^52, then add one\n        xdfp = xdfp.multiply(DfpMath.pow(field.getTwo(), exponent));\n\n        if ((bits & 0x8000000000000000L) != 0) {\n            xdfp = xdfp.negate();\n        }\n\n        System.arraycopy(xdfp.mant, 0, mant, 0, mant.length);\n        sign = xdfp.sign;\n        exp  = xdfp.exp;\n        nans = xdfp.nans;\n\n    }",
          "63": "    protected Dfp(final DfpField field, double x) {\n\n        // initialize as if 0\n        mant = new int[field.getRadixDigits()];\n        sign = 1;\n        exp = 0;\n        nans = FINITE;\n        this.field = field;\n\n        long bits = Double.doubleToLongBits(x);\n        long mantissa = bits & 0x000fffffffffffffL;\n        int exponent = (int) ((bits | 9218868437227405312L) >> 52) - 1023;\n        if (exponent == -1023) {\n            // Zero or sub-normal\n            if (x == 0) {\n                // make sure 0 has the right sign\n                if ((bits & 0x8000000000000000L) != 0) {\n                    sign = -1;\n                }\n                return;\n            }\n\n            exponent++;\n\n            // Normalize the subnormal number\n            while ( (mantissa & 0x0010000000000000L) == 0) {\n                exponent--;\n                mantissa <<= 1;\n            }\n            mantissa &= 0x000fffffffffffffL;\n        }\n\n        if (exponent == 1024) {\n            // infinity or NAN\n            if (x != x) {\n                sign = (byte) 1;\n                nans = QNAN;\n            } else if (x < 0) {\n                sign = (byte) -1;\n                nans = INFINITE;\n            } else {\n                sign = (byte) 1;\n                nans = INFINITE;\n            }\n            return;\n        }\n\n        Dfp xdfp = new Dfp(field, mantissa);\n        xdfp = xdfp.divide(new Dfp(field, 4503599627370496l)).add(field.getOne());  // Divide by 2^52, then add one\n        xdfp = xdfp.multiply(DfpMath.pow(field.getTwo(), exponent));\n\n        if ((bits & 0x8000000000000000L) != 0) {\n            xdfp = xdfp.negate();\n        }\n\n        System.arraycopy(xdfp.mant, 0, mant, 0, mant.length);\n        sign = xdfp.sign;\n        exp  = xdfp.exp;\n        nans = xdfp.nans;\n\n    }",
          "64": "    protected Dfp(final DfpField field, double x) {\n\n        // initialize as if 0\n        mant = new int[field.getRadixDigits()];\n        sign = 1;\n        exp = 0;\n        nans = FINITE;\n        this.field = field;\n\n        long bits = Double.doubleToLongBits(x);\n        long mantissa = bits & 0x000fffffffffffffL;\nint exponent = ((bits > 0))?((bits | 9218868437227405312L) >> 52):0;\n\n        if (exponent == -1023) {\n            // Zero or sub-normal\n            if (x == 0) {\n                // make sure 0 has the right sign\n                if ((bits & 0x8000000000000000L) != 0) {\n                    sign = -1;\n                }\n                return;\n            }\n\n            exponent++;\n\n            // Normalize the subnormal number\n            while ( (mantissa & 0x0010000000000000L) == 0) {\n                exponent--;\n                mantissa <<= 1;\n            }\n            mantissa &= 0x000fffffffffffffL;\n        }\n\n        if (exponent == 1024) {\n            // infinity or NAN\n            if (x != x) {\n                sign = (byte) 1;\n                nans = QNAN;\n            } else if (x < 0) {\n                sign = (byte) -1;\n                nans = INFINITE;\n            } else {\n                sign = (byte) 1;\n                nans = INFINITE;\n            }\n            return;\n        }\n\n        Dfp xdfp = new Dfp(field, mantissa);\n        xdfp = xdfp.divide(new Dfp(field, 4503599627370496l)).add(field.getOne());  // Divide by 2^52, then add one\n        xdfp = xdfp.multiply(DfpMath.pow(field.getTwo(), exponent));\n\n        if ((bits & 0x8000000000000000L) != 0) {\n            xdfp = xdfp.negate();\n        }\n\n        System.arraycopy(xdfp.mant, 0, mant, 0, mant.length);\n        sign = xdfp.sign;\n        exp  = xdfp.exp;\n        nans = xdfp.nans;\n\n    }",
          "65": "    protected Dfp(final DfpField field, double x) {\n\n        // initialize as if 0\n        mant = new int[field.getRadixDigits()];\n        sign = 1;\n        exp = 0;\n        nans = FINITE;\n        this.field = field;\n\n        long bits = Double.doubleToLongBits(x);\n        long mantissa = bits & 0x000fffffffffffffL;\nint exponent = ((bits > 0))?((int)((bits | 9218868437227405312L) >> 52) - 1023):0;\n\n        if (exponent == -1023) {\n            // Zero or sub-normal\n            if (x == 0) {\n                // make sure 0 has the right sign\n                if ((bits & 0x8000000000000000L) != 0) {\n                    sign = -1;\n                }\n                return;\n            }\n\n            exponent++;\n\n            // Normalize the subnormal number\n            while ( (mantissa & 0x0010000000000000L) == 0) {\n                exponent--;\n                mantissa <<= 1;\n            }\n            mantissa &= 0x000fffffffffffffL;\n        }\n\n        if (exponent == 1024) {\n            // infinity or NAN\n            if (x != x) {\n                sign = (byte) 1;\n                nans = QNAN;\n            } else if (x < 0) {\n                sign = (byte) -1;\n                nans = INFINITE;\n            } else {\n                sign = (byte) 1;\n                nans = INFINITE;\n            }\n            return;\n        }\n\n        Dfp xdfp = new Dfp(field, mantissa);\n        xdfp = xdfp.divide(new Dfp(field, 4503599627370496l)).add(field.getOne());  // Divide by 2^52, then add one\n        xdfp = xdfp.multiply(DfpMath.pow(field.getTwo(), exponent));\n\n        if ((bits & 0x8000000000000000L) != 0) {\n            xdfp = xdfp.negate();\n        }\n\n        System.arraycopy(xdfp.mant, 0, mant, 0, mant.length);\n        sign = xdfp.sign;\n        exp  = xdfp.exp;\n        nans = xdfp.nans;\n\n    }",
          "66": "    protected Dfp(final DfpField field, double x) {\n\n        // initialize as if 0\n        mant = new int[field.getRadixDigits()];\n        sign = 1;\n        exp = 0;\n        nans = FINITE;\n        this.field = field;\n\n        long bits = Double.doubleToLongBits(x);\n        long mantissa = bits & 0x000fffffffffffffL;\nint exponent = ((bits > bits))?((bits | 9218868437227405312L) >> 52):0;\n\n        if (exponent == -1023) {\n            // Zero or sub-normal\n            if (x == 0) {\n                // make sure 0 has the right sign\n                if ((bits & 0x8000000000000000L) != 0) {\n                    sign = -1;\n                }\n                return;\n            }\n\n            exponent++;\n\n            // Normalize the subnormal number\n            while ( (mantissa & 0x0010000000000000L) == 0) {\n                exponent--;\n                mantissa <<= 1;\n            }\n            mantissa &= 0x000fffffffffffffL;\n        }\n\n        if (exponent == 1024) {\n            // infinity or NAN\n            if (x != x) {\n                sign = (byte) 1;\n                nans = QNAN;\n            } else if (x < 0) {\n                sign = (byte) -1;\n                nans = INFINITE;\n            } else {\n                sign = (byte) 1;\n                nans = INFINITE;\n            }\n            return;\n        }\n\n        Dfp xdfp = new Dfp(field, mantissa);\n        xdfp = xdfp.divide(new Dfp(field, 4503599627370496l)).add(field.getOne());  // Divide by 2^52, then add one\n        xdfp = xdfp.multiply(DfpMath.pow(field.getTwo(), exponent));\n\n        if ((bits & 0x8000000000000000L) != 0) {\n            xdfp = xdfp.negate();\n        }\n\n        System.arraycopy(xdfp.mant, 0, mant, 0, mant.length);\n        sign = xdfp.sign;\n        exp  = xdfp.exp;\n        nans = xdfp.nans;\n\n    }",
          "67": "    protected Dfp(final DfpField field, double x) {\n\n        // initialize as if 0\n        mant = new int[field.getRadixDigits()];\n        sign = 1;\n        exp = 0;\n        nans = FINITE;\n        this.field = field;\n\n        long bits = Double.doubleToLongBits(x);\n        long mantissa = bits & 0x000fffffffffffffL;\nint exponent = ((bits < bits))?((bits | 9218868437227405312L) >> 52):0;\n\n        if (exponent == -1023) {\n            // Zero or sub-normal\n            if (x == 0) {\n                // make sure 0 has the right sign\n                if ((bits & 0x8000000000000000L) != 0) {\n                    sign = -1;\n                }\n                return;\n            }\n\n            exponent++;\n\n            // Normalize the subnormal number\n            while ( (mantissa & 0x0010000000000000L) == 0) {\n                exponent--;\n                mantissa <<= 1;\n            }\n            mantissa &= 0x000fffffffffffffL;\n        }\n\n        if (exponent == 1024) {\n            // infinity or NAN\n            if (x != x) {\n                sign = (byte) 1;\n                nans = QNAN;\n            } else if (x < 0) {\n                sign = (byte) -1;\n                nans = INFINITE;\n            } else {\n                sign = (byte) 1;\n                nans = INFINITE;\n            }\n            return;\n        }\n\n        Dfp xdfp = new Dfp(field, mantissa);\n        xdfp = xdfp.divide(new Dfp(field, 4503599627370496l)).add(field.getOne());  // Divide by 2^52, then add one\n        xdfp = xdfp.multiply(DfpMath.pow(field.getTwo(), exponent));\n\n        if ((bits & 0x8000000000000000L) != 0) {\n            xdfp = xdfp.negate();\n        }\n\n        System.arraycopy(xdfp.mant, 0, mant, 0, mant.length);\n        sign = xdfp.sign;\n        exp  = xdfp.exp;\n        nans = xdfp.nans;\n\n    }",
          "68": "    protected Dfp(final DfpField field, double x) {\n\n        // initialize as if 0\n        mant = new int[field.getRadixDigits()];\n        sign = 1;\n        exp = 0;\n        nans = FINITE;\n        this.field = field;\n\n        long bits = Double.doubleToLongBits(x);\n        long mantissa = bits & 0x000fffffffffffffL;\nint exponent = ((bits > 0))?bits:((int)((bits | 9218868437227405312L) >> 52) - 1023);\n\n        if (exponent == -1023) {\n            // Zero or sub-normal\n            if (x == 0) {\n                // make sure 0 has the right sign\n                if ((bits & 0x8000000000000000L) != 0) {\n                    sign = -1;\n                }\n                return;\n            }\n\n            exponent++;\n\n            // Normalize the subnormal number\n            while ( (mantissa & 0x0010000000000000L) == 0) {\n                exponent--;\n                mantissa <<= 1;\n            }\n            mantissa &= 0x000fffffffffffffL;\n        }\n\n        if (exponent == 1024) {\n            // infinity or NAN\n            if (x != x) {\n                sign = (byte) 1;\n                nans = QNAN;\n            } else if (x < 0) {\n                sign = (byte) -1;\n                nans = INFINITE;\n            } else {\n                sign = (byte) 1;\n                nans = INFINITE;\n            }\n            return;\n        }\n\n        Dfp xdfp = new Dfp(field, mantissa);\n        xdfp = xdfp.divide(new Dfp(field, 4503599627370496l)).add(field.getOne());  // Divide by 2^52, then add one\n        xdfp = xdfp.multiply(DfpMath.pow(field.getTwo(), exponent));\n\n        if ((bits & 0x8000000000000000L) != 0) {\n            xdfp = xdfp.negate();\n        }\n\n        System.arraycopy(xdfp.mant, 0, mant, 0, mant.length);\n        sign = xdfp.sign;\n        exp  = xdfp.exp;\n        nans = xdfp.nans;\n\n    }",
          "69": "    protected Dfp(final DfpField field, double x) {\n\n        // initialize as if 0\n        mant = new int[field.getRadixDigits()];\n        sign = 1;\n        exp = 0;\n        nans = FINITE;\n        this.field = field;\n\n        long bits = Double.doubleToLongBits(x);\n        long mantissa = bits & 0x000fffffffffffffL;\nint exponent = ((bits > bits))?bits:((int)((bits | 9218868437227405312L) >> 52) - 1023);\n\n        if (exponent == -1023) {\n            // Zero or sub-normal\n            if (x == 0) {\n                // make sure 0 has the right sign\n                if ((bits & 0x8000000000000000L) != 0) {\n                    sign = -1;\n                }\n                return;\n            }\n\n            exponent++;\n\n            // Normalize the subnormal number\n            while ( (mantissa & 0x0010000000000000L) == 0) {\n                exponent--;\n                mantissa <<= 1;\n            }\n            mantissa &= 0x000fffffffffffffL;\n        }\n\n        if (exponent == 1024) {\n            // infinity or NAN\n            if (x != x) {\n                sign = (byte) 1;\n                nans = QNAN;\n            } else if (x < 0) {\n                sign = (byte) -1;\n                nans = INFINITE;\n            } else {\n                sign = (byte) 1;\n                nans = INFINITE;\n            }\n            return;\n        }\n\n        Dfp xdfp = new Dfp(field, mantissa);\n        xdfp = xdfp.divide(new Dfp(field, 4503599627370496l)).add(field.getOne());  // Divide by 2^52, then add one\n        xdfp = xdfp.multiply(DfpMath.pow(field.getTwo(), exponent));\n\n        if ((bits & 0x8000000000000000L) != 0) {\n            xdfp = xdfp.negate();\n        }\n\n        System.arraycopy(xdfp.mant, 0, mant, 0, mant.length);\n        sign = xdfp.sign;\n        exp  = xdfp.exp;\n        nans = xdfp.nans;\n\n    }",
          "70": "    protected Dfp(final DfpField field, double x) {\n\n        // initialize as if 0\n        mant = new int[field.getRadixDigits()];\n        sign = 1;\n        exp = 0;\n        nans = FINITE;\n        this.field = field;\n\n        long bits = Double.doubleToLongBits(x);\n        long mantissa = bits & 0x000fffffffffffffL;\nint exponent = ((bits < bits))?bits:0;\n\n        if (exponent == -1023) {\n            // Zero or sub-normal\n            if (x == 0) {\n                // make sure 0 has the right sign\n                if ((bits & 0x8000000000000000L) != 0) {\n                    sign = -1;\n                }\n                return;\n            }\n\n            exponent++;\n\n            // Normalize the subnormal number\n            while ( (mantissa & 0x0010000000000000L) == 0) {\n                exponent--;\n                mantissa <<= 1;\n            }\n            mantissa &= 0x000fffffffffffffL;\n        }\n\n        if (exponent == 1024) {\n            // infinity or NAN\n            if (x != x) {\n                sign = (byte) 1;\n                nans = QNAN;\n            } else if (x < 0) {\n                sign = (byte) -1;\n                nans = INFINITE;\n            } else {\n                sign = (byte) 1;\n                nans = INFINITE;\n            }\n            return;\n        }\n\n        Dfp xdfp = new Dfp(field, mantissa);\n        xdfp = xdfp.divide(new Dfp(field, 4503599627370496l)).add(field.getOne());  // Divide by 2^52, then add one\n        xdfp = xdfp.multiply(DfpMath.pow(field.getTwo(), exponent));\n\n        if ((bits & 0x8000000000000000L) != 0) {\n            xdfp = xdfp.negate();\n        }\n\n        System.arraycopy(xdfp.mant, 0, mant, 0, mant.length);\n        sign = xdfp.sign;\n        exp  = xdfp.exp;\n        nans = xdfp.nans;\n\n    }",
          "71": "    protected Dfp(final DfpField field, double x) {\n\n        // initialize as if 0\n        mant = new int[field.getRadixDigits()];\n        sign = 1;\n        exp = 0;\n        nans = FINITE;\n        this.field = field;\n\n        long bits = Double.doubleToLongBits(x);\n        long mantissa = bits & 0x000fffffffffffffL;\nint exponent = ((bits > bits))?bits:0;\n\n        if (exponent == -1023) {\n            // Zero or sub-normal\n            if (x == 0) {\n                // make sure 0 has the right sign\n                if ((bits & 0x8000000000000000L) != 0) {\n                    sign = -1;\n                }\n                return;\n            }\n\n            exponent++;\n\n            // Normalize the subnormal number\n            while ( (mantissa & 0x0010000000000000L) == 0) {\n                exponent--;\n                mantissa <<= 1;\n            }\n            mantissa &= 0x000fffffffffffffL;\n        }\n\n        if (exponent == 1024) {\n            // infinity or NAN\n            if (x != x) {\n                sign = (byte) 1;\n                nans = QNAN;\n            } else if (x < 0) {\n                sign = (byte) -1;\n                nans = INFINITE;\n            } else {\n                sign = (byte) 1;\n                nans = INFINITE;\n            }\n            return;\n        }\n\n        Dfp xdfp = new Dfp(field, mantissa);\n        xdfp = xdfp.divide(new Dfp(field, 4503599627370496l)).add(field.getOne());  // Divide by 2^52, then add one\n        xdfp = xdfp.multiply(DfpMath.pow(field.getTwo(), exponent));\n\n        if ((bits & 0x8000000000000000L) != 0) {\n            xdfp = xdfp.negate();\n        }\n\n        System.arraycopy(xdfp.mant, 0, mant, 0, mant.length);\n        sign = xdfp.sign;\n        exp  = xdfp.exp;\n        nans = xdfp.nans;\n\n    }",
          "72": "    protected Dfp(final DfpField field, double x) {\n\n        // initialize as if 0\n        mant = new int[field.getRadixDigits()];\n        sign = 1;\n        exp = 0;\n        nans = FINITE;\n        this.field = field;\n\n        long bits = Double.doubleToLongBits(x);\n        long mantissa = bits & 0x000fffffffffffffL;\nint exponent = ((bits > bits))?bits:bits;\n\n        if (exponent == -1023) {\n            // Zero or sub-normal\n            if (x == 0) {\n                // make sure 0 has the right sign\n                if ((bits & 0x8000000000000000L) != 0) {\n                    sign = -1;\n                }\n                return;\n            }\n\n            exponent++;\n\n            // Normalize the subnormal number\n            while ( (mantissa & 0x0010000000000000L) == 0) {\n                exponent--;\n                mantissa <<= 1;\n            }\n            mantissa &= 0x000fffffffffffffL;\n        }\n\n        if (exponent == 1024) {\n            // infinity or NAN\n            if (x != x) {\n                sign = (byte) 1;\n                nans = QNAN;\n            } else if (x < 0) {\n                sign = (byte) -1;\n                nans = INFINITE;\n            } else {\n                sign = (byte) 1;\n                nans = INFINITE;\n            }\n            return;\n        }\n\n        Dfp xdfp = new Dfp(field, mantissa);\n        xdfp = xdfp.divide(new Dfp(field, 4503599627370496l)).add(field.getOne());  // Divide by 2^52, then add one\n        xdfp = xdfp.multiply(DfpMath.pow(field.getTwo(), exponent));\n\n        if ((bits & 0x8000000000000000L) != 0) {\n            xdfp = xdfp.negate();\n        }\n\n        System.arraycopy(xdfp.mant, 0, mant, 0, mant.length);\n        sign = xdfp.sign;\n        exp  = xdfp.exp;\n        nans = xdfp.nans;\n\n    }",
          "73": "    protected Dfp(final DfpField field, double x) {\n\n        // initialize as if 0\n        mant = new int[field.getRadixDigits()];\n        sign = 1;\n        exp = 0;\n        nans = FINITE;\n        this.field = field;\n\n        long bits = Double.doubleToLongBits(x);\n        long mantissa = bits & 0x000fffffffffffffL;\nint exponent = ((bits < bits))?bits:bits;\n\n        if (exponent == -1023) {\n            // Zero or sub-normal\n            if (x == 0) {\n                // make sure 0 has the right sign\n                if ((bits & 0x8000000000000000L) != 0) {\n                    sign = -1;\n                }\n                return;\n            }\n\n            exponent++;\n\n            // Normalize the subnormal number\n            while ( (mantissa & 0x0010000000000000L) == 0) {\n                exponent--;\n                mantissa <<= 1;\n            }\n            mantissa &= 0x000fffffffffffffL;\n        }\n\n        if (exponent == 1024) {\n            // infinity or NAN\n            if (x != x) {\n                sign = (byte) 1;\n                nans = QNAN;\n            } else if (x < 0) {\n                sign = (byte) -1;\n                nans = INFINITE;\n            } else {\n                sign = (byte) 1;\n                nans = INFINITE;\n            }\n            return;\n        }\n\n        Dfp xdfp = new Dfp(field, mantissa);\n        xdfp = xdfp.divide(new Dfp(field, 4503599627370496l)).add(field.getOne());  // Divide by 2^52, then add one\n        xdfp = xdfp.multiply(DfpMath.pow(field.getTwo(), exponent));\n\n        if ((bits & 0x8000000000000000L) != 0) {\n            xdfp = xdfp.negate();\n        }\n\n        System.arraycopy(xdfp.mant, 0, mant, 0, mant.length);\n        sign = xdfp.sign;\n        exp  = xdfp.exp;\n        nans = xdfp.nans;\n\n    }",
          "74": "    protected Dfp(final DfpField field, double x) {\n\n        // initialize as if 0\n        mant = new int[field.getRadixDigits()];\n        sign = 1;\n        exp = 0;\n        nans = FINITE;\n        this.field = field;\n\n        long bits = Double.doubleToLongBits(x);\n        long mantissa = bits & 0x000fffffffffffffL;\nint exponent = (((bits > bits) && (bits == bits)))?bits:((int)((bits | 9218868437227405312L) >> 52) - 1023);\n\n        if (exponent == -1023) {\n            // Zero or sub-normal\n            if (x == 0) {\n                // make sure 0 has the right sign\n                if ((bits & 0x8000000000000000L) != 0) {\n                    sign = -1;\n                }\n                return;\n            }\n\n            exponent++;\n\n            // Normalize the subnormal number\n            while ( (mantissa & 0x0010000000000000L) == 0) {\n                exponent--;\n                mantissa <<= 1;\n            }\n            mantissa &= 0x000fffffffffffffL;\n        }\n\n        if (exponent == 1024) {\n            // infinity or NAN\n            if (x != x) {\n                sign = (byte) 1;\n                nans = QNAN;\n            } else if (x < 0) {\n                sign = (byte) -1;\n                nans = INFINITE;\n            } else {\n                sign = (byte) 1;\n                nans = INFINITE;\n            }\n            return;\n        }\n\n        Dfp xdfp = new Dfp(field, mantissa);\n        xdfp = xdfp.divide(new Dfp(field, 4503599627370496l)).add(field.getOne());  // Divide by 2^52, then add one\n        xdfp = xdfp.multiply(DfpMath.pow(field.getTwo(), exponent));\n\n        if ((bits & 0x8000000000000000L) != 0) {\n            xdfp = xdfp.negate();\n        }\n\n        System.arraycopy(xdfp.mant, 0, mant, 0, mant.length);\n        sign = xdfp.sign;\n        exp  = xdfp.exp;\n        nans = xdfp.nans;\n\n    }",
          "75": "    protected Dfp(final DfpField field, double x) {\n\n        // initialize as if 0\n        mant = new int[field.getRadixDigits()];\n        sign = 1;\n        exp = 0;\n        nans = FINITE;\n        this.field = field;\n\n        long bits = Double.doubleToLongBits(x);\n        long mantissa = bits & 0x000fffffffffffffL;\nint exponent = (((bits > bits) && (bits != bits)))?bits:((int)((bits | 9218868437227405312L) >> 52) - 1023);\n\n        if (exponent == -1023) {\n            // Zero or sub-normal\n            if (x == 0) {\n                // make sure 0 has the right sign\n                if ((bits & 0x8000000000000000L) != 0) {\n                    sign = -1;\n                }\n                return;\n            }\n\n            exponent++;\n\n            // Normalize the subnormal number\n            while ( (mantissa & 0x0010000000000000L) == 0) {\n                exponent--;\n                mantissa <<= 1;\n            }\n            mantissa &= 0x000fffffffffffffL;\n        }\n\n        if (exponent == 1024) {\n            // infinity or NAN\n            if (x != x) {\n                sign = (byte) 1;\n                nans = QNAN;\n            } else if (x < 0) {\n                sign = (byte) -1;\n                nans = INFINITE;\n            } else {\n                sign = (byte) 1;\n                nans = INFINITE;\n            }\n            return;\n        }\n\n        Dfp xdfp = new Dfp(field, mantissa);\n        xdfp = xdfp.divide(new Dfp(field, 4503599627370496l)).add(field.getOne());  // Divide by 2^52, then add one\n        xdfp = xdfp.multiply(DfpMath.pow(field.getTwo(), exponent));\n\n        if ((bits & 0x8000000000000000L) != 0) {\n            xdfp = xdfp.negate();\n        }\n\n        System.arraycopy(xdfp.mant, 0, mant, 0, mant.length);\n        sign = xdfp.sign;\n        exp  = xdfp.exp;\n        nans = xdfp.nans;\n\n    }",
          "76": "    protected Dfp(final DfpField field, double x) {\n\n        // initialize as if 0\n        mant = new int[field.getRadixDigits()];\n        sign = 1;\n        exp = 0;\n        nans = FINITE;\n        this.field = field;\n\n        long bits = Double.doubleToLongBits(x);\n        long mantissa = bits & 0x000fffffffffffffL;\nint exponent = (((bits > bits) && (bits == bits)))?bits:((bits | 9218868437227405312L) >> 52);\n\n        if (exponent == -1023) {\n            // Zero or sub-normal\n            if (x == 0) {\n                // make sure 0 has the right sign\n                if ((bits & 0x8000000000000000L) != 0) {\n                    sign = -1;\n                }\n                return;\n            }\n\n            exponent++;\n\n            // Normalize the subnormal number\n            while ( (mantissa & 0x0010000000000000L) == 0) {\n                exponent--;\n                mantissa <<= 1;\n            }\n            mantissa &= 0x000fffffffffffffL;\n        }\n\n        if (exponent == 1024) {\n            // infinity or NAN\n            if (x != x) {\n                sign = (byte) 1;\n                nans = QNAN;\n            } else if (x < 0) {\n                sign = (byte) -1;\n                nans = INFINITE;\n            } else {\n                sign = (byte) 1;\n                nans = INFINITE;\n            }\n            return;\n        }\n\n        Dfp xdfp = new Dfp(field, mantissa);\n        xdfp = xdfp.divide(new Dfp(field, 4503599627370496l)).add(field.getOne());  // Divide by 2^52, then add one\n        xdfp = xdfp.multiply(DfpMath.pow(field.getTwo(), exponent));\n\n        if ((bits & 0x8000000000000000L) != 0) {\n            xdfp = xdfp.negate();\n        }\n\n        System.arraycopy(xdfp.mant, 0, mant, 0, mant.length);\n        sign = xdfp.sign;\n        exp  = xdfp.exp;\n        nans = xdfp.nans;\n\n    }",
          "77": "    protected Dfp(final DfpField field, double x) {\n\n        // initialize as if 0\n        mant = new int[field.getRadixDigits()];\n        sign = 1;\n        exp = 0;\n        nans = FINITE;\n        this.field = field;\n\n        long bits = Double.doubleToLongBits(x);\n        long mantissa = bits & 0x000fffffffffffffL;\nint exponent = (((bits > bits) && (bits > bits)))?bits:((int)((bits | 9218868437227405312L) >> 52) - 1023);\n\n        if (exponent == -1023) {\n            // Zero or sub-normal\n            if (x == 0) {\n                // make sure 0 has the right sign\n                if ((bits & 0x8000000000000000L) != 0) {\n                    sign = -1;\n                }\n                return;\n            }\n\n            exponent++;\n\n            // Normalize the subnormal number\n            while ( (mantissa & 0x0010000000000000L) == 0) {\n                exponent--;\n                mantissa <<= 1;\n            }\n            mantissa &= 0x000fffffffffffffL;\n        }\n\n        if (exponent == 1024) {\n            // infinity or NAN\n            if (x != x) {\n                sign = (byte) 1;\n                nans = QNAN;\n            } else if (x < 0) {\n                sign = (byte) -1;\n                nans = INFINITE;\n            } else {\n                sign = (byte) 1;\n                nans = INFINITE;\n            }\n            return;\n        }\n\n        Dfp xdfp = new Dfp(field, mantissa);\n        xdfp = xdfp.divide(new Dfp(field, 4503599627370496l)).add(field.getOne());  // Divide by 2^52, then add one\n        xdfp = xdfp.multiply(DfpMath.pow(field.getTwo(), exponent));\n\n        if ((bits & 0x8000000000000000L) != 0) {\n            xdfp = xdfp.negate();\n        }\n\n        System.arraycopy(xdfp.mant, 0, mant, 0, mant.length);\n        sign = xdfp.sign;\n        exp  = xdfp.exp;\n        nans = xdfp.nans;\n\n    }",
          "78": "    protected Dfp(final DfpField field, double x) {\n\n        // initialize as if 0\n        mant = new int[field.getRadixDigits()];\n        sign = 1;\n        exp = 0;\n        nans = FINITE;\n        this.field = field;\n\n        long bits = Double.doubleToLongBits(x);\n        long mantissa = bits & 0x000fffffffffffffL;\nint exponent = (((bits > bits) && (bits != bits)))?bits:((bits | 9218868437227405312L) >> 52);\n\n        if (exponent == -1023) {\n            // Zero or sub-normal\n            if (x == 0) {\n                // make sure 0 has the right sign\n                if ((bits & 0x8000000000000000L) != 0) {\n                    sign = -1;\n                }\n                return;\n            }\n\n            exponent++;\n\n            // Normalize the subnormal number\n            while ( (mantissa & 0x0010000000000000L) == 0) {\n                exponent--;\n                mantissa <<= 1;\n            }\n            mantissa &= 0x000fffffffffffffL;\n        }\n\n        if (exponent == 1024) {\n            // infinity or NAN\n            if (x != x) {\n                sign = (byte) 1;\n                nans = QNAN;\n            } else if (x < 0) {\n                sign = (byte) -1;\n                nans = INFINITE;\n            } else {\n                sign = (byte) 1;\n                nans = INFINITE;\n            }\n            return;\n        }\n\n        Dfp xdfp = new Dfp(field, mantissa);\n        xdfp = xdfp.divide(new Dfp(field, 4503599627370496l)).add(field.getOne());  // Divide by 2^52, then add one\n        xdfp = xdfp.multiply(DfpMath.pow(field.getTwo(), exponent));\n\n        if ((bits & 0x8000000000000000L) != 0) {\n            xdfp = xdfp.negate();\n        }\n\n        System.arraycopy(xdfp.mant, 0, mant, 0, mant.length);\n        sign = xdfp.sign;\n        exp  = xdfp.exp;\n        nans = xdfp.nans;\n\n    }",
          "79": "    protected Dfp(final DfpField field, double x) {\n\n        // initialize as if 0\n        mant = new int[field.getRadixDigits()];\n        sign = 1;\n        exp = 0;\n        nans = FINITE;\n        this.field = field;\n\n        long bits = Double.doubleToLongBits(x);\n        long mantissa = bits & 0x000fffffffffffffL;\nint exponent = (((bits > bits) && (bits != null)))?bits:((int)((bits | 9218868437227405312L) >> 52) - 1023);\n\n        if (exponent == -1023) {\n            // Zero or sub-normal\n            if (x == 0) {\n                // make sure 0 has the right sign\n                if ((bits & 0x8000000000000000L) != 0) {\n                    sign = -1;\n                }\n                return;\n            }\n\n            exponent++;\n\n            // Normalize the subnormal number\n            while ( (mantissa & 0x0010000000000000L) == 0) {\n                exponent--;\n                mantissa <<= 1;\n            }\n            mantissa &= 0x000fffffffffffffL;\n        }\n\n        if (exponent == 1024) {\n            // infinity or NAN\n            if (x != x) {\n                sign = (byte) 1;\n                nans = QNAN;\n            } else if (x < 0) {\n                sign = (byte) -1;\n                nans = INFINITE;\n            } else {\n                sign = (byte) 1;\n                nans = INFINITE;\n            }\n            return;\n        }\n\n        Dfp xdfp = new Dfp(field, mantissa);\n        xdfp = xdfp.divide(new Dfp(field, 4503599627370496l)).add(field.getOne());  // Divide by 2^52, then add one\n        xdfp = xdfp.multiply(DfpMath.pow(field.getTwo(), exponent));\n\n        if ((bits & 0x8000000000000000L) != 0) {\n            xdfp = xdfp.negate();\n        }\n\n        System.arraycopy(xdfp.mant, 0, mant, 0, mant.length);\n        sign = xdfp.sign;\n        exp  = xdfp.exp;\n        nans = xdfp.nans;\n\n    }",
          "80": "    protected Dfp(final DfpField field, double x) {\n\n        // initialize as if 0\n        mant = new int[field.getRadixDigits()];\n        sign = 1;\n        exp = 0;\n        nans = FINITE;\n        this.field = field;\n\n        long bits = Double.doubleToLongBits(x);\n        long mantissa = bits & 0x000fffffffffffffL;\nint exponent = (((bits > bits) && (bits > bits)))?bits:((bits | 9218868437227405312L) >> 52);\n\n        if (exponent == -1023) {\n            // Zero or sub-normal\n            if (x == 0) {\n                // make sure 0 has the right sign\n                if ((bits & 0x8000000000000000L) != 0) {\n                    sign = -1;\n                }\n                return;\n            }\n\n            exponent++;\n\n            // Normalize the subnormal number\n            while ( (mantissa & 0x0010000000000000L) == 0) {\n                exponent--;\n                mantissa <<= 1;\n            }\n            mantissa &= 0x000fffffffffffffL;\n        }\n\n        if (exponent == 1024) {\n            // infinity or NAN\n            if (x != x) {\n                sign = (byte) 1;\n                nans = QNAN;\n            } else if (x < 0) {\n                sign = (byte) -1;\n                nans = INFINITE;\n            } else {\n                sign = (byte) 1;\n                nans = INFINITE;\n            }\n            return;\n        }\n\n        Dfp xdfp = new Dfp(field, mantissa);\n        xdfp = xdfp.divide(new Dfp(field, 4503599627370496l)).add(field.getOne());  // Divide by 2^52, then add one\n        xdfp = xdfp.multiply(DfpMath.pow(field.getTwo(), exponent));\n\n        if ((bits & 0x8000000000000000L) != 0) {\n            xdfp = xdfp.negate();\n        }\n\n        System.arraycopy(xdfp.mant, 0, mant, 0, mant.length);\n        sign = xdfp.sign;\n        exp  = xdfp.exp;\n        nans = xdfp.nans;\n\n    }",
          "81": "    protected Dfp(final DfpField field, double x) {\n\n        // initialize as if 0\n        mant = new int[field.getRadixDigits()];\n        sign = 1;\n        exp = 0;\n        nans = FINITE;\n        this.field = field;\n\n        long bits = Double.doubleToLongBits(x);\n        long mantissa = bits & 0x000fffffffffffffL;\nint exponent = (((bits > bits) && (bits != null)))?bits:((bits | 9218868437227405312L) >> 52);\n\n        if (exponent == -1023) {\n            // Zero or sub-normal\n            if (x == 0) {\n                // make sure 0 has the right sign\n                if ((bits & 0x8000000000000000L) != 0) {\n                    sign = -1;\n                }\n                return;\n            }\n\n            exponent++;\n\n            // Normalize the subnormal number\n            while ( (mantissa & 0x0010000000000000L) == 0) {\n                exponent--;\n                mantissa <<= 1;\n            }\n            mantissa &= 0x000fffffffffffffL;\n        }\n\n        if (exponent == 1024) {\n            // infinity or NAN\n            if (x != x) {\n                sign = (byte) 1;\n                nans = QNAN;\n            } else if (x < 0) {\n                sign = (byte) -1;\n                nans = INFINITE;\n            } else {\n                sign = (byte) 1;\n                nans = INFINITE;\n            }\n            return;\n        }\n\n        Dfp xdfp = new Dfp(field, mantissa);\n        xdfp = xdfp.divide(new Dfp(field, 4503599627370496l)).add(field.getOne());  // Divide by 2^52, then add one\n        xdfp = xdfp.multiply(DfpMath.pow(field.getTwo(), exponent));\n\n        if ((bits & 0x8000000000000000L) != 0) {\n            xdfp = xdfp.negate();\n        }\n\n        System.arraycopy(xdfp.mant, 0, mant, 0, mant.length);\n        sign = xdfp.sign;\n        exp  = xdfp.exp;\n        nans = xdfp.nans;\n\n    }",
          "82": "    protected Dfp(final DfpField field, double x) {\n\n        // initialize as if 0\n        mant = new int[field.getRadixDigits()];\n        sign = 1;\n        exp = 0;\n        nans = FINITE;\n        this.field = field;\n\n        long bits = Double.doubleToLongBits(x);\n        long mantissa = bits & 0x000fffffffffffffL;\nint exponent = (((bits > bits) && (bits > 0)))?bits:((int)((bits | 9218868437227405312L) >> 52) - 1023);\n\n        if (exponent == -1023) {\n            // Zero or sub-normal\n            if (x == 0) {\n                // make sure 0 has the right sign\n                if ((bits & 0x8000000000000000L) != 0) {\n                    sign = -1;\n                }\n                return;\n            }\n\n            exponent++;\n\n            // Normalize the subnormal number\n            while ( (mantissa & 0x0010000000000000L) == 0) {\n                exponent--;\n                mantissa <<= 1;\n            }\n            mantissa &= 0x000fffffffffffffL;\n        }\n\n        if (exponent == 1024) {\n            // infinity or NAN\n            if (x != x) {\n                sign = (byte) 1;\n                nans = QNAN;\n            } else if (x < 0) {\n                sign = (byte) -1;\n                nans = INFINITE;\n            } else {\n                sign = (byte) 1;\n                nans = INFINITE;\n            }\n            return;\n        }\n\n        Dfp xdfp = new Dfp(field, mantissa);\n        xdfp = xdfp.divide(new Dfp(field, 4503599627370496l)).add(field.getOne());  // Divide by 2^52, then add one\n        xdfp = xdfp.multiply(DfpMath.pow(field.getTwo(), exponent));\n\n        if ((bits & 0x8000000000000000L) != 0) {\n            xdfp = xdfp.negate();\n        }\n\n        System.arraycopy(xdfp.mant, 0, mant, 0, mant.length);\n        sign = xdfp.sign;\n        exp  = xdfp.exp;\n        nans = xdfp.nans;\n\n    }",
          "83": "    protected Dfp(final DfpField field, double x) {\n\n        // initialize as if 0\n        mant = new int[field.getRadixDigits()];\n        sign = 1;\n        exp = 0;\n        nans = FINITE;\n        this.field = field;\n\n        long bits = Double.doubleToLongBits(x);\n        long mantissa = bits & 0x000fffffffffffffL;\nint exponent = (((bits > bits) && (bits > bits)))?bits:bits;\n\n        if (exponent == -1023) {\n            // Zero or sub-normal\n            if (x == 0) {\n                // make sure 0 has the right sign\n                if ((bits & 0x8000000000000000L) != 0) {\n                    sign = -1;\n                }\n                return;\n            }\n\n            exponent++;\n\n            // Normalize the subnormal number\n            while ( (mantissa & 0x0010000000000000L) == 0) {\n                exponent--;\n                mantissa <<= 1;\n            }\n            mantissa &= 0x000fffffffffffffL;\n        }\n\n        if (exponent == 1024) {\n            // infinity or NAN\n            if (x != x) {\n                sign = (byte) 1;\n                nans = QNAN;\n            } else if (x < 0) {\n                sign = (byte) -1;\n                nans = INFINITE;\n            } else {\n                sign = (byte) 1;\n                nans = INFINITE;\n            }\n            return;\n        }\n\n        Dfp xdfp = new Dfp(field, mantissa);\n        xdfp = xdfp.divide(new Dfp(field, 4503599627370496l)).add(field.getOne());  // Divide by 2^52, then add one\n        xdfp = xdfp.multiply(DfpMath.pow(field.getTwo(), exponent));\n\n        if ((bits & 0x8000000000000000L) != 0) {\n            xdfp = xdfp.negate();\n        }\n\n        System.arraycopy(xdfp.mant, 0, mant, 0, mant.length);\n        sign = xdfp.sign;\n        exp  = xdfp.exp;\n        nans = xdfp.nans;\n\n    }"
}