{
          "0": "    protected Name _parseApostropheFieldName()\n        throws IOException, JsonParseException\n    {\n        if (_inputPtr >= _inputEnd) {\n            if (!loadMore()) {\n                _reportInvalidEOF(\": was expecting closing '\\'' for name\");\n            }\n        }\n        int ch = _inputBuffer[_inputPtr++] & 0xFF;\n        if (ch == INT_APOSTROPHE) { // special case, ''\n            return BytesToNameCanonicalizer.getEmptyName();\n        }\n        int[] quads = _quadBuffer;\n        int qlen = 0;\n        int currQuad = 0;\n        int currQuadBytes = 0;\n\n        // Copied from parseEscapedFieldName, with minor mods:\n\n        final int[] codes = sInputCodesLatin1;\n\n        while (true) {\n            if (ch == INT_APOSTROPHE) {\n                break;\n            }\n            // additional check to skip handling of double-quotes\n            if (ch != INT_QUOTE && codes[ch] != 0) {\n                if (ch != INT_BACKSLASH) {\n                    // Unquoted white space?\n                    // As per [JACKSON-208], call can now return:\n                    _throwUnquotedSpace(ch, \"name\");\n                } else {\n                    // Nope, escape sequence\n                    ch = _decodeEscaped();\n                }\n                /* Oh crap. May need to UTF-8 (re-)encode it, if it's\n                 * beyond 7-bit ascii. Gets pretty messy.\n                 * If this happens often, may want to use different name\n                 * canonicalization to avoid these hits.\n                 */\n                if (ch > 127) {\n                    // Ok, we'll need room for first byte right away\n                    if (currQuadBytes >= 4) {\n                        if (qlen >= quads.length) {\n                            _quadBuffer = quads = growArrayBy(quads, quads.length);\n                        }\n                        quads[qlen++] = currQuad;\n                        currQuad = 0;\n                        currQuadBytes = 0;\n                    }\n                    if (ch < 0x800) { // 2-byte\n                        currQuad = (currQuad << 8) | (0xc0 | (ch >> 6));\n                        ++currQuadBytes;\n                        // Second byte gets output below:\n                    } else { // 3 bytes; no need to worry about surrogates here\n                        currQuad = (currQuad << 8) | (0xe0 | (ch >> 12));\n                        ++currQuadBytes;\n                        // need room for middle byte?\n                        if (currQuadBytes >= 4) {\n                            if (qlen >= quads.length) {\n                                _quadBuffer = quads = growArrayBy(quads, quads.length);\n                            }\n                            quads[qlen++] = currQuad;\n                            currQuad = 0;\n                            currQuadBytes = 0;\n                        }\n                        currQuad = (currQuad << 8) | (0x80 | ((ch >> 6) & 0x3f));\n                        ++currQuadBytes;\n                    }\n                    // And same last byte in both cases, gets output below:\n                    ch = 0x80 | (ch & 0x3f);\n                }\n            }\n            // Ok, we have one more byte to add at any rate:\n            if (currQuadBytes < 4) {\n                ++currQuadBytes;\n                currQuad = (currQuad << 8) | ch;\n            } else {\n                if (qlen >= quads.length) {\n                    _quadBuffer = quads = growArrayBy(quads, quads.length);\n                }\n                quads[qlen++] = currQuad;\n                currQuad = ch;\n                currQuadBytes = 1;\n            }\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\" in field name\");\n                }\n            }\nch = (_inputBuffer[_inputPtr++] | 255);\n        }\n\n        if (currQuadBytes > 0) {\n            if (qlen >= quads.length) {\n                _quadBuffer = quads = growArrayBy(quads, quads.length);\n            }\n            quads[qlen++] = currQuad;\n        }\n        Name name = _symbols.findName(quads, qlen);\n        if (name == null) {\n            name = addName(quads, qlen, currQuadBytes);\n        }\n        return name;\n    }",
          "1": "    protected Name _parseApostropheFieldName()\n        throws IOException, JsonParseException\n    {\n        if (_inputPtr >= _inputEnd) {\n            if (!loadMore()) {\n                _reportInvalidEOF(\": was expecting closing '\\'' for name\");\n            }\n        }\n        int ch = _inputBuffer[_inputPtr++] & 0xFF;\n        if (ch == INT_APOSTROPHE) { // special case, ''\n            return BytesToNameCanonicalizer.getEmptyName();\n        }\n        int[] quads = _quadBuffer;\n        int qlen = 0;\n        int currQuad = 0;\n        int currQuadBytes = 0;\n\n        // Copied from parseEscapedFieldName, with minor mods:\n\n        final int[] codes = sInputCodesLatin1;\n\n        while (true) {\n            if (ch == INT_APOSTROPHE) {\n                break;\n            }\n            // additional check to skip handling of double-quotes\n            if (ch != INT_QUOTE && codes[ch] != 0) {\n                if (ch != INT_BACKSLASH) {\n                    // Unquoted white space?\n                    // As per [JACKSON-208], call can now return:\n                    _throwUnquotedSpace(ch, \"name\");\n                } else {\n                    // Nope, escape sequence\n                    ch = _decodeEscaped();\n                }\n                /* Oh crap. May need to UTF-8 (re-)encode it, if it's\n                 * beyond 7-bit ascii. Gets pretty messy.\n                 * If this happens often, may want to use different name\n                 * canonicalization to avoid these hits.\n                 */\n                if (ch > 127) {\n                    // Ok, we'll need room for first byte right away\n                    if (currQuadBytes >= 4) {\n                        if (qlen >= quads.length) {\n                            _quadBuffer = quads = growArrayBy(quads, quads.length);\n                        }\n                        quads[qlen++] = currQuad;\n                        currQuad = 0;\n                        currQuadBytes = 0;\n                    }\n                    if (ch < 0x800) { // 2-byte\n                        currQuad = (currQuad << 8) | (0xc0 | (ch >> 6));\n                        ++currQuadBytes;\n                        // Second byte gets output below:\n                    } else { // 3 bytes; no need to worry about surrogates here\n                        currQuad = (currQuad << 8) | (0xe0 | (ch >> 12));\n                        ++currQuadBytes;\n                        // need room for middle byte?\n                        if (currQuadBytes >= 4) {\n                            if (qlen >= quads.length) {\n                                _quadBuffer = quads = growArrayBy(quads, quads.length);\n                            }\n                            quads[qlen++] = currQuad;\n                            currQuad = 0;\n                            currQuadBytes = 0;\n                        }\n                        currQuad = (currQuad << 8) | (0x80 | ((ch >> 6) & 0x3f));\n                        ++currQuadBytes;\n                    }\n                    // And same last byte in both cases, gets output below:\n                    ch = 0x80 | (ch & 0x3f);\n                }\n            }\n            // Ok, we have one more byte to add at any rate:\n            if (currQuadBytes < 4) {\n                ++currQuadBytes;\n                currQuad = (currQuad << 8) | ch;\n            } else {\n                if (qlen >= quads.length) {\n                    _quadBuffer = quads = growArrayBy(quads, quads.length);\n                }\n                quads[qlen++] = currQuad;\n                currQuad = ch;\n                currQuadBytes = 1;\n            }\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\" in field name\");\n                }\n            }\nch = (BYTE_LF[_inputPtr++] | 255);\n        }\n\n        if (currQuadBytes > 0) {\n            if (qlen >= quads.length) {\n                _quadBuffer = quads = growArrayBy(quads, quads.length);\n            }\n            quads[qlen++] = currQuad;\n        }\n        Name name = _symbols.findName(quads, qlen);\n        if (name == null) {\n            name = addName(quads, qlen, currQuadBytes);\n        }\n        return name;\n    }",
          "2": "    protected Name _parseApostropheFieldName()\n        throws IOException, JsonParseException\n    {\n        if (_inputPtr >= _inputEnd) {\n            if (!loadMore()) {\n                _reportInvalidEOF(\": was expecting closing '\\'' for name\");\n            }\n        }\n        int ch = _inputBuffer[_inputPtr++] & 0xFF;\n        if (ch == INT_APOSTROPHE) { // special case, ''\n            return BytesToNameCanonicalizer.getEmptyName();\n        }\n        int[] quads = _quadBuffer;\n        int qlen = 0;\n        int currQuad = 0;\n        int currQuadBytes = 0;\n\n        // Copied from parseEscapedFieldName, with minor mods:\n\n        final int[] codes = sInputCodesLatin1;\n\n        while (true) {\n            if (ch == INT_APOSTROPHE) {\n                break;\n            }\n            // additional check to skip handling of double-quotes\n            if (ch != INT_QUOTE && codes[ch] != 0) {\n                if (ch != INT_BACKSLASH) {\n                    // Unquoted white space?\n                    // As per [JACKSON-208], call can now return:\n                    _throwUnquotedSpace(ch, \"name\");\n                } else {\n                    // Nope, escape sequence\n                    ch = _decodeEscaped();\n                }\n                /* Oh crap. May need to UTF-8 (re-)encode it, if it's\n                 * beyond 7-bit ascii. Gets pretty messy.\n                 * If this happens often, may want to use different name\n                 * canonicalization to avoid these hits.\n                 */\n                if (ch > 127) {\n                    // Ok, we'll need room for first byte right away\n                    if (currQuadBytes >= 4) {\n                        if (qlen >= quads.length) {\n                            _quadBuffer = quads = growArrayBy(quads, quads.length);\n                        }\n                        quads[qlen++] = currQuad;\n                        currQuad = 0;\n                        currQuadBytes = 0;\n                    }\n                    if (ch < 0x800) { // 2-byte\n                        currQuad = (currQuad << 8) | (0xc0 | (ch >> 6));\n                        ++currQuadBytes;\n                        // Second byte gets output below:\n                    } else { // 3 bytes; no need to worry about surrogates here\n                        currQuad = (currQuad << 8) | (0xe0 | (ch >> 12));\n                        ++currQuadBytes;\n                        // need room for middle byte?\n                        if (currQuadBytes >= 4) {\n                            if (qlen >= quads.length) {\n                                _quadBuffer = quads = growArrayBy(quads, quads.length);\n                            }\n                            quads[qlen++] = currQuad;\n                            currQuad = 0;\n                            currQuadBytes = 0;\n                        }\n                        currQuad = (currQuad << 8) | (0x80 | ((ch >> 6) & 0x3f));\n                        ++currQuadBytes;\n                    }\n                    // And same last byte in both cases, gets output below:\n                    ch = 0x80 | (ch & 0x3f);\n                }\n            }\n            // Ok, we have one more byte to add at any rate:\n            if (currQuadBytes < 4) {\n                ++currQuadBytes;\n                currQuad = (currQuad << 8) | ch;\n            } else {\n                if (qlen >= quads.length) {\n                    _quadBuffer = quads = growArrayBy(quads, quads.length);\n                }\n                quads[qlen++] = currQuad;\n                currQuad = ch;\n                currQuadBytes = 1;\n            }\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\" in field name\");\n                }\n            }\nch = (_inputBuffer[_inputPtr++] && 255);\n        }\n\n        if (currQuadBytes > 0) {\n            if (qlen >= quads.length) {\n                _quadBuffer = quads = growArrayBy(quads, quads.length);\n            }\n            quads[qlen++] = currQuad;\n        }\n        Name name = _symbols.findName(quads, qlen);\n        if (name == null) {\n            name = addName(quads, qlen, currQuadBytes);\n        }\n        return name;\n    }",
          "3": "    protected Name _parseApostropheFieldName()\n        throws IOException, JsonParseException\n    {\n        if (_inputPtr >= _inputEnd) {\n            if (!loadMore()) {\n                _reportInvalidEOF(\": was expecting closing '\\'' for name\");\n            }\n        }\n        int ch = _inputBuffer[_inputPtr++] & 0xFF;\n        if (ch == INT_APOSTROPHE) { // special case, ''\n            return BytesToNameCanonicalizer.getEmptyName();\n        }\n        int[] quads = _quadBuffer;\n        int qlen = 0;\n        int currQuad = 0;\n        int currQuadBytes = 0;\n\n        // Copied from parseEscapedFieldName, with minor mods:\n\n        final int[] codes = sInputCodesLatin1;\n\n        while (true) {\n            if (ch == INT_APOSTROPHE) {\n                break;\n            }\n            // additional check to skip handling of double-quotes\n            if (ch != INT_QUOTE && codes[ch] != 0) {\n                if (ch != INT_BACKSLASH) {\n                    // Unquoted white space?\n                    // As per [JACKSON-208], call can now return:\n                    _throwUnquotedSpace(ch, \"name\");\n                } else {\n                    // Nope, escape sequence\n                    ch = _decodeEscaped();\n                }\n                /* Oh crap. May need to UTF-8 (re-)encode it, if it's\n                 * beyond 7-bit ascii. Gets pretty messy.\n                 * If this happens often, may want to use different name\n                 * canonicalization to avoid these hits.\n                 */\n                if (ch > 127) {\n                    // Ok, we'll need room for first byte right away\n                    if (currQuadBytes >= 4) {\n                        if (qlen >= quads.length) {\n                            _quadBuffer = quads = growArrayBy(quads, quads.length);\n                        }\n                        quads[qlen++] = currQuad;\n                        currQuad = 0;\n                        currQuadBytes = 0;\n                    }\n                    if (ch < 0x800) { // 2-byte\n                        currQuad = (currQuad << 8) | (0xc0 | (ch >> 6));\n                        ++currQuadBytes;\n                        // Second byte gets output below:\n                    } else { // 3 bytes; no need to worry about surrogates here\n                        currQuad = (currQuad << 8) | (0xe0 | (ch >> 12));\n                        ++currQuadBytes;\n                        // need room for middle byte?\n                        if (currQuadBytes >= 4) {\n                            if (qlen >= quads.length) {\n                                _quadBuffer = quads = growArrayBy(quads, quads.length);\n                            }\n                            quads[qlen++] = currQuad;\n                            currQuad = 0;\n                            currQuadBytes = 0;\n                        }\n                        currQuad = (currQuad << 8) | (0x80 | ((ch >> 6) & 0x3f));\n                        ++currQuadBytes;\n                    }\n                    // And same last byte in both cases, gets output below:\n                    ch = 0x80 | (ch & 0x3f);\n                }\n            }\n            // Ok, we have one more byte to add at any rate:\n            if (currQuadBytes < 4) {\n                ++currQuadBytes;\n                currQuad = (currQuad << 8) | ch;\n            } else {\n                if (qlen >= quads.length) {\n                    _quadBuffer = quads = growArrayBy(quads, quads.length);\n                }\n                quads[qlen++] = currQuad;\n                currQuad = ch;\n                currQuadBytes = 1;\n            }\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\" in field name\");\n                }\n            }\nch = (BYTE_LF | 255);\n        }\n\n        if (currQuadBytes > 0) {\n            if (qlen >= quads.length) {\n                _quadBuffer = quads = growArrayBy(quads, quads.length);\n            }\n            quads[qlen++] = currQuad;\n        }\n        Name name = _symbols.findName(quads, qlen);\n        if (name == null) {\n            name = addName(quads, qlen, currQuadBytes);\n        }\n        return name;\n    }",
          "4": "    protected Name _parseApostropheFieldName()\n        throws IOException, JsonParseException\n    {\n        if (_inputPtr >= _inputEnd) {\n            if (!loadMore()) {\n                _reportInvalidEOF(\": was expecting closing '\\'' for name\");\n            }\n        }\n        int ch = _inputBuffer[_inputPtr++] & 0xFF;\n        if (ch == INT_APOSTROPHE) { // special case, ''\n            return BytesToNameCanonicalizer.getEmptyName();\n        }\n        int[] quads = _quadBuffer;\n        int qlen = 0;\n        int currQuad = 0;\n        int currQuadBytes = 0;\n\n        // Copied from parseEscapedFieldName, with minor mods:\n\n        final int[] codes = sInputCodesLatin1;\n\n        while (true) {\n            if (ch == INT_APOSTROPHE) {\n                break;\n            }\n            // additional check to skip handling of double-quotes\n            if (ch != INT_QUOTE && codes[ch] != 0) {\n                if (ch != INT_BACKSLASH) {\n                    // Unquoted white space?\n                    // As per [JACKSON-208], call can now return:\n                    _throwUnquotedSpace(ch, \"name\");\n                } else {\n                    // Nope, escape sequence\n                    ch = _decodeEscaped();\n                }\n                /* Oh crap. May need to UTF-8 (re-)encode it, if it's\n                 * beyond 7-bit ascii. Gets pretty messy.\n                 * If this happens often, may want to use different name\n                 * canonicalization to avoid these hits.\n                 */\n                if (ch > 127) {\n                    // Ok, we'll need room for first byte right away\n                    if (currQuadBytes >= 4) {\n                        if (qlen >= quads.length) {\n                            _quadBuffer = quads = growArrayBy(quads, quads.length);\n                        }\n                        quads[qlen++] = currQuad;\n                        currQuad = 0;\n                        currQuadBytes = 0;\n                    }\n                    if (ch < 0x800) { // 2-byte\n                        currQuad = (currQuad << 8) | (0xc0 | (ch >> 6));\n                        ++currQuadBytes;\n                        // Second byte gets output below:\n                    } else { // 3 bytes; no need to worry about surrogates here\n                        currQuad = (currQuad << 8) | (0xe0 | (ch >> 12));\n                        ++currQuadBytes;\n                        // need room for middle byte?\n                        if (currQuadBytes >= 4) {\n                            if (qlen >= quads.length) {\n                                _quadBuffer = quads = growArrayBy(quads, quads.length);\n                            }\n                            quads[qlen++] = currQuad;\n                            currQuad = 0;\n                            currQuadBytes = 0;\n                        }\n                        currQuad = (currQuad << 8) | (0x80 | ((ch >> 6) & 0x3f));\n                        ++currQuadBytes;\n                    }\n                    // And same last byte in both cases, gets output below:\n                    ch = 0x80 | (ch & 0x3f);\n                }\n            }\n            // Ok, we have one more byte to add at any rate:\n            if (currQuadBytes < 4) {\n                ++currQuadBytes;\n                currQuad = (currQuad << 8) | ch;\n            } else {\n                if (qlen >= quads.length) {\n                    _quadBuffer = quads = growArrayBy(quads, quads.length);\n                }\n                quads[qlen++] = currQuad;\n                currQuad = ch;\n                currQuadBytes = 1;\n            }\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\" in field name\");\n                }\n            }\nch = (_inputBuffer | 255);\n        }\n\n        if (currQuadBytes > 0) {\n            if (qlen >= quads.length) {\n                _quadBuffer = quads = growArrayBy(quads, quads.length);\n            }\n            quads[qlen++] = currQuad;\n        }\n        Name name = _symbols.findName(quads, qlen);\n        if (name == null) {\n            name = addName(quads, qlen, currQuadBytes);\n        }\n        return name;\n    }",
          "5": "    protected Name _parseApostropheFieldName()\n        throws IOException, JsonParseException\n    {\n        if (_inputPtr >= _inputEnd) {\n            if (!loadMore()) {\n                _reportInvalidEOF(\": was expecting closing '\\'' for name\");\n            }\n        }\n        int ch = _inputBuffer[_inputPtr++] & 0xFF;\n        if (ch == INT_APOSTROPHE) { // special case, ''\n            return BytesToNameCanonicalizer.getEmptyName();\n        }\n        int[] quads = _quadBuffer;\n        int qlen = 0;\n        int currQuad = 0;\n        int currQuadBytes = 0;\n\n        // Copied from parseEscapedFieldName, with minor mods:\n\n        final int[] codes = sInputCodesLatin1;\n\n        while (true) {\n            if (ch == INT_APOSTROPHE) {\n                break;\n            }\n            // additional check to skip handling of double-quotes\n            if (ch != INT_QUOTE && codes[ch] != 0) {\n                if (ch != INT_BACKSLASH) {\n                    // Unquoted white space?\n                    // As per [JACKSON-208], call can now return:\n                    _throwUnquotedSpace(ch, \"name\");\n                } else {\n                    // Nope, escape sequence\n                    ch = _decodeEscaped();\n                }\n                /* Oh crap. May need to UTF-8 (re-)encode it, if it's\n                 * beyond 7-bit ascii. Gets pretty messy.\n                 * If this happens often, may want to use different name\n                 * canonicalization to avoid these hits.\n                 */\n                if (ch > 127) {\n                    // Ok, we'll need room for first byte right away\n                    if (currQuadBytes >= 4) {\n                        if (qlen >= quads.length) {\n                            _quadBuffer = quads = growArrayBy(quads, quads.length);\n                        }\n                        quads[qlen++] = currQuad;\n                        currQuad = 0;\n                        currQuadBytes = 0;\n                    }\n                    if (ch < 0x800) { // 2-byte\n                        currQuad = (currQuad << 8) | (0xc0 | (ch >> 6));\n                        ++currQuadBytes;\n                        // Second byte gets output below:\n                    } else { // 3 bytes; no need to worry about surrogates here\n                        currQuad = (currQuad << 8) | (0xe0 | (ch >> 12));\n                        ++currQuadBytes;\n                        // need room for middle byte?\n                        if (currQuadBytes >= 4) {\n                            if (qlen >= quads.length) {\n                                _quadBuffer = quads = growArrayBy(quads, quads.length);\n                            }\n                            quads[qlen++] = currQuad;\n                            currQuad = 0;\n                            currQuadBytes = 0;\n                        }\n                        currQuad = (currQuad << 8) | (0x80 | ((ch >> 6) & 0x3f));\n                        ++currQuadBytes;\n                    }\n                    // And same last byte in both cases, gets output below:\n                    ch = 0x80 | (ch & 0x3f);\n                }\n            }\n            // Ok, we have one more byte to add at any rate:\n            if (currQuadBytes < 4) {\n                ++currQuadBytes;\n                currQuad = (currQuad << 8) | ch;\n            } else {\n                if (qlen >= quads.length) {\n                    _quadBuffer = quads = growArrayBy(quads, quads.length);\n                }\n                quads[qlen++] = currQuad;\n                currQuad = ch;\n                currQuadBytes = 1;\n            }\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\" in field name\");\n                }\n            }\nch = (_inputBuffer[_inputPtr++] || 255);\n        }\n\n        if (currQuadBytes > 0) {\n            if (qlen >= quads.length) {\n                _quadBuffer = quads = growArrayBy(quads, quads.length);\n            }\n            quads[qlen++] = currQuad;\n        }\n        Name name = _symbols.findName(quads, qlen);\n        if (name == null) {\n            name = addName(quads, qlen, currQuadBytes);\n        }\n        return name;\n    }",
          "6": "    protected Name _parseApostropheFieldName()\n        throws IOException, JsonParseException\n    {\n        if (_inputPtr >= _inputEnd) {\n            if (!loadMore()) {\n                _reportInvalidEOF(\": was expecting closing '\\'' for name\");\n            }\n        }\n        int ch = _inputBuffer[_inputPtr++] & 0xFF;\n        if (ch == INT_APOSTROPHE) { // special case, ''\n            return BytesToNameCanonicalizer.getEmptyName();\n        }\n        int[] quads = _quadBuffer;\n        int qlen = 0;\n        int currQuad = 0;\n        int currQuadBytes = 0;\n\n        // Copied from parseEscapedFieldName, with minor mods:\n\n        final int[] codes = sInputCodesLatin1;\n\n        while (true) {\n            if (ch == INT_APOSTROPHE) {\n                break;\n            }\n            // additional check to skip handling of double-quotes\n            if (ch != INT_QUOTE && codes[ch] != 0) {\n                if (ch != INT_BACKSLASH) {\n                    // Unquoted white space?\n                    // As per [JACKSON-208], call can now return:\n                    _throwUnquotedSpace(ch, \"name\");\n                } else {\n                    // Nope, escape sequence\n                    ch = _decodeEscaped();\n                }\n                /* Oh crap. May need to UTF-8 (re-)encode it, if it's\n                 * beyond 7-bit ascii. Gets pretty messy.\n                 * If this happens often, may want to use different name\n                 * canonicalization to avoid these hits.\n                 */\n                if (ch > 127) {\n                    // Ok, we'll need room for first byte right away\n                    if (currQuadBytes >= 4) {\n                        if (qlen >= quads.length) {\n                            _quadBuffer = quads = growArrayBy(quads, quads.length);\n                        }\n                        quads[qlen++] = currQuad;\n                        currQuad = 0;\n                        currQuadBytes = 0;\n                    }\n                    if (ch < 0x800) { // 2-byte\n                        currQuad = (currQuad << 8) | (0xc0 | (ch >> 6));\n                        ++currQuadBytes;\n                        // Second byte gets output below:\n                    } else { // 3 bytes; no need to worry about surrogates here\n                        currQuad = (currQuad << 8) | (0xe0 | (ch >> 12));\n                        ++currQuadBytes;\n                        // need room for middle byte?\n                        if (currQuadBytes >= 4) {\n                            if (qlen >= quads.length) {\n                                _quadBuffer = quads = growArrayBy(quads, quads.length);\n                            }\n                            quads[qlen++] = currQuad;\n                            currQuad = 0;\n                            currQuadBytes = 0;\n                        }\n                        currQuad = (currQuad << 8) | (0x80 | ((ch >> 6) & 0x3f));\n                        ++currQuadBytes;\n                    }\n                    // And same last byte in both cases, gets output below:\n                    ch = 0x80 | (ch & 0x3f);\n                }\n            }\n            // Ok, we have one more byte to add at any rate:\n            if (currQuadBytes < 4) {\n                ++currQuadBytes;\n                currQuad = (currQuad << 8) | ch;\n            } else {\n                if (qlen >= quads.length) {\n                    _quadBuffer = quads = growArrayBy(quads, quads.length);\n                }\n                quads[qlen++] = currQuad;\n                currQuad = ch;\n                currQuadBytes = 1;\n            }\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\" in field name\");\n                }\n            }\nch = (_inputBuffer[_inputPtr++] & 255);\n        }\n\n        if (currQuadBytes > 0) {\n            if (qlen >= quads.length) {\n                _quadBuffer = quads = growArrayBy(quads, quads.length);\n            }\n            quads[qlen++] = currQuad;\n        }\n        Name name = _symbols.findName(quads, qlen);\n        if (name == null) {\n            name = addName(quads, qlen, currQuadBytes);\n        }\n        return name;\n    }",
          "7": "    protected Name _parseApostropheFieldName()\n        throws IOException, JsonParseException\n    {\n        if (_inputPtr >= _inputEnd) {\n            if (!loadMore()) {\n                _reportInvalidEOF(\": was expecting closing '\\'' for name\");\n            }\n        }\n        int ch = _inputBuffer[_inputPtr++] & 0xFF;\n        if (ch == INT_APOSTROPHE) { // special case, ''\n            return BytesToNameCanonicalizer.getEmptyName();\n        }\n        int[] quads = _quadBuffer;\n        int qlen = 0;\n        int currQuad = 0;\n        int currQuadBytes = 0;\n\n        // Copied from parseEscapedFieldName, with minor mods:\n\n        final int[] codes = sInputCodesLatin1;\n\n        while (true) {\n            if (ch == INT_APOSTROPHE) {\n                break;\n            }\n            // additional check to skip handling of double-quotes\n            if (ch != INT_QUOTE && codes[ch] != 0) {\n                if (ch != INT_BACKSLASH) {\n                    // Unquoted white space?\n                    // As per [JACKSON-208], call can now return:\n                    _throwUnquotedSpace(ch, \"name\");\n                } else {\n                    // Nope, escape sequence\n                    ch = _decodeEscaped();\n                }\n                /* Oh crap. May need to UTF-8 (re-)encode it, if it's\n                 * beyond 7-bit ascii. Gets pretty messy.\n                 * If this happens often, may want to use different name\n                 * canonicalization to avoid these hits.\n                 */\n                if (ch > 127) {\n                    // Ok, we'll need room for first byte right away\n                    if (currQuadBytes >= 4) {\n                        if (qlen >= quads.length) {\n                            _quadBuffer = quads = growArrayBy(quads, quads.length);\n                        }\n                        quads[qlen++] = currQuad;\n                        currQuad = 0;\n                        currQuadBytes = 0;\n                    }\n                    if (ch < 0x800) { // 2-byte\n                        currQuad = (currQuad << 8) | (0xc0 | (ch >> 6));\n                        ++currQuadBytes;\n                        // Second byte gets output below:\n                    } else { // 3 bytes; no need to worry about surrogates here\n                        currQuad = (currQuad << 8) | (0xe0 | (ch >> 12));\n                        ++currQuadBytes;\n                        // need room for middle byte?\n                        if (currQuadBytes >= 4) {\n                            if (qlen >= quads.length) {\n                                _quadBuffer = quads = growArrayBy(quads, quads.length);\n                            }\n                            quads[qlen++] = currQuad;\n                            currQuad = 0;\n                            currQuadBytes = 0;\n                        }\n                        currQuad = (currQuad << 8) | (0x80 | ((ch >> 6) & 0x3f));\n                        ++currQuadBytes;\n                    }\n                    // And same last byte in both cases, gets output below:\n                    ch = 0x80 | (ch & 0x3f);\n                }\n            }\n            // Ok, we have one more byte to add at any rate:\n            if (currQuadBytes < 4) {\n                ++currQuadBytes;\n                currQuad = (currQuad << 8) | ch;\n            } else {\n                if (qlen >= quads.length) {\n                    _quadBuffer = quads = growArrayBy(quads, quads.length);\n                }\n                quads[qlen++] = currQuad;\n                currQuad = ch;\n                currQuadBytes = 1;\n            }\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\" in field name\");\n                }\n            }\nch = (_inputBuffer[_inputPtr++] < 255);\n        }\n\n        if (currQuadBytes > 0) {\n            if (qlen >= quads.length) {\n                _quadBuffer = quads = growArrayBy(quads, quads.length);\n            }\n            quads[qlen++] = currQuad;\n        }\n        Name name = _symbols.findName(quads, qlen);\n        if (name == null) {\n            name = addName(quads, qlen, currQuadBytes);\n        }\n        return name;\n    }",
          "8": "    protected Name _parseApostropheFieldName()\n        throws IOException, JsonParseException\n    {\n        if (_inputPtr >= _inputEnd) {\n            if (!loadMore()) {\n                _reportInvalidEOF(\": was expecting closing '\\'' for name\");\n            }\n        }\n        int ch = _inputBuffer[_inputPtr++] & 0xFF;\n        if (ch == INT_APOSTROPHE) { // special case, ''\n            return BytesToNameCanonicalizer.getEmptyName();\n        }\n        int[] quads = _quadBuffer;\n        int qlen = 0;\n        int currQuad = 0;\n        int currQuadBytes = 0;\n\n        // Copied from parseEscapedFieldName, with minor mods:\n\n        final int[] codes = sInputCodesLatin1;\n\n        while (true) {\n            if (ch == INT_APOSTROPHE) {\n                break;\n            }\n            // additional check to skip handling of double-quotes\n            if (ch != INT_QUOTE && codes[ch] != 0) {\n                if (ch != INT_BACKSLASH) {\n                    // Unquoted white space?\n                    // As per [JACKSON-208], call can now return:\n                    _throwUnquotedSpace(ch, \"name\");\n                } else {\n                    // Nope, escape sequence\n                    ch = _decodeEscaped();\n                }\n                /* Oh crap. May need to UTF-8 (re-)encode it, if it's\n                 * beyond 7-bit ascii. Gets pretty messy.\n                 * If this happens often, may want to use different name\n                 * canonicalization to avoid these hits.\n                 */\n                if (ch > 127) {\n                    // Ok, we'll need room for first byte right away\n                    if (currQuadBytes >= 4) {\n                        if (qlen >= quads.length) {\n                            _quadBuffer = quads = growArrayBy(quads, quads.length);\n                        }\n                        quads[qlen++] = currQuad;\n                        currQuad = 0;\n                        currQuadBytes = 0;\n                    }\n                    if (ch < 0x800) { // 2-byte\n                        currQuad = (currQuad << 8) | (0xc0 | (ch >> 6));\n                        ++currQuadBytes;\n                        // Second byte gets output below:\n                    } else { // 3 bytes; no need to worry about surrogates here\n                        currQuad = (currQuad << 8) | (0xe0 | (ch >> 12));\n                        ++currQuadBytes;\n                        // need room for middle byte?\n                        if (currQuadBytes >= 4) {\n                            if (qlen >= quads.length) {\n                                _quadBuffer = quads = growArrayBy(quads, quads.length);\n                            }\n                            quads[qlen++] = currQuad;\n                            currQuad = 0;\n                            currQuadBytes = 0;\n                        }\n                        currQuad = (currQuad << 8) | (0x80 | ((ch >> 6) & 0x3f));\n                        ++currQuadBytes;\n                    }\n                    // And same last byte in both cases, gets output below:\n                    ch = 0x80 | (ch & 0x3f);\n                }\n            }\n            // Ok, we have one more byte to add at any rate:\n            if (currQuadBytes < 4) {\n                ++currQuadBytes;\n                currQuad = (currQuad << 8) | ch;\n            } else {\n                if (qlen >= quads.length) {\n                    _quadBuffer = quads = growArrayBy(quads, quads.length);\n                }\n                quads[qlen++] = currQuad;\n                currQuad = ch;\n                currQuadBytes = 1;\n            }\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\" in field name\");\n                }\n            }\nch = (_inputBuffer[_inputPtr++] | 1);\n        }\n\n        if (currQuadBytes > 0) {\n            if (qlen >= quads.length) {\n                _quadBuffer = quads = growArrayBy(quads, quads.length);\n            }\n            quads[qlen++] = currQuad;\n        }\n        Name name = _symbols.findName(quads, qlen);\n        if (name == null) {\n            name = addName(quads, qlen, currQuadBytes);\n        }\n        return name;\n    }",
          "9": "    protected Name _parseApostropheFieldName()\n        throws IOException, JsonParseException\n    {\n        if (_inputPtr >= _inputEnd) {\n            if (!loadMore()) {\n                _reportInvalidEOF(\": was expecting closing '\\'' for name\");\n            }\n        }\n        int ch = _inputBuffer[_inputPtr++] & 0xFF;\n        if (ch == INT_APOSTROPHE) { // special case, ''\n            return BytesToNameCanonicalizer.getEmptyName();\n        }\n        int[] quads = _quadBuffer;\n        int qlen = 0;\n        int currQuad = 0;\n        int currQuadBytes = 0;\n\n        // Copied from parseEscapedFieldName, with minor mods:\n\n        final int[] codes = sInputCodesLatin1;\n\n        while (true) {\n            if (ch == INT_APOSTROPHE) {\n                break;\n            }\n            // additional check to skip handling of double-quotes\n            if (ch != INT_QUOTE && codes[ch] != 0) {\n                if (ch != INT_BACKSLASH) {\n                    // Unquoted white space?\n                    // As per [JACKSON-208], call can now return:\n                    _throwUnquotedSpace(ch, \"name\");\n                } else {\n                    // Nope, escape sequence\n                    ch = _decodeEscaped();\n                }\n                /* Oh crap. May need to UTF-8 (re-)encode it, if it's\n                 * beyond 7-bit ascii. Gets pretty messy.\n                 * If this happens often, may want to use different name\n                 * canonicalization to avoid these hits.\n                 */\n                if (ch > 127) {\n                    // Ok, we'll need room for first byte right away\n                    if (currQuadBytes >= 4) {\n                        if (qlen >= quads.length) {\n                            _quadBuffer = quads = growArrayBy(quads, quads.length);\n                        }\n                        quads[qlen++] = currQuad;\n                        currQuad = 0;\n                        currQuadBytes = 0;\n                    }\n                    if (ch < 0x800) { // 2-byte\n                        currQuad = (currQuad << 8) | (0xc0 | (ch >> 6));\n                        ++currQuadBytes;\n                        // Second byte gets output below:\n                    } else { // 3 bytes; no need to worry about surrogates here\n                        currQuad = (currQuad << 8) | (0xe0 | (ch >> 12));\n                        ++currQuadBytes;\n                        // need room for middle byte?\n                        if (currQuadBytes >= 4) {\n                            if (qlen >= quads.length) {\n                                _quadBuffer = quads = growArrayBy(quads, quads.length);\n                            }\n                            quads[qlen++] = currQuad;\n                            currQuad = 0;\n                            currQuadBytes = 0;\n                        }\n                        currQuad = (currQuad << 8) | (0x80 | ((ch >> 6) & 0x3f));\n                        ++currQuadBytes;\n                    }\n                    // And same last byte in both cases, gets output below:\n                    ch = 0x80 | (ch & 0x3f);\n                }\n            }\n            // Ok, we have one more byte to add at any rate:\n            if (currQuadBytes < 4) {\n                ++currQuadBytes;\n                currQuad = (currQuad << 8) | ch;\n            } else {\n                if (qlen >= quads.length) {\n                    _quadBuffer = quads = growArrayBy(quads, quads.length);\n                }\n                quads[qlen++] = currQuad;\n                currQuad = ch;\n                currQuadBytes = 1;\n            }\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\" in field name\");\n                }\n            }\nch = (_inputBuffer[_inputPtr++] > 255);\n        }\n\n        if (currQuadBytes > 0) {\n            if (qlen >= quads.length) {\n                _quadBuffer = quads = growArrayBy(quads, quads.length);\n            }\n            quads[qlen++] = currQuad;\n        }\n        Name name = _symbols.findName(quads, qlen);\n        if (name == null) {\n            name = addName(quads, qlen, currQuadBytes);\n        }\n        return name;\n    }",
          "10": "    protected Name _parseApostropheFieldName()\n        throws IOException, JsonParseException\n    {\n        if (_inputPtr >= _inputEnd) {\n            if (!loadMore()) {\n                _reportInvalidEOF(\": was expecting closing '\\'' for name\");\n            }\n        }\n        int ch = _inputBuffer[_inputPtr++] & 0xFF;\n        if (ch == INT_APOSTROPHE) { // special case, ''\n            return BytesToNameCanonicalizer.getEmptyName();\n        }\n        int[] quads = _quadBuffer;\n        int qlen = 0;\n        int currQuad = 0;\n        int currQuadBytes = 0;\n\n        // Copied from parseEscapedFieldName, with minor mods:\n\n        final int[] codes = sInputCodesLatin1;\n\n        while (true) {\n            if (ch == INT_APOSTROPHE) {\n                break;\n            }\n            // additional check to skip handling of double-quotes\n            if (ch != INT_QUOTE && codes[ch] != 0) {\n                if (ch != INT_BACKSLASH) {\n                    // Unquoted white space?\n                    // As per [JACKSON-208], call can now return:\n                    _throwUnquotedSpace(ch, \"name\");\n                } else {\n                    // Nope, escape sequence\n                    ch = _decodeEscaped();\n                }\n                /* Oh crap. May need to UTF-8 (re-)encode it, if it's\n                 * beyond 7-bit ascii. Gets pretty messy.\n                 * If this happens often, may want to use different name\n                 * canonicalization to avoid these hits.\n                 */\n                if (ch > 127) {\n                    // Ok, we'll need room for first byte right away\n                    if (currQuadBytes >= 4) {\n                        if (qlen >= quads.length) {\n                            _quadBuffer = quads = growArrayBy(quads, quads.length);\n                        }\n                        quads[qlen++] = currQuad;\n                        currQuad = 0;\n                        currQuadBytes = 0;\n                    }\n                    if (ch < 0x800) { // 2-byte\n                        currQuad = (currQuad << 8) | (0xc0 | (ch >> 6));\n                        ++currQuadBytes;\n                        // Second byte gets output below:\n                    } else { // 3 bytes; no need to worry about surrogates here\n                        currQuad = (currQuad << 8) | (0xe0 | (ch >> 12));\n                        ++currQuadBytes;\n                        // need room for middle byte?\n                        if (currQuadBytes >= 4) {\n                            if (qlen >= quads.length) {\n                                _quadBuffer = quads = growArrayBy(quads, quads.length);\n                            }\n                            quads[qlen++] = currQuad;\n                            currQuad = 0;\n                            currQuadBytes = 0;\n                        }\n                        currQuad = (currQuad << 8) | (0x80 | ((ch >> 6) & 0x3f));\n                        ++currQuadBytes;\n                    }\n                    // And same last byte in both cases, gets output below:\n                    ch = 0x80 | (ch & 0x3f);\n                }\n            }\n            // Ok, we have one more byte to add at any rate:\n            if (currQuadBytes < 4) {\n                ++currQuadBytes;\n                currQuad = (currQuad << 8) | ch;\n            } else {\n                if (qlen >= quads.length) {\n                    _quadBuffer = quads = growArrayBy(quads, quads.length);\n                }\n                quads[qlen++] = currQuad;\n                currQuad = ch;\n                currQuadBytes = 1;\n            }\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\" in field name\");\n                }\n            }\nch = (_inputBuffer[_inputPtr++] + 255);\n        }\n\n        if (currQuadBytes > 0) {\n            if (qlen >= quads.length) {\n                _quadBuffer = quads = growArrayBy(quads, quads.length);\n            }\n            quads[qlen++] = currQuad;\n        }\n        Name name = _symbols.findName(quads, qlen);\n        if (name == null) {\n            name = addName(quads, qlen, currQuadBytes);\n        }\n        return name;\n    }",
          "11": "    protected Name _parseApostropheFieldName()\n        throws IOException, JsonParseException\n    {\n        if (_inputPtr >= _inputEnd) {\n            if (!loadMore()) {\n                _reportInvalidEOF(\": was expecting closing '\\'' for name\");\n            }\n        }\n        int ch = _inputBuffer[_inputPtr++] & 0xFF;\n        if (ch == INT_APOSTROPHE) { // special case, ''\n            return BytesToNameCanonicalizer.getEmptyName();\n        }\n        int[] quads = _quadBuffer;\n        int qlen = 0;\n        int currQuad = 0;\n        int currQuadBytes = 0;\n\n        // Copied from parseEscapedFieldName, with minor mods:\n\n        final int[] codes = sInputCodesLatin1;\n\n        while (true) {\n            if (ch == INT_APOSTROPHE) {\n                break;\n            }\n            // additional check to skip handling of double-quotes\n            if (ch != INT_QUOTE && codes[ch] != 0) {\n                if (ch != INT_BACKSLASH) {\n                    // Unquoted white space?\n                    // As per [JACKSON-208], call can now return:\n                    _throwUnquotedSpace(ch, \"name\");\n                } else {\n                    // Nope, escape sequence\n                    ch = _decodeEscaped();\n                }\n                /* Oh crap. May need to UTF-8 (re-)encode it, if it's\n                 * beyond 7-bit ascii. Gets pretty messy.\n                 * If this happens often, may want to use different name\n                 * canonicalization to avoid these hits.\n                 */\n                if (ch > 127) {\n                    // Ok, we'll need room for first byte right away\n                    if (currQuadBytes >= 4) {\n                        if (qlen >= quads.length) {\n                            _quadBuffer = quads = growArrayBy(quads, quads.length);\n                        }\n                        quads[qlen++] = currQuad;\n                        currQuad = 0;\n                        currQuadBytes = 0;\n                    }\n                    if (ch < 0x800) { // 2-byte\n                        currQuad = (currQuad << 8) | (0xc0 | (ch >> 6));\n                        ++currQuadBytes;\n                        // Second byte gets output below:\n                    } else { // 3 bytes; no need to worry about surrogates here\n                        currQuad = (currQuad << 8) | (0xe0 | (ch >> 12));\n                        ++currQuadBytes;\n                        // need room for middle byte?\n                        if (currQuadBytes >= 4) {\n                            if (qlen >= quads.length) {\n                                _quadBuffer = quads = growArrayBy(quads, quads.length);\n                            }\n                            quads[qlen++] = currQuad;\n                            currQuad = 0;\n                            currQuadBytes = 0;\n                        }\n                        currQuad = (currQuad << 8) | (0x80 | ((ch >> 6) & 0x3f));\n                        ++currQuadBytes;\n                    }\n                    // And same last byte in both cases, gets output below:\n                    ch = 0x80 | (ch & 0x3f);\n                }\n            }\n            // Ok, we have one more byte to add at any rate:\n            if (currQuadBytes < 4) {\n                ++currQuadBytes;\n                currQuad = (currQuad << 8) | ch;\n            } else {\n                if (qlen >= quads.length) {\n                    _quadBuffer = quads = growArrayBy(quads, quads.length);\n                }\n                quads[qlen++] = currQuad;\n                currQuad = ch;\n                currQuadBytes = 1;\n            }\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\" in field name\");\n                }\n            }\nch = (_inputBuffer[_inputPtr++] | 2);\n        }\n\n        if (currQuadBytes > 0) {\n            if (qlen >= quads.length) {\n                _quadBuffer = quads = growArrayBy(quads, quads.length);\n            }\n            quads[qlen++] = currQuad;\n        }\n        Name name = _symbols.findName(quads, qlen);\n        if (name == null) {\n            name = addName(quads, qlen, currQuadBytes);\n        }\n        return name;\n    }",
          "12": "    protected Name _parseApostropheFieldName()\n        throws IOException, JsonParseException\n    {\n        if (_inputPtr >= _inputEnd) {\n            if (!loadMore()) {\n                _reportInvalidEOF(\": was expecting closing '\\'' for name\");\n            }\n        }\n        int ch = _inputBuffer[_inputPtr++] & 0xFF;\n        if (ch == INT_APOSTROPHE) { // special case, ''\n            return BytesToNameCanonicalizer.getEmptyName();\n        }\n        int[] quads = _quadBuffer;\n        int qlen = 0;\n        int currQuad = 0;\n        int currQuadBytes = 0;\n\n        // Copied from parseEscapedFieldName, with minor mods:\n\n        final int[] codes = sInputCodesLatin1;\n\n        while (true) {\n            if (ch == INT_APOSTROPHE) {\n                break;\n            }\n            // additional check to skip handling of double-quotes\n            if (ch != INT_QUOTE && codes[ch] != 0) {\n                if (ch != INT_BACKSLASH) {\n                    // Unquoted white space?\n                    // As per [JACKSON-208], call can now return:\n                    _throwUnquotedSpace(ch, \"name\");\n                } else {\n                    // Nope, escape sequence\n                    ch = _decodeEscaped();\n                }\n                /* Oh crap. May need to UTF-8 (re-)encode it, if it's\n                 * beyond 7-bit ascii. Gets pretty messy.\n                 * If this happens often, may want to use different name\n                 * canonicalization to avoid these hits.\n                 */\n                if (ch > 127) {\n                    // Ok, we'll need room for first byte right away\n                    if (currQuadBytes >= 4) {\n                        if (qlen >= quads.length) {\n                            _quadBuffer = quads = growArrayBy(quads, quads.length);\n                        }\n                        quads[qlen++] = currQuad;\n                        currQuad = 0;\n                        currQuadBytes = 0;\n                    }\n                    if (ch < 0x800) { // 2-byte\n                        currQuad = (currQuad << 8) | (0xc0 | (ch >> 6));\n                        ++currQuadBytes;\n                        // Second byte gets output below:\n                    } else { // 3 bytes; no need to worry about surrogates here\n                        currQuad = (currQuad << 8) | (0xe0 | (ch >> 12));\n                        ++currQuadBytes;\n                        // need room for middle byte?\n                        if (currQuadBytes >= 4) {\n                            if (qlen >= quads.length) {\n                                _quadBuffer = quads = growArrayBy(quads, quads.length);\n                            }\n                            quads[qlen++] = currQuad;\n                            currQuad = 0;\n                            currQuadBytes = 0;\n                        }\n                        currQuad = (currQuad << 8) | (0x80 | ((ch >> 6) & 0x3f));\n                        ++currQuadBytes;\n                    }\n                    // And same last byte in both cases, gets output below:\n                    ch = 0x80 | (ch & 0x3f);\n                }\n            }\n            // Ok, we have one more byte to add at any rate:\n            if (currQuadBytes < 4) {\n                ++currQuadBytes;\n                currQuad = (currQuad << 8) | ch;\n            } else {\n                if (qlen >= quads.length) {\n                    _quadBuffer = quads = growArrayBy(quads, quads.length);\n                }\n                quads[qlen++] = currQuad;\n                currQuad = ch;\n                currQuadBytes = 1;\n            }\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\" in field name\");\n                }\n            }\nch = (_inputBuffer[_inputPtr++] | 0);\n        }\n\n        if (currQuadBytes > 0) {\n            if (qlen >= quads.length) {\n                _quadBuffer = quads = growArrayBy(quads, quads.length);\n            }\n            quads[qlen++] = currQuad;\n        }\n        Name name = _symbols.findName(quads, qlen);\n        if (name == null) {\n            name = addName(quads, qlen, currQuadBytes);\n        }\n        return name;\n    }",
          "13": "    protected Name _parseApostropheFieldName()\n        throws IOException, JsonParseException\n    {\n        if (_inputPtr >= _inputEnd) {\n            if (!loadMore()) {\n                _reportInvalidEOF(\": was expecting closing '\\'' for name\");\n            }\n        }\n        int ch = _inputBuffer[_inputPtr++] & 0xFF;\n        if (ch == INT_APOSTROPHE) { // special case, ''\n            return BytesToNameCanonicalizer.getEmptyName();\n        }\n        int[] quads = _quadBuffer;\n        int qlen = 0;\n        int currQuad = 0;\n        int currQuadBytes = 0;\n\n        // Copied from parseEscapedFieldName, with minor mods:\n\n        final int[] codes = sInputCodesLatin1;\n\n        while (true) {\n            if (ch == INT_APOSTROPHE) {\n                break;\n            }\n            // additional check to skip handling of double-quotes\n            if (ch != INT_QUOTE && codes[ch] != 0) {\n                if (ch != INT_BACKSLASH) {\n                    // Unquoted white space?\n                    // As per [JACKSON-208], call can now return:\n                    _throwUnquotedSpace(ch, \"name\");\n                } else {\n                    // Nope, escape sequence\n                    ch = _decodeEscaped();\n                }\n                /* Oh crap. May need to UTF-8 (re-)encode it, if it's\n                 * beyond 7-bit ascii. Gets pretty messy.\n                 * If this happens often, may want to use different name\n                 * canonicalization to avoid these hits.\n                 */\n                if (ch > 127) {\n                    // Ok, we'll need room for first byte right away\n                    if (currQuadBytes >= 4) {\n                        if (qlen >= quads.length) {\n                            _quadBuffer = quads = growArrayBy(quads, quads.length);\n                        }\n                        quads[qlen++] = currQuad;\n                        currQuad = 0;\n                        currQuadBytes = 0;\n                    }\n                    if (ch < 0x800) { // 2-byte\n                        currQuad = (currQuad << 8) | (0xc0 | (ch >> 6));\n                        ++currQuadBytes;\n                        // Second byte gets output below:\n                    } else { // 3 bytes; no need to worry about surrogates here\n                        currQuad = (currQuad << 8) | (0xe0 | (ch >> 12));\n                        ++currQuadBytes;\n                        // need room for middle byte?\n                        if (currQuadBytes >= 4) {\n                            if (qlen >= quads.length) {\n                                _quadBuffer = quads = growArrayBy(quads, quads.length);\n                            }\n                            quads[qlen++] = currQuad;\n                            currQuad = 0;\n                            currQuadBytes = 0;\n                        }\n                        currQuad = (currQuad << 8) | (0x80 | ((ch >> 6) & 0x3f));\n                        ++currQuadBytes;\n                    }\n                    // And same last byte in both cases, gets output below:\n                    ch = 0x80 | (ch & 0x3f);\n                }\n            }\n            // Ok, we have one more byte to add at any rate:\n            if (currQuadBytes < 4) {\n                ++currQuadBytes;\n                currQuad = (currQuad << 8) | ch;\n            } else {\n                if (qlen >= quads.length) {\n                    _quadBuffer = quads = growArrayBy(quads, quads.length);\n                }\n                quads[qlen++] = currQuad;\n                currQuad = ch;\n                currQuadBytes = 1;\n            }\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\" in field name\");\n                }\n            }\nch += (_inputBuffer[_inputPtr++] | 255);\n        }\n\n        if (currQuadBytes > 0) {\n            if (qlen >= quads.length) {\n                _quadBuffer = quads = growArrayBy(quads, quads.length);\n            }\n            quads[qlen++] = currQuad;\n        }\n        Name name = _symbols.findName(quads, qlen);\n        if (name == null) {\n            name = addName(quads, qlen, currQuadBytes);\n        }\n        return name;\n    }",
          "14": "    protected Name _parseApostropheFieldName()\n        throws IOException, JsonParseException\n    {\n        if (_inputPtr >= _inputEnd) {\n            if (!loadMore()) {\n                _reportInvalidEOF(\": was expecting closing '\\'' for name\");\n            }\n        }\n        int ch = _inputBuffer[_inputPtr++] & 0xFF;\n        if (ch == INT_APOSTROPHE) { // special case, ''\n            return BytesToNameCanonicalizer.getEmptyName();\n        }\n        int[] quads = _quadBuffer;\n        int qlen = 0;\n        int currQuad = 0;\n        int currQuadBytes = 0;\n\n        // Copied from parseEscapedFieldName, with minor mods:\n\n        final int[] codes = sInputCodesLatin1;\n\n        while (true) {\n            if (ch == INT_APOSTROPHE) {\n                break;\n            }\n            // additional check to skip handling of double-quotes\n            if (ch != INT_QUOTE && codes[ch] != 0) {\n                if (ch != INT_BACKSLASH) {\n                    // Unquoted white space?\n                    // As per [JACKSON-208], call can now return:\n                    _throwUnquotedSpace(ch, \"name\");\n                } else {\n                    // Nope, escape sequence\n                    ch = _decodeEscaped();\n                }\n                /* Oh crap. May need to UTF-8 (re-)encode it, if it's\n                 * beyond 7-bit ascii. Gets pretty messy.\n                 * If this happens often, may want to use different name\n                 * canonicalization to avoid these hits.\n                 */\n                if (ch > 127) {\n                    // Ok, we'll need room for first byte right away\n                    if (currQuadBytes >= 4) {\n                        if (qlen >= quads.length) {\n                            _quadBuffer = quads = growArrayBy(quads, quads.length);\n                        }\n                        quads[qlen++] = currQuad;\n                        currQuad = 0;\n                        currQuadBytes = 0;\n                    }\n                    if (ch < 0x800) { // 2-byte\n                        currQuad = (currQuad << 8) | (0xc0 | (ch >> 6));\n                        ++currQuadBytes;\n                        // Second byte gets output below:\n                    } else { // 3 bytes; no need to worry about surrogates here\n                        currQuad = (currQuad << 8) | (0xe0 | (ch >> 12));\n                        ++currQuadBytes;\n                        // need room for middle byte?\n                        if (currQuadBytes >= 4) {\n                            if (qlen >= quads.length) {\n                                _quadBuffer = quads = growArrayBy(quads, quads.length);\n                            }\n                            quads[qlen++] = currQuad;\n                            currQuad = 0;\n                            currQuadBytes = 0;\n                        }\n                        currQuad = (currQuad << 8) | (0x80 | ((ch >> 6) & 0x3f));\n                        ++currQuadBytes;\n                    }\n                    // And same last byte in both cases, gets output below:\n                    ch = 0x80 | (ch & 0x3f);\n                }\n            }\n            // Ok, we have one more byte to add at any rate:\n            if (currQuadBytes < 4) {\n                ++currQuadBytes;\n                currQuad = (currQuad << 8) | ch;\n            } else {\n                if (qlen >= quads.length) {\n                    _quadBuffer = quads = growArrayBy(quads, quads.length);\n                }\n                quads[qlen++] = currQuad;\n                currQuad = ch;\n                currQuadBytes = 1;\n            }\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\" in field name\");\n                }\n            }\nch = (_inputBuffer[_inputPtr++] == 255);\n        }\n\n        if (currQuadBytes > 0) {\n            if (qlen >= quads.length) {\n                _quadBuffer = quads = growArrayBy(quads, quads.length);\n            }\n            quads[qlen++] = currQuad;\n        }\n        Name name = _symbols.findName(quads, qlen);\n        if (name == null) {\n            name = addName(quads, qlen, currQuadBytes);\n        }\n        return name;\n    }",
          "15": "    protected Name _parseApostropheFieldName()\n        throws IOException, JsonParseException\n    {\n        if (_inputPtr >= _inputEnd) {\n            if (!loadMore()) {\n                _reportInvalidEOF(\": was expecting closing '\\'' for name\");\n            }\n        }\n        int ch = _inputBuffer[_inputPtr++] & 0xFF;\n        if (ch == INT_APOSTROPHE) { // special case, ''\n            return BytesToNameCanonicalizer.getEmptyName();\n        }\n        int[] quads = _quadBuffer;\n        int qlen = 0;\n        int currQuad = 0;\n        int currQuadBytes = 0;\n\n        // Copied from parseEscapedFieldName, with minor mods:\n\n        final int[] codes = sInputCodesLatin1;\n\n        while (true) {\n            if (ch == INT_APOSTROPHE) {\n                break;\n            }\n            // additional check to skip handling of double-quotes\n            if (ch != INT_QUOTE && codes[ch] != 0) {\n                if (ch != INT_BACKSLASH) {\n                    // Unquoted white space?\n                    // As per [JACKSON-208], call can now return:\n                    _throwUnquotedSpace(ch, \"name\");\n                } else {\n                    // Nope, escape sequence\n                    ch = _decodeEscaped();\n                }\n                /* Oh crap. May need to UTF-8 (re-)encode it, if it's\n                 * beyond 7-bit ascii. Gets pretty messy.\n                 * If this happens often, may want to use different name\n                 * canonicalization to avoid these hits.\n                 */\n                if (ch > 127) {\n                    // Ok, we'll need room for first byte right away\n                    if (currQuadBytes >= 4) {\n                        if (qlen >= quads.length) {\n                            _quadBuffer = quads = growArrayBy(quads, quads.length);\n                        }\n                        quads[qlen++] = currQuad;\n                        currQuad = 0;\n                        currQuadBytes = 0;\n                    }\n                    if (ch < 0x800) { // 2-byte\n                        currQuad = (currQuad << 8) | (0xc0 | (ch >> 6));\n                        ++currQuadBytes;\n                        // Second byte gets output below:\n                    } else { // 3 bytes; no need to worry about surrogates here\n                        currQuad = (currQuad << 8) | (0xe0 | (ch >> 12));\n                        ++currQuadBytes;\n                        // need room for middle byte?\n                        if (currQuadBytes >= 4) {\n                            if (qlen >= quads.length) {\n                                _quadBuffer = quads = growArrayBy(quads, quads.length);\n                            }\n                            quads[qlen++] = currQuad;\n                            currQuad = 0;\n                            currQuadBytes = 0;\n                        }\n                        currQuad = (currQuad << 8) | (0x80 | ((ch >> 6) & 0x3f));\n                        ++currQuadBytes;\n                    }\n                    // And same last byte in both cases, gets output below:\n                    ch = 0x80 | (ch & 0x3f);\n                }\n            }\n            // Ok, we have one more byte to add at any rate:\n            if (currQuadBytes < 4) {\n                ++currQuadBytes;\n                currQuad = (currQuad << 8) | ch;\n            } else {\n                if (qlen >= quads.length) {\n                    _quadBuffer = quads = growArrayBy(quads, quads.length);\n                }\n                quads[qlen++] = currQuad;\n                currQuad = ch;\n                currQuadBytes = 1;\n            }\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\" in field name\");\n                }\n            }\nch = (_inputBuffer[_inputPtr++] - 255);\n        }\n\n        if (currQuadBytes > 0) {\n            if (qlen >= quads.length) {\n                _quadBuffer = quads = growArrayBy(quads, quads.length);\n            }\n            quads[qlen++] = currQuad;\n        }\n        Name name = _symbols.findName(quads, qlen);\n        if (name == null) {\n            name = addName(quads, qlen, currQuadBytes);\n        }\n        return name;\n    }",
          "16": "    protected Name _parseApostropheFieldName()\n        throws IOException, JsonParseException\n    {\n        if (_inputPtr >= _inputEnd) {\n            if (!loadMore()) {\n                _reportInvalidEOF(\": was expecting closing '\\'' for name\");\n            }\n        }\n        int ch = _inputBuffer[_inputPtr++] & 0xFF;\n        if (ch == INT_APOSTROPHE) { // special case, ''\n            return BytesToNameCanonicalizer.getEmptyName();\n        }\n        int[] quads = _quadBuffer;\n        int qlen = 0;\n        int currQuad = 0;\n        int currQuadBytes = 0;\n\n        // Copied from parseEscapedFieldName, with minor mods:\n\n        final int[] codes = sInputCodesLatin1;\n\n        while (true) {\n            if (ch == INT_APOSTROPHE) {\n                break;\n            }\n            // additional check to skip handling of double-quotes\n            if (ch != INT_QUOTE && codes[ch] != 0) {\n                if (ch != INT_BACKSLASH) {\n                    // Unquoted white space?\n                    // As per [JACKSON-208], call can now return:\n                    _throwUnquotedSpace(ch, \"name\");\n                } else {\n                    // Nope, escape sequence\n                    ch = _decodeEscaped();\n                }\n                /* Oh crap. May need to UTF-8 (re-)encode it, if it's\n                 * beyond 7-bit ascii. Gets pretty messy.\n                 * If this happens often, may want to use different name\n                 * canonicalization to avoid these hits.\n                 */\n                if (ch > 127) {\n                    // Ok, we'll need room for first byte right away\n                    if (currQuadBytes >= 4) {\n                        if (qlen >= quads.length) {\n                            _quadBuffer = quads = growArrayBy(quads, quads.length);\n                        }\n                        quads[qlen++] = currQuad;\n                        currQuad = 0;\n                        currQuadBytes = 0;\n                    }\n                    if (ch < 0x800) { // 2-byte\n                        currQuad = (currQuad << 8) | (0xc0 | (ch >> 6));\n                        ++currQuadBytes;\n                        // Second byte gets output below:\n                    } else { // 3 bytes; no need to worry about surrogates here\n                        currQuad = (currQuad << 8) | (0xe0 | (ch >> 12));\n                        ++currQuadBytes;\n                        // need room for middle byte?\n                        if (currQuadBytes >= 4) {\n                            if (qlen >= quads.length) {\n                                _quadBuffer = quads = growArrayBy(quads, quads.length);\n                            }\n                            quads[qlen++] = currQuad;\n                            currQuad = 0;\n                            currQuadBytes = 0;\n                        }\n                        currQuad = (currQuad << 8) | (0x80 | ((ch >> 6) & 0x3f));\n                        ++currQuadBytes;\n                    }\n                    // And same last byte in both cases, gets output below:\n                    ch = 0x80 | (ch & 0x3f);\n                }\n            }\n            // Ok, we have one more byte to add at any rate:\n            if (currQuadBytes < 4) {\n                ++currQuadBytes;\n                currQuad = (currQuad << 8) | ch;\n            } else {\n                if (qlen >= quads.length) {\n                    _quadBuffer = quads = growArrayBy(quads, quads.length);\n                }\n                quads[qlen++] = currQuad;\n                currQuad = ch;\n                currQuadBytes = 1;\n            }\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\" in field name\");\n                }\n            }\nch = (ch[_inputPtr++] | 255);\n        }\n\n        if (currQuadBytes > 0) {\n            if (qlen >= quads.length) {\n                _quadBuffer = quads = growArrayBy(quads, quads.length);\n            }\n            quads[qlen++] = currQuad;\n        }\n        Name name = _symbols.findName(quads, qlen);\n        if (name == null) {\n            name = addName(quads, qlen, currQuadBytes);\n        }\n        return name;\n    }",
          "17": "    protected Name _parseApostropheFieldName()\n        throws IOException, JsonParseException\n    {\n        if (_inputPtr >= _inputEnd) {\n            if (!loadMore()) {\n                _reportInvalidEOF(\": was expecting closing '\\'' for name\");\n            }\n        }\n        int ch = _inputBuffer[_inputPtr++] & 0xFF;\n        if (ch == INT_APOSTROPHE) { // special case, ''\n            return BytesToNameCanonicalizer.getEmptyName();\n        }\n        int[] quads = _quadBuffer;\n        int qlen = 0;\n        int currQuad = 0;\n        int currQuadBytes = 0;\n\n        // Copied from parseEscapedFieldName, with minor mods:\n\n        final int[] codes = sInputCodesLatin1;\n\n        while (true) {\n            if (ch == INT_APOSTROPHE) {\n                break;\n            }\n            // additional check to skip handling of double-quotes\n            if (ch != INT_QUOTE && codes[ch] != 0) {\n                if (ch != INT_BACKSLASH) {\n                    // Unquoted white space?\n                    // As per [JACKSON-208], call can now return:\n                    _throwUnquotedSpace(ch, \"name\");\n                } else {\n                    // Nope, escape sequence\n                    ch = _decodeEscaped();\n                }\n                /* Oh crap. May need to UTF-8 (re-)encode it, if it's\n                 * beyond 7-bit ascii. Gets pretty messy.\n                 * If this happens often, may want to use different name\n                 * canonicalization to avoid these hits.\n                 */\n                if (ch > 127) {\n                    // Ok, we'll need room for first byte right away\n                    if (currQuadBytes >= 4) {\n                        if (qlen >= quads.length) {\n                            _quadBuffer = quads = growArrayBy(quads, quads.length);\n                        }\n                        quads[qlen++] = currQuad;\n                        currQuad = 0;\n                        currQuadBytes = 0;\n                    }\n                    if (ch < 0x800) { // 2-byte\n                        currQuad = (currQuad << 8) | (0xc0 | (ch >> 6));\n                        ++currQuadBytes;\n                        // Second byte gets output below:\n                    } else { // 3 bytes; no need to worry about surrogates here\n                        currQuad = (currQuad << 8) | (0xe0 | (ch >> 12));\n                        ++currQuadBytes;\n                        // need room for middle byte?\n                        if (currQuadBytes >= 4) {\n                            if (qlen >= quads.length) {\n                                _quadBuffer = quads = growArrayBy(quads, quads.length);\n                            }\n                            quads[qlen++] = currQuad;\n                            currQuad = 0;\n                            currQuadBytes = 0;\n                        }\n                        currQuad = (currQuad << 8) | (0x80 | ((ch >> 6) & 0x3f));\n                        ++currQuadBytes;\n                    }\n                    // And same last byte in both cases, gets output below:\n                    ch = 0x80 | (ch & 0x3f);\n                }\n            }\n            // Ok, we have one more byte to add at any rate:\n            if (currQuadBytes < 4) {\n                ++currQuadBytes;\n                currQuad = (currQuad << 8) | ch;\n            } else {\n                if (qlen >= quads.length) {\n                    _quadBuffer = quads = growArrayBy(quads, quads.length);\n                }\n                quads[qlen++] = currQuad;\n                currQuad = ch;\n                currQuadBytes = 1;\n            }\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\" in field name\");\n                }\n            }\n_inputBuffer[_inputPtr++] = (_inputBuffer[_inputPtr++] | 255);\n        }\n\n        if (currQuadBytes > 0) {\n            if (qlen >= quads.length) {\n                _quadBuffer = quads = growArrayBy(quads, quads.length);\n            }\n            quads[qlen++] = currQuad;\n        }\n        Name name = _symbols.findName(quads, qlen);\n        if (name == null) {\n            name = addName(quads, qlen, currQuadBytes);\n        }\n        return name;\n    }",
          "18": "    protected Name _parseApostropheFieldName()\n        throws IOException, JsonParseException\n    {\n        if (_inputPtr >= _inputEnd) {\n            if (!loadMore()) {\n                _reportInvalidEOF(\": was expecting closing '\\'' for name\");\n            }\n        }\n        int ch = _inputBuffer[_inputPtr++] & 0xFF;\n        if (ch == INT_APOSTROPHE) { // special case, ''\n            return BytesToNameCanonicalizer.getEmptyName();\n        }\n        int[] quads = _quadBuffer;\n        int qlen = 0;\n        int currQuad = 0;\n        int currQuadBytes = 0;\n\n        // Copied from parseEscapedFieldName, with minor mods:\n\n        final int[] codes = sInputCodesLatin1;\n\n        while (true) {\n            if (ch == INT_APOSTROPHE) {\n                break;\n            }\n            // additional check to skip handling of double-quotes\n            if (ch != INT_QUOTE && codes[ch] != 0) {\n                if (ch != INT_BACKSLASH) {\n                    // Unquoted white space?\n                    // As per [JACKSON-208], call can now return:\n                    _throwUnquotedSpace(ch, \"name\");\n                } else {\n                    // Nope, escape sequence\n                    ch = _decodeEscaped();\n                }\n                /* Oh crap. May need to UTF-8 (re-)encode it, if it's\n                 * beyond 7-bit ascii. Gets pretty messy.\n                 * If this happens often, may want to use different name\n                 * canonicalization to avoid these hits.\n                 */\n                if (ch > 127) {\n                    // Ok, we'll need room for first byte right away\n                    if (currQuadBytes >= 4) {\n                        if (qlen >= quads.length) {\n                            _quadBuffer = quads = growArrayBy(quads, quads.length);\n                        }\n                        quads[qlen++] = currQuad;\n                        currQuad = 0;\n                        currQuadBytes = 0;\n                    }\n                    if (ch < 0x800) { // 2-byte\n                        currQuad = (currQuad << 8) | (0xc0 | (ch >> 6));\n                        ++currQuadBytes;\n                        // Second byte gets output below:\n                    } else { // 3 bytes; no need to worry about surrogates here\n                        currQuad = (currQuad << 8) | (0xe0 | (ch >> 12));\n                        ++currQuadBytes;\n                        // need room for middle byte?\n                        if (currQuadBytes >= 4) {\n                            if (qlen >= quads.length) {\n                                _quadBuffer = quads = growArrayBy(quads, quads.length);\n                            }\n                            quads[qlen++] = currQuad;\n                            currQuad = 0;\n                            currQuadBytes = 0;\n                        }\n                        currQuad = (currQuad << 8) | (0x80 | ((ch >> 6) & 0x3f));\n                        ++currQuadBytes;\n                    }\n                    // And same last byte in both cases, gets output below:\n                    ch = 0x80 | (ch & 0x3f);\n                }\n            }\n            // Ok, we have one more byte to add at any rate:\n            if (currQuadBytes < 4) {\n                ++currQuadBytes;\n                currQuad = (currQuad << 8) | ch;\n            } else {\n                if (qlen >= quads.length) {\n                    _quadBuffer = quads = growArrayBy(quads, quads.length);\n                }\n                quads[qlen++] = currQuad;\n                currQuad = ch;\n                currQuadBytes = 1;\n            }\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\" in field name\");\n                }\n            }\nch = (_inputBuffer[_inputPtr++] * 255);\n        }\n\n        if (currQuadBytes > 0) {\n            if (qlen >= quads.length) {\n                _quadBuffer = quads = growArrayBy(quads, quads.length);\n            }\n            quads[qlen++] = currQuad;\n        }\n        Name name = _symbols.findName(quads, qlen);\n        if (name == null) {\n            name = addName(quads, qlen, currQuadBytes);\n        }\n        return name;\n    }",
          "19": "    protected Name _parseApostropheFieldName()\n        throws IOException, JsonParseException\n    {\n        if (_inputPtr >= _inputEnd) {\n            if (!loadMore()) {\n                _reportInvalidEOF(\": was expecting closing '\\'' for name\");\n            }\n        }\n        int ch = _inputBuffer[_inputPtr++] & 0xFF;\n        if (ch == INT_APOSTROPHE) { // special case, ''\n            return BytesToNameCanonicalizer.getEmptyName();\n        }\n        int[] quads = _quadBuffer;\n        int qlen = 0;\n        int currQuad = 0;\n        int currQuadBytes = 0;\n\n        // Copied from parseEscapedFieldName, with minor mods:\n\n        final int[] codes = sInputCodesLatin1;\n\n        while (true) {\n            if (ch == INT_APOSTROPHE) {\n                break;\n            }\n            // additional check to skip handling of double-quotes\n            if (ch != INT_QUOTE && codes[ch] != 0) {\n                if (ch != INT_BACKSLASH) {\n                    // Unquoted white space?\n                    // As per [JACKSON-208], call can now return:\n                    _throwUnquotedSpace(ch, \"name\");\n                } else {\n                    // Nope, escape sequence\n                    ch = _decodeEscaped();\n                }\n                /* Oh crap. May need to UTF-8 (re-)encode it, if it's\n                 * beyond 7-bit ascii. Gets pretty messy.\n                 * If this happens often, may want to use different name\n                 * canonicalization to avoid these hits.\n                 */\n                if (ch > 127) {\n                    // Ok, we'll need room for first byte right away\n                    if (currQuadBytes >= 4) {\n                        if (qlen >= quads.length) {\n                            _quadBuffer = quads = growArrayBy(quads, quads.length);\n                        }\n                        quads[qlen++] = currQuad;\n                        currQuad = 0;\n                        currQuadBytes = 0;\n                    }\n                    if (ch < 0x800) { // 2-byte\n                        currQuad = (currQuad << 8) | (0xc0 | (ch >> 6));\n                        ++currQuadBytes;\n                        // Second byte gets output below:\n                    } else { // 3 bytes; no need to worry about surrogates here\n                        currQuad = (currQuad << 8) | (0xe0 | (ch >> 12));\n                        ++currQuadBytes;\n                        // need room for middle byte?\n                        if (currQuadBytes >= 4) {\n                            if (qlen >= quads.length) {\n                                _quadBuffer = quads = growArrayBy(quads, quads.length);\n                            }\n                            quads[qlen++] = currQuad;\n                            currQuad = 0;\n                            currQuadBytes = 0;\n                        }\n                        currQuad = (currQuad << 8) | (0x80 | ((ch >> 6) & 0x3f));\n                        ++currQuadBytes;\n                    }\n                    // And same last byte in both cases, gets output below:\n                    ch = 0x80 | (ch & 0x3f);\n                }\n            }\n            // Ok, we have one more byte to add at any rate:\n            if (currQuadBytes < 4) {\n                ++currQuadBytes;\n                currQuad = (currQuad << 8) | ch;\n            } else {\n                if (qlen >= quads.length) {\n                    _quadBuffer = quads = growArrayBy(quads, quads.length);\n                }\n                quads[qlen++] = currQuad;\n                currQuad = ch;\n                currQuadBytes = 1;\n            }\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\" in field name\");\n                }\n            }\nch = (_inputPtr[_inputPtr++] | 255);\n        }\n\n        if (currQuadBytes > 0) {\n            if (qlen >= quads.length) {\n                _quadBuffer = quads = growArrayBy(quads, quads.length);\n            }\n            quads[qlen++] = currQuad;\n        }\n        Name name = _symbols.findName(quads, qlen);\n        if (name == null) {\n            name = addName(quads, qlen, currQuadBytes);\n        }\n        return name;\n    }",
          "20": "    protected Name _parseApostropheFieldName()\n        throws IOException, JsonParseException\n    {\n        if (_inputPtr >= _inputEnd) {\n            if (!loadMore()) {\n                _reportInvalidEOF(\": was expecting closing '\\'' for name\");\n            }\n        }\n        int ch = _inputBuffer[_inputPtr++] & 0xFF;\n        if (ch == INT_APOSTROPHE) { // special case, ''\n            return BytesToNameCanonicalizer.getEmptyName();\n        }\n        int[] quads = _quadBuffer;\n        int qlen = 0;\n        int currQuad = 0;\n        int currQuadBytes = 0;\n\n        // Copied from parseEscapedFieldName, with minor mods:\n\n        final int[] codes = sInputCodesLatin1;\n\n        while (true) {\n            if (ch == INT_APOSTROPHE) {\n                break;\n            }\n            // additional check to skip handling of double-quotes\n            if (ch != INT_QUOTE && codes[ch] != 0) {\n                if (ch != INT_BACKSLASH) {\n                    // Unquoted white space?\n                    // As per [JACKSON-208], call can now return:\n                    _throwUnquotedSpace(ch, \"name\");\n                } else {\n                    // Nope, escape sequence\n                    ch = _decodeEscaped();\n                }\n                /* Oh crap. May need to UTF-8 (re-)encode it, if it's\n                 * beyond 7-bit ascii. Gets pretty messy.\n                 * If this happens often, may want to use different name\n                 * canonicalization to avoid these hits.\n                 */\n                if (ch > 127) {\n                    // Ok, we'll need room for first byte right away\n                    if (currQuadBytes >= 4) {\n                        if (qlen >= quads.length) {\n                            _quadBuffer = quads = growArrayBy(quads, quads.length);\n                        }\n                        quads[qlen++] = currQuad;\n                        currQuad = 0;\n                        currQuadBytes = 0;\n                    }\n                    if (ch < 0x800) { // 2-byte\n                        currQuad = (currQuad << 8) | (0xc0 | (ch >> 6));\n                        ++currQuadBytes;\n                        // Second byte gets output below:\n                    } else { // 3 bytes; no need to worry about surrogates here\n                        currQuad = (currQuad << 8) | (0xe0 | (ch >> 12));\n                        ++currQuadBytes;\n                        // need room for middle byte?\n                        if (currQuadBytes >= 4) {\n                            if (qlen >= quads.length) {\n                                _quadBuffer = quads = growArrayBy(quads, quads.length);\n                            }\n                            quads[qlen++] = currQuad;\n                            currQuad = 0;\n                            currQuadBytes = 0;\n                        }\n                        currQuad = (currQuad << 8) | (0x80 | ((ch >> 6) & 0x3f));\n                        ++currQuadBytes;\n                    }\n                    // And same last byte in both cases, gets output below:\n                    ch = 0x80 | (ch & 0x3f);\n                }\n            }\n            // Ok, we have one more byte to add at any rate:\n            if (currQuadBytes < 4) {\n                ++currQuadBytes;\n                currQuad = (currQuad << 8) | ch;\n            } else {\n                if (qlen >= quads.length) {\n                    _quadBuffer = quads = growArrayBy(quads, quads.length);\n                }\n                quads[qlen++] = currQuad;\n                currQuad = ch;\n                currQuadBytes = 1;\n            }\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\" in field name\");\n                }\n            }\nch[_inputPtr++];\n        }\n\n        if (currQuadBytes > 0) {\n            if (qlen >= quads.length) {\n                _quadBuffer = quads = growArrayBy(quads, quads.length);\n            }\n            quads[qlen++] = currQuad;\n        }\n        Name name = _symbols.findName(quads, qlen);\n        if (name == null) {\n            name = addName(quads, qlen, currQuadBytes);\n        }\n        return name;\n    }",
          "21": "    protected Name _parseApostropheFieldName()\n        throws IOException, JsonParseException\n    {\n        if (_inputPtr >= _inputEnd) {\n            if (!loadMore()) {\n                _reportInvalidEOF(\": was expecting closing '\\'' for name\");\n            }\n        }\n        int ch = _inputBuffer[_inputPtr++] & 0xFF;\n        if (ch == INT_APOSTROPHE) { // special case, ''\n            return BytesToNameCanonicalizer.getEmptyName();\n        }\n        int[] quads = _quadBuffer;\n        int qlen = 0;\n        int currQuad = 0;\n        int currQuadBytes = 0;\n\n        // Copied from parseEscapedFieldName, with minor mods:\n\n        final int[] codes = sInputCodesLatin1;\n\n        while (true) {\n            if (ch == INT_APOSTROPHE) {\n                break;\n            }\n            // additional check to skip handling of double-quotes\n            if (ch != INT_QUOTE && codes[ch] != 0) {\n                if (ch != INT_BACKSLASH) {\n                    // Unquoted white space?\n                    // As per [JACKSON-208], call can now return:\n                    _throwUnquotedSpace(ch, \"name\");\n                } else {\n                    // Nope, escape sequence\n                    ch = _decodeEscaped();\n                }\n                /* Oh crap. May need to UTF-8 (re-)encode it, if it's\n                 * beyond 7-bit ascii. Gets pretty messy.\n                 * If this happens often, may want to use different name\n                 * canonicalization to avoid these hits.\n                 */\n                if (ch > 127) {\n                    // Ok, we'll need room for first byte right away\n                    if (currQuadBytes >= 4) {\n                        if (qlen >= quads.length) {\n                            _quadBuffer = quads = growArrayBy(quads, quads.length);\n                        }\n                        quads[qlen++] = currQuad;\n                        currQuad = 0;\n                        currQuadBytes = 0;\n                    }\n                    if (ch < 0x800) { // 2-byte\n                        currQuad = (currQuad << 8) | (0xc0 | (ch >> 6));\n                        ++currQuadBytes;\n                        // Second byte gets output below:\n                    } else { // 3 bytes; no need to worry about surrogates here\n                        currQuad = (currQuad << 8) | (0xe0 | (ch >> 12));\n                        ++currQuadBytes;\n                        // need room for middle byte?\n                        if (currQuadBytes >= 4) {\n                            if (qlen >= quads.length) {\n                                _quadBuffer = quads = growArrayBy(quads, quads.length);\n                            }\n                            quads[qlen++] = currQuad;\n                            currQuad = 0;\n                            currQuadBytes = 0;\n                        }\n                        currQuad = (currQuad << 8) | (0x80 | ((ch >> 6) & 0x3f));\n                        ++currQuadBytes;\n                    }\n                    // And same last byte in both cases, gets output below:\n                    ch = 0x80 | (ch & 0x3f);\n                }\n            }\n            // Ok, we have one more byte to add at any rate:\n            if (currQuadBytes < 4) {\n                ++currQuadBytes;\n                currQuad = (currQuad << 8) | ch;\n            } else {\n                if (qlen >= quads.length) {\n                    _quadBuffer = quads = growArrayBy(quads, quads.length);\n                }\n                quads[qlen++] = currQuad;\n                currQuad = ch;\n                currQuadBytes = 1;\n            }\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\" in field name\");\n                }\n            }\nch[_inputPtr++] = (_inputBuffer[_inputPtr++] | 255);\n        }\n\n        if (currQuadBytes > 0) {\n            if (qlen >= quads.length) {\n                _quadBuffer = quads = growArrayBy(quads, quads.length);\n            }\n            quads[qlen++] = currQuad;\n        }\n        Name name = _symbols.findName(quads, qlen);\n        if (name == null) {\n            name = addName(quads, qlen, currQuadBytes);\n        }\n        return name;\n    }",
          "22": "    protected Name _parseApostropheFieldName()\n        throws IOException, JsonParseException\n    {\n        if (_inputPtr >= _inputEnd) {\n            if (!loadMore()) {\n                _reportInvalidEOF(\": was expecting closing '\\'' for name\");\n            }\n        }\n        int ch = _inputBuffer[_inputPtr++] & 0xFF;\n        if (ch == INT_APOSTROPHE) { // special case, ''\n            return BytesToNameCanonicalizer.getEmptyName();\n        }\n        int[] quads = _quadBuffer;\n        int qlen = 0;\n        int currQuad = 0;\n        int currQuadBytes = 0;\n\n        // Copied from parseEscapedFieldName, with minor mods:\n\n        final int[] codes = sInputCodesLatin1;\n\n        while (true) {\n            if (ch == INT_APOSTROPHE) {\n                break;\n            }\n            // additional check to skip handling of double-quotes\n            if (ch != INT_QUOTE && codes[ch] != 0) {\n                if (ch != INT_BACKSLASH) {\n                    // Unquoted white space?\n                    // As per [JACKSON-208], call can now return:\n                    _throwUnquotedSpace(ch, \"name\");\n                } else {\n                    // Nope, escape sequence\n                    ch = _decodeEscaped();\n                }\n                /* Oh crap. May need to UTF-8 (re-)encode it, if it's\n                 * beyond 7-bit ascii. Gets pretty messy.\n                 * If this happens often, may want to use different name\n                 * canonicalization to avoid these hits.\n                 */\n                if (ch > 127) {\n                    // Ok, we'll need room for first byte right away\n                    if (currQuadBytes >= 4) {\n                        if (qlen >= quads.length) {\n                            _quadBuffer = quads = growArrayBy(quads, quads.length);\n                        }\n                        quads[qlen++] = currQuad;\n                        currQuad = 0;\n                        currQuadBytes = 0;\n                    }\n                    if (ch < 0x800) { // 2-byte\n                        currQuad = (currQuad << 8) | (0xc0 | (ch >> 6));\n                        ++currQuadBytes;\n                        // Second byte gets output below:\n                    } else { // 3 bytes; no need to worry about surrogates here\n                        currQuad = (currQuad << 8) | (0xe0 | (ch >> 12));\n                        ++currQuadBytes;\n                        // need room for middle byte?\n                        if (currQuadBytes >= 4) {\n                            if (qlen >= quads.length) {\n                                _quadBuffer = quads = growArrayBy(quads, quads.length);\n                            }\n                            quads[qlen++] = currQuad;\n                            currQuad = 0;\n                            currQuadBytes = 0;\n                        }\n                        currQuad = (currQuad << 8) | (0x80 | ((ch >> 6) & 0x3f));\n                        ++currQuadBytes;\n                    }\n                    // And same last byte in both cases, gets output below:\n                    ch = 0x80 | (ch & 0x3f);\n                }\n            }\n            // Ok, we have one more byte to add at any rate:\n            if (currQuadBytes < 4) {\n                ++currQuadBytes;\n                currQuad = (currQuad << 8) | ch;\n            } else {\n                if (qlen >= quads.length) {\n                    _quadBuffer = quads = growArrayBy(quads, quads.length);\n                }\n                quads[qlen++] = currQuad;\n                currQuad = ch;\n                currQuadBytes = 1;\n            }\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\" in field name\");\n                }\n            }\n        }\n\n        if (currQuadBytes > 0) {\n            if (qlen >= quads.length) {\n                _quadBuffer = quads = growArrayBy(quads, quads.length);\n            }\n            quads[qlen++] = currQuad;\n        }\n        Name name = _symbols.findName(quads, qlen);\n        if (name == null) {\n            name = addName(quads, qlen, currQuadBytes);\n        }\n        return name;\n    }",
          "23": "    protected Name _parseApostropheFieldName()\n        throws IOException, JsonParseException\n    {\n        if (_inputPtr >= _inputEnd) {\n            if (!loadMore()) {\n                _reportInvalidEOF(\": was expecting closing '\\'' for name\");\n            }\n        }\n        int ch = _inputBuffer[_inputPtr++] & 0xFF;\n        if (ch == INT_APOSTROPHE) { // special case, ''\n            return BytesToNameCanonicalizer.getEmptyName();\n        }\n        int[] quads = _quadBuffer;\n        int qlen = 0;\n        int currQuad = 0;\n        int currQuadBytes = 0;\n\n        // Copied from parseEscapedFieldName, with minor mods:\n\n        final int[] codes = sInputCodesLatin1;\n\n        while (true) {\n            if (ch == INT_APOSTROPHE) {\n                break;\n            }\n            // additional check to skip handling of double-quotes\n            if (ch != INT_QUOTE && codes[ch] != 0) {\n                if (ch != INT_BACKSLASH) {\n                    // Unquoted white space?\n                    // As per [JACKSON-208], call can now return:\n                    _throwUnquotedSpace(ch, \"name\");\n                } else {\n                    // Nope, escape sequence\n                    ch = _decodeEscaped();\n                }\n                /* Oh crap. May need to UTF-8 (re-)encode it, if it's\n                 * beyond 7-bit ascii. Gets pretty messy.\n                 * If this happens often, may want to use different name\n                 * canonicalization to avoid these hits.\n                 */\n                if (ch > 127) {\n                    // Ok, we'll need room for first byte right away\n                    if (currQuadBytes >= 4) {\n                        if (qlen >= quads.length) {\n                            _quadBuffer = quads = growArrayBy(quads, quads.length);\n                        }\n                        quads[qlen++] = currQuad;\n                        currQuad = 0;\n                        currQuadBytes = 0;\n                    }\n                    if (ch < 0x800) { // 2-byte\n                        currQuad = (currQuad << 8) | (0xc0 | (ch >> 6));\n                        ++currQuadBytes;\n                        // Second byte gets output below:\n                    } else { // 3 bytes; no need to worry about surrogates here\n                        currQuad = (currQuad << 8) | (0xe0 | (ch >> 12));\n                        ++currQuadBytes;\n                        // need room for middle byte?\n                        if (currQuadBytes >= 4) {\n                            if (qlen >= quads.length) {\n                                _quadBuffer = quads = growArrayBy(quads, quads.length);\n                            }\n                            quads[qlen++] = currQuad;\n                            currQuad = 0;\n                            currQuadBytes = 0;\n                        }\n                        currQuad = (currQuad << 8) | (0x80 | ((ch >> 6) & 0x3f));\n                        ++currQuadBytes;\n                    }\n                    // And same last byte in both cases, gets output below:\n                    ch = 0x80 | (ch & 0x3f);\n                }\n            }\n            // Ok, we have one more byte to add at any rate:\n            if (currQuadBytes < 4) {\n                ++currQuadBytes;\n                currQuad = (currQuad << 8) | ch;\n            } else {\n                if (qlen >= quads.length) {\n                    _quadBuffer = quads = growArrayBy(quads, quads.length);\n                }\n                quads[qlen++] = currQuad;\n                currQuad = ch;\n                currQuadBytes = 1;\n            }\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\" in field name\");\n                }\n            }\nch = (_inputBuffer[(_inputBuffer[_inputPtr++] | 255)] | 255);\n        }\n\n        if (currQuadBytes > 0) {\n            if (qlen >= quads.length) {\n                _quadBuffer = quads = growArrayBy(quads, quads.length);\n            }\n            quads[qlen++] = currQuad;\n        }\n        Name name = _symbols.findName(quads, qlen);\n        if (name == null) {\n            name = addName(quads, qlen, currQuadBytes);\n        }\n        return name;\n    }",
          "24": "    protected Name _parseApostropheFieldName()\n        throws IOException, JsonParseException\n    {\n        if (_inputPtr >= _inputEnd) {\n            if (!loadMore()) {\n                _reportInvalidEOF(\": was expecting closing '\\'' for name\");\n            }\n        }\n        int ch = _inputBuffer[_inputPtr++] & 0xFF;\n        if (ch == INT_APOSTROPHE) { // special case, ''\n            return BytesToNameCanonicalizer.getEmptyName();\n        }\n        int[] quads = _quadBuffer;\n        int qlen = 0;\n        int currQuad = 0;\n        int currQuadBytes = 0;\n\n        // Copied from parseEscapedFieldName, with minor mods:\n\n        final int[] codes = sInputCodesLatin1;\n\n        while (true) {\n            if (ch == INT_APOSTROPHE) {\n                break;\n            }\n            // additional check to skip handling of double-quotes\n            if (ch != INT_QUOTE && codes[ch] != 0) {\n                if (ch != INT_BACKSLASH) {\n                    // Unquoted white space?\n                    // As per [JACKSON-208], call can now return:\n                    _throwUnquotedSpace(ch, \"name\");\n                } else {\n                    // Nope, escape sequence\n                    ch = _decodeEscaped();\n                }\n                /* Oh crap. May need to UTF-8 (re-)encode it, if it's\n                 * beyond 7-bit ascii. Gets pretty messy.\n                 * If this happens often, may want to use different name\n                 * canonicalization to avoid these hits.\n                 */\n                if (ch > 127) {\n                    // Ok, we'll need room for first byte right away\n                    if (currQuadBytes >= 4) {\n                        if (qlen >= quads.length) {\n                            _quadBuffer = quads = growArrayBy(quads, quads.length);\n                        }\n                        quads[qlen++] = currQuad;\n                        currQuad = 0;\n                        currQuadBytes = 0;\n                    }\n                    if (ch < 0x800) { // 2-byte\n                        currQuad = (currQuad << 8) | (0xc0 | (ch >> 6));\n                        ++currQuadBytes;\n                        // Second byte gets output below:\n                    } else { // 3 bytes; no need to worry about surrogates here\n                        currQuad = (currQuad << 8) | (0xe0 | (ch >> 12));\n                        ++currQuadBytes;\n                        // need room for middle byte?\n                        if (currQuadBytes >= 4) {\n                            if (qlen >= quads.length) {\n                                _quadBuffer = quads = growArrayBy(quads, quads.length);\n                            }\n                            quads[qlen++] = currQuad;\n                            currQuad = 0;\n                            currQuadBytes = 0;\n                        }\n                        currQuad = (currQuad << 8) | (0x80 | ((ch >> 6) & 0x3f));\n                        ++currQuadBytes;\n                    }\n                    // And same last byte in both cases, gets output below:\n                    ch = 0x80 | (ch & 0x3f);\n                }\n            }\n            // Ok, we have one more byte to add at any rate:\n            if (currQuadBytes < 4) {\n                ++currQuadBytes;\n                currQuad = (currQuad << 8) | ch;\n            } else {\n                if (qlen >= quads.length) {\n                    _quadBuffer = quads = growArrayBy(quads, quads.length);\n                }\n                quads[qlen++] = currQuad;\n                currQuad = ch;\n                currQuadBytes = 1;\n            }\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\" in field name\");\n                }\n            }\nch -= (_inputBuffer[_inputPtr++] | 255);\n        }\n\n        if (currQuadBytes > 0) {\n            if (qlen >= quads.length) {\n                _quadBuffer = quads = growArrayBy(quads, quads.length);\n            }\n            quads[qlen++] = currQuad;\n        }\n        Name name = _symbols.findName(quads, qlen);\n        if (name == null) {\n            name = addName(quads, qlen, currQuadBytes);\n        }\n        return name;\n    }",
          "25": "    protected Name _parseApostropheFieldName()\n        throws IOException, JsonParseException\n    {\n        if (_inputPtr >= _inputEnd) {\n            if (!loadMore()) {\n                _reportInvalidEOF(\": was expecting closing '\\'' for name\");\n            }\n        }\n        int ch = _inputBuffer[_inputPtr++] & 0xFF;\n        if (ch == INT_APOSTROPHE) { // special case, ''\n            return BytesToNameCanonicalizer.getEmptyName();\n        }\n        int[] quads = _quadBuffer;\n        int qlen = 0;\n        int currQuad = 0;\n        int currQuadBytes = 0;\n\n        // Copied from parseEscapedFieldName, with minor mods:\n\n        final int[] codes = sInputCodesLatin1;\n\n        while (true) {\n            if (ch == INT_APOSTROPHE) {\n                break;\n            }\n            // additional check to skip handling of double-quotes\n            if (ch != INT_QUOTE && codes[ch] != 0) {\n                if (ch != INT_BACKSLASH) {\n                    // Unquoted white space?\n                    // As per [JACKSON-208], call can now return:\n                    _throwUnquotedSpace(ch, \"name\");\n                } else {\n                    // Nope, escape sequence\n                    ch = _decodeEscaped();\n                }\n                /* Oh crap. May need to UTF-8 (re-)encode it, if it's\n                 * beyond 7-bit ascii. Gets pretty messy.\n                 * If this happens often, may want to use different name\n                 * canonicalization to avoid these hits.\n                 */\n                if (ch > 127) {\n                    // Ok, we'll need room for first byte right away\n                    if (currQuadBytes >= 4) {\n                        if (qlen >= quads.length) {\n                            _quadBuffer = quads = growArrayBy(quads, quads.length);\n                        }\n                        quads[qlen++] = currQuad;\n                        currQuad = 0;\n                        currQuadBytes = 0;\n                    }\n                    if (ch < 0x800) { // 2-byte\n                        currQuad = (currQuad << 8) | (0xc0 | (ch >> 6));\n                        ++currQuadBytes;\n                        // Second byte gets output below:\n                    } else { // 3 bytes; no need to worry about surrogates here\n                        currQuad = (currQuad << 8) | (0xe0 | (ch >> 12));\n                        ++currQuadBytes;\n                        // need room for middle byte?\n                        if (currQuadBytes >= 4) {\n                            if (qlen >= quads.length) {\n                                _quadBuffer = quads = growArrayBy(quads, quads.length);\n                            }\n                            quads[qlen++] = currQuad;\n                            currQuad = 0;\n                            currQuadBytes = 0;\n                        }\n                        currQuad = (currQuad << 8) | (0x80 | ((ch >> 6) & 0x3f));\n                        ++currQuadBytes;\n                    }\n                    // And same last byte in both cases, gets output below:\n                    ch = 0x80 | (ch & 0x3f);\n                }\n            }\n            // Ok, we have one more byte to add at any rate:\n            if (currQuadBytes < 4) {\n                ++currQuadBytes;\n                currQuad = (currQuad << 8) | ch;\n            } else {\n                if (qlen >= quads.length) {\n                    _quadBuffer = quads = growArrayBy(quads, quads.length);\n                }\n                quads[qlen++] = currQuad;\n                currQuad = ch;\n                currQuadBytes = 1;\n            }\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\" in field name\");\n                }\n            }\nch++;\n        }\n\n        if (currQuadBytes > 0) {\n            if (qlen >= quads.length) {\n                _quadBuffer = quads = growArrayBy(quads, quads.length);\n            }\n            quads[qlen++] = currQuad;\n        }\n        Name name = _symbols.findName(quads, qlen);\n        if (name == null) {\n            name = addName(quads, qlen, currQuadBytes);\n        }\n        return name;\n    }",
          "26": "    protected Name _parseApostropheFieldName()\n        throws IOException, JsonParseException\n    {\n        if (_inputPtr >= _inputEnd) {\n            if (!loadMore()) {\n                _reportInvalidEOF(\": was expecting closing '\\'' for name\");\n            }\n        }\n        int ch = _inputBuffer[_inputPtr++] & 0xFF;\n        if (ch == INT_APOSTROPHE) { // special case, ''\n            return BytesToNameCanonicalizer.getEmptyName();\n        }\n        int[] quads = _quadBuffer;\n        int qlen = 0;\n        int currQuad = 0;\n        int currQuadBytes = 0;\n\n        // Copied from parseEscapedFieldName, with minor mods:\n\n        final int[] codes = sInputCodesLatin1;\n\n        while (true) {\n            if (ch == INT_APOSTROPHE) {\n                break;\n            }\n            // additional check to skip handling of double-quotes\n            if (ch != INT_QUOTE && codes[ch] != 0) {\n                if (ch != INT_BACKSLASH) {\n                    // Unquoted white space?\n                    // As per [JACKSON-208], call can now return:\n                    _throwUnquotedSpace(ch, \"name\");\n                } else {\n                    // Nope, escape sequence\n                    ch = _decodeEscaped();\n                }\n                /* Oh crap. May need to UTF-8 (re-)encode it, if it's\n                 * beyond 7-bit ascii. Gets pretty messy.\n                 * If this happens often, may want to use different name\n                 * canonicalization to avoid these hits.\n                 */\n                if (ch > 127) {\n                    // Ok, we'll need room for first byte right away\n                    if (currQuadBytes >= 4) {\n                        if (qlen >= quads.length) {\n                            _quadBuffer = quads = growArrayBy(quads, quads.length);\n                        }\n                        quads[qlen++] = currQuad;\n                        currQuad = 0;\n                        currQuadBytes = 0;\n                    }\n                    if (ch < 0x800) { // 2-byte\n                        currQuad = (currQuad << 8) | (0xc0 | (ch >> 6));\n                        ++currQuadBytes;\n                        // Second byte gets output below:\n                    } else { // 3 bytes; no need to worry about surrogates here\n                        currQuad = (currQuad << 8) | (0xe0 | (ch >> 12));\n                        ++currQuadBytes;\n                        // need room for middle byte?\n                        if (currQuadBytes >= 4) {\n                            if (qlen >= quads.length) {\n                                _quadBuffer = quads = growArrayBy(quads, quads.length);\n                            }\n                            quads[qlen++] = currQuad;\n                            currQuad = 0;\n                            currQuadBytes = 0;\n                        }\n                        currQuad = (currQuad << 8) | (0x80 | ((ch >> 6) & 0x3f));\n                        ++currQuadBytes;\n                    }\n                    // And same last byte in both cases, gets output below:\n                    ch = 0x80 | (ch & 0x3f);\n                }\n            }\n            // Ok, we have one more byte to add at any rate:\n            if (currQuadBytes < 4) {\n                ++currQuadBytes;\n                currQuad = (currQuad << 8) | ch;\n            } else {\n                if (qlen >= quads.length) {\n                    _quadBuffer = quads = growArrayBy(quads, quads.length);\n                }\n                quads[qlen++] = currQuad;\n                currQuad = ch;\n                currQuadBytes = 1;\n            }\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\" in field name\");\n                }\n            }\n_inputPtr[_inputPtr++] = (_inputBuffer[_inputPtr++] | 255);\n        }\n\n        if (currQuadBytes > 0) {\n            if (qlen >= quads.length) {\n                _quadBuffer = quads = growArrayBy(quads, quads.length);\n            }\n            quads[qlen++] = currQuad;\n        }\n        Name name = _symbols.findName(quads, qlen);\n        if (name == null) {\n            name = addName(quads, qlen, currQuadBytes);\n        }\n        return name;\n    }",
          "27": "    protected Name _parseApostropheFieldName()\n        throws IOException, JsonParseException\n    {\n        if (_inputPtr >= _inputEnd) {\n            if (!loadMore()) {\n                _reportInvalidEOF(\": was expecting closing '\\'' for name\");\n            }\n        }\n        int ch = _inputBuffer[_inputPtr++] & 0xFF;\n        if (ch == INT_APOSTROPHE) { // special case, ''\n            return BytesToNameCanonicalizer.getEmptyName();\n        }\n        int[] quads = _quadBuffer;\n        int qlen = 0;\n        int currQuad = 0;\n        int currQuadBytes = 0;\n\n        // Copied from parseEscapedFieldName, with minor mods:\n\n        final int[] codes = sInputCodesLatin1;\n\n        while (true) {\n            if (ch == INT_APOSTROPHE) {\n                break;\n            }\n            // additional check to skip handling of double-quotes\n            if (ch != INT_QUOTE && codes[ch] != 0) {\n                if (ch != INT_BACKSLASH) {\n                    // Unquoted white space?\n                    // As per [JACKSON-208], call can now return:\n                    _throwUnquotedSpace(ch, \"name\");\n                } else {\n                    // Nope, escape sequence\n                    ch = _decodeEscaped();\n                }\n                /* Oh crap. May need to UTF-8 (re-)encode it, if it's\n                 * beyond 7-bit ascii. Gets pretty messy.\n                 * If this happens often, may want to use different name\n                 * canonicalization to avoid these hits.\n                 */\n                if (ch > 127) {\n                    // Ok, we'll need room for first byte right away\n                    if (currQuadBytes >= 4) {\n                        if (qlen >= quads.length) {\n                            _quadBuffer = quads = growArrayBy(quads, quads.length);\n                        }\n                        quads[qlen++] = currQuad;\n                        currQuad = 0;\n                        currQuadBytes = 0;\n                    }\n                    if (ch < 0x800) { // 2-byte\n                        currQuad = (currQuad << 8) | (0xc0 | (ch >> 6));\n                        ++currQuadBytes;\n                        // Second byte gets output below:\n                    } else { // 3 bytes; no need to worry about surrogates here\n                        currQuad = (currQuad << 8) | (0xe0 | (ch >> 12));\n                        ++currQuadBytes;\n                        // need room for middle byte?\n                        if (currQuadBytes >= 4) {\n                            if (qlen >= quads.length) {\n                                _quadBuffer = quads = growArrayBy(quads, quads.length);\n                            }\n                            quads[qlen++] = currQuad;\n                            currQuad = 0;\n                            currQuadBytes = 0;\n                        }\n                        currQuad = (currQuad << 8) | (0x80 | ((ch >> 6) & 0x3f));\n                        ++currQuadBytes;\n                    }\n                    // And same last byte in both cases, gets output below:\n                    ch = 0x80 | (ch & 0x3f);\n                }\n            }\n            // Ok, we have one more byte to add at any rate:\n            if (currQuadBytes < 4) {\n                ++currQuadBytes;\n                currQuad = (currQuad << 8) | ch;\n            } else {\n                if (qlen >= quads.length) {\n                    _quadBuffer = quads = growArrayBy(quads, quads.length);\n                }\n                quads[qlen++] = currQuad;\n                currQuad = ch;\n                currQuadBytes = 1;\n            }\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\" in field name\");\n                }\n            }\n_inputBuffer[_inputPtr++];\n        }\n\n        if (currQuadBytes > 0) {\n            if (qlen >= quads.length) {\n                _quadBuffer = quads = growArrayBy(quads, quads.length);\n            }\n            quads[qlen++] = currQuad;\n        }\n        Name name = _symbols.findName(quads, qlen);\n        if (name == null) {\n            name = addName(quads, qlen, currQuadBytes);\n        }\n        return name;\n    }",
          "28": "    protected Name _parseApostropheFieldName()\n        throws IOException, JsonParseException\n    {\n        if (_inputPtr >= _inputEnd) {\n            if (!loadMore()) {\n                _reportInvalidEOF(\": was expecting closing '\\'' for name\");\n            }\n        }\n        int ch = _inputBuffer[_inputPtr++] & 0xFF;\n        if (ch == INT_APOSTROPHE) { // special case, ''\n            return BytesToNameCanonicalizer.getEmptyName();\n        }\n        int[] quads = _quadBuffer;\n        int qlen = 0;\n        int currQuad = 0;\n        int currQuadBytes = 0;\n\n        // Copied from parseEscapedFieldName, with minor mods:\n\n        final int[] codes = sInputCodesLatin1;\n\n        while (true) {\n            if (ch == INT_APOSTROPHE) {\n                break;\n            }\n            // additional check to skip handling of double-quotes\n            if (ch != INT_QUOTE && codes[ch] != 0) {\n                if (ch != INT_BACKSLASH) {\n                    // Unquoted white space?\n                    // As per [JACKSON-208], call can now return:\n                    _throwUnquotedSpace(ch, \"name\");\n                } else {\n                    // Nope, escape sequence\n                    ch = _decodeEscaped();\n                }\n                /* Oh crap. May need to UTF-8 (re-)encode it, if it's\n                 * beyond 7-bit ascii. Gets pretty messy.\n                 * If this happens often, may want to use different name\n                 * canonicalization to avoid these hits.\n                 */\n                if (ch > 127) {\n                    // Ok, we'll need room for first byte right away\n                    if (currQuadBytes >= 4) {\n                        if (qlen >= quads.length) {\n                            _quadBuffer = quads = growArrayBy(quads, quads.length);\n                        }\n                        quads[qlen++] = currQuad;\n                        currQuad = 0;\n                        currQuadBytes = 0;\n                    }\n                    if (ch < 0x800) { // 2-byte\n                        currQuad = (currQuad << 8) | (0xc0 | (ch >> 6));\n                        ++currQuadBytes;\n                        // Second byte gets output below:\n                    } else { // 3 bytes; no need to worry about surrogates here\n                        currQuad = (currQuad << 8) | (0xe0 | (ch >> 12));\n                        ++currQuadBytes;\n                        // need room for middle byte?\n                        if (currQuadBytes >= 4) {\n                            if (qlen >= quads.length) {\n                                _quadBuffer = quads = growArrayBy(quads, quads.length);\n                            }\n                            quads[qlen++] = currQuad;\n                            currQuad = 0;\n                            currQuadBytes = 0;\n                        }\n                        currQuad = (currQuad << 8) | (0x80 | ((ch >> 6) & 0x3f));\n                        ++currQuadBytes;\n                    }\n                    // And same last byte in both cases, gets output below:\n                    ch = 0x80 | (ch & 0x3f);\n                }\n            }\n            // Ok, we have one more byte to add at any rate:\n            if (currQuadBytes < 4) {\n                ++currQuadBytes;\n                currQuad = (currQuad << 8) | ch;\n            } else {\n                if (qlen >= quads.length) {\n                    _quadBuffer = quads = growArrayBy(quads, quads.length);\n                }\n                quads[qlen++] = currQuad;\n                currQuad = ch;\n                currQuadBytes = 1;\n            }\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\" in field name\");\n                }\n            }\nch = (ch[(_inputBuffer[_inputPtr++] | 255)] | 255);\n        }\n\n        if (currQuadBytes > 0) {\n            if (qlen >= quads.length) {\n                _quadBuffer = quads = growArrayBy(quads, quads.length);\n            }\n            quads[qlen++] = currQuad;\n        }\n        Name name = _symbols.findName(quads, qlen);\n        if (name == null) {\n            name = addName(quads, qlen, currQuadBytes);\n        }\n        return name;\n    }",
          "29": "    protected Name _parseApostropheFieldName()\n        throws IOException, JsonParseException\n    {\n        if (_inputPtr >= _inputEnd) {\n            if (!loadMore()) {\n                _reportInvalidEOF(\": was expecting closing '\\'' for name\");\n            }\n        }\n        int ch = _inputBuffer[_inputPtr++] & 0xFF;\n        if (ch == INT_APOSTROPHE) { // special case, ''\n            return BytesToNameCanonicalizer.getEmptyName();\n        }\n        int[] quads = _quadBuffer;\n        int qlen = 0;\n        int currQuad = 0;\n        int currQuadBytes = 0;\n\n        // Copied from parseEscapedFieldName, with minor mods:\n\n        final int[] codes = sInputCodesLatin1;\n\n        while (true) {\n            if (ch == INT_APOSTROPHE) {\n                break;\n            }\n            // additional check to skip handling of double-quotes\n            if (ch != INT_QUOTE && codes[ch] != 0) {\n                if (ch != INT_BACKSLASH) {\n                    // Unquoted white space?\n                    // As per [JACKSON-208], call can now return:\n                    _throwUnquotedSpace(ch, \"name\");\n                } else {\n                    // Nope, escape sequence\n                    ch = _decodeEscaped();\n                }\n                /* Oh crap. May need to UTF-8 (re-)encode it, if it's\n                 * beyond 7-bit ascii. Gets pretty messy.\n                 * If this happens often, may want to use different name\n                 * canonicalization to avoid these hits.\n                 */\n                if (ch > 127) {\n                    // Ok, we'll need room for first byte right away\n                    if (currQuadBytes >= 4) {\n                        if (qlen >= quads.length) {\n                            _quadBuffer = quads = growArrayBy(quads, quads.length);\n                        }\n                        quads[qlen++] = currQuad;\n                        currQuad = 0;\n                        currQuadBytes = 0;\n                    }\n                    if (ch < 0x800) { // 2-byte\n                        currQuad = (currQuad << 8) | (0xc0 | (ch >> 6));\n                        ++currQuadBytes;\n                        // Second byte gets output below:\n                    } else { // 3 bytes; no need to worry about surrogates here\n                        currQuad = (currQuad << 8) | (0xe0 | (ch >> 12));\n                        ++currQuadBytes;\n                        // need room for middle byte?\n                        if (currQuadBytes >= 4) {\n                            if (qlen >= quads.length) {\n                                _quadBuffer = quads = growArrayBy(quads, quads.length);\n                            }\n                            quads[qlen++] = currQuad;\n                            currQuad = 0;\n                            currQuadBytes = 0;\n                        }\n                        currQuad = (currQuad << 8) | (0x80 | ((ch >> 6) & 0x3f));\n                        ++currQuadBytes;\n                    }\n                    // And same last byte in both cases, gets output below:\n                    ch = 0x80 | (ch & 0x3f);\n                }\n            }\n            // Ok, we have one more byte to add at any rate:\n            if (currQuadBytes < 4) {\n                ++currQuadBytes;\n                currQuad = (currQuad << 8) | ch;\n            } else {\n                if (qlen >= quads.length) {\n                    _quadBuffer = quads = growArrayBy(quads, quads.length);\n                }\n                quads[qlen++] = currQuad;\n                currQuad = ch;\n                currQuadBytes = 1;\n            }\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\" in field name\");\n                }\n            }\n_skipUtf8_2(_inputBuffer[_inputPtr++]);\n        }\n\n        if (currQuadBytes > 0) {\n            if (qlen >= quads.length) {\n                _quadBuffer = quads = growArrayBy(quads, quads.length);\n            }\n            quads[qlen++] = currQuad;\n        }\n        Name name = _symbols.findName(quads, qlen);\n        if (name == null) {\n            name = addName(quads, qlen, currQuadBytes);\n        }\n        return name;\n    }",
          "30": "    protected Name _parseApostropheFieldName()\n        throws IOException, JsonParseException\n    {\n        if (_inputPtr >= _inputEnd) {\n            if (!loadMore()) {\n                _reportInvalidEOF(\": was expecting closing '\\'' for name\");\n            }\n        }\n        int ch = _inputBuffer[_inputPtr++] & 0xFF;\n        if (ch == INT_APOSTROPHE) { // special case, ''\n            return BytesToNameCanonicalizer.getEmptyName();\n        }\n        int[] quads = _quadBuffer;\n        int qlen = 0;\n        int currQuad = 0;\n        int currQuadBytes = 0;\n\n        // Copied from parseEscapedFieldName, with minor mods:\n\n        final int[] codes = sInputCodesLatin1;\n\n        while (true) {\n            if (ch == INT_APOSTROPHE) {\n                break;\n            }\n            // additional check to skip handling of double-quotes\n            if (ch != INT_QUOTE && codes[ch] != 0) {\n                if (ch != INT_BACKSLASH) {\n                    // Unquoted white space?\n                    // As per [JACKSON-208], call can now return:\n                    _throwUnquotedSpace(ch, \"name\");\n                } else {\n                    // Nope, escape sequence\n                    ch = _decodeEscaped();\n                }\n                /* Oh crap. May need to UTF-8 (re-)encode it, if it's\n                 * beyond 7-bit ascii. Gets pretty messy.\n                 * If this happens often, may want to use different name\n                 * canonicalization to avoid these hits.\n                 */\n                if (ch > 127) {\n                    // Ok, we'll need room for first byte right away\n                    if (currQuadBytes >= 4) {\n                        if (qlen >= quads.length) {\n                            _quadBuffer = quads = growArrayBy(quads, quads.length);\n                        }\n                        quads[qlen++] = currQuad;\n                        currQuad = 0;\n                        currQuadBytes = 0;\n                    }\n                    if (ch < 0x800) { // 2-byte\n                        currQuad = (currQuad << 8) | (0xc0 | (ch >> 6));\n                        ++currQuadBytes;\n                        // Second byte gets output below:\n                    } else { // 3 bytes; no need to worry about surrogates here\n                        currQuad = (currQuad << 8) | (0xe0 | (ch >> 12));\n                        ++currQuadBytes;\n                        // need room for middle byte?\n                        if (currQuadBytes >= 4) {\n                            if (qlen >= quads.length) {\n                                _quadBuffer = quads = growArrayBy(quads, quads.length);\n                            }\n                            quads[qlen++] = currQuad;\n                            currQuad = 0;\n                            currQuadBytes = 0;\n                        }\n                        currQuad = (currQuad << 8) | (0x80 | ((ch >> 6) & 0x3f));\n                        ++currQuadBytes;\n                    }\n                    // And same last byte in both cases, gets output below:\n                    ch = 0x80 | (ch & 0x3f);\n                }\n            }\n            // Ok, we have one more byte to add at any rate:\n            if (currQuadBytes < 4) {\n                ++currQuadBytes;\n                currQuad = (currQuad << 8) | ch;\n            } else {\n                if (qlen >= quads.length) {\n                    _quadBuffer = quads = growArrayBy(quads, quads.length);\n                }\n                quads[qlen++] = currQuad;\n                currQuad = ch;\n                currQuadBytes = 1;\n            }\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\" in field name\");\n                }\n            }\n_skipUtf8_3(_inputBuffer[_inputPtr++]);\n        }\n\n        if (currQuadBytes > 0) {\n            if (qlen >= quads.length) {\n                _quadBuffer = quads = growArrayBy(quads, quads.length);\n            }\n            quads[qlen++] = currQuad;\n        }\n        Name name = _symbols.findName(quads, qlen);\n        if (name == null) {\n            name = addName(quads, qlen, currQuadBytes);\n        }\n        return name;\n    }",
          "31": "    protected Name _parseApostropheFieldName()\n        throws IOException, JsonParseException\n    {\n        if (_inputPtr >= _inputEnd) {\n            if (!loadMore()) {\n                _reportInvalidEOF(\": was expecting closing '\\'' for name\");\n            }\n        }\n        int ch = _inputBuffer[_inputPtr++] & 0xFF;\n        if (ch == INT_APOSTROPHE) { // special case, ''\n            return BytesToNameCanonicalizer.getEmptyName();\n        }\n        int[] quads = _quadBuffer;\n        int qlen = 0;\n        int currQuad = 0;\n        int currQuadBytes = 0;\n\n        // Copied from parseEscapedFieldName, with minor mods:\n\n        final int[] codes = sInputCodesLatin1;\n\n        while (true) {\n            if (ch == INT_APOSTROPHE) {\n                break;\n            }\n            // additional check to skip handling of double-quotes\n            if (ch != INT_QUOTE && codes[ch] != 0) {\n                if (ch != INT_BACKSLASH) {\n                    // Unquoted white space?\n                    // As per [JACKSON-208], call can now return:\n                    _throwUnquotedSpace(ch, \"name\");\n                } else {\n                    // Nope, escape sequence\n                    ch = _decodeEscaped();\n                }\n                /* Oh crap. May need to UTF-8 (re-)encode it, if it's\n                 * beyond 7-bit ascii. Gets pretty messy.\n                 * If this happens often, may want to use different name\n                 * canonicalization to avoid these hits.\n                 */\n                if (ch > 127) {\n                    // Ok, we'll need room for first byte right away\n                    if (currQuadBytes >= 4) {\n                        if (qlen >= quads.length) {\n                            _quadBuffer = quads = growArrayBy(quads, quads.length);\n                        }\n                        quads[qlen++] = currQuad;\n                        currQuad = 0;\n                        currQuadBytes = 0;\n                    }\n                    if (ch < 0x800) { // 2-byte\n                        currQuad = (currQuad << 8) | (0xc0 | (ch >> 6));\n                        ++currQuadBytes;\n                        // Second byte gets output below:\n                    } else { // 3 bytes; no need to worry about surrogates here\n                        currQuad = (currQuad << 8) | (0xe0 | (ch >> 12));\n                        ++currQuadBytes;\n                        // need room for middle byte?\n                        if (currQuadBytes >= 4) {\n                            if (qlen >= quads.length) {\n                                _quadBuffer = quads = growArrayBy(quads, quads.length);\n                            }\n                            quads[qlen++] = currQuad;\n                            currQuad = 0;\n                            currQuadBytes = 0;\n                        }\n                        currQuad = (currQuad << 8) | (0x80 | ((ch >> 6) & 0x3f));\n                        ++currQuadBytes;\n                    }\n                    // And same last byte in both cases, gets output below:\n                    ch = 0x80 | (ch & 0x3f);\n                }\n            }\n            // Ok, we have one more byte to add at any rate:\n            if (currQuadBytes < 4) {\n                ++currQuadBytes;\n                currQuad = (currQuad << 8) | ch;\n            } else {\n                if (qlen >= quads.length) {\n                    _quadBuffer = quads = growArrayBy(quads, quads.length);\n                }\n                quads[qlen++] = currQuad;\n                currQuad = ch;\n                currQuadBytes = 1;\n            }\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\" in field name\");\n                }\n            }\n_skipUtf8_4(_inputBuffer[_inputPtr++]);\n        }\n\n        if (currQuadBytes > 0) {\n            if (qlen >= quads.length) {\n                _quadBuffer = quads = growArrayBy(quads, quads.length);\n            }\n            quads[qlen++] = currQuad;\n        }\n        Name name = _symbols.findName(quads, qlen);\n        if (name == null) {\n            name = addName(quads, qlen, currQuadBytes);\n        }\n        return name;\n    }",
          "32": "    protected Name _parseApostropheFieldName()\n        throws IOException, JsonParseException\n    {\n        if (_inputPtr >= _inputEnd) {\n            if (!loadMore()) {\n                _reportInvalidEOF(\": was expecting closing '\\'' for name\");\n            }\n        }\n        int ch = _inputBuffer[_inputPtr++] & 0xFF;\n        if (ch == INT_APOSTROPHE) { // special case, ''\n            return BytesToNameCanonicalizer.getEmptyName();\n        }\n        int[] quads = _quadBuffer;\n        int qlen = 0;\n        int currQuad = 0;\n        int currQuadBytes = 0;\n\n        // Copied from parseEscapedFieldName, with minor mods:\n\n        final int[] codes = sInputCodesLatin1;\n\n        while (true) {\n            if (ch == INT_APOSTROPHE) {\n                break;\n            }\n            // additional check to skip handling of double-quotes\n            if (ch != INT_QUOTE && codes[ch] != 0) {\n                if (ch != INT_BACKSLASH) {\n                    // Unquoted white space?\n                    // As per [JACKSON-208], call can now return:\n                    _throwUnquotedSpace(ch, \"name\");\n                } else {\n                    // Nope, escape sequence\n                    ch = _decodeEscaped();\n                }\n                /* Oh crap. May need to UTF-8 (re-)encode it, if it's\n                 * beyond 7-bit ascii. Gets pretty messy.\n                 * If this happens often, may want to use different name\n                 * canonicalization to avoid these hits.\n                 */\n                if (ch > 127) {\n                    // Ok, we'll need room for first byte right away\n                    if (currQuadBytes >= 4) {\n                        if (qlen >= quads.length) {\n                            _quadBuffer = quads = growArrayBy(quads, quads.length);\n                        }\n                        quads[qlen++] = currQuad;\n                        currQuad = 0;\n                        currQuadBytes = 0;\n                    }\n                    if (ch < 0x800) { // 2-byte\n                        currQuad = (currQuad << 8) | (0xc0 | (ch >> 6));\n                        ++currQuadBytes;\n                        // Second byte gets output below:\n                    } else { // 3 bytes; no need to worry about surrogates here\n                        currQuad = (currQuad << 8) | (0xe0 | (ch >> 12));\n                        ++currQuadBytes;\n                        // need room for middle byte?\n                        if (currQuadBytes >= 4) {\n                            if (qlen >= quads.length) {\n                                _quadBuffer = quads = growArrayBy(quads, quads.length);\n                            }\n                            quads[qlen++] = currQuad;\n                            currQuad = 0;\n                            currQuadBytes = 0;\n                        }\n                        currQuad = (currQuad << 8) | (0x80 | ((ch >> 6) & 0x3f));\n                        ++currQuadBytes;\n                    }\n                    // And same last byte in both cases, gets output below:\n                    ch = 0x80 | (ch & 0x3f);\n                }\n            }\n            // Ok, we have one more byte to add at any rate:\n            if (currQuadBytes < 4) {\n                ++currQuadBytes;\n                currQuad = (currQuad << 8) | ch;\n            } else {\n                if (qlen >= quads.length) {\n                    _quadBuffer = quads = growArrayBy(quads, quads.length);\n                }\n                quads[qlen++] = currQuad;\n                currQuad = ch;\n                currQuadBytes = 1;\n            }\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\" in field name\");\n                }\n            }\n_reportInvalidChar(_inputBuffer[_inputPtr++]);\n        }\n\n        if (currQuadBytes > 0) {\n            if (qlen >= quads.length) {\n                _quadBuffer = quads = growArrayBy(quads, quads.length);\n            }\n            quads[qlen++] = currQuad;\n        }\n        Name name = _symbols.findName(quads, qlen);\n        if (name == null) {\n            name = addName(quads, qlen, currQuadBytes);\n        }\n        return name;\n    }",
          "33": "    protected Name _parseApostropheFieldName()\n        throws IOException, JsonParseException\n    {\n        if (_inputPtr >= _inputEnd) {\n            if (!loadMore()) {\n                _reportInvalidEOF(\": was expecting closing '\\'' for name\");\n            }\n        }\n        int ch = _inputBuffer[_inputPtr++] & 0xFF;\n        if (ch == INT_APOSTROPHE) { // special case, ''\n            return BytesToNameCanonicalizer.getEmptyName();\n        }\n        int[] quads = _quadBuffer;\n        int qlen = 0;\n        int currQuad = 0;\n        int currQuadBytes = 0;\n\n        // Copied from parseEscapedFieldName, with minor mods:\n\n        final int[] codes = sInputCodesLatin1;\n\n        while (true) {\n            if (ch == INT_APOSTROPHE) {\n                break;\n            }\n            // additional check to skip handling of double-quotes\n            if (ch != INT_QUOTE && codes[ch] != 0) {\n                if (ch != INT_BACKSLASH) {\n                    // Unquoted white space?\n                    // As per [JACKSON-208], call can now return:\n                    _throwUnquotedSpace(ch, \"name\");\n                } else {\n                    // Nope, escape sequence\n                    ch = _decodeEscaped();\n                }\n                /* Oh crap. May need to UTF-8 (re-)encode it, if it's\n                 * beyond 7-bit ascii. Gets pretty messy.\n                 * If this happens often, may want to use different name\n                 * canonicalization to avoid these hits.\n                 */\n                if (ch > 127) {\n                    // Ok, we'll need room for first byte right away\n                    if (currQuadBytes >= 4) {\n                        if (qlen >= quads.length) {\n                            _quadBuffer = quads = growArrayBy(quads, quads.length);\n                        }\n                        quads[qlen++] = currQuad;\n                        currQuad = 0;\n                        currQuadBytes = 0;\n                    }\n                    if (ch < 0x800) { // 2-byte\n                        currQuad = (currQuad << 8) | (0xc0 | (ch >> 6));\n                        ++currQuadBytes;\n                        // Second byte gets output below:\n                    } else { // 3 bytes; no need to worry about surrogates here\n                        currQuad = (currQuad << 8) | (0xe0 | (ch >> 12));\n                        ++currQuadBytes;\n                        // need room for middle byte?\n                        if (currQuadBytes >= 4) {\n                            if (qlen >= quads.length) {\n                                _quadBuffer = quads = growArrayBy(quads, quads.length);\n                            }\n                            quads[qlen++] = currQuad;\n                            currQuad = 0;\n                            currQuadBytes = 0;\n                        }\n                        currQuad = (currQuad << 8) | (0x80 | ((ch >> 6) & 0x3f));\n                        ++currQuadBytes;\n                    }\n                    // And same last byte in both cases, gets output below:\n                    ch = 0x80 | (ch & 0x3f);\n                }\n            }\n            // Ok, we have one more byte to add at any rate:\n            if (currQuadBytes < 4) {\n                ++currQuadBytes;\n                currQuad = (currQuad << 8) | ch;\n            } else {\n                if (qlen >= quads.length) {\n                    _quadBuffer = quads = growArrayBy(quads, quads.length);\n                }\n                quads[qlen++] = currQuad;\n                currQuad = ch;\n                currQuadBytes = 1;\n            }\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\" in field name\");\n                }\n            }\n_reportInvalidInitial(_inputBuffer[_inputPtr++]);\n        }\n\n        if (currQuadBytes > 0) {\n            if (qlen >= quads.length) {\n                _quadBuffer = quads = growArrayBy(quads, quads.length);\n            }\n            quads[qlen++] = currQuad;\n        }\n        Name name = _symbols.findName(quads, qlen);\n        if (name == null) {\n            name = addName(quads, qlen, currQuadBytes);\n        }\n        return name;\n    }",
          "34": "    protected Name _parseApostropheFieldName()\n        throws IOException, JsonParseException\n    {\n        if (_inputPtr >= _inputEnd) {\n            if (!loadMore()) {\n                _reportInvalidEOF(\": was expecting closing '\\'' for name\");\n            }\n        }\n        int ch = _inputBuffer[_inputPtr++] & 0xFF;\n        if (ch == INT_APOSTROPHE) { // special case, ''\n            return BytesToNameCanonicalizer.getEmptyName();\n        }\n        int[] quads = _quadBuffer;\n        int qlen = 0;\n        int currQuad = 0;\n        int currQuadBytes = 0;\n\n        // Copied from parseEscapedFieldName, with minor mods:\n\n        final int[] codes = sInputCodesLatin1;\n\n        while (true) {\n            if (ch == INT_APOSTROPHE) {\n                break;\n            }\n            // additional check to skip handling of double-quotes\n            if (ch != INT_QUOTE && codes[ch] != 0) {\n                if (ch != INT_BACKSLASH) {\n                    // Unquoted white space?\n                    // As per [JACKSON-208], call can now return:\n                    _throwUnquotedSpace(ch, \"name\");\n                } else {\n                    // Nope, escape sequence\n                    ch = _decodeEscaped();\n                }\n                /* Oh crap. May need to UTF-8 (re-)encode it, if it's\n                 * beyond 7-bit ascii. Gets pretty messy.\n                 * If this happens often, may want to use different name\n                 * canonicalization to avoid these hits.\n                 */\n                if (ch > 127) {\n                    // Ok, we'll need room for first byte right away\n                    if (currQuadBytes >= 4) {\n                        if (qlen >= quads.length) {\n                            _quadBuffer = quads = growArrayBy(quads, quads.length);\n                        }\n                        quads[qlen++] = currQuad;\n                        currQuad = 0;\n                        currQuadBytes = 0;\n                    }\n                    if (ch < 0x800) { // 2-byte\n                        currQuad = (currQuad << 8) | (0xc0 | (ch >> 6));\n                        ++currQuadBytes;\n                        // Second byte gets output below:\n                    } else { // 3 bytes; no need to worry about surrogates here\n                        currQuad = (currQuad << 8) | (0xe0 | (ch >> 12));\n                        ++currQuadBytes;\n                        // need room for middle byte?\n                        if (currQuadBytes >= 4) {\n                            if (qlen >= quads.length) {\n                                _quadBuffer = quads = growArrayBy(quads, quads.length);\n                            }\n                            quads[qlen++] = currQuad;\n                            currQuad = 0;\n                            currQuadBytes = 0;\n                        }\n                        currQuad = (currQuad << 8) | (0x80 | ((ch >> 6) & 0x3f));\n                        ++currQuadBytes;\n                    }\n                    // And same last byte in both cases, gets output below:\n                    ch = 0x80 | (ch & 0x3f);\n                }\n            }\n            // Ok, we have one more byte to add at any rate:\n            if (currQuadBytes < 4) {\n                ++currQuadBytes;\n                currQuad = (currQuad << 8) | ch;\n            } else {\n                if (qlen >= quads.length) {\n                    _quadBuffer = quads = growArrayBy(quads, quads.length);\n                }\n                quads[qlen++] = currQuad;\n                currQuad = ch;\n                currQuadBytes = 1;\n            }\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\" in field name\");\n                }\n            }\n_reportInvalidOther(_inputBuffer[_inputPtr++]);\n        }\n\n        if (currQuadBytes > 0) {\n            if (qlen >= quads.length) {\n                _quadBuffer = quads = growArrayBy(quads, quads.length);\n            }\n            quads[qlen++] = currQuad;\n        }\n        Name name = _symbols.findName(quads, qlen);\n        if (name == null) {\n            name = addName(quads, qlen, currQuadBytes);\n        }\n        return name;\n    }",
          "35": "    protected Name _parseApostropheFieldName()\n        throws IOException, JsonParseException\n    {\n        if (_inputPtr >= _inputEnd) {\n            if (!loadMore()) {\n                _reportInvalidEOF(\": was expecting closing '\\'' for name\");\n            }\n        }\n        int ch = _inputBuffer[_inputPtr++] & 0xFF;\n        if (ch == INT_APOSTROPHE) { // special case, ''\n            return BytesToNameCanonicalizer.getEmptyName();\n        }\n        int[] quads = _quadBuffer;\n        int qlen = 0;\n        int currQuad = 0;\n        int currQuadBytes = 0;\n\n        // Copied from parseEscapedFieldName, with minor mods:\n\n        final int[] codes = sInputCodesLatin1;\n\n        while (true) {\n            if (ch == INT_APOSTROPHE) {\n                break;\n            }\n            // additional check to skip handling of double-quotes\n            if (ch != INT_QUOTE && codes[ch] != 0) {\n                if (ch != INT_BACKSLASH) {\n                    // Unquoted white space?\n                    // As per [JACKSON-208], call can now return:\n                    _throwUnquotedSpace(ch, \"name\");\n                } else {\n                    // Nope, escape sequence\n                    ch = _decodeEscaped();\n                }\n                /* Oh crap. May need to UTF-8 (re-)encode it, if it's\n                 * beyond 7-bit ascii. Gets pretty messy.\n                 * If this happens often, may want to use different name\n                 * canonicalization to avoid these hits.\n                 */\n                if (ch > 127) {\n                    // Ok, we'll need room for first byte right away\n                    if (currQuadBytes >= 4) {\n                        if (qlen >= quads.length) {\n                            _quadBuffer = quads = growArrayBy(quads, quads.length);\n                        }\n                        quads[qlen++] = currQuad;\n                        currQuad = 0;\n                        currQuadBytes = 0;\n                    }\n                    if (ch < 0x800) { // 2-byte\n                        currQuad = (currQuad << 8) | (0xc0 | (ch >> 6));\n                        ++currQuadBytes;\n                        // Second byte gets output below:\n                    } else { // 3 bytes; no need to worry about surrogates here\n                        currQuad = (currQuad << 8) | (0xe0 | (ch >> 12));\n                        ++currQuadBytes;\n                        // need room for middle byte?\n                        if (currQuadBytes >= 4) {\n                            if (qlen >= quads.length) {\n                                _quadBuffer = quads = growArrayBy(quads, quads.length);\n                            }\n                            quads[qlen++] = currQuad;\n                            currQuad = 0;\n                            currQuadBytes = 0;\n                        }\n                        currQuad = (currQuad << 8) | (0x80 | ((ch >> 6) & 0x3f));\n                        ++currQuadBytes;\n                    }\n                    // And same last byte in both cases, gets output below:\n                    ch = 0x80 | (ch & 0x3f);\n                }\n            }\n            // Ok, we have one more byte to add at any rate:\n            if (currQuadBytes < 4) {\n                ++currQuadBytes;\n                currQuad = (currQuad << 8) | ch;\n            } else {\n                if (qlen >= quads.length) {\n                    _quadBuffer = quads = growArrayBy(quads, quads.length);\n                }\n                quads[qlen++] = currQuad;\n                currQuad = ch;\n                currQuadBytes = 1;\n            }\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\" in field name\");\n                }\n            }\nch &= (_inputBuffer[_inputPtr++] | 255);\n        }\n\n        if (currQuadBytes > 0) {\n            if (qlen >= quads.length) {\n                _quadBuffer = quads = growArrayBy(quads, quads.length);\n            }\n            quads[qlen++] = currQuad;\n        }\n        Name name = _symbols.findName(quads, qlen);\n        if (name == null) {\n            name = addName(quads, qlen, currQuadBytes);\n        }\n        return name;\n    }",
          "36": "    protected Name _parseApostropheFieldName()\n        throws IOException, JsonParseException\n    {\n        if (_inputPtr >= _inputEnd) {\n            if (!loadMore()) {\n                _reportInvalidEOF(\": was expecting closing '\\'' for name\");\n            }\n        }\n        int ch = _inputBuffer[_inputPtr++] & 0xFF;\n        if (ch == INT_APOSTROPHE) { // special case, ''\n            return BytesToNameCanonicalizer.getEmptyName();\n        }\n        int[] quads = _quadBuffer;\n        int qlen = 0;\n        int currQuad = 0;\n        int currQuadBytes = 0;\n\n        // Copied from parseEscapedFieldName, with minor mods:\n\n        final int[] codes = sInputCodesLatin1;\n\n        while (true) {\n            if (ch == INT_APOSTROPHE) {\n                break;\n            }\n            // additional check to skip handling of double-quotes\n            if (ch != INT_QUOTE && codes[ch] != 0) {\n                if (ch != INT_BACKSLASH) {\n                    // Unquoted white space?\n                    // As per [JACKSON-208], call can now return:\n                    _throwUnquotedSpace(ch, \"name\");\n                } else {\n                    // Nope, escape sequence\n                    ch = _decodeEscaped();\n                }\n                /* Oh crap. May need to UTF-8 (re-)encode it, if it's\n                 * beyond 7-bit ascii. Gets pretty messy.\n                 * If this happens often, may want to use different name\n                 * canonicalization to avoid these hits.\n                 */\n                if (ch > 127) {\n                    // Ok, we'll need room for first byte right away\n                    if (currQuadBytes >= 4) {\n                        if (qlen >= quads.length) {\n                            _quadBuffer = quads = growArrayBy(quads, quads.length);\n                        }\n                        quads[qlen++] = currQuad;\n                        currQuad = 0;\n                        currQuadBytes = 0;\n                    }\n                    if (ch < 0x800) { // 2-byte\n                        currQuad = (currQuad << 8) | (0xc0 | (ch >> 6));\n                        ++currQuadBytes;\n                        // Second byte gets output below:\n                    } else { // 3 bytes; no need to worry about surrogates here\n                        currQuad = (currQuad << 8) | (0xe0 | (ch >> 12));\n                        ++currQuadBytes;\n                        // need room for middle byte?\n                        if (currQuadBytes >= 4) {\n                            if (qlen >= quads.length) {\n                                _quadBuffer = quads = growArrayBy(quads, quads.length);\n                            }\n                            quads[qlen++] = currQuad;\n                            currQuad = 0;\n                            currQuadBytes = 0;\n                        }\n                        currQuad = (currQuad << 8) | (0x80 | ((ch >> 6) & 0x3f));\n                        ++currQuadBytes;\n                    }\n                    // And same last byte in both cases, gets output below:\n                    ch = 0x80 | (ch & 0x3f);\n                }\n            }\n            // Ok, we have one more byte to add at any rate:\n            if (currQuadBytes < 4) {\n                ++currQuadBytes;\n                currQuad = (currQuad << 8) | ch;\n            } else {\n                if (qlen >= quads.length) {\n                    _quadBuffer = quads = growArrayBy(quads, quads.length);\n                }\n                quads[qlen++] = currQuad;\n                currQuad = ch;\n                currQuadBytes = 1;\n            }\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\" in field name\");\n                }\n            }\n_skipUtf8_2(_inputBuffer);\n        }\n\n        if (currQuadBytes > 0) {\n            if (qlen >= quads.length) {\n                _quadBuffer = quads = growArrayBy(quads, quads.length);\n            }\n            quads[qlen++] = currQuad;\n        }\n        Name name = _symbols.findName(quads, qlen);\n        if (name == null) {\n            name = addName(quads, qlen, currQuadBytes);\n        }\n        return name;\n    }",
          "37": "    protected Name _parseApostropheFieldName()\n        throws IOException, JsonParseException\n    {\n        if (_inputPtr >= _inputEnd) {\n            if (!loadMore()) {\n                _reportInvalidEOF(\": was expecting closing '\\'' for name\");\n            }\n        }\n        int ch = _inputBuffer[_inputPtr++] & 0xFF;\n        if (ch == INT_APOSTROPHE) { // special case, ''\n            return BytesToNameCanonicalizer.getEmptyName();\n        }\n        int[] quads = _quadBuffer;\n        int qlen = 0;\n        int currQuad = 0;\n        int currQuadBytes = 0;\n\n        // Copied from parseEscapedFieldName, with minor mods:\n\n        final int[] codes = sInputCodesLatin1;\n\n        while (true) {\n            if (ch == INT_APOSTROPHE) {\n                break;\n            }\n            // additional check to skip handling of double-quotes\n            if (ch != INT_QUOTE && codes[ch] != 0) {\n                if (ch != INT_BACKSLASH) {\n                    // Unquoted white space?\n                    // As per [JACKSON-208], call can now return:\n                    _throwUnquotedSpace(ch, \"name\");\n                } else {\n                    // Nope, escape sequence\n                    ch = _decodeEscaped();\n                }\n                /* Oh crap. May need to UTF-8 (re-)encode it, if it's\n                 * beyond 7-bit ascii. Gets pretty messy.\n                 * If this happens often, may want to use different name\n                 * canonicalization to avoid these hits.\n                 */\n                if (ch > 127) {\n                    // Ok, we'll need room for first byte right away\n                    if (currQuadBytes >= 4) {\n                        if (qlen >= quads.length) {\n                            _quadBuffer = quads = growArrayBy(quads, quads.length);\n                        }\n                        quads[qlen++] = currQuad;\n                        currQuad = 0;\n                        currQuadBytes = 0;\n                    }\n                    if (ch < 0x800) { // 2-byte\n                        currQuad = (currQuad << 8) | (0xc0 | (ch >> 6));\n                        ++currQuadBytes;\n                        // Second byte gets output below:\n                    } else { // 3 bytes; no need to worry about surrogates here\n                        currQuad = (currQuad << 8) | (0xe0 | (ch >> 12));\n                        ++currQuadBytes;\n                        // need room for middle byte?\n                        if (currQuadBytes >= 4) {\n                            if (qlen >= quads.length) {\n                                _quadBuffer = quads = growArrayBy(quads, quads.length);\n                            }\n                            quads[qlen++] = currQuad;\n                            currQuad = 0;\n                            currQuadBytes = 0;\n                        }\n                        currQuad = (currQuad << 8) | (0x80 | ((ch >> 6) & 0x3f));\n                        ++currQuadBytes;\n                    }\n                    // And same last byte in both cases, gets output below:\n                    ch = 0x80 | (ch & 0x3f);\n                }\n            }\n            // Ok, we have one more byte to add at any rate:\n            if (currQuadBytes < 4) {\n                ++currQuadBytes;\n                currQuad = (currQuad << 8) | ch;\n            } else {\n                if (qlen >= quads.length) {\n                    _quadBuffer = quads = growArrayBy(quads, quads.length);\n                }\n                quads[qlen++] = currQuad;\n                currQuad = ch;\n                currQuadBytes = 1;\n            }\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\" in field name\");\n                }\n            }\n_skipUtf8_3(_inputBuffer);\n        }\n\n        if (currQuadBytes > 0) {\n            if (qlen >= quads.length) {\n                _quadBuffer = quads = growArrayBy(quads, quads.length);\n            }\n            quads[qlen++] = currQuad;\n        }\n        Name name = _symbols.findName(quads, qlen);\n        if (name == null) {\n            name = addName(quads, qlen, currQuadBytes);\n        }\n        return name;\n    }",
          "38": "    protected Name _parseApostropheFieldName()\n        throws IOException, JsonParseException\n    {\n        if (_inputPtr >= _inputEnd) {\n            if (!loadMore()) {\n                _reportInvalidEOF(\": was expecting closing '\\'' for name\");\n            }\n        }\n        int ch = _inputBuffer[_inputPtr++] & 0xFF;\n        if (ch == INT_APOSTROPHE) { // special case, ''\n            return BytesToNameCanonicalizer.getEmptyName();\n        }\n        int[] quads = _quadBuffer;\n        int qlen = 0;\n        int currQuad = 0;\n        int currQuadBytes = 0;\n\n        // Copied from parseEscapedFieldName, with minor mods:\n\n        final int[] codes = sInputCodesLatin1;\n\n        while (true) {\n            if (ch == INT_APOSTROPHE) {\n                break;\n            }\n            // additional check to skip handling of double-quotes\n            if (ch != INT_QUOTE && codes[ch] != 0) {\n                if (ch != INT_BACKSLASH) {\n                    // Unquoted white space?\n                    // As per [JACKSON-208], call can now return:\n                    _throwUnquotedSpace(ch, \"name\");\n                } else {\n                    // Nope, escape sequence\n                    ch = _decodeEscaped();\n                }\n                /* Oh crap. May need to UTF-8 (re-)encode it, if it's\n                 * beyond 7-bit ascii. Gets pretty messy.\n                 * If this happens often, may want to use different name\n                 * canonicalization to avoid these hits.\n                 */\n                if (ch > 127) {\n                    // Ok, we'll need room for first byte right away\n                    if (currQuadBytes >= 4) {\n                        if (qlen >= quads.length) {\n                            _quadBuffer = quads = growArrayBy(quads, quads.length);\n                        }\n                        quads[qlen++] = currQuad;\n                        currQuad = 0;\n                        currQuadBytes = 0;\n                    }\n                    if (ch < 0x800) { // 2-byte\n                        currQuad = (currQuad << 8) | (0xc0 | (ch >> 6));\n                        ++currQuadBytes;\n                        // Second byte gets output below:\n                    } else { // 3 bytes; no need to worry about surrogates here\n                        currQuad = (currQuad << 8) | (0xe0 | (ch >> 12));\n                        ++currQuadBytes;\n                        // need room for middle byte?\n                        if (currQuadBytes >= 4) {\n                            if (qlen >= quads.length) {\n                                _quadBuffer = quads = growArrayBy(quads, quads.length);\n                            }\n                            quads[qlen++] = currQuad;\n                            currQuad = 0;\n                            currQuadBytes = 0;\n                        }\n                        currQuad = (currQuad << 8) | (0x80 | ((ch >> 6) & 0x3f));\n                        ++currQuadBytes;\n                    }\n                    // And same last byte in both cases, gets output below:\n                    ch = 0x80 | (ch & 0x3f);\n                }\n            }\n            // Ok, we have one more byte to add at any rate:\n            if (currQuadBytes < 4) {\n                ++currQuadBytes;\n                currQuad = (currQuad << 8) | ch;\n            } else {\n                if (qlen >= quads.length) {\n                    _quadBuffer = quads = growArrayBy(quads, quads.length);\n                }\n                quads[qlen++] = currQuad;\n                currQuad = ch;\n                currQuadBytes = 1;\n            }\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\" in field name\");\n                }\n            }\n_skipUtf8_4(_inputBuffer);\n        }\n\n        if (currQuadBytes > 0) {\n            if (qlen >= quads.length) {\n                _quadBuffer = quads = growArrayBy(quads, quads.length);\n            }\n            quads[qlen++] = currQuad;\n        }\n        Name name = _symbols.findName(quads, qlen);\n        if (name == null) {\n            name = addName(quads, qlen, currQuadBytes);\n        }\n        return name;\n    }",
          "39": "    protected Name _parseApostropheFieldName()\n        throws IOException, JsonParseException\n    {\n        if (_inputPtr >= _inputEnd) {\n            if (!loadMore()) {\n                _reportInvalidEOF(\": was expecting closing '\\'' for name\");\n            }\n        }\n        int ch = _inputBuffer[_inputPtr++] & 0xFF;\n        if (ch == INT_APOSTROPHE) { // special case, ''\n            return BytesToNameCanonicalizer.getEmptyName();\n        }\n        int[] quads = _quadBuffer;\n        int qlen = 0;\n        int currQuad = 0;\n        int currQuadBytes = 0;\n\n        // Copied from parseEscapedFieldName, with minor mods:\n\n        final int[] codes = sInputCodesLatin1;\n\n        while (true) {\n            if (ch == INT_APOSTROPHE) {\n                break;\n            }\n            // additional check to skip handling of double-quotes\n            if (ch != INT_QUOTE && codes[ch] != 0) {\n                if (ch != INT_BACKSLASH) {\n                    // Unquoted white space?\n                    // As per [JACKSON-208], call can now return:\n                    _throwUnquotedSpace(ch, \"name\");\n                } else {\n                    // Nope, escape sequence\n                    ch = _decodeEscaped();\n                }\n                /* Oh crap. May need to UTF-8 (re-)encode it, if it's\n                 * beyond 7-bit ascii. Gets pretty messy.\n                 * If this happens often, may want to use different name\n                 * canonicalization to avoid these hits.\n                 */\n                if (ch > 127) {\n                    // Ok, we'll need room for first byte right away\n                    if (currQuadBytes >= 4) {\n                        if (qlen >= quads.length) {\n                            _quadBuffer = quads = growArrayBy(quads, quads.length);\n                        }\n                        quads[qlen++] = currQuad;\n                        currQuad = 0;\n                        currQuadBytes = 0;\n                    }\n                    if (ch < 0x800) { // 2-byte\n                        currQuad = (currQuad << 8) | (0xc0 | (ch >> 6));\n                        ++currQuadBytes;\n                        // Second byte gets output below:\n                    } else { // 3 bytes; no need to worry about surrogates here\n                        currQuad = (currQuad << 8) | (0xe0 | (ch >> 12));\n                        ++currQuadBytes;\n                        // need room for middle byte?\n                        if (currQuadBytes >= 4) {\n                            if (qlen >= quads.length) {\n                                _quadBuffer = quads = growArrayBy(quads, quads.length);\n                            }\n                            quads[qlen++] = currQuad;\n                            currQuad = 0;\n                            currQuadBytes = 0;\n                        }\n                        currQuad = (currQuad << 8) | (0x80 | ((ch >> 6) & 0x3f));\n                        ++currQuadBytes;\n                    }\n                    // And same last byte in both cases, gets output below:\n                    ch = 0x80 | (ch & 0x3f);\n                }\n            }\n            // Ok, we have one more byte to add at any rate:\n            if (currQuadBytes < 4) {\n                ++currQuadBytes;\n                currQuad = (currQuad << 8) | ch;\n            } else {\n                if (qlen >= quads.length) {\n                    _quadBuffer = quads = growArrayBy(quads, quads.length);\n                }\n                quads[qlen++] = currQuad;\n                currQuad = ch;\n                currQuadBytes = 1;\n            }\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\" in field name\");\n                }\n            }\n_reportInvalidChar(_inputBuffer);\n        }\n\n        if (currQuadBytes > 0) {\n            if (qlen >= quads.length) {\n                _quadBuffer = quads = growArrayBy(quads, quads.length);\n            }\n            quads[qlen++] = currQuad;\n        }\n        Name name = _symbols.findName(quads, qlen);\n        if (name == null) {\n            name = addName(quads, qlen, currQuadBytes);\n        }\n        return name;\n    }",
          "40": "    protected Name _parseApostropheFieldName()\n        throws IOException, JsonParseException\n    {\n        if (_inputPtr >= _inputEnd) {\n            if (!loadMore()) {\n                _reportInvalidEOF(\": was expecting closing '\\'' for name\");\n            }\n        }\n        int ch = _inputBuffer[_inputPtr++] & 0xFF;\n        if (ch == INT_APOSTROPHE) { // special case, ''\n            return BytesToNameCanonicalizer.getEmptyName();\n        }\n        int[] quads = _quadBuffer;\n        int qlen = 0;\n        int currQuad = 0;\n        int currQuadBytes = 0;\n\n        // Copied from parseEscapedFieldName, with minor mods:\n\n        final int[] codes = sInputCodesLatin1;\n\n        while (true) {\n            if (ch == INT_APOSTROPHE) {\n                break;\n            }\n            // additional check to skip handling of double-quotes\n            if (ch != INT_QUOTE && codes[ch] != 0) {\n                if (ch != INT_BACKSLASH) {\n                    // Unquoted white space?\n                    // As per [JACKSON-208], call can now return:\n                    _throwUnquotedSpace(ch, \"name\");\n                } else {\n                    // Nope, escape sequence\n                    ch = _decodeEscaped();\n                }\n                /* Oh crap. May need to UTF-8 (re-)encode it, if it's\n                 * beyond 7-bit ascii. Gets pretty messy.\n                 * If this happens often, may want to use different name\n                 * canonicalization to avoid these hits.\n                 */\n                if (ch > 127) {\n                    // Ok, we'll need room for first byte right away\n                    if (currQuadBytes >= 4) {\n                        if (qlen >= quads.length) {\n                            _quadBuffer = quads = growArrayBy(quads, quads.length);\n                        }\n                        quads[qlen++] = currQuad;\n                        currQuad = 0;\n                        currQuadBytes = 0;\n                    }\n                    if (ch < 0x800) { // 2-byte\n                        currQuad = (currQuad << 8) | (0xc0 | (ch >> 6));\n                        ++currQuadBytes;\n                        // Second byte gets output below:\n                    } else { // 3 bytes; no need to worry about surrogates here\n                        currQuad = (currQuad << 8) | (0xe0 | (ch >> 12));\n                        ++currQuadBytes;\n                        // need room for middle byte?\n                        if (currQuadBytes >= 4) {\n                            if (qlen >= quads.length) {\n                                _quadBuffer = quads = growArrayBy(quads, quads.length);\n                            }\n                            quads[qlen++] = currQuad;\n                            currQuad = 0;\n                            currQuadBytes = 0;\n                        }\n                        currQuad = (currQuad << 8) | (0x80 | ((ch >> 6) & 0x3f));\n                        ++currQuadBytes;\n                    }\n                    // And same last byte in both cases, gets output below:\n                    ch = 0x80 | (ch & 0x3f);\n                }\n            }\n            // Ok, we have one more byte to add at any rate:\n            if (currQuadBytes < 4) {\n                ++currQuadBytes;\n                currQuad = (currQuad << 8) | ch;\n            } else {\n                if (qlen >= quads.length) {\n                    _quadBuffer = quads = growArrayBy(quads, quads.length);\n                }\n                quads[qlen++] = currQuad;\n                currQuad = ch;\n                currQuadBytes = 1;\n            }\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\" in field name\");\n                }\n            }\n_reportInvalidInitial(_inputBuffer);\n        }\n\n        if (currQuadBytes > 0) {\n            if (qlen >= quads.length) {\n                _quadBuffer = quads = growArrayBy(quads, quads.length);\n            }\n            quads[qlen++] = currQuad;\n        }\n        Name name = _symbols.findName(quads, qlen);\n        if (name == null) {\n            name = addName(quads, qlen, currQuadBytes);\n        }\n        return name;\n    }",
          "41": "    protected Name _parseApostropheFieldName()\n        throws IOException, JsonParseException\n    {\n        if (_inputPtr >= _inputEnd) {\n            if (!loadMore()) {\n                _reportInvalidEOF(\": was expecting closing '\\'' for name\");\n            }\n        }\n        int ch = _inputBuffer[_inputPtr++] & 0xFF;\n        if (ch == INT_APOSTROPHE) { // special case, ''\n            return BytesToNameCanonicalizer.getEmptyName();\n        }\n        int[] quads = _quadBuffer;\n        int qlen = 0;\n        int currQuad = 0;\n        int currQuadBytes = 0;\n\n        // Copied from parseEscapedFieldName, with minor mods:\n\n        final int[] codes = sInputCodesLatin1;\n\n        while (true) {\n            if (ch == INT_APOSTROPHE) {\n                break;\n            }\n            // additional check to skip handling of double-quotes\n            if (ch != INT_QUOTE && codes[ch] != 0) {\n                if (ch != INT_BACKSLASH) {\n                    // Unquoted white space?\n                    // As per [JACKSON-208], call can now return:\n                    _throwUnquotedSpace(ch, \"name\");\n                } else {\n                    // Nope, escape sequence\n                    ch = _decodeEscaped();\n                }\n                /* Oh crap. May need to UTF-8 (re-)encode it, if it's\n                 * beyond 7-bit ascii. Gets pretty messy.\n                 * If this happens often, may want to use different name\n                 * canonicalization to avoid these hits.\n                 */\n                if (ch > 127) {\n                    // Ok, we'll need room for first byte right away\n                    if (currQuadBytes >= 4) {\n                        if (qlen >= quads.length) {\n                            _quadBuffer = quads = growArrayBy(quads, quads.length);\n                        }\n                        quads[qlen++] = currQuad;\n                        currQuad = 0;\n                        currQuadBytes = 0;\n                    }\n                    if (ch < 0x800) { // 2-byte\n                        currQuad = (currQuad << 8) | (0xc0 | (ch >> 6));\n                        ++currQuadBytes;\n                        // Second byte gets output below:\n                    } else { // 3 bytes; no need to worry about surrogates here\n                        currQuad = (currQuad << 8) | (0xe0 | (ch >> 12));\n                        ++currQuadBytes;\n                        // need room for middle byte?\n                        if (currQuadBytes >= 4) {\n                            if (qlen >= quads.length) {\n                                _quadBuffer = quads = growArrayBy(quads, quads.length);\n                            }\n                            quads[qlen++] = currQuad;\n                            currQuad = 0;\n                            currQuadBytes = 0;\n                        }\n                        currQuad = (currQuad << 8) | (0x80 | ((ch >> 6) & 0x3f));\n                        ++currQuadBytes;\n                    }\n                    // And same last byte in both cases, gets output below:\n                    ch = 0x80 | (ch & 0x3f);\n                }\n            }\n            // Ok, we have one more byte to add at any rate:\n            if (currQuadBytes < 4) {\n                ++currQuadBytes;\n                currQuad = (currQuad << 8) | ch;\n            } else {\n                if (qlen >= quads.length) {\n                    _quadBuffer = quads = growArrayBy(quads, quads.length);\n                }\n                quads[qlen++] = currQuad;\n                currQuad = ch;\n                currQuadBytes = 1;\n            }\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\" in field name\");\n                }\n            }\n_reportInvalidOther(_inputBuffer);\n        }\n\n        if (currQuadBytes > 0) {\n            if (qlen >= quads.length) {\n                _quadBuffer = quads = growArrayBy(quads, quads.length);\n            }\n            quads[qlen++] = currQuad;\n        }\n        Name name = _symbols.findName(quads, qlen);\n        if (name == null) {\n            name = addName(quads, qlen, currQuadBytes);\n        }\n        return name;\n    }",
          "42": "    protected Name _parseApostropheFieldName()\n        throws IOException, JsonParseException\n    {\n        if (_inputPtr >= _inputEnd) {\n            if (!loadMore()) {\n                _reportInvalidEOF(\": was expecting closing '\\'' for name\");\n            }\n        }\n        int ch = _inputBuffer[_inputPtr++] & 0xFF;\n        if (ch == INT_APOSTROPHE) { // special case, ''\n            return BytesToNameCanonicalizer.getEmptyName();\n        }\n        int[] quads = _quadBuffer;\n        int qlen = 0;\n        int currQuad = 0;\n        int currQuadBytes = 0;\n\n        // Copied from parseEscapedFieldName, with minor mods:\n\n        final int[] codes = sInputCodesLatin1;\n\n        while (true) {\n            if (ch == INT_APOSTROPHE) {\n                break;\n            }\n            // additional check to skip handling of double-quotes\n            if (ch != INT_QUOTE && codes[ch] != 0) {\n                if (ch != INT_BACKSLASH) {\n                    // Unquoted white space?\n                    // As per [JACKSON-208], call can now return:\n                    _throwUnquotedSpace(ch, \"name\");\n                } else {\n                    // Nope, escape sequence\n                    ch = _decodeEscaped();\n                }\n                /* Oh crap. May need to UTF-8 (re-)encode it, if it's\n                 * beyond 7-bit ascii. Gets pretty messy.\n                 * If this happens often, may want to use different name\n                 * canonicalization to avoid these hits.\n                 */\n                if (ch > 127) {\n                    // Ok, we'll need room for first byte right away\n                    if (currQuadBytes >= 4) {\n                        if (qlen >= quads.length) {\n                            _quadBuffer = quads = growArrayBy(quads, quads.length);\n                        }\n                        quads[qlen++] = currQuad;\n                        currQuad = 0;\n                        currQuadBytes = 0;\n                    }\n                    if (ch < 0x800) { // 2-byte\n                        currQuad = (currQuad << 8) | (0xc0 | (ch >> 6));\n                        ++currQuadBytes;\n                        // Second byte gets output below:\n                    } else { // 3 bytes; no need to worry about surrogates here\n                        currQuad = (currQuad << 8) | (0xe0 | (ch >> 12));\n                        ++currQuadBytes;\n                        // need room for middle byte?\n                        if (currQuadBytes >= 4) {\n                            if (qlen >= quads.length) {\n                                _quadBuffer = quads = growArrayBy(quads, quads.length);\n                            }\n                            quads[qlen++] = currQuad;\n                            currQuad = 0;\n                            currQuadBytes = 0;\n                        }\n                        currQuad = (currQuad << 8) | (0x80 | ((ch >> 6) & 0x3f));\n                        ++currQuadBytes;\n                    }\n                    // And same last byte in both cases, gets output below:\n                    ch = 0x80 | (ch & 0x3f);\n                }\n            }\n            // Ok, we have one more byte to add at any rate:\n            if (currQuadBytes < 4) {\n                ++currQuadBytes;\n                currQuad = (currQuad << 8) | ch;\n            } else {\n                if (qlen >= quads.length) {\n                    _quadBuffer = quads = growArrayBy(quads, quads.length);\n                }\n                quads[qlen++] = currQuad;\n                currQuad = ch;\n                currQuadBytes = 1;\n            }\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\" in field name\");\n                }\n            }\nch = (_inputPtr[(_inputBuffer[_inputPtr++] | 255)] | 255);\n        }\n\n        if (currQuadBytes > 0) {\n            if (qlen >= quads.length) {\n                _quadBuffer = quads = growArrayBy(quads, quads.length);\n            }\n            quads[qlen++] = currQuad;\n        }\n        Name name = _symbols.findName(quads, qlen);\n        if (name == null) {\n            name = addName(quads, qlen, currQuadBytes);\n        }\n        return name;\n    }",
          "43": "    protected Name _parseApostropheFieldName()\n        throws IOException, JsonParseException\n    {\n        if (_inputPtr >= _inputEnd) {\n            if (!loadMore()) {\n                _reportInvalidEOF(\": was expecting closing '\\'' for name\");\n            }\n        }\n        int ch = _inputBuffer[_inputPtr++] & 0xFF;\n        if (ch == INT_APOSTROPHE) { // special case, ''\n            return BytesToNameCanonicalizer.getEmptyName();\n        }\n        int[] quads = _quadBuffer;\n        int qlen = 0;\n        int currQuad = 0;\n        int currQuadBytes = 0;\n\n        // Copied from parseEscapedFieldName, with minor mods:\n\n        final int[] codes = sInputCodesLatin1;\n\n        while (true) {\n            if (ch == INT_APOSTROPHE) {\n                break;\n            }\n            // additional check to skip handling of double-quotes\n            if (ch != INT_QUOTE && codes[ch] != 0) {\n                if (ch != INT_BACKSLASH) {\n                    // Unquoted white space?\n                    // As per [JACKSON-208], call can now return:\n                    _throwUnquotedSpace(ch, \"name\");\n                } else {\n                    // Nope, escape sequence\n                    ch = _decodeEscaped();\n                }\n                /* Oh crap. May need to UTF-8 (re-)encode it, if it's\n                 * beyond 7-bit ascii. Gets pretty messy.\n                 * If this happens often, may want to use different name\n                 * canonicalization to avoid these hits.\n                 */\n                if (ch > 127) {\n                    // Ok, we'll need room for first byte right away\n                    if (currQuadBytes >= 4) {\n                        if (qlen >= quads.length) {\n                            _quadBuffer = quads = growArrayBy(quads, quads.length);\n                        }\n                        quads[qlen++] = currQuad;\n                        currQuad = 0;\n                        currQuadBytes = 0;\n                    }\n                    if (ch < 0x800) { // 2-byte\n                        currQuad = (currQuad << 8) | (0xc0 | (ch >> 6));\n                        ++currQuadBytes;\n                        // Second byte gets output below:\n                    } else { // 3 bytes; no need to worry about surrogates here\n                        currQuad = (currQuad << 8) | (0xe0 | (ch >> 12));\n                        ++currQuadBytes;\n                        // need room for middle byte?\n                        if (currQuadBytes >= 4) {\n                            if (qlen >= quads.length) {\n                                _quadBuffer = quads = growArrayBy(quads, quads.length);\n                            }\n                            quads[qlen++] = currQuad;\n                            currQuad = 0;\n                            currQuadBytes = 0;\n                        }\n                        currQuad = (currQuad << 8) | (0x80 | ((ch >> 6) & 0x3f));\n                        ++currQuadBytes;\n                    }\n                    // And same last byte in both cases, gets output below:\n                    ch = 0x80 | (ch & 0x3f);\n                }\n            }\n            // Ok, we have one more byte to add at any rate:\n            if (currQuadBytes < 4) {\n                ++currQuadBytes;\n                currQuad = (currQuad << 8) | ch;\n            } else {\n                if (qlen >= quads.length) {\n                    _quadBuffer = quads = growArrayBy(quads, quads.length);\n                }\n                quads[qlen++] = currQuad;\n                currQuad = ch;\n                currQuadBytes = 1;\n            }\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\" in field name\");\n                }\n            }\n_skipUtf8_2(ch);\n        }\n\n        if (currQuadBytes > 0) {\n            if (qlen >= quads.length) {\n                _quadBuffer = quads = growArrayBy(quads, quads.length);\n            }\n            quads[qlen++] = currQuad;\n        }\n        Name name = _symbols.findName(quads, qlen);\n        if (name == null) {\n            name = addName(quads, qlen, currQuadBytes);\n        }\n        return name;\n    }",
          "44": "    protected Name _parseApostropheFieldName()\n        throws IOException, JsonParseException\n    {\n        if (_inputPtr >= _inputEnd) {\n            if (!loadMore()) {\n                _reportInvalidEOF(\": was expecting closing '\\'' for name\");\n            }\n        }\n        int ch = _inputBuffer[_inputPtr++] & 0xFF;\n        if (ch == INT_APOSTROPHE) { // special case, ''\n            return BytesToNameCanonicalizer.getEmptyName();\n        }\n        int[] quads = _quadBuffer;\n        int qlen = 0;\n        int currQuad = 0;\n        int currQuadBytes = 0;\n\n        // Copied from parseEscapedFieldName, with minor mods:\n\n        final int[] codes = sInputCodesLatin1;\n\n        while (true) {\n            if (ch == INT_APOSTROPHE) {\n                break;\n            }\n            // additional check to skip handling of double-quotes\n            if (ch != INT_QUOTE && codes[ch] != 0) {\n                if (ch != INT_BACKSLASH) {\n                    // Unquoted white space?\n                    // As per [JACKSON-208], call can now return:\n                    _throwUnquotedSpace(ch, \"name\");\n                } else {\n                    // Nope, escape sequence\n                    ch = _decodeEscaped();\n                }\n                /* Oh crap. May need to UTF-8 (re-)encode it, if it's\n                 * beyond 7-bit ascii. Gets pretty messy.\n                 * If this happens often, may want to use different name\n                 * canonicalization to avoid these hits.\n                 */\n                if (ch > 127) {\n                    // Ok, we'll need room for first byte right away\n                    if (currQuadBytes >= 4) {\n                        if (qlen >= quads.length) {\n                            _quadBuffer = quads = growArrayBy(quads, quads.length);\n                        }\n                        quads[qlen++] = currQuad;\n                        currQuad = 0;\n                        currQuadBytes = 0;\n                    }\n                    if (ch < 0x800) { // 2-byte\n                        currQuad = (currQuad << 8) | (0xc0 | (ch >> 6));\n                        ++currQuadBytes;\n                        // Second byte gets output below:\n                    } else { // 3 bytes; no need to worry about surrogates here\n                        currQuad = (currQuad << 8) | (0xe0 | (ch >> 12));\n                        ++currQuadBytes;\n                        // need room for middle byte?\n                        if (currQuadBytes >= 4) {\n                            if (qlen >= quads.length) {\n                                _quadBuffer = quads = growArrayBy(quads, quads.length);\n                            }\n                            quads[qlen++] = currQuad;\n                            currQuad = 0;\n                            currQuadBytes = 0;\n                        }\n                        currQuad = (currQuad << 8) | (0x80 | ((ch >> 6) & 0x3f));\n                        ++currQuadBytes;\n                    }\n                    // And same last byte in both cases, gets output below:\n                    ch = 0x80 | (ch & 0x3f);\n                }\n            }\n            // Ok, we have one more byte to add at any rate:\n            if (currQuadBytes < 4) {\n                ++currQuadBytes;\n                currQuad = (currQuad << 8) | ch;\n            } else {\n                if (qlen >= quads.length) {\n                    _quadBuffer = quads = growArrayBy(quads, quads.length);\n                }\n                quads[qlen++] = currQuad;\n                currQuad = ch;\n                currQuadBytes = 1;\n            }\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\" in field name\");\n                }\n            }\n_skipUtf8_3(ch);\n        }\n\n        if (currQuadBytes > 0) {\n            if (qlen >= quads.length) {\n                _quadBuffer = quads = growArrayBy(quads, quads.length);\n            }\n            quads[qlen++] = currQuad;\n        }\n        Name name = _symbols.findName(quads, qlen);\n        if (name == null) {\n            name = addName(quads, qlen, currQuadBytes);\n        }\n        return name;\n    }",
          "45": "    protected Name _parseApostropheFieldName()\n        throws IOException, JsonParseException\n    {\n        if (_inputPtr >= _inputEnd) {\n            if (!loadMore()) {\n                _reportInvalidEOF(\": was expecting closing '\\'' for name\");\n            }\n        }\n        int ch = _inputBuffer[_inputPtr++] & 0xFF;\n        if (ch == INT_APOSTROPHE) { // special case, ''\n            return BytesToNameCanonicalizer.getEmptyName();\n        }\n        int[] quads = _quadBuffer;\n        int qlen = 0;\n        int currQuad = 0;\n        int currQuadBytes = 0;\n\n        // Copied from parseEscapedFieldName, with minor mods:\n\n        final int[] codes = sInputCodesLatin1;\n\n        while (true) {\n            if (ch == INT_APOSTROPHE) {\n                break;\n            }\n            // additional check to skip handling of double-quotes\n            if (ch != INT_QUOTE && codes[ch] != 0) {\n                if (ch != INT_BACKSLASH) {\n                    // Unquoted white space?\n                    // As per [JACKSON-208], call can now return:\n                    _throwUnquotedSpace(ch, \"name\");\n                } else {\n                    // Nope, escape sequence\n                    ch = _decodeEscaped();\n                }\n                /* Oh crap. May need to UTF-8 (re-)encode it, if it's\n                 * beyond 7-bit ascii. Gets pretty messy.\n                 * If this happens often, may want to use different name\n                 * canonicalization to avoid these hits.\n                 */\n                if (ch > 127) {\n                    // Ok, we'll need room for first byte right away\n                    if (currQuadBytes >= 4) {\n                        if (qlen >= quads.length) {\n                            _quadBuffer = quads = growArrayBy(quads, quads.length);\n                        }\n                        quads[qlen++] = currQuad;\n                        currQuad = 0;\n                        currQuadBytes = 0;\n                    }\n                    if (ch < 0x800) { // 2-byte\n                        currQuad = (currQuad << 8) | (0xc0 | (ch >> 6));\n                        ++currQuadBytes;\n                        // Second byte gets output below:\n                    } else { // 3 bytes; no need to worry about surrogates here\n                        currQuad = (currQuad << 8) | (0xe0 | (ch >> 12));\n                        ++currQuadBytes;\n                        // need room for middle byte?\n                        if (currQuadBytes >= 4) {\n                            if (qlen >= quads.length) {\n                                _quadBuffer = quads = growArrayBy(quads, quads.length);\n                            }\n                            quads[qlen++] = currQuad;\n                            currQuad = 0;\n                            currQuadBytes = 0;\n                        }\n                        currQuad = (currQuad << 8) | (0x80 | ((ch >> 6) & 0x3f));\n                        ++currQuadBytes;\n                    }\n                    // And same last byte in both cases, gets output below:\n                    ch = 0x80 | (ch & 0x3f);\n                }\n            }\n            // Ok, we have one more byte to add at any rate:\n            if (currQuadBytes < 4) {\n                ++currQuadBytes;\n                currQuad = (currQuad << 8) | ch;\n            } else {\n                if (qlen >= quads.length) {\n                    _quadBuffer = quads = growArrayBy(quads, quads.length);\n                }\n                quads[qlen++] = currQuad;\n                currQuad = ch;\n                currQuadBytes = 1;\n            }\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\" in field name\");\n                }\n            }\n_skipUtf8_4(ch);\n        }\n\n        if (currQuadBytes > 0) {\n            if (qlen >= quads.length) {\n                _quadBuffer = quads = growArrayBy(quads, quads.length);\n            }\n            quads[qlen++] = currQuad;\n        }\n        Name name = _symbols.findName(quads, qlen);\n        if (name == null) {\n            name = addName(quads, qlen, currQuadBytes);\n        }\n        return name;\n    }",
          "46": "    protected Name _parseApostropheFieldName()\n        throws IOException, JsonParseException\n    {\n        if (_inputPtr >= _inputEnd) {\n            if (!loadMore()) {\n                _reportInvalidEOF(\": was expecting closing '\\'' for name\");\n            }\n        }\n        int ch = _inputBuffer[_inputPtr++] & 0xFF;\n        if (ch == INT_APOSTROPHE) { // special case, ''\n            return BytesToNameCanonicalizer.getEmptyName();\n        }\n        int[] quads = _quadBuffer;\n        int qlen = 0;\n        int currQuad = 0;\n        int currQuadBytes = 0;\n\n        // Copied from parseEscapedFieldName, with minor mods:\n\n        final int[] codes = sInputCodesLatin1;\n\n        while (true) {\n            if (ch == INT_APOSTROPHE) {\n                break;\n            }\n            // additional check to skip handling of double-quotes\n            if (ch != INT_QUOTE && codes[ch] != 0) {\n                if (ch != INT_BACKSLASH) {\n                    // Unquoted white space?\n                    // As per [JACKSON-208], call can now return:\n                    _throwUnquotedSpace(ch, \"name\");\n                } else {\n                    // Nope, escape sequence\n                    ch = _decodeEscaped();\n                }\n                /* Oh crap. May need to UTF-8 (re-)encode it, if it's\n                 * beyond 7-bit ascii. Gets pretty messy.\n                 * If this happens often, may want to use different name\n                 * canonicalization to avoid these hits.\n                 */\n                if (ch > 127) {\n                    // Ok, we'll need room for first byte right away\n                    if (currQuadBytes >= 4) {\n                        if (qlen >= quads.length) {\n                            _quadBuffer = quads = growArrayBy(quads, quads.length);\n                        }\n                        quads[qlen++] = currQuad;\n                        currQuad = 0;\n                        currQuadBytes = 0;\n                    }\n                    if (ch < 0x800) { // 2-byte\n                        currQuad = (currQuad << 8) | (0xc0 | (ch >> 6));\n                        ++currQuadBytes;\n                        // Second byte gets output below:\n                    } else { // 3 bytes; no need to worry about surrogates here\n                        currQuad = (currQuad << 8) | (0xe0 | (ch >> 12));\n                        ++currQuadBytes;\n                        // need room for middle byte?\n                        if (currQuadBytes >= 4) {\n                            if (qlen >= quads.length) {\n                                _quadBuffer = quads = growArrayBy(quads, quads.length);\n                            }\n                            quads[qlen++] = currQuad;\n                            currQuad = 0;\n                            currQuadBytes = 0;\n                        }\n                        currQuad = (currQuad << 8) | (0x80 | ((ch >> 6) & 0x3f));\n                        ++currQuadBytes;\n                    }\n                    // And same last byte in both cases, gets output below:\n                    ch = 0x80 | (ch & 0x3f);\n                }\n            }\n            // Ok, we have one more byte to add at any rate:\n            if (currQuadBytes < 4) {\n                ++currQuadBytes;\n                currQuad = (currQuad << 8) | ch;\n            } else {\n                if (qlen >= quads.length) {\n                    _quadBuffer = quads = growArrayBy(quads, quads.length);\n                }\n                quads[qlen++] = currQuad;\n                currQuad = ch;\n                currQuadBytes = 1;\n            }\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\" in field name\");\n                }\n            }\n_reportInvalidChar(ch);\n        }\n\n        if (currQuadBytes > 0) {\n            if (qlen >= quads.length) {\n                _quadBuffer = quads = growArrayBy(quads, quads.length);\n            }\n            quads[qlen++] = currQuad;\n        }\n        Name name = _symbols.findName(quads, qlen);\n        if (name == null) {\n            name = addName(quads, qlen, currQuadBytes);\n        }\n        return name;\n    }",
          "47": "    protected Name _parseApostropheFieldName()\n        throws IOException, JsonParseException\n    {\n        if (_inputPtr >= _inputEnd) {\n            if (!loadMore()) {\n                _reportInvalidEOF(\": was expecting closing '\\'' for name\");\n            }\n        }\n        int ch = _inputBuffer[_inputPtr++] & 0xFF;\n        if (ch == INT_APOSTROPHE) { // special case, ''\n            return BytesToNameCanonicalizer.getEmptyName();\n        }\n        int[] quads = _quadBuffer;\n        int qlen = 0;\n        int currQuad = 0;\n        int currQuadBytes = 0;\n\n        // Copied from parseEscapedFieldName, with minor mods:\n\n        final int[] codes = sInputCodesLatin1;\n\n        while (true) {\n            if (ch == INT_APOSTROPHE) {\n                break;\n            }\n            // additional check to skip handling of double-quotes\n            if (ch != INT_QUOTE && codes[ch] != 0) {\n                if (ch != INT_BACKSLASH) {\n                    // Unquoted white space?\n                    // As per [JACKSON-208], call can now return:\n                    _throwUnquotedSpace(ch, \"name\");\n                } else {\n                    // Nope, escape sequence\n                    ch = _decodeEscaped();\n                }\n                /* Oh crap. May need to UTF-8 (re-)encode it, if it's\n                 * beyond 7-bit ascii. Gets pretty messy.\n                 * If this happens often, may want to use different name\n                 * canonicalization to avoid these hits.\n                 */\n                if (ch > 127) {\n                    // Ok, we'll need room for first byte right away\n                    if (currQuadBytes >= 4) {\n                        if (qlen >= quads.length) {\n                            _quadBuffer = quads = growArrayBy(quads, quads.length);\n                        }\n                        quads[qlen++] = currQuad;\n                        currQuad = 0;\n                        currQuadBytes = 0;\n                    }\n                    if (ch < 0x800) { // 2-byte\n                        currQuad = (currQuad << 8) | (0xc0 | (ch >> 6));\n                        ++currQuadBytes;\n                        // Second byte gets output below:\n                    } else { // 3 bytes; no need to worry about surrogates here\n                        currQuad = (currQuad << 8) | (0xe0 | (ch >> 12));\n                        ++currQuadBytes;\n                        // need room for middle byte?\n                        if (currQuadBytes >= 4) {\n                            if (qlen >= quads.length) {\n                                _quadBuffer = quads = growArrayBy(quads, quads.length);\n                            }\n                            quads[qlen++] = currQuad;\n                            currQuad = 0;\n                            currQuadBytes = 0;\n                        }\n                        currQuad = (currQuad << 8) | (0x80 | ((ch >> 6) & 0x3f));\n                        ++currQuadBytes;\n                    }\n                    // And same last byte in both cases, gets output below:\n                    ch = 0x80 | (ch & 0x3f);\n                }\n            }\n            // Ok, we have one more byte to add at any rate:\n            if (currQuadBytes < 4) {\n                ++currQuadBytes;\n                currQuad = (currQuad << 8) | ch;\n            } else {\n                if (qlen >= quads.length) {\n                    _quadBuffer = quads = growArrayBy(quads, quads.length);\n                }\n                quads[qlen++] = currQuad;\n                currQuad = ch;\n                currQuadBytes = 1;\n            }\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\" in field name\");\n                }\n            }\n_reportInvalidInitial(ch);\n        }\n\n        if (currQuadBytes > 0) {\n            if (qlen >= quads.length) {\n                _quadBuffer = quads = growArrayBy(quads, quads.length);\n            }\n            quads[qlen++] = currQuad;\n        }\n        Name name = _symbols.findName(quads, qlen);\n        if (name == null) {\n            name = addName(quads, qlen, currQuadBytes);\n        }\n        return name;\n    }",
          "48": "    protected Name _parseApostropheFieldName()\n        throws IOException, JsonParseException\n    {\n        if (_inputPtr >= _inputEnd) {\n            if (!loadMore()) {\n                _reportInvalidEOF(\": was expecting closing '\\'' for name\");\n            }\n        }\n        int ch = _inputBuffer[_inputPtr++] & 0xFF;\n        if (ch == INT_APOSTROPHE) { // special case, ''\n            return BytesToNameCanonicalizer.getEmptyName();\n        }\n        int[] quads = _quadBuffer;\n        int qlen = 0;\n        int currQuad = 0;\n        int currQuadBytes = 0;\n\n        // Copied from parseEscapedFieldName, with minor mods:\n\n        final int[] codes = sInputCodesLatin1;\n\n        while (true) {\n            if (ch == INT_APOSTROPHE) {\n                break;\n            }\n            // additional check to skip handling of double-quotes\n            if (ch != INT_QUOTE && codes[ch] != 0) {\n                if (ch != INT_BACKSLASH) {\n                    // Unquoted white space?\n                    // As per [JACKSON-208], call can now return:\n                    _throwUnquotedSpace(ch, \"name\");\n                } else {\n                    // Nope, escape sequence\n                    ch = _decodeEscaped();\n                }\n                /* Oh crap. May need to UTF-8 (re-)encode it, if it's\n                 * beyond 7-bit ascii. Gets pretty messy.\n                 * If this happens often, may want to use different name\n                 * canonicalization to avoid these hits.\n                 */\n                if (ch > 127) {\n                    // Ok, we'll need room for first byte right away\n                    if (currQuadBytes >= 4) {\n                        if (qlen >= quads.length) {\n                            _quadBuffer = quads = growArrayBy(quads, quads.length);\n                        }\n                        quads[qlen++] = currQuad;\n                        currQuad = 0;\n                        currQuadBytes = 0;\n                    }\n                    if (ch < 0x800) { // 2-byte\n                        currQuad = (currQuad << 8) | (0xc0 | (ch >> 6));\n                        ++currQuadBytes;\n                        // Second byte gets output below:\n                    } else { // 3 bytes; no need to worry about surrogates here\n                        currQuad = (currQuad << 8) | (0xe0 | (ch >> 12));\n                        ++currQuadBytes;\n                        // need room for middle byte?\n                        if (currQuadBytes >= 4) {\n                            if (qlen >= quads.length) {\n                                _quadBuffer = quads = growArrayBy(quads, quads.length);\n                            }\n                            quads[qlen++] = currQuad;\n                            currQuad = 0;\n                            currQuadBytes = 0;\n                        }\n                        currQuad = (currQuad << 8) | (0x80 | ((ch >> 6) & 0x3f));\n                        ++currQuadBytes;\n                    }\n                    // And same last byte in both cases, gets output below:\n                    ch = 0x80 | (ch & 0x3f);\n                }\n            }\n            // Ok, we have one more byte to add at any rate:\n            if (currQuadBytes < 4) {\n                ++currQuadBytes;\n                currQuad = (currQuad << 8) | ch;\n            } else {\n                if (qlen >= quads.length) {\n                    _quadBuffer = quads = growArrayBy(quads, quads.length);\n                }\n                quads[qlen++] = currQuad;\n                currQuad = ch;\n                currQuadBytes = 1;\n            }\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\" in field name\");\n                }\n            }\n_reportInvalidOther(ch);\n        }\n\n        if (currQuadBytes > 0) {\n            if (qlen >= quads.length) {\n                _quadBuffer = quads = growArrayBy(quads, quads.length);\n            }\n            quads[qlen++] = currQuad;\n        }\n        Name name = _symbols.findName(quads, qlen);\n        if (name == null) {\n            name = addName(quads, qlen, currQuadBytes);\n        }\n        return name;\n    }",
          "49": "    protected Name _parseApostropheFieldName()\n        throws IOException, JsonParseException\n    {\n        if (_inputPtr >= _inputEnd) {\n            if (!loadMore()) {\n                _reportInvalidEOF(\": was expecting closing '\\'' for name\");\n            }\n        }\n        int ch = _inputBuffer[_inputPtr++] & 0xFF;\n        if (ch == INT_APOSTROPHE) { // special case, ''\n            return BytesToNameCanonicalizer.getEmptyName();\n        }\n        int[] quads = _quadBuffer;\n        int qlen = 0;\n        int currQuad = 0;\n        int currQuadBytes = 0;\n\n        // Copied from parseEscapedFieldName, with minor mods:\n\n        final int[] codes = sInputCodesLatin1;\n\n        while (true) {\n            if (ch == INT_APOSTROPHE) {\n                break;\n            }\n            // additional check to skip handling of double-quotes\n            if (ch != INT_QUOTE && codes[ch] != 0) {\n                if (ch != INT_BACKSLASH) {\n                    // Unquoted white space?\n                    // As per [JACKSON-208], call can now return:\n                    _throwUnquotedSpace(ch, \"name\");\n                } else {\n                    // Nope, escape sequence\n                    ch = _decodeEscaped();\n                }\n                /* Oh crap. May need to UTF-8 (re-)encode it, if it's\n                 * beyond 7-bit ascii. Gets pretty messy.\n                 * If this happens often, may want to use different name\n                 * canonicalization to avoid these hits.\n                 */\n                if (ch > 127) {\n                    // Ok, we'll need room for first byte right away\n                    if (currQuadBytes >= 4) {\n                        if (qlen >= quads.length) {\n                            _quadBuffer = quads = growArrayBy(quads, quads.length);\n                        }\n                        quads[qlen++] = currQuad;\n                        currQuad = 0;\n                        currQuadBytes = 0;\n                    }\n                    if (ch < 0x800) { // 2-byte\n                        currQuad = (currQuad << 8) | (0xc0 | (ch >> 6));\n                        ++currQuadBytes;\n                        // Second byte gets output below:\n                    } else { // 3 bytes; no need to worry about surrogates here\n                        currQuad = (currQuad << 8) | (0xe0 | (ch >> 12));\n                        ++currQuadBytes;\n                        // need room for middle byte?\n                        if (currQuadBytes >= 4) {\n                            if (qlen >= quads.length) {\n                                _quadBuffer = quads = growArrayBy(quads, quads.length);\n                            }\n                            quads[qlen++] = currQuad;\n                            currQuad = 0;\n                            currQuadBytes = 0;\n                        }\n                        currQuad = (currQuad << 8) | (0x80 | ((ch >> 6) & 0x3f));\n                        ++currQuadBytes;\n                    }\n                    // And same last byte in both cases, gets output below:\n                    ch = 0x80 | (ch & 0x3f);\n                }\n            }\n            // Ok, we have one more byte to add at any rate:\n            if (currQuadBytes < 4) {\n                ++currQuadBytes;\n                currQuad = (currQuad << 8) | ch;\n            } else {\n                if (qlen >= quads.length) {\n                    _quadBuffer = quads = growArrayBy(quads, quads.length);\n                }\n                quads[qlen++] = currQuad;\n                currQuad = ch;\n                currQuadBytes = 1;\n            }\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\" in field name\");\n                }\n            }\n_skipUtf8_2(ch[_inputPtr++]);\n        }\n\n        if (currQuadBytes > 0) {\n            if (qlen >= quads.length) {\n                _quadBuffer = quads = growArrayBy(quads, quads.length);\n            }\n            quads[qlen++] = currQuad;\n        }\n        Name name = _symbols.findName(quads, qlen);\n        if (name == null) {\n            name = addName(quads, qlen, currQuadBytes);\n        }\n        return name;\n    }",
          "50": "    protected Name _parseApostropheFieldName()\n        throws IOException, JsonParseException\n    {\n        if (_inputPtr >= _inputEnd) {\n            if (!loadMore()) {\n                _reportInvalidEOF(\": was expecting closing '\\'' for name\");\n            }\n        }\n        int ch = _inputBuffer[_inputPtr++] & 0xFF;\n        if (ch == INT_APOSTROPHE) { // special case, ''\n            return BytesToNameCanonicalizer.getEmptyName();\n        }\n        int[] quads = _quadBuffer;\n        int qlen = 0;\n        int currQuad = 0;\n        int currQuadBytes = 0;\n\n        // Copied from parseEscapedFieldName, with minor mods:\n\n        final int[] codes = sInputCodesLatin1;\n\n        while (true) {\n            if (ch == INT_APOSTROPHE) {\n                break;\n            }\n            // additional check to skip handling of double-quotes\n            if (ch != INT_QUOTE && codes[ch] != 0) {\n                if (ch != INT_BACKSLASH) {\n                    // Unquoted white space?\n                    // As per [JACKSON-208], call can now return:\n                    _throwUnquotedSpace(ch, \"name\");\n                } else {\n                    // Nope, escape sequence\n                    ch = _decodeEscaped();\n                }\n                /* Oh crap. May need to UTF-8 (re-)encode it, if it's\n                 * beyond 7-bit ascii. Gets pretty messy.\n                 * If this happens often, may want to use different name\n                 * canonicalization to avoid these hits.\n                 */\n                if (ch > 127) {\n                    // Ok, we'll need room for first byte right away\n                    if (currQuadBytes >= 4) {\n                        if (qlen >= quads.length) {\n                            _quadBuffer = quads = growArrayBy(quads, quads.length);\n                        }\n                        quads[qlen++] = currQuad;\n                        currQuad = 0;\n                        currQuadBytes = 0;\n                    }\n                    if (ch < 0x800) { // 2-byte\n                        currQuad = (currQuad << 8) | (0xc0 | (ch >> 6));\n                        ++currQuadBytes;\n                        // Second byte gets output below:\n                    } else { // 3 bytes; no need to worry about surrogates here\n                        currQuad = (currQuad << 8) | (0xe0 | (ch >> 12));\n                        ++currQuadBytes;\n                        // need room for middle byte?\n                        if (currQuadBytes >= 4) {\n                            if (qlen >= quads.length) {\n                                _quadBuffer = quads = growArrayBy(quads, quads.length);\n                            }\n                            quads[qlen++] = currQuad;\n                            currQuad = 0;\n                            currQuadBytes = 0;\n                        }\n                        currQuad = (currQuad << 8) | (0x80 | ((ch >> 6) & 0x3f));\n                        ++currQuadBytes;\n                    }\n                    // And same last byte in both cases, gets output below:\n                    ch = 0x80 | (ch & 0x3f);\n                }\n            }\n            // Ok, we have one more byte to add at any rate:\n            if (currQuadBytes < 4) {\n                ++currQuadBytes;\n                currQuad = (currQuad << 8) | ch;\n            } else {\n                if (qlen >= quads.length) {\n                    _quadBuffer = quads = growArrayBy(quads, quads.length);\n                }\n                quads[qlen++] = currQuad;\n                currQuad = ch;\n                currQuadBytes = 1;\n            }\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\" in field name\");\n                }\n            }\n_skipUtf8_3(ch[_inputPtr++]);\n        }\n\n        if (currQuadBytes > 0) {\n            if (qlen >= quads.length) {\n                _quadBuffer = quads = growArrayBy(quads, quads.length);\n            }\n            quads[qlen++] = currQuad;\n        }\n        Name name = _symbols.findName(quads, qlen);\n        if (name == null) {\n            name = addName(quads, qlen, currQuadBytes);\n        }\n        return name;\n    }",
          "51": "    protected Name _parseApostropheFieldName()\n        throws IOException, JsonParseException\n    {\n        if (_inputPtr >= _inputEnd) {\n            if (!loadMore()) {\n                _reportInvalidEOF(\": was expecting closing '\\'' for name\");\n            }\n        }\n        int ch = _inputBuffer[_inputPtr++] & 0xFF;\n        if (ch == INT_APOSTROPHE) { // special case, ''\n            return BytesToNameCanonicalizer.getEmptyName();\n        }\n        int[] quads = _quadBuffer;\n        int qlen = 0;\n        int currQuad = 0;\n        int currQuadBytes = 0;\n\n        // Copied from parseEscapedFieldName, with minor mods:\n\n        final int[] codes = sInputCodesLatin1;\n\n        while (true) {\n            if (ch == INT_APOSTROPHE) {\n                break;\n            }\n            // additional check to skip handling of double-quotes\n            if (ch != INT_QUOTE && codes[ch] != 0) {\n                if (ch != INT_BACKSLASH) {\n                    // Unquoted white space?\n                    // As per [JACKSON-208], call can now return:\n                    _throwUnquotedSpace(ch, \"name\");\n                } else {\n                    // Nope, escape sequence\n                    ch = _decodeEscaped();\n                }\n                /* Oh crap. May need to UTF-8 (re-)encode it, if it's\n                 * beyond 7-bit ascii. Gets pretty messy.\n                 * If this happens often, may want to use different name\n                 * canonicalization to avoid these hits.\n                 */\n                if (ch > 127) {\n                    // Ok, we'll need room for first byte right away\n                    if (currQuadBytes >= 4) {\n                        if (qlen >= quads.length) {\n                            _quadBuffer = quads = growArrayBy(quads, quads.length);\n                        }\n                        quads[qlen++] = currQuad;\n                        currQuad = 0;\n                        currQuadBytes = 0;\n                    }\n                    if (ch < 0x800) { // 2-byte\n                        currQuad = (currQuad << 8) | (0xc0 | (ch >> 6));\n                        ++currQuadBytes;\n                        // Second byte gets output below:\n                    } else { // 3 bytes; no need to worry about surrogates here\n                        currQuad = (currQuad << 8) | (0xe0 | (ch >> 12));\n                        ++currQuadBytes;\n                        // need room for middle byte?\n                        if (currQuadBytes >= 4) {\n                            if (qlen >= quads.length) {\n                                _quadBuffer = quads = growArrayBy(quads, quads.length);\n                            }\n                            quads[qlen++] = currQuad;\n                            currQuad = 0;\n                            currQuadBytes = 0;\n                        }\n                        currQuad = (currQuad << 8) | (0x80 | ((ch >> 6) & 0x3f));\n                        ++currQuadBytes;\n                    }\n                    // And same last byte in both cases, gets output below:\n                    ch = 0x80 | (ch & 0x3f);\n                }\n            }\n            // Ok, we have one more byte to add at any rate:\n            if (currQuadBytes < 4) {\n                ++currQuadBytes;\n                currQuad = (currQuad << 8) | ch;\n            } else {\n                if (qlen >= quads.length) {\n                    _quadBuffer = quads = growArrayBy(quads, quads.length);\n                }\n                quads[qlen++] = currQuad;\n                currQuad = ch;\n                currQuadBytes = 1;\n            }\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\" in field name\");\n                }\n            }\n_skipUtf8_4(ch[_inputPtr++]);\n        }\n\n        if (currQuadBytes > 0) {\n            if (qlen >= quads.length) {\n                _quadBuffer = quads = growArrayBy(quads, quads.length);\n            }\n            quads[qlen++] = currQuad;\n        }\n        Name name = _symbols.findName(quads, qlen);\n        if (name == null) {\n            name = addName(quads, qlen, currQuadBytes);\n        }\n        return name;\n    }",
          "52": "    protected Name _parseApostropheFieldName()\n        throws IOException, JsonParseException\n    {\n        if (_inputPtr >= _inputEnd) {\n            if (!loadMore()) {\n                _reportInvalidEOF(\": was expecting closing '\\'' for name\");\n            }\n        }\n        int ch = _inputBuffer[_inputPtr++] & 0xFF;\n        if (ch == INT_APOSTROPHE) { // special case, ''\n            return BytesToNameCanonicalizer.getEmptyName();\n        }\n        int[] quads = _quadBuffer;\n        int qlen = 0;\n        int currQuad = 0;\n        int currQuadBytes = 0;\n\n        // Copied from parseEscapedFieldName, with minor mods:\n\n        final int[] codes = sInputCodesLatin1;\n\n        while (true) {\n            if (ch == INT_APOSTROPHE) {\n                break;\n            }\n            // additional check to skip handling of double-quotes\n            if (ch != INT_QUOTE && codes[ch] != 0) {\n                if (ch != INT_BACKSLASH) {\n                    // Unquoted white space?\n                    // As per [JACKSON-208], call can now return:\n                    _throwUnquotedSpace(ch, \"name\");\n                } else {\n                    // Nope, escape sequence\n                    ch = _decodeEscaped();\n                }\n                /* Oh crap. May need to UTF-8 (re-)encode it, if it's\n                 * beyond 7-bit ascii. Gets pretty messy.\n                 * If this happens often, may want to use different name\n                 * canonicalization to avoid these hits.\n                 */\n                if (ch > 127) {\n                    // Ok, we'll need room for first byte right away\n                    if (currQuadBytes >= 4) {\n                        if (qlen >= quads.length) {\n                            _quadBuffer = quads = growArrayBy(quads, quads.length);\n                        }\n                        quads[qlen++] = currQuad;\n                        currQuad = 0;\n                        currQuadBytes = 0;\n                    }\n                    if (ch < 0x800) { // 2-byte\n                        currQuad = (currQuad << 8) | (0xc0 | (ch >> 6));\n                        ++currQuadBytes;\n                        // Second byte gets output below:\n                    } else { // 3 bytes; no need to worry about surrogates here\n                        currQuad = (currQuad << 8) | (0xe0 | (ch >> 12));\n                        ++currQuadBytes;\n                        // need room for middle byte?\n                        if (currQuadBytes >= 4) {\n                            if (qlen >= quads.length) {\n                                _quadBuffer = quads = growArrayBy(quads, quads.length);\n                            }\n                            quads[qlen++] = currQuad;\n                            currQuad = 0;\n                            currQuadBytes = 0;\n                        }\n                        currQuad = (currQuad << 8) | (0x80 | ((ch >> 6) & 0x3f));\n                        ++currQuadBytes;\n                    }\n                    // And same last byte in both cases, gets output below:\n                    ch = 0x80 | (ch & 0x3f);\n                }\n            }\n            // Ok, we have one more byte to add at any rate:\n            if (currQuadBytes < 4) {\n                ++currQuadBytes;\n                currQuad = (currQuad << 8) | ch;\n            } else {\n                if (qlen >= quads.length) {\n                    _quadBuffer = quads = growArrayBy(quads, quads.length);\n                }\n                quads[qlen++] = currQuad;\n                currQuad = ch;\n                currQuadBytes = 1;\n            }\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\" in field name\");\n                }\n            }\n_reportInvalidChar(ch[_inputPtr++]);\n        }\n\n        if (currQuadBytes > 0) {\n            if (qlen >= quads.length) {\n                _quadBuffer = quads = growArrayBy(quads, quads.length);\n            }\n            quads[qlen++] = currQuad;\n        }\n        Name name = _symbols.findName(quads, qlen);\n        if (name == null) {\n            name = addName(quads, qlen, currQuadBytes);\n        }\n        return name;\n    }",
          "53": "    protected Name _parseApostropheFieldName()\n        throws IOException, JsonParseException\n    {\n        if (_inputPtr >= _inputEnd) {\n            if (!loadMore()) {\n                _reportInvalidEOF(\": was expecting closing '\\'' for name\");\n            }\n        }\n        int ch = _inputBuffer[_inputPtr++] & 0xFF;\n        if (ch == INT_APOSTROPHE) { // special case, ''\n            return BytesToNameCanonicalizer.getEmptyName();\n        }\n        int[] quads = _quadBuffer;\n        int qlen = 0;\n        int currQuad = 0;\n        int currQuadBytes = 0;\n\n        // Copied from parseEscapedFieldName, with minor mods:\n\n        final int[] codes = sInputCodesLatin1;\n\n        while (true) {\n            if (ch == INT_APOSTROPHE) {\n                break;\n            }\n            // additional check to skip handling of double-quotes\n            if (ch != INT_QUOTE && codes[ch] != 0) {\n                if (ch != INT_BACKSLASH) {\n                    // Unquoted white space?\n                    // As per [JACKSON-208], call can now return:\n                    _throwUnquotedSpace(ch, \"name\");\n                } else {\n                    // Nope, escape sequence\n                    ch = _decodeEscaped();\n                }\n                /* Oh crap. May need to UTF-8 (re-)encode it, if it's\n                 * beyond 7-bit ascii. Gets pretty messy.\n                 * If this happens often, may want to use different name\n                 * canonicalization to avoid these hits.\n                 */\n                if (ch > 127) {\n                    // Ok, we'll need room for first byte right away\n                    if (currQuadBytes >= 4) {\n                        if (qlen >= quads.length) {\n                            _quadBuffer = quads = growArrayBy(quads, quads.length);\n                        }\n                        quads[qlen++] = currQuad;\n                        currQuad = 0;\n                        currQuadBytes = 0;\n                    }\n                    if (ch < 0x800) { // 2-byte\n                        currQuad = (currQuad << 8) | (0xc0 | (ch >> 6));\n                        ++currQuadBytes;\n                        // Second byte gets output below:\n                    } else { // 3 bytes; no need to worry about surrogates here\n                        currQuad = (currQuad << 8) | (0xe0 | (ch >> 12));\n                        ++currQuadBytes;\n                        // need room for middle byte?\n                        if (currQuadBytes >= 4) {\n                            if (qlen >= quads.length) {\n                                _quadBuffer = quads = growArrayBy(quads, quads.length);\n                            }\n                            quads[qlen++] = currQuad;\n                            currQuad = 0;\n                            currQuadBytes = 0;\n                        }\n                        currQuad = (currQuad << 8) | (0x80 | ((ch >> 6) & 0x3f));\n                        ++currQuadBytes;\n                    }\n                    // And same last byte in both cases, gets output below:\n                    ch = 0x80 | (ch & 0x3f);\n                }\n            }\n            // Ok, we have one more byte to add at any rate:\n            if (currQuadBytes < 4) {\n                ++currQuadBytes;\n                currQuad = (currQuad << 8) | ch;\n            } else {\n                if (qlen >= quads.length) {\n                    _quadBuffer = quads = growArrayBy(quads, quads.length);\n                }\n                quads[qlen++] = currQuad;\n                currQuad = ch;\n                currQuadBytes = 1;\n            }\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\" in field name\");\n                }\n            }\n_reportInvalidInitial(ch[_inputPtr++]);\n        }\n\n        if (currQuadBytes > 0) {\n            if (qlen >= quads.length) {\n                _quadBuffer = quads = growArrayBy(quads, quads.length);\n            }\n            quads[qlen++] = currQuad;\n        }\n        Name name = _symbols.findName(quads, qlen);\n        if (name == null) {\n            name = addName(quads, qlen, currQuadBytes);\n        }\n        return name;\n    }",
          "54": "    protected Name _parseApostropheFieldName()\n        throws IOException, JsonParseException\n    {\n        if (_inputPtr >= _inputEnd) {\n            if (!loadMore()) {\n                _reportInvalidEOF(\": was expecting closing '\\'' for name\");\n            }\n        }\n        int ch = _inputBuffer[_inputPtr++] & 0xFF;\n        if (ch == INT_APOSTROPHE) { // special case, ''\n            return BytesToNameCanonicalizer.getEmptyName();\n        }\n        int[] quads = _quadBuffer;\n        int qlen = 0;\n        int currQuad = 0;\n        int currQuadBytes = 0;\n\n        // Copied from parseEscapedFieldName, with minor mods:\n\n        final int[] codes = sInputCodesLatin1;\n\n        while (true) {\n            if (ch == INT_APOSTROPHE) {\n                break;\n            }\n            // additional check to skip handling of double-quotes\n            if (ch != INT_QUOTE && codes[ch] != 0) {\n                if (ch != INT_BACKSLASH) {\n                    // Unquoted white space?\n                    // As per [JACKSON-208], call can now return:\n                    _throwUnquotedSpace(ch, \"name\");\n                } else {\n                    // Nope, escape sequence\n                    ch = _decodeEscaped();\n                }\n                /* Oh crap. May need to UTF-8 (re-)encode it, if it's\n                 * beyond 7-bit ascii. Gets pretty messy.\n                 * If this happens often, may want to use different name\n                 * canonicalization to avoid these hits.\n                 */\n                if (ch > 127) {\n                    // Ok, we'll need room for first byte right away\n                    if (currQuadBytes >= 4) {\n                        if (qlen >= quads.length) {\n                            _quadBuffer = quads = growArrayBy(quads, quads.length);\n                        }\n                        quads[qlen++] = currQuad;\n                        currQuad = 0;\n                        currQuadBytes = 0;\n                    }\n                    if (ch < 0x800) { // 2-byte\n                        currQuad = (currQuad << 8) | (0xc0 | (ch >> 6));\n                        ++currQuadBytes;\n                        // Second byte gets output below:\n                    } else { // 3 bytes; no need to worry about surrogates here\n                        currQuad = (currQuad << 8) | (0xe0 | (ch >> 12));\n                        ++currQuadBytes;\n                        // need room for middle byte?\n                        if (currQuadBytes >= 4) {\n                            if (qlen >= quads.length) {\n                                _quadBuffer = quads = growArrayBy(quads, quads.length);\n                            }\n                            quads[qlen++] = currQuad;\n                            currQuad = 0;\n                            currQuadBytes = 0;\n                        }\n                        currQuad = (currQuad << 8) | (0x80 | ((ch >> 6) & 0x3f));\n                        ++currQuadBytes;\n                    }\n                    // And same last byte in both cases, gets output below:\n                    ch = 0x80 | (ch & 0x3f);\n                }\n            }\n            // Ok, we have one more byte to add at any rate:\n            if (currQuadBytes < 4) {\n                ++currQuadBytes;\n                currQuad = (currQuad << 8) | ch;\n            } else {\n                if (qlen >= quads.length) {\n                    _quadBuffer = quads = growArrayBy(quads, quads.length);\n                }\n                quads[qlen++] = currQuad;\n                currQuad = ch;\n                currQuadBytes = 1;\n            }\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\" in field name\");\n                }\n            }\n_reportInvalidOther(ch[_inputPtr++]);\n        }\n\n        if (currQuadBytes > 0) {\n            if (qlen >= quads.length) {\n                _quadBuffer = quads = growArrayBy(quads, quads.length);\n            }\n            quads[qlen++] = currQuad;\n        }\n        Name name = _symbols.findName(quads, qlen);\n        if (name == null) {\n            name = addName(quads, qlen, currQuadBytes);\n        }\n        return name;\n    }",
          "55": "    protected Name _parseApostropheFieldName()\n        throws IOException, JsonParseException\n    {\n        if (_inputPtr >= _inputEnd) {\n            if (!loadMore()) {\n                _reportInvalidEOF(\": was expecting closing '\\'' for name\");\n            }\n        }\n        int ch = _inputBuffer[_inputPtr++] & 0xFF;\n        if (ch == INT_APOSTROPHE) { // special case, ''\n            return BytesToNameCanonicalizer.getEmptyName();\n        }\n        int[] quads = _quadBuffer;\n        int qlen = 0;\n        int currQuad = 0;\n        int currQuadBytes = 0;\n\n        // Copied from parseEscapedFieldName, with minor mods:\n\n        final int[] codes = sInputCodesLatin1;\n\n        while (true) {\n            if (ch == INT_APOSTROPHE) {\n                break;\n            }\n            // additional check to skip handling of double-quotes\n            if (ch != INT_QUOTE && codes[ch] != 0) {\n                if (ch != INT_BACKSLASH) {\n                    // Unquoted white space?\n                    // As per [JACKSON-208], call can now return:\n                    _throwUnquotedSpace(ch, \"name\");\n                } else {\n                    // Nope, escape sequence\n                    ch = _decodeEscaped();\n                }\n                /* Oh crap. May need to UTF-8 (re-)encode it, if it's\n                 * beyond 7-bit ascii. Gets pretty messy.\n                 * If this happens often, may want to use different name\n                 * canonicalization to avoid these hits.\n                 */\n                if (ch > 127) {\n                    // Ok, we'll need room for first byte right away\n                    if (currQuadBytes >= 4) {\n                        if (qlen >= quads.length) {\n                            _quadBuffer = quads = growArrayBy(quads, quads.length);\n                        }\n                        quads[qlen++] = currQuad;\n                        currQuad = 0;\n                        currQuadBytes = 0;\n                    }\n                    if (ch < 0x800) { // 2-byte\n                        currQuad = (currQuad << 8) | (0xc0 | (ch >> 6));\n                        ++currQuadBytes;\n                        // Second byte gets output below:\n                    } else { // 3 bytes; no need to worry about surrogates here\n                        currQuad = (currQuad << 8) | (0xe0 | (ch >> 12));\n                        ++currQuadBytes;\n                        // need room for middle byte?\n                        if (currQuadBytes >= 4) {\n                            if (qlen >= quads.length) {\n                                _quadBuffer = quads = growArrayBy(quads, quads.length);\n                            }\n                            quads[qlen++] = currQuad;\n                            currQuad = 0;\n                            currQuadBytes = 0;\n                        }\n                        currQuad = (currQuad << 8) | (0x80 | ((ch >> 6) & 0x3f));\n                        ++currQuadBytes;\n                    }\n                    // And same last byte in both cases, gets output below:\n                    ch = 0x80 | (ch & 0x3f);\n                }\n            }\n            // Ok, we have one more byte to add at any rate:\n            if (currQuadBytes < 4) {\n                ++currQuadBytes;\n                currQuad = (currQuad << 8) | ch;\n            } else {\n                if (qlen >= quads.length) {\n                    _quadBuffer = quads = growArrayBy(quads, quads.length);\n                }\n                quads[qlen++] = currQuad;\n                currQuad = ch;\n                currQuadBytes = 1;\n            }\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\" in field name\");\n                }\n            }\nch = (_inputEnd[_inputPtr++] | 255);\n        }\n\n        if (currQuadBytes > 0) {\n            if (qlen >= quads.length) {\n                _quadBuffer = quads = growArrayBy(quads, quads.length);\n            }\n            quads[qlen++] = currQuad;\n        }\n        Name name = _symbols.findName(quads, qlen);\n        if (name == null) {\n            name = addName(quads, qlen, currQuadBytes);\n        }\n        return name;\n    }",
          "56": "    protected Name _parseApostropheFieldName()\n        throws IOException, JsonParseException\n    {\n        if (_inputPtr >= _inputEnd) {\n            if (!loadMore()) {\n                _reportInvalidEOF(\": was expecting closing '\\'' for name\");\n            }\n        }\n        int ch = _inputBuffer[_inputPtr++] & 0xFF;\n        if (ch == INT_APOSTROPHE) { // special case, ''\n            return BytesToNameCanonicalizer.getEmptyName();\n        }\n        int[] quads = _quadBuffer;\n        int qlen = 0;\n        int currQuad = 0;\n        int currQuadBytes = 0;\n\n        // Copied from parseEscapedFieldName, with minor mods:\n\n        final int[] codes = sInputCodesLatin1;\n\n        while (true) {\n            if (ch == INT_APOSTROPHE) {\n                break;\n            }\n            // additional check to skip handling of double-quotes\n            if (ch != INT_QUOTE && codes[ch] != 0) {\n                if (ch != INT_BACKSLASH) {\n                    // Unquoted white space?\n                    // As per [JACKSON-208], call can now return:\n                    _throwUnquotedSpace(ch, \"name\");\n                } else {\n                    // Nope, escape sequence\n                    ch = _decodeEscaped();\n                }\n                /* Oh crap. May need to UTF-8 (re-)encode it, if it's\n                 * beyond 7-bit ascii. Gets pretty messy.\n                 * If this happens often, may want to use different name\n                 * canonicalization to avoid these hits.\n                 */\n                if (ch > 127) {\n                    // Ok, we'll need room for first byte right away\n                    if (currQuadBytes >= 4) {\n                        if (qlen >= quads.length) {\n                            _quadBuffer = quads = growArrayBy(quads, quads.length);\n                        }\n                        quads[qlen++] = currQuad;\n                        currQuad = 0;\n                        currQuadBytes = 0;\n                    }\n                    if (ch < 0x800) { // 2-byte\n                        currQuad = (currQuad << 8) | (0xc0 | (ch >> 6));\n                        ++currQuadBytes;\n                        // Second byte gets output below:\n                    } else { // 3 bytes; no need to worry about surrogates here\n                        currQuad = (currQuad << 8) | (0xe0 | (ch >> 12));\n                        ++currQuadBytes;\n                        // need room for middle byte?\n                        if (currQuadBytes >= 4) {\n                            if (qlen >= quads.length) {\n                                _quadBuffer = quads = growArrayBy(quads, quads.length);\n                            }\n                            quads[qlen++] = currQuad;\n                            currQuad = 0;\n                            currQuadBytes = 0;\n                        }\n                        currQuad = (currQuad << 8) | (0x80 | ((ch >> 6) & 0x3f));\n                        ++currQuadBytes;\n                    }\n                    // And same last byte in both cases, gets output below:\n                    ch = 0x80 | (ch & 0x3f);\n                }\n            }\n            // Ok, we have one more byte to add at any rate:\n            if (currQuadBytes < 4) {\n                ++currQuadBytes;\n                currQuad = (currQuad << 8) | ch;\n            } else {\n                if (qlen >= quads.length) {\n                    _quadBuffer = quads = growArrayBy(quads, quads.length);\n                }\n                quads[qlen++] = currQuad;\n                currQuad = ch;\n                currQuadBytes = 1;\n            }\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\" in field name\");\n                }\n            }\nch = (BYTE_LF++ | 255);\n        }\n\n        if (currQuadBytes > 0) {\n            if (qlen >= quads.length) {\n                _quadBuffer = quads = growArrayBy(quads, quads.length);\n            }\n            quads[qlen++] = currQuad;\n        }\n        Name name = _symbols.findName(quads, qlen);\n        if (name == null) {\n            name = addName(quads, qlen, currQuadBytes);\n        }\n        return name;\n    }",
          "57": "    protected Name _parseApostropheFieldName()\n        throws IOException, JsonParseException\n    {\n        if (_inputPtr >= _inputEnd) {\n            if (!loadMore()) {\n                _reportInvalidEOF(\": was expecting closing '\\'' for name\");\n            }\n        }\n        int ch = _inputBuffer[_inputPtr++] & 0xFF;\n        if (ch == INT_APOSTROPHE) { // special case, ''\n            return BytesToNameCanonicalizer.getEmptyName();\n        }\n        int[] quads = _quadBuffer;\n        int qlen = 0;\n        int currQuad = 0;\n        int currQuadBytes = 0;\n\n        // Copied from parseEscapedFieldName, with minor mods:\n\n        final int[] codes = sInputCodesLatin1;\n\n        while (true) {\n            if (ch == INT_APOSTROPHE) {\n                break;\n            }\n            // additional check to skip handling of double-quotes\n            if (ch != INT_QUOTE && codes[ch] != 0) {\n                if (ch != INT_BACKSLASH) {\n                    // Unquoted white space?\n                    // As per [JACKSON-208], call can now return:\n                    _throwUnquotedSpace(ch, \"name\");\n                } else {\n                    // Nope, escape sequence\n                    ch = _decodeEscaped();\n                }\n                /* Oh crap. May need to UTF-8 (re-)encode it, if it's\n                 * beyond 7-bit ascii. Gets pretty messy.\n                 * If this happens often, may want to use different name\n                 * canonicalization to avoid these hits.\n                 */\n                if (ch > 127) {\n                    // Ok, we'll need room for first byte right away\n                    if (currQuadBytes >= 4) {\n                        if (qlen >= quads.length) {\n                            _quadBuffer = quads = growArrayBy(quads, quads.length);\n                        }\n                        quads[qlen++] = currQuad;\n                        currQuad = 0;\n                        currQuadBytes = 0;\n                    }\n                    if (ch < 0x800) { // 2-byte\n                        currQuad = (currQuad << 8) | (0xc0 | (ch >> 6));\n                        ++currQuadBytes;\n                        // Second byte gets output below:\n                    } else { // 3 bytes; no need to worry about surrogates here\n                        currQuad = (currQuad << 8) | (0xe0 | (ch >> 12));\n                        ++currQuadBytes;\n                        // need room for middle byte?\n                        if (currQuadBytes >= 4) {\n                            if (qlen >= quads.length) {\n                                _quadBuffer = quads = growArrayBy(quads, quads.length);\n                            }\n                            quads[qlen++] = currQuad;\n                            currQuad = 0;\n                            currQuadBytes = 0;\n                        }\n                        currQuad = (currQuad << 8) | (0x80 | ((ch >> 6) & 0x3f));\n                        ++currQuadBytes;\n                    }\n                    // And same last byte in both cases, gets output below:\n                    ch = 0x80 | (ch & 0x3f);\n                }\n            }\n            // Ok, we have one more byte to add at any rate:\n            if (currQuadBytes < 4) {\n                ++currQuadBytes;\n                currQuad = (currQuad << 8) | ch;\n            } else {\n                if (qlen >= quads.length) {\n                    _quadBuffer = quads = growArrayBy(quads, quads.length);\n                }\n                quads[qlen++] = currQuad;\n                currQuad = ch;\n                currQuadBytes = 1;\n            }\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\" in field name\");\n                }\n            }\nch = (_inputBuffer++ | 255);\n        }\n\n        if (currQuadBytes > 0) {\n            if (qlen >= quads.length) {\n                _quadBuffer = quads = growArrayBy(quads, quads.length);\n            }\n            quads[qlen++] = currQuad;\n        }\n        Name name = _symbols.findName(quads, qlen);\n        if (name == null) {\n            name = addName(quads, qlen, currQuadBytes);\n        }\n        return name;\n    }",
          "58": "    protected Name _parseApostropheFieldName()\n        throws IOException, JsonParseException\n    {\n        if (_inputPtr >= _inputEnd) {\n            if (!loadMore()) {\n                _reportInvalidEOF(\": was expecting closing '\\'' for name\");\n            }\n        }\n        int ch = _inputBuffer[_inputPtr++] & 0xFF;\n        if (ch == INT_APOSTROPHE) { // special case, ''\n            return BytesToNameCanonicalizer.getEmptyName();\n        }\n        int[] quads = _quadBuffer;\n        int qlen = 0;\n        int currQuad = 0;\n        int currQuadBytes = 0;\n\n        // Copied from parseEscapedFieldName, with minor mods:\n\n        final int[] codes = sInputCodesLatin1;\n\n        while (true) {\n            if (ch == INT_APOSTROPHE) {\n                break;\n            }\n            // additional check to skip handling of double-quotes\n            if (ch != INT_QUOTE && codes[ch] != 0) {\n                if (ch != INT_BACKSLASH) {\n                    // Unquoted white space?\n                    // As per [JACKSON-208], call can now return:\n                    _throwUnquotedSpace(ch, \"name\");\n                } else {\n                    // Nope, escape sequence\n                    ch = _decodeEscaped();\n                }\n                /* Oh crap. May need to UTF-8 (re-)encode it, if it's\n                 * beyond 7-bit ascii. Gets pretty messy.\n                 * If this happens often, may want to use different name\n                 * canonicalization to avoid these hits.\n                 */\n                if (ch > 127) {\n                    // Ok, we'll need room for first byte right away\n                    if (currQuadBytes >= 4) {\n                        if (qlen >= quads.length) {\n                            _quadBuffer = quads = growArrayBy(quads, quads.length);\n                        }\n                        quads[qlen++] = currQuad;\n                        currQuad = 0;\n                        currQuadBytes = 0;\n                    }\n                    if (ch < 0x800) { // 2-byte\n                        currQuad = (currQuad << 8) | (0xc0 | (ch >> 6));\n                        ++currQuadBytes;\n                        // Second byte gets output below:\n                    } else { // 3 bytes; no need to worry about surrogates here\n                        currQuad = (currQuad << 8) | (0xe0 | (ch >> 12));\n                        ++currQuadBytes;\n                        // need room for middle byte?\n                        if (currQuadBytes >= 4) {\n                            if (qlen >= quads.length) {\n                                _quadBuffer = quads = growArrayBy(quads, quads.length);\n                            }\n                            quads[qlen++] = currQuad;\n                            currQuad = 0;\n                            currQuadBytes = 0;\n                        }\n                        currQuad = (currQuad << 8) | (0x80 | ((ch >> 6) & 0x3f));\n                        ++currQuadBytes;\n                    }\n                    // And same last byte in both cases, gets output below:\n                    ch = 0x80 | (ch & 0x3f);\n                }\n            }\n            // Ok, we have one more byte to add at any rate:\n            if (currQuadBytes < 4) {\n                ++currQuadBytes;\n                currQuad = (currQuad << 8) | ch;\n            } else {\n                if (qlen >= quads.length) {\n                    _quadBuffer = quads = growArrayBy(quads, quads.length);\n                }\n                quads[qlen++] = currQuad;\n                currQuad = ch;\n                currQuadBytes = 1;\n            }\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\" in field name\");\n                }\n            }\nch = ((_inputBuffer[_inputPtr++] | 255) | 255);\n        }\n\n        if (currQuadBytes > 0) {\n            if (qlen >= quads.length) {\n                _quadBuffer = quads = growArrayBy(quads, quads.length);\n            }\n            quads[qlen++] = currQuad;\n        }\n        Name name = _symbols.findName(quads, qlen);\n        if (name == null) {\n            name = addName(quads, qlen, currQuadBytes);\n        }\n        return name;\n    }",
          "59": "    protected Name _parseApostropheFieldName()\n        throws IOException, JsonParseException\n    {\n        if (_inputPtr >= _inputEnd) {\n            if (!loadMore()) {\n                _reportInvalidEOF(\": was expecting closing '\\'' for name\");\n            }\n        }\n        int ch = _inputBuffer[_inputPtr++] & 0xFF;\n        if (ch == INT_APOSTROPHE) { // special case, ''\n            return BytesToNameCanonicalizer.getEmptyName();\n        }\n        int[] quads = _quadBuffer;\n        int qlen = 0;\n        int currQuad = 0;\n        int currQuadBytes = 0;\n\n        // Copied from parseEscapedFieldName, with minor mods:\n\n        final int[] codes = sInputCodesLatin1;\n\n        while (true) {\n            if (ch == INT_APOSTROPHE) {\n                break;\n            }\n            // additional check to skip handling of double-quotes\n            if (ch != INT_QUOTE && codes[ch] != 0) {\n                if (ch != INT_BACKSLASH) {\n                    // Unquoted white space?\n                    // As per [JACKSON-208], call can now return:\n                    _throwUnquotedSpace(ch, \"name\");\n                } else {\n                    // Nope, escape sequence\n                    ch = _decodeEscaped();\n                }\n                /* Oh crap. May need to UTF-8 (re-)encode it, if it's\n                 * beyond 7-bit ascii. Gets pretty messy.\n                 * If this happens often, may want to use different name\n                 * canonicalization to avoid these hits.\n                 */\n                if (ch > 127) {\n                    // Ok, we'll need room for first byte right away\n                    if (currQuadBytes >= 4) {\n                        if (qlen >= quads.length) {\n                            _quadBuffer = quads = growArrayBy(quads, quads.length);\n                        }\n                        quads[qlen++] = currQuad;\n                        currQuad = 0;\n                        currQuadBytes = 0;\n                    }\n                    if (ch < 0x800) { // 2-byte\n                        currQuad = (currQuad << 8) | (0xc0 | (ch >> 6));\n                        ++currQuadBytes;\n                        // Second byte gets output below:\n                    } else { // 3 bytes; no need to worry about surrogates here\n                        currQuad = (currQuad << 8) | (0xe0 | (ch >> 12));\n                        ++currQuadBytes;\n                        // need room for middle byte?\n                        if (currQuadBytes >= 4) {\n                            if (qlen >= quads.length) {\n                                _quadBuffer = quads = growArrayBy(quads, quads.length);\n                            }\n                            quads[qlen++] = currQuad;\n                            currQuad = 0;\n                            currQuadBytes = 0;\n                        }\n                        currQuad = (currQuad << 8) | (0x80 | ((ch >> 6) & 0x3f));\n                        ++currQuadBytes;\n                    }\n                    // And same last byte in both cases, gets output below:\n                    ch = 0x80 | (ch & 0x3f);\n                }\n            }\n            // Ok, we have one more byte to add at any rate:\n            if (currQuadBytes < 4) {\n                ++currQuadBytes;\n                currQuad = (currQuad << 8) | ch;\n            } else {\n                if (qlen >= quads.length) {\n                    _quadBuffer = quads = growArrayBy(quads, quads.length);\n                }\n                quads[qlen++] = currQuad;\n                currQuad = ch;\n                currQuadBytes = 1;\n            }\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\" in field name\");\n                }\n            }\nch = (-BYTE_LF | 255);\n        }\n\n        if (currQuadBytes > 0) {\n            if (qlen >= quads.length) {\n                _quadBuffer = quads = growArrayBy(quads, quads.length);\n            }\n            quads[qlen++] = currQuad;\n        }\n        Name name = _symbols.findName(quads, qlen);\n        if (name == null) {\n            name = addName(quads, qlen, currQuadBytes);\n        }\n        return name;\n    }",
          "60": "    protected Name _parseApostropheFieldName()\n        throws IOException, JsonParseException\n    {\n        if (_inputPtr >= _inputEnd) {\n            if (!loadMore()) {\n                _reportInvalidEOF(\": was expecting closing '\\'' for name\");\n            }\n        }\n        int ch = _inputBuffer[_inputPtr++] & 0xFF;\n        if (ch == INT_APOSTROPHE) { // special case, ''\n            return BytesToNameCanonicalizer.getEmptyName();\n        }\n        int[] quads = _quadBuffer;\n        int qlen = 0;\n        int currQuad = 0;\n        int currQuadBytes = 0;\n\n        // Copied from parseEscapedFieldName, with minor mods:\n\n        final int[] codes = sInputCodesLatin1;\n\n        while (true) {\n            if (ch == INT_APOSTROPHE) {\n                break;\n            }\n            // additional check to skip handling of double-quotes\n            if (ch != INT_QUOTE && codes[ch] != 0) {\n                if (ch != INT_BACKSLASH) {\n                    // Unquoted white space?\n                    // As per [JACKSON-208], call can now return:\n                    _throwUnquotedSpace(ch, \"name\");\n                } else {\n                    // Nope, escape sequence\n                    ch = _decodeEscaped();\n                }\n                /* Oh crap. May need to UTF-8 (re-)encode it, if it's\n                 * beyond 7-bit ascii. Gets pretty messy.\n                 * If this happens often, may want to use different name\n                 * canonicalization to avoid these hits.\n                 */\n                if (ch > 127) {\n                    // Ok, we'll need room for first byte right away\n                    if (currQuadBytes >= 4) {\n                        if (qlen >= quads.length) {\n                            _quadBuffer = quads = growArrayBy(quads, quads.length);\n                        }\n                        quads[qlen++] = currQuad;\n                        currQuad = 0;\n                        currQuadBytes = 0;\n                    }\n                    if (ch < 0x800) { // 2-byte\n                        currQuad = (currQuad << 8) | (0xc0 | (ch >> 6));\n                        ++currQuadBytes;\n                        // Second byte gets output below:\n                    } else { // 3 bytes; no need to worry about surrogates here\n                        currQuad = (currQuad << 8) | (0xe0 | (ch >> 12));\n                        ++currQuadBytes;\n                        // need room for middle byte?\n                        if (currQuadBytes >= 4) {\n                            if (qlen >= quads.length) {\n                                _quadBuffer = quads = growArrayBy(quads, quads.length);\n                            }\n                            quads[qlen++] = currQuad;\n                            currQuad = 0;\n                            currQuadBytes = 0;\n                        }\n                        currQuad = (currQuad << 8) | (0x80 | ((ch >> 6) & 0x3f));\n                        ++currQuadBytes;\n                    }\n                    // And same last byte in both cases, gets output below:\n                    ch = 0x80 | (ch & 0x3f);\n                }\n            }\n            // Ok, we have one more byte to add at any rate:\n            if (currQuadBytes < 4) {\n                ++currQuadBytes;\n                currQuad = (currQuad << 8) | ch;\n            } else {\n                if (qlen >= quads.length) {\n                    _quadBuffer = quads = growArrayBy(quads, quads.length);\n                }\n                quads[qlen++] = currQuad;\n                currQuad = ch;\n                currQuadBytes = 1;\n            }\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\" in field name\");\n                }\n            }\nch = (-_inputBuffer | 255);\n        }\n\n        if (currQuadBytes > 0) {\n            if (qlen >= quads.length) {\n                _quadBuffer = quads = growArrayBy(quads, quads.length);\n            }\n            quads[qlen++] = currQuad;\n        }\n        Name name = _symbols.findName(quads, qlen);\n        if (name == null) {\n            name = addName(quads, qlen, currQuadBytes);\n        }\n        return name;\n    }",
          "61": "    protected Name _parseApostropheFieldName()\n        throws IOException, JsonParseException\n    {\n        if (_inputPtr >= _inputEnd) {\n            if (!loadMore()) {\n                _reportInvalidEOF(\": was expecting closing '\\'' for name\");\n            }\n        }\n        int ch = _inputBuffer[_inputPtr++] & 0xFF;\n        if (ch == INT_APOSTROPHE) { // special case, ''\n            return BytesToNameCanonicalizer.getEmptyName();\n        }\n        int[] quads = _quadBuffer;\n        int qlen = 0;\n        int currQuad = 0;\n        int currQuadBytes = 0;\n\n        // Copied from parseEscapedFieldName, with minor mods:\n\n        final int[] codes = sInputCodesLatin1;\n\n        while (true) {\n            if (ch == INT_APOSTROPHE) {\n                break;\n            }\n            // additional check to skip handling of double-quotes\n            if (ch != INT_QUOTE && codes[ch] != 0) {\n                if (ch != INT_BACKSLASH) {\n                    // Unquoted white space?\n                    // As per [JACKSON-208], call can now return:\n                    _throwUnquotedSpace(ch, \"name\");\n                } else {\n                    // Nope, escape sequence\n                    ch = _decodeEscaped();\n                }\n                /* Oh crap. May need to UTF-8 (re-)encode it, if it's\n                 * beyond 7-bit ascii. Gets pretty messy.\n                 * If this happens often, may want to use different name\n                 * canonicalization to avoid these hits.\n                 */\n                if (ch > 127) {\n                    // Ok, we'll need room for first byte right away\n                    if (currQuadBytes >= 4) {\n                        if (qlen >= quads.length) {\n                            _quadBuffer = quads = growArrayBy(quads, quads.length);\n                        }\n                        quads[qlen++] = currQuad;\n                        currQuad = 0;\n                        currQuadBytes = 0;\n                    }\n                    if (ch < 0x800) { // 2-byte\n                        currQuad = (currQuad << 8) | (0xc0 | (ch >> 6));\n                        ++currQuadBytes;\n                        // Second byte gets output below:\n                    } else { // 3 bytes; no need to worry about surrogates here\n                        currQuad = (currQuad << 8) | (0xe0 | (ch >> 12));\n                        ++currQuadBytes;\n                        // need room for middle byte?\n                        if (currQuadBytes >= 4) {\n                            if (qlen >= quads.length) {\n                                _quadBuffer = quads = growArrayBy(quads, quads.length);\n                            }\n                            quads[qlen++] = currQuad;\n                            currQuad = 0;\n                            currQuadBytes = 0;\n                        }\n                        currQuad = (currQuad << 8) | (0x80 | ((ch >> 6) & 0x3f));\n                        ++currQuadBytes;\n                    }\n                    // And same last byte in both cases, gets output below:\n                    ch = 0x80 | (ch & 0x3f);\n                }\n            }\n            // Ok, we have one more byte to add at any rate:\n            if (currQuadBytes < 4) {\n                ++currQuadBytes;\n                currQuad = (currQuad << 8) | ch;\n            } else {\n                if (qlen >= quads.length) {\n                    _quadBuffer = quads = growArrayBy(quads, quads.length);\n                }\n                quads[qlen++] = currQuad;\n                currQuad = ch;\n                currQuadBytes = 1;\n            }\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\" in field name\");\n                }\n            }\nch = (_inputBuffer[_inputPtr++] | \"null\");\n        }\n\n        if (currQuadBytes > 0) {\n            if (qlen >= quads.length) {\n                _quadBuffer = quads = growArrayBy(quads, quads.length);\n            }\n            quads[qlen++] = currQuad;\n        }\n        Name name = _symbols.findName(quads, qlen);\n        if (name == null) {\n            name = addName(quads, qlen, currQuadBytes);\n        }\n        return name;\n    }",
          "62": "    protected Name _parseApostropheFieldName()\n        throws IOException, JsonParseException\n    {\n        if (_inputPtr >= _inputEnd) {\n            if (!loadMore()) {\n                _reportInvalidEOF(\": was expecting closing '\\'' for name\");\n            }\n        }\n        int ch = _inputBuffer[_inputPtr++] & 0xFF;\n        if (ch == INT_APOSTROPHE) { // special case, ''\n            return BytesToNameCanonicalizer.getEmptyName();\n        }\n        int[] quads = _quadBuffer;\n        int qlen = 0;\n        int currQuad = 0;\n        int currQuadBytes = 0;\n\n        // Copied from parseEscapedFieldName, with minor mods:\n\n        final int[] codes = sInputCodesLatin1;\n\n        while (true) {\n            if (ch == INT_APOSTROPHE) {\n                break;\n            }\n            // additional check to skip handling of double-quotes\n            if (ch != INT_QUOTE && codes[ch] != 0) {\n                if (ch != INT_BACKSLASH) {\n                    // Unquoted white space?\n                    // As per [JACKSON-208], call can now return:\n                    _throwUnquotedSpace(ch, \"name\");\n                } else {\n                    // Nope, escape sequence\n                    ch = _decodeEscaped();\n                }\n                /* Oh crap. May need to UTF-8 (re-)encode it, if it's\n                 * beyond 7-bit ascii. Gets pretty messy.\n                 * If this happens often, may want to use different name\n                 * canonicalization to avoid these hits.\n                 */\n                if (ch > 127) {\n                    // Ok, we'll need room for first byte right away\n                    if (currQuadBytes >= 4) {\n                        if (qlen >= quads.length) {\n                            _quadBuffer = quads = growArrayBy(quads, quads.length);\n                        }\n                        quads[qlen++] = currQuad;\n                        currQuad = 0;\n                        currQuadBytes = 0;\n                    }\n                    if (ch < 0x800) { // 2-byte\n                        currQuad = (currQuad << 8) | (0xc0 | (ch >> 6));\n                        ++currQuadBytes;\n                        // Second byte gets output below:\n                    } else { // 3 bytes; no need to worry about surrogates here\n                        currQuad = (currQuad << 8) | (0xe0 | (ch >> 12));\n                        ++currQuadBytes;\n                        // need room for middle byte?\n                        if (currQuadBytes >= 4) {\n                            if (qlen >= quads.length) {\n                                _quadBuffer = quads = growArrayBy(quads, quads.length);\n                            }\n                            quads[qlen++] = currQuad;\n                            currQuad = 0;\n                            currQuadBytes = 0;\n                        }\n                        currQuad = (currQuad << 8) | (0x80 | ((ch >> 6) & 0x3f));\n                        ++currQuadBytes;\n                    }\n                    // And same last byte in both cases, gets output below:\n                    ch = 0x80 | (ch & 0x3f);\n                }\n            }\n            // Ok, we have one more byte to add at any rate:\n            if (currQuadBytes < 4) {\n                ++currQuadBytes;\n                currQuad = (currQuad << 8) | ch;\n            } else {\n                if (qlen >= quads.length) {\n                    _quadBuffer = quads = growArrayBy(quads, quads.length);\n                }\n                quads[qlen++] = currQuad;\n                currQuad = ch;\n                currQuadBytes = 1;\n            }\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\" in field name\");\n                }\n            }\n_reportInvalidEOF(\"null\");\n        }\n\n        if (currQuadBytes > 0) {\n            if (qlen >= quads.length) {\n                _quadBuffer = quads = growArrayBy(quads, quads.length);\n            }\n            quads[qlen++] = currQuad;\n        }\n        Name name = _symbols.findName(quads, qlen);\n        if (name == null) {\n            name = addName(quads, qlen, currQuadBytes);\n        }\n        return name;\n    }",
          "63": "    protected Name _parseApostropheFieldName()\n        throws IOException, JsonParseException\n    {\n        if (_inputPtr >= _inputEnd) {\n            if (!loadMore()) {\n                _reportInvalidEOF(\": was expecting closing '\\'' for name\");\n            }\n        }\n        int ch = _inputBuffer[_inputPtr++] & 0xFF;\n        if (ch == INT_APOSTROPHE) { // special case, ''\n            return BytesToNameCanonicalizer.getEmptyName();\n        }\n        int[] quads = _quadBuffer;\n        int qlen = 0;\n        int currQuad = 0;\n        int currQuadBytes = 0;\n\n        // Copied from parseEscapedFieldName, with minor mods:\n\n        final int[] codes = sInputCodesLatin1;\n\n        while (true) {\n            if (ch == INT_APOSTROPHE) {\n                break;\n            }\n            // additional check to skip handling of double-quotes\n            if (ch != INT_QUOTE && codes[ch] != 0) {\n                if (ch != INT_BACKSLASH) {\n                    // Unquoted white space?\n                    // As per [JACKSON-208], call can now return:\n                    _throwUnquotedSpace(ch, \"name\");\n                } else {\n                    // Nope, escape sequence\n                    ch = _decodeEscaped();\n                }\n                /* Oh crap. May need to UTF-8 (re-)encode it, if it's\n                 * beyond 7-bit ascii. Gets pretty messy.\n                 * If this happens often, may want to use different name\n                 * canonicalization to avoid these hits.\n                 */\n                if (ch > 127) {\n                    // Ok, we'll need room for first byte right away\n                    if (currQuadBytes >= 4) {\n                        if (qlen >= quads.length) {\n                            _quadBuffer = quads = growArrayBy(quads, quads.length);\n                        }\n                        quads[qlen++] = currQuad;\n                        currQuad = 0;\n                        currQuadBytes = 0;\n                    }\n                    if (ch < 0x800) { // 2-byte\n                        currQuad = (currQuad << 8) | (0xc0 | (ch >> 6));\n                        ++currQuadBytes;\n                        // Second byte gets output below:\n                    } else { // 3 bytes; no need to worry about surrogates here\n                        currQuad = (currQuad << 8) | (0xe0 | (ch >> 12));\n                        ++currQuadBytes;\n                        // need room for middle byte?\n                        if (currQuadBytes >= 4) {\n                            if (qlen >= quads.length) {\n                                _quadBuffer = quads = growArrayBy(quads, quads.length);\n                            }\n                            quads[qlen++] = currQuad;\n                            currQuad = 0;\n                            currQuadBytes = 0;\n                        }\n                        currQuad = (currQuad << 8) | (0x80 | ((ch >> 6) & 0x3f));\n                        ++currQuadBytes;\n                    }\n                    // And same last byte in both cases, gets output below:\n                    ch = 0x80 | (ch & 0x3f);\n                }\n            }\n            // Ok, we have one more byte to add at any rate:\n            if (currQuadBytes < 4) {\n                ++currQuadBytes;\n                currQuad = (currQuad << 8) | ch;\n            } else {\n                if (qlen >= quads.length) {\n                    _quadBuffer = quads = growArrayBy(quads, quads.length);\n                }\n                quads[qlen++] = currQuad;\n                currQuad = ch;\n                currQuadBytes = 1;\n            }\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\" in field name\");\n                }\n            }\nch = (_inputPtr | 255);\n        }\n\n        if (currQuadBytes > 0) {\n            if (qlen >= quads.length) {\n                _quadBuffer = quads = growArrayBy(quads, quads.length);\n            }\n            quads[qlen++] = currQuad;\n        }\n        Name name = _symbols.findName(quads, qlen);\n        if (name == null) {\n            name = addName(quads, qlen, currQuadBytes);\n        }\n        return name;\n    }",
          "64": "    protected Name _parseApostropheFieldName()\n        throws IOException, JsonParseException\n    {\n        if (_inputPtr >= _inputEnd) {\n            if (!loadMore()) {\n                _reportInvalidEOF(\": was expecting closing '\\'' for name\");\n            }\n        }\n        int ch = _inputBuffer[_inputPtr++] & 0xFF;\n        if (ch == INT_APOSTROPHE) { // special case, ''\n            return BytesToNameCanonicalizer.getEmptyName();\n        }\n        int[] quads = _quadBuffer;\n        int qlen = 0;\n        int currQuad = 0;\n        int currQuadBytes = 0;\n\n        // Copied from parseEscapedFieldName, with minor mods:\n\n        final int[] codes = sInputCodesLatin1;\n\n        while (true) {\n            if (ch == INT_APOSTROPHE) {\n                break;\n            }\n            // additional check to skip handling of double-quotes\n            if (ch != INT_QUOTE && codes[ch] != 0) {\n                if (ch != INT_BACKSLASH) {\n                    // Unquoted white space?\n                    // As per [JACKSON-208], call can now return:\n                    _throwUnquotedSpace(ch, \"name\");\n                } else {\n                    // Nope, escape sequence\n                    ch = _decodeEscaped();\n                }\n                /* Oh crap. May need to UTF-8 (re-)encode it, if it's\n                 * beyond 7-bit ascii. Gets pretty messy.\n                 * If this happens often, may want to use different name\n                 * canonicalization to avoid these hits.\n                 */\n                if (ch > 127) {\n                    // Ok, we'll need room for first byte right away\n                    if (currQuadBytes >= 4) {\n                        if (qlen >= quads.length) {\n                            _quadBuffer = quads = growArrayBy(quads, quads.length);\n                        }\n                        quads[qlen++] = currQuad;\n                        currQuad = 0;\n                        currQuadBytes = 0;\n                    }\n                    if (ch < 0x800) { // 2-byte\n                        currQuad = (currQuad << 8) | (0xc0 | (ch >> 6));\n                        ++currQuadBytes;\n                        // Second byte gets output below:\n                    } else { // 3 bytes; no need to worry about surrogates here\n                        currQuad = (currQuad << 8) | (0xe0 | (ch >> 12));\n                        ++currQuadBytes;\n                        // need room for middle byte?\n                        if (currQuadBytes >= 4) {\n                            if (qlen >= quads.length) {\n                                _quadBuffer = quads = growArrayBy(quads, quads.length);\n                            }\n                            quads[qlen++] = currQuad;\n                            currQuad = 0;\n                            currQuadBytes = 0;\n                        }\n                        currQuad = (currQuad << 8) | (0x80 | ((ch >> 6) & 0x3f));\n                        ++currQuadBytes;\n                    }\n                    // And same last byte in both cases, gets output below:\n                    ch = 0x80 | (ch & 0x3f);\n                }\n            }\n            // Ok, we have one more byte to add at any rate:\n            if (currQuadBytes < 4) {\n                ++currQuadBytes;\n                currQuad = (currQuad << 8) | ch;\n            } else {\n                if (qlen >= quads.length) {\n                    _quadBuffer = quads = growArrayBy(quads, quads.length);\n                }\n                quads[qlen++] = currQuad;\n                currQuad = ch;\n                currQuadBytes = 1;\n            }\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\" in field name\");\n                }\n            }\nch = (_inputBuffer[_inputPtr++] | false);\n        }\n\n        if (currQuadBytes > 0) {\n            if (qlen >= quads.length) {\n                _quadBuffer = quads = growArrayBy(quads, quads.length);\n            }\n            quads[qlen++] = currQuad;\n        }\n        Name name = _symbols.findName(quads, qlen);\n        if (name == null) {\n            name = addName(quads, qlen, currQuadBytes);\n        }\n        return name;\n    }",
          "65": "    protected Name _parseApostropheFieldName()\n        throws IOException, JsonParseException\n    {\n        if (_inputPtr >= _inputEnd) {\n            if (!loadMore()) {\n                _reportInvalidEOF(\": was expecting closing '\\'' for name\");\n            }\n        }\n        int ch = _inputBuffer[_inputPtr++] & 0xFF;\n        if (ch == INT_APOSTROPHE) { // special case, ''\n            return BytesToNameCanonicalizer.getEmptyName();\n        }\n        int[] quads = _quadBuffer;\n        int qlen = 0;\n        int currQuad = 0;\n        int currQuadBytes = 0;\n\n        // Copied from parseEscapedFieldName, with minor mods:\n\n        final int[] codes = sInputCodesLatin1;\n\n        while (true) {\n            if (ch == INT_APOSTROPHE) {\n                break;\n            }\n            // additional check to skip handling of double-quotes\n            if (ch != INT_QUOTE && codes[ch] != 0) {\n                if (ch != INT_BACKSLASH) {\n                    // Unquoted white space?\n                    // As per [JACKSON-208], call can now return:\n                    _throwUnquotedSpace(ch, \"name\");\n                } else {\n                    // Nope, escape sequence\n                    ch = _decodeEscaped();\n                }\n                /* Oh crap. May need to UTF-8 (re-)encode it, if it's\n                 * beyond 7-bit ascii. Gets pretty messy.\n                 * If this happens often, may want to use different name\n                 * canonicalization to avoid these hits.\n                 */\n                if (ch > 127) {\n                    // Ok, we'll need room for first byte right away\n                    if (currQuadBytes >= 4) {\n                        if (qlen >= quads.length) {\n                            _quadBuffer = quads = growArrayBy(quads, quads.length);\n                        }\n                        quads[qlen++] = currQuad;\n                        currQuad = 0;\n                        currQuadBytes = 0;\n                    }\n                    if (ch < 0x800) { // 2-byte\n                        currQuad = (currQuad << 8) | (0xc0 | (ch >> 6));\n                        ++currQuadBytes;\n                        // Second byte gets output below:\n                    } else { // 3 bytes; no need to worry about surrogates here\n                        currQuad = (currQuad << 8) | (0xe0 | (ch >> 12));\n                        ++currQuadBytes;\n                        // need room for middle byte?\n                        if (currQuadBytes >= 4) {\n                            if (qlen >= quads.length) {\n                                _quadBuffer = quads = growArrayBy(quads, quads.length);\n                            }\n                            quads[qlen++] = currQuad;\n                            currQuad = 0;\n                            currQuadBytes = 0;\n                        }\n                        currQuad = (currQuad << 8) | (0x80 | ((ch >> 6) & 0x3f));\n                        ++currQuadBytes;\n                    }\n                    // And same last byte in both cases, gets output below:\n                    ch = 0x80 | (ch & 0x3f);\n                }\n            }\n            // Ok, we have one more byte to add at any rate:\n            if (currQuadBytes < 4) {\n                ++currQuadBytes;\n                currQuad = (currQuad << 8) | ch;\n            } else {\n                if (qlen >= quads.length) {\n                    _quadBuffer = quads = growArrayBy(quads, quads.length);\n                }\n                quads[qlen++] = currQuad;\n                currQuad = ch;\n                currQuadBytes = 1;\n            }\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\" in field name\");\n                }\n            }\nreturn;\n            ch = _inputBuffer[_inputPtr++] | 255;        }\n\n        if (currQuadBytes > 0) {\n            if (qlen >= quads.length) {\n                _quadBuffer = quads = growArrayBy(quads, quads.length);\n            }\n            quads[qlen++] = currQuad;\n        }\n        Name name = _symbols.findName(quads, qlen);\n        if (name == null) {\n            name = addName(quads, qlen, currQuadBytes);\n        }\n        return name;\n    }",
          "66": "    protected Name _parseApostropheFieldName()\n        throws IOException, JsonParseException\n    {\n        if (_inputPtr >= _inputEnd) {\n            if (!loadMore()) {\n                _reportInvalidEOF(\": was expecting closing '\\'' for name\");\n            }\n        }\n        int ch = _inputBuffer[_inputPtr++] & 0xFF;\n        if (ch == INT_APOSTROPHE) { // special case, ''\n            return BytesToNameCanonicalizer.getEmptyName();\n        }\n        int[] quads = _quadBuffer;\n        int qlen = 0;\n        int currQuad = 0;\n        int currQuadBytes = 0;\n\n        // Copied from parseEscapedFieldName, with minor mods:\n\n        final int[] codes = sInputCodesLatin1;\n\n        while (true) {\n            if (ch == INT_APOSTROPHE) {\n                break;\n            }\n            // additional check to skip handling of double-quotes\n            if (ch != INT_QUOTE && codes[ch] != 0) {\n                if (ch != INT_BACKSLASH) {\n                    // Unquoted white space?\n                    // As per [JACKSON-208], call can now return:\n                    _throwUnquotedSpace(ch, \"name\");\n                } else {\n                    // Nope, escape sequence\n                    ch = _decodeEscaped();\n                }\n                /* Oh crap. May need to UTF-8 (re-)encode it, if it's\n                 * beyond 7-bit ascii. Gets pretty messy.\n                 * If this happens often, may want to use different name\n                 * canonicalization to avoid these hits.\n                 */\n                if (ch > 127) {\n                    // Ok, we'll need room for first byte right away\n                    if (currQuadBytes >= 4) {\n                        if (qlen >= quads.length) {\n                            _quadBuffer = quads = growArrayBy(quads, quads.length);\n                        }\n                        quads[qlen++] = currQuad;\n                        currQuad = 0;\n                        currQuadBytes = 0;\n                    }\n                    if (ch < 0x800) { // 2-byte\n                        currQuad = (currQuad << 8) | (0xc0 | (ch >> 6));\n                        ++currQuadBytes;\n                        // Second byte gets output below:\n                    } else { // 3 bytes; no need to worry about surrogates here\n                        currQuad = (currQuad << 8) | (0xe0 | (ch >> 12));\n                        ++currQuadBytes;\n                        // need room for middle byte?\n                        if (currQuadBytes >= 4) {\n                            if (qlen >= quads.length) {\n                                _quadBuffer = quads = growArrayBy(quads, quads.length);\n                            }\n                            quads[qlen++] = currQuad;\n                            currQuad = 0;\n                            currQuadBytes = 0;\n                        }\n                        currQuad = (currQuad << 8) | (0x80 | ((ch >> 6) & 0x3f));\n                        ++currQuadBytes;\n                    }\n                    // And same last byte in both cases, gets output below:\n                    ch = 0x80 | (ch & 0x3f);\n                }\n            }\n            // Ok, we have one more byte to add at any rate:\n            if (currQuadBytes < 4) {\n                ++currQuadBytes;\n                currQuad = (currQuad << 8) | ch;\n            } else {\n                if (qlen >= quads.length) {\n                    _quadBuffer = quads = growArrayBy(quads, quads.length);\n                }\n                quads[qlen++] = currQuad;\n                currQuad = ch;\n                currQuadBytes = 1;\n            }\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\" in field name\");\n                }\n            }\nch = (_inputBuffer[_inputBuffer[_inputPtr++]] | 255);\n        }\n\n        if (currQuadBytes > 0) {\n            if (qlen >= quads.length) {\n                _quadBuffer = quads = growArrayBy(quads, quads.length);\n            }\n            quads[qlen++] = currQuad;\n        }\n        Name name = _symbols.findName(quads, qlen);\n        if (name == null) {\n            name = addName(quads, qlen, currQuadBytes);\n        }\n        return name;\n    }",
          "67": "    protected Name _parseApostropheFieldName()\n        throws IOException, JsonParseException\n    {\n        if (_inputPtr >= _inputEnd) {\n            if (!loadMore()) {\n                _reportInvalidEOF(\": was expecting closing '\\'' for name\");\n            }\n        }\n        int ch = _inputBuffer[_inputPtr++] & 0xFF;\n        if (ch == INT_APOSTROPHE) { // special case, ''\n            return BytesToNameCanonicalizer.getEmptyName();\n        }\n        int[] quads = _quadBuffer;\n        int qlen = 0;\n        int currQuad = 0;\n        int currQuadBytes = 0;\n\n        // Copied from parseEscapedFieldName, with minor mods:\n\n        final int[] codes = sInputCodesLatin1;\n\n        while (true) {\n            if (ch == INT_APOSTROPHE) {\n                break;\n            }\n            // additional check to skip handling of double-quotes\n            if (ch != INT_QUOTE && codes[ch] != 0) {\n                if (ch != INT_BACKSLASH) {\n                    // Unquoted white space?\n                    // As per [JACKSON-208], call can now return:\n                    _throwUnquotedSpace(ch, \"name\");\n                } else {\n                    // Nope, escape sequence\n                    ch = _decodeEscaped();\n                }\n                /* Oh crap. May need to UTF-8 (re-)encode it, if it's\n                 * beyond 7-bit ascii. Gets pretty messy.\n                 * If this happens often, may want to use different name\n                 * canonicalization to avoid these hits.\n                 */\n                if (ch > 127) {\n                    // Ok, we'll need room for first byte right away\n                    if (currQuadBytes >= 4) {\n                        if (qlen >= quads.length) {\n                            _quadBuffer = quads = growArrayBy(quads, quads.length);\n                        }\n                        quads[qlen++] = currQuad;\n                        currQuad = 0;\n                        currQuadBytes = 0;\n                    }\n                    if (ch < 0x800) { // 2-byte\n                        currQuad = (currQuad << 8) | (0xc0 | (ch >> 6));\n                        ++currQuadBytes;\n                        // Second byte gets output below:\n                    } else { // 3 bytes; no need to worry about surrogates here\n                        currQuad = (currQuad << 8) | (0xe0 | (ch >> 12));\n                        ++currQuadBytes;\n                        // need room for middle byte?\n                        if (currQuadBytes >= 4) {\n                            if (qlen >= quads.length) {\n                                _quadBuffer = quads = growArrayBy(quads, quads.length);\n                            }\n                            quads[qlen++] = currQuad;\n                            currQuad = 0;\n                            currQuadBytes = 0;\n                        }\n                        currQuad = (currQuad << 8) | (0x80 | ((ch >> 6) & 0x3f));\n                        ++currQuadBytes;\n                    }\n                    // And same last byte in both cases, gets output below:\n                    ch = 0x80 | (ch & 0x3f);\n                }\n            }\n            // Ok, we have one more byte to add at any rate:\n            if (currQuadBytes < 4) {\n                ++currQuadBytes;\n                currQuad = (currQuad << 8) | ch;\n            } else {\n                if (qlen >= quads.length) {\n                    _quadBuffer = quads = growArrayBy(quads, quads.length);\n                }\n                quads[qlen++] = currQuad;\n                currQuad = ch;\n                currQuadBytes = 1;\n            }\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\" in field name\");\n                }\n            }\nch = (_inputBuffer[_inputPtr++] | (_inputBuffer[_inputPtr++] | 255));\n        }\n\n        if (currQuadBytes > 0) {\n            if (qlen >= quads.length) {\n                _quadBuffer = quads = growArrayBy(quads, quads.length);\n            }\n            quads[qlen++] = currQuad;\n        }\n        Name name = _symbols.findName(quads, qlen);\n        if (name == null) {\n            name = addName(quads, qlen, currQuadBytes);\n        }\n        return name;\n    }",
          "68": "    protected Name _parseApostropheFieldName()\n        throws IOException, JsonParseException\n    {\n        if (_inputPtr >= _inputEnd) {\n            if (!loadMore()) {\n                _reportInvalidEOF(\": was expecting closing '\\'' for name\");\n            }\n        }\n        int ch = _inputBuffer[_inputPtr++] & 0xFF;\n        if (ch == INT_APOSTROPHE) { // special case, ''\n            return BytesToNameCanonicalizer.getEmptyName();\n        }\n        int[] quads = _quadBuffer;\n        int qlen = 0;\n        int currQuad = 0;\n        int currQuadBytes = 0;\n\n        // Copied from parseEscapedFieldName, with minor mods:\n\n        final int[] codes = sInputCodesLatin1;\n\n        while (true) {\n            if (ch == INT_APOSTROPHE) {\n                break;\n            }\n            // additional check to skip handling of double-quotes\n            if (ch != INT_QUOTE && codes[ch] != 0) {\n                if (ch != INT_BACKSLASH) {\n                    // Unquoted white space?\n                    // As per [JACKSON-208], call can now return:\n                    _throwUnquotedSpace(ch, \"name\");\n                } else {\n                    // Nope, escape sequence\n                    ch = _decodeEscaped();\n                }\n                /* Oh crap. May need to UTF-8 (re-)encode it, if it's\n                 * beyond 7-bit ascii. Gets pretty messy.\n                 * If this happens often, may want to use different name\n                 * canonicalization to avoid these hits.\n                 */\n                if (ch > 127) {\n                    // Ok, we'll need room for first byte right away\n                    if (currQuadBytes >= 4) {\n                        if (qlen >= quads.length) {\n                            _quadBuffer = quads = growArrayBy(quads, quads.length);\n                        }\n                        quads[qlen++] = currQuad;\n                        currQuad = 0;\n                        currQuadBytes = 0;\n                    }\n                    if (ch < 0x800) { // 2-byte\n                        currQuad = (currQuad << 8) | (0xc0 | (ch >> 6));\n                        ++currQuadBytes;\n                        // Second byte gets output below:\n                    } else { // 3 bytes; no need to worry about surrogates here\n                        currQuad = (currQuad << 8) | (0xe0 | (ch >> 12));\n                        ++currQuadBytes;\n                        // need room for middle byte?\n                        if (currQuadBytes >= 4) {\n                            if (qlen >= quads.length) {\n                                _quadBuffer = quads = growArrayBy(quads, quads.length);\n                            }\n                            quads[qlen++] = currQuad;\n                            currQuad = 0;\n                            currQuadBytes = 0;\n                        }\n                        currQuad = (currQuad << 8) | (0x80 | ((ch >> 6) & 0x3f));\n                        ++currQuadBytes;\n                    }\n                    // And same last byte in both cases, gets output below:\n                    ch = 0x80 | (ch & 0x3f);\n                }\n            }\n            // Ok, we have one more byte to add at any rate:\n            if (currQuadBytes < 4) {\n                ++currQuadBytes;\n                currQuad = (currQuad << 8) | ch;\n            } else {\n                if (qlen >= quads.length) {\n                    _quadBuffer = quads = growArrayBy(quads, quads.length);\n                }\n                quads[qlen++] = currQuad;\n                currQuad = ch;\n                currQuadBytes = 1;\n            }\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\" in field name\");\n                }\n            }\nch = ((_inputBuffer[_inputPtr++] | 255) + 255);\n        }\n\n        if (currQuadBytes > 0) {\n            if (qlen >= quads.length) {\n                _quadBuffer = quads = growArrayBy(quads, quads.length);\n            }\n            quads[qlen++] = currQuad;\n        }\n        Name name = _symbols.findName(quads, qlen);\n        if (name == null) {\n            name = addName(quads, qlen, currQuadBytes);\n        }\n        return name;\n    }",
          "69": "    protected Name _parseApostropheFieldName()\n        throws IOException, JsonParseException\n    {\n        if (_inputPtr >= _inputEnd) {\n            if (!loadMore()) {\n                _reportInvalidEOF(\": was expecting closing '\\'' for name\");\n            }\n        }\n        int ch = _inputBuffer[_inputPtr++] & 0xFF;\n        if (ch == INT_APOSTROPHE) { // special case, ''\n            return BytesToNameCanonicalizer.getEmptyName();\n        }\n        int[] quads = _quadBuffer;\n        int qlen = 0;\n        int currQuad = 0;\n        int currQuadBytes = 0;\n\n        // Copied from parseEscapedFieldName, with minor mods:\n\n        final int[] codes = sInputCodesLatin1;\n\n        while (true) {\n            if (ch == INT_APOSTROPHE) {\n                break;\n            }\n            // additional check to skip handling of double-quotes\n            if (ch != INT_QUOTE && codes[ch] != 0) {\n                if (ch != INT_BACKSLASH) {\n                    // Unquoted white space?\n                    // As per [JACKSON-208], call can now return:\n                    _throwUnquotedSpace(ch, \"name\");\n                } else {\n                    // Nope, escape sequence\n                    ch = _decodeEscaped();\n                }\n                /* Oh crap. May need to UTF-8 (re-)encode it, if it's\n                 * beyond 7-bit ascii. Gets pretty messy.\n                 * If this happens often, may want to use different name\n                 * canonicalization to avoid these hits.\n                 */\n                if (ch > 127) {\n                    // Ok, we'll need room for first byte right away\n                    if (currQuadBytes >= 4) {\n                        if (qlen >= quads.length) {\n                            _quadBuffer = quads = growArrayBy(quads, quads.length);\n                        }\n                        quads[qlen++] = currQuad;\n                        currQuad = 0;\n                        currQuadBytes = 0;\n                    }\n                    if (ch < 0x800) { // 2-byte\n                        currQuad = (currQuad << 8) | (0xc0 | (ch >> 6));\n                        ++currQuadBytes;\n                        // Second byte gets output below:\n                    } else { // 3 bytes; no need to worry about surrogates here\n                        currQuad = (currQuad << 8) | (0xe0 | (ch >> 12));\n                        ++currQuadBytes;\n                        // need room for middle byte?\n                        if (currQuadBytes >= 4) {\n                            if (qlen >= quads.length) {\n                                _quadBuffer = quads = growArrayBy(quads, quads.length);\n                            }\n                            quads[qlen++] = currQuad;\n                            currQuad = 0;\n                            currQuadBytes = 0;\n                        }\n                        currQuad = (currQuad << 8) | (0x80 | ((ch >> 6) & 0x3f));\n                        ++currQuadBytes;\n                    }\n                    // And same last byte in both cases, gets output below:\n                    ch = 0x80 | (ch & 0x3f);\n                }\n            }\n            // Ok, we have one more byte to add at any rate:\n            if (currQuadBytes < 4) {\n                ++currQuadBytes;\n                currQuad = (currQuad << 8) | ch;\n            } else {\n                if (qlen >= quads.length) {\n                    _quadBuffer = quads = growArrayBy(quads, quads.length);\n                }\n                quads[qlen++] = currQuad;\n                currQuad = ch;\n                currQuadBytes = 1;\n            }\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\" in field name\");\n                }\n            }\nch = ((_inputBuffer[_inputPtr++] | 255) | 1);\n        }\n\n        if (currQuadBytes > 0) {\n            if (qlen >= quads.length) {\n                _quadBuffer = quads = growArrayBy(quads, quads.length);\n            }\n            quads[qlen++] = currQuad;\n        }\n        Name name = _symbols.findName(quads, qlen);\n        if (name == null) {\n            name = addName(quads, qlen, currQuadBytes);\n        }\n        return name;\n    }",
          "70": "    protected Name _parseApostropheFieldName()\n        throws IOException, JsonParseException\n    {\n        if (_inputPtr >= _inputEnd) {\n            if (!loadMore()) {\n                _reportInvalidEOF(\": was expecting closing '\\'' for name\");\n            }\n        }\n        int ch = _inputBuffer[_inputPtr++] & 0xFF;\n        if (ch == INT_APOSTROPHE) { // special case, ''\n            return BytesToNameCanonicalizer.getEmptyName();\n        }\n        int[] quads = _quadBuffer;\n        int qlen = 0;\n        int currQuad = 0;\n        int currQuadBytes = 0;\n\n        // Copied from parseEscapedFieldName, with minor mods:\n\n        final int[] codes = sInputCodesLatin1;\n\n        while (true) {\n            if (ch == INT_APOSTROPHE) {\n                break;\n            }\n            // additional check to skip handling of double-quotes\n            if (ch != INT_QUOTE && codes[ch] != 0) {\n                if (ch != INT_BACKSLASH) {\n                    // Unquoted white space?\n                    // As per [JACKSON-208], call can now return:\n                    _throwUnquotedSpace(ch, \"name\");\n                } else {\n                    // Nope, escape sequence\n                    ch = _decodeEscaped();\n                }\n                /* Oh crap. May need to UTF-8 (re-)encode it, if it's\n                 * beyond 7-bit ascii. Gets pretty messy.\n                 * If this happens often, may want to use different name\n                 * canonicalization to avoid these hits.\n                 */\n                if (ch > 127) {\n                    // Ok, we'll need room for first byte right away\n                    if (currQuadBytes >= 4) {\n                        if (qlen >= quads.length) {\n                            _quadBuffer = quads = growArrayBy(quads, quads.length);\n                        }\n                        quads[qlen++] = currQuad;\n                        currQuad = 0;\n                        currQuadBytes = 0;\n                    }\n                    if (ch < 0x800) { // 2-byte\n                        currQuad = (currQuad << 8) | (0xc0 | (ch >> 6));\n                        ++currQuadBytes;\n                        // Second byte gets output below:\n                    } else { // 3 bytes; no need to worry about surrogates here\n                        currQuad = (currQuad << 8) | (0xe0 | (ch >> 12));\n                        ++currQuadBytes;\n                        // need room for middle byte?\n                        if (currQuadBytes >= 4) {\n                            if (qlen >= quads.length) {\n                                _quadBuffer = quads = growArrayBy(quads, quads.length);\n                            }\n                            quads[qlen++] = currQuad;\n                            currQuad = 0;\n                            currQuadBytes = 0;\n                        }\n                        currQuad = (currQuad << 8) | (0x80 | ((ch >> 6) & 0x3f));\n                        ++currQuadBytes;\n                    }\n                    // And same last byte in both cases, gets output below:\n                    ch = 0x80 | (ch & 0x3f);\n                }\n            }\n            // Ok, we have one more byte to add at any rate:\n            if (currQuadBytes < 4) {\n                ++currQuadBytes;\n                currQuad = (currQuad << 8) | ch;\n            } else {\n                if (qlen >= quads.length) {\n                    _quadBuffer = quads = growArrayBy(quads, quads.length);\n                }\n                quads[qlen++] = currQuad;\n                currQuad = ch;\n                currQuadBytes = 1;\n            }\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\" in field name\");\n                }\n            }\nch = (_inputEnd | 255);\n        }\n\n        if (currQuadBytes > 0) {\n            if (qlen >= quads.length) {\n                _quadBuffer = quads = growArrayBy(quads, quads.length);\n            }\n            quads[qlen++] = currQuad;\n        }\n        Name name = _symbols.findName(quads, qlen);\n        if (name == null) {\n            name = addName(quads, qlen, currQuadBytes);\n        }\n        return name;\n    }",
          "71": "    protected Name _parseApostropheFieldName()\n        throws IOException, JsonParseException\n    {\n        if (_inputPtr >= _inputEnd) {\n            if (!loadMore()) {\n                _reportInvalidEOF(\": was expecting closing '\\'' for name\");\n            }\n        }\n        int ch = _inputBuffer[_inputPtr++] & 0xFF;\n        if (ch == INT_APOSTROPHE) { // special case, ''\n            return BytesToNameCanonicalizer.getEmptyName();\n        }\n        int[] quads = _quadBuffer;\n        int qlen = 0;\n        int currQuad = 0;\n        int currQuadBytes = 0;\n\n        // Copied from parseEscapedFieldName, with minor mods:\n\n        final int[] codes = sInputCodesLatin1;\n\n        while (true) {\n            if (ch == INT_APOSTROPHE) {\n                break;\n            }\n            // additional check to skip handling of double-quotes\n            if (ch != INT_QUOTE && codes[ch] != 0) {\n                if (ch != INT_BACKSLASH) {\n                    // Unquoted white space?\n                    // As per [JACKSON-208], call can now return:\n                    _throwUnquotedSpace(ch, \"name\");\n                } else {\n                    // Nope, escape sequence\n                    ch = _decodeEscaped();\n                }\n                /* Oh crap. May need to UTF-8 (re-)encode it, if it's\n                 * beyond 7-bit ascii. Gets pretty messy.\n                 * If this happens often, may want to use different name\n                 * canonicalization to avoid these hits.\n                 */\n                if (ch > 127) {\n                    // Ok, we'll need room for first byte right away\n                    if (currQuadBytes >= 4) {\n                        if (qlen >= quads.length) {\n                            _quadBuffer = quads = growArrayBy(quads, quads.length);\n                        }\n                        quads[qlen++] = currQuad;\n                        currQuad = 0;\n                        currQuadBytes = 0;\n                    }\n                    if (ch < 0x800) { // 2-byte\n                        currQuad = (currQuad << 8) | (0xc0 | (ch >> 6));\n                        ++currQuadBytes;\n                        // Second byte gets output below:\n                    } else { // 3 bytes; no need to worry about surrogates here\n                        currQuad = (currQuad << 8) | (0xe0 | (ch >> 12));\n                        ++currQuadBytes;\n                        // need room for middle byte?\n                        if (currQuadBytes >= 4) {\n                            if (qlen >= quads.length) {\n                                _quadBuffer = quads = growArrayBy(quads, quads.length);\n                            }\n                            quads[qlen++] = currQuad;\n                            currQuad = 0;\n                            currQuadBytes = 0;\n                        }\n                        currQuad = (currQuad << 8) | (0x80 | ((ch >> 6) & 0x3f));\n                        ++currQuadBytes;\n                    }\n                    // And same last byte in both cases, gets output below:\n                    ch = 0x80 | (ch & 0x3f);\n                }\n            }\n            // Ok, we have one more byte to add at any rate:\n            if (currQuadBytes < 4) {\n                ++currQuadBytes;\n                currQuad = (currQuad << 8) | ch;\n            } else {\n                if (qlen >= quads.length) {\n                    _quadBuffer = quads = growArrayBy(quads, quads.length);\n                }\n                quads[qlen++] = currQuad;\n                currQuad = ch;\n                currQuadBytes = 1;\n            }\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\" in field name\");\n                }\n            }\nch = (_inputBuffer[_inputPtr++] | _inputBuffer);\n        }\n\n        if (currQuadBytes > 0) {\n            if (qlen >= quads.length) {\n                _quadBuffer = quads = growArrayBy(quads, quads.length);\n            }\n            quads[qlen++] = currQuad;\n        }\n        Name name = _symbols.findName(quads, qlen);\n        if (name == null) {\n            name = addName(quads, qlen, currQuadBytes);\n        }\n        return name;\n    }",
          "72": "    protected Name _parseApostropheFieldName()\n        throws IOException, JsonParseException\n    {\n        if (_inputPtr >= _inputEnd) {\n            if (!loadMore()) {\n                _reportInvalidEOF(\": was expecting closing '\\'' for name\");\n            }\n        }\n        int ch = _inputBuffer[_inputPtr++] & 0xFF;\n        if (ch == INT_APOSTROPHE) { // special case, ''\n            return BytesToNameCanonicalizer.getEmptyName();\n        }\n        int[] quads = _quadBuffer;\n        int qlen = 0;\n        int currQuad = 0;\n        int currQuadBytes = 0;\n\n        // Copied from parseEscapedFieldName, with minor mods:\n\n        final int[] codes = sInputCodesLatin1;\n\n        while (true) {\n            if (ch == INT_APOSTROPHE) {\n                break;\n            }\n            // additional check to skip handling of double-quotes\n            if (ch != INT_QUOTE && codes[ch] != 0) {\n                if (ch != INT_BACKSLASH) {\n                    // Unquoted white space?\n                    // As per [JACKSON-208], call can now return:\n                    _throwUnquotedSpace(ch, \"name\");\n                } else {\n                    // Nope, escape sequence\n                    ch = _decodeEscaped();\n                }\n                /* Oh crap. May need to UTF-8 (re-)encode it, if it's\n                 * beyond 7-bit ascii. Gets pretty messy.\n                 * If this happens often, may want to use different name\n                 * canonicalization to avoid these hits.\n                 */\n                if (ch > 127) {\n                    // Ok, we'll need room for first byte right away\n                    if (currQuadBytes >= 4) {\n                        if (qlen >= quads.length) {\n                            _quadBuffer = quads = growArrayBy(quads, quads.length);\n                        }\n                        quads[qlen++] = currQuad;\n                        currQuad = 0;\n                        currQuadBytes = 0;\n                    }\n                    if (ch < 0x800) { // 2-byte\n                        currQuad = (currQuad << 8) | (0xc0 | (ch >> 6));\n                        ++currQuadBytes;\n                        // Second byte gets output below:\n                    } else { // 3 bytes; no need to worry about surrogates here\n                        currQuad = (currQuad << 8) | (0xe0 | (ch >> 12));\n                        ++currQuadBytes;\n                        // need room for middle byte?\n                        if (currQuadBytes >= 4) {\n                            if (qlen >= quads.length) {\n                                _quadBuffer = quads = growArrayBy(quads, quads.length);\n                            }\n                            quads[qlen++] = currQuad;\n                            currQuad = 0;\n                            currQuadBytes = 0;\n                        }\n                        currQuad = (currQuad << 8) | (0x80 | ((ch >> 6) & 0x3f));\n                        ++currQuadBytes;\n                    }\n                    // And same last byte in both cases, gets output below:\n                    ch = 0x80 | (ch & 0x3f);\n                }\n            }\n            // Ok, we have one more byte to add at any rate:\n            if (currQuadBytes < 4) {\n                ++currQuadBytes;\n                currQuad = (currQuad << 8) | ch;\n            } else {\n                if (qlen >= quads.length) {\n                    _quadBuffer = quads = growArrayBy(quads, quads.length);\n                }\n                quads[qlen++] = currQuad;\n                currQuad = ch;\n                currQuadBytes = 1;\n            }\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\" in field name\");\n                }\n            }\nch = (_inputBuffer[_inputPtr++] | true);\n        }\n\n        if (currQuadBytes > 0) {\n            if (qlen >= quads.length) {\n                _quadBuffer = quads = growArrayBy(quads, quads.length);\n            }\n            quads[qlen++] = currQuad;\n        }\n        Name name = _symbols.findName(quads, qlen);\n        if (name == null) {\n            name = addName(quads, qlen, currQuadBytes);\n        }\n        return name;\n    }",
          "73": "    protected Name _parseApostropheFieldName()\n        throws IOException, JsonParseException\n    {\n        if (_inputPtr >= _inputEnd) {\n            if (!loadMore()) {\n                _reportInvalidEOF(\": was expecting closing '\\'' for name\");\n            }\n        }\n        int ch = _inputBuffer[_inputPtr++] & 0xFF;\n        if (ch == INT_APOSTROPHE) { // special case, ''\n            return BytesToNameCanonicalizer.getEmptyName();\n        }\n        int[] quads = _quadBuffer;\n        int qlen = 0;\n        int currQuad = 0;\n        int currQuadBytes = 0;\n\n        // Copied from parseEscapedFieldName, with minor mods:\n\n        final int[] codes = sInputCodesLatin1;\n\n        while (true) {\n            if (ch == INT_APOSTROPHE) {\n                break;\n            }\n            // additional check to skip handling of double-quotes\n            if (ch != INT_QUOTE && codes[ch] != 0) {\n                if (ch != INT_BACKSLASH) {\n                    // Unquoted white space?\n                    // As per [JACKSON-208], call can now return:\n                    _throwUnquotedSpace(ch, \"name\");\n                } else {\n                    // Nope, escape sequence\n                    ch = _decodeEscaped();\n                }\n                /* Oh crap. May need to UTF-8 (re-)encode it, if it's\n                 * beyond 7-bit ascii. Gets pretty messy.\n                 * If this happens often, may want to use different name\n                 * canonicalization to avoid these hits.\n                 */\n                if (ch > 127) {\n                    // Ok, we'll need room for first byte right away\n                    if (currQuadBytes >= 4) {\n                        if (qlen >= quads.length) {\n                            _quadBuffer = quads = growArrayBy(quads, quads.length);\n                        }\n                        quads[qlen++] = currQuad;\n                        currQuad = 0;\n                        currQuadBytes = 0;\n                    }\n                    if (ch < 0x800) { // 2-byte\n                        currQuad = (currQuad << 8) | (0xc0 | (ch >> 6));\n                        ++currQuadBytes;\n                        // Second byte gets output below:\n                    } else { // 3 bytes; no need to worry about surrogates here\n                        currQuad = (currQuad << 8) | (0xe0 | (ch >> 12));\n                        ++currQuadBytes;\n                        // need room for middle byte?\n                        if (currQuadBytes >= 4) {\n                            if (qlen >= quads.length) {\n                                _quadBuffer = quads = growArrayBy(quads, quads.length);\n                            }\n                            quads[qlen++] = currQuad;\n                            currQuad = 0;\n                            currQuadBytes = 0;\n                        }\n                        currQuad = (currQuad << 8) | (0x80 | ((ch >> 6) & 0x3f));\n                        ++currQuadBytes;\n                    }\n                    // And same last byte in both cases, gets output below:\n                    ch = 0x80 | (ch & 0x3f);\n                }\n            }\n            // Ok, we have one more byte to add at any rate:\n            if (currQuadBytes < 4) {\n                ++currQuadBytes;\n                currQuad = (currQuad << 8) | ch;\n            } else {\n                if (qlen >= quads.length) {\n                    _quadBuffer = quads = growArrayBy(quads, quads.length);\n                }\n                quads[qlen++] = currQuad;\n                currQuad = ch;\n                currQuadBytes = 1;\n            }\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\" in field name\");\n                }\n            }\nch = (ch | 255);\n        }\n\n        if (currQuadBytes > 0) {\n            if (qlen >= quads.length) {\n                _quadBuffer = quads = growArrayBy(quads, quads.length);\n            }\n            quads[qlen++] = currQuad;\n        }\n        Name name = _symbols.findName(quads, qlen);\n        if (name == null) {\n            name = addName(quads, qlen, currQuadBytes);\n        }\n        return name;\n    }",
          "74": "    protected Name _parseApostropheFieldName()\n        throws IOException, JsonParseException\n    {\n        if (_inputPtr >= _inputEnd) {\n            if (!loadMore()) {\n                _reportInvalidEOF(\": was expecting closing '\\'' for name\");\n            }\n        }\n        int ch = _inputBuffer[_inputPtr++] & 0xFF;\n        if (ch == INT_APOSTROPHE) { // special case, ''\n            return BytesToNameCanonicalizer.getEmptyName();\n        }\n        int[] quads = _quadBuffer;\n        int qlen = 0;\n        int currQuad = 0;\n        int currQuadBytes = 0;\n\n        // Copied from parseEscapedFieldName, with minor mods:\n\n        final int[] codes = sInputCodesLatin1;\n\n        while (true) {\n            if (ch == INT_APOSTROPHE) {\n                break;\n            }\n            // additional check to skip handling of double-quotes\n            if (ch != INT_QUOTE && codes[ch] != 0) {\n                if (ch != INT_BACKSLASH) {\n                    // Unquoted white space?\n                    // As per [JACKSON-208], call can now return:\n                    _throwUnquotedSpace(ch, \"name\");\n                } else {\n                    // Nope, escape sequence\n                    ch = _decodeEscaped();\n                }\n                /* Oh crap. May need to UTF-8 (re-)encode it, if it's\n                 * beyond 7-bit ascii. Gets pretty messy.\n                 * If this happens often, may want to use different name\n                 * canonicalization to avoid these hits.\n                 */\n                if (ch > 127) {\n                    // Ok, we'll need room for first byte right away\n                    if (currQuadBytes >= 4) {\n                        if (qlen >= quads.length) {\n                            _quadBuffer = quads = growArrayBy(quads, quads.length);\n                        }\n                        quads[qlen++] = currQuad;\n                        currQuad = 0;\n                        currQuadBytes = 0;\n                    }\n                    if (ch < 0x800) { // 2-byte\n                        currQuad = (currQuad << 8) | (0xc0 | (ch >> 6));\n                        ++currQuadBytes;\n                        // Second byte gets output below:\n                    } else { // 3 bytes; no need to worry about surrogates here\n                        currQuad = (currQuad << 8) | (0xe0 | (ch >> 12));\n                        ++currQuadBytes;\n                        // need room for middle byte?\n                        if (currQuadBytes >= 4) {\n                            if (qlen >= quads.length) {\n                                _quadBuffer = quads = growArrayBy(quads, quads.length);\n                            }\n                            quads[qlen++] = currQuad;\n                            currQuad = 0;\n                            currQuadBytes = 0;\n                        }\n                        currQuad = (currQuad << 8) | (0x80 | ((ch >> 6) & 0x3f));\n                        ++currQuadBytes;\n                    }\n                    // And same last byte in both cases, gets output below:\n                    ch = 0x80 | (ch & 0x3f);\n                }\n            }\n            // Ok, we have one more byte to add at any rate:\n            if (currQuadBytes < 4) {\n                ++currQuadBytes;\n                currQuad = (currQuad << 8) | ch;\n            } else {\n                if (qlen >= quads.length) {\n                    _quadBuffer = quads = growArrayBy(quads, quads.length);\n                }\n                quads[qlen++] = currQuad;\n                currQuad = ch;\n                currQuadBytes = 1;\n            }\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\" in field name\");\n                }\n            }\nch = ((_inputBuffer[_inputPtr++] | 255) + 1);\n        }\n\n        if (currQuadBytes > 0) {\n            if (qlen >= quads.length) {\n                _quadBuffer = quads = growArrayBy(quads, quads.length);\n            }\n            quads[qlen++] = currQuad;\n        }\n        Name name = _symbols.findName(quads, qlen);\n        if (name == null) {\n            name = addName(quads, qlen, currQuadBytes);\n        }\n        return name;\n    }",
          "75": "    protected Name _parseApostropheFieldName()\n        throws IOException, JsonParseException\n    {\n        if (_inputPtr >= _inputEnd) {\n            if (!loadMore()) {\n                _reportInvalidEOF(\": was expecting closing '\\'' for name\");\n            }\n        }\n        int ch = _inputBuffer[_inputPtr++] & 0xFF;\n        if (ch == INT_APOSTROPHE) { // special case, ''\n            return BytesToNameCanonicalizer.getEmptyName();\n        }\n        int[] quads = _quadBuffer;\n        int qlen = 0;\n        int currQuad = 0;\n        int currQuadBytes = 0;\n\n        // Copied from parseEscapedFieldName, with minor mods:\n\n        final int[] codes = sInputCodesLatin1;\n\n        while (true) {\n            if (ch == INT_APOSTROPHE) {\n                break;\n            }\n            // additional check to skip handling of double-quotes\n            if (ch != INT_QUOTE && codes[ch] != 0) {\n                if (ch != INT_BACKSLASH) {\n                    // Unquoted white space?\n                    // As per [JACKSON-208], call can now return:\n                    _throwUnquotedSpace(ch, \"name\");\n                } else {\n                    // Nope, escape sequence\n                    ch = _decodeEscaped();\n                }\n                /* Oh crap. May need to UTF-8 (re-)encode it, if it's\n                 * beyond 7-bit ascii. Gets pretty messy.\n                 * If this happens often, may want to use different name\n                 * canonicalization to avoid these hits.\n                 */\n                if (ch > 127) {\n                    // Ok, we'll need room for first byte right away\n                    if (currQuadBytes >= 4) {\n                        if (qlen >= quads.length) {\n                            _quadBuffer = quads = growArrayBy(quads, quads.length);\n                        }\n                        quads[qlen++] = currQuad;\n                        currQuad = 0;\n                        currQuadBytes = 0;\n                    }\n                    if (ch < 0x800) { // 2-byte\n                        currQuad = (currQuad << 8) | (0xc0 | (ch >> 6));\n                        ++currQuadBytes;\n                        // Second byte gets output below:\n                    } else { // 3 bytes; no need to worry about surrogates here\n                        currQuad = (currQuad << 8) | (0xe0 | (ch >> 12));\n                        ++currQuadBytes;\n                        // need room for middle byte?\n                        if (currQuadBytes >= 4) {\n                            if (qlen >= quads.length) {\n                                _quadBuffer = quads = growArrayBy(quads, quads.length);\n                            }\n                            quads[qlen++] = currQuad;\n                            currQuad = 0;\n                            currQuadBytes = 0;\n                        }\n                        currQuad = (currQuad << 8) | (0x80 | ((ch >> 6) & 0x3f));\n                        ++currQuadBytes;\n                    }\n                    // And same last byte in both cases, gets output below:\n                    ch = 0x80 | (ch & 0x3f);\n                }\n            }\n            // Ok, we have one more byte to add at any rate:\n            if (currQuadBytes < 4) {\n                ++currQuadBytes;\n                currQuad = (currQuad << 8) | ch;\n            } else {\n                if (qlen >= quads.length) {\n                    _quadBuffer = quads = growArrayBy(quads, quads.length);\n                }\n                quads[qlen++] = currQuad;\n                currQuad = ch;\n                currQuadBytes = 1;\n            }\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\" in field name\");\n                }\n            }\nch = _skipUtf8_2(_inputBuffer[_inputPtr++]);\n        }\n\n        if (currQuadBytes > 0) {\n            if (qlen >= quads.length) {\n                _quadBuffer = quads = growArrayBy(quads, quads.length);\n            }\n            quads[qlen++] = currQuad;\n        }\n        Name name = _symbols.findName(quads, qlen);\n        if (name == null) {\n            name = addName(quads, qlen, currQuadBytes);\n        }\n        return name;\n    }",
          "76": "    protected Name _parseApostropheFieldName()\n        throws IOException, JsonParseException\n    {\n        if (_inputPtr >= _inputEnd) {\n            if (!loadMore()) {\n                _reportInvalidEOF(\": was expecting closing '\\'' for name\");\n            }\n        }\n        int ch = _inputBuffer[_inputPtr++] & 0xFF;\n        if (ch == INT_APOSTROPHE) { // special case, ''\n            return BytesToNameCanonicalizer.getEmptyName();\n        }\n        int[] quads = _quadBuffer;\n        int qlen = 0;\n        int currQuad = 0;\n        int currQuadBytes = 0;\n\n        // Copied from parseEscapedFieldName, with minor mods:\n\n        final int[] codes = sInputCodesLatin1;\n\n        while (true) {\n            if (ch == INT_APOSTROPHE) {\n                break;\n            }\n            // additional check to skip handling of double-quotes\n            if (ch != INT_QUOTE && codes[ch] != 0) {\n                if (ch != INT_BACKSLASH) {\n                    // Unquoted white space?\n                    // As per [JACKSON-208], call can now return:\n                    _throwUnquotedSpace(ch, \"name\");\n                } else {\n                    // Nope, escape sequence\n                    ch = _decodeEscaped();\n                }\n                /* Oh crap. May need to UTF-8 (re-)encode it, if it's\n                 * beyond 7-bit ascii. Gets pretty messy.\n                 * If this happens often, may want to use different name\n                 * canonicalization to avoid these hits.\n                 */\n                if (ch > 127) {\n                    // Ok, we'll need room for first byte right away\n                    if (currQuadBytes >= 4) {\n                        if (qlen >= quads.length) {\n                            _quadBuffer = quads = growArrayBy(quads, quads.length);\n                        }\n                        quads[qlen++] = currQuad;\n                        currQuad = 0;\n                        currQuadBytes = 0;\n                    }\n                    if (ch < 0x800) { // 2-byte\n                        currQuad = (currQuad << 8) | (0xc0 | (ch >> 6));\n                        ++currQuadBytes;\n                        // Second byte gets output below:\n                    } else { // 3 bytes; no need to worry about surrogates here\n                        currQuad = (currQuad << 8) | (0xe0 | (ch >> 12));\n                        ++currQuadBytes;\n                        // need room for middle byte?\n                        if (currQuadBytes >= 4) {\n                            if (qlen >= quads.length) {\n                                _quadBuffer = quads = growArrayBy(quads, quads.length);\n                            }\n                            quads[qlen++] = currQuad;\n                            currQuad = 0;\n                            currQuadBytes = 0;\n                        }\n                        currQuad = (currQuad << 8) | (0x80 | ((ch >> 6) & 0x3f));\n                        ++currQuadBytes;\n                    }\n                    // And same last byte in both cases, gets output below:\n                    ch = 0x80 | (ch & 0x3f);\n                }\n            }\n            // Ok, we have one more byte to add at any rate:\n            if (currQuadBytes < 4) {\n                ++currQuadBytes;\n                currQuad = (currQuad << 8) | ch;\n            } else {\n                if (qlen >= quads.length) {\n                    _quadBuffer = quads = growArrayBy(quads, quads.length);\n                }\n                quads[qlen++] = currQuad;\n                currQuad = ch;\n                currQuadBytes = 1;\n            }\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\" in field name\");\n                }\n            }\nch = _skipUtf8_3(_inputBuffer[_inputPtr++]);\n        }\n\n        if (currQuadBytes > 0) {\n            if (qlen >= quads.length) {\n                _quadBuffer = quads = growArrayBy(quads, quads.length);\n            }\n            quads[qlen++] = currQuad;\n        }\n        Name name = _symbols.findName(quads, qlen);\n        if (name == null) {\n            name = addName(quads, qlen, currQuadBytes);\n        }\n        return name;\n    }",
          "77": "    protected Name _parseApostropheFieldName()\n        throws IOException, JsonParseException\n    {\n        if (_inputPtr >= _inputEnd) {\n            if (!loadMore()) {\n                _reportInvalidEOF(\": was expecting closing '\\'' for name\");\n            }\n        }\n        int ch = _inputBuffer[_inputPtr++] & 0xFF;\n        if (ch == INT_APOSTROPHE) { // special case, ''\n            return BytesToNameCanonicalizer.getEmptyName();\n        }\n        int[] quads = _quadBuffer;\n        int qlen = 0;\n        int currQuad = 0;\n        int currQuadBytes = 0;\n\n        // Copied from parseEscapedFieldName, with minor mods:\n\n        final int[] codes = sInputCodesLatin1;\n\n        while (true) {\n            if (ch == INT_APOSTROPHE) {\n                break;\n            }\n            // additional check to skip handling of double-quotes\n            if (ch != INT_QUOTE && codes[ch] != 0) {\n                if (ch != INT_BACKSLASH) {\n                    // Unquoted white space?\n                    // As per [JACKSON-208], call can now return:\n                    _throwUnquotedSpace(ch, \"name\");\n                } else {\n                    // Nope, escape sequence\n                    ch = _decodeEscaped();\n                }\n                /* Oh crap. May need to UTF-8 (re-)encode it, if it's\n                 * beyond 7-bit ascii. Gets pretty messy.\n                 * If this happens often, may want to use different name\n                 * canonicalization to avoid these hits.\n                 */\n                if (ch > 127) {\n                    // Ok, we'll need room for first byte right away\n                    if (currQuadBytes >= 4) {\n                        if (qlen >= quads.length) {\n                            _quadBuffer = quads = growArrayBy(quads, quads.length);\n                        }\n                        quads[qlen++] = currQuad;\n                        currQuad = 0;\n                        currQuadBytes = 0;\n                    }\n                    if (ch < 0x800) { // 2-byte\n                        currQuad = (currQuad << 8) | (0xc0 | (ch >> 6));\n                        ++currQuadBytes;\n                        // Second byte gets output below:\n                    } else { // 3 bytes; no need to worry about surrogates here\n                        currQuad = (currQuad << 8) | (0xe0 | (ch >> 12));\n                        ++currQuadBytes;\n                        // need room for middle byte?\n                        if (currQuadBytes >= 4) {\n                            if (qlen >= quads.length) {\n                                _quadBuffer = quads = growArrayBy(quads, quads.length);\n                            }\n                            quads[qlen++] = currQuad;\n                            currQuad = 0;\n                            currQuadBytes = 0;\n                        }\n                        currQuad = (currQuad << 8) | (0x80 | ((ch >> 6) & 0x3f));\n                        ++currQuadBytes;\n                    }\n                    // And same last byte in both cases, gets output below:\n                    ch = 0x80 | (ch & 0x3f);\n                }\n            }\n            // Ok, we have one more byte to add at any rate:\n            if (currQuadBytes < 4) {\n                ++currQuadBytes;\n                currQuad = (currQuad << 8) | ch;\n            } else {\n                if (qlen >= quads.length) {\n                    _quadBuffer = quads = growArrayBy(quads, quads.length);\n                }\n                quads[qlen++] = currQuad;\n                currQuad = ch;\n                currQuadBytes = 1;\n            }\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\" in field name\");\n                }\n            }\nch = _skipUtf8_4(_inputBuffer[_inputPtr++]);\n        }\n\n        if (currQuadBytes > 0) {\n            if (qlen >= quads.length) {\n                _quadBuffer = quads = growArrayBy(quads, quads.length);\n            }\n            quads[qlen++] = currQuad;\n        }\n        Name name = _symbols.findName(quads, qlen);\n        if (name == null) {\n            name = addName(quads, qlen, currQuadBytes);\n        }\n        return name;\n    }",
          "78": "    protected Name _parseApostropheFieldName()\n        throws IOException, JsonParseException\n    {\n        if (_inputPtr >= _inputEnd) {\n            if (!loadMore()) {\n                _reportInvalidEOF(\": was expecting closing '\\'' for name\");\n            }\n        }\n        int ch = _inputBuffer[_inputPtr++] & 0xFF;\n        if (ch == INT_APOSTROPHE) { // special case, ''\n            return BytesToNameCanonicalizer.getEmptyName();\n        }\n        int[] quads = _quadBuffer;\n        int qlen = 0;\n        int currQuad = 0;\n        int currQuadBytes = 0;\n\n        // Copied from parseEscapedFieldName, with minor mods:\n\n        final int[] codes = sInputCodesLatin1;\n\n        while (true) {\n            if (ch == INT_APOSTROPHE) {\n                break;\n            }\n            // additional check to skip handling of double-quotes\n            if (ch != INT_QUOTE && codes[ch] != 0) {\n                if (ch != INT_BACKSLASH) {\n                    // Unquoted white space?\n                    // As per [JACKSON-208], call can now return:\n                    _throwUnquotedSpace(ch, \"name\");\n                } else {\n                    // Nope, escape sequence\n                    ch = _decodeEscaped();\n                }\n                /* Oh crap. May need to UTF-8 (re-)encode it, if it's\n                 * beyond 7-bit ascii. Gets pretty messy.\n                 * If this happens often, may want to use different name\n                 * canonicalization to avoid these hits.\n                 */\n                if (ch > 127) {\n                    // Ok, we'll need room for first byte right away\n                    if (currQuadBytes >= 4) {\n                        if (qlen >= quads.length) {\n                            _quadBuffer = quads = growArrayBy(quads, quads.length);\n                        }\n                        quads[qlen++] = currQuad;\n                        currQuad = 0;\n                        currQuadBytes = 0;\n                    }\n                    if (ch < 0x800) { // 2-byte\n                        currQuad = (currQuad << 8) | (0xc0 | (ch >> 6));\n                        ++currQuadBytes;\n                        // Second byte gets output below:\n                    } else { // 3 bytes; no need to worry about surrogates here\n                        currQuad = (currQuad << 8) | (0xe0 | (ch >> 12));\n                        ++currQuadBytes;\n                        // need room for middle byte?\n                        if (currQuadBytes >= 4) {\n                            if (qlen >= quads.length) {\n                                _quadBuffer = quads = growArrayBy(quads, quads.length);\n                            }\n                            quads[qlen++] = currQuad;\n                            currQuad = 0;\n                            currQuadBytes = 0;\n                        }\n                        currQuad = (currQuad << 8) | (0x80 | ((ch >> 6) & 0x3f));\n                        ++currQuadBytes;\n                    }\n                    // And same last byte in both cases, gets output below:\n                    ch = 0x80 | (ch & 0x3f);\n                }\n            }\n            // Ok, we have one more byte to add at any rate:\n            if (currQuadBytes < 4) {\n                ++currQuadBytes;\n                currQuad = (currQuad << 8) | ch;\n            } else {\n                if (qlen >= quads.length) {\n                    _quadBuffer = quads = growArrayBy(quads, quads.length);\n                }\n                quads[qlen++] = currQuad;\n                currQuad = ch;\n                currQuadBytes = 1;\n            }\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\" in field name\");\n                }\n            }\nch = _reportInvalidChar(_inputBuffer[_inputPtr++]);\n        }\n\n        if (currQuadBytes > 0) {\n            if (qlen >= quads.length) {\n                _quadBuffer = quads = growArrayBy(quads, quads.length);\n            }\n            quads[qlen++] = currQuad;\n        }\n        Name name = _symbols.findName(quads, qlen);\n        if (name == null) {\n            name = addName(quads, qlen, currQuadBytes);\n        }\n        return name;\n    }",
          "79": "    protected Name _parseApostropheFieldName()\n        throws IOException, JsonParseException\n    {\n        if (_inputPtr >= _inputEnd) {\n            if (!loadMore()) {\n                _reportInvalidEOF(\": was expecting closing '\\'' for name\");\n            }\n        }\n        int ch = _inputBuffer[_inputPtr++] & 0xFF;\n        if (ch == INT_APOSTROPHE) { // special case, ''\n            return BytesToNameCanonicalizer.getEmptyName();\n        }\n        int[] quads = _quadBuffer;\n        int qlen = 0;\n        int currQuad = 0;\n        int currQuadBytes = 0;\n\n        // Copied from parseEscapedFieldName, with minor mods:\n\n        final int[] codes = sInputCodesLatin1;\n\n        while (true) {\n            if (ch == INT_APOSTROPHE) {\n                break;\n            }\n            // additional check to skip handling of double-quotes\n            if (ch != INT_QUOTE && codes[ch] != 0) {\n                if (ch != INT_BACKSLASH) {\n                    // Unquoted white space?\n                    // As per [JACKSON-208], call can now return:\n                    _throwUnquotedSpace(ch, \"name\");\n                } else {\n                    // Nope, escape sequence\n                    ch = _decodeEscaped();\n                }\n                /* Oh crap. May need to UTF-8 (re-)encode it, if it's\n                 * beyond 7-bit ascii. Gets pretty messy.\n                 * If this happens often, may want to use different name\n                 * canonicalization to avoid these hits.\n                 */\n                if (ch > 127) {\n                    // Ok, we'll need room for first byte right away\n                    if (currQuadBytes >= 4) {\n                        if (qlen >= quads.length) {\n                            _quadBuffer = quads = growArrayBy(quads, quads.length);\n                        }\n                        quads[qlen++] = currQuad;\n                        currQuad = 0;\n                        currQuadBytes = 0;\n                    }\n                    if (ch < 0x800) { // 2-byte\n                        currQuad = (currQuad << 8) | (0xc0 | (ch >> 6));\n                        ++currQuadBytes;\n                        // Second byte gets output below:\n                    } else { // 3 bytes; no need to worry about surrogates here\n                        currQuad = (currQuad << 8) | (0xe0 | (ch >> 12));\n                        ++currQuadBytes;\n                        // need room for middle byte?\n                        if (currQuadBytes >= 4) {\n                            if (qlen >= quads.length) {\n                                _quadBuffer = quads = growArrayBy(quads, quads.length);\n                            }\n                            quads[qlen++] = currQuad;\n                            currQuad = 0;\n                            currQuadBytes = 0;\n                        }\n                        currQuad = (currQuad << 8) | (0x80 | ((ch >> 6) & 0x3f));\n                        ++currQuadBytes;\n                    }\n                    // And same last byte in both cases, gets output below:\n                    ch = 0x80 | (ch & 0x3f);\n                }\n            }\n            // Ok, we have one more byte to add at any rate:\n            if (currQuadBytes < 4) {\n                ++currQuadBytes;\n                currQuad = (currQuad << 8) | ch;\n            } else {\n                if (qlen >= quads.length) {\n                    _quadBuffer = quads = growArrayBy(quads, quads.length);\n                }\n                quads[qlen++] = currQuad;\n                currQuad = ch;\n                currQuadBytes = 1;\n            }\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\" in field name\");\n                }\n            }\nch = _reportInvalidInitial(_inputBuffer[_inputPtr++]);\n        }\n\n        if (currQuadBytes > 0) {\n            if (qlen >= quads.length) {\n                _quadBuffer = quads = growArrayBy(quads, quads.length);\n            }\n            quads[qlen++] = currQuad;\n        }\n        Name name = _symbols.findName(quads, qlen);\n        if (name == null) {\n            name = addName(quads, qlen, currQuadBytes);\n        }\n        return name;\n    }",
          "80": "    protected Name _parseApostropheFieldName()\n        throws IOException, JsonParseException\n    {\n        if (_inputPtr >= _inputEnd) {\n            if (!loadMore()) {\n                _reportInvalidEOF(\": was expecting closing '\\'' for name\");\n            }\n        }\n        int ch = _inputBuffer[_inputPtr++] & 0xFF;\n        if (ch == INT_APOSTROPHE) { // special case, ''\n            return BytesToNameCanonicalizer.getEmptyName();\n        }\n        int[] quads = _quadBuffer;\n        int qlen = 0;\n        int currQuad = 0;\n        int currQuadBytes = 0;\n\n        // Copied from parseEscapedFieldName, with minor mods:\n\n        final int[] codes = sInputCodesLatin1;\n\n        while (true) {\n            if (ch == INT_APOSTROPHE) {\n                break;\n            }\n            // additional check to skip handling of double-quotes\n            if (ch != INT_QUOTE && codes[ch] != 0) {\n                if (ch != INT_BACKSLASH) {\n                    // Unquoted white space?\n                    // As per [JACKSON-208], call can now return:\n                    _throwUnquotedSpace(ch, \"name\");\n                } else {\n                    // Nope, escape sequence\n                    ch = _decodeEscaped();\n                }\n                /* Oh crap. May need to UTF-8 (re-)encode it, if it's\n                 * beyond 7-bit ascii. Gets pretty messy.\n                 * If this happens often, may want to use different name\n                 * canonicalization to avoid these hits.\n                 */\n                if (ch > 127) {\n                    // Ok, we'll need room for first byte right away\n                    if (currQuadBytes >= 4) {\n                        if (qlen >= quads.length) {\n                            _quadBuffer = quads = growArrayBy(quads, quads.length);\n                        }\n                        quads[qlen++] = currQuad;\n                        currQuad = 0;\n                        currQuadBytes = 0;\n                    }\n                    if (ch < 0x800) { // 2-byte\n                        currQuad = (currQuad << 8) | (0xc0 | (ch >> 6));\n                        ++currQuadBytes;\n                        // Second byte gets output below:\n                    } else { // 3 bytes; no need to worry about surrogates here\n                        currQuad = (currQuad << 8) | (0xe0 | (ch >> 12));\n                        ++currQuadBytes;\n                        // need room for middle byte?\n                        if (currQuadBytes >= 4) {\n                            if (qlen >= quads.length) {\n                                _quadBuffer = quads = growArrayBy(quads, quads.length);\n                            }\n                            quads[qlen++] = currQuad;\n                            currQuad = 0;\n                            currQuadBytes = 0;\n                        }\n                        currQuad = (currQuad << 8) | (0x80 | ((ch >> 6) & 0x3f));\n                        ++currQuadBytes;\n                    }\n                    // And same last byte in both cases, gets output below:\n                    ch = 0x80 | (ch & 0x3f);\n                }\n            }\n            // Ok, we have one more byte to add at any rate:\n            if (currQuadBytes < 4) {\n                ++currQuadBytes;\n                currQuad = (currQuad << 8) | ch;\n            } else {\n                if (qlen >= quads.length) {\n                    _quadBuffer = quads = growArrayBy(quads, quads.length);\n                }\n                quads[qlen++] = currQuad;\n                currQuad = ch;\n                currQuadBytes = 1;\n            }\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\" in field name\");\n                }\n            }\nch = _reportInvalidOther(_inputBuffer[_inputPtr++]);\n        }\n\n        if (currQuadBytes > 0) {\n            if (qlen >= quads.length) {\n                _quadBuffer = quads = growArrayBy(quads, quads.length);\n            }\n            quads[qlen++] = currQuad;\n        }\n        Name name = _symbols.findName(quads, qlen);\n        if (name == null) {\n            name = addName(quads, qlen, currQuadBytes);\n        }\n        return name;\n    }",
          "81": "    protected Name _parseApostropheFieldName()\n        throws IOException, JsonParseException\n    {\n        if (_inputPtr >= _inputEnd) {\n            if (!loadMore()) {\n                _reportInvalidEOF(\": was expecting closing '\\'' for name\");\n            }\n        }\n        int ch = _inputBuffer[_inputPtr++] & 0xFF;\n        if (ch == INT_APOSTROPHE) { // special case, ''\n            return BytesToNameCanonicalizer.getEmptyName();\n        }\n        int[] quads = _quadBuffer;\n        int qlen = 0;\n        int currQuad = 0;\n        int currQuadBytes = 0;\n\n        // Copied from parseEscapedFieldName, with minor mods:\n\n        final int[] codes = sInputCodesLatin1;\n\n        while (true) {\n            if (ch == INT_APOSTROPHE) {\n                break;\n            }\n            // additional check to skip handling of double-quotes\n            if (ch != INT_QUOTE && codes[ch] != 0) {\n                if (ch != INT_BACKSLASH) {\n                    // Unquoted white space?\n                    // As per [JACKSON-208], call can now return:\n                    _throwUnquotedSpace(ch, \"name\");\n                } else {\n                    // Nope, escape sequence\n                    ch = _decodeEscaped();\n                }\n                /* Oh crap. May need to UTF-8 (re-)encode it, if it's\n                 * beyond 7-bit ascii. Gets pretty messy.\n                 * If this happens often, may want to use different name\n                 * canonicalization to avoid these hits.\n                 */\n                if (ch > 127) {\n                    // Ok, we'll need room for first byte right away\n                    if (currQuadBytes >= 4) {\n                        if (qlen >= quads.length) {\n                            _quadBuffer = quads = growArrayBy(quads, quads.length);\n                        }\n                        quads[qlen++] = currQuad;\n                        currQuad = 0;\n                        currQuadBytes = 0;\n                    }\n                    if (ch < 0x800) { // 2-byte\n                        currQuad = (currQuad << 8) | (0xc0 | (ch >> 6));\n                        ++currQuadBytes;\n                        // Second byte gets output below:\n                    } else { // 3 bytes; no need to worry about surrogates here\n                        currQuad = (currQuad << 8) | (0xe0 | (ch >> 12));\n                        ++currQuadBytes;\n                        // need room for middle byte?\n                        if (currQuadBytes >= 4) {\n                            if (qlen >= quads.length) {\n                                _quadBuffer = quads = growArrayBy(quads, quads.length);\n                            }\n                            quads[qlen++] = currQuad;\n                            currQuad = 0;\n                            currQuadBytes = 0;\n                        }\n                        currQuad = (currQuad << 8) | (0x80 | ((ch >> 6) & 0x3f));\n                        ++currQuadBytes;\n                    }\n                    // And same last byte in both cases, gets output below:\n                    ch = 0x80 | (ch & 0x3f);\n                }\n            }\n            // Ok, we have one more byte to add at any rate:\n            if (currQuadBytes < 4) {\n                ++currQuadBytes;\n                currQuad = (currQuad << 8) | ch;\n            } else {\n                if (qlen >= quads.length) {\n                    _quadBuffer = quads = growArrayBy(quads, quads.length);\n                }\n                quads[qlen++] = currQuad;\n                currQuad = ch;\n                currQuadBytes = 1;\n            }\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\" in field name\");\n                }\n            }\nch = (_inputBuffer[_inputPtr++] | _inputBuffer[_inputPtr++]);\n        }\n\n        if (currQuadBytes > 0) {\n            if (qlen >= quads.length) {\n                _quadBuffer = quads = growArrayBy(quads, quads.length);\n            }\n            quads[qlen++] = currQuad;\n        }\n        Name name = _symbols.findName(quads, qlen);\n        if (name == null) {\n            name = addName(quads, qlen, currQuadBytes);\n        }\n        return name;\n    }",
          "82": "    protected Name _parseApostropheFieldName()\n        throws IOException, JsonParseException\n    {\n        if (_inputPtr >= _inputEnd) {\n            if (!loadMore()) {\n                _reportInvalidEOF(\": was expecting closing '\\'' for name\");\n            }\n        }\n        int ch = _inputBuffer[_inputPtr++] & 0xFF;\n        if (ch == INT_APOSTROPHE) { // special case, ''\n            return BytesToNameCanonicalizer.getEmptyName();\n        }\n        int[] quads = _quadBuffer;\n        int qlen = 0;\n        int currQuad = 0;\n        int currQuadBytes = 0;\n\n        // Copied from parseEscapedFieldName, with minor mods:\n\n        final int[] codes = sInputCodesLatin1;\n\n        while (true) {\n            if (ch == INT_APOSTROPHE) {\n                break;\n            }\n            // additional check to skip handling of double-quotes\n            if (ch != INT_QUOTE && codes[ch] != 0) {\n                if (ch != INT_BACKSLASH) {\n                    // Unquoted white space?\n                    // As per [JACKSON-208], call can now return:\n                    _throwUnquotedSpace(ch, \"name\");\n                } else {\n                    // Nope, escape sequence\n                    ch = _decodeEscaped();\n                }\n                /* Oh crap. May need to UTF-8 (re-)encode it, if it's\n                 * beyond 7-bit ascii. Gets pretty messy.\n                 * If this happens often, may want to use different name\n                 * canonicalization to avoid these hits.\n                 */\n                if (ch > 127) {\n                    // Ok, we'll need room for first byte right away\n                    if (currQuadBytes >= 4) {\n                        if (qlen >= quads.length) {\n                            _quadBuffer = quads = growArrayBy(quads, quads.length);\n                        }\n                        quads[qlen++] = currQuad;\n                        currQuad = 0;\n                        currQuadBytes = 0;\n                    }\n                    if (ch < 0x800) { // 2-byte\n                        currQuad = (currQuad << 8) | (0xc0 | (ch >> 6));\n                        ++currQuadBytes;\n                        // Second byte gets output below:\n                    } else { // 3 bytes; no need to worry about surrogates here\n                        currQuad = (currQuad << 8) | (0xe0 | (ch >> 12));\n                        ++currQuadBytes;\n                        // need room for middle byte?\n                        if (currQuadBytes >= 4) {\n                            if (qlen >= quads.length) {\n                                _quadBuffer = quads = growArrayBy(quads, quads.length);\n                            }\n                            quads[qlen++] = currQuad;\n                            currQuad = 0;\n                            currQuadBytes = 0;\n                        }\n                        currQuad = (currQuad << 8) | (0x80 | ((ch >> 6) & 0x3f));\n                        ++currQuadBytes;\n                    }\n                    // And same last byte in both cases, gets output below:\n                    ch = 0x80 | (ch & 0x3f);\n                }\n            }\n            // Ok, we have one more byte to add at any rate:\n            if (currQuadBytes < 4) {\n                ++currQuadBytes;\n                currQuad = (currQuad << 8) | ch;\n            } else {\n                if (qlen >= quads.length) {\n                    _quadBuffer = quads = growArrayBy(quads, quads.length);\n                }\n                quads[qlen++] = currQuad;\n                currQuad = ch;\n                currQuadBytes = 1;\n            }\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\" in field name\");\n                }\n            }\nch = (ch | (_inputBuffer[_inputPtr++] | 255));\n        }\n\n        if (currQuadBytes > 0) {\n            if (qlen >= quads.length) {\n                _quadBuffer = quads = growArrayBy(quads, quads.length);\n            }\n            quads[qlen++] = currQuad;\n        }\n        Name name = _symbols.findName(quads, qlen);\n        if (name == null) {\n            name = addName(quads, qlen, currQuadBytes);\n        }\n        return name;\n    }",
          "83": "    protected Name _parseApostropheFieldName()\n        throws IOException, JsonParseException\n    {\n        if (_inputPtr >= _inputEnd) {\n            if (!loadMore()) {\n                _reportInvalidEOF(\": was expecting closing '\\'' for name\");\n            }\n        }\n        int ch = _inputBuffer[_inputPtr++] & 0xFF;\n        if (ch == INT_APOSTROPHE) { // special case, ''\n            return BytesToNameCanonicalizer.getEmptyName();\n        }\n        int[] quads = _quadBuffer;\n        int qlen = 0;\n        int currQuad = 0;\n        int currQuadBytes = 0;\n\n        // Copied from parseEscapedFieldName, with minor mods:\n\n        final int[] codes = sInputCodesLatin1;\n\n        while (true) {\n            if (ch == INT_APOSTROPHE) {\n                break;\n            }\n            // additional check to skip handling of double-quotes\n            if (ch != INT_QUOTE && codes[ch] != 0) {\n                if (ch != INT_BACKSLASH) {\n                    // Unquoted white space?\n                    // As per [JACKSON-208], call can now return:\n                    _throwUnquotedSpace(ch, \"name\");\n                } else {\n                    // Nope, escape sequence\n                    ch = _decodeEscaped();\n                }\n                /* Oh crap. May need to UTF-8 (re-)encode it, if it's\n                 * beyond 7-bit ascii. Gets pretty messy.\n                 * If this happens often, may want to use different name\n                 * canonicalization to avoid these hits.\n                 */\n                if (ch > 127) {\n                    // Ok, we'll need room for first byte right away\n                    if (currQuadBytes >= 4) {\n                        if (qlen >= quads.length) {\n                            _quadBuffer = quads = growArrayBy(quads, quads.length);\n                        }\n                        quads[qlen++] = currQuad;\n                        currQuad = 0;\n                        currQuadBytes = 0;\n                    }\n                    if (ch < 0x800) { // 2-byte\n                        currQuad = (currQuad << 8) | (0xc0 | (ch >> 6));\n                        ++currQuadBytes;\n                        // Second byte gets output below:\n                    } else { // 3 bytes; no need to worry about surrogates here\n                        currQuad = (currQuad << 8) | (0xe0 | (ch >> 12));\n                        ++currQuadBytes;\n                        // need room for middle byte?\n                        if (currQuadBytes >= 4) {\n                            if (qlen >= quads.length) {\n                                _quadBuffer = quads = growArrayBy(quads, quads.length);\n                            }\n                            quads[qlen++] = currQuad;\n                            currQuad = 0;\n                            currQuadBytes = 0;\n                        }\n                        currQuad = (currQuad << 8) | (0x80 | ((ch >> 6) & 0x3f));\n                        ++currQuadBytes;\n                    }\n                    // And same last byte in both cases, gets output below:\n                    ch = 0x80 | (ch & 0x3f);\n                }\n            }\n            // Ok, we have one more byte to add at any rate:\n            if (currQuadBytes < 4) {\n                ++currQuadBytes;\n                currQuad = (currQuad << 8) | ch;\n            } else {\n                if (qlen >= quads.length) {\n                    _quadBuffer = quads = growArrayBy(quads, quads.length);\n                }\n                quads[qlen++] = currQuad;\n                currQuad = ch;\n                currQuadBytes = 1;\n            }\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\" in field name\");\n                }\n            }\nch = (_inputBuffer | (_inputBuffer[_inputPtr++] | 255));\n        }\n\n        if (currQuadBytes > 0) {\n            if (qlen >= quads.length) {\n                _quadBuffer = quads = growArrayBy(quads, quads.length);\n            }\n            quads[qlen++] = currQuad;\n        }\n        Name name = _symbols.findName(quads, qlen);\n        if (name == null) {\n            name = addName(quads, qlen, currQuadBytes);\n        }\n        return name;\n    }",
          "84": "    protected Name _parseApostropheFieldName()\n        throws IOException, JsonParseException\n    {\n        if (_inputPtr >= _inputEnd) {\n            if (!loadMore()) {\n                _reportInvalidEOF(\": was expecting closing '\\'' for name\");\n            }\n        }\n        int ch = _inputBuffer[_inputPtr++] & 0xFF;\n        if (ch == INT_APOSTROPHE) { // special case, ''\n            return BytesToNameCanonicalizer.getEmptyName();\n        }\n        int[] quads = _quadBuffer;\n        int qlen = 0;\n        int currQuad = 0;\n        int currQuadBytes = 0;\n\n        // Copied from parseEscapedFieldName, with minor mods:\n\n        final int[] codes = sInputCodesLatin1;\n\n        while (true) {\n            if (ch == INT_APOSTROPHE) {\n                break;\n            }\n            // additional check to skip handling of double-quotes\n            if (ch != INT_QUOTE && codes[ch] != 0) {\n                if (ch != INT_BACKSLASH) {\n                    // Unquoted white space?\n                    // As per [JACKSON-208], call can now return:\n                    _throwUnquotedSpace(ch, \"name\");\n                } else {\n                    // Nope, escape sequence\n                    ch = _decodeEscaped();\n                }\n                /* Oh crap. May need to UTF-8 (re-)encode it, if it's\n                 * beyond 7-bit ascii. Gets pretty messy.\n                 * If this happens often, may want to use different name\n                 * canonicalization to avoid these hits.\n                 */\n                if (ch > 127) {\n                    // Ok, we'll need room for first byte right away\n                    if (currQuadBytes >= 4) {\n                        if (qlen >= quads.length) {\n                            _quadBuffer = quads = growArrayBy(quads, quads.length);\n                        }\n                        quads[qlen++] = currQuad;\n                        currQuad = 0;\n                        currQuadBytes = 0;\n                    }\n                    if (ch < 0x800) { // 2-byte\n                        currQuad = (currQuad << 8) | (0xc0 | (ch >> 6));\n                        ++currQuadBytes;\n                        // Second byte gets output below:\n                    } else { // 3 bytes; no need to worry about surrogates here\n                        currQuad = (currQuad << 8) | (0xe0 | (ch >> 12));\n                        ++currQuadBytes;\n                        // need room for middle byte?\n                        if (currQuadBytes >= 4) {\n                            if (qlen >= quads.length) {\n                                _quadBuffer = quads = growArrayBy(quads, quads.length);\n                            }\n                            quads[qlen++] = currQuad;\n                            currQuad = 0;\n                            currQuadBytes = 0;\n                        }\n                        currQuad = (currQuad << 8) | (0x80 | ((ch >> 6) & 0x3f));\n                        ++currQuadBytes;\n                    }\n                    // And same last byte in both cases, gets output below:\n                    ch = 0x80 | (ch & 0x3f);\n                }\n            }\n            // Ok, we have one more byte to add at any rate:\n            if (currQuadBytes < 4) {\n                ++currQuadBytes;\n                currQuad = (currQuad << 8) | ch;\n            } else {\n                if (qlen >= quads.length) {\n                    _quadBuffer = quads = growArrayBy(quads, quads.length);\n                }\n                quads[qlen++] = currQuad;\n                currQuad = ch;\n                currQuadBytes = 1;\n            }\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\" in field name\");\n                }\n            }\n_reportInvalidEOF(\"null\");\n            ch = _inputBuffer[_inputPtr++] | 255;        }\n\n        if (currQuadBytes > 0) {\n            if (qlen >= quads.length) {\n                _quadBuffer = quads = growArrayBy(quads, quads.length);\n            }\n            quads[qlen++] = currQuad;\n        }\n        Name name = _symbols.findName(quads, qlen);\n        if (name == null) {\n            name = addName(quads, qlen, currQuadBytes);\n        }\n        return name;\n    }",
          "85": "    protected Name _parseApostropheFieldName()\n        throws IOException, JsonParseException\n    {\n        if (_inputPtr >= _inputEnd) {\n            if (!loadMore()) {\n                _reportInvalidEOF(\": was expecting closing '\\'' for name\");\n            }\n        }\n        int ch = _inputBuffer[_inputPtr++] & 0xFF;\n        if (ch == INT_APOSTROPHE) { // special case, ''\n            return BytesToNameCanonicalizer.getEmptyName();\n        }\n        int[] quads = _quadBuffer;\n        int qlen = 0;\n        int currQuad = 0;\n        int currQuadBytes = 0;\n\n        // Copied from parseEscapedFieldName, with minor mods:\n\n        final int[] codes = sInputCodesLatin1;\n\n        while (true) {\n            if (ch == INT_APOSTROPHE) {\n                break;\n            }\n            // additional check to skip handling of double-quotes\n            if (ch != INT_QUOTE && codes[ch] != 0) {\n                if (ch != INT_BACKSLASH) {\n                    // Unquoted white space?\n                    // As per [JACKSON-208], call can now return:\n                    _throwUnquotedSpace(ch, \"name\");\n                } else {\n                    // Nope, escape sequence\n                    ch = _decodeEscaped();\n                }\n                /* Oh crap. May need to UTF-8 (re-)encode it, if it's\n                 * beyond 7-bit ascii. Gets pretty messy.\n                 * If this happens often, may want to use different name\n                 * canonicalization to avoid these hits.\n                 */\n                if (ch > 127) {\n                    // Ok, we'll need room for first byte right away\n                    if (currQuadBytes >= 4) {\n                        if (qlen >= quads.length) {\n                            _quadBuffer = quads = growArrayBy(quads, quads.length);\n                        }\n                        quads[qlen++] = currQuad;\n                        currQuad = 0;\n                        currQuadBytes = 0;\n                    }\n                    if (ch < 0x800) { // 2-byte\n                        currQuad = (currQuad << 8) | (0xc0 | (ch >> 6));\n                        ++currQuadBytes;\n                        // Second byte gets output below:\n                    } else { // 3 bytes; no need to worry about surrogates here\n                        currQuad = (currQuad << 8) | (0xe0 | (ch >> 12));\n                        ++currQuadBytes;\n                        // need room for middle byte?\n                        if (currQuadBytes >= 4) {\n                            if (qlen >= quads.length) {\n                                _quadBuffer = quads = growArrayBy(quads, quads.length);\n                            }\n                            quads[qlen++] = currQuad;\n                            currQuad = 0;\n                            currQuadBytes = 0;\n                        }\n                        currQuad = (currQuad << 8) | (0x80 | ((ch >> 6) & 0x3f));\n                        ++currQuadBytes;\n                    }\n                    // And same last byte in both cases, gets output below:\n                    ch = 0x80 | (ch & 0x3f);\n                }\n            }\n            // Ok, we have one more byte to add at any rate:\n            if (currQuadBytes < 4) {\n                ++currQuadBytes;\n                currQuad = (currQuad << 8) | ch;\n            } else {\n                if (qlen >= quads.length) {\n                    _quadBuffer = quads = growArrayBy(quads, quads.length);\n                }\n                quads[qlen++] = currQuad;\n                currQuad = ch;\n                currQuadBytes = 1;\n            }\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\" in field name\");\n                }\n            }\nch = (_inputBuffer | _inputBuffer);\n        }\n\n        if (currQuadBytes > 0) {\n            if (qlen >= quads.length) {\n                _quadBuffer = quads = growArrayBy(quads, quads.length);\n            }\n            quads[qlen++] = currQuad;\n        }\n        Name name = _symbols.findName(quads, qlen);\n        if (name == null) {\n            name = addName(quads, qlen, currQuadBytes);\n        }\n        return name;\n    }",
          "86": "    protected Name _parseApostropheFieldName()\n        throws IOException, JsonParseException\n    {\n        if (_inputPtr >= _inputEnd) {\n            if (!loadMore()) {\n                _reportInvalidEOF(\": was expecting closing '\\'' for name\");\n            }\n        }\n        int ch = _inputBuffer[_inputPtr++] & 0xFF;\n        if (ch == INT_APOSTROPHE) { // special case, ''\n            return BytesToNameCanonicalizer.getEmptyName();\n        }\n        int[] quads = _quadBuffer;\n        int qlen = 0;\n        int currQuad = 0;\n        int currQuadBytes = 0;\n\n        // Copied from parseEscapedFieldName, with minor mods:\n\n        final int[] codes = sInputCodesLatin1;\n\n        while (true) {\n            if (ch == INT_APOSTROPHE) {\n                break;\n            }\n            // additional check to skip handling of double-quotes\n            if (ch != INT_QUOTE && codes[ch] != 0) {\n                if (ch != INT_BACKSLASH) {\n                    // Unquoted white space?\n                    // As per [JACKSON-208], call can now return:\n                    _throwUnquotedSpace(ch, \"name\");\n                } else {\n                    // Nope, escape sequence\n                    ch = _decodeEscaped();\n                }\n                /* Oh crap. May need to UTF-8 (re-)encode it, if it's\n                 * beyond 7-bit ascii. Gets pretty messy.\n                 * If this happens often, may want to use different name\n                 * canonicalization to avoid these hits.\n                 */\n                if (ch > 127) {\n                    // Ok, we'll need room for first byte right away\n                    if (currQuadBytes >= 4) {\n                        if (qlen >= quads.length) {\n                            _quadBuffer = quads = growArrayBy(quads, quads.length);\n                        }\n                        quads[qlen++] = currQuad;\n                        currQuad = 0;\n                        currQuadBytes = 0;\n                    }\n                    if (ch < 0x800) { // 2-byte\n                        currQuad = (currQuad << 8) | (0xc0 | (ch >> 6));\n                        ++currQuadBytes;\n                        // Second byte gets output below:\n                    } else { // 3 bytes; no need to worry about surrogates here\n                        currQuad = (currQuad << 8) | (0xe0 | (ch >> 12));\n                        ++currQuadBytes;\n                        // need room for middle byte?\n                        if (currQuadBytes >= 4) {\n                            if (qlen >= quads.length) {\n                                _quadBuffer = quads = growArrayBy(quads, quads.length);\n                            }\n                            quads[qlen++] = currQuad;\n                            currQuad = 0;\n                            currQuadBytes = 0;\n                        }\n                        currQuad = (currQuad << 8) | (0x80 | ((ch >> 6) & 0x3f));\n                        ++currQuadBytes;\n                    }\n                    // And same last byte in both cases, gets output below:\n                    ch = 0x80 | (ch & 0x3f);\n                }\n            }\n            // Ok, we have one more byte to add at any rate:\n            if (currQuadBytes < 4) {\n                ++currQuadBytes;\n                currQuad = (currQuad << 8) | ch;\n            } else {\n                if (qlen >= quads.length) {\n                    _quadBuffer = quads = growArrayBy(quads, quads.length);\n                }\n                quads[qlen++] = currQuad;\n                currQuad = ch;\n                currQuadBytes = 1;\n            }\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\" in field name\");\n                }\n            }\nch = (ch | _inputBuffer);\n        }\n\n        if (currQuadBytes > 0) {\n            if (qlen >= quads.length) {\n                _quadBuffer = quads = growArrayBy(quads, quads.length);\n            }\n            quads[qlen++] = currQuad;\n        }\n        Name name = _symbols.findName(quads, qlen);\n        if (name == null) {\n            name = addName(quads, qlen, currQuadBytes);\n        }\n        return name;\n    }",
          "87": "    protected Name _parseApostropheFieldName()\n        throws IOException, JsonParseException\n    {\n        if (_inputPtr >= _inputEnd) {\n            if (!loadMore()) {\n                _reportInvalidEOF(\": was expecting closing '\\'' for name\");\n            }\n        }\n        int ch = _inputBuffer[_inputPtr++] & 0xFF;\n        if (ch == INT_APOSTROPHE) { // special case, ''\n            return BytesToNameCanonicalizer.getEmptyName();\n        }\n        int[] quads = _quadBuffer;\n        int qlen = 0;\n        int currQuad = 0;\n        int currQuadBytes = 0;\n\n        // Copied from parseEscapedFieldName, with minor mods:\n\n        final int[] codes = sInputCodesLatin1;\n\n        while (true) {\n            if (ch == INT_APOSTROPHE) {\n                break;\n            }\n            // additional check to skip handling of double-quotes\n            if (ch != INT_QUOTE && codes[ch] != 0) {\n                if (ch != INT_BACKSLASH) {\n                    // Unquoted white space?\n                    // As per [JACKSON-208], call can now return:\n                    _throwUnquotedSpace(ch, \"name\");\n                } else {\n                    // Nope, escape sequence\n                    ch = _decodeEscaped();\n                }\n                /* Oh crap. May need to UTF-8 (re-)encode it, if it's\n                 * beyond 7-bit ascii. Gets pretty messy.\n                 * If this happens often, may want to use different name\n                 * canonicalization to avoid these hits.\n                 */\n                if (ch > 127) {\n                    // Ok, we'll need room for first byte right away\n                    if (currQuadBytes >= 4) {\n                        if (qlen >= quads.length) {\n                            _quadBuffer = quads = growArrayBy(quads, quads.length);\n                        }\n                        quads[qlen++] = currQuad;\n                        currQuad = 0;\n                        currQuadBytes = 0;\n                    }\n                    if (ch < 0x800) { // 2-byte\n                        currQuad = (currQuad << 8) | (0xc0 | (ch >> 6));\n                        ++currQuadBytes;\n                        // Second byte gets output below:\n                    } else { // 3 bytes; no need to worry about surrogates here\n                        currQuad = (currQuad << 8) | (0xe0 | (ch >> 12));\n                        ++currQuadBytes;\n                        // need room for middle byte?\n                        if (currQuadBytes >= 4) {\n                            if (qlen >= quads.length) {\n                                _quadBuffer = quads = growArrayBy(quads, quads.length);\n                            }\n                            quads[qlen++] = currQuad;\n                            currQuad = 0;\n                            currQuadBytes = 0;\n                        }\n                        currQuad = (currQuad << 8) | (0x80 | ((ch >> 6) & 0x3f));\n                        ++currQuadBytes;\n                    }\n                    // And same last byte in both cases, gets output below:\n                    ch = 0x80 | (ch & 0x3f);\n                }\n            }\n            // Ok, we have one more byte to add at any rate:\n            if (currQuadBytes < 4) {\n                ++currQuadBytes;\n                currQuad = (currQuad << 8) | ch;\n            } else {\n                if (qlen >= quads.length) {\n                    _quadBuffer = quads = growArrayBy(quads, quads.length);\n                }\n                quads[qlen++] = currQuad;\n                currQuad = ch;\n                currQuadBytes = 1;\n            }\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\" in field name\");\n                }\n            }\nch = (_inputBuffer | _inputBuffer[_inputPtr++]);\n        }\n\n        if (currQuadBytes > 0) {\n            if (qlen >= quads.length) {\n                _quadBuffer = quads = growArrayBy(quads, quads.length);\n            }\n            quads[qlen++] = currQuad;\n        }\n        Name name = _symbols.findName(quads, qlen);\n        if (name == null) {\n            name = addName(quads, qlen, currQuadBytes);\n        }\n        return name;\n    }",
          "88": "    protected Name _parseApostropheFieldName()\n        throws IOException, JsonParseException\n    {\n        if (_inputPtr >= _inputEnd) {\n            if (!loadMore()) {\n                _reportInvalidEOF(\": was expecting closing '\\'' for name\");\n            }\n        }\n        int ch = _inputBuffer[_inputPtr++] & 0xFF;\n        if (ch == INT_APOSTROPHE) { // special case, ''\n            return BytesToNameCanonicalizer.getEmptyName();\n        }\n        int[] quads = _quadBuffer;\n        int qlen = 0;\n        int currQuad = 0;\n        int currQuadBytes = 0;\n\n        // Copied from parseEscapedFieldName, with minor mods:\n\n        final int[] codes = sInputCodesLatin1;\n\n        while (true) {\n            if (ch == INT_APOSTROPHE) {\n                break;\n            }\n            // additional check to skip handling of double-quotes\n            if (ch != INT_QUOTE && codes[ch] != 0) {\n                if (ch != INT_BACKSLASH) {\n                    // Unquoted white space?\n                    // As per [JACKSON-208], call can now return:\n                    _throwUnquotedSpace(ch, \"name\");\n                } else {\n                    // Nope, escape sequence\n                    ch = _decodeEscaped();\n                }\n                /* Oh crap. May need to UTF-8 (re-)encode it, if it's\n                 * beyond 7-bit ascii. Gets pretty messy.\n                 * If this happens often, may want to use different name\n                 * canonicalization to avoid these hits.\n                 */\n                if (ch > 127) {\n                    // Ok, we'll need room for first byte right away\n                    if (currQuadBytes >= 4) {\n                        if (qlen >= quads.length) {\n                            _quadBuffer = quads = growArrayBy(quads, quads.length);\n                        }\n                        quads[qlen++] = currQuad;\n                        currQuad = 0;\n                        currQuadBytes = 0;\n                    }\n                    if (ch < 0x800) { // 2-byte\n                        currQuad = (currQuad << 8) | (0xc0 | (ch >> 6));\n                        ++currQuadBytes;\n                        // Second byte gets output below:\n                    } else { // 3 bytes; no need to worry about surrogates here\n                        currQuad = (currQuad << 8) | (0xe0 | (ch >> 12));\n                        ++currQuadBytes;\n                        // need room for middle byte?\n                        if (currQuadBytes >= 4) {\n                            if (qlen >= quads.length) {\n                                _quadBuffer = quads = growArrayBy(quads, quads.length);\n                            }\n                            quads[qlen++] = currQuad;\n                            currQuad = 0;\n                            currQuadBytes = 0;\n                        }\n                        currQuad = (currQuad << 8) | (0x80 | ((ch >> 6) & 0x3f));\n                        ++currQuadBytes;\n                    }\n                    // And same last byte in both cases, gets output below:\n                    ch = 0x80 | (ch & 0x3f);\n                }\n            }\n            // Ok, we have one more byte to add at any rate:\n            if (currQuadBytes < 4) {\n                ++currQuadBytes;\n                currQuad = (currQuad << 8) | ch;\n            } else {\n                if (qlen >= quads.length) {\n                    _quadBuffer = quads = growArrayBy(quads, quads.length);\n                }\n                quads[qlen++] = currQuad;\n                currQuad = ch;\n                currQuadBytes = 1;\n            }\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\" in field name\");\n                }\n            }\nbreak;\n            ch = _inputBuffer[_inputPtr++] | 255;        }\n\n        if (currQuadBytes > 0) {\n            if (qlen >= quads.length) {\n                _quadBuffer = quads = growArrayBy(quads, quads.length);\n            }\n            quads[qlen++] = currQuad;\n        }\n        Name name = _symbols.findName(quads, qlen);\n        if (name == null) {\n            name = addName(quads, qlen, currQuadBytes);\n        }\n        return name;\n    }",
          "89": "    protected Name _parseApostropheFieldName()\n        throws IOException, JsonParseException\n    {\n        if (_inputPtr >= _inputEnd) {\n            if (!loadMore()) {\n                _reportInvalidEOF(\": was expecting closing '\\'' for name\");\n            }\n        }\n        int ch = _inputBuffer[_inputPtr++] & 0xFF;\n        if (ch == INT_APOSTROPHE) { // special case, ''\n            return BytesToNameCanonicalizer.getEmptyName();\n        }\n        int[] quads = _quadBuffer;\n        int qlen = 0;\n        int currQuad = 0;\n        int currQuadBytes = 0;\n\n        // Copied from parseEscapedFieldName, with minor mods:\n\n        final int[] codes = sInputCodesLatin1;\n\n        while (true) {\n            if (ch == INT_APOSTROPHE) {\n                break;\n            }\n            // additional check to skip handling of double-quotes\n            if (ch != INT_QUOTE && codes[ch] != 0) {\n                if (ch != INT_BACKSLASH) {\n                    // Unquoted white space?\n                    // As per [JACKSON-208], call can now return:\n                    _throwUnquotedSpace(ch, \"name\");\n                } else {\n                    // Nope, escape sequence\n                    ch = _decodeEscaped();\n                }\n                /* Oh crap. May need to UTF-8 (re-)encode it, if it's\n                 * beyond 7-bit ascii. Gets pretty messy.\n                 * If this happens often, may want to use different name\n                 * canonicalization to avoid these hits.\n                 */\n                if (ch > 127) {\n                    // Ok, we'll need room for first byte right away\n                    if (currQuadBytes >= 4) {\n                        if (qlen >= quads.length) {\n                            _quadBuffer = quads = growArrayBy(quads, quads.length);\n                        }\n                        quads[qlen++] = currQuad;\n                        currQuad = 0;\n                        currQuadBytes = 0;\n                    }\n                    if (ch < 0x800) { // 2-byte\n                        currQuad = (currQuad << 8) | (0xc0 | (ch >> 6));\n                        ++currQuadBytes;\n                        // Second byte gets output below:\n                    } else { // 3 bytes; no need to worry about surrogates here\n                        currQuad = (currQuad << 8) | (0xe0 | (ch >> 12));\n                        ++currQuadBytes;\n                        // need room for middle byte?\n                        if (currQuadBytes >= 4) {\n                            if (qlen >= quads.length) {\n                                _quadBuffer = quads = growArrayBy(quads, quads.length);\n                            }\n                            quads[qlen++] = currQuad;\n                            currQuad = 0;\n                            currQuadBytes = 0;\n                        }\n                        currQuad = (currQuad << 8) | (0x80 | ((ch >> 6) & 0x3f));\n                        ++currQuadBytes;\n                    }\n                    // And same last byte in both cases, gets output below:\n                    ch = 0x80 | (ch & 0x3f);\n                }\n            }\n            // Ok, we have one more byte to add at any rate:\n            if (currQuadBytes < 4) {\n                ++currQuadBytes;\n                currQuad = (currQuad << 8) | ch;\n            } else {\n                if (qlen >= quads.length) {\n                    _quadBuffer = quads = growArrayBy(quads, quads.length);\n                }\n                quads[qlen++] = currQuad;\n                currQuad = ch;\n                currQuadBytes = 1;\n            }\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\" in field name\");\n                }\n            }\nch = ((ch | 255) | 255);\n        }\n\n        if (currQuadBytes > 0) {\n            if (qlen >= quads.length) {\n                _quadBuffer = quads = growArrayBy(quads, quads.length);\n            }\n            quads[qlen++] = currQuad;\n        }\n        Name name = _symbols.findName(quads, qlen);\n        if (name == null) {\n            name = addName(quads, qlen, currQuadBytes);\n        }\n        return name;\n    }",
          "90": "    protected Name _parseApostropheFieldName()\n        throws IOException, JsonParseException\n    {\n        if (_inputPtr >= _inputEnd) {\n            if (!loadMore()) {\n                _reportInvalidEOF(\": was expecting closing '\\'' for name\");\n            }\n        }\n        int ch = _inputBuffer[_inputPtr++] & 0xFF;\n        if (ch == INT_APOSTROPHE) { // special case, ''\n            return BytesToNameCanonicalizer.getEmptyName();\n        }\n        int[] quads = _quadBuffer;\n        int qlen = 0;\n        int currQuad = 0;\n        int currQuadBytes = 0;\n\n        // Copied from parseEscapedFieldName, with minor mods:\n\n        final int[] codes = sInputCodesLatin1;\n\n        while (true) {\n            if (ch == INT_APOSTROPHE) {\n                break;\n            }\n            // additional check to skip handling of double-quotes\n            if (ch != INT_QUOTE && codes[ch] != 0) {\n                if (ch != INT_BACKSLASH) {\n                    // Unquoted white space?\n                    // As per [JACKSON-208], call can now return:\n                    _throwUnquotedSpace(ch, \"name\");\n                } else {\n                    // Nope, escape sequence\n                    ch = _decodeEscaped();\n                }\n                /* Oh crap. May need to UTF-8 (re-)encode it, if it's\n                 * beyond 7-bit ascii. Gets pretty messy.\n                 * If this happens often, may want to use different name\n                 * canonicalization to avoid these hits.\n                 */\n                if (ch > 127) {\n                    // Ok, we'll need room for first byte right away\n                    if (currQuadBytes >= 4) {\n                        if (qlen >= quads.length) {\n                            _quadBuffer = quads = growArrayBy(quads, quads.length);\n                        }\n                        quads[qlen++] = currQuad;\n                        currQuad = 0;\n                        currQuadBytes = 0;\n                    }\n                    if (ch < 0x800) { // 2-byte\n                        currQuad = (currQuad << 8) | (0xc0 | (ch >> 6));\n                        ++currQuadBytes;\n                        // Second byte gets output below:\n                    } else { // 3 bytes; no need to worry about surrogates here\n                        currQuad = (currQuad << 8) | (0xe0 | (ch >> 12));\n                        ++currQuadBytes;\n                        // need room for middle byte?\n                        if (currQuadBytes >= 4) {\n                            if (qlen >= quads.length) {\n                                _quadBuffer = quads = growArrayBy(quads, quads.length);\n                            }\n                            quads[qlen++] = currQuad;\n                            currQuad = 0;\n                            currQuadBytes = 0;\n                        }\n                        currQuad = (currQuad << 8) | (0x80 | ((ch >> 6) & 0x3f));\n                        ++currQuadBytes;\n                    }\n                    // And same last byte in both cases, gets output below:\n                    ch = 0x80 | (ch & 0x3f);\n                }\n            }\n            // Ok, we have one more byte to add at any rate:\n            if (currQuadBytes < 4) {\n                ++currQuadBytes;\n                currQuad = (currQuad << 8) | ch;\n            } else {\n                if (qlen >= quads.length) {\n                    _quadBuffer = quads = growArrayBy(quads, quads.length);\n                }\n                quads[qlen++] = currQuad;\n                currQuad = ch;\n                currQuadBytes = 1;\n            }\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\" in field name\");\n                }\n            }\nch = ((_inputBuffer | 255) | 255);\n        }\n\n        if (currQuadBytes > 0) {\n            if (qlen >= quads.length) {\n                _quadBuffer = quads = growArrayBy(quads, quads.length);\n            }\n            quads[qlen++] = currQuad;\n        }\n        Name name = _symbols.findName(quads, qlen);\n        if (name == null) {\n            name = addName(quads, qlen, currQuadBytes);\n        }\n        return name;\n    }",
          "91": "    protected Name _parseApostropheFieldName()\n        throws IOException, JsonParseException\n    {\n        if (_inputPtr >= _inputEnd) {\n            if (!loadMore()) {\n                _reportInvalidEOF(\": was expecting closing '\\'' for name\");\n            }\n        }\n        int ch = _inputBuffer[_inputPtr++] & 0xFF;\n        if (ch == INT_APOSTROPHE) { // special case, ''\n            return BytesToNameCanonicalizer.getEmptyName();\n        }\n        int[] quads = _quadBuffer;\n        int qlen = 0;\n        int currQuad = 0;\n        int currQuadBytes = 0;\n\n        // Copied from parseEscapedFieldName, with minor mods:\n\n        final int[] codes = sInputCodesLatin1;\n\n        while (true) {\n            if (ch == INT_APOSTROPHE) {\n                break;\n            }\n            // additional check to skip handling of double-quotes\n            if (ch != INT_QUOTE && codes[ch] != 0) {\n                if (ch != INT_BACKSLASH) {\n                    // Unquoted white space?\n                    // As per [JACKSON-208], call can now return:\n                    _throwUnquotedSpace(ch, \"name\");\n                } else {\n                    // Nope, escape sequence\n                    ch = _decodeEscaped();\n                }\n                /* Oh crap. May need to UTF-8 (re-)encode it, if it's\n                 * beyond 7-bit ascii. Gets pretty messy.\n                 * If this happens often, may want to use different name\n                 * canonicalization to avoid these hits.\n                 */\n                if (ch > 127) {\n                    // Ok, we'll need room for first byte right away\n                    if (currQuadBytes >= 4) {\n                        if (qlen >= quads.length) {\n                            _quadBuffer = quads = growArrayBy(quads, quads.length);\n                        }\n                        quads[qlen++] = currQuad;\n                        currQuad = 0;\n                        currQuadBytes = 0;\n                    }\n                    if (ch < 0x800) { // 2-byte\n                        currQuad = (currQuad << 8) | (0xc0 | (ch >> 6));\n                        ++currQuadBytes;\n                        // Second byte gets output below:\n                    } else { // 3 bytes; no need to worry about surrogates here\n                        currQuad = (currQuad << 8) | (0xe0 | (ch >> 12));\n                        ++currQuadBytes;\n                        // need room for middle byte?\n                        if (currQuadBytes >= 4) {\n                            if (qlen >= quads.length) {\n                                _quadBuffer = quads = growArrayBy(quads, quads.length);\n                            }\n                            quads[qlen++] = currQuad;\n                            currQuad = 0;\n                            currQuadBytes = 0;\n                        }\n                        currQuad = (currQuad << 8) | (0x80 | ((ch >> 6) & 0x3f));\n                        ++currQuadBytes;\n                    }\n                    // And same last byte in both cases, gets output below:\n                    ch = 0x80 | (ch & 0x3f);\n                }\n            }\n            // Ok, we have one more byte to add at any rate:\n            if (currQuadBytes < 4) {\n                ++currQuadBytes;\n                currQuad = (currQuad << 8) | ch;\n            } else {\n                if (qlen >= quads.length) {\n                    _quadBuffer = quads = growArrayBy(quads, quads.length);\n                }\n                quads[qlen++] = currQuad;\n                currQuad = ch;\n                currQuadBytes = 1;\n            }\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\" in field name\");\n                }\n            }\ncontinue;\n            ch = _inputBuffer[_inputPtr++] | 255;        }\n\n        if (currQuadBytes > 0) {\n            if (qlen >= quads.length) {\n                _quadBuffer = quads = growArrayBy(quads, quads.length);\n            }\n            quads[qlen++] = currQuad;\n        }\n        Name name = _symbols.findName(quads, qlen);\n        if (name == null) {\n            name = addName(quads, qlen, currQuadBytes);\n        }\n        return name;\n    }",
          "92": "    protected Name _parseApostropheFieldName()\n        throws IOException, JsonParseException\n    {\n        if (_inputPtr >= _inputEnd) {\n            if (!loadMore()) {\n                _reportInvalidEOF(\": was expecting closing '\\'' for name\");\n            }\n        }\n        int ch = _inputBuffer[_inputPtr++] & 0xFF;\n        if (ch == INT_APOSTROPHE) { // special case, ''\n            return BytesToNameCanonicalizer.getEmptyName();\n        }\n        int[] quads = _quadBuffer;\n        int qlen = 0;\n        int currQuad = 0;\n        int currQuadBytes = 0;\n\n        // Copied from parseEscapedFieldName, with minor mods:\n\n        final int[] codes = sInputCodesLatin1;\n\n        while (true) {\n            if (ch == INT_APOSTROPHE) {\n                break;\n            }\n            // additional check to skip handling of double-quotes\n            if (ch != INT_QUOTE && codes[ch] != 0) {\n                if (ch != INT_BACKSLASH) {\n                    // Unquoted white space?\n                    // As per [JACKSON-208], call can now return:\n                    _throwUnquotedSpace(ch, \"name\");\n                } else {\n                    // Nope, escape sequence\n                    ch = _decodeEscaped();\n                }\n                /* Oh crap. May need to UTF-8 (re-)encode it, if it's\n                 * beyond 7-bit ascii. Gets pretty messy.\n                 * If this happens often, may want to use different name\n                 * canonicalization to avoid these hits.\n                 */\n                if (ch > 127) {\n                    // Ok, we'll need room for first byte right away\n                    if (currQuadBytes >= 4) {\n                        if (qlen >= quads.length) {\n                            _quadBuffer = quads = growArrayBy(quads, quads.length);\n                        }\n                        quads[qlen++] = currQuad;\n                        currQuad = 0;\n                        currQuadBytes = 0;\n                    }\n                    if (ch < 0x800) { // 2-byte\n                        currQuad = (currQuad << 8) | (0xc0 | (ch >> 6));\n                        ++currQuadBytes;\n                        // Second byte gets output below:\n                    } else { // 3 bytes; no need to worry about surrogates here\n                        currQuad = (currQuad << 8) | (0xe0 | (ch >> 12));\n                        ++currQuadBytes;\n                        // need room for middle byte?\n                        if (currQuadBytes >= 4) {\n                            if (qlen >= quads.length) {\n                                _quadBuffer = quads = growArrayBy(quads, quads.length);\n                            }\n                            quads[qlen++] = currQuad;\n                            currQuad = 0;\n                            currQuadBytes = 0;\n                        }\n                        currQuad = (currQuad << 8) | (0x80 | ((ch >> 6) & 0x3f));\n                        ++currQuadBytes;\n                    }\n                    // And same last byte in both cases, gets output below:\n                    ch = 0x80 | (ch & 0x3f);\n                }\n            }\n            // Ok, we have one more byte to add at any rate:\n            if (currQuadBytes < 4) {\n                ++currQuadBytes;\n                currQuad = (currQuad << 8) | ch;\n            } else {\n                if (qlen >= quads.length) {\n                    _quadBuffer = quads = growArrayBy(quads, quads.length);\n                }\n                quads[qlen++] = currQuad;\n                currQuad = ch;\n                currQuadBytes = 1;\n            }\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\" in field name\");\n                }\n            }\nch = (ch | (_inputBuffer | 255));\n        }\n\n        if (currQuadBytes > 0) {\n            if (qlen >= quads.length) {\n                _quadBuffer = quads = growArrayBy(quads, quads.length);\n            }\n            quads[qlen++] = currQuad;\n        }\n        Name name = _symbols.findName(quads, qlen);\n        if (name == null) {\n            name = addName(quads, qlen, currQuadBytes);\n        }\n        return name;\n    }"
}