{
          "0": "    protected double[] fst(double[] f) throws MathIllegalArgumentException {\n\n        final double[] transformed = new double[f.length];\n\n        if (!ArithmeticUtils.isPowerOfTwo(f.length)) {\n            throw new MathIllegalArgumentException(\n                    LocalizedFormats.NOT_POWER_OF_TWO_CONSIDER_PADDING,\n                    Integer.valueOf(f.length));\n        }\n        if (f[0] != 0.0) {\n            throw new MathIllegalArgumentException(\n                    LocalizedFormats.FIRST_ELEMENT_NOT_ZERO,\n                    Double.valueOf(f[0]));\n        }\n        final int n = f.length;\n        if (n == 1) {       // trivial case\n            transformed[0] = 0.0;\n            return transformed;\n        }\n\n        // construct a new array and perform FFT on it\n        final double[] x = new double[n];\n        x[0] = 0.0;\nf[(n >> 1)] = (2.0 * f[(n << 1)]);\n        for (int i = 1; i < (n >> 1); i++) {\n            final double a = FastMath.sin(i * FastMath.PI / n) * (f[i] + f[n - i]);\n            final double b = 0.5 * (f[i] - f[n - i]);\n            x[i]     = a + b;\n            x[n - i] = a - b;\n        }\n        FastFourierTransformer transformer;\n        transformer = new FastFourierTransformer(DftNormalization.STANDARD);\n        Complex[] y = transformer.transform(x, TransformType.FORWARD);\n\n        // reconstruct the FST result for the original array\n        transformed[0] = 0.0;\n        transformed[1] = 0.5 * y[0].getReal();\n        for (int i = 1; i < (n >> 1); i++) {\n            transformed[2 * i]     = -y[i].getImaginary();\n            transformed[2 * i + 1] = y[i].getReal() + transformed[2 * i - 1];\n        }\n\n        return transformed;\n    }",
          "1": "    protected double[] fst(double[] f) throws MathIllegalArgumentException {\n\n        final double[] transformed = new double[f.length];\n\n        if (!ArithmeticUtils.isPowerOfTwo(f.length)) {\n            throw new MathIllegalArgumentException(\n                    LocalizedFormats.NOT_POWER_OF_TWO_CONSIDER_PADDING,\n                    Integer.valueOf(f.length));\n        }\n        if (f[0] != 0.0) {\n            throw new MathIllegalArgumentException(\n                    LocalizedFormats.FIRST_ELEMENT_NOT_ZERO,\n                    Double.valueOf(f[0]));\n        }\n        final int n = f.length;\n        if (n == 1) {       // trivial case\n            transformed[0] = 0.0;\n            return transformed;\n        }\n\n        // construct a new array and perform FFT on it\n        final double[] x = new double[n];\n        x[0] = 0.0;\nx[(n >> 1)] = (2.0 * f[(n >> 1)]);\n        for (int i = 1; i < (n >> 1); i++) {\n            final double a = FastMath.sin(i * FastMath.PI / n) * (f[i] + f[n - i]);\n            final double b = 0.5 * (f[i] - f[n - i]);\n            x[i]     = a + b;\n            x[n - i] = a - b;\n        }\n        FastFourierTransformer transformer;\n        transformer = new FastFourierTransformer(DftNormalization.STANDARD);\n        Complex[] y = transformer.transform(x, TransformType.FORWARD);\n\n        // reconstruct the FST result for the original array\n        transformed[0] = 0.0;\n        transformed[1] = 0.5 * y[0].getReal();\n        for (int i = 1; i < (n >> 1); i++) {\n            transformed[2 * i]     = -y[i].getImaginary();\n            transformed[2 * i + 1] = y[i].getReal() + transformed[2 * i - 1];\n        }\n\n        return transformed;\n    }",
          "2": "    protected double[] fst(double[] f) throws MathIllegalArgumentException {\n\n        final double[] transformed = new double[f.length];\n\n        if (!ArithmeticUtils.isPowerOfTwo(f.length)) {\n            throw new MathIllegalArgumentException(\n                    LocalizedFormats.NOT_POWER_OF_TWO_CONSIDER_PADDING,\n                    Integer.valueOf(f.length));\n        }\n        if (f[0] != 0.0) {\n            throw new MathIllegalArgumentException(\n                    LocalizedFormats.FIRST_ELEMENT_NOT_ZERO,\n                    Double.valueOf(f[0]));\n        }\n        final int n = f.length;\n        if (n == 1) {       // trivial case\n            transformed[0] = 0.0;\n            return transformed;\n        }\n\n        // construct a new array and perform FFT on it\n        final double[] x = new double[n];\n        x[0] = 0.0;\nx[(n >> 1)] = (2.0 * f[(n << 1)]);\n        for (int i = 1; i < (n >> 1); i++) {\n            final double a = FastMath.sin(i * FastMath.PI / n) * (f[i] + f[n - i]);\n            final double b = 0.5 * (f[i] - f[n - i]);\n            x[i]     = a + b;\n            x[n - i] = a - b;\n        }\n        FastFourierTransformer transformer;\n        transformer = new FastFourierTransformer(DftNormalization.STANDARD);\n        Complex[] y = transformer.transform(x, TransformType.FORWARD);\n\n        // reconstruct the FST result for the original array\n        transformed[0] = 0.0;\n        transformed[1] = 0.5 * y[0].getReal();\n        for (int i = 1; i < (n >> 1); i++) {\n            transformed[2 * i]     = -y[i].getImaginary();\n            transformed[2 * i + 1] = y[i].getReal() + transformed[2 * i - 1];\n        }\n\n        return transformed;\n    }",
          "3": "    protected double[] fst(double[] f) throws MathIllegalArgumentException {\n\n        final double[] transformed = new double[f.length];\n\n        if (!ArithmeticUtils.isPowerOfTwo(f.length)) {\n            throw new MathIllegalArgumentException(\n                    LocalizedFormats.NOT_POWER_OF_TWO_CONSIDER_PADDING,\n                    Integer.valueOf(f.length));\n        }\n        if (f[0] != 0.0) {\n            throw new MathIllegalArgumentException(\n                    LocalizedFormats.FIRST_ELEMENT_NOT_ZERO,\n                    Double.valueOf(f[0]));\n        }\n        final int n = f.length;\n        if (n == 1) {       // trivial case\n            transformed[0] = 0.0;\n            return transformed;\n        }\n\n        // construct a new array and perform FFT on it\n        final double[] x = new double[n];\n        x[0] = 0.0;\nf[(n << 1)] = (2.0 * f[(n << 1)]);\n        for (int i = 1; i < (n >> 1); i++) {\n            final double a = FastMath.sin(i * FastMath.PI / n) * (f[i] + f[n - i]);\n            final double b = 0.5 * (f[i] - f[n - i]);\n            x[i]     = a + b;\n            x[n - i] = a - b;\n        }\n        FastFourierTransformer transformer;\n        transformer = new FastFourierTransformer(DftNormalization.STANDARD);\n        Complex[] y = transformer.transform(x, TransformType.FORWARD);\n\n        // reconstruct the FST result for the original array\n        transformed[0] = 0.0;\n        transformed[1] = 0.5 * y[0].getReal();\n        for (int i = 1; i < (n >> 1); i++) {\n            transformed[2 * i]     = -y[i].getImaginary();\n            transformed[2 * i + 1] = y[i].getReal() + transformed[2 * i - 1];\n        }\n\n        return transformed;\n    }",
          "4": "    protected double[] fst(double[] f) throws MathIllegalArgumentException {\n\n        final double[] transformed = new double[f.length];\n\n        if (!ArithmeticUtils.isPowerOfTwo(f.length)) {\n            throw new MathIllegalArgumentException(\n                    LocalizedFormats.NOT_POWER_OF_TWO_CONSIDER_PADDING,\n                    Integer.valueOf(f.length));\n        }\n        if (f[0] != 0.0) {\n            throw new MathIllegalArgumentException(\n                    LocalizedFormats.FIRST_ELEMENT_NOT_ZERO,\n                    Double.valueOf(f[0]));\n        }\n        final int n = f.length;\n        if (n == 1) {       // trivial case\n            transformed[0] = 0.0;\n            return transformed;\n        }\n\n        // construct a new array and perform FFT on it\n        final double[] x = new double[n];\n        x[0] = 0.0;\nx[(n >> 1)] = (2.0 * f);\n        for (int i = 1; i < (n >> 1); i++) {\n            final double a = FastMath.sin(i * FastMath.PI / n) * (f[i] + f[n - i]);\n            final double b = 0.5 * (f[i] - f[n - i]);\n            x[i]     = a + b;\n            x[n - i] = a - b;\n        }\n        FastFourierTransformer transformer;\n        transformer = new FastFourierTransformer(DftNormalization.STANDARD);\n        Complex[] y = transformer.transform(x, TransformType.FORWARD);\n\n        // reconstruct the FST result for the original array\n        transformed[0] = 0.0;\n        transformed[1] = 0.5 * y[0].getReal();\n        for (int i = 1; i < (n >> 1); i++) {\n            transformed[2 * i]     = -y[i].getImaginary();\n            transformed[2 * i + 1] = y[i].getReal() + transformed[2 * i - 1];\n        }\n\n        return transformed;\n    }",
          "5": "    protected double[] fst(double[] f) throws MathIllegalArgumentException {\n\n        final double[] transformed = new double[f.length];\n\n        if (!ArithmeticUtils.isPowerOfTwo(f.length)) {\n            throw new MathIllegalArgumentException(\n                    LocalizedFormats.NOT_POWER_OF_TWO_CONSIDER_PADDING,\n                    Integer.valueOf(f.length));\n        }\n        if (f[0] != 0.0) {\n            throw new MathIllegalArgumentException(\n                    LocalizedFormats.FIRST_ELEMENT_NOT_ZERO,\n                    Double.valueOf(f[0]));\n        }\n        final int n = f.length;\n        if (n == 1) {       // trivial case\n            transformed[0] = 0.0;\n            return transformed;\n        }\n\n        // construct a new array and perform FFT on it\n        final double[] x = new double[n];\n        x[0] = 0.0;\nf = (2.0 * f[(n << 1)]);\n        for (int i = 1; i < (n >> 1); i++) {\n            final double a = FastMath.sin(i * FastMath.PI / n) * (f[i] + f[n - i]);\n            final double b = 0.5 * (f[i] - f[n - i]);\n            x[i]     = a + b;\n            x[n - i] = a - b;\n        }\n        FastFourierTransformer transformer;\n        transformer = new FastFourierTransformer(DftNormalization.STANDARD);\n        Complex[] y = transformer.transform(x, TransformType.FORWARD);\n\n        // reconstruct the FST result for the original array\n        transformed[0] = 0.0;\n        transformed[1] = 0.5 * y[0].getReal();\n        for (int i = 1; i < (n >> 1); i++) {\n            transformed[2 * i]     = -y[i].getImaginary();\n            transformed[2 * i + 1] = y[i].getReal() + transformed[2 * i - 1];\n        }\n\n        return transformed;\n    }",
          "6": "    protected double[] fst(double[] f) throws MathIllegalArgumentException {\n\n        final double[] transformed = new double[f.length];\n\n        if (!ArithmeticUtils.isPowerOfTwo(f.length)) {\n            throw new MathIllegalArgumentException(\n                    LocalizedFormats.NOT_POWER_OF_TWO_CONSIDER_PADDING,\n                    Integer.valueOf(f.length));\n        }\n        if (f[0] != 0.0) {\n            throw new MathIllegalArgumentException(\n                    LocalizedFormats.FIRST_ELEMENT_NOT_ZERO,\n                    Double.valueOf(f[0]));\n        }\n        final int n = f.length;\n        if (n == 1) {       // trivial case\n            transformed[0] = 0.0;\n            return transformed;\n        }\n\n        // construct a new array and perform FFT on it\n        final double[] x = new double[n];\n        x[0] = 0.0;\nx[(n >> 1)] = (2.0 * x[(n >> 1)]);\n        for (int i = 1; i < (n >> 1); i++) {\n            final double a = FastMath.sin(i * FastMath.PI / n) * (f[i] + f[n - i]);\n            final double b = 0.5 * (f[i] - f[n - i]);\n            x[i]     = a + b;\n            x[n - i] = a - b;\n        }\n        FastFourierTransformer transformer;\n        transformer = new FastFourierTransformer(DftNormalization.STANDARD);\n        Complex[] y = transformer.transform(x, TransformType.FORWARD);\n\n        // reconstruct the FST result for the original array\n        transformed[0] = 0.0;\n        transformed[1] = 0.5 * y[0].getReal();\n        for (int i = 1; i < (n >> 1); i++) {\n            transformed[2 * i]     = -y[i].getImaginary();\n            transformed[2 * i + 1] = y[i].getReal() + transformed[2 * i - 1];\n        }\n\n        return transformed;\n    }",
          "7": "    protected double[] fst(double[] f) throws MathIllegalArgumentException {\n\n        final double[] transformed = new double[f.length];\n\n        if (!ArithmeticUtils.isPowerOfTwo(f.length)) {\n            throw new MathIllegalArgumentException(\n                    LocalizedFormats.NOT_POWER_OF_TWO_CONSIDER_PADDING,\n                    Integer.valueOf(f.length));\n        }\n        if (f[0] != 0.0) {\n            throw new MathIllegalArgumentException(\n                    LocalizedFormats.FIRST_ELEMENT_NOT_ZERO,\n                    Double.valueOf(f[0]));\n        }\n        final int n = f.length;\n        if (n == 1) {       // trivial case\n            transformed[0] = 0.0;\n            return transformed;\n        }\n\n        // construct a new array and perform FFT on it\n        final double[] x = new double[n];\n        x[0] = 0.0;\nx[(n >> 1)] = (2.0 * x);\n        for (int i = 1; i < (n >> 1); i++) {\n            final double a = FastMath.sin(i * FastMath.PI / n) * (f[i] + f[n - i]);\n            final double b = 0.5 * (f[i] - f[n - i]);\n            x[i]     = a + b;\n            x[n - i] = a - b;\n        }\n        FastFourierTransformer transformer;\n        transformer = new FastFourierTransformer(DftNormalization.STANDARD);\n        Complex[] y = transformer.transform(x, TransformType.FORWARD);\n\n        // reconstruct the FST result for the original array\n        transformed[0] = 0.0;\n        transformed[1] = 0.5 * y[0].getReal();\n        for (int i = 1; i < (n >> 1); i++) {\n            transformed[2 * i]     = -y[i].getImaginary();\n            transformed[2 * i + 1] = y[i].getReal() + transformed[2 * i - 1];\n        }\n\n        return transformed;\n    }",
          "8": "    protected double[] fst(double[] f) throws MathIllegalArgumentException {\n\n        final double[] transformed = new double[f.length];\n\n        if (!ArithmeticUtils.isPowerOfTwo(f.length)) {\n            throw new MathIllegalArgumentException(\n                    LocalizedFormats.NOT_POWER_OF_TWO_CONSIDER_PADDING,\n                    Integer.valueOf(f.length));\n        }\n        if (f[0] != 0.0) {\n            throw new MathIllegalArgumentException(\n                    LocalizedFormats.FIRST_ELEMENT_NOT_ZERO,\n                    Double.valueOf(f[0]));\n        }\n        final int n = f.length;\n        if (n == 1) {       // trivial case\n            transformed[0] = 0.0;\n            return transformed;\n        }\n\n        // construct a new array and perform FFT on it\n        final double[] x = new double[n];\n        x[0] = 0.0;\nx = (2.0 * f[(n << 1)]);\n        for (int i = 1; i < (n >> 1); i++) {\n            final double a = FastMath.sin(i * FastMath.PI / n) * (f[i] + f[n - i]);\n            final double b = 0.5 * (f[i] - f[n - i]);\n            x[i]     = a + b;\n            x[n - i] = a - b;\n        }\n        FastFourierTransformer transformer;\n        transformer = new FastFourierTransformer(DftNormalization.STANDARD);\n        Complex[] y = transformer.transform(x, TransformType.FORWARD);\n\n        // reconstruct the FST result for the original array\n        transformed[0] = 0.0;\n        transformed[1] = 0.5 * y[0].getReal();\n        for (int i = 1; i < (n >> 1); i++) {\n            transformed[2 * i]     = -y[i].getImaginary();\n            transformed[2 * i + 1] = y[i].getReal() + transformed[2 * i - 1];\n        }\n\n        return transformed;\n    }",
          "9": "    protected double[] fst(double[] f) throws MathIllegalArgumentException {\n\n        final double[] transformed = new double[f.length];\n\n        if (!ArithmeticUtils.isPowerOfTwo(f.length)) {\n            throw new MathIllegalArgumentException(\n                    LocalizedFormats.NOT_POWER_OF_TWO_CONSIDER_PADDING,\n                    Integer.valueOf(f.length));\n        }\n        if (f[0] != 0.0) {\n            throw new MathIllegalArgumentException(\n                    LocalizedFormats.FIRST_ELEMENT_NOT_ZERO,\n                    Double.valueOf(f[0]));\n        }\n        final int n = f.length;\n        if (n == 1) {       // trivial case\n            transformed[0] = 0.0;\n            return transformed;\n        }\n\n        // construct a new array and perform FFT on it\n        final double[] x = new double[n];\n        x[0] = 0.0;\nx[(n >> 1)] = (n << 1);\n        for (int i = 1; i < (n >> 1); i++) {\n            final double a = FastMath.sin(i * FastMath.PI / n) * (f[i] + f[n - i]);\n            final double b = 0.5 * (f[i] - f[n - i]);\n            x[i]     = a + b;\n            x[n - i] = a - b;\n        }\n        FastFourierTransformer transformer;\n        transformer = new FastFourierTransformer(DftNormalization.STANDARD);\n        Complex[] y = transformer.transform(x, TransformType.FORWARD);\n\n        // reconstruct the FST result for the original array\n        transformed[0] = 0.0;\n        transformed[1] = 0.5 * y[0].getReal();\n        for (int i = 1; i < (n >> 1); i++) {\n            transformed[2 * i]     = -y[i].getImaginary();\n            transformed[2 * i + 1] = y[i].getReal() + transformed[2 * i - 1];\n        }\n\n        return transformed;\n    }",
          "10": "    protected double[] fst(double[] f) throws MathIllegalArgumentException {\n\n        final double[] transformed = new double[f.length];\n\n        if (!ArithmeticUtils.isPowerOfTwo(f.length)) {\n            throw new MathIllegalArgumentException(\n                    LocalizedFormats.NOT_POWER_OF_TWO_CONSIDER_PADDING,\n                    Integer.valueOf(f.length));\n        }\n        if (f[0] != 0.0) {\n            throw new MathIllegalArgumentException(\n                    LocalizedFormats.FIRST_ELEMENT_NOT_ZERO,\n                    Double.valueOf(f[0]));\n        }\n        final int n = f.length;\n        if (n == 1) {       // trivial case\n            transformed[0] = 0.0;\n            return transformed;\n        }\n\n        // construct a new array and perform FFT on it\n        final double[] x = new double[n];\n        x[0] = 0.0;\nx[(n >> 1)] = (2.0 * f[0]);\n        for (int i = 1; i < (n >> 1); i++) {\n            final double a = FastMath.sin(i * FastMath.PI / n) * (f[i] + f[n - i]);\n            final double b = 0.5 * (f[i] - f[n - i]);\n            x[i]     = a + b;\n            x[n - i] = a - b;\n        }\n        FastFourierTransformer transformer;\n        transformer = new FastFourierTransformer(DftNormalization.STANDARD);\n        Complex[] y = transformer.transform(x, TransformType.FORWARD);\n\n        // reconstruct the FST result for the original array\n        transformed[0] = 0.0;\n        transformed[1] = 0.5 * y[0].getReal();\n        for (int i = 1; i < (n >> 1); i++) {\n            transformed[2 * i]     = -y[i].getImaginary();\n            transformed[2 * i + 1] = y[i].getReal() + transformed[2 * i - 1];\n        }\n\n        return transformed;\n    }",
          "11": "    protected double[] fst(double[] f) throws MathIllegalArgumentException {\n\n        final double[] transformed = new double[f.length];\n\n        if (!ArithmeticUtils.isPowerOfTwo(f.length)) {\n            throw new MathIllegalArgumentException(\n                    LocalizedFormats.NOT_POWER_OF_TWO_CONSIDER_PADDING,\n                    Integer.valueOf(f.length));\n        }\n        if (f[0] != 0.0) {\n            throw new MathIllegalArgumentException(\n                    LocalizedFormats.FIRST_ELEMENT_NOT_ZERO,\n                    Double.valueOf(f[0]));\n        }\n        final int n = f.length;\n        if (n == 1) {       // trivial case\n            transformed[0] = 0.0;\n            return transformed;\n        }\n\n        // construct a new array and perform FFT on it\n        final double[] x = new double[n];\n        x[0] = 0.0;\nx[(n >> 1)] = (2.0 * x[(n << 1)]);\n        for (int i = 1; i < (n >> 1); i++) {\n            final double a = FastMath.sin(i * FastMath.PI / n) * (f[i] + f[n - i]);\n            final double b = 0.5 * (f[i] - f[n - i]);\n            x[i]     = a + b;\n            x[n - i] = a - b;\n        }\n        FastFourierTransformer transformer;\n        transformer = new FastFourierTransformer(DftNormalization.STANDARD);\n        Complex[] y = transformer.transform(x, TransformType.FORWARD);\n\n        // reconstruct the FST result for the original array\n        transformed[0] = 0.0;\n        transformed[1] = 0.5 * y[0].getReal();\n        for (int i = 1; i < (n >> 1); i++) {\n            transformed[2 * i]     = -y[i].getImaginary();\n            transformed[2 * i + 1] = y[i].getReal() + transformed[2 * i - 1];\n        }\n\n        return transformed;\n    }",
          "12": "    protected double[] fst(double[] f) throws MathIllegalArgumentException {\n\n        final double[] transformed = new double[f.length];\n\n        if (!ArithmeticUtils.isPowerOfTwo(f.length)) {\n            throw new MathIllegalArgumentException(\n                    LocalizedFormats.NOT_POWER_OF_TWO_CONSIDER_PADDING,\n                    Integer.valueOf(f.length));\n        }\n        if (f[0] != 0.0) {\n            throw new MathIllegalArgumentException(\n                    LocalizedFormats.FIRST_ELEMENT_NOT_ZERO,\n                    Double.valueOf(f[0]));\n        }\n        final int n = f.length;\n        if (n == 1) {       // trivial case\n            transformed[0] = 0.0;\n            return transformed;\n        }\n\n        // construct a new array and perform FFT on it\n        final double[] x = new double[n];\n        x[0] = 0.0;\nx[(n << 1)] = (2.0 * f[(n << 1)]);\n        for (int i = 1; i < (n >> 1); i++) {\n            final double a = FastMath.sin(i * FastMath.PI / n) * (f[i] + f[n - i]);\n            final double b = 0.5 * (f[i] - f[n - i]);\n            x[i]     = a + b;\n            x[n - i] = a - b;\n        }\n        FastFourierTransformer transformer;\n        transformer = new FastFourierTransformer(DftNormalization.STANDARD);\n        Complex[] y = transformer.transform(x, TransformType.FORWARD);\n\n        // reconstruct the FST result for the original array\n        transformed[0] = 0.0;\n        transformed[1] = 0.5 * y[0].getReal();\n        for (int i = 1; i < (n >> 1); i++) {\n            transformed[2 * i]     = -y[i].getImaginary();\n            transformed[2 * i + 1] = y[i].getReal() + transformed[2 * i - 1];\n        }\n\n        return transformed;\n    }",
          "13": "    protected double[] fst(double[] f) throws MathIllegalArgumentException {\n\n        final double[] transformed = new double[f.length];\n\n        if (!ArithmeticUtils.isPowerOfTwo(f.length)) {\n            throw new MathIllegalArgumentException(\n                    LocalizedFormats.NOT_POWER_OF_TWO_CONSIDER_PADDING,\n                    Integer.valueOf(f.length));\n        }\n        if (f[0] != 0.0) {\n            throw new MathIllegalArgumentException(\n                    LocalizedFormats.FIRST_ELEMENT_NOT_ZERO,\n                    Double.valueOf(f[0]));\n        }\n        final int n = f.length;\n        if (n == 1) {       // trivial case\n            transformed[0] = 0.0;\n            return transformed;\n        }\n\n        // construct a new array and perform FFT on it\n        final double[] x = new double[n];\n        x[0] = 0.0;\nf[0] = (2.0 * f[(n << 1)]);\n        for (int i = 1; i < (n >> 1); i++) {\n            final double a = FastMath.sin(i * FastMath.PI / n) * (f[i] + f[n - i]);\n            final double b = 0.5 * (f[i] - f[n - i]);\n            x[i]     = a + b;\n            x[n - i] = a - b;\n        }\n        FastFourierTransformer transformer;\n        transformer = new FastFourierTransformer(DftNormalization.STANDARD);\n        Complex[] y = transformer.transform(x, TransformType.FORWARD);\n\n        // reconstruct the FST result for the original array\n        transformed[0] = 0.0;\n        transformed[1] = 0.5 * y[0].getReal();\n        for (int i = 1; i < (n >> 1); i++) {\n            transformed[2 * i]     = -y[i].getImaginary();\n            transformed[2 * i + 1] = y[i].getReal() + transformed[2 * i - 1];\n        }\n\n        return transformed;\n    }",
          "14": "    protected double[] fst(double[] f) throws MathIllegalArgumentException {\n\n        final double[] transformed = new double[f.length];\n\n        if (!ArithmeticUtils.isPowerOfTwo(f.length)) {\n            throw new MathIllegalArgumentException(\n                    LocalizedFormats.NOT_POWER_OF_TWO_CONSIDER_PADDING,\n                    Integer.valueOf(f.length));\n        }\n        if (f[0] != 0.0) {\n            throw new MathIllegalArgumentException(\n                    LocalizedFormats.FIRST_ELEMENT_NOT_ZERO,\n                    Double.valueOf(f[0]));\n        }\n        final int n = f.length;\n        if (n == 1) {       // trivial case\n            transformed[0] = 0.0;\n            return transformed;\n        }\n\n        // construct a new array and perform FFT on it\n        final double[] x = new double[n];\n        x[0] = 0.0;\nx[(n >> 1)] = (2.0 * f[(n << 0)]);\n        for (int i = 1; i < (n >> 1); i++) {\n            final double a = FastMath.sin(i * FastMath.PI / n) * (f[i] + f[n - i]);\n            final double b = 0.5 * (f[i] - f[n - i]);\n            x[i]     = a + b;\n            x[n - i] = a - b;\n        }\n        FastFourierTransformer transformer;\n        transformer = new FastFourierTransformer(DftNormalization.STANDARD);\n        Complex[] y = transformer.transform(x, TransformType.FORWARD);\n\n        // reconstruct the FST result for the original array\n        transformed[0] = 0.0;\n        transformed[1] = 0.5 * y[0].getReal();\n        for (int i = 1; i < (n >> 1); i++) {\n            transformed[2 * i]     = -y[i].getImaginary();\n            transformed[2 * i + 1] = y[i].getReal() + transformed[2 * i - 1];\n        }\n\n        return transformed;\n    }",
          "15": "    protected double[] fst(double[] f) throws MathIllegalArgumentException {\n\n        final double[] transformed = new double[f.length];\n\n        if (!ArithmeticUtils.isPowerOfTwo(f.length)) {\n            throw new MathIllegalArgumentException(\n                    LocalizedFormats.NOT_POWER_OF_TWO_CONSIDER_PADDING,\n                    Integer.valueOf(f.length));\n        }\n        if (f[0] != 0.0) {\n            throw new MathIllegalArgumentException(\n                    LocalizedFormats.FIRST_ELEMENT_NOT_ZERO,\n                    Double.valueOf(f[0]));\n        }\n        final int n = f.length;\n        if (n == 1) {       // trivial case\n            transformed[0] = 0.0;\n            return transformed;\n        }\n\n        // construct a new array and perform FFT on it\n        final double[] x = new double[n];\n        x[0] = 0.0;\nx[(n >> 1)] = (n >> 1);\n        for (int i = 1; i < (n >> 1); i++) {\n            final double a = FastMath.sin(i * FastMath.PI / n) * (f[i] + f[n - i]);\n            final double b = 0.5 * (f[i] - f[n - i]);\n            x[i]     = a + b;\n            x[n - i] = a - b;\n        }\n        FastFourierTransformer transformer;\n        transformer = new FastFourierTransformer(DftNormalization.STANDARD);\n        Complex[] y = transformer.transform(x, TransformType.FORWARD);\n\n        // reconstruct the FST result for the original array\n        transformed[0] = 0.0;\n        transformed[1] = 0.5 * y[0].getReal();\n        for (int i = 1; i < (n >> 1); i++) {\n            transformed[2 * i]     = -y[i].getImaginary();\n            transformed[2 * i + 1] = y[i].getReal() + transformed[2 * i - 1];\n        }\n\n        return transformed;\n    }",
          "16": "    protected double[] fst(double[] f) throws MathIllegalArgumentException {\n\n        final double[] transformed = new double[f.length];\n\n        if (!ArithmeticUtils.isPowerOfTwo(f.length)) {\n            throw new MathIllegalArgumentException(\n                    LocalizedFormats.NOT_POWER_OF_TWO_CONSIDER_PADDING,\n                    Integer.valueOf(f.length));\n        }\n        if (f[0] != 0.0) {\n            throw new MathIllegalArgumentException(\n                    LocalizedFormats.FIRST_ELEMENT_NOT_ZERO,\n                    Double.valueOf(f[0]));\n        }\n        final int n = f.length;\n        if (n == 1) {       // trivial case\n            transformed[0] = 0.0;\n            return transformed;\n        }\n\n        // construct a new array and perform FFT on it\n        final double[] x = new double[n];\n        x[0] = 0.0;\nx[(n >> 1)] = f[(n << 1)];\n        for (int i = 1; i < (n >> 1); i++) {\n            final double a = FastMath.sin(i * FastMath.PI / n) * (f[i] + f[n - i]);\n            final double b = 0.5 * (f[i] - f[n - i]);\n            x[i]     = a + b;\n            x[n - i] = a - b;\n        }\n        FastFourierTransformer transformer;\n        transformer = new FastFourierTransformer(DftNormalization.STANDARD);\n        Complex[] y = transformer.transform(x, TransformType.FORWARD);\n\n        // reconstruct the FST result for the original array\n        transformed[0] = 0.0;\n        transformed[1] = 0.5 * y[0].getReal();\n        for (int i = 1; i < (n >> 1); i++) {\n            transformed[2 * i]     = -y[i].getImaginary();\n            transformed[2 * i + 1] = y[i].getReal() + transformed[2 * i - 1];\n        }\n\n        return transformed;\n    }",
          "17": "    protected double[] fst(double[] f) throws MathIllegalArgumentException {\n\n        final double[] transformed = new double[f.length];\n\n        if (!ArithmeticUtils.isPowerOfTwo(f.length)) {\n            throw new MathIllegalArgumentException(\n                    LocalizedFormats.NOT_POWER_OF_TWO_CONSIDER_PADDING,\n                    Integer.valueOf(f.length));\n        }\n        if (f[0] != 0.0) {\n            throw new MathIllegalArgumentException(\n                    LocalizedFormats.FIRST_ELEMENT_NOT_ZERO,\n                    Double.valueOf(f[0]));\n        }\n        final int n = f.length;\n        if (n == 1) {       // trivial case\n            transformed[0] = 0.0;\n            return transformed;\n        }\n\n        // construct a new array and perform FFT on it\n        final double[] x = new double[n];\n        x[0] = 0.0;\nx[(n >> 1)] = (2.0 * x[0]);\n        for (int i = 1; i < (n >> 1); i++) {\n            final double a = FastMath.sin(i * FastMath.PI / n) * (f[i] + f[n - i]);\n            final double b = 0.5 * (f[i] - f[n - i]);\n            x[i]     = a + b;\n            x[n - i] = a - b;\n        }\n        FastFourierTransformer transformer;\n        transformer = new FastFourierTransformer(DftNormalization.STANDARD);\n        Complex[] y = transformer.transform(x, TransformType.FORWARD);\n\n        // reconstruct the FST result for the original array\n        transformed[0] = 0.0;\n        transformed[1] = 0.5 * y[0].getReal();\n        for (int i = 1; i < (n >> 1); i++) {\n            transformed[2 * i]     = -y[i].getImaginary();\n            transformed[2 * i + 1] = y[i].getReal() + transformed[2 * i - 1];\n        }\n\n        return transformed;\n    }",
          "18": "    protected double[] fst(double[] f) throws MathIllegalArgumentException {\n\n        final double[] transformed = new double[f.length];\n\n        if (!ArithmeticUtils.isPowerOfTwo(f.length)) {\n            throw new MathIllegalArgumentException(\n                    LocalizedFormats.NOT_POWER_OF_TWO_CONSIDER_PADDING,\n                    Integer.valueOf(f.length));\n        }\n        if (f[0] != 0.0) {\n            throw new MathIllegalArgumentException(\n                    LocalizedFormats.FIRST_ELEMENT_NOT_ZERO,\n                    Double.valueOf(f[0]));\n        }\n        final int n = f.length;\n        if (n == 1) {       // trivial case\n            transformed[0] = 0.0;\n            return transformed;\n        }\n\n        // construct a new array and perform FFT on it\n        final double[] x = new double[n];\n        x[0] = 0.0;\nx[(n >> 1)] = (2.0 * i);\n        for (int i = 1; i < (n >> 1); i++) {\n            final double a = FastMath.sin(i * FastMath.PI / n) * (f[i] + f[n - i]);\n            final double b = 0.5 * (f[i] - f[n - i]);\n            x[i]     = a + b;\n            x[n - i] = a - b;\n        }\n        FastFourierTransformer transformer;\n        transformer = new FastFourierTransformer(DftNormalization.STANDARD);\n        Complex[] y = transformer.transform(x, TransformType.FORWARD);\n\n        // reconstruct the FST result for the original array\n        transformed[0] = 0.0;\n        transformed[1] = 0.5 * y[0].getReal();\n        for (int i = 1; i < (n >> 1); i++) {\n            transformed[2 * i]     = -y[i].getImaginary();\n            transformed[2 * i + 1] = y[i].getReal() + transformed[2 * i - 1];\n        }\n\n        return transformed;\n    }",
          "19": "    protected double[] fst(double[] f) throws MathIllegalArgumentException {\n\n        final double[] transformed = new double[f.length];\n\n        if (!ArithmeticUtils.isPowerOfTwo(f.length)) {\n            throw new MathIllegalArgumentException(\n                    LocalizedFormats.NOT_POWER_OF_TWO_CONSIDER_PADDING,\n                    Integer.valueOf(f.length));\n        }\n        if (f[0] != 0.0) {\n            throw new MathIllegalArgumentException(\n                    LocalizedFormats.FIRST_ELEMENT_NOT_ZERO,\n                    Double.valueOf(f[0]));\n        }\n        final int n = f.length;\n        if (n == 1) {       // trivial case\n            transformed[0] = 0.0;\n            return transformed;\n        }\n\n        // construct a new array and perform FFT on it\n        final double[] x = new double[n];\n        x[0] = 0.0;\nx[0] = (2.0 * f[(n << 1)]);\n        for (int i = 1; i < (n >> 1); i++) {\n            final double a = FastMath.sin(i * FastMath.PI / n) * (f[i] + f[n - i]);\n            final double b = 0.5 * (f[i] - f[n - i]);\n            x[i]     = a + b;\n            x[n - i] = a - b;\n        }\n        FastFourierTransformer transformer;\n        transformer = new FastFourierTransformer(DftNormalization.STANDARD);\n        Complex[] y = transformer.transform(x, TransformType.FORWARD);\n\n        // reconstruct the FST result for the original array\n        transformed[0] = 0.0;\n        transformed[1] = 0.5 * y[0].getReal();\n        for (int i = 1; i < (n >> 1); i++) {\n            transformed[2 * i]     = -y[i].getImaginary();\n            transformed[2 * i + 1] = y[i].getReal() + transformed[2 * i - 1];\n        }\n\n        return transformed;\n    }",
          "20": "    protected double[] fst(double[] f) throws MathIllegalArgumentException {\n\n        final double[] transformed = new double[f.length];\n\n        if (!ArithmeticUtils.isPowerOfTwo(f.length)) {\n            throw new MathIllegalArgumentException(\n                    LocalizedFormats.NOT_POWER_OF_TWO_CONSIDER_PADDING,\n                    Integer.valueOf(f.length));\n        }\n        if (f[0] != 0.0) {\n            throw new MathIllegalArgumentException(\n                    LocalizedFormats.FIRST_ELEMENT_NOT_ZERO,\n                    Double.valueOf(f[0]));\n        }\n        final int n = f.length;\n        if (n == 1) {       // trivial case\n            transformed[0] = 0.0;\n            return transformed;\n        }\n\n        // construct a new array and perform FFT on it\n        final double[] x = new double[n];\n        x[0] = 0.0;\nx[(n - i)] = (a - b);\n        for (int i = 1; i < (n >> 1); i++) {\n            final double a = FastMath.sin(i * FastMath.PI / n) * (f[i] + f[n - i]);\n            final double b = 0.5 * (f[i] - f[n - i]);\n            x[i]     = a + b;\n            x[n - i] = a - b;\n        }\n        FastFourierTransformer transformer;\n        transformer = new FastFourierTransformer(DftNormalization.STANDARD);\n        Complex[] y = transformer.transform(x, TransformType.FORWARD);\n\n        // reconstruct the FST result for the original array\n        transformed[0] = 0.0;\n        transformed[1] = 0.5 * y[0].getReal();\n        for (int i = 1; i < (n >> 1); i++) {\n            transformed[2 * i]     = -y[i].getImaginary();\n            transformed[2 * i + 1] = y[i].getReal() + transformed[2 * i - 1];\n        }\n\n        return transformed;\n    }",
          "21": "    protected double[] fst(double[] f) throws MathIllegalArgumentException {\n\n        final double[] transformed = new double[f.length];\n\n        if (!ArithmeticUtils.isPowerOfTwo(f.length)) {\n            throw new MathIllegalArgumentException(\n                    LocalizedFormats.NOT_POWER_OF_TWO_CONSIDER_PADDING,\n                    Integer.valueOf(f.length));\n        }\n        if (f[0] != 0.0) {\n            throw new MathIllegalArgumentException(\n                    LocalizedFormats.FIRST_ELEMENT_NOT_ZERO,\n                    Double.valueOf(f[0]));\n        }\n        final int n = f.length;\n        if (n == 1) {       // trivial case\n            transformed[0] = 0.0;\n            return transformed;\n        }\n\n        // construct a new array and perform FFT on it\n        final double[] x = new double[n];\n        x[0] = 0.0;\nx[(n >> 1)] = f[(n >> 1)];\n        for (int i = 1; i < (n >> 1); i++) {\n            final double a = FastMath.sin(i * FastMath.PI / n) * (f[i] + f[n - i]);\n            final double b = 0.5 * (f[i] - f[n - i]);\n            x[i]     = a + b;\n            x[n - i] = a - b;\n        }\n        FastFourierTransformer transformer;\n        transformer = new FastFourierTransformer(DftNormalization.STANDARD);\n        Complex[] y = transformer.transform(x, TransformType.FORWARD);\n\n        // reconstruct the FST result for the original array\n        transformed[0] = 0.0;\n        transformed[1] = 0.5 * y[0].getReal();\n        for (int i = 1; i < (n >> 1); i++) {\n            transformed[2 * i]     = -y[i].getImaginary();\n            transformed[2 * i + 1] = y[i].getReal() + transformed[2 * i - 1];\n        }\n\n        return transformed;\n    }",
          "22": "    protected double[] fst(double[] f) throws MathIllegalArgumentException {\n\n        final double[] transformed = new double[f.length];\n\n        if (!ArithmeticUtils.isPowerOfTwo(f.length)) {\n            throw new MathIllegalArgumentException(\n                    LocalizedFormats.NOT_POWER_OF_TWO_CONSIDER_PADDING,\n                    Integer.valueOf(f.length));\n        }\n        if (f[0] != 0.0) {\n            throw new MathIllegalArgumentException(\n                    LocalizedFormats.FIRST_ELEMENT_NOT_ZERO,\n                    Double.valueOf(f[0]));\n        }\n        final int n = f.length;\n        if (n == 1) {       // trivial case\n            transformed[0] = 0.0;\n            return transformed;\n        }\n\n        // construct a new array and perform FFT on it\n        final double[] x = new double[n];\n        x[0] = 0.0;\nx[i] = (a + b);\n        for (int i = 1; i < (n >> 1); i++) {\n            final double a = FastMath.sin(i * FastMath.PI / n) * (f[i] + f[n - i]);\n            final double b = 0.5 * (f[i] - f[n - i]);\n            x[i]     = a + b;\n            x[n - i] = a - b;\n        }\n        FastFourierTransformer transformer;\n        transformer = new FastFourierTransformer(DftNormalization.STANDARD);\n        Complex[] y = transformer.transform(x, TransformType.FORWARD);\n\n        // reconstruct the FST result for the original array\n        transformed[0] = 0.0;\n        transformed[1] = 0.5 * y[0].getReal();\n        for (int i = 1; i < (n >> 1); i++) {\n            transformed[2 * i]     = -y[i].getImaginary();\n            transformed[2 * i + 1] = y[i].getReal() + transformed[2 * i - 1];\n        }\n\n        return transformed;\n    }",
          "23": "    protected double[] fst(double[] f) throws MathIllegalArgumentException {\n\n        final double[] transformed = new double[f.length];\n\n        if (!ArithmeticUtils.isPowerOfTwo(f.length)) {\n            throw new MathIllegalArgumentException(\n                    LocalizedFormats.NOT_POWER_OF_TWO_CONSIDER_PADDING,\n                    Integer.valueOf(f.length));\n        }\n        if (f[0] != 0.0) {\n            throw new MathIllegalArgumentException(\n                    LocalizedFormats.FIRST_ELEMENT_NOT_ZERO,\n                    Double.valueOf(f[0]));\n        }\n        final int n = f.length;\n        if (n == 1) {       // trivial case\n            transformed[0] = 0.0;\n            return transformed;\n        }\n\n        // construct a new array and perform FFT on it\n        final double[] x = new double[n];\n        x[0] = 0.0;\nn = (2.0 * f[(n << 1)]);\n        for (int i = 1; i < (n >> 1); i++) {\n            final double a = FastMath.sin(i * FastMath.PI / n) * (f[i] + f[n - i]);\n            final double b = 0.5 * (f[i] - f[n - i]);\n            x[i]     = a + b;\n            x[n - i] = a - b;\n        }\n        FastFourierTransformer transformer;\n        transformer = new FastFourierTransformer(DftNormalization.STANDARD);\n        Complex[] y = transformer.transform(x, TransformType.FORWARD);\n\n        // reconstruct the FST result for the original array\n        transformed[0] = 0.0;\n        transformed[1] = 0.5 * y[0].getReal();\n        for (int i = 1; i < (n >> 1); i++) {\n            transformed[2 * i]     = -y[i].getImaginary();\n            transformed[2 * i + 1] = y[i].getReal() + transformed[2 * i - 1];\n        }\n\n        return transformed;\n    }",
          "24": "    protected double[] fst(double[] f) throws MathIllegalArgumentException {\n\n        final double[] transformed = new double[f.length];\n\n        if (!ArithmeticUtils.isPowerOfTwo(f.length)) {\n            throw new MathIllegalArgumentException(\n                    LocalizedFormats.NOT_POWER_OF_TWO_CONSIDER_PADDING,\n                    Integer.valueOf(f.length));\n        }\n        if (f[0] != 0.0) {\n            throw new MathIllegalArgumentException(\n                    LocalizedFormats.FIRST_ELEMENT_NOT_ZERO,\n                    Double.valueOf(f[0]));\n        }\n        final int n = f.length;\n        if (n == 1) {       // trivial case\n            transformed[0] = 0.0;\n            return transformed;\n        }\n\n        // construct a new array and perform FFT on it\n        final double[] x = new double[n];\n        x[0] = 0.0;\nx[(n >> 1)] = (2.0 * f[(n << 2)]);\n        for (int i = 1; i < (n >> 1); i++) {\n            final double a = FastMath.sin(i * FastMath.PI / n) * (f[i] + f[n - i]);\n            final double b = 0.5 * (f[i] - f[n - i]);\n            x[i]     = a + b;\n            x[n - i] = a - b;\n        }\n        FastFourierTransformer transformer;\n        transformer = new FastFourierTransformer(DftNormalization.STANDARD);\n        Complex[] y = transformer.transform(x, TransformType.FORWARD);\n\n        // reconstruct the FST result for the original array\n        transformed[0] = 0.0;\n        transformed[1] = 0.5 * y[0].getReal();\n        for (int i = 1; i < (n >> 1); i++) {\n            transformed[2 * i]     = -y[i].getImaginary();\n            transformed[2 * i + 1] = y[i].getReal() + transformed[2 * i - 1];\n        }\n\n        return transformed;\n    }",
          "25": "    protected double[] fst(double[] f) throws MathIllegalArgumentException {\n\n        final double[] transformed = new double[f.length];\n\n        if (!ArithmeticUtils.isPowerOfTwo(f.length)) {\n            throw new MathIllegalArgumentException(\n                    LocalizedFormats.NOT_POWER_OF_TWO_CONSIDER_PADDING,\n                    Integer.valueOf(f.length));\n        }\n        if (f[0] != 0.0) {\n            throw new MathIllegalArgumentException(\n                    LocalizedFormats.FIRST_ELEMENT_NOT_ZERO,\n                    Double.valueOf(f[0]));\n        }\n        final int n = f.length;\n        if (n == 1) {       // trivial case\n            transformed[0] = 0.0;\n            return transformed;\n        }\n\n        // construct a new array and perform FFT on it\n        final double[] x = new double[n];\n        x[0] = 0.0;\nx[(n >> 1)] = (2.0 * n[(n >> 1)]);\n        for (int i = 1; i < (n >> 1); i++) {\n            final double a = FastMath.sin(i * FastMath.PI / n) * (f[i] + f[n - i]);\n            final double b = 0.5 * (f[i] - f[n - i]);\n            x[i]     = a + b;\n            x[n - i] = a - b;\n        }\n        FastFourierTransformer transformer;\n        transformer = new FastFourierTransformer(DftNormalization.STANDARD);\n        Complex[] y = transformer.transform(x, TransformType.FORWARD);\n\n        // reconstruct the FST result for the original array\n        transformed[0] = 0.0;\n        transformed[1] = 0.5 * y[0].getReal();\n        for (int i = 1; i < (n >> 1); i++) {\n            transformed[2 * i]     = -y[i].getImaginary();\n            transformed[2 * i + 1] = y[i].getReal() + transformed[2 * i - 1];\n        }\n\n        return transformed;\n    }",
          "26": "    protected double[] fst(double[] f) throws MathIllegalArgumentException {\n\n        final double[] transformed = new double[f.length];\n\n        if (!ArithmeticUtils.isPowerOfTwo(f.length)) {\n            throw new MathIllegalArgumentException(\n                    LocalizedFormats.NOT_POWER_OF_TWO_CONSIDER_PADDING,\n                    Integer.valueOf(f.length));\n        }\n        if (f[0] != 0.0) {\n            throw new MathIllegalArgumentException(\n                    LocalizedFormats.FIRST_ELEMENT_NOT_ZERO,\n                    Double.valueOf(f[0]));\n        }\n        final int n = f.length;\n        if (n == 1) {       // trivial case\n            transformed[0] = 0.0;\n            return transformed;\n        }\n\n        // construct a new array and perform FFT on it\n        final double[] x = new double[n];\n        x[0] = 0.0;\nn[(n >> 1)] = (2.0 * f[(n << 1)]);\n        for (int i = 1; i < (n >> 1); i++) {\n            final double a = FastMath.sin(i * FastMath.PI / n) * (f[i] + f[n - i]);\n            final double b = 0.5 * (f[i] - f[n - i]);\n            x[i]     = a + b;\n            x[n - i] = a - b;\n        }\n        FastFourierTransformer transformer;\n        transformer = new FastFourierTransformer(DftNormalization.STANDARD);\n        Complex[] y = transformer.transform(x, TransformType.FORWARD);\n\n        // reconstruct the FST result for the original array\n        transformed[0] = 0.0;\n        transformed[1] = 0.5 * y[0].getReal();\n        for (int i = 1; i < (n >> 1); i++) {\n            transformed[2 * i]     = -y[i].getImaginary();\n            transformed[2 * i + 1] = y[i].getReal() + transformed[2 * i - 1];\n        }\n\n        return transformed;\n    }",
          "27": "    protected double[] fst(double[] f) throws MathIllegalArgumentException {\n\n        final double[] transformed = new double[f.length];\n\n        if (!ArithmeticUtils.isPowerOfTwo(f.length)) {\n            throw new MathIllegalArgumentException(\n                    LocalizedFormats.NOT_POWER_OF_TWO_CONSIDER_PADDING,\n                    Integer.valueOf(f.length));\n        }\n        if (f[0] != 0.0) {\n            throw new MathIllegalArgumentException(\n                    LocalizedFormats.FIRST_ELEMENT_NOT_ZERO,\n                    Double.valueOf(f[0]));\n        }\n        final int n = f.length;\n        if (n == 1) {       // trivial case\n            transformed[0] = 0.0;\n            return transformed;\n        }\n\n        // construct a new array and perform FFT on it\n        final double[] x = new double[n];\n        x[0] = 0.0;\nx[(n >> 1)] = (2.0 * f[(n > 1)]);\n        for (int i = 1; i < (n >> 1); i++) {\n            final double a = FastMath.sin(i * FastMath.PI / n) * (f[i] + f[n - i]);\n            final double b = 0.5 * (f[i] - f[n - i]);\n            x[i]     = a + b;\n            x[n - i] = a - b;\n        }\n        FastFourierTransformer transformer;\n        transformer = new FastFourierTransformer(DftNormalization.STANDARD);\n        Complex[] y = transformer.transform(x, TransformType.FORWARD);\n\n        // reconstruct the FST result for the original array\n        transformed[0] = 0.0;\n        transformed[1] = 0.5 * y[0].getReal();\n        for (int i = 1; i < (n >> 1); i++) {\n            transformed[2 * i]     = -y[i].getImaginary();\n            transformed[2 * i + 1] = y[i].getReal() + transformed[2 * i - 1];\n        }\n\n        return transformed;\n    }",
          "28": "    protected double[] fst(double[] f) throws MathIllegalArgumentException {\n\n        final double[] transformed = new double[f.length];\n\n        if (!ArithmeticUtils.isPowerOfTwo(f.length)) {\n            throw new MathIllegalArgumentException(\n                    LocalizedFormats.NOT_POWER_OF_TWO_CONSIDER_PADDING,\n                    Integer.valueOf(f.length));\n        }\n        if (f[0] != 0.0) {\n            throw new MathIllegalArgumentException(\n                    LocalizedFormats.FIRST_ELEMENT_NOT_ZERO,\n                    Double.valueOf(f[0]));\n        }\n        final int n = f.length;\n        if (n == 1) {       // trivial case\n            transformed[0] = 0.0;\n            return transformed;\n        }\n\n        // construct a new array and perform FFT on it\n        final double[] x = new double[n];\n        x[0] = 0.0;\nx[(n >> 1)] = (2.0 * f[(n <= 1)]);\n        for (int i = 1; i < (n >> 1); i++) {\n            final double a = FastMath.sin(i * FastMath.PI / n) * (f[i] + f[n - i]);\n            final double b = 0.5 * (f[i] - f[n - i]);\n            x[i]     = a + b;\n            x[n - i] = a - b;\n        }\n        FastFourierTransformer transformer;\n        transformer = new FastFourierTransformer(DftNormalization.STANDARD);\n        Complex[] y = transformer.transform(x, TransformType.FORWARD);\n\n        // reconstruct the FST result for the original array\n        transformed[0] = 0.0;\n        transformed[1] = 0.5 * y[0].getReal();\n        for (int i = 1; i < (n >> 1); i++) {\n            transformed[2 * i]     = -y[i].getImaginary();\n            transformed[2 * i + 1] = y[i].getReal() + transformed[2 * i - 1];\n        }\n\n        return transformed;\n    }",
          "29": "    protected double[] fst(double[] f) throws MathIllegalArgumentException {\n\n        final double[] transformed = new double[f.length];\n\n        if (!ArithmeticUtils.isPowerOfTwo(f.length)) {\n            throw new MathIllegalArgumentException(\n                    LocalizedFormats.NOT_POWER_OF_TWO_CONSIDER_PADDING,\n                    Integer.valueOf(f.length));\n        }\n        if (f[0] != 0.0) {\n            throw new MathIllegalArgumentException(\n                    LocalizedFormats.FIRST_ELEMENT_NOT_ZERO,\n                    Double.valueOf(f[0]));\n        }\n        final int n = f.length;\n        if (n == 1) {       // trivial case\n            transformed[0] = 0.0;\n            return transformed;\n        }\n\n        // construct a new array and perform FFT on it\n        final double[] x = new double[n];\n        x[0] = 0.0;\nx[(n >> 1)] = (2.0 * f[(n >= 1)]);\n        for (int i = 1; i < (n >> 1); i++) {\n            final double a = FastMath.sin(i * FastMath.PI / n) * (f[i] + f[n - i]);\n            final double b = 0.5 * (f[i] - f[n - i]);\n            x[i]     = a + b;\n            x[n - i] = a - b;\n        }\n        FastFourierTransformer transformer;\n        transformer = new FastFourierTransformer(DftNormalization.STANDARD);\n        Complex[] y = transformer.transform(x, TransformType.FORWARD);\n\n        // reconstruct the FST result for the original array\n        transformed[0] = 0.0;\n        transformed[1] = 0.5 * y[0].getReal();\n        for (int i = 1; i < (n >> 1); i++) {\n            transformed[2 * i]     = -y[i].getImaginary();\n            transformed[2 * i + 1] = y[i].getReal() + transformed[2 * i - 1];\n        }\n\n        return transformed;\n    }",
          "30": "    protected double[] fst(double[] f) throws MathIllegalArgumentException {\n\n        final double[] transformed = new double[f.length];\n\n        if (!ArithmeticUtils.isPowerOfTwo(f.length)) {\n            throw new MathIllegalArgumentException(\n                    LocalizedFormats.NOT_POWER_OF_TWO_CONSIDER_PADDING,\n                    Integer.valueOf(f.length));\n        }\n        if (f[0] != 0.0) {\n            throw new MathIllegalArgumentException(\n                    LocalizedFormats.FIRST_ELEMENT_NOT_ZERO,\n                    Double.valueOf(f[0]));\n        }\n        final int n = f.length;\n        if (n == 1) {       // trivial case\n            transformed[0] = 0.0;\n            return transformed;\n        }\n\n        // construct a new array and perform FFT on it\n        final double[] x = new double[n];\n        x[0] = 0.0;\nx[(n >> 1)] = (2.0 * f[(n << 2.0)]);\n        for (int i = 1; i < (n >> 1); i++) {\n            final double a = FastMath.sin(i * FastMath.PI / n) * (f[i] + f[n - i]);\n            final double b = 0.5 * (f[i] - f[n - i]);\n            x[i]     = a + b;\n            x[n - i] = a - b;\n        }\n        FastFourierTransformer transformer;\n        transformer = new FastFourierTransformer(DftNormalization.STANDARD);\n        Complex[] y = transformer.transform(x, TransformType.FORWARD);\n\n        // reconstruct the FST result for the original array\n        transformed[0] = 0.0;\n        transformed[1] = 0.5 * y[0].getReal();\n        for (int i = 1; i < (n >> 1); i++) {\n            transformed[2 * i]     = -y[i].getImaginary();\n            transformed[2 * i + 1] = y[i].getReal() + transformed[2 * i - 1];\n        }\n\n        return transformed;\n    }",
          "31": "    protected double[] fst(double[] f) throws MathIllegalArgumentException {\n\n        final double[] transformed = new double[f.length];\n\n        if (!ArithmeticUtils.isPowerOfTwo(f.length)) {\n            throw new MathIllegalArgumentException(\n                    LocalizedFormats.NOT_POWER_OF_TWO_CONSIDER_PADDING,\n                    Integer.valueOf(f.length));\n        }\n        if (f[0] != 0.0) {\n            throw new MathIllegalArgumentException(\n                    LocalizedFormats.FIRST_ELEMENT_NOT_ZERO,\n                    Double.valueOf(f[0]));\n        }\n        final int n = f.length;\n        if (n == 1) {       // trivial case\n            transformed[0] = 0.0;\n            return transformed;\n        }\n\n        // construct a new array and perform FFT on it\n        final double[] x = new double[n];\n        x[0] = 0.0;\nx[(n >> 1)] = (2.0 * f[(n < 1)]);\n        for (int i = 1; i < (n >> 1); i++) {\n            final double a = FastMath.sin(i * FastMath.PI / n) * (f[i] + f[n - i]);\n            final double b = 0.5 * (f[i] - f[n - i]);\n            x[i]     = a + b;\n            x[n - i] = a - b;\n        }\n        FastFourierTransformer transformer;\n        transformer = new FastFourierTransformer(DftNormalization.STANDARD);\n        Complex[] y = transformer.transform(x, TransformType.FORWARD);\n\n        // reconstruct the FST result for the original array\n        transformed[0] = 0.0;\n        transformed[1] = 0.5 * y[0].getReal();\n        for (int i = 1; i < (n >> 1); i++) {\n            transformed[2 * i]     = -y[i].getImaginary();\n            transformed[2 * i + 1] = y[i].getReal() + transformed[2 * i - 1];\n        }\n\n        return transformed;\n    }",
          "32": "    protected double[] fst(double[] f) throws MathIllegalArgumentException {\n\n        final double[] transformed = new double[f.length];\n\n        if (!ArithmeticUtils.isPowerOfTwo(f.length)) {\n            throw new MathIllegalArgumentException(\n                    LocalizedFormats.NOT_POWER_OF_TWO_CONSIDER_PADDING,\n                    Integer.valueOf(f.length));\n        }\n        if (f[0] != 0.0) {\n            throw new MathIllegalArgumentException(\n                    LocalizedFormats.FIRST_ELEMENT_NOT_ZERO,\n                    Double.valueOf(f[0]));\n        }\n        final int n = f.length;\n        if (n == 1) {       // trivial case\n            transformed[0] = 0.0;\n            return transformed;\n        }\n\n        // construct a new array and perform FFT on it\n        final double[] x = new double[n];\n        x[0] = 0.0;\nx[(n >> 1)] = (2.0 * f[(n >>> 1)]);\n        for (int i = 1; i < (n >> 1); i++) {\n            final double a = FastMath.sin(i * FastMath.PI / n) * (f[i] + f[n - i]);\n            final double b = 0.5 * (f[i] - f[n - i]);\n            x[i]     = a + b;\n            x[n - i] = a - b;\n        }\n        FastFourierTransformer transformer;\n        transformer = new FastFourierTransformer(DftNormalization.STANDARD);\n        Complex[] y = transformer.transform(x, TransformType.FORWARD);\n\n        // reconstruct the FST result for the original array\n        transformed[0] = 0.0;\n        transformed[1] = 0.5 * y[0].getReal();\n        for (int i = 1; i < (n >> 1); i++) {\n            transformed[2 * i]     = -y[i].getImaginary();\n            transformed[2 * i + 1] = y[i].getReal() + transformed[2 * i - 1];\n        }\n\n        return transformed;\n    }",
          "33": "    protected double[] fst(double[] f) throws MathIllegalArgumentException {\n\n        final double[] transformed = new double[f.length];\n\n        if (!ArithmeticUtils.isPowerOfTwo(f.length)) {\n            throw new MathIllegalArgumentException(\n                    LocalizedFormats.NOT_POWER_OF_TWO_CONSIDER_PADDING,\n                    Integer.valueOf(f.length));\n        }\n        if (f[0] != 0.0) {\n            throw new MathIllegalArgumentException(\n                    LocalizedFormats.FIRST_ELEMENT_NOT_ZERO,\n                    Double.valueOf(f[0]));\n        }\n        final int n = f.length;\n        if (n == 1) {       // trivial case\n            transformed[0] = 0.0;\n            return transformed;\n        }\n\n        // construct a new array and perform FFT on it\n        final double[] x = new double[n];\n        x[0] = 0.0;\nx[(n >> 1)] = (2.0 * f[(n - 1)]);\n        for (int i = 1; i < (n >> 1); i++) {\n            final double a = FastMath.sin(i * FastMath.PI / n) * (f[i] + f[n - i]);\n            final double b = 0.5 * (f[i] - f[n - i]);\n            x[i]     = a + b;\n            x[n - i] = a - b;\n        }\n        FastFourierTransformer transformer;\n        transformer = new FastFourierTransformer(DftNormalization.STANDARD);\n        Complex[] y = transformer.transform(x, TransformType.FORWARD);\n\n        // reconstruct the FST result for the original array\n        transformed[0] = 0.0;\n        transformed[1] = 0.5 * y[0].getReal();\n        for (int i = 1; i < (n >> 1); i++) {\n            transformed[2 * i]     = -y[i].getImaginary();\n            transformed[2 * i + 1] = y[i].getReal() + transformed[2 * i - 1];\n        }\n\n        return transformed;\n    }",
          "34": "    protected double[] fst(double[] f) throws MathIllegalArgumentException {\n\n        final double[] transformed = new double[f.length];\n\n        if (!ArithmeticUtils.isPowerOfTwo(f.length)) {\n            throw new MathIllegalArgumentException(\n                    LocalizedFormats.NOT_POWER_OF_TWO_CONSIDER_PADDING,\n                    Integer.valueOf(f.length));\n        }\n        if (f[0] != 0.0) {\n            throw new MathIllegalArgumentException(\n                    LocalizedFormats.FIRST_ELEMENT_NOT_ZERO,\n                    Double.valueOf(f[0]));\n        }\n        final int n = f.length;\n        if (n == 1) {       // trivial case\n            transformed[0] = 0.0;\n            return transformed;\n        }\n\n        // construct a new array and perform FFT on it\n        final double[] x = new double[n];\n        x[0] = 0.0;\nreturn;\n        x[n >> 1] = 2.0 * f[n << 1];        for (int i = 1; i < (n >> 1); i++) {\n            final double a = FastMath.sin(i * FastMath.PI / n) * (f[i] + f[n - i]);\n            final double b = 0.5 * (f[i] - f[n - i]);\n            x[i]     = a + b;\n            x[n - i] = a - b;\n        }\n        FastFourierTransformer transformer;\n        transformer = new FastFourierTransformer(DftNormalization.STANDARD);\n        Complex[] y = transformer.transform(x, TransformType.FORWARD);\n\n        // reconstruct the FST result for the original array\n        transformed[0] = 0.0;\n        transformed[1] = 0.5 * y[0].getReal();\n        for (int i = 1; i < (n >> 1); i++) {\n            transformed[2 * i]     = -y[i].getImaginary();\n            transformed[2 * i + 1] = y[i].getReal() + transformed[2 * i - 1];\n        }\n\n        return transformed;\n    }",
          "35": "    protected double[] fst(double[] f) throws MathIllegalArgumentException {\n\n        final double[] transformed = new double[f.length];\n\n        if (!ArithmeticUtils.isPowerOfTwo(f.length)) {\n            throw new MathIllegalArgumentException(\n                    LocalizedFormats.NOT_POWER_OF_TWO_CONSIDER_PADDING,\n                    Integer.valueOf(f.length));\n        }\n        if (f[0] != 0.0) {\n            throw new MathIllegalArgumentException(\n                    LocalizedFormats.FIRST_ELEMENT_NOT_ZERO,\n                    Double.valueOf(f[0]));\n        }\n        final int n = f.length;\n        if (n == 1) {       // trivial case\n            transformed[0] = 0.0;\n            return transformed;\n        }\n\n        // construct a new array and perform FFT on it\n        final double[] x = new double[n];\n        x[0] = 0.0;\nbreak;\n        x[n >> 1] = 2.0 * f[n << 1];        for (int i = 1; i < (n >> 1); i++) {\n            final double a = FastMath.sin(i * FastMath.PI / n) * (f[i] + f[n - i]);\n            final double b = 0.5 * (f[i] - f[n - i]);\n            x[i]     = a + b;\n            x[n - i] = a - b;\n        }\n        FastFourierTransformer transformer;\n        transformer = new FastFourierTransformer(DftNormalization.STANDARD);\n        Complex[] y = transformer.transform(x, TransformType.FORWARD);\n\n        // reconstruct the FST result for the original array\n        transformed[0] = 0.0;\n        transformed[1] = 0.5 * y[0].getReal();\n        for (int i = 1; i < (n >> 1); i++) {\n            transformed[2 * i]     = -y[i].getImaginary();\n            transformed[2 * i + 1] = y[i].getReal() + transformed[2 * i - 1];\n        }\n\n        return transformed;\n    }",
          "36": "    protected double[] fst(double[] f) throws MathIllegalArgumentException {\n\n        final double[] transformed = new double[f.length];\n\n        if (!ArithmeticUtils.isPowerOfTwo(f.length)) {\n            throw new MathIllegalArgumentException(\n                    LocalizedFormats.NOT_POWER_OF_TWO_CONSIDER_PADDING,\n                    Integer.valueOf(f.length));\n        }\n        if (f[0] != 0.0) {\n            throw new MathIllegalArgumentException(\n                    LocalizedFormats.FIRST_ELEMENT_NOT_ZERO,\n                    Double.valueOf(f[0]));\n        }\n        final int n = f.length;\n        if (n == 1) {       // trivial case\n            transformed[0] = 0.0;\n            return transformed;\n        }\n\n        // construct a new array and perform FFT on it\n        final double[] x = new double[n];\n        x[0] = 0.0;\nx[(n >> 1)] = ((((f * f) * 1) * f) + f[(n << 1)]);\n        for (int i = 1; i < (n >> 1); i++) {\n            final double a = FastMath.sin(i * FastMath.PI / n) * (f[i] + f[n - i]);\n            final double b = 0.5 * (f[i] - f[n - i]);\n            x[i]     = a + b;\n            x[n - i] = a - b;\n        }\n        FastFourierTransformer transformer;\n        transformer = new FastFourierTransformer(DftNormalization.STANDARD);\n        Complex[] y = transformer.transform(x, TransformType.FORWARD);\n\n        // reconstruct the FST result for the original array\n        transformed[0] = 0.0;\n        transformed[1] = 0.5 * y[0].getReal();\n        for (int i = 1; i < (n >> 1); i++) {\n            transformed[2 * i]     = -y[i].getImaginary();\n            transformed[2 * i + 1] = y[i].getReal() + transformed[2 * i - 1];\n        }\n\n        return transformed;\n    }",
          "37": "    protected double[] fst(double[] f) throws MathIllegalArgumentException {\n\n        final double[] transformed = new double[f.length];\n\n        if (!ArithmeticUtils.isPowerOfTwo(f.length)) {\n            throw new MathIllegalArgumentException(\n                    LocalizedFormats.NOT_POWER_OF_TWO_CONSIDER_PADDING,\n                    Integer.valueOf(f.length));\n        }\n        if (f[0] != 0.0) {\n            throw new MathIllegalArgumentException(\n                    LocalizedFormats.FIRST_ELEMENT_NOT_ZERO,\n                    Double.valueOf(f[0]));\n        }\n        final int n = f.length;\n        if (n == 1) {       // trivial case\n            transformed[0] = 0.0;\n            return transformed;\n        }\n\n        // construct a new array and perform FFT on it\n        final double[] x = new double[n];\n        x[0] = 0.0;\nx[(n >> 1)] = ((((f * f) * 1) * f) * f[(n << 1)]);\n        for (int i = 1; i < (n >> 1); i++) {\n            final double a = FastMath.sin(i * FastMath.PI / n) * (f[i] + f[n - i]);\n            final double b = 0.5 * (f[i] - f[n - i]);\n            x[i]     = a + b;\n            x[n - i] = a - b;\n        }\n        FastFourierTransformer transformer;\n        transformer = new FastFourierTransformer(DftNormalization.STANDARD);\n        Complex[] y = transformer.transform(x, TransformType.FORWARD);\n\n        // reconstruct the FST result for the original array\n        transformed[0] = 0.0;\n        transformed[1] = 0.5 * y[0].getReal();\n        for (int i = 1; i < (n >> 1); i++) {\n            transformed[2 * i]     = -y[i].getImaginary();\n            transformed[2 * i + 1] = y[i].getReal() + transformed[2 * i - 1];\n        }\n\n        return transformed;\n    }",
          "38": "    protected double[] fst(double[] f) throws MathIllegalArgumentException {\n\n        final double[] transformed = new double[f.length];\n\n        if (!ArithmeticUtils.isPowerOfTwo(f.length)) {\n            throw new MathIllegalArgumentException(\n                    LocalizedFormats.NOT_POWER_OF_TWO_CONSIDER_PADDING,\n                    Integer.valueOf(f.length));\n        }\n        if (f[0] != 0.0) {\n            throw new MathIllegalArgumentException(\n                    LocalizedFormats.FIRST_ELEMENT_NOT_ZERO,\n                    Double.valueOf(f[0]));\n        }\n        final int n = f.length;\n        if (n == 1) {       // trivial case\n            transformed[0] = 0.0;\n            return transformed;\n        }\n\n        // construct a new array and perform FFT on it\n        final double[] x = new double[n];\n        x[0] = 0.0;\nx[(n >> 1)] = ((((f * f) * f) * f[(n << 1)]) * f[(n << 1)]);\n        for (int i = 1; i < (n >> 1); i++) {\n            final double a = FastMath.sin(i * FastMath.PI / n) * (f[i] + f[n - i]);\n            final double b = 0.5 * (f[i] - f[n - i]);\n            x[i]     = a + b;\n            x[n - i] = a - b;\n        }\n        FastFourierTransformer transformer;\n        transformer = new FastFourierTransformer(DftNormalization.STANDARD);\n        Complex[] y = transformer.transform(x, TransformType.FORWARD);\n\n        // reconstruct the FST result for the original array\n        transformed[0] = 0.0;\n        transformed[1] = 0.5 * y[0].getReal();\n        for (int i = 1; i < (n >> 1); i++) {\n            transformed[2 * i]     = -y[i].getImaginary();\n            transformed[2 * i + 1] = y[i].getReal() + transformed[2 * i - 1];\n        }\n\n        return transformed;\n    }",
          "39": "    protected double[] fst(double[] f) throws MathIllegalArgumentException {\n\n        final double[] transformed = new double[f.length];\n\n        if (!ArithmeticUtils.isPowerOfTwo(f.length)) {\n            throw new MathIllegalArgumentException(\n                    LocalizedFormats.NOT_POWER_OF_TWO_CONSIDER_PADDING,\n                    Integer.valueOf(f.length));\n        }\n        if (f[0] != 0.0) {\n            throw new MathIllegalArgumentException(\n                    LocalizedFormats.FIRST_ELEMENT_NOT_ZERO,\n                    Double.valueOf(f[0]));\n        }\n        final int n = f.length;\n        if (n == 1) {       // trivial case\n            transformed[0] = 0.0;\n            return transformed;\n        }\n\n        // construct a new array and perform FFT on it\n        final double[] x = new double[n];\n        x[0] = 0.0;\nx[(n >> 1)] = ((((f * f) * f) * f[(n << 1)]) + f[(n << 1)]);\n        for (int i = 1; i < (n >> 1); i++) {\n            final double a = FastMath.sin(i * FastMath.PI / n) * (f[i] + f[n - i]);\n            final double b = 0.5 * (f[i] - f[n - i]);\n            x[i]     = a + b;\n            x[n - i] = a - b;\n        }\n        FastFourierTransformer transformer;\n        transformer = new FastFourierTransformer(DftNormalization.STANDARD);\n        Complex[] y = transformer.transform(x, TransformType.FORWARD);\n\n        // reconstruct the FST result for the original array\n        transformed[0] = 0.0;\n        transformed[1] = 0.5 * y[0].getReal();\n        for (int i = 1; i < (n >> 1); i++) {\n            transformed[2 * i]     = -y[i].getImaginary();\n            transformed[2 * i + 1] = y[i].getReal() + transformed[2 * i - 1];\n        }\n\n        return transformed;\n    }",
          "40": "    protected double[] fst(double[] f) throws MathIllegalArgumentException {\n\n        final double[] transformed = new double[f.length];\n\n        if (!ArithmeticUtils.isPowerOfTwo(f.length)) {\n            throw new MathIllegalArgumentException(\n                    LocalizedFormats.NOT_POWER_OF_TWO_CONSIDER_PADDING,\n                    Integer.valueOf(f.length));\n        }\n        if (f[0] != 0.0) {\n            throw new MathIllegalArgumentException(\n                    LocalizedFormats.FIRST_ELEMENT_NOT_ZERO,\n                    Double.valueOf(f[0]));\n        }\n        final int n = f.length;\n        if (n == 1) {       // trivial case\n            transformed[0] = 0.0;\n            return transformed;\n        }\n\n        // construct a new array and perform FFT on it\n        final double[] x = new double[n];\n        x[0] = 0.0;\nx[(n >> 1)] = ((((f * f) * f) * f[(n << 1)]) | f[(n << 1)]);\n        for (int i = 1; i < (n >> 1); i++) {\n            final double a = FastMath.sin(i * FastMath.PI / n) * (f[i] + f[n - i]);\n            final double b = 0.5 * (f[i] - f[n - i]);\n            x[i]     = a + b;\n            x[n - i] = a - b;\n        }\n        FastFourierTransformer transformer;\n        transformer = new FastFourierTransformer(DftNormalization.STANDARD);\n        Complex[] y = transformer.transform(x, TransformType.FORWARD);\n\n        // reconstruct the FST result for the original array\n        transformed[0] = 0.0;\n        transformed[1] = 0.5 * y[0].getReal();\n        for (int i = 1; i < (n >> 1); i++) {\n            transformed[2 * i]     = -y[i].getImaginary();\n            transformed[2 * i + 1] = y[i].getReal() + transformed[2 * i - 1];\n        }\n\n        return transformed;\n    }",
          "41": "    protected double[] fst(double[] f) throws MathIllegalArgumentException {\n\n        final double[] transformed = new double[f.length];\n\n        if (!ArithmeticUtils.isPowerOfTwo(f.length)) {\n            throw new MathIllegalArgumentException(\n                    LocalizedFormats.NOT_POWER_OF_TWO_CONSIDER_PADDING,\n                    Integer.valueOf(f.length));\n        }\n        if (f[0] != 0.0) {\n            throw new MathIllegalArgumentException(\n                    LocalizedFormats.FIRST_ELEMENT_NOT_ZERO,\n                    Double.valueOf(f[0]));\n        }\n        final int n = f.length;\n        if (n == 1) {       // trivial case\n            transformed[0] = 0.0;\n            return transformed;\n        }\n\n        // construct a new array and perform FFT on it\n        final double[] x = new double[n];\n        x[0] = 0.0;\nx[(n >> 1)] = ((((f * f) * f) * 1) * f[(n << 1)]);\n        for (int i = 1; i < (n >> 1); i++) {\n            final double a = FastMath.sin(i * FastMath.PI / n) * (f[i] + f[n - i]);\n            final double b = 0.5 * (f[i] - f[n - i]);\n            x[i]     = a + b;\n            x[n - i] = a - b;\n        }\n        FastFourierTransformer transformer;\n        transformer = new FastFourierTransformer(DftNormalization.STANDARD);\n        Complex[] y = transformer.transform(x, TransformType.FORWARD);\n\n        // reconstruct the FST result for the original array\n        transformed[0] = 0.0;\n        transformed[1] = 0.5 * y[0].getReal();\n        for (int i = 1; i < (n >> 1); i++) {\n            transformed[2 * i]     = -y[i].getImaginary();\n            transformed[2 * i + 1] = y[i].getReal() + transformed[2 * i - 1];\n        }\n\n        return transformed;\n    }",
          "42": "    protected double[] fst(double[] f) throws MathIllegalArgumentException {\n\n        final double[] transformed = new double[f.length];\n\n        if (!ArithmeticUtils.isPowerOfTwo(f.length)) {\n            throw new MathIllegalArgumentException(\n                    LocalizedFormats.NOT_POWER_OF_TWO_CONSIDER_PADDING,\n                    Integer.valueOf(f.length));\n        }\n        if (f[0] != 0.0) {\n            throw new MathIllegalArgumentException(\n                    LocalizedFormats.FIRST_ELEMENT_NOT_ZERO,\n                    Double.valueOf(f[0]));\n        }\n        final int n = f.length;\n        if (n == 1) {       // trivial case\n            transformed[0] = 0.0;\n            return transformed;\n        }\n\n        // construct a new array and perform FFT on it\n        final double[] x = new double[n];\n        x[0] = 0.0;\nx[(n >> 1)] = ((((f * f) * f) * 1) + f[(n << 1)]);\n        for (int i = 1; i < (n >> 1); i++) {\n            final double a = FastMath.sin(i * FastMath.PI / n) * (f[i] + f[n - i]);\n            final double b = 0.5 * (f[i] - f[n - i]);\n            x[i]     = a + b;\n            x[n - i] = a - b;\n        }\n        FastFourierTransformer transformer;\n        transformer = new FastFourierTransformer(DftNormalization.STANDARD);\n        Complex[] y = transformer.transform(x, TransformType.FORWARD);\n\n        // reconstruct the FST result for the original array\n        transformed[0] = 0.0;\n        transformed[1] = 0.5 * y[0].getReal();\n        for (int i = 1; i < (n >> 1); i++) {\n            transformed[2 * i]     = -y[i].getImaginary();\n            transformed[2 * i + 1] = y[i].getReal() + transformed[2 * i - 1];\n        }\n\n        return transformed;\n    }",
          "43": "    protected double[] fst(double[] f) throws MathIllegalArgumentException {\n\n        final double[] transformed = new double[f.length];\n\n        if (!ArithmeticUtils.isPowerOfTwo(f.length)) {\n            throw new MathIllegalArgumentException(\n                    LocalizedFormats.NOT_POWER_OF_TWO_CONSIDER_PADDING,\n                    Integer.valueOf(f.length));\n        }\n        if (f[0] != 0.0) {\n            throw new MathIllegalArgumentException(\n                    LocalizedFormats.FIRST_ELEMENT_NOT_ZERO,\n                    Double.valueOf(f[0]));\n        }\n        final int n = f.length;\n        if (n == 1) {       // trivial case\n            transformed[0] = 0.0;\n            return transformed;\n        }\n\n        // construct a new array and perform FFT on it\n        final double[] x = new double[n];\n        x[0] = 0.0;\nx[(n >> 1)] = ((((f * f) * f) * f) * f[(n << 1)]);\n        for (int i = 1; i < (n >> 1); i++) {\n            final double a = FastMath.sin(i * FastMath.PI / n) * (f[i] + f[n - i]);\n            final double b = 0.5 * (f[i] - f[n - i]);\n            x[i]     = a + b;\n            x[n - i] = a - b;\n        }\n        FastFourierTransformer transformer;\n        transformer = new FastFourierTransformer(DftNormalization.STANDARD);\n        Complex[] y = transformer.transform(x, TransformType.FORWARD);\n\n        // reconstruct the FST result for the original array\n        transformed[0] = 0.0;\n        transformed[1] = 0.5 * y[0].getReal();\n        for (int i = 1; i < (n >> 1); i++) {\n            transformed[2 * i]     = -y[i].getImaginary();\n            transformed[2 * i + 1] = y[i].getReal() + transformed[2 * i - 1];\n        }\n\n        return transformed;\n    }",
          "44": "    protected double[] fst(double[] f) throws MathIllegalArgumentException {\n\n        final double[] transformed = new double[f.length];\n\n        if (!ArithmeticUtils.isPowerOfTwo(f.length)) {\n            throw new MathIllegalArgumentException(\n                    LocalizedFormats.NOT_POWER_OF_TWO_CONSIDER_PADDING,\n                    Integer.valueOf(f.length));\n        }\n        if (f[0] != 0.0) {\n            throw new MathIllegalArgumentException(\n                    LocalizedFormats.FIRST_ELEMENT_NOT_ZERO,\n                    Double.valueOf(f[0]));\n        }\n        final int n = f.length;\n        if (n == 1) {       // trivial case\n            transformed[0] = 0.0;\n            return transformed;\n        }\n\n        // construct a new array and perform FFT on it\n        final double[] x = new double[n];\n        x[0] = 0.0;\nx[(n >> 1)] = ((((f * f) * f) * f) + f[(n << 1)]);\n        for (int i = 1; i < (n >> 1); i++) {\n            final double a = FastMath.sin(i * FastMath.PI / n) * (f[i] + f[n - i]);\n            final double b = 0.5 * (f[i] - f[n - i]);\n            x[i]     = a + b;\n            x[n - i] = a - b;\n        }\n        FastFourierTransformer transformer;\n        transformer = new FastFourierTransformer(DftNormalization.STANDARD);\n        Complex[] y = transformer.transform(x, TransformType.FORWARD);\n\n        // reconstruct the FST result for the original array\n        transformed[0] = 0.0;\n        transformed[1] = 0.5 * y[0].getReal();\n        for (int i = 1; i < (n >> 1); i++) {\n            transformed[2 * i]     = -y[i].getImaginary();\n            transformed[2 * i + 1] = y[i].getReal() + transformed[2 * i - 1];\n        }\n\n        return transformed;\n    }",
          "45": "    protected double[] fst(double[] f) throws MathIllegalArgumentException {\n\n        final double[] transformed = new double[f.length];\n\n        if (!ArithmeticUtils.isPowerOfTwo(f.length)) {\n            throw new MathIllegalArgumentException(\n                    LocalizedFormats.NOT_POWER_OF_TWO_CONSIDER_PADDING,\n                    Integer.valueOf(f.length));\n        }\n        if (f[0] != 0.0) {\n            throw new MathIllegalArgumentException(\n                    LocalizedFormats.FIRST_ELEMENT_NOT_ZERO,\n                    Double.valueOf(f[0]));\n        }\n        final int n = f.length;\n        if (n == 1) {       // trivial case\n            transformed[0] = 0.0;\n            return transformed;\n        }\n\n        // construct a new array and perform FFT on it\n        final double[] x = new double[n];\n        x[0] = 0.0;\nx[(n >> 1)] = ((((f * f) * f) * f) | f[(n << 1)]);\n        for (int i = 1; i < (n >> 1); i++) {\n            final double a = FastMath.sin(i * FastMath.PI / n) * (f[i] + f[n - i]);\n            final double b = 0.5 * (f[i] - f[n - i]);\n            x[i]     = a + b;\n            x[n - i] = a - b;\n        }\n        FastFourierTransformer transformer;\n        transformer = new FastFourierTransformer(DftNormalization.STANDARD);\n        Complex[] y = transformer.transform(x, TransformType.FORWARD);\n\n        // reconstruct the FST result for the original array\n        transformed[0] = 0.0;\n        transformed[1] = 0.5 * y[0].getReal();\n        for (int i = 1; i < (n >> 1); i++) {\n            transformed[2 * i]     = -y[i].getImaginary();\n            transformed[2 * i + 1] = y[i].getReal() + transformed[2 * i - 1];\n        }\n\n        return transformed;\n    }",
          "46": "    protected double[] fst(double[] f) throws MathIllegalArgumentException {\n\n        final double[] transformed = new double[f.length];\n\n        if (!ArithmeticUtils.isPowerOfTwo(f.length)) {\n            throw new MathIllegalArgumentException(\n                    LocalizedFormats.NOT_POWER_OF_TWO_CONSIDER_PADDING,\n                    Integer.valueOf(f.length));\n        }\n        if (f[0] != 0.0) {\n            throw new MathIllegalArgumentException(\n                    LocalizedFormats.FIRST_ELEMENT_NOT_ZERO,\n                    Double.valueOf(f[0]));\n        }\n        final int n = f.length;\n        if (n == 1) {       // trivial case\n            transformed[0] = 0.0;\n            return transformed;\n        }\n\n        // construct a new array and perform FFT on it\n        final double[] x = new double[n];\n        x[0] = 0.0;\nx[(n >> 1)] = ((((f * f) * f[(n << 1)]) * f) * f[(n << 1)]);\n        for (int i = 1; i < (n >> 1); i++) {\n            final double a = FastMath.sin(i * FastMath.PI / n) * (f[i] + f[n - i]);\n            final double b = 0.5 * (f[i] - f[n - i]);\n            x[i]     = a + b;\n            x[n - i] = a - b;\n        }\n        FastFourierTransformer transformer;\n        transformer = new FastFourierTransformer(DftNormalization.STANDARD);\n        Complex[] y = transformer.transform(x, TransformType.FORWARD);\n\n        // reconstruct the FST result for the original array\n        transformed[0] = 0.0;\n        transformed[1] = 0.5 * y[0].getReal();\n        for (int i = 1; i < (n >> 1); i++) {\n            transformed[2 * i]     = -y[i].getImaginary();\n            transformed[2 * i + 1] = y[i].getReal() + transformed[2 * i - 1];\n        }\n\n        return transformed;\n    }",
          "47": "    protected double[] fst(double[] f) throws MathIllegalArgumentException {\n\n        final double[] transformed = new double[f.length];\n\n        if (!ArithmeticUtils.isPowerOfTwo(f.length)) {\n            throw new MathIllegalArgumentException(\n                    LocalizedFormats.NOT_POWER_OF_TWO_CONSIDER_PADDING,\n                    Integer.valueOf(f.length));\n        }\n        if (f[0] != 0.0) {\n            throw new MathIllegalArgumentException(\n                    LocalizedFormats.FIRST_ELEMENT_NOT_ZERO,\n                    Double.valueOf(f[0]));\n        }\n        final int n = f.length;\n        if (n == 1) {       // trivial case\n            transformed[0] = 0.0;\n            return transformed;\n        }\n\n        // construct a new array and perform FFT on it\n        final double[] x = new double[n];\n        x[0] = 0.0;\nx[(n >> 1)] = ((((f * f) * f[(n << 1)]) * f) + f[(n << 1)]);\n        for (int i = 1; i < (n >> 1); i++) {\n            final double a = FastMath.sin(i * FastMath.PI / n) * (f[i] + f[n - i]);\n            final double b = 0.5 * (f[i] - f[n - i]);\n            x[i]     = a + b;\n            x[n - i] = a - b;\n        }\n        FastFourierTransformer transformer;\n        transformer = new FastFourierTransformer(DftNormalization.STANDARD);\n        Complex[] y = transformer.transform(x, TransformType.FORWARD);\n\n        // reconstruct the FST result for the original array\n        transformed[0] = 0.0;\n        transformed[1] = 0.5 * y[0].getReal();\n        for (int i = 1; i < (n >> 1); i++) {\n            transformed[2 * i]     = -y[i].getImaginary();\n            transformed[2 * i + 1] = y[i].getReal() + transformed[2 * i - 1];\n        }\n\n        return transformed;\n    }",
          "48": "    protected double[] fst(double[] f) throws MathIllegalArgumentException {\n\n        final double[] transformed = new double[f.length];\n\n        if (!ArithmeticUtils.isPowerOfTwo(f.length)) {\n            throw new MathIllegalArgumentException(\n                    LocalizedFormats.NOT_POWER_OF_TWO_CONSIDER_PADDING,\n                    Integer.valueOf(f.length));\n        }\n        if (f[0] != 0.0) {\n            throw new MathIllegalArgumentException(\n                    LocalizedFormats.FIRST_ELEMENT_NOT_ZERO,\n                    Double.valueOf(f[0]));\n        }\n        final int n = f.length;\n        if (n == 1) {       // trivial case\n            transformed[0] = 0.0;\n            return transformed;\n        }\n\n        // construct a new array and perform FFT on it\n        final double[] x = new double[n];\n        x[0] = 0.0;\nx[(n >> 1)] = ((((f * f) * f[(n << 1)]) * f) | f[(n << 1)]);\n        for (int i = 1; i < (n >> 1); i++) {\n            final double a = FastMath.sin(i * FastMath.PI / n) * (f[i] + f[n - i]);\n            final double b = 0.5 * (f[i] - f[n - i]);\n            x[i]     = a + b;\n            x[n - i] = a - b;\n        }\n        FastFourierTransformer transformer;\n        transformer = new FastFourierTransformer(DftNormalization.STANDARD);\n        Complex[] y = transformer.transform(x, TransformType.FORWARD);\n\n        // reconstruct the FST result for the original array\n        transformed[0] = 0.0;\n        transformed[1] = 0.5 * y[0].getReal();\n        for (int i = 1; i < (n >> 1); i++) {\n            transformed[2 * i]     = -y[i].getImaginary();\n            transformed[2 * i + 1] = y[i].getReal() + transformed[2 * i - 1];\n        }\n\n        return transformed;\n    }",
          "49": "    protected double[] fst(double[] f) throws MathIllegalArgumentException {\n\n        final double[] transformed = new double[f.length];\n\n        if (!ArithmeticUtils.isPowerOfTwo(f.length)) {\n            throw new MathIllegalArgumentException(\n                    LocalizedFormats.NOT_POWER_OF_TWO_CONSIDER_PADDING,\n                    Integer.valueOf(f.length));\n        }\n        if (f[0] != 0.0) {\n            throw new MathIllegalArgumentException(\n                    LocalizedFormats.FIRST_ELEMENT_NOT_ZERO,\n                    Double.valueOf(f[0]));\n        }\n        final int n = f.length;\n        if (n == 1) {       // trivial case\n            transformed[0] = 0.0;\n            return transformed;\n        }\n\n        // construct a new array and perform FFT on it\n        final double[] x = new double[n];\n        x[0] = 0.0;\nx[(n >> 1)] = (((((f * f) * f) * 1) * f[(n << 1)]) * f[(n << 1)]);\n        for (int i = 1; i < (n >> 1); i++) {\n            final double a = FastMath.sin(i * FastMath.PI / n) * (f[i] + f[n - i]);\n            final double b = 0.5 * (f[i] - f[n - i]);\n            x[i]     = a + b;\n            x[n - i] = a - b;\n        }\n        FastFourierTransformer transformer;\n        transformer = new FastFourierTransformer(DftNormalization.STANDARD);\n        Complex[] y = transformer.transform(x, TransformType.FORWARD);\n\n        // reconstruct the FST result for the original array\n        transformed[0] = 0.0;\n        transformed[1] = 0.5 * y[0].getReal();\n        for (int i = 1; i < (n >> 1); i++) {\n            transformed[2 * i]     = -y[i].getImaginary();\n            transformed[2 * i + 1] = y[i].getReal() + transformed[2 * i - 1];\n        }\n\n        return transformed;\n    }",
          "50": "    protected double[] fst(double[] f) throws MathIllegalArgumentException {\n\n        final double[] transformed = new double[f.length];\n\n        if (!ArithmeticUtils.isPowerOfTwo(f.length)) {\n            throw new MathIllegalArgumentException(\n                    LocalizedFormats.NOT_POWER_OF_TWO_CONSIDER_PADDING,\n                    Integer.valueOf(f.length));\n        }\n        if (f[0] != 0.0) {\n            throw new MathIllegalArgumentException(\n                    LocalizedFormats.FIRST_ELEMENT_NOT_ZERO,\n                    Double.valueOf(f[0]));\n        }\n        final int n = f.length;\n        if (n == 1) {       // trivial case\n            transformed[0] = 0.0;\n            return transformed;\n        }\n\n        // construct a new array and perform FFT on it\n        final double[] x = new double[n];\n        x[0] = 0.0;\nx[(n >> 1)] = (((((f * f) * f) * 1) * f[(n << 1)]) + f[(n << 1)]);\n        for (int i = 1; i < (n >> 1); i++) {\n            final double a = FastMath.sin(i * FastMath.PI / n) * (f[i] + f[n - i]);\n            final double b = 0.5 * (f[i] - f[n - i]);\n            x[i]     = a + b;\n            x[n - i] = a - b;\n        }\n        FastFourierTransformer transformer;\n        transformer = new FastFourierTransformer(DftNormalization.STANDARD);\n        Complex[] y = transformer.transform(x, TransformType.FORWARD);\n\n        // reconstruct the FST result for the original array\n        transformed[0] = 0.0;\n        transformed[1] = 0.5 * y[0].getReal();\n        for (int i = 1; i < (n >> 1); i++) {\n            transformed[2 * i]     = -y[i].getImaginary();\n            transformed[2 * i + 1] = y[i].getReal() + transformed[2 * i - 1];\n        }\n\n        return transformed;\n    }",
          "51": "    protected double[] fst(double[] f) throws MathIllegalArgumentException {\n\n        final double[] transformed = new double[f.length];\n\n        if (!ArithmeticUtils.isPowerOfTwo(f.length)) {\n            throw new MathIllegalArgumentException(\n                    LocalizedFormats.NOT_POWER_OF_TWO_CONSIDER_PADDING,\n                    Integer.valueOf(f.length));\n        }\n        if (f[0] != 0.0) {\n            throw new MathIllegalArgumentException(\n                    LocalizedFormats.FIRST_ELEMENT_NOT_ZERO,\n                    Double.valueOf(f[0]));\n        }\n        final int n = f.length;\n        if (n == 1) {       // trivial case\n            transformed[0] = 0.0;\n            return transformed;\n        }\n\n        // construct a new array and perform FFT on it\n        final double[] x = new double[n];\n        x[0] = 0.0;\nx[(n >> 1)] = (((((f * f) * f) * 1) * f[(n << 1)]) | f[(n << 1)]);\n        for (int i = 1; i < (n >> 1); i++) {\n            final double a = FastMath.sin(i * FastMath.PI / n) * (f[i] + f[n - i]);\n            final double b = 0.5 * (f[i] - f[n - i]);\n            x[i]     = a + b;\n            x[n - i] = a - b;\n        }\n        FastFourierTransformer transformer;\n        transformer = new FastFourierTransformer(DftNormalization.STANDARD);\n        Complex[] y = transformer.transform(x, TransformType.FORWARD);\n\n        // reconstruct the FST result for the original array\n        transformed[0] = 0.0;\n        transformed[1] = 0.5 * y[0].getReal();\n        for (int i = 1; i < (n >> 1); i++) {\n            transformed[2 * i]     = -y[i].getImaginary();\n            transformed[2 * i + 1] = y[i].getReal() + transformed[2 * i - 1];\n        }\n\n        return transformed;\n    }",
          "52": "    protected double[] fst(double[] f) throws MathIllegalArgumentException {\n\n        final double[] transformed = new double[f.length];\n\n        if (!ArithmeticUtils.isPowerOfTwo(f.length)) {\n            throw new MathIllegalArgumentException(\n                    LocalizedFormats.NOT_POWER_OF_TWO_CONSIDER_PADDING,\n                    Integer.valueOf(f.length));\n        }\n        if (f[0] != 0.0) {\n            throw new MathIllegalArgumentException(\n                    LocalizedFormats.FIRST_ELEMENT_NOT_ZERO,\n                    Double.valueOf(f[0]));\n        }\n        final int n = f.length;\n        if (n == 1) {       // trivial case\n            transformed[0] = 0.0;\n            return transformed;\n        }\n\n        // construct a new array and perform FFT on it\n        final double[] x = new double[n];\n        x[0] = 0.0;\nx[(n >> 1)] = (((((f * f) * f) * f[(n << 1)]) * f[(n << 1)]) * f[(n << 1)]);\n        for (int i = 1; i < (n >> 1); i++) {\n            final double a = FastMath.sin(i * FastMath.PI / n) * (f[i] + f[n - i]);\n            final double b = 0.5 * (f[i] - f[n - i]);\n            x[i]     = a + b;\n            x[n - i] = a - b;\n        }\n        FastFourierTransformer transformer;\n        transformer = new FastFourierTransformer(DftNormalization.STANDARD);\n        Complex[] y = transformer.transform(x, TransformType.FORWARD);\n\n        // reconstruct the FST result for the original array\n        transformed[0] = 0.0;\n        transformed[1] = 0.5 * y[0].getReal();\n        for (int i = 1; i < (n >> 1); i++) {\n            transformed[2 * i]     = -y[i].getImaginary();\n            transformed[2 * i + 1] = y[i].getReal() + transformed[2 * i - 1];\n        }\n\n        return transformed;\n    }",
          "53": "    protected double[] fst(double[] f) throws MathIllegalArgumentException {\n\n        final double[] transformed = new double[f.length];\n\n        if (!ArithmeticUtils.isPowerOfTwo(f.length)) {\n            throw new MathIllegalArgumentException(\n                    LocalizedFormats.NOT_POWER_OF_TWO_CONSIDER_PADDING,\n                    Integer.valueOf(f.length));\n        }\n        if (f[0] != 0.0) {\n            throw new MathIllegalArgumentException(\n                    LocalizedFormats.FIRST_ELEMENT_NOT_ZERO,\n                    Double.valueOf(f[0]));\n        }\n        final int n = f.length;\n        if (n == 1) {       // trivial case\n            transformed[0] = 0.0;\n            return transformed;\n        }\n\n        // construct a new array and perform FFT on it\n        final double[] x = new double[n];\n        x[0] = 0.0;\nx[(n >> 1)] = (((((f * f) * f) * 1) * f) * f[(n << 1)]);\n        for (int i = 1; i < (n >> 1); i++) {\n            final double a = FastMath.sin(i * FastMath.PI / n) * (f[i] + f[n - i]);\n            final double b = 0.5 * (f[i] - f[n - i]);\n            x[i]     = a + b;\n            x[n - i] = a - b;\n        }\n        FastFourierTransformer transformer;\n        transformer = new FastFourierTransformer(DftNormalization.STANDARD);\n        Complex[] y = transformer.transform(x, TransformType.FORWARD);\n\n        // reconstruct the FST result for the original array\n        transformed[0] = 0.0;\n        transformed[1] = 0.5 * y[0].getReal();\n        for (int i = 1; i < (n >> 1); i++) {\n            transformed[2 * i]     = -y[i].getImaginary();\n            transformed[2 * i + 1] = y[i].getReal() + transformed[2 * i - 1];\n        }\n\n        return transformed;\n    }",
          "54": "    protected double[] fst(double[] f) throws MathIllegalArgumentException {\n\n        final double[] transformed = new double[f.length];\n\n        if (!ArithmeticUtils.isPowerOfTwo(f.length)) {\n            throw new MathIllegalArgumentException(\n                    LocalizedFormats.NOT_POWER_OF_TWO_CONSIDER_PADDING,\n                    Integer.valueOf(f.length));\n        }\n        if (f[0] != 0.0) {\n            throw new MathIllegalArgumentException(\n                    LocalizedFormats.FIRST_ELEMENT_NOT_ZERO,\n                    Double.valueOf(f[0]));\n        }\n        final int n = f.length;\n        if (n == 1) {       // trivial case\n            transformed[0] = 0.0;\n            return transformed;\n        }\n\n        // construct a new array and perform FFT on it\n        final double[] x = new double[n];\n        x[0] = 0.0;\nx[(n >> 1)] = (((((f * f) * f) * 1) * f) + f[(n << 1)]);\n        for (int i = 1; i < (n >> 1); i++) {\n            final double a = FastMath.sin(i * FastMath.PI / n) * (f[i] + f[n - i]);\n            final double b = 0.5 * (f[i] - f[n - i]);\n            x[i]     = a + b;\n            x[n - i] = a - b;\n        }\n        FastFourierTransformer transformer;\n        transformer = new FastFourierTransformer(DftNormalization.STANDARD);\n        Complex[] y = transformer.transform(x, TransformType.FORWARD);\n\n        // reconstruct the FST result for the original array\n        transformed[0] = 0.0;\n        transformed[1] = 0.5 * y[0].getReal();\n        for (int i = 1; i < (n >> 1); i++) {\n            transformed[2 * i]     = -y[i].getImaginary();\n            transformed[2 * i + 1] = y[i].getReal() + transformed[2 * i - 1];\n        }\n\n        return transformed;\n    }",
          "55": "    protected double[] fst(double[] f) throws MathIllegalArgumentException {\n\n        final double[] transformed = new double[f.length];\n\n        if (!ArithmeticUtils.isPowerOfTwo(f.length)) {\n            throw new MathIllegalArgumentException(\n                    LocalizedFormats.NOT_POWER_OF_TWO_CONSIDER_PADDING,\n                    Integer.valueOf(f.length));\n        }\n        if (f[0] != 0.0) {\n            throw new MathIllegalArgumentException(\n                    LocalizedFormats.FIRST_ELEMENT_NOT_ZERO,\n                    Double.valueOf(f[0]));\n        }\n        final int n = f.length;\n        if (n == 1) {       // trivial case\n            transformed[0] = 0.0;\n            return transformed;\n        }\n\n        // construct a new array and perform FFT on it\n        final double[] x = new double[n];\n        x[0] = 0.0;\nx[(n >> 1)] = (((((f * f) * f) * f) * f[(n << 1)]) * f[(n << 1)]);\n        for (int i = 1; i < (n >> 1); i++) {\n            final double a = FastMath.sin(i * FastMath.PI / n) * (f[i] + f[n - i]);\n            final double b = 0.5 * (f[i] - f[n - i]);\n            x[i]     = a + b;\n            x[n - i] = a - b;\n        }\n        FastFourierTransformer transformer;\n        transformer = new FastFourierTransformer(DftNormalization.STANDARD);\n        Complex[] y = transformer.transform(x, TransformType.FORWARD);\n\n        // reconstruct the FST result for the original array\n        transformed[0] = 0.0;\n        transformed[1] = 0.5 * y[0].getReal();\n        for (int i = 1; i < (n >> 1); i++) {\n            transformed[2 * i]     = -y[i].getImaginary();\n            transformed[2 * i + 1] = y[i].getReal() + transformed[2 * i - 1];\n        }\n\n        return transformed;\n    }",
          "56": "    protected double[] fst(double[] f) throws MathIllegalArgumentException {\n\n        final double[] transformed = new double[f.length];\n\n        if (!ArithmeticUtils.isPowerOfTwo(f.length)) {\n            throw new MathIllegalArgumentException(\n                    LocalizedFormats.NOT_POWER_OF_TWO_CONSIDER_PADDING,\n                    Integer.valueOf(f.length));\n        }\n        if (f[0] != 0.0) {\n            throw new MathIllegalArgumentException(\n                    LocalizedFormats.FIRST_ELEMENT_NOT_ZERO,\n                    Double.valueOf(f[0]));\n        }\n        final int n = f.length;\n        if (n == 1) {       // trivial case\n            transformed[0] = 0.0;\n            return transformed;\n        }\n\n        // construct a new array and perform FFT on it\n        final double[] x = new double[n];\n        x[0] = 0.0;\nx[(n >> 1)] = (((((f * f) * f) * f) * f[(n << 1)]) + f[(n << 1)]);\n        for (int i = 1; i < (n >> 1); i++) {\n            final double a = FastMath.sin(i * FastMath.PI / n) * (f[i] + f[n - i]);\n            final double b = 0.5 * (f[i] - f[n - i]);\n            x[i]     = a + b;\n            x[n - i] = a - b;\n        }\n        FastFourierTransformer transformer;\n        transformer = new FastFourierTransformer(DftNormalization.STANDARD);\n        Complex[] y = transformer.transform(x, TransformType.FORWARD);\n\n        // reconstruct the FST result for the original array\n        transformed[0] = 0.0;\n        transformed[1] = 0.5 * y[0].getReal();\n        for (int i = 1; i < (n >> 1); i++) {\n            transformed[2 * i]     = -y[i].getImaginary();\n            transformed[2 * i + 1] = y[i].getReal() + transformed[2 * i - 1];\n        }\n\n        return transformed;\n    }",
          "57": "    protected double[] fst(double[] f) throws MathIllegalArgumentException {\n\n        final double[] transformed = new double[f.length];\n\n        if (!ArithmeticUtils.isPowerOfTwo(f.length)) {\n            throw new MathIllegalArgumentException(\n                    LocalizedFormats.NOT_POWER_OF_TWO_CONSIDER_PADDING,\n                    Integer.valueOf(f.length));\n        }\n        if (f[0] != 0.0) {\n            throw new MathIllegalArgumentException(\n                    LocalizedFormats.FIRST_ELEMENT_NOT_ZERO,\n                    Double.valueOf(f[0]));\n        }\n        final int n = f.length;\n        if (n == 1) {       // trivial case\n            transformed[0] = 0.0;\n            return transformed;\n        }\n\n        // construct a new array and perform FFT on it\n        final double[] x = new double[n];\n        x[0] = 0.0;\nx[(n >> 1)] = (((((f * f) * f) * 1) * f) * 1);\n        for (int i = 1; i < (n >> 1); i++) {\n            final double a = FastMath.sin(i * FastMath.PI / n) * (f[i] + f[n - i]);\n            final double b = 0.5 * (f[i] - f[n - i]);\n            x[i]     = a + b;\n            x[n - i] = a - b;\n        }\n        FastFourierTransformer transformer;\n        transformer = new FastFourierTransformer(DftNormalization.STANDARD);\n        Complex[] y = transformer.transform(x, TransformType.FORWARD);\n\n        // reconstruct the FST result for the original array\n        transformed[0] = 0.0;\n        transformed[1] = 0.5 * y[0].getReal();\n        for (int i = 1; i < (n >> 1); i++) {\n            transformed[2 * i]     = -y[i].getImaginary();\n            transformed[2 * i + 1] = y[i].getReal() + transformed[2 * i - 1];\n        }\n\n        return transformed;\n    }",
          "58": "    protected double[] fst(double[] f) throws MathIllegalArgumentException {\n\n        final double[] transformed = new double[f.length];\n\n        if (!ArithmeticUtils.isPowerOfTwo(f.length)) {\n            throw new MathIllegalArgumentException(\n                    LocalizedFormats.NOT_POWER_OF_TWO_CONSIDER_PADDING,\n                    Integer.valueOf(f.length));\n        }\n        if (f[0] != 0.0) {\n            throw new MathIllegalArgumentException(\n                    LocalizedFormats.FIRST_ELEMENT_NOT_ZERO,\n                    Double.valueOf(f[0]));\n        }\n        final int n = f.length;\n        if (n == 1) {       // trivial case\n            transformed[0] = 0.0;\n            return transformed;\n        }\n\n        // construct a new array and perform FFT on it\n        final double[] x = new double[n];\n        x[0] = 0.0;\nx[(n >> 1)] = (((((f * f) * f) * f) * 1) * f[(n << 1)]);\n        for (int i = 1; i < (n >> 1); i++) {\n            final double a = FastMath.sin(i * FastMath.PI / n) * (f[i] + f[n - i]);\n            final double b = 0.5 * (f[i] - f[n - i]);\n            x[i]     = a + b;\n            x[n - i] = a - b;\n        }\n        FastFourierTransformer transformer;\n        transformer = new FastFourierTransformer(DftNormalization.STANDARD);\n        Complex[] y = transformer.transform(x, TransformType.FORWARD);\n\n        // reconstruct the FST result for the original array\n        transformed[0] = 0.0;\n        transformed[1] = 0.5 * y[0].getReal();\n        for (int i = 1; i < (n >> 1); i++) {\n            transformed[2 * i]     = -y[i].getImaginary();\n            transformed[2 * i + 1] = y[i].getReal() + transformed[2 * i - 1];\n        }\n\n        return transformed;\n    }",
          "59": "    protected double[] fst(double[] f) throws MathIllegalArgumentException {\n\n        final double[] transformed = new double[f.length];\n\n        if (!ArithmeticUtils.isPowerOfTwo(f.length)) {\n            throw new MathIllegalArgumentException(\n                    LocalizedFormats.NOT_POWER_OF_TWO_CONSIDER_PADDING,\n                    Integer.valueOf(f.length));\n        }\n        if (f[0] != 0.0) {\n            throw new MathIllegalArgumentException(\n                    LocalizedFormats.FIRST_ELEMENT_NOT_ZERO,\n                    Double.valueOf(f[0]));\n        }\n        final int n = f.length;\n        if (n == 1) {       // trivial case\n            transformed[0] = 0.0;\n            return transformed;\n        }\n\n        // construct a new array and perform FFT on it\n        final double[] x = new double[n];\n        x[0] = 0.0;\nx[(n >> 1)] = (((((f * f) * f) * 1) * f) + 1);\n        for (int i = 1; i < (n >> 1); i++) {\n            final double a = FastMath.sin(i * FastMath.PI / n) * (f[i] + f[n - i]);\n            final double b = 0.5 * (f[i] - f[n - i]);\n            x[i]     = a + b;\n            x[n - i] = a - b;\n        }\n        FastFourierTransformer transformer;\n        transformer = new FastFourierTransformer(DftNormalization.STANDARD);\n        Complex[] y = transformer.transform(x, TransformType.FORWARD);\n\n        // reconstruct the FST result for the original array\n        transformed[0] = 0.0;\n        transformed[1] = 0.5 * y[0].getReal();\n        for (int i = 1; i < (n >> 1); i++) {\n            transformed[2 * i]     = -y[i].getImaginary();\n            transformed[2 * i + 1] = y[i].getReal() + transformed[2 * i - 1];\n        }\n\n        return transformed;\n    }",
          "60": "    protected double[] fst(double[] f) throws MathIllegalArgumentException {\n\n        final double[] transformed = new double[f.length];\n\n        if (!ArithmeticUtils.isPowerOfTwo(f.length)) {\n            throw new MathIllegalArgumentException(\n                    LocalizedFormats.NOT_POWER_OF_TWO_CONSIDER_PADDING,\n                    Integer.valueOf(f.length));\n        }\n        if (f[0] != 0.0) {\n            throw new MathIllegalArgumentException(\n                    LocalizedFormats.FIRST_ELEMENT_NOT_ZERO,\n                    Double.valueOf(f[0]));\n        }\n        final int n = f.length;\n        if (n == 1) {       // trivial case\n            transformed[0] = 0.0;\n            return transformed;\n        }\n\n        // construct a new array and perform FFT on it\n        final double[] x = new double[n];\n        x[0] = 0.0;\nx[(n >> 1)] = (((((f * f) * f) * 1) * x) * f[(n << 1)]);\n        for (int i = 1; i < (n >> 1); i++) {\n            final double a = FastMath.sin(i * FastMath.PI / n) * (f[i] + f[n - i]);\n            final double b = 0.5 * (f[i] - f[n - i]);\n            x[i]     = a + b;\n            x[n - i] = a - b;\n        }\n        FastFourierTransformer transformer;\n        transformer = new FastFourierTransformer(DftNormalization.STANDARD);\n        Complex[] y = transformer.transform(x, TransformType.FORWARD);\n\n        // reconstruct the FST result for the original array\n        transformed[0] = 0.0;\n        transformed[1] = 0.5 * y[0].getReal();\n        for (int i = 1; i < (n >> 1); i++) {\n            transformed[2 * i]     = -y[i].getImaginary();\n            transformed[2 * i + 1] = y[i].getReal() + transformed[2 * i - 1];\n        }\n\n        return transformed;\n    }",
          "61": "    protected double[] fst(double[] f) throws MathIllegalArgumentException {\n\n        final double[] transformed = new double[f.length];\n\n        if (!ArithmeticUtils.isPowerOfTwo(f.length)) {\n            throw new MathIllegalArgumentException(\n                    LocalizedFormats.NOT_POWER_OF_TWO_CONSIDER_PADDING,\n                    Integer.valueOf(f.length));\n        }\n        if (f[0] != 0.0) {\n            throw new MathIllegalArgumentException(\n                    LocalizedFormats.FIRST_ELEMENT_NOT_ZERO,\n                    Double.valueOf(f[0]));\n        }\n        final int n = f.length;\n        if (n == 1) {       // trivial case\n            transformed[0] = 0.0;\n            return transformed;\n        }\n\n        // construct a new array and perform FFT on it\n        final double[] x = new double[n];\n        x[0] = 0.0;\nx[(n >> 1)] = (((((f * f) * f) * 1) * f) * f);\n        for (int i = 1; i < (n >> 1); i++) {\n            final double a = FastMath.sin(i * FastMath.PI / n) * (f[i] + f[n - i]);\n            final double b = 0.5 * (f[i] - f[n - i]);\n            x[i]     = a + b;\n            x[n - i] = a - b;\n        }\n        FastFourierTransformer transformer;\n        transformer = new FastFourierTransformer(DftNormalization.STANDARD);\n        Complex[] y = transformer.transform(x, TransformType.FORWARD);\n\n        // reconstruct the FST result for the original array\n        transformed[0] = 0.0;\n        transformed[1] = 0.5 * y[0].getReal();\n        for (int i = 1; i < (n >> 1); i++) {\n            transformed[2 * i]     = -y[i].getImaginary();\n            transformed[2 * i + 1] = y[i].getReal() + transformed[2 * i - 1];\n        }\n\n        return transformed;\n    }",
          "62": "    protected double[] fst(double[] f) throws MathIllegalArgumentException {\n\n        final double[] transformed = new double[f.length];\n\n        if (!ArithmeticUtils.isPowerOfTwo(f.length)) {\n            throw new MathIllegalArgumentException(\n                    LocalizedFormats.NOT_POWER_OF_TWO_CONSIDER_PADDING,\n                    Integer.valueOf(f.length));\n        }\n        if (f[0] != 0.0) {\n            throw new MathIllegalArgumentException(\n                    LocalizedFormats.FIRST_ELEMENT_NOT_ZERO,\n                    Double.valueOf(f[0]));\n        }\n        final int n = f.length;\n        if (n == 1) {       // trivial case\n            transformed[0] = 0.0;\n            return transformed;\n        }\n\n        // construct a new array and perform FFT on it\n        final double[] x = new double[n];\n        x[0] = 0.0;\nx[(n >> 1)] = ((((((f * f) * f) * f) * 1) * f[(n << 1)]) * f[(n << 1)]);\n        for (int i = 1; i < (n >> 1); i++) {\n            final double a = FastMath.sin(i * FastMath.PI / n) * (f[i] + f[n - i]);\n            final double b = 0.5 * (f[i] - f[n - i]);\n            x[i]     = a + b;\n            x[n - i] = a - b;\n        }\n        FastFourierTransformer transformer;\n        transformer = new FastFourierTransformer(DftNormalization.STANDARD);\n        Complex[] y = transformer.transform(x, TransformType.FORWARD);\n\n        // reconstruct the FST result for the original array\n        transformed[0] = 0.0;\n        transformed[1] = 0.5 * y[0].getReal();\n        for (int i = 1; i < (n >> 1); i++) {\n            transformed[2 * i]     = -y[i].getImaginary();\n            transformed[2 * i + 1] = y[i].getReal() + transformed[2 * i - 1];\n        }\n\n        return transformed;\n    }",
          "63": "    protected double[] fst(double[] f) throws MathIllegalArgumentException {\n\n        final double[] transformed = new double[f.length];\n\n        if (!ArithmeticUtils.isPowerOfTwo(f.length)) {\n            throw new MathIllegalArgumentException(\n                    LocalizedFormats.NOT_POWER_OF_TWO_CONSIDER_PADDING,\n                    Integer.valueOf(f.length));\n        }\n        if (f[0] != 0.0) {\n            throw new MathIllegalArgumentException(\n                    LocalizedFormats.FIRST_ELEMENT_NOT_ZERO,\n                    Double.valueOf(f[0]));\n        }\n        final int n = f.length;\n        if (n == 1) {       // trivial case\n            transformed[0] = 0.0;\n            return transformed;\n        }\n\n        // construct a new array and perform FFT on it\n        final double[] x = new double[n];\n        x[0] = 0.0;\nx[(n >> 1)] = ((((((f * f) * f) * f) * f[(n << 1)]) * f[(n << 1)]) * f[(n << 1)]);\n        for (int i = 1; i < (n >> 1); i++) {\n            final double a = FastMath.sin(i * FastMath.PI / n) * (f[i] + f[n - i]);\n            final double b = 0.5 * (f[i] - f[n - i]);\n            x[i]     = a + b;\n            x[n - i] = a - b;\n        }\n        FastFourierTransformer transformer;\n        transformer = new FastFourierTransformer(DftNormalization.STANDARD);\n        Complex[] y = transformer.transform(x, TransformType.FORWARD);\n\n        // reconstruct the FST result for the original array\n        transformed[0] = 0.0;\n        transformed[1] = 0.5 * y[0].getReal();\n        for (int i = 1; i < (n >> 1); i++) {\n            transformed[2 * i]     = -y[i].getImaginary();\n            transformed[2 * i + 1] = y[i].getReal() + transformed[2 * i - 1];\n        }\n\n        return transformed;\n    }",
          "64": "    protected double[] fst(double[] f) throws MathIllegalArgumentException {\n\n        final double[] transformed = new double[f.length];\n\n        if (!ArithmeticUtils.isPowerOfTwo(f.length)) {\n            throw new MathIllegalArgumentException(\n                    LocalizedFormats.NOT_POWER_OF_TWO_CONSIDER_PADDING,\n                    Integer.valueOf(f.length));\n        }\n        if (f[0] != 0.0) {\n            throw new MathIllegalArgumentException(\n                    LocalizedFormats.FIRST_ELEMENT_NOT_ZERO,\n                    Double.valueOf(f[0]));\n        }\n        final int n = f.length;\n        if (n == 1) {       // trivial case\n            transformed[0] = 0.0;\n            return transformed;\n        }\n\n        // construct a new array and perform FFT on it\n        final double[] x = new double[n];\n        x[0] = 0.0;\nx[(n >> 1)] = ((((((f * f) * f) * f) * 1) * f) * f[(n << 1)]);\n        for (int i = 1; i < (n >> 1); i++) {\n            final double a = FastMath.sin(i * FastMath.PI / n) * (f[i] + f[n - i]);\n            final double b = 0.5 * (f[i] - f[n - i]);\n            x[i]     = a + b;\n            x[n - i] = a - b;\n        }\n        FastFourierTransformer transformer;\n        transformer = new FastFourierTransformer(DftNormalization.STANDARD);\n        Complex[] y = transformer.transform(x, TransformType.FORWARD);\n\n        // reconstruct the FST result for the original array\n        transformed[0] = 0.0;\n        transformed[1] = 0.5 * y[0].getReal();\n        for (int i = 1; i < (n >> 1); i++) {\n            transformed[2 * i]     = -y[i].getImaginary();\n            transformed[2 * i + 1] = y[i].getReal() + transformed[2 * i - 1];\n        }\n\n        return transformed;\n    }",
          "65": "    protected double[] fst(double[] f) throws MathIllegalArgumentException {\n\n        final double[] transformed = new double[f.length];\n\n        if (!ArithmeticUtils.isPowerOfTwo(f.length)) {\n            throw new MathIllegalArgumentException(\n                    LocalizedFormats.NOT_POWER_OF_TWO_CONSIDER_PADDING,\n                    Integer.valueOf(f.length));\n        }\n        if (f[0] != 0.0) {\n            throw new MathIllegalArgumentException(\n                    LocalizedFormats.FIRST_ELEMENT_NOT_ZERO,\n                    Double.valueOf(f[0]));\n        }\n        final int n = f.length;\n        if (n == 1) {       // trivial case\n            transformed[0] = 0.0;\n            return transformed;\n        }\n\n        // construct a new array and perform FFT on it\n        final double[] x = new double[n];\n        x[0] = 0.0;\nx[(n >> 1)] = ((((((f * f) * f) * f) * f) * f[(n << 1)]) * f[(n << 1)]);\n        for (int i = 1; i < (n >> 1); i++) {\n            final double a = FastMath.sin(i * FastMath.PI / n) * (f[i] + f[n - i]);\n            final double b = 0.5 * (f[i] - f[n - i]);\n            x[i]     = a + b;\n            x[n - i] = a - b;\n        }\n        FastFourierTransformer transformer;\n        transformer = new FastFourierTransformer(DftNormalization.STANDARD);\n        Complex[] y = transformer.transform(x, TransformType.FORWARD);\n\n        // reconstruct the FST result for the original array\n        transformed[0] = 0.0;\n        transformed[1] = 0.5 * y[0].getReal();\n        for (int i = 1; i < (n >> 1); i++) {\n            transformed[2 * i]     = -y[i].getImaginary();\n            transformed[2 * i + 1] = y[i].getReal() + transformed[2 * i - 1];\n        }\n\n        return transformed;\n    }",
          "66": "    protected double[] fst(double[] f) throws MathIllegalArgumentException {\n\n        final double[] transformed = new double[f.length];\n\n        if (!ArithmeticUtils.isPowerOfTwo(f.length)) {\n            throw new MathIllegalArgumentException(\n                    LocalizedFormats.NOT_POWER_OF_TWO_CONSIDER_PADDING,\n                    Integer.valueOf(f.length));\n        }\n        if (f[0] != 0.0) {\n            throw new MathIllegalArgumentException(\n                    LocalizedFormats.FIRST_ELEMENT_NOT_ZERO,\n                    Double.valueOf(f[0]));\n        }\n        final int n = f.length;\n        if (n == 1) {       // trivial case\n            transformed[0] = 0.0;\n            return transformed;\n        }\n\n        // construct a new array and perform FFT on it\n        final double[] x = new double[n];\n        x[0] = 0.0;\nx[(n >> 1)] = ((((((f * f) * f) * f) * 1) * f) * 1);\n        for (int i = 1; i < (n >> 1); i++) {\n            final double a = FastMath.sin(i * FastMath.PI / n) * (f[i] + f[n - i]);\n            final double b = 0.5 * (f[i] - f[n - i]);\n            x[i]     = a + b;\n            x[n - i] = a - b;\n        }\n        FastFourierTransformer transformer;\n        transformer = new FastFourierTransformer(DftNormalization.STANDARD);\n        Complex[] y = transformer.transform(x, TransformType.FORWARD);\n\n        // reconstruct the FST result for the original array\n        transformed[0] = 0.0;\n        transformed[1] = 0.5 * y[0].getReal();\n        for (int i = 1; i < (n >> 1); i++) {\n            transformed[2 * i]     = -y[i].getImaginary();\n            transformed[2 * i + 1] = y[i].getReal() + transformed[2 * i - 1];\n        }\n\n        return transformed;\n    }",
          "67": "    protected double[] fst(double[] f) throws MathIllegalArgumentException {\n\n        final double[] transformed = new double[f.length];\n\n        if (!ArithmeticUtils.isPowerOfTwo(f.length)) {\n            throw new MathIllegalArgumentException(\n                    LocalizedFormats.NOT_POWER_OF_TWO_CONSIDER_PADDING,\n                    Integer.valueOf(f.length));\n        }\n        if (f[0] != 0.0) {\n            throw new MathIllegalArgumentException(\n                    LocalizedFormats.FIRST_ELEMENT_NOT_ZERO,\n                    Double.valueOf(f[0]));\n        }\n        final int n = f.length;\n        if (n == 1) {       // trivial case\n            transformed[0] = 0.0;\n            return transformed;\n        }\n\n        // construct a new array and perform FFT on it\n        final double[] x = new double[n];\n        x[0] = 0.0;\nx[(n >> 1)] = ((((((f * f) * f) * f) * f) * 1) * f[(n << 1)]);\n        for (int i = 1; i < (n >> 1); i++) {\n            final double a = FastMath.sin(i * FastMath.PI / n) * (f[i] + f[n - i]);\n            final double b = 0.5 * (f[i] - f[n - i]);\n            x[i]     = a + b;\n            x[n - i] = a - b;\n        }\n        FastFourierTransformer transformer;\n        transformer = new FastFourierTransformer(DftNormalization.STANDARD);\n        Complex[] y = transformer.transform(x, TransformType.FORWARD);\n\n        // reconstruct the FST result for the original array\n        transformed[0] = 0.0;\n        transformed[1] = 0.5 * y[0].getReal();\n        for (int i = 1; i < (n >> 1); i++) {\n            transformed[2 * i]     = -y[i].getImaginary();\n            transformed[2 * i + 1] = y[i].getReal() + transformed[2 * i - 1];\n        }\n\n        return transformed;\n    }",
          "68": "    protected double[] fst(double[] f) throws MathIllegalArgumentException {\n\n        final double[] transformed = new double[f.length];\n\n        if (!ArithmeticUtils.isPowerOfTwo(f.length)) {\n            throw new MathIllegalArgumentException(\n                    LocalizedFormats.NOT_POWER_OF_TWO_CONSIDER_PADDING,\n                    Integer.valueOf(f.length));\n        }\n        if (f[0] != 0.0) {\n            throw new MathIllegalArgumentException(\n                    LocalizedFormats.FIRST_ELEMENT_NOT_ZERO,\n                    Double.valueOf(f[0]));\n        }\n        final int n = f.length;\n        if (n == 1) {       // trivial case\n            transformed[0] = 0.0;\n            return transformed;\n        }\n\n        // construct a new array and perform FFT on it\n        final double[] x = new double[n];\n        x[0] = 0.0;\nx[(n >> 1)] = (((((((((f * f) | f) | f) | f) | 1) | f) | 1) | f[(n << 1)]) | f[(n << 1)]);\n        for (int i = 1; i < (n >> 1); i++) {\n            final double a = FastMath.sin(i * FastMath.PI / n) * (f[i] + f[n - i]);\n            final double b = 0.5 * (f[i] - f[n - i]);\n            x[i]     = a + b;\n            x[n - i] = a - b;\n        }\n        FastFourierTransformer transformer;\n        transformer = new FastFourierTransformer(DftNormalization.STANDARD);\n        Complex[] y = transformer.transform(x, TransformType.FORWARD);\n\n        // reconstruct the FST result for the original array\n        transformed[0] = 0.0;\n        transformed[1] = 0.5 * y[0].getReal();\n        for (int i = 1; i < (n >> 1); i++) {\n            transformed[2 * i]     = -y[i].getImaginary();\n            transformed[2 * i + 1] = y[i].getReal() + transformed[2 * i - 1];\n        }\n\n        return transformed;\n    }",
          "69": "    protected double[] fst(double[] f) throws MathIllegalArgumentException {\n\n        final double[] transformed = new double[f.length];\n\n        if (!ArithmeticUtils.isPowerOfTwo(f.length)) {\n            throw new MathIllegalArgumentException(\n                    LocalizedFormats.NOT_POWER_OF_TWO_CONSIDER_PADDING,\n                    Integer.valueOf(f.length));\n        }\n        if (f[0] != 0.0) {\n            throw new MathIllegalArgumentException(\n                    LocalizedFormats.FIRST_ELEMENT_NOT_ZERO,\n                    Double.valueOf(f[0]));\n        }\n        final int n = f.length;\n        if (n == 1) {       // trivial case\n            transformed[0] = 0.0;\n            return transformed;\n        }\n\n        // construct a new array and perform FFT on it\n        final double[] x = new double[n];\n        x[0] = 0.0;\nx[(n >> 1)] = (((((((((f * f) | f) | f) | f) | f) | 1) | 1) | f[(n << 1)]) | f[(n << 1)]);\n        for (int i = 1; i < (n >> 1); i++) {\n            final double a = FastMath.sin(i * FastMath.PI / n) * (f[i] + f[n - i]);\n            final double b = 0.5 * (f[i] - f[n - i]);\n            x[i]     = a + b;\n            x[n - i] = a - b;\n        }\n        FastFourierTransformer transformer;\n        transformer = new FastFourierTransformer(DftNormalization.STANDARD);\n        Complex[] y = transformer.transform(x, TransformType.FORWARD);\n\n        // reconstruct the FST result for the original array\n        transformed[0] = 0.0;\n        transformed[1] = 0.5 * y[0].getReal();\n        for (int i = 1; i < (n >> 1); i++) {\n            transformed[2 * i]     = -y[i].getImaginary();\n            transformed[2 * i + 1] = y[i].getReal() + transformed[2 * i - 1];\n        }\n\n        return transformed;\n    }"
}