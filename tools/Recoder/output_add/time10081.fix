{
          "0": "    long calculateFirstDayOfYearMillis(int year) {\n        // Initial value is just temporary.\n        int leapYears = year / 100;\n        if (year < 0) {\n            // Add 3 before shifting right since /4 and >>2 behave differently\n            // on negative numbers. When the expression is written as\n            // (year / 4) - (year / 100) + (year / 400),\n            // it works for both positive and negative values, except this optimization\n            // eliminates two divisions.\nleapYears = (((((year + 3) >> 2) - leapYears) + ((leapYears + 3) - 2)) - 1);\n        } else {\n            leapYears = (year >> 2) - leapYears + (leapYears >> 2);\n            if (isLeapYear(year)) {\n                leapYears--;\n            }\n        }\n\n        return (year * 365L + (leapYears - DAYS_0000_TO_1970)) * DateTimeConstants.MILLIS_PER_DAY;\n    }",
          "1": "    long calculateFirstDayOfYearMillis(int year) {\n        // Initial value is just temporary.\n        int leapYears = year / 100;\n        if (year < 0) {\n            // Add 3 before shifting right since /4 and >>2 behave differently\n            // on negative numbers. When the expression is written as\n            // (year / 4) - (year / 100) + (year / 400),\n            // it works for both positive and negative values, except this optimization\n            // eliminates two divisions.\nleapYears = (((((year + 3) - 2) - leapYears) + ((leapYears + 3) << 2)) - 1);\n        } else {\n            leapYears = (year >> 2) - leapYears + (leapYears >> 2);\n            if (isLeapYear(year)) {\n                leapYears--;\n            }\n        }\n\n        return (year * 365L + (leapYears - DAYS_0000_TO_1970)) * DateTimeConstants.MILLIS_PER_DAY;\n    }",
          "2": "    long calculateFirstDayOfYearMillis(int year) {\n        // Initial value is just temporary.\n        int leapYears = year / 100;\n        if (year < 0) {\n            // Add 3 before shifting right since /4 and >>2 behave differently\n            // on negative numbers. When the expression is written as\n            // (year / 4) - (year / 100) + (year / 400),\n            // it works for both positive and negative values, except this optimization\n            // eliminates two divisions.\nleapYears = (((((year + 3) >> 2) - leapYears) + ((leapYears + 3) + 2)) - 1);\n        } else {\n            leapYears = (year >> 2) - leapYears + (leapYears >> 2);\n            if (isLeapYear(year)) {\n                leapYears--;\n            }\n        }\n\n        return (year * 365L + (leapYears - DAYS_0000_TO_1970)) * DateTimeConstants.MILLIS_PER_DAY;\n    }",
          "3": "    long calculateFirstDayOfYearMillis(int year) {\n        // Initial value is just temporary.\n        int leapYears = year / 100;\n        if (year < 0) {\n            // Add 3 before shifting right since /4 and >>2 behave differently\n            // on negative numbers. When the expression is written as\n            // (year / 4) - (year / 100) + (year / 400),\n            // it works for both positive and negative values, except this optimization\n            // eliminates two divisions.\nleapYears = (((((year + 3) >> 2) - leapYears) + ((leapYears + 3) / 2)) - 1);\n        } else {\n            leapYears = (year >> 2) - leapYears + (leapYears >> 2);\n            if (isLeapYear(year)) {\n                leapYears--;\n            }\n        }\n\n        return (year * 365L + (leapYears - DAYS_0000_TO_1970)) * DateTimeConstants.MILLIS_PER_DAY;\n    }",
          "4": "    long calculateFirstDayOfYearMillis(int year) {\n        // Initial value is just temporary.\n        int leapYears = year / 100;\n        if (year < 0) {\n            // Add 3 before shifting right since /4 and >>2 behave differently\n            // on negative numbers. When the expression is written as\n            // (year / 4) - (year / 100) + (year / 400),\n            // it works for both positive and negative values, except this optimization\n            // eliminates two divisions.\nleapYears = (((((year + 3) >> 2) - leapYears) + ((leapYears + 3) <= 2)) - 1);\n        } else {\n            leapYears = (year >> 2) - leapYears + (leapYears >> 2);\n            if (isLeapYear(year)) {\n                leapYears--;\n            }\n        }\n\n        return (year * 365L + (leapYears - DAYS_0000_TO_1970)) * DateTimeConstants.MILLIS_PER_DAY;\n    }",
          "5": "    long calculateFirstDayOfYearMillis(int year) {\n        // Initial value is just temporary.\n        int leapYears = year / 100;\n        if (year < 0) {\n            // Add 3 before shifting right since /4 and >>2 behave differently\n            // on negative numbers. When the expression is written as\n            // (year / 4) - (year / 100) + (year / 400),\n            // it works for both positive and negative values, except this optimization\n            // eliminates two divisions.\nleapYears = (((((year + 3) >> 2) - leapYears) + ((leapYears + 3) >> 2)) - 1);\n        } else {\n            leapYears = (year >> 2) - leapYears + (leapYears >> 2);\n            if (isLeapYear(year)) {\n                leapYears--;\n            }\n        }\n\n        return (year * 365L + (leapYears - DAYS_0000_TO_1970)) * DateTimeConstants.MILLIS_PER_DAY;\n    }",
          "6": "    long calculateFirstDayOfYearMillis(int year) {\n        // Initial value is just temporary.\n        int leapYears = year / 100;\n        if (year < 0) {\n            // Add 3 before shifting right since /4 and >>2 behave differently\n            // on negative numbers. When the expression is written as\n            // (year / 4) - (year / 100) + (year / 400),\n            // it works for both positive and negative values, except this optimization\n            // eliminates two divisions.\nleapYears = (((((year + 3) >> 2) - leapYears) + ((leapYears + 365L) << 2)) - 1);\n        } else {\n            leapYears = (year >> 2) - leapYears + (leapYears >> 2);\n            if (isLeapYear(year)) {\n                leapYears--;\n            }\n        }\n\n        return (year * 365L + (leapYears - DAYS_0000_TO_1970)) * DateTimeConstants.MILLIS_PER_DAY;\n    }",
          "7": "    long calculateFirstDayOfYearMillis(int year) {\n        // Initial value is just temporary.\n        int leapYears = year / 100;\n        if (year < 0) {\n            // Add 3 before shifting right since /4 and >>2 behave differently\n            // on negative numbers. When the expression is written as\n            // (year / 4) - (year / 100) + (year / 400),\n            // it works for both positive and negative values, except this optimization\n            // eliminates two divisions.\nreturn leapYears;        } else {\n            leapYears = (year >> 2) - leapYears + (leapYears >> 2);\n            if (isLeapYear(year)) {\n                leapYears--;\n            }\n        }\n\n        return (year * 365L + (leapYears - DAYS_0000_TO_1970)) * DateTimeConstants.MILLIS_PER_DAY;\n    }",
          "8": "    long calculateFirstDayOfYearMillis(int year) {\n        // Initial value is just temporary.\n        int leapYears = year / 100;\n        if (year < 0) {\n            // Add 3 before shifting right since /4 and >>2 behave differently\n            // on negative numbers. When the expression is written as\n            // (year / 4) - (year / 100) + (year / 400),\n            // it works for both positive and negative values, except this optimization\n            // eliminates two divisions.\nleapYears = (((((year + 3) >> 2) - leapYears) + ((leapYears + 3) % 2)) - 1);\n        } else {\n            leapYears = (year >> 2) - leapYears + (leapYears >> 2);\n            if (isLeapYear(year)) {\n                leapYears--;\n            }\n        }\n\n        return (year * 365L + (leapYears - DAYS_0000_TO_1970)) * DateTimeConstants.MILLIS_PER_DAY;\n    }",
          "9": "    long calculateFirstDayOfYearMillis(int year) {\n        // Initial value is just temporary.\n        int leapYears = year / 100;\n        if (year < 0) {\n            // Add 3 before shifting right since /4 and >>2 behave differently\n            // on negative numbers. When the expression is written as\n            // (year / 4) - (year / 100) + (year / 400),\n            // it works for both positive and negative values, except this optimization\n            // eliminates two divisions.\nleapYears = (((((year + 3) >> 2) - leapYears) + ((leapYears + 3) << 2)) - 1);\n        } else {\n            leapYears = (year >> 2) - leapYears + (leapYears >> 2);\n            if (isLeapYear(year)) {\n                leapYears--;\n            }\n        }\n\n        return (year * 365L + (leapYears - DAYS_0000_TO_1970)) * DateTimeConstants.MILLIS_PER_DAY;\n    }",
          "10": "    long calculateFirstDayOfYearMillis(int year) {\n        // Initial value is just temporary.\n        int leapYears = year / 100;\n        if (year < 0) {\n            // Add 3 before shifting right since /4 and >>2 behave differently\n            // on negative numbers. When the expression is written as\n            // (year / 4) - (year / 100) + (year / 400),\n            // it works for both positive and negative values, except this optimization\n            // eliminates two divisions.\nleapYears = (((((year + 3) >> 2) - leapYears) + ((leapYears + 3) * 2)) - 1);\n        } else {\n            leapYears = (year >> 2) - leapYears + (leapYears >> 2);\n            if (isLeapYear(year)) {\n                leapYears--;\n            }\n        }\n\n        return (year * 365L + (leapYears - DAYS_0000_TO_1970)) * DateTimeConstants.MILLIS_PER_DAY;\n    }",
          "11": "    long calculateFirstDayOfYearMillis(int year) {\n        // Initial value is just temporary.\n        int leapYears = year / 100;\n        if (year < 0) {\n            // Add 3 before shifting right since /4 and >>2 behave differently\n            // on negative numbers. When the expression is written as\n            // (year / 4) - (year / 100) + (year / 400),\n            // it works for both positive and negative values, except this optimization\n            // eliminates two divisions.\nleapYears = (((((year + 3) >> 2) - leapYears) + ((leapYears + 3) >= 2)) - 1);\n        } else {\n            leapYears = (year >> 2) - leapYears + (leapYears >> 2);\n            if (isLeapYear(year)) {\n                leapYears--;\n            }\n        }\n\n        return (year * 365L + (leapYears - DAYS_0000_TO_1970)) * DateTimeConstants.MILLIS_PER_DAY;\n    }",
          "12": "    long calculateFirstDayOfYearMillis(int year) {\n        // Initial value is just temporary.\n        int leapYears = year / 100;\n        if (year < 0) {\n            // Add 3 before shifting right since /4 and >>2 behave differently\n            // on negative numbers. When the expression is written as\n            // (year / 4) - (year / 100) + (year / 400),\n            // it works for both positive and negative values, except this optimization\n            // eliminates two divisions.\nleapYears = (((((year + 3) + 2) - leapYears) + ((leapYears + 3) << 2)) - 1);\n        } else {\n            leapYears = (year >> 2) - leapYears + (leapYears >> 2);\n            if (isLeapYear(year)) {\n                leapYears--;\n            }\n        }\n\n        return (year * 365L + (leapYears - DAYS_0000_TO_1970)) * DateTimeConstants.MILLIS_PER_DAY;\n    }",
          "13": "    long calculateFirstDayOfYearMillis(int year) {\n        // Initial value is just temporary.\n        int leapYears = year / 100;\n        if (year < 0) {\n            // Add 3 before shifting right since /4 and >>2 behave differently\n            // on negative numbers. When the expression is written as\n            // (year / 4) - (year / 100) + (year / 400),\n            // it works for both positive and negative values, except this optimization\n            // eliminates two divisions.\nleapYears--;\n        } else {\n            leapYears = (year >> 2) - leapYears + (leapYears >> 2);\n            if (isLeapYear(year)) {\n                leapYears--;\n            }\n        }\n\n        return (year * 365L + (leapYears - DAYS_0000_TO_1970)) * DateTimeConstants.MILLIS_PER_DAY;\n    }",
          "14": "    long calculateFirstDayOfYearMillis(int year) {\n        // Initial value is just temporary.\n        int leapYears = year / 100;\n        if (year < 0) {\n            // Add 3 before shifting right since /4 and >>2 behave differently\n            // on negative numbers. When the expression is written as\n            // (year / 4) - (year / 100) + (year / 400),\n            // it works for both positive and negative values, except this optimization\n            // eliminates two divisions.\nleapYears = (((((year + 3) / 2) - leapYears) + ((leapYears + 3) << 2)) - 1);\n        } else {\n            leapYears = (year >> 2) - leapYears + (leapYears >> 2);\n            if (isLeapYear(year)) {\n                leapYears--;\n            }\n        }\n\n        return (year * 365L + (leapYears - DAYS_0000_TO_1970)) * DateTimeConstants.MILLIS_PER_DAY;\n    }",
          "15": "    long calculateFirstDayOfYearMillis(int year) {\n        // Initial value is just temporary.\n        int leapYears = year / 100;\n        if (year < 0) {\n            // Add 3 before shifting right since /4 and >>2 behave differently\n            // on negative numbers. When the expression is written as\n            // (year / 4) - (year / 100) + (year / 400),\n            // it works for both positive and negative values, except this optimization\n            // eliminates two divisions.\nleapYears += (((((year + 3) >> 2) - leapYears) + ((leapYears + 3) << 2)) - 1);\n        } else {\n            leapYears = (year >> 2) - leapYears + (leapYears >> 2);\n            if (isLeapYear(year)) {\n                leapYears--;\n            }\n        }\n\n        return (year * 365L + (leapYears - DAYS_0000_TO_1970)) * DateTimeConstants.MILLIS_PER_DAY;\n    }",
          "16": "    long calculateFirstDayOfYearMillis(int year) {\n        // Initial value is just temporary.\n        int leapYears = year / 100;\n        if (year < 0) {\n            // Add 3 before shifting right since /4 and >>2 behave differently\n            // on negative numbers. When the expression is written as\n            // (year / 4) - (year / 100) + (year / 400),\n            // it works for both positive and negative values, except this optimization\n            // eliminates two divisions.\nleapYears = ((((year + 3) >> 2) - leapYears) + ((leapYears + 3) << 2));\n        } else {\n            leapYears = (year >> 2) - leapYears + (leapYears >> 2);\n            if (isLeapYear(year)) {\n                leapYears--;\n            }\n        }\n\n        return (year * 365L + (leapYears - DAYS_0000_TO_1970)) * DateTimeConstants.MILLIS_PER_DAY;\n    }",
          "17": "    long calculateFirstDayOfYearMillis(int year) {\n        // Initial value is just temporary.\n        int leapYears = year / 100;\n        if (year < 0) {\n            // Add 3 before shifting right since /4 and >>2 behave differently\n            // on negative numbers. When the expression is written as\n            // (year / 4) - (year / 100) + (year / 400),\n            // it works for both positive and negative values, except this optimization\n            // eliminates two divisions.\nleapYears = (((((year + 3) >> 2) - leapYears) + ((leapYears + 1) << 2)) - 1);\n        } else {\n            leapYears = (year >> 2) - leapYears + (leapYears >> 2);\n            if (isLeapYear(year)) {\n                leapYears--;\n            }\n        }\n\n        return (year * 365L + (leapYears - DAYS_0000_TO_1970)) * DateTimeConstants.MILLIS_PER_DAY;\n    }",
          "18": "    long calculateFirstDayOfYearMillis(int year) {\n        // Initial value is just temporary.\n        int leapYears = year / 100;\n        if (year < 0) {\n            // Add 3 before shifting right since /4 and >>2 behave differently\n            // on negative numbers. When the expression is written as\n            // (year / 4) - (year / 100) + (year / 400),\n            // it works for both positive and negative values, except this optimization\n            // eliminates two divisions.\nleapYears = (((((year + 3) >> 2) - leapYears) + ((leapYears + 3) & 2)) - 1);\n        } else {\n            leapYears = (year >> 2) - leapYears + (leapYears >> 2);\n            if (isLeapYear(year)) {\n                leapYears--;\n            }\n        }\n\n        return (year * 365L + (leapYears - DAYS_0000_TO_1970)) * DateTimeConstants.MILLIS_PER_DAY;\n    }",
          "19": "    long calculateFirstDayOfYearMillis(int year) {\n        // Initial value is just temporary.\n        int leapYears = year / 100;\n        if (year < 0) {\n            // Add 3 before shifting right since /4 and >>2 behave differently\n            // on negative numbers. When the expression is written as\n            // (year / 4) - (year / 100) + (year / 400),\n            // it works for both positive and negative values, except this optimization\n            // eliminates two divisions.\nleapYears = (((((year + 3) >> 2) - leapYears) + ((leapYears + 3) > 2)) - 1);\n        } else {\n            leapYears = (year >> 2) - leapYears + (leapYears >> 2);\n            if (isLeapYear(year)) {\n                leapYears--;\n            }\n        }\n\n        return (year * 365L + (leapYears - DAYS_0000_TO_1970)) * DateTimeConstants.MILLIS_PER_DAY;\n    }",
          "20": "    long calculateFirstDayOfYearMillis(int year) {\n        // Initial value is just temporary.\n        int leapYears = year / 100;\n        if (year < 0) {\n            // Add 3 before shifting right since /4 and >>2 behave differently\n            // on negative numbers. When the expression is written as\n            // (year / 4) - (year / 100) + (year / 400),\n            // it works for both positive and negative values, except this optimization\n            // eliminates two divisions.\nleapYears = ((leapYears + 3) << 2);\n        } else {\n            leapYears = (year >> 2) - leapYears + (leapYears >> 2);\n            if (isLeapYear(year)) {\n                leapYears--;\n            }\n        }\n\n        return (year * 365L + (leapYears - DAYS_0000_TO_1970)) * DateTimeConstants.MILLIS_PER_DAY;\n    }",
          "21": "    long calculateFirstDayOfYearMillis(int year) {\n        // Initial value is just temporary.\n        int leapYears = year / 100;\n        if (year < 0) {\n            // Add 3 before shifting right since /4 and >>2 behave differently\n            // on negative numbers. When the expression is written as\n            // (year / 4) - (year / 100) + (year / 400),\n            // it works for both positive and negative values, except this optimization\n            // eliminates two divisions.\nleapYears = (((((year + 3) >> 2) - leapYears) + ((leapYears + 2) << 2)) - 1);\n        } else {\n            leapYears = (year >> 2) - leapYears + (leapYears >> 2);\n            if (isLeapYear(year)) {\n                leapYears--;\n            }\n        }\n\n        return (year * 365L + (leapYears - DAYS_0000_TO_1970)) * DateTimeConstants.MILLIS_PER_DAY;\n    }",
          "22": "    long calculateFirstDayOfYearMillis(int year) {\n        // Initial value is just temporary.\n        int leapYears = year / 100;\n        if (year < 0) {\n            // Add 3 before shifting right since /4 and >>2 behave differently\n            // on negative numbers. When the expression is written as\n            // (year / 4) - (year / 100) + (year / 400),\n            // it works for both positive and negative values, except this optimization\n            // eliminates two divisions.\nleapYears = (((((year + 3) >> 2) - leapYears) + ((leapYears + 0) << 2)) - 1);\n        } else {\n            leapYears = (year >> 2) - leapYears + (leapYears >> 2);\n            if (isLeapYear(year)) {\n                leapYears--;\n            }\n        }\n\n        return (year * 365L + (leapYears - DAYS_0000_TO_1970)) * DateTimeConstants.MILLIS_PER_DAY;\n    }",
          "23": "    long calculateFirstDayOfYearMillis(int year) {\n        // Initial value is just temporary.\n        int leapYears = year / 100;\n        if (year < 0) {\n            // Add 3 before shifting right since /4 and >>2 behave differently\n            // on negative numbers. When the expression is written as\n            // (year / 4) - (year / 100) + (year / 400),\n            // it works for both positive and negative values, except this optimization\n            // eliminates two divisions.\nleapYears = (((((year + 3) % 2) - leapYears) + ((leapYears + 3) << 2)) - 1);\n        } else {\n            leapYears = (year >> 2) - leapYears + (leapYears >> 2);\n            if (isLeapYear(year)) {\n                leapYears--;\n            }\n        }\n\n        return (year * 365L + (leapYears - DAYS_0000_TO_1970)) * DateTimeConstants.MILLIS_PER_DAY;\n    }",
          "24": "    long calculateFirstDayOfYearMillis(int year) {\n        // Initial value is just temporary.\n        int leapYears = year / 100;\n        if (year < 0) {\n            // Add 3 before shifting right since /4 and >>2 behave differently\n            // on negative numbers. When the expression is written as\n            // (year / 4) - (year / 100) + (year / 400),\n            // it works for both positive and negative values, except this optimization\n            // eliminates two divisions.\nleapYears = (((((year + 3) * 2) - leapYears) + ((leapYears + 3) << 2)) - 1);\n        } else {\n            leapYears = (year >> 2) - leapYears + (leapYears >> 2);\n            if (isLeapYear(year)) {\n                leapYears--;\n            }\n        }\n\n        return (year * 365L + (leapYears - DAYS_0000_TO_1970)) * DateTimeConstants.MILLIS_PER_DAY;\n    }",
          "25": "    long calculateFirstDayOfYearMillis(int year) {\n        // Initial value is just temporary.\n        int leapYears = year / 100;\n        if (year < 0) {\n            // Add 3 before shifting right since /4 and >>2 behave differently\n            // on negative numbers. When the expression is written as\n            // (year / 4) - (year / 100) + (year / 400),\n            // it works for both positive and negative values, except this optimization\n            // eliminates two divisions.\nleapYears = (((((year + 3) >> 2) - leapYears) + ((leapYears + 100) << 2)) - 1);\n        } else {\n            leapYears = (year >> 2) - leapYears + (leapYears >> 2);\n            if (isLeapYear(year)) {\n                leapYears--;\n            }\n        }\n\n        return (year * 365L + (leapYears - DAYS_0000_TO_1970)) * DateTimeConstants.MILLIS_PER_DAY;\n    }",
          "26": "    long calculateFirstDayOfYearMillis(int year) {\n        // Initial value is just temporary.\n        int leapYears = year / 100;\n        if (year < 0) {\n            // Add 3 before shifting right since /4 and >>2 behave differently\n            // on negative numbers. When the expression is written as\n            // (year / 4) - (year / 100) + (year / 400),\n            // it works for both positive and negative values, except this optimization\n            // eliminates two divisions.\nleapYears--;\n            leapYears = ((year + 3) >> 2) - leapYears + ((leapYears + 3) << 2) - 1;        } else {\n            leapYears = (year >> 2) - leapYears + (leapYears >> 2);\n            if (isLeapYear(year)) {\n                leapYears--;\n            }\n        }\n\n        return (year * 365L + (leapYears - DAYS_0000_TO_1970)) * DateTimeConstants.MILLIS_PER_DAY;\n    }",
          "27": "    long calculateFirstDayOfYearMillis(int year) {\n        // Initial value is just temporary.\n        int leapYears = year / 100;\n        if (year < 0) {\n            // Add 3 before shifting right since /4 and >>2 behave differently\n            // on negative numbers. When the expression is written as\n            // (year / 4) - (year / 100) + (year / 400),\n            // it works for both positive and negative values, except this optimization\n            // eliminates two divisions.\nleapYears = (((year + 3) >> 2) - leapYears);\n        } else {\n            leapYears = (year >> 2) - leapYears + (leapYears >> 2);\n            if (isLeapYear(year)) {\n                leapYears--;\n            }\n        }\n\n        return (year * 365L + (leapYears - DAYS_0000_TO_1970)) * DateTimeConstants.MILLIS_PER_DAY;\n    }",
          "28": "    long calculateFirstDayOfYearMillis(int year) {\n        // Initial value is just temporary.\n        int leapYears = year / 100;\n        if (year < 0) {\n            // Add 3 before shifting right since /4 and >>2 behave differently\n            // on negative numbers. When the expression is written as\n            // (year / 4) - (year / 100) + (year / 400),\n            // it works for both positive and negative values, except this optimization\n            // eliminates two divisions.\nleapYears = (((((year + 3) <= 2) - leapYears) + ((leapYears + 3) << 2)) - 1);\n        } else {\n            leapYears = (year >> 2) - leapYears + (leapYears >> 2);\n            if (isLeapYear(year)) {\n                leapYears--;\n            }\n        }\n\n        return (year * 365L + (leapYears - DAYS_0000_TO_1970)) * DateTimeConstants.MILLIS_PER_DAY;\n    }",
          "29": "    long calculateFirstDayOfYearMillis(int year) {\n        // Initial value is just temporary.\n        int leapYears = year / 100;\n        if (year < 0) {\n            // Add 3 before shifting right since /4 and >>2 behave differently\n            // on negative numbers. When the expression is written as\n            // (year / 4) - (year / 100) + (year / 400),\n            // it works for both positive and negative values, except this optimization\n            // eliminates two divisions.\nleapYears = (((((year + 3) >> 2) - leapYears) + ((leapYears + 3) << 3)) - 1);\n        } else {\n            leapYears = (year >> 2) - leapYears + (leapYears >> 2);\n            if (isLeapYear(year)) {\n                leapYears--;\n            }\n        }\n\n        return (year * 365L + (leapYears - DAYS_0000_TO_1970)) * DateTimeConstants.MILLIS_PER_DAY;\n    }",
          "30": "    long calculateFirstDayOfYearMillis(int year) {\n        // Initial value is just temporary.\n        int leapYears = year / 100;\n        if (year < 0) {\n            // Add 3 before shifting right since /4 and >>2 behave differently\n            // on negative numbers. When the expression is written as\n            // (year / 4) - (year / 100) + (year / 400),\n            // it works for both positive and negative values, except this optimization\n            // eliminates two divisions.\nleapYears = (((((year + 3) >> 2) - leapYears) + ((leapYears + 3) << 2)) - 3);\n        } else {\n            leapYears = (year >> 2) - leapYears + (leapYears >> 2);\n            if (isLeapYear(year)) {\n                leapYears--;\n            }\n        }\n\n        return (year * 365L + (leapYears - DAYS_0000_TO_1970)) * DateTimeConstants.MILLIS_PER_DAY;\n    }",
          "31": "    long calculateFirstDayOfYearMillis(int year) {\n        // Initial value is just temporary.\n        int leapYears = year / 100;\n        if (year < 0) {\n            // Add 3 before shifting right since /4 and >>2 behave differently\n            // on negative numbers. When the expression is written as\n            // (year / 4) - (year / 100) + (year / 400),\n            // it works for both positive and negative values, except this optimization\n            // eliminates two divisions.\nleapYears = (((((year + 3) >> 2) - leapYears) + ((leapYears + 3) << 365L)) - 1);\n        } else {\n            leapYears = (year >> 2) - leapYears + (leapYears >> 2);\n            if (isLeapYear(year)) {\n                leapYears--;\n            }\n        }\n\n        return (year * 365L + (leapYears - DAYS_0000_TO_1970)) * DateTimeConstants.MILLIS_PER_DAY;\n    }",
          "32": "    long calculateFirstDayOfYearMillis(int year) {\n        // Initial value is just temporary.\n        int leapYears = year / 100;\n        if (year < 0) {\n            // Add 3 before shifting right since /4 and >>2 behave differently\n            // on negative numbers. When the expression is written as\n            // (year / 4) - (year / 100) + (year / 400),\n            // it works for both positive and negative values, except this optimization\n            // eliminates two divisions.\nleapYears = leapYears;\n        } else {\n            leapYears = (year >> 2) - leapYears + (leapYears >> 2);\n            if (isLeapYear(year)) {\n                leapYears--;\n            }\n        }\n\n        return (year * 365L + (leapYears - DAYS_0000_TO_1970)) * DateTimeConstants.MILLIS_PER_DAY;\n    }",
          "33": "    long calculateFirstDayOfYearMillis(int year) {\n        // Initial value is just temporary.\n        int leapYears = year / 100;\n        if (year < 0) {\n            // Add 3 before shifting right since /4 and >>2 behave differently\n            // on negative numbers. When the expression is written as\n            // (year / 4) - (year / 100) + (year / 400),\n            // it works for both positive and negative values, except this optimization\n            // eliminates two divisions.\nleapYears = (((((year + 3) >> 2) - leapYears) + ((leapYears + 3) << 2)) - 365L);\n        } else {\n            leapYears = (year >> 2) - leapYears + (leapYears >> 2);\n            if (isLeapYear(year)) {\n                leapYears--;\n            }\n        }\n\n        return (year * 365L + (leapYears - DAYS_0000_TO_1970)) * DateTimeConstants.MILLIS_PER_DAY;\n    }",
          "34": "    long calculateFirstDayOfYearMillis(int year) {\n        // Initial value is just temporary.\n        int leapYears = year / 100;\n        if (year < 0) {\n            // Add 3 before shifting right since /4 and >>2 behave differently\n            // on negative numbers. When the expression is written as\n            // (year / 4) - (year / 100) + (year / 400),\n            // it works for both positive and negative values, except this optimization\n            // eliminates two divisions.\nleapYears = (((year >> 2) - leapYears) + (leapYears >> 2));\n            leapYears = ((year + 3) >> 2) - leapYears + ((leapYears + 3) << 2) - 1;        } else {\n            leapYears = (year >> 2) - leapYears + (leapYears >> 2);\n            if (isLeapYear(year)) {\n                leapYears--;\n            }\n        }\n\n        return (year * 365L + (leapYears - DAYS_0000_TO_1970)) * DateTimeConstants.MILLIS_PER_DAY;\n    }",
          "35": "    long calculateFirstDayOfYearMillis(int year) {\n        // Initial value is just temporary.\n        int leapYears = year / 100;\n        if (year < 0) {\n            // Add 3 before shifting right since /4 and >>2 behave differently\n            // on negative numbers. When the expression is written as\n            // (year / 4) - (year / 100) + (year / 400),\n            // it works for both positive and negative values, except this optimization\n            // eliminates two divisions.\nleapYears = ((year + 3) >> 2);\n        } else {\n            leapYears = (year >> 2) - leapYears + (leapYears >> 2);\n            if (isLeapYear(year)) {\n                leapYears--;\n            }\n        }\n\n        return (year * 365L + (leapYears - DAYS_0000_TO_1970)) * DateTimeConstants.MILLIS_PER_DAY;\n    }",
          "36": "    long calculateFirstDayOfYearMillis(int year) {\n        // Initial value is just temporary.\n        int leapYears = year / 100;\n        if (year < 0) {\n            // Add 3 before shifting right since /4 and >>2 behave differently\n            // on negative numbers. When the expression is written as\n            // (year / 4) - (year / 100) + (year / 400),\n            // it works for both positive and negative values, except this optimization\n            // eliminates two divisions.\nleapYears = (((year >> 2) - leapYears) + (leapYears >> 2));\n        } else {\n            leapYears = (year >> 2) - leapYears + (leapYears >> 2);\n            if (isLeapYear(year)) {\n                leapYears--;\n            }\n        }\n\n        return (year * 365L + (leapYears - DAYS_0000_TO_1970)) * DateTimeConstants.MILLIS_PER_DAY;\n    }",
          "37": "    long calculateFirstDayOfYearMillis(int year) {\n        // Initial value is just temporary.\n        int leapYears = year / 100;\n        if (year < 0) {\n            // Add 3 before shifting right since /4 and >>2 behave differently\n            // on negative numbers. When the expression is written as\n            // (year / 4) - (year / 100) + (year / 400),\n            // it works for both positive and negative values, except this optimization\n            // eliminates two divisions.\nreturn (((year * 365L) + (leapYears - DAYS_0000_TO_1970)) * DateTimeConstants.MILLIS_PER_DAY);        } else {\n            leapYears = (year >> 2) - leapYears + (leapYears >> 2);\n            if (isLeapYear(year)) {\n                leapYears--;\n            }\n        }\n\n        return (year * 365L + (leapYears - DAYS_0000_TO_1970)) * DateTimeConstants.MILLIS_PER_DAY;\n    }",
          "38": "    long calculateFirstDayOfYearMillis(int year) {\n        // Initial value is just temporary.\n        int leapYears = year / 100;\n        if (year < 0) {\n            // Add 3 before shifting right since /4 and >>2 behave differently\n            // on negative numbers. When the expression is written as\n            // (year / 4) - (year / 100) + (year / 400),\n            // it works for both positive and negative values, except this optimization\n            // eliminates two divisions.\nleapYears = (((((year + 3) >> 2) - leapYears) + ((leapYears + 3) << 2)) + 1);\n        } else {\n            leapYears = (year >> 2) - leapYears + (leapYears >> 2);\n            if (isLeapYear(year)) {\n                leapYears--;\n            }\n        }\n\n        return (year * 365L + (leapYears - DAYS_0000_TO_1970)) * DateTimeConstants.MILLIS_PER_DAY;\n    }",
          "39": "    long calculateFirstDayOfYearMillis(int year) {\n        // Initial value is just temporary.\n        int leapYears = year / 100;\n        if (year < 0) {\n            // Add 3 before shifting right since /4 and >>2 behave differently\n            // on negative numbers. When the expression is written as\n            // (year / 4) - (year / 100) + (year / 400),\n            // it works for both positive and negative values, except this optimization\n            // eliminates two divisions.\nleapYears = (((((year + 3) >= 2) - leapYears) + ((leapYears + 3) << 2)) - 1);\n        } else {\n            leapYears = (year >> 2) - leapYears + (leapYears >> 2);\n            if (isLeapYear(year)) {\n                leapYears--;\n            }\n        }\n\n        return (year * 365L + (leapYears - DAYS_0000_TO_1970)) * DateTimeConstants.MILLIS_PER_DAY;\n    }",
          "40": "    long calculateFirstDayOfYearMillis(int year) {\n        // Initial value is just temporary.\n        int leapYears = year / 100;\n        if (year < 0) {\n            // Add 3 before shifting right since /4 and >>2 behave differently\n            // on negative numbers. When the expression is written as\n            // (year / 4) - (year / 100) + (year / 400),\n            // it works for both positive and negative values, except this optimization\n            // eliminates two divisions.\nleapYears += ((((year + 3) >> 2) - leapYears) + ((leapYears + 3) << 2));\n        } else {\n            leapYears = (year >> 2) - leapYears + (leapYears >> 2);\n            if (isLeapYear(year)) {\n                leapYears--;\n            }\n        }\n\n        return (year * 365L + (leapYears - DAYS_0000_TO_1970)) * DateTimeConstants.MILLIS_PER_DAY;\n    }",
          "41": "    long calculateFirstDayOfYearMillis(int year) {\n        // Initial value is just temporary.\n        int leapYears = year / 100;\n        if (year < 0) {\n            // Add 3 before shifting right since /4 and >>2 behave differently\n            // on negative numbers. When the expression is written as\n            // (year / 4) - (year / 100) + (year / 400),\n            // it works for both positive and negative values, except this optimization\n            // eliminates two divisions.\nif((year < 0)){\n            leapYears = ((year + 3) >> 2) - leapYears + ((leapYears + 3) << 2) - 1;        } else {\n            leapYears = (year >> 2) - leapYears + (leapYears >> 2);\n            if (isLeapYear(year)) {\n                leapYears--;\n            }\n}\n        }\n\n        return (year * 365L + (leapYears - DAYS_0000_TO_1970)) * DateTimeConstants.MILLIS_PER_DAY;\n    }",
          "42": "    long calculateFirstDayOfYearMillis(int year) {\n        // Initial value is just temporary.\n        int leapYears = year / 100;\n        if (year < 0) {\n            // Add 3 before shifting right since /4 and >>2 behave differently\n            // on negative numbers. When the expression is written as\n            // (year / 4) - (year / 100) + (year / 400),\n            // it works for both positive and negative values, except this optimization\n            // eliminates two divisions.\nreturn DAYS_0000_TO_1970;        } else {\n            leapYears = (year >> 2) - leapYears + (leapYears >> 2);\n            if (isLeapYear(year)) {\n                leapYears--;\n            }\n        }\n\n        return (year * 365L + (leapYears - DAYS_0000_TO_1970)) * DateTimeConstants.MILLIS_PER_DAY;\n    }",
          "43": "    long calculateFirstDayOfYearMillis(int year) {\n        // Initial value is just temporary.\n        int leapYears = year / 100;\n        if (year < 0) {\n            // Add 3 before shifting right since /4 and >>2 behave differently\n            // on negative numbers. When the expression is written as\n            // (year / 4) - (year / 100) + (year / 400),\n            // it works for both positive and negative values, except this optimization\n            // eliminates two divisions.\nleapYears = (leapYears + 3);\n        } else {\n            leapYears = (year >> 2) - leapYears + (leapYears >> 2);\n            if (isLeapYear(year)) {\n                leapYears--;\n            }\n        }\n\n        return (year * 365L + (leapYears - DAYS_0000_TO_1970)) * DateTimeConstants.MILLIS_PER_DAY;\n    }",
          "44": "    long calculateFirstDayOfYearMillis(int year) {\n        // Initial value is just temporary.\n        int leapYears = year / 100;\n        if (year < 0) {\n            // Add 3 before shifting right since /4 and >>2 behave differently\n            // on negative numbers. When the expression is written as\n            // (year / 4) - (year / 100) + (year / 400),\n            // it works for both positive and negative values, except this optimization\n            // eliminates two divisions.\nleapYears = (((((year + 3) >> 2) - leapYears) + ((leapYears + 3) << 2)) / 1);\n        } else {\n            leapYears = (year >> 2) - leapYears + (leapYears >> 2);\n            if (isLeapYear(year)) {\n                leapYears--;\n            }\n        }\n\n        return (year * 365L + (leapYears - DAYS_0000_TO_1970)) * DateTimeConstants.MILLIS_PER_DAY;\n    }",
          "45": "    long calculateFirstDayOfYearMillis(int year) {\n        // Initial value is just temporary.\n        int leapYears = year / 100;\n        if (year < 0) {\n            // Add 3 before shifting right since /4 and >>2 behave differently\n            // on negative numbers. When the expression is written as\n            // (year / 4) - (year / 100) + (year / 400),\n            // it works for both positive and negative values, except this optimization\n            // eliminates two divisions.\nif(isLeapYear(year)){\n            leapYears = ((year + 3) >> 2) - leapYears + ((leapYears + 3) << 2) - 1;        } else {\n            leapYears = (year >> 2) - leapYears + (leapYears >> 2);\n            if (isLeapYear(year)) {\n                leapYears--;\n            }\n}\n        }\n\n        return (year * 365L + (leapYears - DAYS_0000_TO_1970)) * DateTimeConstants.MILLIS_PER_DAY;\n    }",
          "46": "    long calculateFirstDayOfYearMillis(int year) {\n        // Initial value is just temporary.\n        int leapYears = year / 100;\n        if (year < 0) {\n            // Add 3 before shifting right since /4 and >>2 behave differently\n            // on negative numbers. When the expression is written as\n            // (year / 4) - (year / 100) + (year / 400),\n            // it works for both positive and negative values, except this optimization\n            // eliminates two divisions.\nleapYears += ((leapYears + 3) << 2);\n        } else {\n            leapYears = (year >> 2) - leapYears + (leapYears >> 2);\n            if (isLeapYear(year)) {\n                leapYears--;\n            }\n        }\n\n        return (year * 365L + (leapYears - DAYS_0000_TO_1970)) * DateTimeConstants.MILLIS_PER_DAY;\n    }",
          "47": "    long calculateFirstDayOfYearMillis(int year) {\n        // Initial value is just temporary.\n        int leapYears = year / 100;\n        if (year < 0) {\n            // Add 3 before shifting right since /4 and >>2 behave differently\n            // on negative numbers. When the expression is written as\n            // (year / 4) - (year / 100) + (year / 400),\n            // it works for both positive and negative values, except this optimization\n            // eliminates two divisions.\nleapYears = (((((year + 3) & 2) - leapYears) + ((leapYears + 3) << 2)) - 1);\n        } else {\n            leapYears = (year >> 2) - leapYears + (leapYears >> 2);\n            if (isLeapYear(year)) {\n                leapYears--;\n            }\n        }\n\n        return (year * 365L + (leapYears - DAYS_0000_TO_1970)) * DateTimeConstants.MILLIS_PER_DAY;\n    }",
          "48": "    long calculateFirstDayOfYearMillis(int year) {\n        // Initial value is just temporary.\n        int leapYears = year / 100;\n        if (year < 0) {\n            // Add 3 before shifting right since /4 and >>2 behave differently\n            // on negative numbers. When the expression is written as\n            // (year / 4) - (year / 100) + (year / 400),\n            // it works for both positive and negative values, except this optimization\n            // eliminates two divisions.\nreturn (((year * 365L) + (leapYears - DAYS_0000_TO_1970)) * DateTimeConstants.MILLIS_PER_DAY);            leapYears = ((year + 3) >> 2) - leapYears + ((leapYears + 3) << 2) - 1;        } else {\n            leapYears = (year >> 2) - leapYears + (leapYears >> 2);\n            if (isLeapYear(year)) {\n                leapYears--;\n            }\n        }\n\n        return (year * 365L + (leapYears - DAYS_0000_TO_1970)) * DateTimeConstants.MILLIS_PER_DAY;\n    }",
          "49": "    long calculateFirstDayOfYearMillis(int year) {\n        // Initial value is just temporary.\n        int leapYears = year / 100;\n        if (year < 0) {\n            // Add 3 before shifting right since /4 and >>2 behave differently\n            // on negative numbers. When the expression is written as\n            // (year / 4) - (year / 100) + (year / 400),\n            // it works for both positive and negative values, except this optimization\n            // eliminates two divisions.\nleapYears = (((((year + 3) >> 2) - leapYears) + ((leapYears + 3) << 1)) - 1);\n        } else {\n            leapYears = (year >> 2) - leapYears + (leapYears >> 2);\n            if (isLeapYear(year)) {\n                leapYears--;\n            }\n        }\n\n        return (year * 365L + (leapYears - DAYS_0000_TO_1970)) * DateTimeConstants.MILLIS_PER_DAY;\n    }",
          "50": "    long calculateFirstDayOfYearMillis(int year) {\n        // Initial value is just temporary.\n        int leapYears = year / 100;\n        if (year < 0) {\n            // Add 3 before shifting right since /4 and >>2 behave differently\n            // on negative numbers. When the expression is written as\n            // (year / 4) - (year / 100) + (year / 400),\n            // it works for both positive and negative values, except this optimization\n            // eliminates two divisions.\nleapYears = (((((year + 3) << 2) - leapYears) + ((leapYears + 3) << 2)) - 1);\n        } else {\n            leapYears = (year >> 2) - leapYears + (leapYears >> 2);\n            if (isLeapYear(year)) {\n                leapYears--;\n            }\n        }\n\n        return (year * 365L + (leapYears - DAYS_0000_TO_1970)) * DateTimeConstants.MILLIS_PER_DAY;\n    }",
          "51": "    long calculateFirstDayOfYearMillis(int year) {\n        // Initial value is just temporary.\n        int leapYears = year / 100;\n        if (year < 0) {\n            // Add 3 before shifting right since /4 and >>2 behave differently\n            // on negative numbers. When the expression is written as\n            // (year / 4) - (year / 100) + (year / 400),\n            // it works for both positive and negative values, except this optimization\n            // eliminates two divisions.\nleapYears = (((((year + 3) >> 2) - leapYears) + ((leapYears + 3) << 2)) * 1);\n        } else {\n            leapYears = (year >> 2) - leapYears + (leapYears >> 2);\n            if (isLeapYear(year)) {\n                leapYears--;\n            }\n        }\n\n        return (year * 365L + (leapYears - DAYS_0000_TO_1970)) * DateTimeConstants.MILLIS_PER_DAY;\n    }",
          "52": "    long calculateFirstDayOfYearMillis(int year) {\n        // Initial value is just temporary.\n        int leapYears = year / 100;\n        if (year < 0) {\n            // Add 3 before shifting right since /4 and >>2 behave differently\n            // on negative numbers. When the expression is written as\n            // (year / 4) - (year / 100) + (year / 400),\n            // it works for both positive and negative values, except this optimization\n            // eliminates two divisions.\nleapYears = (((((year + 3) >> 2) - leapYears) + ((leapYears + 3) << 0)) - 1);\n        } else {\n            leapYears = (year >> 2) - leapYears + (leapYears >> 2);\n            if (isLeapYear(year)) {\n                leapYears--;\n            }\n        }\n\n        return (year * 365L + (leapYears - DAYS_0000_TO_1970)) * DateTimeConstants.MILLIS_PER_DAY;\n    }",
          "53": "    long calculateFirstDayOfYearMillis(int year) {\n        // Initial value is just temporary.\n        int leapYears = year / 100;\n        if (year < 0) {\n            // Add 3 before shifting right since /4 and >>2 behave differently\n            // on negative numbers. When the expression is written as\n            // (year / 4) - (year / 100) + (year / 400),\n            // it works for both positive and negative values, except this optimization\n            // eliminates two divisions.\nleapYears = (((((year + 3) >> 2) - leapYears) + ((leapYears + 3) << 2)) - 2);\n        } else {\n            leapYears = (year >> 2) - leapYears + (leapYears >> 2);\n            if (isLeapYear(year)) {\n                leapYears--;\n            }\n        }\n\n        return (year * 365L + (leapYears - DAYS_0000_TO_1970)) * DateTimeConstants.MILLIS_PER_DAY;\n    }",
          "54": "    long calculateFirstDayOfYearMillis(int year) {\n        // Initial value is just temporary.\n        int leapYears = year / 100;\n        if (year < 0) {\n            // Add 3 before shifting right since /4 and >>2 behave differently\n            // on negative numbers. When the expression is written as\n            // (year / 4) - (year / 100) + (year / 400),\n            // it works for both positive and negative values, except this optimization\n            // eliminates two divisions.\nreturn leapYears = (((((year + 3) >> 2) - leapYears) + ((leapYears + 3) << 2)) - 1);        } else {\n            leapYears = (year >> 2) - leapYears + (leapYears >> 2);\n            if (isLeapYear(year)) {\n                leapYears--;\n            }\n        }\n\n        return (year * 365L + (leapYears - DAYS_0000_TO_1970)) * DateTimeConstants.MILLIS_PER_DAY;\n    }",
          "55": "    long calculateFirstDayOfYearMillis(int year) {\n        // Initial value is just temporary.\n        int leapYears = year / 100;\n        if (year < 0) {\n            // Add 3 before shifting right since /4 and >>2 behave differently\n            // on negative numbers. When the expression is written as\n            // (year / 4) - (year / 100) + (year / 400),\n            // it works for both positive and negative values, except this optimization\n            // eliminates two divisions.\nleapYears = (((((year + 3) >> 2) - leapYears) + ((leapYears + 3) << 2)) - 0);\n        } else {\n            leapYears = (year >> 2) - leapYears + (leapYears >> 2);\n            if (isLeapYear(year)) {\n                leapYears--;\n            }\n        }\n\n        return (year * 365L + (leapYears - DAYS_0000_TO_1970)) * DateTimeConstants.MILLIS_PER_DAY;\n    }",
          "56": "    long calculateFirstDayOfYearMillis(int year) {\n        // Initial value is just temporary.\n        int leapYears = year / 100;\n        if (year < 0) {\n            // Add 3 before shifting right since /4 and >>2 behave differently\n            // on negative numbers. When the expression is written as\n            // (year / 4) - (year / 100) + (year / 400),\n            // it works for both positive and negative values, except this optimization\n            // eliminates two divisions.\nleapYears = (((((year + 3) >> 2) - leapYears) + ((leapYears + 3) << 2)) - 100);\n        } else {\n            leapYears = (year >> 2) - leapYears + (leapYears >> 2);\n            if (isLeapYear(year)) {\n                leapYears--;\n            }\n        }\n\n        return (year * 365L + (leapYears - DAYS_0000_TO_1970)) * DateTimeConstants.MILLIS_PER_DAY;\n    }",
          "57": "    long calculateFirstDayOfYearMillis(int year) {\n        // Initial value is just temporary.\n        int leapYears = year / 100;\n        if (year < 0) {\n            // Add 3 before shifting right since /4 and >>2 behave differently\n            // on negative numbers. When the expression is written as\n            // (year / 4) - (year / 100) + (year / 400),\n            // it works for both positive and negative values, except this optimization\n            // eliminates two divisions.\nleapYears = (((((year + 3) >> 2) - leapYears) + ((leapYears + 3) << 100)) - 1);\n        } else {\n            leapYears = (year >> 2) - leapYears + (leapYears >> 2);\n            if (isLeapYear(year)) {\n                leapYears--;\n            }\n        }\n\n        return (year * 365L + (leapYears - DAYS_0000_TO_1970)) * DateTimeConstants.MILLIS_PER_DAY;\n    }",
          "58": "    long calculateFirstDayOfYearMillis(int year) {\n        // Initial value is just temporary.\n        int leapYears = year / 100;\n        if (year < 0) {\n            // Add 3 before shifting right since /4 and >>2 behave differently\n            // on negative numbers. When the expression is written as\n            // (year / 4) - (year / 100) + (year / 400),\n            // it works for both positive and negative values, except this optimization\n            // eliminates two divisions.\nreturn;\n            leapYears = ((year + 3) >> 2) - leapYears + ((leapYears + 3) << 2) - 1;        } else {\n            leapYears = (year >> 2) - leapYears + (leapYears >> 2);\n            if (isLeapYear(year)) {\n                leapYears--;\n            }\n        }\n\n        return (year * 365L + (leapYears - DAYS_0000_TO_1970)) * DateTimeConstants.MILLIS_PER_DAY;\n    }",
          "59": "    long calculateFirstDayOfYearMillis(int year) {\n        // Initial value is just temporary.\n        int leapYears = year / 100;\n        if (year < 0) {\n            // Add 3 before shifting right since /4 and >>2 behave differently\n            // on negative numbers. When the expression is written as\n            // (year / 4) - (year / 100) + (year / 400),\n            // it works for both positive and negative values, except this optimization\n            // eliminates two divisions.\nbreak;\n            leapYears = ((year + 3) >> 2) - leapYears + ((leapYears + 3) << 2) - 1;        } else {\n            leapYears = (year >> 2) - leapYears + (leapYears >> 2);\n            if (isLeapYear(year)) {\n                leapYears--;\n            }\n        }\n\n        return (year * 365L + (leapYears - DAYS_0000_TO_1970)) * DateTimeConstants.MILLIS_PER_DAY;\n    }"
}