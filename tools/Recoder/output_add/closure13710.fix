{
          "0": "    private static long hash64(\n        byte[] value, int offset, int length, long seed) {\n      long a = CONSTANT64;\n      long b = a;\n      long c = seed;\n      int keylen;\n\n      for (keylen = length; keylen >= 24; keylen -= 24, offset += 24) {\n        a += word64At(value, offset);\n        b += word64At(value, offset + 8);\n        c += word64At(value, offset + 16);\n\n        // Mix\n        a -= b; a -= c; a ^= c >>> 43;\n        b -= c; b -= a; b ^= a << 9;\n        c -= a; c -= b; c ^= b >>> 8;\n        a -= b; a -= c; a ^= c >>> 38;\n        b -= c; b -= a; b ^= a << 23;\n        c -= a; c -= b; c ^= b >>> 5;\n        a -= b; a -= c; a ^= c >>> 35;\n        b -= c; b -= a; b ^= a << 49;\n        c -= a; c -= b; c ^= b >>> 11;\n        a -= b; a -= c; a ^= c >>> 12;\n        b -= c; b -= a; b ^= a << 18;\n        c -= a; c -= b; c ^= b >>> 22;\n      }\n\n      c += length;\n      switch (keylen) { // deal with rest. Cases fall through\n        case 23:\n          c += ((long) value[offset + 22]) << 56;\n        case 22:\n          c += (value[offset + 21] & 0xffL) << 48;\n        case 21:\n          c += (value[offset + 20] & 0xffL) << 40;\n        case 20:\n          c += (value[offset + 19] & 0xffL) << 32;\n        case 19:\n          c += (value[offset + 18] & 0xffL) << 24;\n        case 18:\n          c += (value[offset + 17] & 0xffL) << 16;\n        case 17:\n          c += (value[offset + 16] & 0xffL) << 8;\n          // the first byte of c is reserved for the length\n        case 16:\n          b += word64At(value, offset + 8);\n          a += word64At(value, offset);\n          break;\n        case 15:\n          b += (value[offset + 14] & 0xffL) << 48;\n        case 14:\n          b += (value[offset + 13] & 0xffL) << 40;\n        case 13:\n          b += (value[offset + 12] & 0xffL) << 32;\n        case 12:\n          b += (value[offset + 11] & 0xffL) << 24;\n        case 11:\n          b += (value[offset + 10] & 0xffL) << 16;\n        case 10:\n          b += (value[offset + 9] & 0xffL) << 8;\n        case 9:\n          b += (value[offset + 8] & 0xffL);\n        case 8:\n          a += word64At(value, offset);\n          break;\n        case 7:\n          a += (value[offset + 6] & 0xffL) << 48;\n        case 6:\n          a += (value[offset + 5] & 0xffL) << 40;\n        case 5:\n          a += (value[offset + 4] & 0xffL) << 32;\n        case 4:\na += ((value[(offset + 3)] & 255L) >>> 0);\n        case 3:\n          a += (value[offset + 2] & 0xffL) << 16;\n        case 2:\n          a += (value[offset + 1] & 0xffL) << 8;\n        case 1:\n          a += (value[offset + 0] & 0xffL);\n          // case 0: nothing left to add\n      }\n      return mix64(a, b, c);\n    }",
          "1": "    private static long hash64(\n        byte[] value, int offset, int length, long seed) {\n      long a = CONSTANT64;\n      long b = a;\n      long c = seed;\n      int keylen;\n\n      for (keylen = length; keylen >= 24; keylen -= 24, offset += 24) {\n        a += word64At(value, offset);\n        b += word64At(value, offset + 8);\n        c += word64At(value, offset + 16);\n\n        // Mix\n        a -= b; a -= c; a ^= c >>> 43;\n        b -= c; b -= a; b ^= a << 9;\n        c -= a; c -= b; c ^= b >>> 8;\n        a -= b; a -= c; a ^= c >>> 38;\n        b -= c; b -= a; b ^= a << 23;\n        c -= a; c -= b; c ^= b >>> 5;\n        a -= b; a -= c; a ^= c >>> 35;\n        b -= c; b -= a; b ^= a << 49;\n        c -= a; c -= b; c ^= b >>> 11;\n        a -= b; a -= c; a ^= c >>> 12;\n        b -= c; b -= a; b ^= a << 18;\n        c -= a; c -= b; c ^= b >>> 22;\n      }\n\n      c += length;\n      switch (keylen) { // deal with rest. Cases fall through\n        case 23:\n          c += ((long) value[offset + 22]) << 56;\n        case 22:\n          c += (value[offset + 21] & 0xffL) << 48;\n        case 21:\n          c += (value[offset + 20] & 0xffL) << 40;\n        case 20:\n          c += (value[offset + 19] & 0xffL) << 32;\n        case 19:\n          c += (value[offset + 18] & 0xffL) << 24;\n        case 18:\n          c += (value[offset + 17] & 0xffL) << 16;\n        case 17:\n          c += (value[offset + 16] & 0xffL) << 8;\n          // the first byte of c is reserved for the length\n        case 16:\n          b += word64At(value, offset + 8);\n          a += word64At(value, offset);\n          break;\n        case 15:\n          b += (value[offset + 14] & 0xffL) << 48;\n        case 14:\n          b += (value[offset + 13] & 0xffL) << 40;\n        case 13:\n          b += (value[offset + 12] & 0xffL) << 32;\n        case 12:\n          b += (value[offset + 11] & 0xffL) << 24;\n        case 11:\n          b += (value[offset + 10] & 0xffL) << 16;\n        case 10:\n          b += (value[offset + 9] & 0xffL) << 8;\n        case 9:\n          b += (value[offset + 8] & 0xffL);\n        case 8:\n          a += word64At(value, offset);\n          break;\n        case 7:\n          a += (value[offset + 6] & 0xffL) << 48;\n        case 6:\n          a += (value[offset + 5] & 0xffL) << 40;\n        case 5:\n          a += (value[offset + 4] & 0xffL) << 32;\n        case 4:\na += ((value[(offset + 3)] & 255L) >>> 1);\n        case 3:\n          a += (value[offset + 2] & 0xffL) << 16;\n        case 2:\n          a += (value[offset + 1] & 0xffL) << 8;\n        case 1:\n          a += (value[offset + 0] & 0xffL);\n          // case 0: nothing left to add\n      }\n      return mix64(a, b, c);\n    }",
          "2": "    private static long hash64(\n        byte[] value, int offset, int length, long seed) {\n      long a = CONSTANT64;\n      long b = a;\n      long c = seed;\n      int keylen;\n\n      for (keylen = length; keylen >= 24; keylen -= 24, offset += 24) {\n        a += word64At(value, offset);\n        b += word64At(value, offset + 8);\n        c += word64At(value, offset + 16);\n\n        // Mix\n        a -= b; a -= c; a ^= c >>> 43;\n        b -= c; b -= a; b ^= a << 9;\n        c -= a; c -= b; c ^= b >>> 8;\n        a -= b; a -= c; a ^= c >>> 38;\n        b -= c; b -= a; b ^= a << 23;\n        c -= a; c -= b; c ^= b >>> 5;\n        a -= b; a -= c; a ^= c >>> 35;\n        b -= c; b -= a; b ^= a << 49;\n        c -= a; c -= b; c ^= b >>> 11;\n        a -= b; a -= c; a ^= c >>> 12;\n        b -= c; b -= a; b ^= a << 18;\n        c -= a; c -= b; c ^= b >>> 22;\n      }\n\n      c += length;\n      switch (keylen) { // deal with rest. Cases fall through\n        case 23:\n          c += ((long) value[offset + 22]) << 56;\n        case 22:\n          c += (value[offset + 21] & 0xffL) << 48;\n        case 21:\n          c += (value[offset + 20] & 0xffL) << 40;\n        case 20:\n          c += (value[offset + 19] & 0xffL) << 32;\n        case 19:\n          c += (value[offset + 18] & 0xffL) << 24;\n        case 18:\n          c += (value[offset + 17] & 0xffL) << 16;\n        case 17:\n          c += (value[offset + 16] & 0xffL) << 8;\n          // the first byte of c is reserved for the length\n        case 16:\n          b += word64At(value, offset + 8);\n          a += word64At(value, offset);\n          break;\n        case 15:\n          b += (value[offset + 14] & 0xffL) << 48;\n        case 14:\n          b += (value[offset + 13] & 0xffL) << 40;\n        case 13:\n          b += (value[offset + 12] & 0xffL) << 32;\n        case 12:\n          b += (value[offset + 11] & 0xffL) << 24;\n        case 11:\n          b += (value[offset + 10] & 0xffL) << 16;\n        case 10:\n          b += (value[offset + 9] & 0xffL) << 8;\n        case 9:\n          b += (value[offset + 8] & 0xffL);\n        case 8:\n          a += word64At(value, offset);\n          break;\n        case 7:\n          a += (value[offset + 6] & 0xffL) << 48;\n        case 6:\n          a += (value[offset + 5] & 0xffL) << 40;\n        case 5:\n          a += (value[offset + 4] & 0xffL) << 32;\n        case 4:\na += ((value[(offset + 3)] & 255L) >>> 32);\n        case 3:\n          a += (value[offset + 2] & 0xffL) << 16;\n        case 2:\n          a += (value[offset + 1] & 0xffL) << 8;\n        case 1:\n          a += (value[offset + 0] & 0xffL);\n          // case 0: nothing left to add\n      }\n      return mix64(a, b, c);\n    }",
          "3": "    private static long hash64(\n        byte[] value, int offset, int length, long seed) {\n      long a = CONSTANT64;\n      long b = a;\n      long c = seed;\n      int keylen;\n\n      for (keylen = length; keylen >= 24; keylen -= 24, offset += 24) {\n        a += word64At(value, offset);\n        b += word64At(value, offset + 8);\n        c += word64At(value, offset + 16);\n\n        // Mix\n        a -= b; a -= c; a ^= c >>> 43;\n        b -= c; b -= a; b ^= a << 9;\n        c -= a; c -= b; c ^= b >>> 8;\n        a -= b; a -= c; a ^= c >>> 38;\n        b -= c; b -= a; b ^= a << 23;\n        c -= a; c -= b; c ^= b >>> 5;\n        a -= b; a -= c; a ^= c >>> 35;\n        b -= c; b -= a; b ^= a << 49;\n        c -= a; c -= b; c ^= b >>> 11;\n        a -= b; a -= c; a ^= c >>> 12;\n        b -= c; b -= a; b ^= a << 18;\n        c -= a; c -= b; c ^= b >>> 22;\n      }\n\n      c += length;\n      switch (keylen) { // deal with rest. Cases fall through\n        case 23:\n          c += ((long) value[offset + 22]) << 56;\n        case 22:\n          c += (value[offset + 21] & 0xffL) << 48;\n        case 21:\n          c += (value[offset + 20] & 0xffL) << 40;\n        case 20:\n          c += (value[offset + 19] & 0xffL) << 32;\n        case 19:\n          c += (value[offset + 18] & 0xffL) << 24;\n        case 18:\n          c += (value[offset + 17] & 0xffL) << 16;\n        case 17:\n          c += (value[offset + 16] & 0xffL) << 8;\n          // the first byte of c is reserved for the length\n        case 16:\n          b += word64At(value, offset + 8);\n          a += word64At(value, offset);\n          break;\n        case 15:\n          b += (value[offset + 14] & 0xffL) << 48;\n        case 14:\n          b += (value[offset + 13] & 0xffL) << 40;\n        case 13:\n          b += (value[offset + 12] & 0xffL) << 32;\n        case 12:\n          b += (value[offset + 11] & 0xffL) << 24;\n        case 11:\n          b += (value[offset + 10] & 0xffL) << 16;\n        case 10:\n          b += (value[offset + 9] & 0xffL) << 8;\n        case 9:\n          b += (value[offset + 8] & 0xffL);\n        case 8:\n          a += word64At(value, offset);\n          break;\n        case 7:\n          a += (value[offset + 6] & 0xffL) << 48;\n        case 6:\n          a += (value[offset + 5] & 0xffL) << 40;\n        case 5:\n          a += (value[offset + 4] & 0xffL) << 32;\n        case 4:\na += ((value[(offset + 3)] & 255L) >>> 4);\n        case 3:\n          a += (value[offset + 2] & 0xffL) << 16;\n        case 2:\n          a += (value[offset + 1] & 0xffL) << 8;\n        case 1:\n          a += (value[offset + 0] & 0xffL);\n          // case 0: nothing left to add\n      }\n      return mix64(a, b, c);\n    }",
          "4": "    private static long hash64(\n        byte[] value, int offset, int length, long seed) {\n      long a = CONSTANT64;\n      long b = a;\n      long c = seed;\n      int keylen;\n\n      for (keylen = length; keylen >= 24; keylen -= 24, offset += 24) {\n        a += word64At(value, offset);\n        b += word64At(value, offset + 8);\n        c += word64At(value, offset + 16);\n\n        // Mix\n        a -= b; a -= c; a ^= c >>> 43;\n        b -= c; b -= a; b ^= a << 9;\n        c -= a; c -= b; c ^= b >>> 8;\n        a -= b; a -= c; a ^= c >>> 38;\n        b -= c; b -= a; b ^= a << 23;\n        c -= a; c -= b; c ^= b >>> 5;\n        a -= b; a -= c; a ^= c >>> 35;\n        b -= c; b -= a; b ^= a << 49;\n        c -= a; c -= b; c ^= b >>> 11;\n        a -= b; a -= c; a ^= c >>> 12;\n        b -= c; b -= a; b ^= a << 18;\n        c -= a; c -= b; c ^= b >>> 22;\n      }\n\n      c += length;\n      switch (keylen) { // deal with rest. Cases fall through\n        case 23:\n          c += ((long) value[offset + 22]) << 56;\n        case 22:\n          c += (value[offset + 21] & 0xffL) << 48;\n        case 21:\n          c += (value[offset + 20] & 0xffL) << 40;\n        case 20:\n          c += (value[offset + 19] & 0xffL) << 32;\n        case 19:\n          c += (value[offset + 18] & 0xffL) << 24;\n        case 18:\n          c += (value[offset + 17] & 0xffL) << 16;\n        case 17:\n          c += (value[offset + 16] & 0xffL) << 8;\n          // the first byte of c is reserved for the length\n        case 16:\n          b += word64At(value, offset + 8);\n          a += word64At(value, offset);\n          break;\n        case 15:\n          b += (value[offset + 14] & 0xffL) << 48;\n        case 14:\n          b += (value[offset + 13] & 0xffL) << 40;\n        case 13:\n          b += (value[offset + 12] & 0xffL) << 32;\n        case 12:\n          b += (value[offset + 11] & 0xffL) << 24;\n        case 11:\n          b += (value[offset + 10] & 0xffL) << 16;\n        case 10:\n          b += (value[offset + 9] & 0xffL) << 8;\n        case 9:\n          b += (value[offset + 8] & 0xffL);\n        case 8:\n          a += word64At(value, offset);\n          break;\n        case 7:\n          a += (value[offset + 6] & 0xffL) << 48;\n        case 6:\n          a += (value[offset + 5] & 0xffL) << 40;\n        case 5:\n          a += (value[offset + 4] & 0xffL) << 32;\n        case 4:\na += ((value[(offset + 3)] & 0) >>> 24);\n        case 3:\n          a += (value[offset + 2] & 0xffL) << 16;\n        case 2:\n          a += (value[offset + 1] & 0xffL) << 8;\n        case 1:\n          a += (value[offset + 0] & 0xffL);\n          // case 0: nothing left to add\n      }\n      return mix64(a, b, c);\n    }",
          "5": "    private static long hash64(\n        byte[] value, int offset, int length, long seed) {\n      long a = CONSTANT64;\n      long b = a;\n      long c = seed;\n      int keylen;\n\n      for (keylen = length; keylen >= 24; keylen -= 24, offset += 24) {\n        a += word64At(value, offset);\n        b += word64At(value, offset + 8);\n        c += word64At(value, offset + 16);\n\n        // Mix\n        a -= b; a -= c; a ^= c >>> 43;\n        b -= c; b -= a; b ^= a << 9;\n        c -= a; c -= b; c ^= b >>> 8;\n        a -= b; a -= c; a ^= c >>> 38;\n        b -= c; b -= a; b ^= a << 23;\n        c -= a; c -= b; c ^= b >>> 5;\n        a -= b; a -= c; a ^= c >>> 35;\n        b -= c; b -= a; b ^= a << 49;\n        c -= a; c -= b; c ^= b >>> 11;\n        a -= b; a -= c; a ^= c >>> 12;\n        b -= c; b -= a; b ^= a << 18;\n        c -= a; c -= b; c ^= b >>> 22;\n      }\n\n      c += length;\n      switch (keylen) { // deal with rest. Cases fall through\n        case 23:\n          c += ((long) value[offset + 22]) << 56;\n        case 22:\n          c += (value[offset + 21] & 0xffL) << 48;\n        case 21:\n          c += (value[offset + 20] & 0xffL) << 40;\n        case 20:\n          c += (value[offset + 19] & 0xffL) << 32;\n        case 19:\n          c += (value[offset + 18] & 0xffL) << 24;\n        case 18:\n          c += (value[offset + 17] & 0xffL) << 16;\n        case 17:\n          c += (value[offset + 16] & 0xffL) << 8;\n          // the first byte of c is reserved for the length\n        case 16:\n          b += word64At(value, offset + 8);\n          a += word64At(value, offset);\n          break;\n        case 15:\n          b += (value[offset + 14] & 0xffL) << 48;\n        case 14:\n          b += (value[offset + 13] & 0xffL) << 40;\n        case 13:\n          b += (value[offset + 12] & 0xffL) << 32;\n        case 12:\n          b += (value[offset + 11] & 0xffL) << 24;\n        case 11:\n          b += (value[offset + 10] & 0xffL) << 16;\n        case 10:\n          b += (value[offset + 9] & 0xffL) << 8;\n        case 9:\n          b += (value[offset + 8] & 0xffL);\n        case 8:\n          a += word64At(value, offset);\n          break;\n        case 7:\n          a += (value[offset + 6] & 0xffL) << 48;\n        case 6:\n          a += (value[offset + 5] & 0xffL) << 40;\n        case 5:\n          a += (value[offset + 4] & 0xffL) << 32;\n        case 4:\na += ((value[(offset + 3)] & 255L) >>> 2);\n        case 3:\n          a += (value[offset + 2] & 0xffL) << 16;\n        case 2:\n          a += (value[offset + 1] & 0xffL) << 8;\n        case 1:\n          a += (value[offset + 0] & 0xffL);\n          // case 0: nothing left to add\n      }\n      return mix64(a, b, c);\n    }",
          "6": "    private static long hash64(\n        byte[] value, int offset, int length, long seed) {\n      long a = CONSTANT64;\n      long b = a;\n      long c = seed;\n      int keylen;\n\n      for (keylen = length; keylen >= 24; keylen -= 24, offset += 24) {\n        a += word64At(value, offset);\n        b += word64At(value, offset + 8);\n        c += word64At(value, offset + 16);\n\n        // Mix\n        a -= b; a -= c; a ^= c >>> 43;\n        b -= c; b -= a; b ^= a << 9;\n        c -= a; c -= b; c ^= b >>> 8;\n        a -= b; a -= c; a ^= c >>> 38;\n        b -= c; b -= a; b ^= a << 23;\n        c -= a; c -= b; c ^= b >>> 5;\n        a -= b; a -= c; a ^= c >>> 35;\n        b -= c; b -= a; b ^= a << 49;\n        c -= a; c -= b; c ^= b >>> 11;\n        a -= b; a -= c; a ^= c >>> 12;\n        b -= c; b -= a; b ^= a << 18;\n        c -= a; c -= b; c ^= b >>> 22;\n      }\n\n      c += length;\n      switch (keylen) { // deal with rest. Cases fall through\n        case 23:\n          c += ((long) value[offset + 22]) << 56;\n        case 22:\n          c += (value[offset + 21] & 0xffL) << 48;\n        case 21:\n          c += (value[offset + 20] & 0xffL) << 40;\n        case 20:\n          c += (value[offset + 19] & 0xffL) << 32;\n        case 19:\n          c += (value[offset + 18] & 0xffL) << 24;\n        case 18:\n          c += (value[offset + 17] & 0xffL) << 16;\n        case 17:\n          c += (value[offset + 16] & 0xffL) << 8;\n          // the first byte of c is reserved for the length\n        case 16:\n          b += word64At(value, offset + 8);\n          a += word64At(value, offset);\n          break;\n        case 15:\n          b += (value[offset + 14] & 0xffL) << 48;\n        case 14:\n          b += (value[offset + 13] & 0xffL) << 40;\n        case 13:\n          b += (value[offset + 12] & 0xffL) << 32;\n        case 12:\n          b += (value[offset + 11] & 0xffL) << 24;\n        case 11:\n          b += (value[offset + 10] & 0xffL) << 16;\n        case 10:\n          b += (value[offset + 9] & 0xffL) << 8;\n        case 9:\n          b += (value[offset + 8] & 0xffL);\n        case 8:\n          a += word64At(value, offset);\n          break;\n        case 7:\n          a += (value[offset + 6] & 0xffL) << 48;\n        case 6:\n          a += (value[offset + 5] & 0xffL) << 40;\n        case 5:\n          a += (value[offset + 4] & 0xffL) << 32;\n        case 4:\na += ((value[(offset + 3)] & 255L) >>> true);\n        case 3:\n          a += (value[offset + 2] & 0xffL) << 16;\n        case 2:\n          a += (value[offset + 1] & 0xffL) << 8;\n        case 1:\n          a += (value[offset + 0] & 0xffL);\n          // case 0: nothing left to add\n      }\n      return mix64(a, b, c);\n    }",
          "7": "    private static long hash64(\n        byte[] value, int offset, int length, long seed) {\n      long a = CONSTANT64;\n      long b = a;\n      long c = seed;\n      int keylen;\n\n      for (keylen = length; keylen >= 24; keylen -= 24, offset += 24) {\n        a += word64At(value, offset);\n        b += word64At(value, offset + 8);\n        c += word64At(value, offset + 16);\n\n        // Mix\n        a -= b; a -= c; a ^= c >>> 43;\n        b -= c; b -= a; b ^= a << 9;\n        c -= a; c -= b; c ^= b >>> 8;\n        a -= b; a -= c; a ^= c >>> 38;\n        b -= c; b -= a; b ^= a << 23;\n        c -= a; c -= b; c ^= b >>> 5;\n        a -= b; a -= c; a ^= c >>> 35;\n        b -= c; b -= a; b ^= a << 49;\n        c -= a; c -= b; c ^= b >>> 11;\n        a -= b; a -= c; a ^= c >>> 12;\n        b -= c; b -= a; b ^= a << 18;\n        c -= a; c -= b; c ^= b >>> 22;\n      }\n\n      c += length;\n      switch (keylen) { // deal with rest. Cases fall through\n        case 23:\n          c += ((long) value[offset + 22]) << 56;\n        case 22:\n          c += (value[offset + 21] & 0xffL) << 48;\n        case 21:\n          c += (value[offset + 20] & 0xffL) << 40;\n        case 20:\n          c += (value[offset + 19] & 0xffL) << 32;\n        case 19:\n          c += (value[offset + 18] & 0xffL) << 24;\n        case 18:\n          c += (value[offset + 17] & 0xffL) << 16;\n        case 17:\n          c += (value[offset + 16] & 0xffL) << 8;\n          // the first byte of c is reserved for the length\n        case 16:\n          b += word64At(value, offset + 8);\n          a += word64At(value, offset);\n          break;\n        case 15:\n          b += (value[offset + 14] & 0xffL) << 48;\n        case 14:\n          b += (value[offset + 13] & 0xffL) << 40;\n        case 13:\n          b += (value[offset + 12] & 0xffL) << 32;\n        case 12:\n          b += (value[offset + 11] & 0xffL) << 24;\n        case 11:\n          b += (value[offset + 10] & 0xffL) << 16;\n        case 10:\n          b += (value[offset + 9] & 0xffL) << 8;\n        case 9:\n          b += (value[offset + 8] & 0xffL);\n        case 8:\n          a += word64At(value, offset);\n          break;\n        case 7:\n          a += (value[offset + 6] & 0xffL) << 48;\n        case 6:\n          a += (value[offset + 5] & 0xffL) << 40;\n        case 5:\n          a += (value[offset + 4] & 0xffL) << 32;\n        case 4:\na += ((value[(offset + 3)] & 255L) >>> false);\n        case 3:\n          a += (value[offset + 2] & 0xffL) << 16;\n        case 2:\n          a += (value[offset + 1] & 0xffL) << 8;\n        case 1:\n          a += (value[offset + 0] & 0xffL);\n          // case 0: nothing left to add\n      }\n      return mix64(a, b, c);\n    }",
          "8": "    private static long hash64(\n        byte[] value, int offset, int length, long seed) {\n      long a = CONSTANT64;\n      long b = a;\n      long c = seed;\n      int keylen;\n\n      for (keylen = length; keylen >= 24; keylen -= 24, offset += 24) {\n        a += word64At(value, offset);\n        b += word64At(value, offset + 8);\n        c += word64At(value, offset + 16);\n\n        // Mix\n        a -= b; a -= c; a ^= c >>> 43;\n        b -= c; b -= a; b ^= a << 9;\n        c -= a; c -= b; c ^= b >>> 8;\n        a -= b; a -= c; a ^= c >>> 38;\n        b -= c; b -= a; b ^= a << 23;\n        c -= a; c -= b; c ^= b >>> 5;\n        a -= b; a -= c; a ^= c >>> 35;\n        b -= c; b -= a; b ^= a << 49;\n        c -= a; c -= b; c ^= b >>> 11;\n        a -= b; a -= c; a ^= c >>> 12;\n        b -= c; b -= a; b ^= a << 18;\n        c -= a; c -= b; c ^= b >>> 22;\n      }\n\n      c += length;\n      switch (keylen) { // deal with rest. Cases fall through\n        case 23:\n          c += ((long) value[offset + 22]) << 56;\n        case 22:\n          c += (value[offset + 21] & 0xffL) << 48;\n        case 21:\n          c += (value[offset + 20] & 0xffL) << 40;\n        case 20:\n          c += (value[offset + 19] & 0xffL) << 32;\n        case 19:\n          c += (value[offset + 18] & 0xffL) << 24;\n        case 18:\n          c += (value[offset + 17] & 0xffL) << 16;\n        case 17:\n          c += (value[offset + 16] & 0xffL) << 8;\n          // the first byte of c is reserved for the length\n        case 16:\n          b += word64At(value, offset + 8);\n          a += word64At(value, offset);\n          break;\n        case 15:\n          b += (value[offset + 14] & 0xffL) << 48;\n        case 14:\n          b += (value[offset + 13] & 0xffL) << 40;\n        case 13:\n          b += (value[offset + 12] & 0xffL) << 32;\n        case 12:\n          b += (value[offset + 11] & 0xffL) << 24;\n        case 11:\n          b += (value[offset + 10] & 0xffL) << 16;\n        case 10:\n          b += (value[offset + 9] & 0xffL) << 8;\n        case 9:\n          b += (value[offset + 8] & 0xffL);\n        case 8:\n          a += word64At(value, offset);\n          break;\n        case 7:\n          a += (value[offset + 6] & 0xffL) << 48;\n        case 6:\n          a += (value[offset + 5] & 0xffL) << 40;\n        case 5:\n          a += (value[offset + 4] & 0xffL) << 32;\n        case 4:\na += ((value[(offset + 3)] & 255L) >>> 0xffL);\n        case 3:\n          a += (value[offset + 2] & 0xffL) << 16;\n        case 2:\n          a += (value[offset + 1] & 0xffL) << 8;\n        case 1:\n          a += (value[offset + 0] & 0xffL);\n          // case 0: nothing left to add\n      }\n      return mix64(a, b, c);\n    }",
          "9": "    private static long hash64(\n        byte[] value, int offset, int length, long seed) {\n      long a = CONSTANT64;\n      long b = a;\n      long c = seed;\n      int keylen;\n\n      for (keylen = length; keylen >= 24; keylen -= 24, offset += 24) {\n        a += word64At(value, offset);\n        b += word64At(value, offset + 8);\n        c += word64At(value, offset + 16);\n\n        // Mix\n        a -= b; a -= c; a ^= c >>> 43;\n        b -= c; b -= a; b ^= a << 9;\n        c -= a; c -= b; c ^= b >>> 8;\n        a -= b; a -= c; a ^= c >>> 38;\n        b -= c; b -= a; b ^= a << 23;\n        c -= a; c -= b; c ^= b >>> 5;\n        a -= b; a -= c; a ^= c >>> 35;\n        b -= c; b -= a; b ^= a << 49;\n        c -= a; c -= b; c ^= b >>> 11;\n        a -= b; a -= c; a ^= c >>> 12;\n        b -= c; b -= a; b ^= a << 18;\n        c -= a; c -= b; c ^= b >>> 22;\n      }\n\n      c += length;\n      switch (keylen) { // deal with rest. Cases fall through\n        case 23:\n          c += ((long) value[offset + 22]) << 56;\n        case 22:\n          c += (value[offset + 21] & 0xffL) << 48;\n        case 21:\n          c += (value[offset + 20] & 0xffL) << 40;\n        case 20:\n          c += (value[offset + 19] & 0xffL) << 32;\n        case 19:\n          c += (value[offset + 18] & 0xffL) << 24;\n        case 18:\n          c += (value[offset + 17] & 0xffL) << 16;\n        case 17:\n          c += (value[offset + 16] & 0xffL) << 8;\n          // the first byte of c is reserved for the length\n        case 16:\n          b += word64At(value, offset + 8);\n          a += word64At(value, offset);\n          break;\n        case 15:\n          b += (value[offset + 14] & 0xffL) << 48;\n        case 14:\n          b += (value[offset + 13] & 0xffL) << 40;\n        case 13:\n          b += (value[offset + 12] & 0xffL) << 32;\n        case 12:\n          b += (value[offset + 11] & 0xffL) << 24;\n        case 11:\n          b += (value[offset + 10] & 0xffL) << 16;\n        case 10:\n          b += (value[offset + 9] & 0xffL) << 8;\n        case 9:\n          b += (value[offset + 8] & 0xffL);\n        case 8:\n          a += word64At(value, offset);\n          break;\n        case 7:\n          a += (value[offset + 6] & 0xffL) << 48;\n        case 6:\n          a += (value[offset + 5] & 0xffL) << 40;\n        case 5:\n          a += (value[offset + 4] & 0xffL) << 32;\n        case 4:\na += ((value[(offset + 3)] & 255L) >>> 5);\n        case 3:\n          a += (value[offset + 2] & 0xffL) << 16;\n        case 2:\n          a += (value[offset + 1] & 0xffL) << 8;\n        case 1:\n          a += (value[offset + 0] & 0xffL);\n          // case 0: nothing left to add\n      }\n      return mix64(a, b, c);\n    }",
          "10": "    private static long hash64(\n        byte[] value, int offset, int length, long seed) {\n      long a = CONSTANT64;\n      long b = a;\n      long c = seed;\n      int keylen;\n\n      for (keylen = length; keylen >= 24; keylen -= 24, offset += 24) {\n        a += word64At(value, offset);\n        b += word64At(value, offset + 8);\n        c += word64At(value, offset + 16);\n\n        // Mix\n        a -= b; a -= c; a ^= c >>> 43;\n        b -= c; b -= a; b ^= a << 9;\n        c -= a; c -= b; c ^= b >>> 8;\n        a -= b; a -= c; a ^= c >>> 38;\n        b -= c; b -= a; b ^= a << 23;\n        c -= a; c -= b; c ^= b >>> 5;\n        a -= b; a -= c; a ^= c >>> 35;\n        b -= c; b -= a; b ^= a << 49;\n        c -= a; c -= b; c ^= b >>> 11;\n        a -= b; a -= c; a ^= c >>> 12;\n        b -= c; b -= a; b ^= a << 18;\n        c -= a; c -= b; c ^= b >>> 22;\n      }\n\n      c += length;\n      switch (keylen) { // deal with rest. Cases fall through\n        case 23:\n          c += ((long) value[offset + 22]) << 56;\n        case 22:\n          c += (value[offset + 21] & 0xffL) << 48;\n        case 21:\n          c += (value[offset + 20] & 0xffL) << 40;\n        case 20:\n          c += (value[offset + 19] & 0xffL) << 32;\n        case 19:\n          c += (value[offset + 18] & 0xffL) << 24;\n        case 18:\n          c += (value[offset + 17] & 0xffL) << 16;\n        case 17:\n          c += (value[offset + 16] & 0xffL) << 8;\n          // the first byte of c is reserved for the length\n        case 16:\n          b += word64At(value, offset + 8);\n          a += word64At(value, offset);\n          break;\n        case 15:\n          b += (value[offset + 14] & 0xffL) << 48;\n        case 14:\n          b += (value[offset + 13] & 0xffL) << 40;\n        case 13:\n          b += (value[offset + 12] & 0xffL) << 32;\n        case 12:\n          b += (value[offset + 11] & 0xffL) << 24;\n        case 11:\n          b += (value[offset + 10] & 0xffL) << 16;\n        case 10:\n          b += (value[offset + 9] & 0xffL) << 8;\n        case 9:\n          b += (value[offset + 8] & 0xffL);\n        case 8:\n          a += word64At(value, offset);\n          break;\n        case 7:\n          a += (value[offset + 6] & 0xffL) << 48;\n        case 6:\n          a += (value[offset + 5] & 0xffL) << 40;\n        case 5:\n          a += (value[offset + 4] & 0xffL) << 32;\n        case 4:\na += ((value[(offset + 3)] & 1) >>> 24);\n        case 3:\n          a += (value[offset + 2] & 0xffL) << 16;\n        case 2:\n          a += (value[offset + 1] & 0xffL) << 8;\n        case 1:\n          a += (value[offset + 0] & 0xffL);\n          // case 0: nothing left to add\n      }\n      return mix64(a, b, c);\n    }",
          "11": "    private static long hash64(\n        byte[] value, int offset, int length, long seed) {\n      long a = CONSTANT64;\n      long b = a;\n      long c = seed;\n      int keylen;\n\n      for (keylen = length; keylen >= 24; keylen -= 24, offset += 24) {\n        a += word64At(value, offset);\n        b += word64At(value, offset + 8);\n        c += word64At(value, offset + 16);\n\n        // Mix\n        a -= b; a -= c; a ^= c >>> 43;\n        b -= c; b -= a; b ^= a << 9;\n        c -= a; c -= b; c ^= b >>> 8;\n        a -= b; a -= c; a ^= c >>> 38;\n        b -= c; b -= a; b ^= a << 23;\n        c -= a; c -= b; c ^= b >>> 5;\n        a -= b; a -= c; a ^= c >>> 35;\n        b -= c; b -= a; b ^= a << 49;\n        c -= a; c -= b; c ^= b >>> 11;\n        a -= b; a -= c; a ^= c >>> 12;\n        b -= c; b -= a; b ^= a << 18;\n        c -= a; c -= b; c ^= b >>> 22;\n      }\n\n      c += length;\n      switch (keylen) { // deal with rest. Cases fall through\n        case 23:\n          c += ((long) value[offset + 22]) << 56;\n        case 22:\n          c += (value[offset + 21] & 0xffL) << 48;\n        case 21:\n          c += (value[offset + 20] & 0xffL) << 40;\n        case 20:\n          c += (value[offset + 19] & 0xffL) << 32;\n        case 19:\n          c += (value[offset + 18] & 0xffL) << 24;\n        case 18:\n          c += (value[offset + 17] & 0xffL) << 16;\n        case 17:\n          c += (value[offset + 16] & 0xffL) << 8;\n          // the first byte of c is reserved for the length\n        case 16:\n          b += word64At(value, offset + 8);\n          a += word64At(value, offset);\n          break;\n        case 15:\n          b += (value[offset + 14] & 0xffL) << 48;\n        case 14:\n          b += (value[offset + 13] & 0xffL) << 40;\n        case 13:\n          b += (value[offset + 12] & 0xffL) << 32;\n        case 12:\n          b += (value[offset + 11] & 0xffL) << 24;\n        case 11:\n          b += (value[offset + 10] & 0xffL) << 16;\n        case 10:\n          b += (value[offset + 9] & 0xffL) << 8;\n        case 9:\n          b += (value[offset + 8] & 0xffL);\n        case 8:\n          a += word64At(value, offset);\n          break;\n        case 7:\n          a += (value[offset + 6] & 0xffL) << 48;\n        case 6:\n          a += (value[offset + 5] & 0xffL) << 40;\n        case 5:\n          a += (value[offset + 4] & 0xffL) << 32;\n        case 4:\na += ((value[(offset + 3)] & 32) >>> 24);\n        case 3:\n          a += (value[offset + 2] & 0xffL) << 16;\n        case 2:\n          a += (value[offset + 1] & 0xffL) << 8;\n        case 1:\n          a += (value[offset + 0] & 0xffL);\n          // case 0: nothing left to add\n      }\n      return mix64(a, b, c);\n    }",
          "12": "    private static long hash64(\n        byte[] value, int offset, int length, long seed) {\n      long a = CONSTANT64;\n      long b = a;\n      long c = seed;\n      int keylen;\n\n      for (keylen = length; keylen >= 24; keylen -= 24, offset += 24) {\n        a += word64At(value, offset);\n        b += word64At(value, offset + 8);\n        c += word64At(value, offset + 16);\n\n        // Mix\n        a -= b; a -= c; a ^= c >>> 43;\n        b -= c; b -= a; b ^= a << 9;\n        c -= a; c -= b; c ^= b >>> 8;\n        a -= b; a -= c; a ^= c >>> 38;\n        b -= c; b -= a; b ^= a << 23;\n        c -= a; c -= b; c ^= b >>> 5;\n        a -= b; a -= c; a ^= c >>> 35;\n        b -= c; b -= a; b ^= a << 49;\n        c -= a; c -= b; c ^= b >>> 11;\n        a -= b; a -= c; a ^= c >>> 12;\n        b -= c; b -= a; b ^= a << 18;\n        c -= a; c -= b; c ^= b >>> 22;\n      }\n\n      c += length;\n      switch (keylen) { // deal with rest. Cases fall through\n        case 23:\n          c += ((long) value[offset + 22]) << 56;\n        case 22:\n          c += (value[offset + 21] & 0xffL) << 48;\n        case 21:\n          c += (value[offset + 20] & 0xffL) << 40;\n        case 20:\n          c += (value[offset + 19] & 0xffL) << 32;\n        case 19:\n          c += (value[offset + 18] & 0xffL) << 24;\n        case 18:\n          c += (value[offset + 17] & 0xffL) << 16;\n        case 17:\n          c += (value[offset + 16] & 0xffL) << 8;\n          // the first byte of c is reserved for the length\n        case 16:\n          b += word64At(value, offset + 8);\n          a += word64At(value, offset);\n          break;\n        case 15:\n          b += (value[offset + 14] & 0xffL) << 48;\n        case 14:\n          b += (value[offset + 13] & 0xffL) << 40;\n        case 13:\n          b += (value[offset + 12] & 0xffL) << 32;\n        case 12:\n          b += (value[offset + 11] & 0xffL) << 24;\n        case 11:\n          b += (value[offset + 10] & 0xffL) << 16;\n        case 10:\n          b += (value[offset + 9] & 0xffL) << 8;\n        case 9:\n          b += (value[offset + 8] & 0xffL);\n        case 8:\n          a += word64At(value, offset);\n          break;\n        case 7:\n          a += (value[offset + 6] & 0xffL) << 48;\n        case 6:\n          a += (value[offset + 5] & 0xffL) << 40;\n        case 5:\n          a += (value[offset + 4] & 0xffL) << 32;\n        case 4:\na += ((value[(offset + 3)] & 255L) >>> 255L);\n        case 3:\n          a += (value[offset + 2] & 0xffL) << 16;\n        case 2:\n          a += (value[offset + 1] & 0xffL) << 8;\n        case 1:\n          a += (value[offset + 0] & 0xffL);\n          // case 0: nothing left to add\n      }\n      return mix64(a, b, c);\n    }",
          "13": "    private static long hash64(\n        byte[] value, int offset, int length, long seed) {\n      long a = CONSTANT64;\n      long b = a;\n      long c = seed;\n      int keylen;\n\n      for (keylen = length; keylen >= 24; keylen -= 24, offset += 24) {\n        a += word64At(value, offset);\n        b += word64At(value, offset + 8);\n        c += word64At(value, offset + 16);\n\n        // Mix\n        a -= b; a -= c; a ^= c >>> 43;\n        b -= c; b -= a; b ^= a << 9;\n        c -= a; c -= b; c ^= b >>> 8;\n        a -= b; a -= c; a ^= c >>> 38;\n        b -= c; b -= a; b ^= a << 23;\n        c -= a; c -= b; c ^= b >>> 5;\n        a -= b; a -= c; a ^= c >>> 35;\n        b -= c; b -= a; b ^= a << 49;\n        c -= a; c -= b; c ^= b >>> 11;\n        a -= b; a -= c; a ^= c >>> 12;\n        b -= c; b -= a; b ^= a << 18;\n        c -= a; c -= b; c ^= b >>> 22;\n      }\n\n      c += length;\n      switch (keylen) { // deal with rest. Cases fall through\n        case 23:\n          c += ((long) value[offset + 22]) << 56;\n        case 22:\n          c += (value[offset + 21] & 0xffL) << 48;\n        case 21:\n          c += (value[offset + 20] & 0xffL) << 40;\n        case 20:\n          c += (value[offset + 19] & 0xffL) << 32;\n        case 19:\n          c += (value[offset + 18] & 0xffL) << 24;\n        case 18:\n          c += (value[offset + 17] & 0xffL) << 16;\n        case 17:\n          c += (value[offset + 16] & 0xffL) << 8;\n          // the first byte of c is reserved for the length\n        case 16:\n          b += word64At(value, offset + 8);\n          a += word64At(value, offset);\n          break;\n        case 15:\n          b += (value[offset + 14] & 0xffL) << 48;\n        case 14:\n          b += (value[offset + 13] & 0xffL) << 40;\n        case 13:\n          b += (value[offset + 12] & 0xffL) << 32;\n        case 12:\n          b += (value[offset + 11] & 0xffL) << 24;\n        case 11:\n          b += (value[offset + 10] & 0xffL) << 16;\n        case 10:\n          b += (value[offset + 9] & 0xffL) << 8;\n        case 9:\n          b += (value[offset + 8] & 0xffL);\n        case 8:\n          a += word64At(value, offset);\n          break;\n        case 7:\n          a += (value[offset + 6] & 0xffL) << 48;\n        case 6:\n          a += (value[offset + 5] & 0xffL) << 40;\n        case 5:\n          a += (value[offset + 4] & 0xffL) << 32;\n        case 4:\na += ((value[(offset + 3)] & 255L) >>> 3);\n        case 3:\n          a += (value[offset + 2] & 0xffL) << 16;\n        case 2:\n          a += (value[offset + 1] & 0xffL) << 8;\n        case 1:\n          a += (value[offset + 0] & 0xffL);\n          // case 0: nothing left to add\n      }\n      return mix64(a, b, c);\n    }",
          "14": "    private static long hash64(\n        byte[] value, int offset, int length, long seed) {\n      long a = CONSTANT64;\n      long b = a;\n      long c = seed;\n      int keylen;\n\n      for (keylen = length; keylen >= 24; keylen -= 24, offset += 24) {\n        a += word64At(value, offset);\n        b += word64At(value, offset + 8);\n        c += word64At(value, offset + 16);\n\n        // Mix\n        a -= b; a -= c; a ^= c >>> 43;\n        b -= c; b -= a; b ^= a << 9;\n        c -= a; c -= b; c ^= b >>> 8;\n        a -= b; a -= c; a ^= c >>> 38;\n        b -= c; b -= a; b ^= a << 23;\n        c -= a; c -= b; c ^= b >>> 5;\n        a -= b; a -= c; a ^= c >>> 35;\n        b -= c; b -= a; b ^= a << 49;\n        c -= a; c -= b; c ^= b >>> 11;\n        a -= b; a -= c; a ^= c >>> 12;\n        b -= c; b -= a; b ^= a << 18;\n        c -= a; c -= b; c ^= b >>> 22;\nbreak;\n      }\n\n      c += length;\n      switch (keylen) { // deal with rest. Cases fall through\n        case 23:\n          c += ((long) value[offset + 22]) << 56;\n        case 22:\n          c += (value[offset + 21] & 0xffL) << 48;\n        case 21:\n          c += (value[offset + 20] & 0xffL) << 40;\n        case 20:\n          c += (value[offset + 19] & 0xffL) << 32;\n        case 19:\n          c += (value[offset + 18] & 0xffL) << 24;\n        case 18:\n          c += (value[offset + 17] & 0xffL) << 16;\n        case 17:\n          c += (value[offset + 16] & 0xffL) << 8;\n          // the first byte of c is reserved for the length\n        case 16:\n          b += word64At(value, offset + 8);\n          a += word64At(value, offset);\n          break;\n        case 15:\n          b += (value[offset + 14] & 0xffL) << 48;\n        case 14:\n          b += (value[offset + 13] & 0xffL) << 40;\n        case 13:\n          b += (value[offset + 12] & 0xffL) << 32;\n        case 12:\n          b += (value[offset + 11] & 0xffL) << 24;\n        case 11:\n          b += (value[offset + 10] & 0xffL) << 16;\n        case 10:\n          b += (value[offset + 9] & 0xffL) << 8;\n        case 9:\n          b += (value[offset + 8] & 0xffL);\n        case 8:\n          a += word64At(value, offset);\n          break;\n        case 7:\n          a += (value[offset + 6] & 0xffL) << 48;\n        case 6:\n          a += (value[offset + 5] & 0xffL) << 40;\n        case 5:\n          a += (value[offset + 4] & 0xffL) << 32;\n        case 4:\n          a += (value[offset + 3] & 255L) >>> 24;        case 3:\n          a += (value[offset + 2] & 0xffL) << 16;\n        case 2:\n          a += (value[offset + 1] & 0xffL) << 8;\n        case 1:\n          a += (value[offset + 0] & 0xffL);\n          // case 0: nothing left to add\n      }\n      return mix64(a, b, c);\n    }",
          "15": "    private static long hash64(\n        byte[] value, int offset, int length, long seed) {\n      long a = CONSTANT64;\n      long b = a;\n      long c = seed;\n      int keylen;\n\n      for (keylen = length; keylen >= 24; keylen -= 24, offset += 24) {\n        a += word64At(value, offset);\n        b += word64At(value, offset + 8);\n        c += word64At(value, offset + 16);\n\n        // Mix\n        a -= b; a -= c; a ^= c >>> 43;\n        b -= c; b -= a; b ^= a << 9;\n        c -= a; c -= b; c ^= b >>> 8;\n        a -= b; a -= c; a ^= c >>> 38;\n        b -= c; b -= a; b ^= a << 23;\n        c -= a; c -= b; c ^= b >>> 5;\n        a -= b; a -= c; a ^= c >>> 35;\n        b -= c; b -= a; b ^= a << 49;\n        c -= a; c -= b; c ^= b >>> 11;\n        a -= b; a -= c; a ^= c >>> 12;\n        b -= c; b -= a; b ^= a << 18;\n        c -= a; c -= b; c ^= b >>> 22;\n      }\n\n      c += length;\n      switch (keylen) { // deal with rest. Cases fall through\n        case 23:\n          c += ((long) value[offset + 22]) << 56;\n        case 22:\n          c += (value[offset + 21] & 0xffL) << 48;\n        case 21:\n          c += (value[offset + 20] & 0xffL) << 40;\n        case 20:\n          c += (value[offset + 19] & 0xffL) << 32;\n        case 19:\n          c += (value[offset + 18] & 0xffL) << 24;\n        case 18:\n          c += (value[offset + 17] & 0xffL) << 16;\n        case 17:\n          c += (value[offset + 16] & 0xffL) << 8;\n          // the first byte of c is reserved for the length\n        case 16:\n          b += word64At(value, offset + 8);\n          a += word64At(value, offset);\n          break;\n        case 15:\n          b += (value[offset + 14] & 0xffL) << 48;\n        case 14:\n          b += (value[offset + 13] & 0xffL) << 40;\n        case 13:\n          b += (value[offset + 12] & 0xffL) << 32;\n        case 12:\n          b += (value[offset + 11] & 0xffL) << 24;\n        case 11:\n          b += (value[offset + 10] & 0xffL) << 16;\n        case 10:\n          b += (value[offset + 9] & 0xffL) << 8;\n        case 9:\n          b += (value[offset + 8] & 0xffL);\n        case 8:\n          a += word64At(value, offset);\n          break;\n        case 7:\n          a += (value[offset + 6] & 0xffL) << 48;\n        case 6:\n          a += (value[offset + 5] & 0xffL) << 40;\n        case 5:\n          a += (value[offset + 4] & 0xffL) << 32;\n        case 4:\na += ((value[(offset + 3)] & 255L) >>> \"null\");\n        case 3:\n          a += (value[offset + 2] & 0xffL) << 16;\n        case 2:\n          a += (value[offset + 1] & 0xffL) << 8;\n        case 1:\n          a += (value[offset + 0] & 0xffL);\n          // case 0: nothing left to add\n      }\n      return mix64(a, b, c);\n    }",
          "16": "    private static long hash64(\n        byte[] value, int offset, int length, long seed) {\n      long a = CONSTANT64;\n      long b = a;\n      long c = seed;\n      int keylen;\n\n      for (keylen = length; keylen >= 24; keylen -= 24, offset += 24) {\n        a += word64At(value, offset);\n        b += word64At(value, offset + 8);\n        c += word64At(value, offset + 16);\n\n        // Mix\n        a -= b; a -= c; a ^= c >>> 43;\n        b -= c; b -= a; b ^= a << 9;\n        c -= a; c -= b; c ^= b >>> 8;\n        a -= b; a -= c; a ^= c >>> 38;\n        b -= c; b -= a; b ^= a << 23;\n        c -= a; c -= b; c ^= b >>> 5;\n        a -= b; a -= c; a ^= c >>> 35;\n        b -= c; b -= a; b ^= a << 49;\n        c -= a; c -= b; c ^= b >>> 11;\n        a -= b; a -= c; a ^= c >>> 12;\n        b -= c; b -= a; b ^= a << 18;\n        c -= a; c -= b; c ^= b >>> 22;\n      }\n\n      c += length;\n      switch (keylen) { // deal with rest. Cases fall through\n        case 23:\n          c += ((long) value[offset + 22]) << 56;\n        case 22:\n          c += (value[offset + 21] & 0xffL) << 48;\n        case 21:\n          c += (value[offset + 20] & 0xffL) << 40;\n        case 20:\n          c += (value[offset + 19] & 0xffL) << 32;\n        case 19:\n          c += (value[offset + 18] & 0xffL) << 24;\n        case 18:\n          c += (value[offset + 17] & 0xffL) << 16;\n        case 17:\n          c += (value[offset + 16] & 0xffL) << 8;\n          // the first byte of c is reserved for the length\n        case 16:\n          b += word64At(value, offset + 8);\n          a += word64At(value, offset);\n          break;\n        case 15:\n          b += (value[offset + 14] & 0xffL) << 48;\n        case 14:\n          b += (value[offset + 13] & 0xffL) << 40;\n        case 13:\n          b += (value[offset + 12] & 0xffL) << 32;\n        case 12:\n          b += (value[offset + 11] & 0xffL) << 24;\n        case 11:\n          b += (value[offset + 10] & 0xffL) << 16;\n        case 10:\n          b += (value[offset + 9] & 0xffL) << 8;\n        case 9:\n          b += (value[offset + 8] & 0xffL);\n        case 8:\n          a += word64At(value, offset);\n          break;\n        case 7:\n          a += (value[offset + 6] & 0xffL) << 48;\n        case 6:\n          a += (value[offset + 5] & 0xffL) << 40;\n        case 5:\n          a += (value[offset + 4] & 0xffL) << 32;\n        case 4:\na += ((value[(offset + 3)] & 4) >>> 24);\n        case 3:\n          a += (value[offset + 2] & 0xffL) << 16;\n        case 2:\n          a += (value[offset + 1] & 0xffL) << 8;\n        case 1:\n          a += (value[offset + 0] & 0xffL);\n          // case 0: nothing left to add\n      }\n      return mix64(a, b, c);\n    }",
          "17": "    private static long hash64(\n        byte[] value, int offset, int length, long seed) {\n      long a = CONSTANT64;\n      long b = a;\n      long c = seed;\n      int keylen;\n\n      for (keylen = length; keylen >= 24; keylen -= 24, offset += 24) {\n        a += word64At(value, offset);\n        b += word64At(value, offset + 8);\n        c += word64At(value, offset + 16);\n\n        // Mix\n        a -= b; a -= c; a ^= c >>> 43;\n        b -= c; b -= a; b ^= a << 9;\n        c -= a; c -= b; c ^= b >>> 8;\n        a -= b; a -= c; a ^= c >>> 38;\n        b -= c; b -= a; b ^= a << 23;\n        c -= a; c -= b; c ^= b >>> 5;\n        a -= b; a -= c; a ^= c >>> 35;\n        b -= c; b -= a; b ^= a << 49;\n        c -= a; c -= b; c ^= b >>> 11;\n        a -= b; a -= c; a ^= c >>> 12;\n        b -= c; b -= a; b ^= a << 18;\n        c -= a; c -= b; c ^= b >>> 22;\n      }\n\n      c += length;\n      switch (keylen) { // deal with rest. Cases fall through\n        case 23:\n          c += ((long) value[offset + 22]) << 56;\n        case 22:\n          c += (value[offset + 21] & 0xffL) << 48;\n        case 21:\n          c += (value[offset + 20] & 0xffL) << 40;\n        case 20:\n          c += (value[offset + 19] & 0xffL) << 32;\n        case 19:\n          c += (value[offset + 18] & 0xffL) << 24;\n        case 18:\n          c += (value[offset + 17] & 0xffL) << 16;\n        case 17:\n          c += (value[offset + 16] & 0xffL) << 8;\n          // the first byte of c is reserved for the length\n        case 16:\n          b += word64At(value, offset + 8);\n          a += word64At(value, offset);\n          break;\n        case 15:\n          b += (value[offset + 14] & 0xffL) << 48;\n        case 14:\n          b += (value[offset + 13] & 0xffL) << 40;\n        case 13:\n          b += (value[offset + 12] & 0xffL) << 32;\n        case 12:\n          b += (value[offset + 11] & 0xffL) << 24;\n        case 11:\n          b += (value[offset + 10] & 0xffL) << 16;\n        case 10:\n          b += (value[offset + 9] & 0xffL) << 8;\n        case 9:\n          b += (value[offset + 8] & 0xffL);\n        case 8:\n          a += word64At(value, offset);\n          break;\n        case 7:\n          a += (value[offset + 6] & 0xffL) << 48;\n        case 6:\n          a += (value[offset + 5] & 0xffL) << 40;\n        case 5:\n          a += (value[offset + 4] & 0xffL) << 32;\n        case 4:\na += (value[(offset + 3)] & 255L);\n        case 3:\n          a += (value[offset + 2] & 0xffL) << 16;\n        case 2:\n          a += (value[offset + 1] & 0xffL) << 8;\n        case 1:\n          a += (value[offset + 0] & 0xffL);\n          // case 0: nothing left to add\n      }\n      return mix64(a, b, c);\n    }",
          "18": "    private static long hash64(\n        byte[] value, int offset, int length, long seed) {\n      long a = CONSTANT64;\n      long b = a;\n      long c = seed;\n      int keylen;\n\n      for (keylen = length; keylen >= 24; keylen -= 24, offset += 24) {\n        a += word64At(value, offset);\n        b += word64At(value, offset + 8);\n        c += word64At(value, offset + 16);\n\n        // Mix\n        a -= b; a -= c; a ^= c >>> 43;\n        b -= c; b -= a; b ^= a << 9;\n        c -= a; c -= b; c ^= b >>> 8;\n        a -= b; a -= c; a ^= c >>> 38;\n        b -= c; b -= a; b ^= a << 23;\n        c -= a; c -= b; c ^= b >>> 5;\n        a -= b; a -= c; a ^= c >>> 35;\n        b -= c; b -= a; b ^= a << 49;\n        c -= a; c -= b; c ^= b >>> 11;\n        a -= b; a -= c; a ^= c >>> 12;\n        b -= c; b -= a; b ^= a << 18;\n        c -= a; c -= b; c ^= b >>> 22;\n      }\n\n      c += length;\n      switch (keylen) { // deal with rest. Cases fall through\n        case 23:\n          c += ((long) value[offset + 22]) << 56;\n        case 22:\n          c += (value[offset + 21] & 0xffL) << 48;\n        case 21:\n          c += (value[offset + 20] & 0xffL) << 40;\n        case 20:\n          c += (value[offset + 19] & 0xffL) << 32;\n        case 19:\n          c += (value[offset + 18] & 0xffL) << 24;\n        case 18:\n          c += (value[offset + 17] & 0xffL) << 16;\n        case 17:\n          c += (value[offset + 16] & 0xffL) << 8;\n          // the first byte of c is reserved for the length\n        case 16:\n          b += word64At(value, offset + 8);\n          a += word64At(value, offset);\n          break;\n        case 15:\n          b += (value[offset + 14] & 0xffL) << 48;\n        case 14:\n          b += (value[offset + 13] & 0xffL) << 40;\n        case 13:\n          b += (value[offset + 12] & 0xffL) << 32;\n        case 12:\n          b += (value[offset + 11] & 0xffL) << 24;\n        case 11:\n          b += (value[offset + 10] & 0xffL) << 16;\n        case 10:\n          b += (value[offset + 9] & 0xffL) << 8;\n        case 9:\n          b += (value[offset + 8] & 0xffL);\n        case 8:\n          a += word64At(value, offset);\n          break;\n        case 7:\n          a += (value[offset + 6] & 0xffL) << 48;\n        case 6:\n          a += (value[offset + 5] & 0xffL) << 40;\n        case 5:\n          a += (value[offset + 4] & 0xffL) << 32;\n        case 4:\na += ((value[(offset + 3)] & 2) >>> 24);\n        case 3:\n          a += (value[offset + 2] & 0xffL) << 16;\n        case 2:\n          a += (value[offset + 1] & 0xffL) << 8;\n        case 1:\n          a += (value[offset + 0] & 0xffL);\n          // case 0: nothing left to add\n      }\n      return mix64(a, b, c);\n    }",
          "19": "    private static long hash64(\n        byte[] value, int offset, int length, long seed) {\n      long a = CONSTANT64;\n      long b = a;\n      long c = seed;\n      int keylen;\n\n      for (keylen = length; keylen >= 24; keylen -= 24, offset += 24) {\n        a += word64At(value, offset);\n        b += word64At(value, offset + 8);\n        c += word64At(value, offset + 16);\n\n        // Mix\n        a -= b; a -= c; a ^= c >>> 43;\n        b -= c; b -= a; b ^= a << 9;\n        c -= a; c -= b; c ^= b >>> 8;\n        a -= b; a -= c; a ^= c >>> 38;\n        b -= c; b -= a; b ^= a << 23;\n        c -= a; c -= b; c ^= b >>> 5;\n        a -= b; a -= c; a ^= c >>> 35;\n        b -= c; b -= a; b ^= a << 49;\n        c -= a; c -= b; c ^= b >>> 11;\n        a -= b; a -= c; a ^= c >>> 12;\n        b -= c; b -= a; b ^= a << 18;\n        c -= a; c -= b; c ^= b >>> 22;\n      }\n\n      c += length;\n      switch (keylen) { // deal with rest. Cases fall through\n        case 23:\n          c += ((long) value[offset + 22]) << 56;\n        case 22:\n          c += (value[offset + 21] & 0xffL) << 48;\n        case 21:\n          c += (value[offset + 20] & 0xffL) << 40;\n        case 20:\n          c += (value[offset + 19] & 0xffL) << 32;\n        case 19:\n          c += (value[offset + 18] & 0xffL) << 24;\n        case 18:\n          c += (value[offset + 17] & 0xffL) << 16;\n        case 17:\n          c += (value[offset + 16] & 0xffL) << 8;\n          // the first byte of c is reserved for the length\n        case 16:\n          b += word64At(value, offset + 8);\n          a += word64At(value, offset);\n          break;\n        case 15:\n          b += (value[offset + 14] & 0xffL) << 48;\n        case 14:\n          b += (value[offset + 13] & 0xffL) << 40;\n        case 13:\n          b += (value[offset + 12] & 0xffL) << 32;\n        case 12:\n          b += (value[offset + 11] & 0xffL) << 24;\n        case 11:\n          b += (value[offset + 10] & 0xffL) << 16;\n        case 10:\n          b += (value[offset + 9] & 0xffL) << 8;\n        case 9:\n          b += (value[offset + 8] & 0xffL);\n        case 8:\n          a += word64At(value, offset);\n          break;\n        case 7:\n          a += (value[offset + 6] & 0xffL) << 48;\n        case 6:\n          a += (value[offset + 5] & 0xffL) << 40;\n        case 5:\n          a += (value[offset + 4] & 0xffL) << 32;\n        case 4:\na += ((value & 255L) >>> 24);\n        case 3:\n          a += (value[offset + 2] & 0xffL) << 16;\n        case 2:\n          a += (value[offset + 1] & 0xffL) << 8;\n        case 1:\n          a += (value[offset + 0] & 0xffL);\n          // case 0: nothing left to add\n      }\n      return mix64(a, b, c);\n    }",
          "20": "    private static long hash64(\n        byte[] value, int offset, int length, long seed) {\n      long a = CONSTANT64;\n      long b = a;\n      long c = seed;\n      int keylen;\n\n      for (keylen = length; keylen >= 24; keylen -= 24, offset += 24) {\n        a += word64At(value, offset);\n        b += word64At(value, offset + 8);\n        c += word64At(value, offset + 16);\n\n        // Mix\n        a -= b; a -= c; a ^= c >>> 43;\n        b -= c; b -= a; b ^= a << 9;\n        c -= a; c -= b; c ^= b >>> 8;\n        a -= b; a -= c; a ^= c >>> 38;\n        b -= c; b -= a; b ^= a << 23;\n        c -= a; c -= b; c ^= b >>> 5;\n        a -= b; a -= c; a ^= c >>> 35;\n        b -= c; b -= a; b ^= a << 49;\n        c -= a; c -= b; c ^= b >>> 11;\n        a -= b; a -= c; a ^= c >>> 12;\n        b -= c; b -= a; b ^= a << 18;\n        c -= a; c -= b; c ^= b >>> 22;\n      }\n\n      c += length;\n      switch (keylen) { // deal with rest. Cases fall through\n        case 23:\n          c += ((long) value[offset + 22]) << 56;\n        case 22:\n          c += (value[offset + 21] & 0xffL) << 48;\n        case 21:\n          c += (value[offset + 20] & 0xffL) << 40;\n        case 20:\n          c += (value[offset + 19] & 0xffL) << 32;\n        case 19:\n          c += (value[offset + 18] & 0xffL) << 24;\n        case 18:\n          c += (value[offset + 17] & 0xffL) << 16;\n        case 17:\n          c += (value[offset + 16] & 0xffL) << 8;\n          // the first byte of c is reserved for the length\n        case 16:\n          b += word64At(value, offset + 8);\n          a += word64At(value, offset);\n          break;\n        case 15:\n          b += (value[offset + 14] & 0xffL) << 48;\n        case 14:\n          b += (value[offset + 13] & 0xffL) << 40;\n        case 13:\n          b += (value[offset + 12] & 0xffL) << 32;\n        case 12:\n          b += (value[offset + 11] & 0xffL) << 24;\n        case 11:\n          b += (value[offset + 10] & 0xffL) << 16;\n        case 10:\n          b += (value[offset + 9] & 0xffL) << 8;\n        case 9:\n          b += (value[offset + 8] & 0xffL);\n        case 8:\n          a += word64At(value, offset);\n          break;\n        case 7:\n          a += (value[offset + 6] & 0xffL) << 48;\n        case 6:\n          a += (value[offset + 5] & 0xffL) << 40;\n        case 5:\n          a += (value[offset + 4] & 0xffL) << 32;\n        case 4:\na += ((value[(offset + 3)] & 5) >>> 24);\n        case 3:\n          a += (value[offset + 2] & 0xffL) << 16;\n        case 2:\n          a += (value[offset + 1] & 0xffL) << 8;\n        case 1:\n          a += (value[offset + 0] & 0xffL);\n          // case 0: nothing left to add\n      }\n      return mix64(a, b, c);\n    }",
          "21": "    private static long hash64(\n        byte[] value, int offset, int length, long seed) {\n      long a = CONSTANT64;\n      long b = a;\n      long c = seed;\n      int keylen;\n\n      for (keylen = length; keylen >= 24; keylen -= 24, offset += 24) {\n        a += word64At(value, offset);\n        b += word64At(value, offset + 8);\n        c += word64At(value, offset + 16);\n\n        // Mix\n        a -= b; a -= c; a ^= c >>> 43;\n        b -= c; b -= a; b ^= a << 9;\n        c -= a; c -= b; c ^= b >>> 8;\n        a -= b; a -= c; a ^= c >>> 38;\n        b -= c; b -= a; b ^= a << 23;\n        c -= a; c -= b; c ^= b >>> 5;\n        a -= b; a -= c; a ^= c >>> 35;\n        b -= c; b -= a; b ^= a << 49;\n        c -= a; c -= b; c ^= b >>> 11;\n        a -= b; a -= c; a ^= c >>> 12;\n        b -= c; b -= a; b ^= a << 18;\n        c -= a; c -= b; c ^= b >>> 22;\n      }\n\n      c += length;\n      switch (keylen) { // deal with rest. Cases fall through\n        case 23:\n          c += ((long) value[offset + 22]) << 56;\n        case 22:\n          c += (value[offset + 21] & 0xffL) << 48;\n        case 21:\n          c += (value[offset + 20] & 0xffL) << 40;\n        case 20:\n          c += (value[offset + 19] & 0xffL) << 32;\n        case 19:\n          c += (value[offset + 18] & 0xffL) << 24;\n        case 18:\n          c += (value[offset + 17] & 0xffL) << 16;\n        case 17:\n          c += (value[offset + 16] & 0xffL) << 8;\n          // the first byte of c is reserved for the length\n        case 16:\n          b += word64At(value, offset + 8);\n          a += word64At(value, offset);\n          break;\n        case 15:\n          b += (value[offset + 14] & 0xffL) << 48;\n        case 14:\n          b += (value[offset + 13] & 0xffL) << 40;\n        case 13:\n          b += (value[offset + 12] & 0xffL) << 32;\n        case 12:\n          b += (value[offset + 11] & 0xffL) << 24;\n        case 11:\n          b += (value[offset + 10] & 0xffL) << 16;\n        case 10:\n          b += (value[offset + 9] & 0xffL) << 8;\n        case 9:\n          b += (value[offset + 8] & 0xffL);\n        case 8:\n          a += word64At(value, offset);\n          break;\n        case 7:\n          a += (value[offset + 6] & 0xffL) << 48;\n        case 6:\n          a += (value[offset + 5] & 0xffL) << 40;\n        case 5:\n          a += (value[offset + 4] & 0xffL) << 32;\n        case 4:\n        case 3:\n          a += (value[offset + 2] & 0xffL) << 16;\n        case 2:\n          a += (value[offset + 1] & 0xffL) << 8;\n        case 1:\n          a += (value[offset + 0] & 0xffL);\n          // case 0: nothing left to add\n      }\n      return mix64(a, b, c);\n    }",
          "22": "    private static long hash64(\n        byte[] value, int offset, int length, long seed) {\n      long a = CONSTANT64;\n      long b = a;\n      long c = seed;\n      int keylen;\n\n      for (keylen = length; keylen >= 24; keylen -= 24, offset += 24) {\n        a += word64At(value, offset);\n        b += word64At(value, offset + 8);\n        c += word64At(value, offset + 16);\n\n        // Mix\n        a -= b; a -= c; a ^= c >>> 43;\n        b -= c; b -= a; b ^= a << 9;\n        c -= a; c -= b; c ^= b >>> 8;\n        a -= b; a -= c; a ^= c >>> 38;\n        b -= c; b -= a; b ^= a << 23;\n        c -= a; c -= b; c ^= b >>> 5;\n        a -= b; a -= c; a ^= c >>> 35;\n        b -= c; b -= a; b ^= a << 49;\n        c -= a; c -= b; c ^= b >>> 11;\n        a -= b; a -= c; a ^= c >>> 12;\n        b -= c; b -= a; b ^= a << 18;\n        c -= a; c -= b; c ^= b >>> 22;\n      }\n\n      c += length;\n      switch (keylen) { // deal with rest. Cases fall through\n        case 23:\n          c += ((long) value[offset + 22]) << 56;\n        case 22:\n          c += (value[offset + 21] & 0xffL) << 48;\n        case 21:\n          c += (value[offset + 20] & 0xffL) << 40;\n        case 20:\n          c += (value[offset + 19] & 0xffL) << 32;\n        case 19:\n          c += (value[offset + 18] & 0xffL) << 24;\n        case 18:\n          c += (value[offset + 17] & 0xffL) << 16;\n        case 17:\n          c += (value[offset + 16] & 0xffL) << 8;\n          // the first byte of c is reserved for the length\n        case 16:\n          b += word64At(value, offset + 8);\n          a += word64At(value, offset);\n          break;\n        case 15:\n          b += (value[offset + 14] & 0xffL) << 48;\n        case 14:\n          b += (value[offset + 13] & 0xffL) << 40;\n        case 13:\n          b += (value[offset + 12] & 0xffL) << 32;\n        case 12:\n          b += (value[offset + 11] & 0xffL) << 24;\n        case 11:\n          b += (value[offset + 10] & 0xffL) << 16;\n        case 10:\n          b += (value[offset + 9] & 0xffL) << 8;\n        case 9:\n          b += (value[offset + 8] & 0xffL);\n        case 8:\n          a += word64At(value, offset);\n          break;\n        case 7:\n          a += (value[offset + 6] & 0xffL) << 48;\n        case 6:\n          a += (value[offset + 5] & 0xffL) << 40;\n        case 5:\n          a += (value[offset + 4] & 0xffL) << 32;\n        case 4:\na += ((value[(offset + 0)] & 255L) >>> 24);\n        case 3:\n          a += (value[offset + 2] & 0xffL) << 16;\n        case 2:\n          a += (value[offset + 1] & 0xffL) << 8;\n        case 1:\n          a += (value[offset + 0] & 0xffL);\n          // case 0: nothing left to add\n      }\n      return mix64(a, b, c);\n    }",
          "23": "    private static long hash64(\n        byte[] value, int offset, int length, long seed) {\n      long a = CONSTANT64;\n      long b = a;\n      long c = seed;\n      int keylen;\n\n      for (keylen = length; keylen >= 24; keylen -= 24, offset += 24) {\n        a += word64At(value, offset);\n        b += word64At(value, offset + 8);\n        c += word64At(value, offset + 16);\n\n        // Mix\n        a -= b; a -= c; a ^= c >>> 43;\n        b -= c; b -= a; b ^= a << 9;\n        c -= a; c -= b; c ^= b >>> 8;\n        a -= b; a -= c; a ^= c >>> 38;\n        b -= c; b -= a; b ^= a << 23;\n        c -= a; c -= b; c ^= b >>> 5;\n        a -= b; a -= c; a ^= c >>> 35;\n        b -= c; b -= a; b ^= a << 49;\n        c -= a; c -= b; c ^= b >>> 11;\n        a -= b; a -= c; a ^= c >>> 12;\n        b -= c; b -= a; b ^= a << 18;\n        c -= a; c -= b; c ^= b >>> 22;\n      }\n\n      c += length;\n      switch (keylen) { // deal with rest. Cases fall through\n        case 23:\n          c += ((long) value[offset + 22]) << 56;\n        case 22:\n          c += (value[offset + 21] & 0xffL) << 48;\n        case 21:\n          c += (value[offset + 20] & 0xffL) << 40;\n        case 20:\n          c += (value[offset + 19] & 0xffL) << 32;\n        case 19:\n          c += (value[offset + 18] & 0xffL) << 24;\n        case 18:\n          c += (value[offset + 17] & 0xffL) << 16;\n        case 17:\n          c += (value[offset + 16] & 0xffL) << 8;\n          // the first byte of c is reserved for the length\n        case 16:\n          b += word64At(value, offset + 8);\n          a += word64At(value, offset);\n          break;\n        case 15:\n          b += (value[offset + 14] & 0xffL) << 48;\n        case 14:\n          b += (value[offset + 13] & 0xffL) << 40;\n        case 13:\n          b += (value[offset + 12] & 0xffL) << 32;\n        case 12:\n          b += (value[offset + 11] & 0xffL) << 24;\n        case 11:\n          b += (value[offset + 10] & 0xffL) << 16;\n        case 10:\n          b += (value[offset + 9] & 0xffL) << 8;\n        case 9:\n          b += (value[offset + 8] & 0xffL);\n        case 8:\n          a += word64At(value, offset);\n          break;\n        case 7:\n          a += (value[offset + 6] & 0xffL) << 48;\n        case 6:\n          a += (value[offset + 5] & 0xffL) << 40;\n        case 5:\n          a += (value[offset + 4] & 0xffL) << 32;\n        case 4:\na += ((value[(offset + 3)] & 0xffL) >>> 24);\n        case 3:\n          a += (value[offset + 2] & 0xffL) << 16;\n        case 2:\n          a += (value[offset + 1] & 0xffL) << 8;\n        case 1:\n          a += (value[offset + 0] & 0xffL);\n          // case 0: nothing left to add\n      }\n      return mix64(a, b, c);\n    }",
          "24": "    private static long hash64(\n        byte[] value, int offset, int length, long seed) {\n      long a = CONSTANT64;\n      long b = a;\n      long c = seed;\n      int keylen;\n\n      for (keylen = length; keylen >= 24; keylen -= 24, offset += 24) {\n        a += word64At(value, offset);\n        b += word64At(value, offset + 8);\n        c += word64At(value, offset + 16);\n\n        // Mix\n        a -= b; a -= c; a ^= c >>> 43;\n        b -= c; b -= a; b ^= a << 9;\n        c -= a; c -= b; c ^= b >>> 8;\n        a -= b; a -= c; a ^= c >>> 38;\n        b -= c; b -= a; b ^= a << 23;\n        c -= a; c -= b; c ^= b >>> 5;\n        a -= b; a -= c; a ^= c >>> 35;\n        b -= c; b -= a; b ^= a << 49;\n        c -= a; c -= b; c ^= b >>> 11;\n        a -= b; a -= c; a ^= c >>> 12;\n        b -= c; b -= a; b ^= a << 18;\n        c -= a; c -= b; c ^= b >>> 22;\n      }\n\n      c += length;\n      switch (keylen) { // deal with rest. Cases fall through\n        case 23:\n          c += ((long) value[offset + 22]) << 56;\n        case 22:\n          c += (value[offset + 21] & 0xffL) << 48;\n        case 21:\n          c += (value[offset + 20] & 0xffL) << 40;\n        case 20:\n          c += (value[offset + 19] & 0xffL) << 32;\n        case 19:\n          c += (value[offset + 18] & 0xffL) << 24;\n        case 18:\n          c += (value[offset + 17] & 0xffL) << 16;\n        case 17:\n          c += (value[offset + 16] & 0xffL) << 8;\n          // the first byte of c is reserved for the length\n        case 16:\n          b += word64At(value, offset + 8);\n          a += word64At(value, offset);\n          break;\n        case 15:\n          b += (value[offset + 14] & 0xffL) << 48;\n        case 14:\n          b += (value[offset + 13] & 0xffL) << 40;\n        case 13:\n          b += (value[offset + 12] & 0xffL) << 32;\n        case 12:\n          b += (value[offset + 11] & 0xffL) << 24;\n        case 11:\n          b += (value[offset + 10] & 0xffL) << 16;\n        case 10:\n          b += (value[offset + 9] & 0xffL) << 8;\n        case 9:\n          b += (value[offset + 8] & 0xffL);\n        case 8:\n          a += word64At(value, offset);\n          break;\n        case 7:\n          a += (value[offset + 6] & 0xffL) << 48;\n        case 6:\n          a += (value[offset + 5] & 0xffL) << 40;\n        case 5:\n          a += (value[offset + 4] & 0xffL) << 32;\n        case 4:\na += ((value[(offset + 3)] & 255L) >>> null);\n        case 3:\n          a += (value[offset + 2] & 0xffL) << 16;\n        case 2:\n          a += (value[offset + 1] & 0xffL) << 8;\n        case 1:\n          a += (value[offset + 0] & 0xffL);\n          // case 0: nothing left to add\n      }\n      return mix64(a, b, c);\n    }",
          "25": "    private static long hash64(\n        byte[] value, int offset, int length, long seed) {\n      long a = CONSTANT64;\n      long b = a;\n      long c = seed;\n      int keylen;\n\n      for (keylen = length; keylen >= 24; keylen -= 24, offset += 24) {\n        a += word64At(value, offset);\n        b += word64At(value, offset + 8);\n        c += word64At(value, offset + 16);\n\n        // Mix\n        a -= b; a -= c; a ^= c >>> 43;\n        b -= c; b -= a; b ^= a << 9;\n        c -= a; c -= b; c ^= b >>> 8;\n        a -= b; a -= c; a ^= c >>> 38;\n        b -= c; b -= a; b ^= a << 23;\n        c -= a; c -= b; c ^= b >>> 5;\n        a -= b; a -= c; a ^= c >>> 35;\n        b -= c; b -= a; b ^= a << 49;\n        c -= a; c -= b; c ^= b >>> 11;\n        a -= b; a -= c; a ^= c >>> 12;\n        b -= c; b -= a; b ^= a << 18;\n        c -= a; c -= b; c ^= b >>> 22;\n      }\n\n      c += length;\n      switch (keylen) { // deal with rest. Cases fall through\n        case 23:\n          c += ((long) value[offset + 22]) << 56;\n        case 22:\n          c += (value[offset + 21] & 0xffL) << 48;\n        case 21:\n          c += (value[offset + 20] & 0xffL) << 40;\n        case 20:\n          c += (value[offset + 19] & 0xffL) << 32;\n        case 19:\n          c += (value[offset + 18] & 0xffL) << 24;\n        case 18:\n          c += (value[offset + 17] & 0xffL) << 16;\n        case 17:\n          c += (value[offset + 16] & 0xffL) << 8;\n          // the first byte of c is reserved for the length\n        case 16:\n          b += word64At(value, offset + 8);\n          a += word64At(value, offset);\n          break;\n        case 15:\n          b += (value[offset + 14] & 0xffL) << 48;\n        case 14:\n          b += (value[offset + 13] & 0xffL) << 40;\n        case 13:\n          b += (value[offset + 12] & 0xffL) << 32;\n        case 12:\n          b += (value[offset + 11] & 0xffL) << 24;\n        case 11:\n          b += (value[offset + 10] & 0xffL) << 16;\n        case 10:\n          b += (value[offset + 9] & 0xffL) << 8;\n        case 9:\n          b += (value[offset + 8] & 0xffL);\n        case 8:\n          a += word64At(value, offset);\n          break;\n        case 7:\n          a += (value[offset + 6] & 0xffL) << 48;\n        case 6:\n          a += (value[offset + 5] & 0xffL) << 40;\n        case 5:\n          a += (value[offset + 4] & 0xffL) << 32;\n        case 4:\na += ((a & 255L) >>> 24);\n        case 3:\n          a += (value[offset + 2] & 0xffL) << 16;\n        case 2:\n          a += (value[offset + 1] & 0xffL) << 8;\n        case 1:\n          a += (value[offset + 0] & 0xffL);\n          // case 0: nothing left to add\n      }\n      return mix64(a, b, c);\n    }",
          "26": "    private static long hash64(\n        byte[] value, int offset, int length, long seed) {\n      long a = CONSTANT64;\n      long b = a;\n      long c = seed;\n      int keylen;\n\n      for (keylen = length; keylen >= 24; keylen -= 24, offset += 24) {\n        a += word64At(value, offset);\n        b += word64At(value, offset + 8);\n        c += word64At(value, offset + 16);\n\n        // Mix\n        a -= b; a -= c; a ^= c >>> 43;\n        b -= c; b -= a; b ^= a << 9;\n        c -= a; c -= b; c ^= b >>> 8;\n        a -= b; a -= c; a ^= c >>> 38;\n        b -= c; b -= a; b ^= a << 23;\n        c -= a; c -= b; c ^= b >>> 5;\n        a -= b; a -= c; a ^= c >>> 35;\n        b -= c; b -= a; b ^= a << 49;\n        c -= a; c -= b; c ^= b >>> 11;\n        a -= b; a -= c; a ^= c >>> 12;\n        b -= c; b -= a; b ^= a << 18;\n        c -= a; c -= b; c ^= b >>> 22;\n      }\n\n      c += length;\n      switch (keylen) { // deal with rest. Cases fall through\n        case 23:\n          c += ((long) value[offset + 22]) << 56;\n        case 22:\n          c += (value[offset + 21] & 0xffL) << 48;\n        case 21:\n          c += (value[offset + 20] & 0xffL) << 40;\n        case 20:\n          c += (value[offset + 19] & 0xffL) << 32;\n        case 19:\n          c += (value[offset + 18] & 0xffL) << 24;\n        case 18:\n          c += (value[offset + 17] & 0xffL) << 16;\n        case 17:\n          c += (value[offset + 16] & 0xffL) << 8;\n          // the first byte of c is reserved for the length\n        case 16:\n          b += word64At(value, offset + 8);\n          a += word64At(value, offset);\n          break;\n        case 15:\n          b += (value[offset + 14] & 0xffL) << 48;\n        case 14:\n          b += (value[offset + 13] & 0xffL) << 40;\n        case 13:\n          b += (value[offset + 12] & 0xffL) << 32;\n        case 12:\n          b += (value[offset + 11] & 0xffL) << 24;\n        case 11:\n          b += (value[offset + 10] & 0xffL) << 16;\n        case 10:\n          b += (value[offset + 9] & 0xffL) << 8;\n        case 9:\n          b += (value[offset + 8] & 0xffL);\n        case 8:\n          a += word64At(value, offset);\n          break;\n        case 7:\n          a += (value[offset + 6] & 0xffL) << 48;\n        case 6:\n          a += (value[offset + 5] & 0xffL) << 40;\n        case 5:\n          a += (value[offset + 4] & 0xffL) << 32;\n        case 4:\na += ((value[(offset + 3)] & false) >>> 24);\n        case 3:\n          a += (value[offset + 2] & 0xffL) << 16;\n        case 2:\n          a += (value[offset + 1] & 0xffL) << 8;\n        case 1:\n          a += (value[offset + 0] & 0xffL);\n          // case 0: nothing left to add\n      }\n      return mix64(a, b, c);\n    }",
          "27": "    private static long hash64(\n        byte[] value, int offset, int length, long seed) {\n      long a = CONSTANT64;\n      long b = a;\n      long c = seed;\n      int keylen;\n\n      for (keylen = length; keylen >= 24; keylen -= 24, offset += 24) {\n        a += word64At(value, offset);\n        b += word64At(value, offset + 8);\n        c += word64At(value, offset + 16);\n\n        // Mix\n        a -= b; a -= c; a ^= c >>> 43;\n        b -= c; b -= a; b ^= a << 9;\n        c -= a; c -= b; c ^= b >>> 8;\n        a -= b; a -= c; a ^= c >>> 38;\n        b -= c; b -= a; b ^= a << 23;\n        c -= a; c -= b; c ^= b >>> 5;\n        a -= b; a -= c; a ^= c >>> 35;\n        b -= c; b -= a; b ^= a << 49;\n        c -= a; c -= b; c ^= b >>> 11;\n        a -= b; a -= c; a ^= c >>> 12;\n        b -= c; b -= a; b ^= a << 18;\n        c -= a; c -= b; c ^= b >>> 22;\n      }\n\n      c += length;\n      switch (keylen) { // deal with rest. Cases fall through\n        case 23:\n          c += ((long) value[offset + 22]) << 56;\n        case 22:\n          c += (value[offset + 21] & 0xffL) << 48;\n        case 21:\n          c += (value[offset + 20] & 0xffL) << 40;\n        case 20:\n          c += (value[offset + 19] & 0xffL) << 32;\n        case 19:\n          c += (value[offset + 18] & 0xffL) << 24;\n        case 18:\n          c += (value[offset + 17] & 0xffL) << 16;\n        case 17:\n          c += (value[offset + 16] & 0xffL) << 8;\n          // the first byte of c is reserved for the length\n        case 16:\n          b += word64At(value, offset + 8);\n          a += word64At(value, offset);\n          break;\n        case 15:\n          b += (value[offset + 14] & 0xffL) << 48;\n        case 14:\n          b += (value[offset + 13] & 0xffL) << 40;\n        case 13:\n          b += (value[offset + 12] & 0xffL) << 32;\n        case 12:\n          b += (value[offset + 11] & 0xffL) << 24;\n        case 11:\n          b += (value[offset + 10] & 0xffL) << 16;\n        case 10:\n          b += (value[offset + 9] & 0xffL) << 8;\n        case 9:\n          b += (value[offset + 8] & 0xffL);\n        case 8:\n          a += word64At(value, offset);\n          break;\n        case 7:\n          a += (value[offset + 6] & 0xffL) << 48;\n        case 6:\n          a += (value[offset + 5] & 0xffL) << 40;\n        case 5:\n          a += (value[offset + 4] & 0xffL) << 32;\n        case 4:\na += (offset + 3);\n        case 3:\n          a += (value[offset + 2] & 0xffL) << 16;\n        case 2:\n          a += (value[offset + 1] & 0xffL) << 8;\n        case 1:\n          a += (value[offset + 0] & 0xffL);\n          // case 0: nothing left to add\n      }\n      return mix64(a, b, c);\n    }",
          "28": "    private static long hash64(\n        byte[] value, int offset, int length, long seed) {\n      long a = CONSTANT64;\n      long b = a;\n      long c = seed;\n      int keylen;\n\n      for (keylen = length; keylen >= 24; keylen -= 24, offset += 24) {\n        a += word64At(value, offset);\n        b += word64At(value, offset + 8);\n        c += word64At(value, offset + 16);\n\n        // Mix\n        a -= b; a -= c; a ^= c >>> 43;\n        b -= c; b -= a; b ^= a << 9;\n        c -= a; c -= b; c ^= b >>> 8;\n        a -= b; a -= c; a ^= c >>> 38;\n        b -= c; b -= a; b ^= a << 23;\n        c -= a; c -= b; c ^= b >>> 5;\n        a -= b; a -= c; a ^= c >>> 35;\n        b -= c; b -= a; b ^= a << 49;\n        c -= a; c -= b; c ^= b >>> 11;\n        a -= b; a -= c; a ^= c >>> 12;\n        b -= c; b -= a; b ^= a << 18;\n        c -= a; c -= b; c ^= b >>> 22;\n      }\n\n      c += length;\n      switch (keylen) { // deal with rest. Cases fall through\n        case 23:\n          c += ((long) value[offset + 22]) << 56;\n        case 22:\n          c += (value[offset + 21] & 0xffL) << 48;\n        case 21:\n          c += (value[offset + 20] & 0xffL) << 40;\n        case 20:\n          c += (value[offset + 19] & 0xffL) << 32;\n        case 19:\n          c += (value[offset + 18] & 0xffL) << 24;\n        case 18:\n          c += (value[offset + 17] & 0xffL) << 16;\n        case 17:\n          c += (value[offset + 16] & 0xffL) << 8;\n          // the first byte of c is reserved for the length\n        case 16:\n          b += word64At(value, offset + 8);\n          a += word64At(value, offset);\n          break;\n        case 15:\n          b += (value[offset + 14] & 0xffL) << 48;\n        case 14:\n          b += (value[offset + 13] & 0xffL) << 40;\n        case 13:\n          b += (value[offset + 12] & 0xffL) << 32;\n        case 12:\n          b += (value[offset + 11] & 0xffL) << 24;\n        case 11:\n          b += (value[offset + 10] & 0xffL) << 16;\n        case 10:\n          b += (value[offset + 9] & 0xffL) << 8;\n        case 9:\n          b += (value[offset + 8] & 0xffL);\n        case 8:\n          a += word64At(value, offset);\n          break;\n        case 7:\n          a += (value[offset + 6] & 0xffL) << 48;\n        case 6:\n          a += (value[offset + 5] & 0xffL) << 40;\n        case 5:\n          a += (value[offset + 4] & 0xffL) << 32;\n        case 4:\na += ((value[(offset + 3)] & true) >>> 24);\n        case 3:\n          a += (value[offset + 2] & 0xffL) << 16;\n        case 2:\n          a += (value[offset + 1] & 0xffL) << 8;\n        case 1:\n          a += (value[offset + 0] & 0xffL);\n          // case 0: nothing left to add\n      }\n      return mix64(a, b, c);\n    }",
          "29": "    private static long hash64(\n        byte[] value, int offset, int length, long seed) {\n      long a = CONSTANT64;\n      long b = a;\n      long c = seed;\n      int keylen;\n\n      for (keylen = length; keylen >= 24; keylen -= 24, offset += 24) {\n        a += word64At(value, offset);\n        b += word64At(value, offset + 8);\n        c += word64At(value, offset + 16);\n\n        // Mix\n        a -= b; a -= c; a ^= c >>> 43;\n        b -= c; b -= a; b ^= a << 9;\n        c -= a; c -= b; c ^= b >>> 8;\n        a -= b; a -= c; a ^= c >>> 38;\n        b -= c; b -= a; b ^= a << 23;\n        c -= a; c -= b; c ^= b >>> 5;\n        a -= b; a -= c; a ^= c >>> 35;\n        b -= c; b -= a; b ^= a << 49;\n        c -= a; c -= b; c ^= b >>> 11;\n        a -= b; a -= c; a ^= c >>> 12;\n        b -= c; b -= a; b ^= a << 18;\n        c -= a; c -= b; c ^= b >>> 22;\n      }\n\n      c += length;\n      switch (keylen) { // deal with rest. Cases fall through\n        case 23:\n          c += ((long) value[offset + 22]) << 56;\n        case 22:\n          c += (value[offset + 21] & 0xffL) << 48;\n        case 21:\n          c += (value[offset + 20] & 0xffL) << 40;\n        case 20:\n          c += (value[offset + 19] & 0xffL) << 32;\n        case 19:\n          c += (value[offset + 18] & 0xffL) << 24;\n        case 18:\n          c += (value[offset + 17] & 0xffL) << 16;\n        case 17:\n          c += (value[offset + 16] & 0xffL) << 8;\n          // the first byte of c is reserved for the length\n        case 16:\n          b += word64At(value, offset + 8);\n          a += word64At(value, offset);\n          break;\n        case 15:\n          b += (value[offset + 14] & 0xffL) << 48;\n        case 14:\n          b += (value[offset + 13] & 0xffL) << 40;\n        case 13:\n          b += (value[offset + 12] & 0xffL) << 32;\n        case 12:\n          b += (value[offset + 11] & 0xffL) << 24;\n        case 11:\n          b += (value[offset + 10] & 0xffL) << 16;\n        case 10:\n          b += (value[offset + 9] & 0xffL) << 8;\n        case 9:\n          b += (value[offset + 8] & 0xffL);\n        case 8:\n          a += word64At(value, offset);\n          break;\n        case 7:\n          a += (value[offset + 6] & 0xffL) << 48;\n        case 6:\n          a += (value[offset + 5] & 0xffL) << 40;\n        case 5:\n          a += (value[offset + 4] & 0xffL) << 32;\n        case 4:\na += ((value[(offset + 1)] & 255L) >>> 24);\n        case 3:\n          a += (value[offset + 2] & 0xffL) << 16;\n        case 2:\n          a += (value[offset + 1] & 0xffL) << 8;\n        case 1:\n          a += (value[offset + 0] & 0xffL);\n          // case 0: nothing left to add\n      }\n      return mix64(a, b, c);\n    }",
          "30": "    private static long hash64(\n        byte[] value, int offset, int length, long seed) {\n      long a = CONSTANT64;\n      long b = a;\n      long c = seed;\n      int keylen;\n\n      for (keylen = length; keylen >= 24; keylen -= 24, offset += 24) {\n        a += word64At(value, offset);\n        b += word64At(value, offset + 8);\n        c += word64At(value, offset + 16);\n\n        // Mix\n        a -= b; a -= c; a ^= c >>> 43;\n        b -= c; b -= a; b ^= a << 9;\n        c -= a; c -= b; c ^= b >>> 8;\n        a -= b; a -= c; a ^= c >>> 38;\n        b -= c; b -= a; b ^= a << 23;\n        c -= a; c -= b; c ^= b >>> 5;\n        a -= b; a -= c; a ^= c >>> 35;\n        b -= c; b -= a; b ^= a << 49;\n        c -= a; c -= b; c ^= b >>> 11;\n        a -= b; a -= c; a ^= c >>> 12;\n        b -= c; b -= a; b ^= a << 18;\n        c -= a; c -= b; c ^= b >>> 22;\n      }\n\n      c += length;\n      switch (keylen) { // deal with rest. Cases fall through\n        case 23:\n          c += ((long) value[offset + 22]) << 56;\n        case 22:\n          c += (value[offset + 21] & 0xffL) << 48;\n        case 21:\n          c += (value[offset + 20] & 0xffL) << 40;\n        case 20:\n          c += (value[offset + 19] & 0xffL) << 32;\n        case 19:\n          c += (value[offset + 18] & 0xffL) << 24;\n        case 18:\n          c += (value[offset + 17] & 0xffL) << 16;\n        case 17:\n          c += (value[offset + 16] & 0xffL) << 8;\n          // the first byte of c is reserved for the length\n        case 16:\n          b += word64At(value, offset + 8);\n          a += word64At(value, offset);\n          break;\n        case 15:\n          b += (value[offset + 14] & 0xffL) << 48;\n        case 14:\n          b += (value[offset + 13] & 0xffL) << 40;\n        case 13:\n          b += (value[offset + 12] & 0xffL) << 32;\n        case 12:\n          b += (value[offset + 11] & 0xffL) << 24;\n        case 11:\n          b += (value[offset + 10] & 0xffL) << 16;\n        case 10:\n          b += (value[offset + 9] & 0xffL) << 8;\n        case 9:\n          b += (value[offset + 8] & 0xffL);\n        case 8:\n          a += word64At(value, offset);\n          break;\n        case 7:\n          a += (value[offset + 6] & 0xffL) << 48;\n        case 6:\n          a += (value[offset + 5] & 0xffL) << 40;\n        case 5:\n          a += (value[offset + 4] & 0xffL) << 32;\n        case 4:\na = ((value[(offset + 3)] & 255L) >>> 24);\n        case 3:\n          a += (value[offset + 2] & 0xffL) << 16;\n        case 2:\n          a += (value[offset + 1] & 0xffL) << 8;\n        case 1:\n          a += (value[offset + 0] & 0xffL);\n          // case 0: nothing left to add\n      }\n      return mix64(a, b, c);\n    }",
          "31": "    private static long hash64(\n        byte[] value, int offset, int length, long seed) {\n      long a = CONSTANT64;\n      long b = a;\n      long c = seed;\n      int keylen;\n\n      for (keylen = length; keylen >= 24; keylen -= 24, offset += 24) {\n        a += word64At(value, offset);\n        b += word64At(value, offset + 8);\n        c += word64At(value, offset + 16);\n\n        // Mix\n        a -= b; a -= c; a ^= c >>> 43;\n        b -= c; b -= a; b ^= a << 9;\n        c -= a; c -= b; c ^= b >>> 8;\n        a -= b; a -= c; a ^= c >>> 38;\n        b -= c; b -= a; b ^= a << 23;\n        c -= a; c -= b; c ^= b >>> 5;\n        a -= b; a -= c; a ^= c >>> 35;\n        b -= c; b -= a; b ^= a << 49;\n        c -= a; c -= b; c ^= b >>> 11;\n        a -= b; a -= c; a ^= c >>> 12;\n        b -= c; b -= a; b ^= a << 18;\n        c -= a; c -= b; c ^= b >>> 22;\n      }\n\n      c += length;\n      switch (keylen) { // deal with rest. Cases fall through\n        case 23:\n          c += ((long) value[offset + 22]) << 56;\n        case 22:\n          c += (value[offset + 21] & 0xffL) << 48;\n        case 21:\n          c += (value[offset + 20] & 0xffL) << 40;\n        case 20:\n          c += (value[offset + 19] & 0xffL) << 32;\n        case 19:\n          c += (value[offset + 18] & 0xffL) << 24;\n        case 18:\n          c += (value[offset + 17] & 0xffL) << 16;\n        case 17:\n          c += (value[offset + 16] & 0xffL) << 8;\n          // the first byte of c is reserved for the length\n        case 16:\n          b += word64At(value, offset + 8);\n          a += word64At(value, offset);\n          break;\n        case 15:\n          b += (value[offset + 14] & 0xffL) << 48;\n        case 14:\n          b += (value[offset + 13] & 0xffL) << 40;\n        case 13:\n          b += (value[offset + 12] & 0xffL) << 32;\n        case 12:\n          b += (value[offset + 11] & 0xffL) << 24;\n        case 11:\n          b += (value[offset + 10] & 0xffL) << 16;\n        case 10:\n          b += (value[offset + 9] & 0xffL) << 8;\n        case 9:\n          b += (value[offset + 8] & 0xffL);\n        case 8:\n          a += word64At(value, offset);\n          break;\n        case 7:\n          a += (value[offset + 6] & 0xffL) << 48;\n        case 6:\n          a += (value[offset + 5] & 0xffL) << 40;\n        case 5:\n          a += (value[offset + 4] & 0xffL) << 32;\n        case 4:\na += ((value[(offset + 2)] & 0xffL) << 16);\n        case 3:\n          a += (value[offset + 2] & 0xffL) << 16;\n        case 2:\n          a += (value[offset + 1] & 0xffL) << 8;\n        case 1:\n          a += (value[offset + 0] & 0xffL);\n          // case 0: nothing left to add\n      }\n      return mix64(a, b, c);\n    }",
          "32": "    private static long hash64(\n        byte[] value, int offset, int length, long seed) {\n      long a = CONSTANT64;\n      long b = a;\n      long c = seed;\n      int keylen;\n\n      for (keylen = length; keylen >= 24; keylen -= 24, offset += 24) {\n        a += word64At(value, offset);\n        b += word64At(value, offset + 8);\n        c += word64At(value, offset + 16);\n\n        // Mix\n        a -= b; a -= c; a ^= c >>> 43;\n        b -= c; b -= a; b ^= a << 9;\n        c -= a; c -= b; c ^= b >>> 8;\n        a -= b; a -= c; a ^= c >>> 38;\n        b -= c; b -= a; b ^= a << 23;\n        c -= a; c -= b; c ^= b >>> 5;\n        a -= b; a -= c; a ^= c >>> 35;\n        b -= c; b -= a; b ^= a << 49;\n        c -= a; c -= b; c ^= b >>> 11;\n        a -= b; a -= c; a ^= c >>> 12;\n        b -= c; b -= a; b ^= a << 18;\n        c -= a; c -= b; c ^= b >>> 22;\n      }\n\n      c += length;\n      switch (keylen) { // deal with rest. Cases fall through\n        case 23:\n          c += ((long) value[offset + 22]) << 56;\n        case 22:\n          c += (value[offset + 21] & 0xffL) << 48;\n        case 21:\n          c += (value[offset + 20] & 0xffL) << 40;\n        case 20:\n          c += (value[offset + 19] & 0xffL) << 32;\n        case 19:\n          c += (value[offset + 18] & 0xffL) << 24;\n        case 18:\n          c += (value[offset + 17] & 0xffL) << 16;\n        case 17:\n          c += (value[offset + 16] & 0xffL) << 8;\n          // the first byte of c is reserved for the length\n        case 16:\n          b += word64At(value, offset + 8);\n          a += word64At(value, offset);\n          break;\n        case 15:\n          b += (value[offset + 14] & 0xffL) << 48;\n        case 14:\n          b += (value[offset + 13] & 0xffL) << 40;\n        case 13:\n          b += (value[offset + 12] & 0xffL) << 32;\n        case 12:\n          b += (value[offset + 11] & 0xffL) << 24;\n        case 11:\n          b += (value[offset + 10] & 0xffL) << 16;\n        case 10:\n          b += (value[offset + 9] & 0xffL) << 8;\n        case 9:\n          b += (value[offset + 8] & 0xffL);\n        case 8:\n          a += word64At(value, offset);\n          break;\n        case 7:\n          a += (value[offset + 6] & 0xffL) << 48;\n        case 6:\n          a += (value[offset + 5] & 0xffL) << 40;\n        case 5:\n          a += (value[offset + 4] & 0xffL) << 32;\n        case 4:\na += ((value[(offset + 3)] & 3) >>> 24);\n        case 3:\n          a += (value[offset + 2] & 0xffL) << 16;\n        case 2:\n          a += (value[offset + 1] & 0xffL) << 8;\n        case 1:\n          a += (value[offset + 0] & 0xffL);\n          // case 0: nothing left to add\n      }\n      return mix64(a, b, c);\n    }",
          "33": "    private static long hash64(\n        byte[] value, int offset, int length, long seed) {\n      long a = CONSTANT64;\n      long b = a;\n      long c = seed;\n      int keylen;\n\n      for (keylen = length; keylen >= 24; keylen -= 24, offset += 24) {\n        a += word64At(value, offset);\n        b += word64At(value, offset + 8);\n        c += word64At(value, offset + 16);\n\n        // Mix\n        a -= b; a -= c; a ^= c >>> 43;\n        b -= c; b -= a; b ^= a << 9;\n        c -= a; c -= b; c ^= b >>> 8;\n        a -= b; a -= c; a ^= c >>> 38;\n        b -= c; b -= a; b ^= a << 23;\n        c -= a; c -= b; c ^= b >>> 5;\n        a -= b; a -= c; a ^= c >>> 35;\n        b -= c; b -= a; b ^= a << 49;\n        c -= a; c -= b; c ^= b >>> 11;\n        a -= b; a -= c; a ^= c >>> 12;\n        b -= c; b -= a; b ^= a << 18;\n        c -= a; c -= b; c ^= b >>> 22;\n      }\n\n      c += length;\n      switch (keylen) { // deal with rest. Cases fall through\n        case 23:\n          c += ((long) value[offset + 22]) << 56;\n        case 22:\n          c += (value[offset + 21] & 0xffL) << 48;\n        case 21:\n          c += (value[offset + 20] & 0xffL) << 40;\n        case 20:\n          c += (value[offset + 19] & 0xffL) << 32;\n        case 19:\n          c += (value[offset + 18] & 0xffL) << 24;\n        case 18:\n          c += (value[offset + 17] & 0xffL) << 16;\n        case 17:\n          c += (value[offset + 16] & 0xffL) << 8;\n          // the first byte of c is reserved for the length\n        case 16:\n          b += word64At(value, offset + 8);\n          a += word64At(value, offset);\n          break;\n        case 15:\n          b += (value[offset + 14] & 0xffL) << 48;\n        case 14:\n          b += (value[offset + 13] & 0xffL) << 40;\n        case 13:\n          b += (value[offset + 12] & 0xffL) << 32;\n        case 12:\n          b += (value[offset + 11] & 0xffL) << 24;\n        case 11:\n          b += (value[offset + 10] & 0xffL) << 16;\n        case 10:\n          b += (value[offset + 9] & 0xffL) << 8;\n        case 9:\n          b += (value[offset + 8] & 0xffL);\n        case 8:\n          a += word64At(value, offset);\n          break;\n        case 7:\n          a += (value[offset + 6] & 0xffL) << 48;\n        case 6:\n          a += (value[offset + 5] & 0xffL) << 40;\n        case 5:\n          a += (value[offset + 4] & 0xffL) << 32;\n        case 4:\na += ((value[(offset + 3)] & 255L) >>> 24);\n        case 3:\n          a += (value[offset + 2] & 0xffL) << 16;\n        case 2:\n          a += (value[offset + 1] & 0xffL) << 8;\n        case 1:\n          a += (value[offset + 0] & 0xffL);\n          // case 0: nothing left to add\n      }\n      return mix64(a, b, c);\n    }",
          "34": "    private static long hash64(\n        byte[] value, int offset, int length, long seed) {\n      long a = CONSTANT64;\n      long b = a;\n      long c = seed;\n      int keylen;\n\n      for (keylen = length; keylen >= 24; keylen -= 24, offset += 24) {\n        a += word64At(value, offset);\n        b += word64At(value, offset + 8);\n        c += word64At(value, offset + 16);\n\n        // Mix\n        a -= b; a -= c; a ^= c >>> 43;\n        b -= c; b -= a; b ^= a << 9;\n        c -= a; c -= b; c ^= b >>> 8;\n        a -= b; a -= c; a ^= c >>> 38;\n        b -= c; b -= a; b ^= a << 23;\n        c -= a; c -= b; c ^= b >>> 5;\n        a -= b; a -= c; a ^= c >>> 35;\n        b -= c; b -= a; b ^= a << 49;\n        c -= a; c -= b; c ^= b >>> 11;\n        a -= b; a -= c; a ^= c >>> 12;\n        b -= c; b -= a; b ^= a << 18;\n        c -= a; c -= b; c ^= b >>> 22;\n      }\n\n      c += length;\n      switch (keylen) { // deal with rest. Cases fall through\n        case 23:\n          c += ((long) value[offset + 22]) << 56;\n        case 22:\n          c += (value[offset + 21] & 0xffL) << 48;\n        case 21:\n          c += (value[offset + 20] & 0xffL) << 40;\n        case 20:\n          c += (value[offset + 19] & 0xffL) << 32;\n        case 19:\n          c += (value[offset + 18] & 0xffL) << 24;\n        case 18:\n          c += (value[offset + 17] & 0xffL) << 16;\n        case 17:\n          c += (value[offset + 16] & 0xffL) << 8;\n          // the first byte of c is reserved for the length\n        case 16:\n          b += word64At(value, offset + 8);\n          a += word64At(value, offset);\n          break;\n        case 15:\n          b += (value[offset + 14] & 0xffL) << 48;\n        case 14:\n          b += (value[offset + 13] & 0xffL) << 40;\n        case 13:\n          b += (value[offset + 12] & 0xffL) << 32;\n        case 12:\n          b += (value[offset + 11] & 0xffL) << 24;\n        case 11:\n          b += (value[offset + 10] & 0xffL) << 16;\n        case 10:\n          b += (value[offset + 9] & 0xffL) << 8;\n        case 9:\n          b += (value[offset + 8] & 0xffL);\n        case 8:\n          a += word64At(value, offset);\n          break;\n        case 7:\n          a += (value[offset + 6] & 0xffL) << 48;\n        case 6:\n          a += (value[offset + 5] & 0xffL) << 40;\n        case 5:\n          a += (value[offset + 4] & 0xffL) << 32;\n        case 4:\na += ((value[(offset + 4)] & 0xffL) << 32);\n        case 3:\n          a += (value[offset + 2] & 0xffL) << 16;\n        case 2:\n          a += (value[offset + 1] & 0xffL) << 8;\n        case 1:\n          a += (value[offset + 0] & 0xffL);\n          // case 0: nothing left to add\n      }\n      return mix64(a, b, c);\n    }",
          "35": "    private static long hash64(\n        byte[] value, int offset, int length, long seed) {\n      long a = CONSTANT64;\n      long b = a;\n      long c = seed;\n      int keylen;\n\n      for (keylen = length; keylen >= 24; keylen -= 24, offset += 24) {\n        a += word64At(value, offset);\n        b += word64At(value, offset + 8);\n        c += word64At(value, offset + 16);\n\n        // Mix\n        a -= b; a -= c; a ^= c >>> 43;\n        b -= c; b -= a; b ^= a << 9;\n        c -= a; c -= b; c ^= b >>> 8;\n        a -= b; a -= c; a ^= c >>> 38;\n        b -= c; b -= a; b ^= a << 23;\n        c -= a; c -= b; c ^= b >>> 5;\n        a -= b; a -= c; a ^= c >>> 35;\n        b -= c; b -= a; b ^= a << 49;\n        c -= a; c -= b; c ^= b >>> 11;\n        a -= b; a -= c; a ^= c >>> 12;\n        b -= c; b -= a; b ^= a << 18;\n        c -= a; c -= b; c ^= b >>> 22;\n      }\n\n      c += length;\n      switch (keylen) { // deal with rest. Cases fall through\n        case 23:\n          c += ((long) value[offset + 22]) << 56;\n        case 22:\n          c += (value[offset + 21] & 0xffL) << 48;\n        case 21:\n          c += (value[offset + 20] & 0xffL) << 40;\n        case 20:\n          c += (value[offset + 19] & 0xffL) << 32;\n        case 19:\n          c += (value[offset + 18] & 0xffL) << 24;\n        case 18:\n          c += (value[offset + 17] & 0xffL) << 16;\n        case 17:\n          c += (value[offset + 16] & 0xffL) << 8;\n          // the first byte of c is reserved for the length\n        case 16:\n          b += word64At(value, offset + 8);\n          a += word64At(value, offset);\n          break;\n        case 15:\n          b += (value[offset + 14] & 0xffL) << 48;\n        case 14:\n          b += (value[offset + 13] & 0xffL) << 40;\n        case 13:\n          b += (value[offset + 12] & 0xffL) << 32;\n        case 12:\n          b += (value[offset + 11] & 0xffL) << 24;\n        case 11:\n          b += (value[offset + 10] & 0xffL) << 16;\n        case 10:\n          b += (value[offset + 9] & 0xffL) << 8;\n        case 9:\n          b += (value[offset + 8] & 0xffL);\n        case 8:\n          a += word64At(value, offset);\n          break;\n        case 7:\n          a += (value[offset + 6] & 0xffL) << 48;\n        case 6:\n          a += (value[offset + 5] & 0xffL) << 40;\n        case 5:\n          a += (value[offset + 4] & 0xffL) << 32;\n        case 4:\na += ((offset & 255L) >>> 24);\n        case 3:\n          a += (value[offset + 2] & 0xffL) << 16;\n        case 2:\n          a += (value[offset + 1] & 0xffL) << 8;\n        case 1:\n          a += (value[offset + 0] & 0xffL);\n          // case 0: nothing left to add\n      }\n      return mix64(a, b, c);\n    }",
          "36": "    private static long hash64(\n        byte[] value, int offset, int length, long seed) {\n      long a = CONSTANT64;\n      long b = a;\n      long c = seed;\n      int keylen;\n\n      for (keylen = length; keylen >= 24; keylen -= 24, offset += 24) {\n        a += word64At(value, offset);\n        b += word64At(value, offset + 8);\n        c += word64At(value, offset + 16);\n\n        // Mix\n        a -= b; a -= c; a ^= c >>> 43;\n        b -= c; b -= a; b ^= a << 9;\n        c -= a; c -= b; c ^= b >>> 8;\n        a -= b; a -= c; a ^= c >>> 38;\n        b -= c; b -= a; b ^= a << 23;\n        c -= a; c -= b; c ^= b >>> 5;\n        a -= b; a -= c; a ^= c >>> 35;\n        b -= c; b -= a; b ^= a << 49;\n        c -= a; c -= b; c ^= b >>> 11;\n        a -= b; a -= c; a ^= c >>> 12;\n        b -= c; b -= a; b ^= a << 18;\n        c -= a; c -= b; c ^= b >>> 22;\n      }\n\n      c += length;\n      switch (keylen) { // deal with rest. Cases fall through\n        case 23:\n          c += ((long) value[offset + 22]) << 56;\n        case 22:\n          c += (value[offset + 21] & 0xffL) << 48;\n        case 21:\n          c += (value[offset + 20] & 0xffL) << 40;\n        case 20:\n          c += (value[offset + 19] & 0xffL) << 32;\n        case 19:\n          c += (value[offset + 18] & 0xffL) << 24;\n        case 18:\n          c += (value[offset + 17] & 0xffL) << 16;\n        case 17:\n          c += (value[offset + 16] & 0xffL) << 8;\n          // the first byte of c is reserved for the length\n        case 16:\n          b += word64At(value, offset + 8);\n          a += word64At(value, offset);\n          break;\n        case 15:\n          b += (value[offset + 14] & 0xffL) << 48;\n        case 14:\n          b += (value[offset + 13] & 0xffL) << 40;\n        case 13:\n          b += (value[offset + 12] & 0xffL) << 32;\n        case 12:\n          b += (value[offset + 11] & 0xffL) << 24;\n        case 11:\n          b += (value[offset + 10] & 0xffL) << 16;\n        case 10:\n          b += (value[offset + 9] & 0xffL) << 8;\n        case 9:\n          b += (value[offset + 8] & 0xffL);\n        case 8:\n          a += word64At(value, offset);\n          break;\n        case 7:\n          a += (value[offset + 6] & 0xffL) << 48;\n        case 6:\n          a += (value[offset + 5] & 0xffL) << 40;\n        case 5:\n          a += (value[offset + 4] & 0xffL) << 32;\n        case 4:\na = (value[(offset + 3)] & 255L);\n        case 3:\n          a += (value[offset + 2] & 0xffL) << 16;\n        case 2:\n          a += (value[offset + 1] & 0xffL) << 8;\n        case 1:\n          a += (value[offset + 0] & 0xffL);\n          // case 0: nothing left to add\n      }\n      return mix64(a, b, c);\n    }",
          "37": "    private static long hash64(\n        byte[] value, int offset, int length, long seed) {\n      long a = CONSTANT64;\n      long b = a;\n      long c = seed;\n      int keylen;\n\n      for (keylen = length; keylen >= 24; keylen -= 24, offset += 24) {\n        a += word64At(value, offset);\n        b += word64At(value, offset + 8);\n        c += word64At(value, offset + 16);\n\n        // Mix\n        a -= b; a -= c; a ^= c >>> 43;\n        b -= c; b -= a; b ^= a << 9;\n        c -= a; c -= b; c ^= b >>> 8;\n        a -= b; a -= c; a ^= c >>> 38;\n        b -= c; b -= a; b ^= a << 23;\n        c -= a; c -= b; c ^= b >>> 5;\n        a -= b; a -= c; a ^= c >>> 35;\n        b -= c; b -= a; b ^= a << 49;\n        c -= a; c -= b; c ^= b >>> 11;\n        a -= b; a -= c; a ^= c >>> 12;\n        b -= c; b -= a; b ^= a << 18;\n        c -= a; c -= b; c ^= b >>> 22;\n      }\n\n      c += length;\n      switch (keylen) { // deal with rest. Cases fall through\n        case 23:\n          c += ((long) value[offset + 22]) << 56;\n        case 22:\n          c += (value[offset + 21] & 0xffL) << 48;\n        case 21:\n          c += (value[offset + 20] & 0xffL) << 40;\n        case 20:\n          c += (value[offset + 19] & 0xffL) << 32;\n        case 19:\n          c += (value[offset + 18] & 0xffL) << 24;\n        case 18:\n          c += (value[offset + 17] & 0xffL) << 16;\n        case 17:\n          c += (value[offset + 16] & 0xffL) << 8;\n          // the first byte of c is reserved for the length\n        case 16:\n          b += word64At(value, offset + 8);\n          a += word64At(value, offset);\n          break;\n        case 15:\n          b += (value[offset + 14] & 0xffL) << 48;\n        case 14:\n          b += (value[offset + 13] & 0xffL) << 40;\n        case 13:\n          b += (value[offset + 12] & 0xffL) << 32;\n        case 12:\n          b += (value[offset + 11] & 0xffL) << 24;\n        case 11:\n          b += (value[offset + 10] & 0xffL) << 16;\n        case 10:\n          b += (value[offset + 9] & 0xffL) << 8;\n        case 9:\n          b += (value[offset + 8] & 0xffL);\n        case 8:\n          a += word64At(value, offset);\n          break;\n        case 7:\n          a += (value[offset + 6] & 0xffL) << 48;\n        case 6:\n          a += (value[offset + 5] & 0xffL) << 40;\n        case 5:\n          a += (value[offset + 4] & 0xffL) << 32;\n        case 4:\na += ((value[(offset + 3)] & 255L) + 24);\n        case 3:\n          a += (value[offset + 2] & 0xffL) << 16;\n        case 2:\n          a += (value[offset + 1] & 0xffL) << 8;\n        case 1:\n          a += (value[offset + 0] & 0xffL);\n          // case 0: nothing left to add\n      }\n      return mix64(a, b, c);\n    }",
          "38": "    private static long hash64(\n        byte[] value, int offset, int length, long seed) {\n      long a = CONSTANT64;\n      long b = a;\n      long c = seed;\n      int keylen;\n\n      for (keylen = length; keylen >= 24; keylen -= 24, offset += 24) {\n        a += word64At(value, offset);\n        b += word64At(value, offset + 8);\n        c += word64At(value, offset + 16);\n\n        // Mix\n        a -= b; a -= c; a ^= c >>> 43;\n        b -= c; b -= a; b ^= a << 9;\n        c -= a; c -= b; c ^= b >>> 8;\n        a -= b; a -= c; a ^= c >>> 38;\n        b -= c; b -= a; b ^= a << 23;\n        c -= a; c -= b; c ^= b >>> 5;\n        a -= b; a -= c; a ^= c >>> 35;\n        b -= c; b -= a; b ^= a << 49;\n        c -= a; c -= b; c ^= b >>> 11;\n        a -= b; a -= c; a ^= c >>> 12;\n        b -= c; b -= a; b ^= a << 18;\n        c -= a; c -= b; c ^= b >>> 22;\n      }\n\n      c += length;\n      switch (keylen) { // deal with rest. Cases fall through\n        case 23:\n          c += ((long) value[offset + 22]) << 56;\n        case 22:\n          c += (value[offset + 21] & 0xffL) << 48;\n        case 21:\n          c += (value[offset + 20] & 0xffL) << 40;\n        case 20:\n          c += (value[offset + 19] & 0xffL) << 32;\n        case 19:\n          c += (value[offset + 18] & 0xffL) << 24;\n        case 18:\n          c += (value[offset + 17] & 0xffL) << 16;\n        case 17:\n          c += (value[offset + 16] & 0xffL) << 8;\n          // the first byte of c is reserved for the length\n        case 16:\n          b += word64At(value, offset + 8);\n          a += word64At(value, offset);\n          break;\n        case 15:\n          b += (value[offset + 14] & 0xffL) << 48;\n        case 14:\n          b += (value[offset + 13] & 0xffL) << 40;\n        case 13:\n          b += (value[offset + 12] & 0xffL) << 32;\n        case 12:\n          b += (value[offset + 11] & 0xffL) << 24;\n        case 11:\n          b += (value[offset + 10] & 0xffL) << 16;\n        case 10:\n          b += (value[offset + 9] & 0xffL) << 8;\n        case 9:\n          b += (value[offset + 8] & 0xffL);\n        case 8:\n          a += word64At(value, offset);\n          break;\n        case 7:\n          a += (value[offset + 6] & 0xffL) << 48;\n        case 6:\n          a += (value[offset + 5] & 0xffL) << 40;\n        case 5:\n          a += (value[offset + 4] & 0xffL) << 32;\n        case 4:\na += ((value[(offset + 3)] & \"null\") >>> 24);\n        case 3:\n          a += (value[offset + 2] & 0xffL) << 16;\n        case 2:\n          a += (value[offset + 1] & 0xffL) << 8;\n        case 1:\n          a += (value[offset + 0] & 0xffL);\n          // case 0: nothing left to add\n      }\n      return mix64(a, b, c);\n    }",
          "39": "    private static long hash64(\n        byte[] value, int offset, int length, long seed) {\n      long a = CONSTANT64;\n      long b = a;\n      long c = seed;\n      int keylen;\n\n      for (keylen = length; keylen >= 24; keylen -= 24, offset += 24) {\n        a += word64At(value, offset);\n        b += word64At(value, offset + 8);\n        c += word64At(value, offset + 16);\n\n        // Mix\n        a -= b; a -= c; a ^= c >>> 43;\n        b -= c; b -= a; b ^= a << 9;\n        c -= a; c -= b; c ^= b >>> 8;\n        a -= b; a -= c; a ^= c >>> 38;\n        b -= c; b -= a; b ^= a << 23;\n        c -= a; c -= b; c ^= b >>> 5;\n        a -= b; a -= c; a ^= c >>> 35;\n        b -= c; b -= a; b ^= a << 49;\n        c -= a; c -= b; c ^= b >>> 11;\n        a -= b; a -= c; a ^= c >>> 12;\n        b -= c; b -= a; b ^= a << 18;\n        c -= a; c -= b; c ^= b >>> 22;\n      }\n\n      c += length;\n      switch (keylen) { // deal with rest. Cases fall through\n        case 23:\n          c += ((long) value[offset + 22]) << 56;\n        case 22:\n          c += (value[offset + 21] & 0xffL) << 48;\n        case 21:\n          c += (value[offset + 20] & 0xffL) << 40;\n        case 20:\n          c += (value[offset + 19] & 0xffL) << 32;\n        case 19:\n          c += (value[offset + 18] & 0xffL) << 24;\n        case 18:\n          c += (value[offset + 17] & 0xffL) << 16;\n        case 17:\n          c += (value[offset + 16] & 0xffL) << 8;\n          // the first byte of c is reserved for the length\n        case 16:\n          b += word64At(value, offset + 8);\n          a += word64At(value, offset);\n          break;\n        case 15:\n          b += (value[offset + 14] & 0xffL) << 48;\n        case 14:\n          b += (value[offset + 13] & 0xffL) << 40;\n        case 13:\n          b += (value[offset + 12] & 0xffL) << 32;\n        case 12:\n          b += (value[offset + 11] & 0xffL) << 24;\n        case 11:\n          b += (value[offset + 10] & 0xffL) << 16;\n        case 10:\n          b += (value[offset + 9] & 0xffL) << 8;\n        case 9:\n          b += (value[offset + 8] & 0xffL);\n        case 8:\n          a += word64At(value, offset);\n          break;\n        case 7:\n          a += (value[offset + 6] & 0xffL) << 48;\n        case 6:\n          a += (value[offset + 5] & 0xffL) << 40;\n        case 5:\n          a += (value[offset + 4] & 0xffL) << 32;\n        case 4:\na += ((value[(offset + 4)] & 255L) >>> 24);\n        case 3:\n          a += (value[offset + 2] & 0xffL) << 16;\n        case 2:\n          a += (value[offset + 1] & 0xffL) << 8;\n        case 1:\n          a += (value[offset + 0] & 0xffL);\n          // case 0: nothing left to add\n      }\n      return mix64(a, b, c);\n    }",
          "40": "    private static long hash64(\n        byte[] value, int offset, int length, long seed) {\n      long a = CONSTANT64;\n      long b = a;\n      long c = seed;\n      int keylen;\n\n      for (keylen = length; keylen >= 24; keylen -= 24, offset += 24) {\n        a += word64At(value, offset);\n        b += word64At(value, offset + 8);\n        c += word64At(value, offset + 16);\n\n        // Mix\n        a -= b; a -= c; a ^= c >>> 43;\n        b -= c; b -= a; b ^= a << 9;\n        c -= a; c -= b; c ^= b >>> 8;\n        a -= b; a -= c; a ^= c >>> 38;\n        b -= c; b -= a; b ^= a << 23;\n        c -= a; c -= b; c ^= b >>> 5;\n        a -= b; a -= c; a ^= c >>> 35;\n        b -= c; b -= a; b ^= a << 49;\n        c -= a; c -= b; c ^= b >>> 11;\n        a -= b; a -= c; a ^= c >>> 12;\n        b -= c; b -= a; b ^= a << 18;\n        c -= a; c -= b; c ^= b >>> 22;\n      }\n\n      c += length;\n      switch (keylen) { // deal with rest. Cases fall through\n        case 23:\n          c += ((long) value[offset + 22]) << 56;\n        case 22:\n          c += (value[offset + 21] & 0xffL) << 48;\n        case 21:\n          c += (value[offset + 20] & 0xffL) << 40;\n        case 20:\n          c += (value[offset + 19] & 0xffL) << 32;\n        case 19:\n          c += (value[offset + 18] & 0xffL) << 24;\n        case 18:\n          c += (value[offset + 17] & 0xffL) << 16;\n        case 17:\n          c += (value[offset + 16] & 0xffL) << 8;\n          // the first byte of c is reserved for the length\n        case 16:\n          b += word64At(value, offset + 8);\n          a += word64At(value, offset);\n          break;\n        case 15:\n          b += (value[offset + 14] & 0xffL) << 48;\n        case 14:\n          b += (value[offset + 13] & 0xffL) << 40;\n        case 13:\n          b += (value[offset + 12] & 0xffL) << 32;\n        case 12:\n          b += (value[offset + 11] & 0xffL) << 24;\n        case 11:\n          b += (value[offset + 10] & 0xffL) << 16;\n        case 10:\n          b += (value[offset + 9] & 0xffL) << 8;\n        case 9:\n          b += (value[offset + 8] & 0xffL);\n        case 8:\n          a += word64At(value, offset);\n          break;\n        case 7:\n          a += (value[offset + 6] & 0xffL) << 48;\n        case 6:\n          a += (value[offset + 5] & 0xffL) << 40;\n        case 5:\n          a += (value[offset + 4] & 0xffL) << 32;\n        case 4:\na -= (value[(offset + 3)] & 255L);\n        case 3:\n          a += (value[offset + 2] & 0xffL) << 16;\n        case 2:\n          a += (value[offset + 1] & 0xffL) << 8;\n        case 1:\n          a += (value[offset + 0] & 0xffL);\n          // case 0: nothing left to add\n      }\n      return mix64(a, b, c);\n    }",
          "41": "    private static long hash64(\n        byte[] value, int offset, int length, long seed) {\n      long a = CONSTANT64;\n      long b = a;\n      long c = seed;\n      int keylen;\n\n      for (keylen = length; keylen >= 24; keylen -= 24, offset += 24) {\n        a += word64At(value, offset);\n        b += word64At(value, offset + 8);\n        c += word64At(value, offset + 16);\n\n        // Mix\n        a -= b; a -= c; a ^= c >>> 43;\n        b -= c; b -= a; b ^= a << 9;\n        c -= a; c -= b; c ^= b >>> 8;\n        a -= b; a -= c; a ^= c >>> 38;\n        b -= c; b -= a; b ^= a << 23;\n        c -= a; c -= b; c ^= b >>> 5;\n        a -= b; a -= c; a ^= c >>> 35;\n        b -= c; b -= a; b ^= a << 49;\n        c -= a; c -= b; c ^= b >>> 11;\n        a -= b; a -= c; a ^= c >>> 12;\n        b -= c; b -= a; b ^= a << 18;\n        c -= a; c -= b; c ^= b >>> 22;\n      }\n\n      c += length;\n      switch (keylen) { // deal with rest. Cases fall through\n        case 23:\n          c += ((long) value[offset + 22]) << 56;\n        case 22:\n          c += (value[offset + 21] & 0xffL) << 48;\n        case 21:\n          c += (value[offset + 20] & 0xffL) << 40;\n        case 20:\n          c += (value[offset + 19] & 0xffL) << 32;\n        case 19:\n          c += (value[offset + 18] & 0xffL) << 24;\n        case 18:\n          c += (value[offset + 17] & 0xffL) << 16;\n        case 17:\n          c += (value[offset + 16] & 0xffL) << 8;\n          // the first byte of c is reserved for the length\n        case 16:\n          b += word64At(value, offset + 8);\n          a += word64At(value, offset);\n          break;\n        case 15:\n          b += (value[offset + 14] & 0xffL) << 48;\n        case 14:\n          b += (value[offset + 13] & 0xffL) << 40;\n        case 13:\n          b += (value[offset + 12] & 0xffL) << 32;\n        case 12:\n          b += (value[offset + 11] & 0xffL) << 24;\n        case 11:\n          b += (value[offset + 10] & 0xffL) << 16;\n        case 10:\n          b += (value[offset + 9] & 0xffL) << 8;\n        case 9:\n          b += (value[offset + 8] & 0xffL);\n        case 8:\n          a += word64At(value, offset);\n          break;\n        case 7:\n          a += (value[offset + 6] & 0xffL) << 48;\n        case 6:\n          a += (value[offset + 5] & 0xffL) << 40;\n        case 5:\n          a += (value[offset + 4] & 0xffL) << 32;\n        case 4:\na += value;\n        case 3:\n          a += (value[offset + 2] & 0xffL) << 16;\n        case 2:\n          a += (value[offset + 1] & 0xffL) << 8;\n        case 1:\n          a += (value[offset + 0] & 0xffL);\n          // case 0: nothing left to add\n      }\n      return mix64(a, b, c);\n    }",
          "42": "    private static long hash64(\n        byte[] value, int offset, int length, long seed) {\n      long a = CONSTANT64;\n      long b = a;\n      long c = seed;\n      int keylen;\n\n      for (keylen = length; keylen >= 24; keylen -= 24, offset += 24) {\n        a += word64At(value, offset);\n        b += word64At(value, offset + 8);\n        c += word64At(value, offset + 16);\n\n        // Mix\n        a -= b; a -= c; a ^= c >>> 43;\n        b -= c; b -= a; b ^= a << 9;\n        c -= a; c -= b; c ^= b >>> 8;\n        a -= b; a -= c; a ^= c >>> 38;\n        b -= c; b -= a; b ^= a << 23;\n        c -= a; c -= b; c ^= b >>> 5;\n        a -= b; a -= c; a ^= c >>> 35;\n        b -= c; b -= a; b ^= a << 49;\n        c -= a; c -= b; c ^= b >>> 11;\n        a -= b; a -= c; a ^= c >>> 12;\n        b -= c; b -= a; b ^= a << 18;\n        c -= a; c -= b; c ^= b >>> 22;\n      }\n\n      c += length;\n      switch (keylen) { // deal with rest. Cases fall through\n        case 23:\n          c += ((long) value[offset + 22]) << 56;\n        case 22:\n          c += (value[offset + 21] & 0xffL) << 48;\n        case 21:\n          c += (value[offset + 20] & 0xffL) << 40;\n        case 20:\n          c += (value[offset + 19] & 0xffL) << 32;\n        case 19:\n          c += (value[offset + 18] & 0xffL) << 24;\n        case 18:\n          c += (value[offset + 17] & 0xffL) << 16;\n        case 17:\n          c += (value[offset + 16] & 0xffL) << 8;\n          // the first byte of c is reserved for the length\n        case 16:\n          b += word64At(value, offset + 8);\n          a += word64At(value, offset);\n          break;\n        case 15:\n          b += (value[offset + 14] & 0xffL) << 48;\n        case 14:\n          b += (value[offset + 13] & 0xffL) << 40;\n        case 13:\n          b += (value[offset + 12] & 0xffL) << 32;\n        case 12:\n          b += (value[offset + 11] & 0xffL) << 24;\n        case 11:\n          b += (value[offset + 10] & 0xffL) << 16;\n        case 10:\n          b += (value[offset + 9] & 0xffL) << 8;\n        case 9:\n          b += (value[offset + 8] & 0xffL);\n        case 8:\n          a += word64At(value, offset);\n          break;\n        case 7:\n          a += (value[offset + 6] & 0xffL) << 48;\n        case 6:\n          a += (value[offset + 5] & 0xffL) << 40;\n        case 5:\n          a += (value[offset + 4] & 0xffL) << 32;\n        case 4:\na += ((value[(offset + 2)] & 255L) >>> 24);\n        case 3:\n          a += (value[offset + 2] & 0xffL) << 16;\n        case 2:\n          a += (value[offset + 1] & 0xffL) << 8;\n        case 1:\n          a += (value[offset + 0] & 0xffL);\n          // case 0: nothing left to add\n      }\n      return mix64(a, b, c);\n    }",
          "43": "    private static long hash64(\n        byte[] value, int offset, int length, long seed) {\n      long a = CONSTANT64;\n      long b = a;\n      long c = seed;\n      int keylen;\n\n      for (keylen = length; keylen >= 24; keylen -= 24, offset += 24) {\n        a += word64At(value, offset);\n        b += word64At(value, offset + 8);\n        c += word64At(value, offset + 16);\n\n        // Mix\n        a -= b; a -= c; a ^= c >>> 43;\n        b -= c; b -= a; b ^= a << 9;\n        c -= a; c -= b; c ^= b >>> 8;\n        a -= b; a -= c; a ^= c >>> 38;\n        b -= c; b -= a; b ^= a << 23;\n        c -= a; c -= b; c ^= b >>> 5;\n        a -= b; a -= c; a ^= c >>> 35;\n        b -= c; b -= a; b ^= a << 49;\n        c -= a; c -= b; c ^= b >>> 11;\n        a -= b; a -= c; a ^= c >>> 12;\n        b -= c; b -= a; b ^= a << 18;\n        c -= a; c -= b; c ^= b >>> 22;\n      }\n\n      c += length;\n      switch (keylen) { // deal with rest. Cases fall through\n        case 23:\n          c += ((long) value[offset + 22]) << 56;\n        case 22:\n          c += (value[offset + 21] & 0xffL) << 48;\n        case 21:\n          c += (value[offset + 20] & 0xffL) << 40;\n        case 20:\n          c += (value[offset + 19] & 0xffL) << 32;\n        case 19:\n          c += (value[offset + 18] & 0xffL) << 24;\n        case 18:\n          c += (value[offset + 17] & 0xffL) << 16;\n        case 17:\n          c += (value[offset + 16] & 0xffL) << 8;\n          // the first byte of c is reserved for the length\n        case 16:\n          b += word64At(value, offset + 8);\n          a += word64At(value, offset);\n          break;\n        case 15:\n          b += (value[offset + 14] & 0xffL) << 48;\n        case 14:\n          b += (value[offset + 13] & 0xffL) << 40;\n        case 13:\n          b += (value[offset + 12] & 0xffL) << 32;\n        case 12:\n          b += (value[offset + 11] & 0xffL) << 24;\n        case 11:\n          b += (value[offset + 10] & 0xffL) << 16;\n        case 10:\n          b += (value[offset + 9] & 0xffL) << 8;\n        case 9:\n          b += (value[offset + 8] & 0xffL);\n        case 8:\n          a += word64At(value, offset);\n          break;\n        case 7:\n          a += (value[offset + 6] & 0xffL) << 48;\n        case 6:\n          a += (value[offset + 5] & 0xffL) << 40;\n        case 5:\n          a += (value[offset + 4] & 0xffL) << 32;\n        case 4:\na += ((value[(offset + 32)] & 255L) >>> 24);\n        case 3:\n          a += (value[offset + 2] & 0xffL) << 16;\n        case 2:\n          a += (value[offset + 1] & 0xffL) << 8;\n        case 1:\n          a += (value[offset + 0] & 0xffL);\n          // case 0: nothing left to add\n      }\n      return mix64(a, b, c);\n    }",
          "44": "    private static long hash64(\n        byte[] value, int offset, int length, long seed) {\n      long a = CONSTANT64;\n      long b = a;\n      long c = seed;\n      int keylen;\n\n      for (keylen = length; keylen >= 24; keylen -= 24, offset += 24) {\n        a += word64At(value, offset);\n        b += word64At(value, offset + 8);\n        c += word64At(value, offset + 16);\n\n        // Mix\n        a -= b; a -= c; a ^= c >>> 43;\n        b -= c; b -= a; b ^= a << 9;\n        c -= a; c -= b; c ^= b >>> 8;\n        a -= b; a -= c; a ^= c >>> 38;\n        b -= c; b -= a; b ^= a << 23;\n        c -= a; c -= b; c ^= b >>> 5;\n        a -= b; a -= c; a ^= c >>> 35;\n        b -= c; b -= a; b ^= a << 49;\n        c -= a; c -= b; c ^= b >>> 11;\n        a -= b; a -= c; a ^= c >>> 12;\n        b -= c; b -= a; b ^= a << 18;\n        c -= a; c -= b; c ^= b >>> 22;\n      }\n\n      c += length;\n      switch (keylen) { // deal with rest. Cases fall through\n        case 23:\n          c += ((long) value[offset + 22]) << 56;\n        case 22:\n          c += (value[offset + 21] & 0xffL) << 48;\n        case 21:\n          c += (value[offset + 20] & 0xffL) << 40;\n        case 20:\n          c += (value[offset + 19] & 0xffL) << 32;\n        case 19:\n          c += (value[offset + 18] & 0xffL) << 24;\n        case 18:\n          c += (value[offset + 17] & 0xffL) << 16;\n        case 17:\n          c += (value[offset + 16] & 0xffL) << 8;\n          // the first byte of c is reserved for the length\n        case 16:\n          b += word64At(value, offset + 8);\n          a += word64At(value, offset);\n          break;\n        case 15:\n          b += (value[offset + 14] & 0xffL) << 48;\n        case 14:\n          b += (value[offset + 13] & 0xffL) << 40;\n        case 13:\n          b += (value[offset + 12] & 0xffL) << 32;\n        case 12:\n          b += (value[offset + 11] & 0xffL) << 24;\n        case 11:\n          b += (value[offset + 10] & 0xffL) << 16;\n        case 10:\n          b += (value[offset + 9] & 0xffL) << 8;\n        case 9:\n          b += (value[offset + 8] & 0xffL);\n        case 8:\n          a += word64At(value, offset);\n          break;\n        case 7:\n          a += (value[offset + 6] & 0xffL) << 48;\n        case 6:\n          a += (value[offset + 5] & 0xffL) << 40;\n        case 5:\n          a += (value[offset + 4] & 0xffL) << 32;\n        case 4:\na += ((value[(offset + 3)] & 255L) + value);\n        case 3:\n          a += (value[offset + 2] & 0xffL) << 16;\n        case 2:\n          a += (value[offset + 1] & 0xffL) << 8;\n        case 1:\n          a += (value[offset + 0] & 0xffL);\n          // case 0: nothing left to add\n      }\n      return mix64(a, b, c);\n    }",
          "45": "    private static long hash64(\n        byte[] value, int offset, int length, long seed) {\n      long a = CONSTANT64;\n      long b = a;\n      long c = seed;\n      int keylen;\n\n      for (keylen = length; keylen >= 24; keylen -= 24, offset += 24) {\n        a += word64At(value, offset);\n        b += word64At(value, offset + 8);\n        c += word64At(value, offset + 16);\n\n        // Mix\n        a -= b; a -= c; a ^= c >>> 43;\n        b -= c; b -= a; b ^= a << 9;\n        c -= a; c -= b; c ^= b >>> 8;\n        a -= b; a -= c; a ^= c >>> 38;\n        b -= c; b -= a; b ^= a << 23;\n        c -= a; c -= b; c ^= b >>> 5;\n        a -= b; a -= c; a ^= c >>> 35;\n        b -= c; b -= a; b ^= a << 49;\n        c -= a; c -= b; c ^= b >>> 11;\n        a -= b; a -= c; a ^= c >>> 12;\n        b -= c; b -= a; b ^= a << 18;\n        c -= a; c -= b; c ^= b >>> 22;\n      }\n\n      c += length;\n      switch (keylen) { // deal with rest. Cases fall through\n        case 23:\n          c += ((long) value[offset + 22]) << 56;\n        case 22:\n          c += (value[offset + 21] & 0xffL) << 48;\n        case 21:\n          c += (value[offset + 20] & 0xffL) << 40;\n        case 20:\n          c += (value[offset + 19] & 0xffL) << 32;\n        case 19:\n          c += (value[offset + 18] & 0xffL) << 24;\n        case 18:\n          c += (value[offset + 17] & 0xffL) << 16;\n        case 17:\n          c += (value[offset + 16] & 0xffL) << 8;\n          // the first byte of c is reserved for the length\n        case 16:\n          b += word64At(value, offset + 8);\n          a += word64At(value, offset);\n          break;\n        case 15:\n          b += (value[offset + 14] & 0xffL) << 48;\n        case 14:\n          b += (value[offset + 13] & 0xffL) << 40;\n        case 13:\n          b += (value[offset + 12] & 0xffL) << 32;\n        case 12:\n          b += (value[offset + 11] & 0xffL) << 24;\n        case 11:\n          b += (value[offset + 10] & 0xffL) << 16;\n        case 10:\n          b += (value[offset + 9] & 0xffL) << 8;\n        case 9:\n          b += (value[offset + 8] & 0xffL);\n        case 8:\n          a += word64At(value, offset);\n          break;\n        case 7:\n          a += (value[offset + 6] & 0xffL) << 48;\n        case 6:\n          a += (value[offset + 5] & 0xffL) << 40;\n        case 5:\n          a += (value[offset + 4] & 0xffL) << 32;\n        case 4:\na -= ((value[(offset + 3)] & 255L) >>> 24);\n        case 3:\n          a += (value[offset + 2] & 0xffL) << 16;\n        case 2:\n          a += (value[offset + 1] & 0xffL) << 8;\n        case 1:\n          a += (value[offset + 0] & 0xffL);\n          // case 0: nothing left to add\n      }\n      return mix64(a, b, c);\n    }",
          "46": "    private static long hash64(\n        byte[] value, int offset, int length, long seed) {\n      long a = CONSTANT64;\n      long b = a;\n      long c = seed;\n      int keylen;\n\n      for (keylen = length; keylen >= 24; keylen -= 24, offset += 24) {\n        a += word64At(value, offset);\n        b += word64At(value, offset + 8);\n        c += word64At(value, offset + 16);\n\n        // Mix\n        a -= b; a -= c; a ^= c >>> 43;\n        b -= c; b -= a; b ^= a << 9;\n        c -= a; c -= b; c ^= b >>> 8;\n        a -= b; a -= c; a ^= c >>> 38;\n        b -= c; b -= a; b ^= a << 23;\n        c -= a; c -= b; c ^= b >>> 5;\n        a -= b; a -= c; a ^= c >>> 35;\n        b -= c; b -= a; b ^= a << 49;\n        c -= a; c -= b; c ^= b >>> 11;\n        a -= b; a -= c; a ^= c >>> 12;\n        b -= c; b -= a; b ^= a << 18;\n        c -= a; c -= b; c ^= b >>> 22;\n      }\n\n      c += length;\n      switch (keylen) { // deal with rest. Cases fall through\n        case 23:\n          c += ((long) value[offset + 22]) << 56;\n        case 22:\n          c += (value[offset + 21] & 0xffL) << 48;\n        case 21:\n          c += (value[offset + 20] & 0xffL) << 40;\n        case 20:\n          c += (value[offset + 19] & 0xffL) << 32;\n        case 19:\n          c += (value[offset + 18] & 0xffL) << 24;\n        case 18:\n          c += (value[offset + 17] & 0xffL) << 16;\n        case 17:\n          c += (value[offset + 16] & 0xffL) << 8;\n          // the first byte of c is reserved for the length\n        case 16:\n          b += word64At(value, offset + 8);\n          a += word64At(value, offset);\n          break;\n        case 15:\n          b += (value[offset + 14] & 0xffL) << 48;\n        case 14:\n          b += (value[offset + 13] & 0xffL) << 40;\n        case 13:\n          b += (value[offset + 12] & 0xffL) << 32;\n        case 12:\n          b += (value[offset + 11] & 0xffL) << 24;\n        case 11:\n          b += (value[offset + 10] & 0xffL) << 16;\n        case 10:\n          b += (value[offset + 9] & 0xffL) << 8;\n        case 9:\n          b += (value[offset + 8] & 0xffL);\n        case 8:\n          a += word64At(value, offset);\n          break;\n        case 7:\n          a += (value[offset + 6] & 0xffL) << 48;\n        case 6:\n          a += (value[offset + 5] & 0xffL) << 40;\n        case 5:\n          a += (value[offset + 4] & 0xffL) << 32;\n        case 4:\na += ((value[(offset + 3)] & 255L) - 24);\n        case 3:\n          a += (value[offset + 2] & 0xffL) << 16;\n        case 2:\n          a += (value[offset + 1] & 0xffL) << 8;\n        case 1:\n          a += (value[offset + 0] & 0xffL);\n          // case 0: nothing left to add\n      }\n      return mix64(a, b, c);\n    }",
          "47": "    private static long hash64(\n        byte[] value, int offset, int length, long seed) {\n      long a = CONSTANT64;\n      long b = a;\n      long c = seed;\n      int keylen;\n\n      for (keylen = length; keylen >= 24; keylen -= 24, offset += 24) {\n        a += word64At(value, offset);\n        b += word64At(value, offset + 8);\n        c += word64At(value, offset + 16);\n\n        // Mix\n        a -= b; a -= c; a ^= c >>> 43;\n        b -= c; b -= a; b ^= a << 9;\n        c -= a; c -= b; c ^= b >>> 8;\n        a -= b; a -= c; a ^= c >>> 38;\n        b -= c; b -= a; b ^= a << 23;\n        c -= a; c -= b; c ^= b >>> 5;\n        a -= b; a -= c; a ^= c >>> 35;\n        b -= c; b -= a; b ^= a << 49;\n        c -= a; c -= b; c ^= b >>> 11;\n        a -= b; a -= c; a ^= c >>> 12;\n        b -= c; b -= a; b ^= a << 18;\n        c -= a; c -= b; c ^= b >>> 22;\n      }\n\n      c += length;\n      switch (keylen) { // deal with rest. Cases fall through\n        case 23:\n          c += ((long) value[offset + 22]) << 56;\n        case 22:\n          c += (value[offset + 21] & 0xffL) << 48;\n        case 21:\n          c += (value[offset + 20] & 0xffL) << 40;\n        case 20:\n          c += (value[offset + 19] & 0xffL) << 32;\n        case 19:\n          c += (value[offset + 18] & 0xffL) << 24;\n        case 18:\n          c += (value[offset + 17] & 0xffL) << 16;\n        case 17:\n          c += (value[offset + 16] & 0xffL) << 8;\n          // the first byte of c is reserved for the length\n        case 16:\n          b += word64At(value, offset + 8);\n          a += word64At(value, offset);\n          break;\n        case 15:\n          b += (value[offset + 14] & 0xffL) << 48;\n        case 14:\n          b += (value[offset + 13] & 0xffL) << 40;\n        case 13:\n          b += (value[offset + 12] & 0xffL) << 32;\n        case 12:\n          b += (value[offset + 11] & 0xffL) << 24;\n        case 11:\n          b += (value[offset + 10] & 0xffL) << 16;\n        case 10:\n          b += (value[offset + 9] & 0xffL) << 8;\n        case 9:\n          b += (value[offset + 8] & 0xffL);\n        case 8:\n          a += word64At(value, offset);\n          break;\n        case 7:\n          a += (value[offset + 6] & 0xffL) << 48;\n        case 6:\n          a += (value[offset + 5] & 0xffL) << 40;\n        case 5:\n          a += (value[offset + 4] & 0xffL) << 32;\n        case 4:\nvalue[(offset + 3)];\n        case 3:\n          a += (value[offset + 2] & 0xffL) << 16;\n        case 2:\n          a += (value[offset + 1] & 0xffL) << 8;\n        case 1:\n          a += (value[offset + 0] & 0xffL);\n          // case 0: nothing left to add\n      }\n      return mix64(a, b, c);\n    }",
          "48": "    private static long hash64(\n        byte[] value, int offset, int length, long seed) {\n      long a = CONSTANT64;\n      long b = a;\n      long c = seed;\n      int keylen;\n\n      for (keylen = length; keylen >= 24; keylen -= 24, offset += 24) {\n        a += word64At(value, offset);\n        b += word64At(value, offset + 8);\n        c += word64At(value, offset + 16);\n\n        // Mix\n        a -= b; a -= c; a ^= c >>> 43;\n        b -= c; b -= a; b ^= a << 9;\n        c -= a; c -= b; c ^= b >>> 8;\n        a -= b; a -= c; a ^= c >>> 38;\n        b -= c; b -= a; b ^= a << 23;\n        c -= a; c -= b; c ^= b >>> 5;\n        a -= b; a -= c; a ^= c >>> 35;\n        b -= c; b -= a; b ^= a << 49;\n        c -= a; c -= b; c ^= b >>> 11;\n        a -= b; a -= c; a ^= c >>> 12;\n        b -= c; b -= a; b ^= a << 18;\n        c -= a; c -= b; c ^= b >>> 22;\n      }\n\n      c += length;\n      switch (keylen) { // deal with rest. Cases fall through\n        case 23:\n          c += ((long) value[offset + 22]) << 56;\n        case 22:\n          c += (value[offset + 21] & 0xffL) << 48;\n        case 21:\n          c += (value[offset + 20] & 0xffL) << 40;\n        case 20:\n          c += (value[offset + 19] & 0xffL) << 32;\n        case 19:\n          c += (value[offset + 18] & 0xffL) << 24;\n        case 18:\n          c += (value[offset + 17] & 0xffL) << 16;\n        case 17:\n          c += (value[offset + 16] & 0xffL) << 8;\n          // the first byte of c is reserved for the length\n        case 16:\n          b += word64At(value, offset + 8);\n          a += word64At(value, offset);\n          break;\n        case 15:\n          b += (value[offset + 14] & 0xffL) << 48;\n        case 14:\n          b += (value[offset + 13] & 0xffL) << 40;\n        case 13:\n          b += (value[offset + 12] & 0xffL) << 32;\n        case 12:\n          b += (value[offset + 11] & 0xffL) << 24;\n        case 11:\n          b += (value[offset + 10] & 0xffL) << 16;\n        case 10:\n          b += (value[offset + 9] & 0xffL) << 8;\n        case 9:\n          b += (value[offset + 8] & 0xffL);\n        case 8:\n          a += word64At(value, offset);\n          break;\n        case 7:\n          a += (value[offset + 6] & 0xffL) << 48;\n        case 6:\n          a += (value[offset + 5] & 0xffL) << 40;\n        case 5:\n          a += (value[offset + 4] & 0xffL) << 32;\n        case 4:\na += ((offset[(offset + 4)] & 255L) >>> 24);\n        case 3:\n          a += (value[offset + 2] & 0xffL) << 16;\n        case 2:\n          a += (value[offset + 1] & 0xffL) << 8;\n        case 1:\n          a += (value[offset + 0] & 0xffL);\n          // case 0: nothing left to add\n      }\n      return mix64(a, b, c);\n    }",
          "49": "    private static long hash64(\n        byte[] value, int offset, int length, long seed) {\n      long a = CONSTANT64;\n      long b = a;\n      long c = seed;\n      int keylen;\n\n      for (keylen = length; keylen >= 24; keylen -= 24, offset += 24) {\n        a += word64At(value, offset);\n        b += word64At(value, offset + 8);\n        c += word64At(value, offset + 16);\n\n        // Mix\n        a -= b; a -= c; a ^= c >>> 43;\n        b -= c; b -= a; b ^= a << 9;\n        c -= a; c -= b; c ^= b >>> 8;\n        a -= b; a -= c; a ^= c >>> 38;\n        b -= c; b -= a; b ^= a << 23;\n        c -= a; c -= b; c ^= b >>> 5;\n        a -= b; a -= c; a ^= c >>> 35;\n        b -= c; b -= a; b ^= a << 49;\n        c -= a; c -= b; c ^= b >>> 11;\n        a -= b; a -= c; a ^= c >>> 12;\n        b -= c; b -= a; b ^= a << 18;\n        c -= a; c -= b; c ^= b >>> 22;\n      }\n\n      c += length;\n      switch (keylen) { // deal with rest. Cases fall through\n        case 23:\n          c += ((long) value[offset + 22]) << 56;\n        case 22:\n          c += (value[offset + 21] & 0xffL) << 48;\n        case 21:\n          c += (value[offset + 20] & 0xffL) << 40;\n        case 20:\n          c += (value[offset + 19] & 0xffL) << 32;\n        case 19:\n          c += (value[offset + 18] & 0xffL) << 24;\n        case 18:\n          c += (value[offset + 17] & 0xffL) << 16;\n        case 17:\n          c += (value[offset + 16] & 0xffL) << 8;\n          // the first byte of c is reserved for the length\n        case 16:\n          b += word64At(value, offset + 8);\n          a += word64At(value, offset);\n          break;\n        case 15:\n          b += (value[offset + 14] & 0xffL) << 48;\n        case 14:\n          b += (value[offset + 13] & 0xffL) << 40;\n        case 13:\n          b += (value[offset + 12] & 0xffL) << 32;\n        case 12:\n          b += (value[offset + 11] & 0xffL) << 24;\n        case 11:\n          b += (value[offset + 10] & 0xffL) << 16;\n        case 10:\n          b += (value[offset + 9] & 0xffL) << 8;\n        case 9:\n          b += (value[offset + 8] & 0xffL);\n        case 8:\n          a += word64At(value, offset);\n          break;\n        case 7:\n          a += (value[offset + 6] & 0xffL) << 48;\n        case 6:\n          a += (value[offset + 5] & 0xffL) << 40;\n        case 5:\n          a += (value[offset + 4] & 0xffL) << 32;\n        case 4:\na += (((value[(offset + 3)] & 255L) >>> 24) + 1);\n        case 3:\n          a += (value[offset + 2] & 0xffL) << 16;\n        case 2:\n          a += (value[offset + 1] & 0xffL) << 8;\n        case 1:\n          a += (value[offset + 0] & 0xffL);\n          // case 0: nothing left to add\n      }\n      return mix64(a, b, c);\n    }",
          "50": "    private static long hash64(\n        byte[] value, int offset, int length, long seed) {\n      long a = CONSTANT64;\n      long b = a;\n      long c = seed;\n      int keylen;\n\n      for (keylen = length; keylen >= 24; keylen -= 24, offset += 24) {\n        a += word64At(value, offset);\n        b += word64At(value, offset + 8);\n        c += word64At(value, offset + 16);\n\n        // Mix\n        a -= b; a -= c; a ^= c >>> 43;\n        b -= c; b -= a; b ^= a << 9;\n        c -= a; c -= b; c ^= b >>> 8;\n        a -= b; a -= c; a ^= c >>> 38;\n        b -= c; b -= a; b ^= a << 23;\n        c -= a; c -= b; c ^= b >>> 5;\n        a -= b; a -= c; a ^= c >>> 35;\n        b -= c; b -= a; b ^= a << 49;\n        c -= a; c -= b; c ^= b >>> 11;\n        a -= b; a -= c; a ^= c >>> 12;\n        b -= c; b -= a; b ^= a << 18;\n        c -= a; c -= b; c ^= b >>> 22;\n      }\n\n      c += length;\n      switch (keylen) { // deal with rest. Cases fall through\n        case 23:\n          c += ((long) value[offset + 22]) << 56;\n        case 22:\n          c += (value[offset + 21] & 0xffL) << 48;\n        case 21:\n          c += (value[offset + 20] & 0xffL) << 40;\n        case 20:\n          c += (value[offset + 19] & 0xffL) << 32;\n        case 19:\n          c += (value[offset + 18] & 0xffL) << 24;\n        case 18:\n          c += (value[offset + 17] & 0xffL) << 16;\n        case 17:\n          c += (value[offset + 16] & 0xffL) << 8;\n          // the first byte of c is reserved for the length\n        case 16:\n          b += word64At(value, offset + 8);\n          a += word64At(value, offset);\n          break;\n        case 15:\n          b += (value[offset + 14] & 0xffL) << 48;\n        case 14:\n          b += (value[offset + 13] & 0xffL) << 40;\n        case 13:\n          b += (value[offset + 12] & 0xffL) << 32;\n        case 12:\n          b += (value[offset + 11] & 0xffL) << 24;\n        case 11:\n          b += (value[offset + 10] & 0xffL) << 16;\n        case 10:\n          b += (value[offset + 9] & 0xffL) << 8;\n        case 9:\n          b += (value[offset + 8] & 0xffL);\n        case 8:\n          a += word64At(value, offset);\n          break;\n        case 7:\n          a += (value[offset + 6] & 0xffL) << 48;\n        case 6:\n          a += (value[offset + 5] & 0xffL) << 40;\n        case 5:\n          a += (value[offset + 4] & 0xffL) << 32;\n        case 4:\na += ((value[(offset + 3)] & null) >>> 24);\n        case 3:\n          a += (value[offset + 2] & 0xffL) << 16;\n        case 2:\n          a += (value[offset + 1] & 0xffL) << 8;\n        case 1:\n          a += (value[offset + 0] & 0xffL);\n          // case 0: nothing left to add\n      }\n      return mix64(a, b, c);\n    }",
          "51": "    private static long hash64(\n        byte[] value, int offset, int length, long seed) {\n      long a = CONSTANT64;\n      long b = a;\n      long c = seed;\n      int keylen;\n\n      for (keylen = length; keylen >= 24; keylen -= 24, offset += 24) {\n        a += word64At(value, offset);\n        b += word64At(value, offset + 8);\n        c += word64At(value, offset + 16);\n\n        // Mix\n        a -= b; a -= c; a ^= c >>> 43;\n        b -= c; b -= a; b ^= a << 9;\n        c -= a; c -= b; c ^= b >>> 8;\n        a -= b; a -= c; a ^= c >>> 38;\n        b -= c; b -= a; b ^= a << 23;\n        c -= a; c -= b; c ^= b >>> 5;\n        a -= b; a -= c; a ^= c >>> 35;\n        b -= c; b -= a; b ^= a << 49;\n        c -= a; c -= b; c ^= b >>> 11;\n        a -= b; a -= c; a ^= c >>> 12;\n        b -= c; b -= a; b ^= a << 18;\n        c -= a; c -= b; c ^= b >>> 22;\n      }\n\n      c += length;\n      switch (keylen) { // deal with rest. Cases fall through\n        case 23:\n          c += ((long) value[offset + 22]) << 56;\n        case 22:\n          c += (value[offset + 21] & 0xffL) << 48;\n        case 21:\n          c += (value[offset + 20] & 0xffL) << 40;\n        case 20:\n          c += (value[offset + 19] & 0xffL) << 32;\n        case 19:\n          c += (value[offset + 18] & 0xffL) << 24;\n        case 18:\n          c += (value[offset + 17] & 0xffL) << 16;\n        case 17:\n          c += (value[offset + 16] & 0xffL) << 8;\n          // the first byte of c is reserved for the length\n        case 16:\n          b += word64At(value, offset + 8);\n          a += word64At(value, offset);\n          break;\n        case 15:\n          b += (value[offset + 14] & 0xffL) << 48;\n        case 14:\n          b += (value[offset + 13] & 0xffL) << 40;\n        case 13:\n          b += (value[offset + 12] & 0xffL) << 32;\n        case 12:\n          b += (value[offset + 11] & 0xffL) << 24;\n        case 11:\n          b += (value[offset + 10] & 0xffL) << 16;\n        case 10:\n          b += (value[offset + 9] & 0xffL) << 8;\n        case 9:\n          b += (value[offset + 8] & 0xffL);\n        case 8:\n          a += word64At(value, offset);\n          break;\n        case 7:\n          a += (value[offset + 6] & 0xffL) << 48;\n        case 6:\n          a += (value[offset + 5] & 0xffL) << 40;\n        case 5:\n          a += (value[offset + 4] & 0xffL) << 32;\n        case 4:\nvalue += ((value[(offset + 3)] & 255L) >>> 24);\n        case 3:\n          a += (value[offset + 2] & 0xffL) << 16;\n        case 2:\n          a += (value[offset + 1] & 0xffL) << 8;\n        case 1:\n          a += (value[offset + 0] & 0xffL);\n          // case 0: nothing left to add\n      }\n      return mix64(a, b, c);\n    }",
          "52": "    private static long hash64(\n        byte[] value, int offset, int length, long seed) {\n      long a = CONSTANT64;\n      long b = a;\n      long c = seed;\n      int keylen;\n\n      for (keylen = length; keylen >= 24; keylen -= 24, offset += 24) {\n        a += word64At(value, offset);\n        b += word64At(value, offset + 8);\n        c += word64At(value, offset + 16);\n\n        // Mix\n        a -= b; a -= c; a ^= c >>> 43;\n        b -= c; b -= a; b ^= a << 9;\n        c -= a; c -= b; c ^= b >>> 8;\n        a -= b; a -= c; a ^= c >>> 38;\n        b -= c; b -= a; b ^= a << 23;\n        c -= a; c -= b; c ^= b >>> 5;\n        a -= b; a -= c; a ^= c >>> 35;\n        b -= c; b -= a; b ^= a << 49;\n        c -= a; c -= b; c ^= b >>> 11;\n        a -= b; a -= c; a ^= c >>> 12;\n        b -= c; b -= a; b ^= a << 18;\n        c -= a; c -= b; c ^= b >>> 22;\n      }\n\n      c += length;\n      switch (keylen) { // deal with rest. Cases fall through\n        case 23:\n          c += ((long) value[offset + 22]) << 56;\n        case 22:\n          c += (value[offset + 21] & 0xffL) << 48;\n        case 21:\n          c += (value[offset + 20] & 0xffL) << 40;\n        case 20:\n          c += (value[offset + 19] & 0xffL) << 32;\n        case 19:\n          c += (value[offset + 18] & 0xffL) << 24;\n        case 18:\n          c += (value[offset + 17] & 0xffL) << 16;\n        case 17:\n          c += (value[offset + 16] & 0xffL) << 8;\n          // the first byte of c is reserved for the length\n        case 16:\n          b += word64At(value, offset + 8);\n          a += word64At(value, offset);\n          break;\n        case 15:\n          b += (value[offset + 14] & 0xffL) << 48;\n        case 14:\n          b += (value[offset + 13] & 0xffL) << 40;\n        case 13:\n          b += (value[offset + 12] & 0xffL) << 32;\n        case 12:\n          b += (value[offset + 11] & 0xffL) << 24;\n        case 11:\n          b += (value[offset + 10] & 0xffL) << 16;\n        case 10:\n          b += (value[offset + 9] & 0xffL) << 8;\n        case 9:\n          b += (value[offset + 8] & 0xffL);\n        case 8:\n          a += word64At(value, offset);\n          break;\n        case 7:\n          a += (value[offset + 6] & 0xffL) << 48;\n        case 6:\n          a += (value[offset + 5] & 0xffL) << 40;\n        case 5:\n          a += (value[offset + 4] & 0xffL) << 32;\n        case 4:\na += ((a[(offset + 4)] & 255L) >>> 24);\n        case 3:\n          a += (value[offset + 2] & 0xffL) << 16;\n        case 2:\n          a += (value[offset + 1] & 0xffL) << 8;\n        case 1:\n          a += (value[offset + 0] & 0xffL);\n          // case 0: nothing left to add\n      }\n      return mix64(a, b, c);\n    }",
          "53": "    private static long hash64(\n        byte[] value, int offset, int length, long seed) {\n      long a = CONSTANT64;\n      long b = a;\n      long c = seed;\n      int keylen;\n\n      for (keylen = length; keylen >= 24; keylen -= 24, offset += 24) {\n        a += word64At(value, offset);\n        b += word64At(value, offset + 8);\n        c += word64At(value, offset + 16);\n\n        // Mix\n        a -= b; a -= c; a ^= c >>> 43;\n        b -= c; b -= a; b ^= a << 9;\n        c -= a; c -= b; c ^= b >>> 8;\n        a -= b; a -= c; a ^= c >>> 38;\n        b -= c; b -= a; b ^= a << 23;\n        c -= a; c -= b; c ^= b >>> 5;\n        a -= b; a -= c; a ^= c >>> 35;\n        b -= c; b -= a; b ^= a << 49;\n        c -= a; c -= b; c ^= b >>> 11;\n        a -= b; a -= c; a ^= c >>> 12;\n        b -= c; b -= a; b ^= a << 18;\n        c -= a; c -= b; c ^= b >>> 22;\n      }\n\n      c += length;\n      switch (keylen) { // deal with rest. Cases fall through\n        case 23:\n          c += ((long) value[offset + 22]) << 56;\n        case 22:\n          c += (value[offset + 21] & 0xffL) << 48;\n        case 21:\n          c += (value[offset + 20] & 0xffL) << 40;\n        case 20:\n          c += (value[offset + 19] & 0xffL) << 32;\n        case 19:\n          c += (value[offset + 18] & 0xffL) << 24;\n        case 18:\n          c += (value[offset + 17] & 0xffL) << 16;\n        case 17:\n          c += (value[offset + 16] & 0xffL) << 8;\n          // the first byte of c is reserved for the length\n        case 16:\n          b += word64At(value, offset + 8);\n          a += word64At(value, offset);\n          break;\n        case 15:\n          b += (value[offset + 14] & 0xffL) << 48;\n        case 14:\n          b += (value[offset + 13] & 0xffL) << 40;\n        case 13:\n          b += (value[offset + 12] & 0xffL) << 32;\n        case 12:\n          b += (value[offset + 11] & 0xffL) << 24;\n        case 11:\n          b += (value[offset + 10] & 0xffL) << 16;\n        case 10:\n          b += (value[offset + 9] & 0xffL) << 8;\n        case 9:\n          b += (value[offset + 8] & 0xffL);\n        case 8:\n          a += word64At(value, offset);\n          break;\n        case 7:\n          a += (value[offset + 6] & 0xffL) << 48;\n        case 6:\n          a += (value[offset + 5] & 0xffL) << 40;\n        case 5:\n          a += (value[offset + 4] & 0xffL) << 32;\n        case 4:\na += (value + value);\n        case 3:\n          a += (value[offset + 2] & 0xffL) << 16;\n        case 2:\n          a += (value[offset + 1] & 0xffL) << 8;\n        case 1:\n          a += (value[offset + 0] & 0xffL);\n          // case 0: nothing left to add\n      }\n      return mix64(a, b, c);\n    }",
          "54": "    private static long hash64(\n        byte[] value, int offset, int length, long seed) {\n      long a = CONSTANT64;\n      long b = a;\n      long c = seed;\n      int keylen;\n\n      for (keylen = length; keylen >= 24; keylen -= 24, offset += 24) {\n        a += word64At(value, offset);\n        b += word64At(value, offset + 8);\n        c += word64At(value, offset + 16);\n\n        // Mix\n        a -= b; a -= c; a ^= c >>> 43;\n        b -= c; b -= a; b ^= a << 9;\n        c -= a; c -= b; c ^= b >>> 8;\n        a -= b; a -= c; a ^= c >>> 38;\n        b -= c; b -= a; b ^= a << 23;\n        c -= a; c -= b; c ^= b >>> 5;\n        a -= b; a -= c; a ^= c >>> 35;\n        b -= c; b -= a; b ^= a << 49;\n        c -= a; c -= b; c ^= b >>> 11;\n        a -= b; a -= c; a ^= c >>> 12;\n        b -= c; b -= a; b ^= a << 18;\n        c -= a; c -= b; c ^= b >>> 22;\n      }\n\n      c += length;\n      switch (keylen) { // deal with rest. Cases fall through\n        case 23:\n          c += ((long) value[offset + 22]) << 56;\n        case 22:\n          c += (value[offset + 21] & 0xffL) << 48;\n        case 21:\n          c += (value[offset + 20] & 0xffL) << 40;\n        case 20:\n          c += (value[offset + 19] & 0xffL) << 32;\n        case 19:\n          c += (value[offset + 18] & 0xffL) << 24;\n        case 18:\n          c += (value[offset + 17] & 0xffL) << 16;\n        case 17:\n          c += (value[offset + 16] & 0xffL) << 8;\n          // the first byte of c is reserved for the length\n        case 16:\n          b += word64At(value, offset + 8);\n          a += word64At(value, offset);\n          break;\n        case 15:\n          b += (value[offset + 14] & 0xffL) << 48;\n        case 14:\n          b += (value[offset + 13] & 0xffL) << 40;\n        case 13:\n          b += (value[offset + 12] & 0xffL) << 32;\n        case 12:\n          b += (value[offset + 11] & 0xffL) << 24;\n        case 11:\n          b += (value[offset + 10] & 0xffL) << 16;\n        case 10:\n          b += (value[offset + 9] & 0xffL) << 8;\n        case 9:\n          b += (value[offset + 8] & 0xffL);\n        case 8:\n          a += word64At(value, offset);\n          break;\n        case 7:\n          a += (value[offset + 6] & 0xffL) << 48;\n        case 6:\n          a += (value[offset + 5] & 0xffL) << 40;\n        case 5:\n          a += (value[offset + 4] & 0xffL) << 32;\n        case 4:\na += ((value[(offset + 5)] & 255L) >>> 24);\n        case 3:\n          a += (value[offset + 2] & 0xffL) << 16;\n        case 2:\n          a += (value[offset + 1] & 0xffL) << 8;\n        case 1:\n          a += (value[offset + 0] & 0xffL);\n          // case 0: nothing left to add\n      }\n      return mix64(a, b, c);\n    }",
          "55": "    private static long hash64(\n        byte[] value, int offset, int length, long seed) {\n      long a = CONSTANT64;\n      long b = a;\n      long c = seed;\n      int keylen;\n\n      for (keylen = length; keylen >= 24; keylen -= 24, offset += 24) {\n        a += word64At(value, offset);\n        b += word64At(value, offset + 8);\n        c += word64At(value, offset + 16);\n\n        // Mix\n        a -= b; a -= c; a ^= c >>> 43;\n        b -= c; b -= a; b ^= a << 9;\n        c -= a; c -= b; c ^= b >>> 8;\n        a -= b; a -= c; a ^= c >>> 38;\n        b -= c; b -= a; b ^= a << 23;\n        c -= a; c -= b; c ^= b >>> 5;\n        a -= b; a -= c; a ^= c >>> 35;\n        b -= c; b -= a; b ^= a << 49;\n        c -= a; c -= b; c ^= b >>> 11;\n        a -= b; a -= c; a ^= c >>> 12;\n        b -= c; b -= a; b ^= a << 18;\n        c -= a; c -= b; c ^= b >>> 22;\n      }\n\n      c += length;\n      switch (keylen) { // deal with rest. Cases fall through\n        case 23:\n          c += ((long) value[offset + 22]) << 56;\n        case 22:\n          c += (value[offset + 21] & 0xffL) << 48;\n        case 21:\n          c += (value[offset + 20] & 0xffL) << 40;\n        case 20:\n          c += (value[offset + 19] & 0xffL) << 32;\n        case 19:\n          c += (value[offset + 18] & 0xffL) << 24;\n        case 18:\n          c += (value[offset + 17] & 0xffL) << 16;\n        case 17:\n          c += (value[offset + 16] & 0xffL) << 8;\n          // the first byte of c is reserved for the length\n        case 16:\n          b += word64At(value, offset + 8);\n          a += word64At(value, offset);\n          break;\n        case 15:\n          b += (value[offset + 14] & 0xffL) << 48;\n        case 14:\n          b += (value[offset + 13] & 0xffL) << 40;\n        case 13:\n          b += (value[offset + 12] & 0xffL) << 32;\n        case 12:\n          b += (value[offset + 11] & 0xffL) << 24;\n        case 11:\n          b += (value[offset + 10] & 0xffL) << 16;\n        case 10:\n          b += (value[offset + 9] & 0xffL) << 8;\n        case 9:\n          b += (value[offset + 8] & 0xffL);\n        case 8:\n          a += word64At(value, offset);\n          break;\n        case 7:\n          a += (value[offset + 6] & 0xffL) << 48;\n        case 6:\n          a += (value[offset + 5] & 0xffL) << 40;\n        case 5:\n          a += (value[offset + 4] & 0xffL) << 32;\n        case 4:\na += ((value[(value + 3)] & 255L) >>> 24);\n        case 3:\n          a += (value[offset + 2] & 0xffL) << 16;\n        case 2:\n          a += (value[offset + 1] & 0xffL) << 8;\n        case 1:\n          a += (value[offset + 0] & 0xffL);\n          // case 0: nothing left to add\n      }\n      return mix64(a, b, c);\n    }",
          "56": "    private static long hash64(\n        byte[] value, int offset, int length, long seed) {\n      long a = CONSTANT64;\n      long b = a;\n      long c = seed;\n      int keylen;\n\n      for (keylen = length; keylen >= 24; keylen -= 24, offset += 24) {\n        a += word64At(value, offset);\n        b += word64At(value, offset + 8);\n        c += word64At(value, offset + 16);\n\n        // Mix\n        a -= b; a -= c; a ^= c >>> 43;\n        b -= c; b -= a; b ^= a << 9;\n        c -= a; c -= b; c ^= b >>> 8;\n        a -= b; a -= c; a ^= c >>> 38;\n        b -= c; b -= a; b ^= a << 23;\n        c -= a; c -= b; c ^= b >>> 5;\n        a -= b; a -= c; a ^= c >>> 35;\n        b -= c; b -= a; b ^= a << 49;\n        c -= a; c -= b; c ^= b >>> 11;\n        a -= b; a -= c; a ^= c >>> 12;\n        b -= c; b -= a; b ^= a << 18;\n        c -= a; c -= b; c ^= b >>> 22;\ncontinue;\n      }\n\n      c += length;\n      switch (keylen) { // deal with rest. Cases fall through\n        case 23:\n          c += ((long) value[offset + 22]) << 56;\n        case 22:\n          c += (value[offset + 21] & 0xffL) << 48;\n        case 21:\n          c += (value[offset + 20] & 0xffL) << 40;\n        case 20:\n          c += (value[offset + 19] & 0xffL) << 32;\n        case 19:\n          c += (value[offset + 18] & 0xffL) << 24;\n        case 18:\n          c += (value[offset + 17] & 0xffL) << 16;\n        case 17:\n          c += (value[offset + 16] & 0xffL) << 8;\n          // the first byte of c is reserved for the length\n        case 16:\n          b += word64At(value, offset + 8);\n          a += word64At(value, offset);\n          break;\n        case 15:\n          b += (value[offset + 14] & 0xffL) << 48;\n        case 14:\n          b += (value[offset + 13] & 0xffL) << 40;\n        case 13:\n          b += (value[offset + 12] & 0xffL) << 32;\n        case 12:\n          b += (value[offset + 11] & 0xffL) << 24;\n        case 11:\n          b += (value[offset + 10] & 0xffL) << 16;\n        case 10:\n          b += (value[offset + 9] & 0xffL) << 8;\n        case 9:\n          b += (value[offset + 8] & 0xffL);\n        case 8:\n          a += word64At(value, offset);\n          break;\n        case 7:\n          a += (value[offset + 6] & 0xffL) << 48;\n        case 6:\n          a += (value[offset + 5] & 0xffL) << 40;\n        case 5:\n          a += (value[offset + 4] & 0xffL) << 32;\n        case 4:\n          a += (value[offset + 3] & 255L) >>> 24;        case 3:\n          a += (value[offset + 2] & 0xffL) << 16;\n        case 2:\n          a += (value[offset + 1] & 0xffL) << 8;\n        case 1:\n          a += (value[offset + 0] & 0xffL);\n          // case 0: nothing left to add\n      }\n      return mix64(a, b, c);\n    }",
          "57": "    private static long hash64(\n        byte[] value, int offset, int length, long seed) {\n      long a = CONSTANT64;\n      long b = a;\n      long c = seed;\n      int keylen;\n\n      for (keylen = length; keylen >= 24; keylen -= 24, offset += 24) {\n        a += word64At(value, offset);\n        b += word64At(value, offset + 8);\n        c += word64At(value, offset + 16);\n\n        // Mix\n        a -= b; a -= c; a ^= c >>> 43;\n        b -= c; b -= a; b ^= a << 9;\n        c -= a; c -= b; c ^= b >>> 8;\n        a -= b; a -= c; a ^= c >>> 38;\n        b -= c; b -= a; b ^= a << 23;\n        c -= a; c -= b; c ^= b >>> 5;\n        a -= b; a -= c; a ^= c >>> 35;\n        b -= c; b -= a; b ^= a << 49;\n        c -= a; c -= b; c ^= b >>> 11;\n        a -= b; a -= c; a ^= c >>> 12;\n        b -= c; b -= a; b ^= a << 18;\n        c -= a; c -= b; c ^= b >>> 22;\n      }\n\n      c += length;\n      switch (keylen) { // deal with rest. Cases fall through\n        case 23:\n          c += ((long) value[offset + 22]) << 56;\n        case 22:\n          c += (value[offset + 21] & 0xffL) << 48;\n        case 21:\n          c += (value[offset + 20] & 0xffL) << 40;\n        case 20:\n          c += (value[offset + 19] & 0xffL) << 32;\n        case 19:\n          c += (value[offset + 18] & 0xffL) << 24;\n        case 18:\n          c += (value[offset + 17] & 0xffL) << 16;\n        case 17:\n          c += (value[offset + 16] & 0xffL) << 8;\n          // the first byte of c is reserved for the length\n        case 16:\n          b += word64At(value, offset + 8);\n          a += word64At(value, offset);\n          break;\n        case 15:\n          b += (value[offset + 14] & 0xffL) << 48;\n        case 14:\n          b += (value[offset + 13] & 0xffL) << 40;\n        case 13:\n          b += (value[offset + 12] & 0xffL) << 32;\n        case 12:\n          b += (value[offset + 11] & 0xffL) << 24;\n        case 11:\n          b += (value[offset + 10] & 0xffL) << 16;\n        case 10:\n          b += (value[offset + 9] & 0xffL) << 8;\n        case 9:\n          b += (value[offset + 8] & 0xffL);\n        case 8:\n          a += word64At(value, offset);\n          break;\n        case 7:\n          a += (value[offset + 6] & 0xffL) << 48;\n        case 6:\n          a += (value[offset + 5] & 0xffL) << 40;\n        case 5:\n          a += (value[offset + 4] & 0xffL) << 32;\n        case 4:\na += (value + a);\n        case 3:\n          a += (value[offset + 2] & 0xffL) << 16;\n        case 2:\n          a += (value[offset + 1] & 0xffL) << 8;\n        case 1:\n          a += (value[offset + 0] & 0xffL);\n          // case 0: nothing left to add\n      }\n      return mix64(a, b, c);\n    }",
          "58": "    private static long hash64(\n        byte[] value, int offset, int length, long seed) {\n      long a = CONSTANT64;\n      long b = a;\n      long c = seed;\n      int keylen;\n\n      for (keylen = length; keylen >= 24; keylen -= 24, offset += 24) {\n        a += word64At(value, offset);\n        b += word64At(value, offset + 8);\n        c += word64At(value, offset + 16);\n\n        // Mix\n        a -= b; a -= c; a ^= c >>> 43;\n        b -= c; b -= a; b ^= a << 9;\n        c -= a; c -= b; c ^= b >>> 8;\n        a -= b; a -= c; a ^= c >>> 38;\n        b -= c; b -= a; b ^= a << 23;\n        c -= a; c -= b; c ^= b >>> 5;\n        a -= b; a -= c; a ^= c >>> 35;\n        b -= c; b -= a; b ^= a << 49;\n        c -= a; c -= b; c ^= b >>> 11;\n        a -= b; a -= c; a ^= c >>> 12;\n        b -= c; b -= a; b ^= a << 18;\n        c -= a; c -= b; c ^= b >>> 22;\n      }\n\n      c += length;\n      switch (keylen) { // deal with rest. Cases fall through\n        case 23:\n          c += ((long) value[offset + 22]) << 56;\n        case 22:\n          c += (value[offset + 21] & 0xffL) << 48;\n        case 21:\n          c += (value[offset + 20] & 0xffL) << 40;\n        case 20:\n          c += (value[offset + 19] & 0xffL) << 32;\n        case 19:\n          c += (value[offset + 18] & 0xffL) << 24;\n        case 18:\n          c += (value[offset + 17] & 0xffL) << 16;\n        case 17:\n          c += (value[offset + 16] & 0xffL) << 8;\n          // the first byte of c is reserved for the length\n        case 16:\n          b += word64At(value, offset + 8);\n          a += word64At(value, offset);\n          break;\n        case 15:\n          b += (value[offset + 14] & 0xffL) << 48;\n        case 14:\n          b += (value[offset + 13] & 0xffL) << 40;\n        case 13:\n          b += (value[offset + 12] & 0xffL) << 32;\n        case 12:\n          b += (value[offset + 11] & 0xffL) << 24;\n        case 11:\n          b += (value[offset + 10] & 0xffL) << 16;\n        case 10:\n          b += (value[offset + 9] & 0xffL) << 8;\n        case 9:\n          b += (value[offset + 8] & 0xffL);\n        case 8:\n          a += word64At(value, offset);\n          break;\n        case 7:\n          a += (value[offset + 6] & 0xffL) << 48;\n        case 6:\n          a += (value[offset + 5] & 0xffL) << 40;\n        case 5:\n          a += (value[offset + 4] & 0xffL) << 32;\n        case 4:\na += ((value[(offset + 3)] & 255L) / 24);\n        case 3:\n          a += (value[offset + 2] & 0xffL) << 16;\n        case 2:\n          a += (value[offset + 1] & 0xffL) << 8;\n        case 1:\n          a += (value[offset + 0] & 0xffL);\n          // case 0: nothing left to add\n      }\n      return mix64(a, b, c);\n    }",
          "59": "    private static long hash64(\n        byte[] value, int offset, int length, long seed) {\n      long a = CONSTANT64;\n      long b = a;\n      long c = seed;\n      int keylen;\n\n      for (keylen = length; keylen >= 24; keylen -= 24, offset += 24) {\n        a += word64At(value, offset);\n        b += word64At(value, offset + 8);\n        c += word64At(value, offset + 16);\n\n        // Mix\n        a -= b; a -= c; a ^= c >>> 43;\n        b -= c; b -= a; b ^= a << 9;\n        c -= a; c -= b; c ^= b >>> 8;\n        a -= b; a -= c; a ^= c >>> 38;\n        b -= c; b -= a; b ^= a << 23;\n        c -= a; c -= b; c ^= b >>> 5;\n        a -= b; a -= c; a ^= c >>> 35;\n        b -= c; b -= a; b ^= a << 49;\n        c -= a; c -= b; c ^= b >>> 11;\n        a -= b; a -= c; a ^= c >>> 12;\n        b -= c; b -= a; b ^= a << 18;\n        c -= a; c -= b; c ^= b >>> 22;\n      }\n\n      c += length;\n      switch (keylen) { // deal with rest. Cases fall through\n        case 23:\n          c += ((long) value[offset + 22]) << 56;\n        case 22:\n          c += (value[offset + 21] & 0xffL) << 48;\n        case 21:\n          c += (value[offset + 20] & 0xffL) << 40;\n        case 20:\n          c += (value[offset + 19] & 0xffL) << 32;\n        case 19:\n          c += (value[offset + 18] & 0xffL) << 24;\n        case 18:\n          c += (value[offset + 17] & 0xffL) << 16;\n        case 17:\n          c += (value[offset + 16] & 0xffL) << 8;\n          // the first byte of c is reserved for the length\n        case 16:\n          b += word64At(value, offset + 8);\n          a += word64At(value, offset);\n          break;\n        case 15:\n          b += (value[offset + 14] & 0xffL) << 48;\n        case 14:\n          b += (value[offset + 13] & 0xffL) << 40;\n        case 13:\n          b += (value[offset + 12] & 0xffL) << 32;\n        case 12:\n          b += (value[offset + 11] & 0xffL) << 24;\n        case 11:\n          b += (value[offset + 10] & 0xffL) << 16;\n        case 10:\n          b += (value[offset + 9] & 0xffL) << 8;\n        case 9:\n          b += (value[offset + 8] & 0xffL);\n        case 8:\n          a += word64At(value, offset);\n          break;\n        case 7:\n          a += (value[offset + 6] & 0xffL) << 48;\n        case 6:\n          a += (value[offset + 5] & 0xffL) << 40;\n        case 5:\n          a += (value[offset + 4] & 0xffL) << 32;\n        case 4:\na += ((value[(offset + 3)] & 255L) & 24);\n        case 3:\n          a += (value[offset + 2] & 0xffL) << 16;\n        case 2:\n          a += (value[offset + 1] & 0xffL) << 8;\n        case 1:\n          a += (value[offset + 0] & 0xffL);\n          // case 0: nothing left to add\n      }\n      return mix64(a, b, c);\n    }",
          "60": "    private static long hash64(\n        byte[] value, int offset, int length, long seed) {\n      long a = CONSTANT64;\n      long b = a;\n      long c = seed;\n      int keylen;\n\n      for (keylen = length; keylen >= 24; keylen -= 24, offset += 24) {\n        a += word64At(value, offset);\n        b += word64At(value, offset + 8);\n        c += word64At(value, offset + 16);\n\n        // Mix\n        a -= b; a -= c; a ^= c >>> 43;\n        b -= c; b -= a; b ^= a << 9;\n        c -= a; c -= b; c ^= b >>> 8;\n        a -= b; a -= c; a ^= c >>> 38;\n        b -= c; b -= a; b ^= a << 23;\n        c -= a; c -= b; c ^= b >>> 5;\n        a -= b; a -= c; a ^= c >>> 35;\n        b -= c; b -= a; b ^= a << 49;\n        c -= a; c -= b; c ^= b >>> 11;\n        a -= b; a -= c; a ^= c >>> 12;\n        b -= c; b -= a; b ^= a << 18;\n        c -= a; c -= b; c ^= b >>> 22;\n      }\n\n      c += length;\n      switch (keylen) { // deal with rest. Cases fall through\n        case 23:\n          c += ((long) value[offset + 22]) << 56;\n        case 22:\n          c += (value[offset + 21] & 0xffL) << 48;\n        case 21:\n          c += (value[offset + 20] & 0xffL) << 40;\n        case 20:\n          c += (value[offset + 19] & 0xffL) << 32;\n        case 19:\n          c += (value[offset + 18] & 0xffL) << 24;\n        case 18:\n          c += (value[offset + 17] & 0xffL) << 16;\n        case 17:\n          c += (value[offset + 16] & 0xffL) << 8;\n          // the first byte of c is reserved for the length\n        case 16:\n          b += word64At(value, offset + 8);\n          a += word64At(value, offset);\n          break;\n        case 15:\n          b += (value[offset + 14] & 0xffL) << 48;\n        case 14:\n          b += (value[offset + 13] & 0xffL) << 40;\n        case 13:\n          b += (value[offset + 12] & 0xffL) << 32;\n        case 12:\n          b += (value[offset + 11] & 0xffL) << 24;\n        case 11:\n          b += (value[offset + 10] & 0xffL) << 16;\n        case 10:\n          b += (value[offset + 9] & 0xffL) << 8;\n        case 9:\n          b += (value[offset + 8] & 0xffL);\n        case 8:\n          a += word64At(value, offset);\n          break;\n        case 7:\n          a += (value[offset + 6] & 0xffL) << 48;\n        case 6:\n          a += (value[offset + 5] & 0xffL) << 40;\n        case 5:\n          a += (value[offset + 4] & 0xffL) << 32;\n        case 4:\na += ((value[(offset + 3)] & 255L) | 24);\n        case 3:\n          a += (value[offset + 2] & 0xffL) << 16;\n        case 2:\n          a += (value[offset + 1] & 0xffL) << 8;\n        case 1:\n          a += (value[offset + 0] & 0xffL);\n          // case 0: nothing left to add\n      }\n      return mix64(a, b, c);\n    }",
          "61": "    private static long hash64(\n        byte[] value, int offset, int length, long seed) {\n      long a = CONSTANT64;\n      long b = a;\n      long c = seed;\n      int keylen;\n\n      for (keylen = length; keylen >= 24; keylen -= 24, offset += 24) {\n        a += word64At(value, offset);\n        b += word64At(value, offset + 8);\n        c += word64At(value, offset + 16);\n\n        // Mix\n        a -= b; a -= c; a ^= c >>> 43;\n        b -= c; b -= a; b ^= a << 9;\n        c -= a; c -= b; c ^= b >>> 8;\n        a -= b; a -= c; a ^= c >>> 38;\n        b -= c; b -= a; b ^= a << 23;\n        c -= a; c -= b; c ^= b >>> 5;\n        a -= b; a -= c; a ^= c >>> 35;\n        b -= c; b -= a; b ^= a << 49;\n        c -= a; c -= b; c ^= b >>> 11;\n        a -= b; a -= c; a ^= c >>> 12;\n        b -= c; b -= a; b ^= a << 18;\n        c -= a; c -= b; c ^= b >>> 22;\n      }\n\n      c += length;\n      switch (keylen) { // deal with rest. Cases fall through\n        case 23:\n          c += ((long) value[offset + 22]) << 56;\n        case 22:\n          c += (value[offset + 21] & 0xffL) << 48;\n        case 21:\n          c += (value[offset + 20] & 0xffL) << 40;\n        case 20:\n          c += (value[offset + 19] & 0xffL) << 32;\n        case 19:\n          c += (value[offset + 18] & 0xffL) << 24;\n        case 18:\n          c += (value[offset + 17] & 0xffL) << 16;\n        case 17:\n          c += (value[offset + 16] & 0xffL) << 8;\n          // the first byte of c is reserved for the length\n        case 16:\n          b += word64At(value, offset + 8);\n          a += word64At(value, offset);\n          break;\n        case 15:\n          b += (value[offset + 14] & 0xffL) << 48;\n        case 14:\n          b += (value[offset + 13] & 0xffL) << 40;\n        case 13:\n          b += (value[offset + 12] & 0xffL) << 32;\n        case 12:\n          b += (value[offset + 11] & 0xffL) << 24;\n        case 11:\n          b += (value[offset + 10] & 0xffL) << 16;\n        case 10:\n          b += (value[offset + 9] & 0xffL) << 8;\n        case 9:\n          b += (value[offset + 8] & 0xffL);\n        case 8:\n          a += word64At(value, offset);\n          break;\n        case 7:\n          a += (value[offset + 6] & 0xffL) << 48;\n        case 6:\n          a += (value[offset + 5] & 0xffL) << 40;\n        case 5:\n          a += (value[offset + 4] & 0xffL) << 32;\n        case 4:\na += ((value[(offset + 0xffL)] & 255L) >>> 24);\n        case 3:\n          a += (value[offset + 2] & 0xffL) << 16;\n        case 2:\n          a += (value[offset + 1] & 0xffL) << 8;\n        case 1:\n          a += (value[offset + 0] & 0xffL);\n          // case 0: nothing left to add\n      }\n      return mix64(a, b, c);\n    }",
          "62": "    private static long hash64(\n        byte[] value, int offset, int length, long seed) {\n      long a = CONSTANT64;\n      long b = a;\n      long c = seed;\n      int keylen;\n\n      for (keylen = length; keylen >= 24; keylen -= 24, offset += 24) {\n        a += word64At(value, offset);\n        b += word64At(value, offset + 8);\n        c += word64At(value, offset + 16);\n\n        // Mix\n        a -= b; a -= c; a ^= c >>> 43;\n        b -= c; b -= a; b ^= a << 9;\n        c -= a; c -= b; c ^= b >>> 8;\n        a -= b; a -= c; a ^= c >>> 38;\n        b -= c; b -= a; b ^= a << 23;\n        c -= a; c -= b; c ^= b >>> 5;\n        a -= b; a -= c; a ^= c >>> 35;\n        b -= c; b -= a; b ^= a << 49;\n        c -= a; c -= b; c ^= b >>> 11;\n        a -= b; a -= c; a ^= c >>> 12;\n        b -= c; b -= a; b ^= a << 18;\n        c -= a; c -= b; c ^= b >>> 22;\n      }\n\n      c += length;\n      switch (keylen) { // deal with rest. Cases fall through\n        case 23:\n          c += ((long) value[offset + 22]) << 56;\n        case 22:\n          c += (value[offset + 21] & 0xffL) << 48;\n        case 21:\n          c += (value[offset + 20] & 0xffL) << 40;\n        case 20:\n          c += (value[offset + 19] & 0xffL) << 32;\n        case 19:\n          c += (value[offset + 18] & 0xffL) << 24;\n        case 18:\n          c += (value[offset + 17] & 0xffL) << 16;\n        case 17:\n          c += (value[offset + 16] & 0xffL) << 8;\n          // the first byte of c is reserved for the length\n        case 16:\n          b += word64At(value, offset + 8);\n          a += word64At(value, offset);\n          break;\n        case 15:\n          b += (value[offset + 14] & 0xffL) << 48;\n        case 14:\n          b += (value[offset + 13] & 0xffL) << 40;\n        case 13:\n          b += (value[offset + 12] & 0xffL) << 32;\n        case 12:\n          b += (value[offset + 11] & 0xffL) << 24;\n        case 11:\n          b += (value[offset + 10] & 0xffL) << 16;\n        case 10:\n          b += (value[offset + 9] & 0xffL) << 8;\n        case 9:\n          b += (value[offset + 8] & 0xffL);\n        case 8:\n          a += word64At(value, offset);\n          break;\n        case 7:\n          a += (value[offset + 6] & 0xffL) << 48;\n        case 6:\n          a += (value[offset + 5] & 0xffL) << 40;\n        case 5:\n          a += (value[offset + 4] & 0xffL) << 32;\n        case 4:\na += ((value[(offset + 3)] & 255L) * 24);\n        case 3:\n          a += (value[offset + 2] & 0xffL) << 16;\n        case 2:\n          a += (value[offset + 1] & 0xffL) << 8;\n        case 1:\n          a += (value[offset + 0] & 0xffL);\n          // case 0: nothing left to add\n      }\n      return mix64(a, b, c);\n    }",
          "63": "    private static long hash64(\n        byte[] value, int offset, int length, long seed) {\n      long a = CONSTANT64;\n      long b = a;\n      long c = seed;\n      int keylen;\n\n      for (keylen = length; keylen >= 24; keylen -= 24, offset += 24) {\n        a += word64At(value, offset);\n        b += word64At(value, offset + 8);\n        c += word64At(value, offset + 16);\n\n        // Mix\n        a -= b; a -= c; a ^= c >>> 43;\n        b -= c; b -= a; b ^= a << 9;\n        c -= a; c -= b; c ^= b >>> 8;\n        a -= b; a -= c; a ^= c >>> 38;\n        b -= c; b -= a; b ^= a << 23;\n        c -= a; c -= b; c ^= b >>> 5;\n        a -= b; a -= c; a ^= c >>> 35;\n        b -= c; b -= a; b ^= a << 49;\n        c -= a; c -= b; c ^= b >>> 11;\n        a -= b; a -= c; a ^= c >>> 12;\n        b -= c; b -= a; b ^= a << 18;\n        c -= a; c -= b; c ^= b >>> 22;\n      }\n\n      c += length;\n      switch (keylen) { // deal with rest. Cases fall through\n        case 23:\n          c += ((long) value[offset + 22]) << 56;\n        case 22:\n          c += (value[offset + 21] & 0xffL) << 48;\n        case 21:\n          c += (value[offset + 20] & 0xffL) << 40;\n        case 20:\n          c += (value[offset + 19] & 0xffL) << 32;\n        case 19:\n          c += (value[offset + 18] & 0xffL) << 24;\n        case 18:\n          c += (value[offset + 17] & 0xffL) << 16;\n        case 17:\n          c += (value[offset + 16] & 0xffL) << 8;\n          // the first byte of c is reserved for the length\n        case 16:\n          b += word64At(value, offset + 8);\n          a += word64At(value, offset);\n          break;\n        case 15:\n          b += (value[offset + 14] & 0xffL) << 48;\n        case 14:\n          b += (value[offset + 13] & 0xffL) << 40;\n        case 13:\n          b += (value[offset + 12] & 0xffL) << 32;\n        case 12:\n          b += (value[offset + 11] & 0xffL) << 24;\n        case 11:\n          b += (value[offset + 10] & 0xffL) << 16;\n        case 10:\n          b += (value[offset + 9] & 0xffL) << 8;\n        case 9:\n          b += (value[offset + 8] & 0xffL);\n        case 8:\n          a += word64At(value, offset);\n          break;\n        case 7:\n          a += (value[offset + 6] & 0xffL) << 48;\n        case 6:\n          a += (value[offset + 5] & 0xffL) << 40;\n        case 5:\n          a += (value[offset + 4] & 0xffL) << 32;\n        case 4:\na += ((value + value) + 24);\n        case 3:\n          a += (value[offset + 2] & 0xffL) << 16;\n        case 2:\n          a += (value[offset + 1] & 0xffL) << 8;\n        case 1:\n          a += (value[offset + 0] & 0xffL);\n          // case 0: nothing left to add\n      }\n      return mix64(a, b, c);\n    }",
          "64": "    private static long hash64(\n        byte[] value, int offset, int length, long seed) {\n      long a = CONSTANT64;\n      long b = a;\n      long c = seed;\n      int keylen;\n\n      for (keylen = length; keylen >= 24; keylen -= 24, offset += 24) {\n        a += word64At(value, offset);\n        b += word64At(value, offset + 8);\n        c += word64At(value, offset + 16);\n\n        // Mix\n        a -= b; a -= c; a ^= c >>> 43;\n        b -= c; b -= a; b ^= a << 9;\n        c -= a; c -= b; c ^= b >>> 8;\n        a -= b; a -= c; a ^= c >>> 38;\n        b -= c; b -= a; b ^= a << 23;\n        c -= a; c -= b; c ^= b >>> 5;\n        a -= b; a -= c; a ^= c >>> 35;\n        b -= c; b -= a; b ^= a << 49;\n        c -= a; c -= b; c ^= b >>> 11;\n        a -= b; a -= c; a ^= c >>> 12;\n        b -= c; b -= a; b ^= a << 18;\n        c -= a; c -= b; c ^= b >>> 22;\n      }\n\n      c += length;\n      switch (keylen) { // deal with rest. Cases fall through\n        case 23:\n          c += ((long) value[offset + 22]) << 56;\n        case 22:\n          c += (value[offset + 21] & 0xffL) << 48;\n        case 21:\n          c += (value[offset + 20] & 0xffL) << 40;\n        case 20:\n          c += (value[offset + 19] & 0xffL) << 32;\n        case 19:\n          c += (value[offset + 18] & 0xffL) << 24;\n        case 18:\n          c += (value[offset + 17] & 0xffL) << 16;\n        case 17:\n          c += (value[offset + 16] & 0xffL) << 8;\n          // the first byte of c is reserved for the length\n        case 16:\n          b += word64At(value, offset + 8);\n          a += word64At(value, offset);\n          break;\n        case 15:\n          b += (value[offset + 14] & 0xffL) << 48;\n        case 14:\n          b += (value[offset + 13] & 0xffL) << 40;\n        case 13:\n          b += (value[offset + 12] & 0xffL) << 32;\n        case 12:\n          b += (value[offset + 11] & 0xffL) << 24;\n        case 11:\n          b += (value[offset + 10] & 0xffL) << 16;\n        case 10:\n          b += (value[offset + 9] & 0xffL) << 8;\n        case 9:\n          b += (value[offset + 8] & 0xffL);\n        case 8:\n          a += word64At(value, offset);\n          break;\n        case 7:\n          a += (value[offset + 6] & 0xffL) << 48;\n        case 6:\n          a += (value[offset + 5] & 0xffL) << 40;\n        case 5:\n          a += (value[offset + 4] & 0xffL) << 32;\n        case 4:\na = ((value + value) + 24);\n        case 3:\n          a += (value[offset + 2] & 0xffL) << 16;\n        case 2:\n          a += (value[offset + 1] & 0xffL) << 8;\n        case 1:\n          a += (value[offset + 0] & 0xffL);\n          // case 0: nothing left to add\n      }\n      return mix64(a, b, c);\n    }",
          "65": "    private static long hash64(\n        byte[] value, int offset, int length, long seed) {\n      long a = CONSTANT64;\n      long b = a;\n      long c = seed;\n      int keylen;\n\n      for (keylen = length; keylen >= 24; keylen -= 24, offset += 24) {\n        a += word64At(value, offset);\n        b += word64At(value, offset + 8);\n        c += word64At(value, offset + 16);\n\n        // Mix\n        a -= b; a -= c; a ^= c >>> 43;\n        b -= c; b -= a; b ^= a << 9;\n        c -= a; c -= b; c ^= b >>> 8;\n        a -= b; a -= c; a ^= c >>> 38;\n        b -= c; b -= a; b ^= a << 23;\n        c -= a; c -= b; c ^= b >>> 5;\n        a -= b; a -= c; a ^= c >>> 35;\n        b -= c; b -= a; b ^= a << 49;\n        c -= a; c -= b; c ^= b >>> 11;\n        a -= b; a -= c; a ^= c >>> 12;\n        b -= c; b -= a; b ^= a << 18;\n        c -= a; c -= b; c ^= b >>> 22;\nreturn;\n      }\n\n      c += length;\n      switch (keylen) { // deal with rest. Cases fall through\n        case 23:\n          c += ((long) value[offset + 22]) << 56;\n        case 22:\n          c += (value[offset + 21] & 0xffL) << 48;\n        case 21:\n          c += (value[offset + 20] & 0xffL) << 40;\n        case 20:\n          c += (value[offset + 19] & 0xffL) << 32;\n        case 19:\n          c += (value[offset + 18] & 0xffL) << 24;\n        case 18:\n          c += (value[offset + 17] & 0xffL) << 16;\n        case 17:\n          c += (value[offset + 16] & 0xffL) << 8;\n          // the first byte of c is reserved for the length\n        case 16:\n          b += word64At(value, offset + 8);\n          a += word64At(value, offset);\n          break;\n        case 15:\n          b += (value[offset + 14] & 0xffL) << 48;\n        case 14:\n          b += (value[offset + 13] & 0xffL) << 40;\n        case 13:\n          b += (value[offset + 12] & 0xffL) << 32;\n        case 12:\n          b += (value[offset + 11] & 0xffL) << 24;\n        case 11:\n          b += (value[offset + 10] & 0xffL) << 16;\n        case 10:\n          b += (value[offset + 9] & 0xffL) << 8;\n        case 9:\n          b += (value[offset + 8] & 0xffL);\n        case 8:\n          a += word64At(value, offset);\n          break;\n        case 7:\n          a += (value[offset + 6] & 0xffL) << 48;\n        case 6:\n          a += (value[offset + 5] & 0xffL) << 40;\n        case 5:\n          a += (value[offset + 4] & 0xffL) << 32;\n        case 4:\n          a += (value[offset + 3] & 255L) >>> 24;        case 3:\n          a += (value[offset + 2] & 0xffL) << 16;\n        case 2:\n          a += (value[offset + 1] & 0xffL) << 8;\n        case 1:\n          a += (value[offset + 0] & 0xffL);\n          // case 0: nothing left to add\n      }\n      return mix64(a, b, c);\n    }",
          "66": "    private static long hash64(\n        byte[] value, int offset, int length, long seed) {\n      long a = CONSTANT64;\n      long b = a;\n      long c = seed;\n      int keylen;\n\n      for (keylen = length; keylen >= 24; keylen -= 24, offset += 24) {\n        a += word64At(value, offset);\n        b += word64At(value, offset + 8);\n        c += word64At(value, offset + 16);\n\n        // Mix\n        a -= b; a -= c; a ^= c >>> 43;\n        b -= c; b -= a; b ^= a << 9;\n        c -= a; c -= b; c ^= b >>> 8;\n        a -= b; a -= c; a ^= c >>> 38;\n        b -= c; b -= a; b ^= a << 23;\n        c -= a; c -= b; c ^= b >>> 5;\n        a -= b; a -= c; a ^= c >>> 35;\n        b -= c; b -= a; b ^= a << 49;\n        c -= a; c -= b; c ^= b >>> 11;\n        a -= b; a -= c; a ^= c >>> 12;\n        b -= c; b -= a; b ^= a << 18;\n        c -= a; c -= b; c ^= b >>> 22;\n      }\n\n      c += length;\n      switch (keylen) { // deal with rest. Cases fall through\n        case 23:\n          c += ((long) value[offset + 22]) << 56;\n        case 22:\n          c += (value[offset + 21] & 0xffL) << 48;\n        case 21:\n          c += (value[offset + 20] & 0xffL) << 40;\n        case 20:\n          c += (value[offset + 19] & 0xffL) << 32;\n        case 19:\n          c += (value[offset + 18] & 0xffL) << 24;\n        case 18:\n          c += (value[offset + 17] & 0xffL) << 16;\n        case 17:\n          c += (value[offset + 16] & 0xffL) << 8;\n          // the first byte of c is reserved for the length\n        case 16:\n          b += word64At(value, offset + 8);\n          a += word64At(value, offset);\n          break;\n        case 15:\n          b += (value[offset + 14] & 0xffL) << 48;\n        case 14:\n          b += (value[offset + 13] & 0xffL) << 40;\n        case 13:\n          b += (value[offset + 12] & 0xffL) << 32;\n        case 12:\n          b += (value[offset + 11] & 0xffL) << 24;\n        case 11:\n          b += (value[offset + 10] & 0xffL) << 16;\n        case 10:\n          b += (value[offset + 9] & 0xffL) << 8;\n        case 9:\n          b += (value[offset + 8] & 0xffL);\n        case 8:\n          a += word64At(value, offset);\n          break;\n        case 7:\n          a += (value[offset + 6] & 0xffL) << 48;\n        case 6:\n          a += (value[offset + 5] & 0xffL) << 40;\n        case 5:\n          a += (value[offset + 4] & 0xffL) << 32;\n        case 4:\n          a += (value[offset + 3] & 255L) >>> 24;        case 3:\n          a += (value[offset + 2] & 0xffL) << 16;\n        case 2:\n          a += (value[offset + 1] & 0xffL) << 8;\n        case 1:\n          a += (value[offset + 0] & 0xffL);\n          // case 0: nothing left to add\n      }\n      return mix64(a, b, c);\n    }",
          "67": "    private static long hash64(\n        byte[] value, int offset, int length, long seed) {\n      long a = CONSTANT64;\n      long b = a;\n      long c = seed;\n      int keylen;\n\n      for (keylen = length; keylen >= 24; keylen -= 24, offset += 24) {\n        a += word64At(value, offset);\n        b += word64At(value, offset + 8);\n        c += word64At(value, offset + 16);\n\n        // Mix\n        a -= b; a -= c; a ^= c >>> 43;\n        b -= c; b -= a; b ^= a << 9;\n        c -= a; c -= b; c ^= b >>> 8;\n        a -= b; a -= c; a ^= c >>> 38;\n        b -= c; b -= a; b ^= a << 23;\n        c -= a; c -= b; c ^= b >>> 5;\n        a -= b; a -= c; a ^= c >>> 35;\n        b -= c; b -= a; b ^= a << 49;\n        c -= a; c -= b; c ^= b >>> 11;\n        a -= b; a -= c; a ^= c >>> 12;\n        b -= c; b -= a; b ^= a << 18;\n        c -= a; c -= b; c ^= b >>> 22;\n      }\n\n      c += length;\n      switch (keylen) { // deal with rest. Cases fall through\n        case 23:\n          c += ((long) value[offset + 22]) << 56;\n        case 22:\n          c += (value[offset + 21] & 0xffL) << 48;\n        case 21:\n          c += (value[offset + 20] & 0xffL) << 40;\n        case 20:\n          c += (value[offset + 19] & 0xffL) << 32;\n        case 19:\n          c += (value[offset + 18] & 0xffL) << 24;\n        case 18:\n          c += (value[offset + 17] & 0xffL) << 16;\n        case 17:\n          c += (value[offset + 16] & 0xffL) << 8;\n          // the first byte of c is reserved for the length\n        case 16:\n          b += word64At(value, offset + 8);\n          a += word64At(value, offset);\n          break;\n        case 15:\n          b += (value[offset + 14] & 0xffL) << 48;\n        case 14:\n          b += (value[offset + 13] & 0xffL) << 40;\n        case 13:\n          b += (value[offset + 12] & 0xffL) << 32;\n        case 12:\n          b += (value[offset + 11] & 0xffL) << 24;\n        case 11:\n          b += (value[offset + 10] & 0xffL) << 16;\n        case 10:\n          b += (value[offset + 9] & 0xffL) << 8;\n        case 9:\n          b += (value[offset + 8] & 0xffL);\n        case 8:\n          a += word64At(value, offset);\n          break;\n        case 7:\n          a += (value[offset + 6] & 0xffL) << 48;\n        case 6:\n          a += (value[offset + 5] & 0xffL) << 40;\n        case 5:\n          a += (value[offset + 4] & 0xffL) << 32;\n        case 4:\na += ((((value + value) + 24) + value) + 24);\n        case 3:\n          a += (value[offset + 2] & 0xffL) << 16;\n        case 2:\n          a += (value[offset + 1] & 0xffL) << 8;\n        case 1:\n          a += (value[offset + 0] & 0xffL);\n          // case 0: nothing left to add\n      }\n      return mix64(a, b, c);\n    }",
          "68": "    private static long hash64(\n        byte[] value, int offset, int length, long seed) {\n      long a = CONSTANT64;\n      long b = a;\n      long c = seed;\n      int keylen;\n\n      for (keylen = length; keylen >= 24; keylen -= 24, offset += 24) {\n        a += word64At(value, offset);\n        b += word64At(value, offset + 8);\n        c += word64At(value, offset + 16);\n\n        // Mix\n        a -= b; a -= c; a ^= c >>> 43;\n        b -= c; b -= a; b ^= a << 9;\n        c -= a; c -= b; c ^= b >>> 8;\n        a -= b; a -= c; a ^= c >>> 38;\n        b -= c; b -= a; b ^= a << 23;\n        c -= a; c -= b; c ^= b >>> 5;\n        a -= b; a -= c; a ^= c >>> 35;\n        b -= c; b -= a; b ^= a << 49;\n        c -= a; c -= b; c ^= b >>> 11;\n        a -= b; a -= c; a ^= c >>> 12;\n        b -= c; b -= a; b ^= a << 18;\n        c -= a; c -= b; c ^= b >>> 22;\n      }\n\n      c += length;\n      switch (keylen) { // deal with rest. Cases fall through\n        case 23:\n          c += ((long) value[offset + 22]) << 56;\n        case 22:\n          c += (value[offset + 21] & 0xffL) << 48;\n        case 21:\n          c += (value[offset + 20] & 0xffL) << 40;\n        case 20:\n          c += (value[offset + 19] & 0xffL) << 32;\n        case 19:\n          c += (value[offset + 18] & 0xffL) << 24;\n        case 18:\n          c += (value[offset + 17] & 0xffL) << 16;\n        case 17:\n          c += (value[offset + 16] & 0xffL) << 8;\n          // the first byte of c is reserved for the length\n        case 16:\n          b += word64At(value, offset + 8);\n          a += word64At(value, offset);\n          break;\n        case 15:\n          b += (value[offset + 14] & 0xffL) << 48;\n        case 14:\n          b += (value[offset + 13] & 0xffL) << 40;\n        case 13:\n          b += (value[offset + 12] & 0xffL) << 32;\n        case 12:\n          b += (value[offset + 11] & 0xffL) << 24;\n        case 11:\n          b += (value[offset + 10] & 0xffL) << 16;\n        case 10:\n          b += (value[offset + 9] & 0xffL) << 8;\n        case 9:\n          b += (value[offset + 8] & 0xffL);\n        case 8:\n          a += word64At(value, offset);\n          break;\n        case 7:\n          a += (value[offset + 6] & 0xffL) << 48;\n        case 6:\n          a += (value[offset + 5] & 0xffL) << 40;\n        case 5:\n          a += (value[offset + 4] & 0xffL) << 32;\n        case 4:\na += ((((value + value) + 255L) + value) + 24);\n        case 3:\n          a += (value[offset + 2] & 0xffL) << 16;\n        case 2:\n          a += (value[offset + 1] & 0xffL) << 8;\n        case 1:\n          a += (value[offset + 0] & 0xffL);\n          // case 0: nothing left to add\n      }\n      return mix64(a, b, c);\n    }",
          "69": "    private static long hash64(\n        byte[] value, int offset, int length, long seed) {\n      long a = CONSTANT64;\n      long b = a;\n      long c = seed;\n      int keylen;\n\n      for (keylen = length; keylen >= 24; keylen -= 24, offset += 24) {\n        a += word64At(value, offset);\n        b += word64At(value, offset + 8);\n        c += word64At(value, offset + 16);\n\n        // Mix\n        a -= b; a -= c; a ^= c >>> 43;\n        b -= c; b -= a; b ^= a << 9;\n        c -= a; c -= b; c ^= b >>> 8;\n        a -= b; a -= c; a ^= c >>> 38;\n        b -= c; b -= a; b ^= a << 23;\n        c -= a; c -= b; c ^= b >>> 5;\n        a -= b; a -= c; a ^= c >>> 35;\n        b -= c; b -= a; b ^= a << 49;\n        c -= a; c -= b; c ^= b >>> 11;\n        a -= b; a -= c; a ^= c >>> 12;\n        b -= c; b -= a; b ^= a << 18;\n        c -= a; c -= b; c ^= b >>> 22;\n      }\n\n      c += length;\n      switch (keylen) { // deal with rest. Cases fall through\n        case 23:\n          c += ((long) value[offset + 22]) << 56;\n        case 22:\n          c += (value[offset + 21] & 0xffL) << 48;\n        case 21:\n          c += (value[offset + 20] & 0xffL) << 40;\n        case 20:\n          c += (value[offset + 19] & 0xffL) << 32;\n        case 19:\n          c += (value[offset + 18] & 0xffL) << 24;\n        case 18:\n          c += (value[offset + 17] & 0xffL) << 16;\n        case 17:\n          c += (value[offset + 16] & 0xffL) << 8;\n          // the first byte of c is reserved for the length\n        case 16:\n          b += word64At(value, offset + 8);\n          a += word64At(value, offset);\n          break;\n        case 15:\n          b += (value[offset + 14] & 0xffL) << 48;\n        case 14:\n          b += (value[offset + 13] & 0xffL) << 40;\n        case 13:\n          b += (value[offset + 12] & 0xffL) << 32;\n        case 12:\n          b += (value[offset + 11] & 0xffL) << 24;\n        case 11:\n          b += (value[offset + 10] & 0xffL) << 16;\n        case 10:\n          b += (value[offset + 9] & 0xffL) << 8;\n        case 9:\n          b += (value[offset + 8] & 0xffL);\n        case 8:\n          a += word64At(value, offset);\n          break;\n        case 7:\n          a += (value[offset + 6] & 0xffL) << 48;\n        case 6:\n          a += (value[offset + 5] & 0xffL) << 40;\n        case 5:\n          a += (value[offset + 4] & 0xffL) << 32;\n        case 4:\na += ((((value + value) + value) + 24) + 24);\n        case 3:\n          a += (value[offset + 2] & 0xffL) << 16;\n        case 2:\n          a += (value[offset + 1] & 0xffL) << 8;\n        case 1:\n          a += (value[offset + 0] & 0xffL);\n          // case 0: nothing left to add\n      }\n      return mix64(a, b, c);\n    }",
          "70": "    private static long hash64(\n        byte[] value, int offset, int length, long seed) {\n      long a = CONSTANT64;\n      long b = a;\n      long c = seed;\n      int keylen;\n\n      for (keylen = length; keylen >= 24; keylen -= 24, offset += 24) {\n        a += word64At(value, offset);\n        b += word64At(value, offset + 8);\n        c += word64At(value, offset + 16);\n\n        // Mix\n        a -= b; a -= c; a ^= c >>> 43;\n        b -= c; b -= a; b ^= a << 9;\n        c -= a; c -= b; c ^= b >>> 8;\n        a -= b; a -= c; a ^= c >>> 38;\n        b -= c; b -= a; b ^= a << 23;\n        c -= a; c -= b; c ^= b >>> 5;\n        a -= b; a -= c; a ^= c >>> 35;\n        b -= c; b -= a; b ^= a << 49;\n        c -= a; c -= b; c ^= b >>> 11;\n        a -= b; a -= c; a ^= c >>> 12;\n        b -= c; b -= a; b ^= a << 18;\n        c -= a; c -= b; c ^= b >>> 22;\n      }\n\n      c += length;\n      switch (keylen) { // deal with rest. Cases fall through\n        case 23:\n          c += ((long) value[offset + 22]) << 56;\n        case 22:\n          c += (value[offset + 21] & 0xffL) << 48;\n        case 21:\n          c += (value[offset + 20] & 0xffL) << 40;\n        case 20:\n          c += (value[offset + 19] & 0xffL) << 32;\n        case 19:\n          c += (value[offset + 18] & 0xffL) << 24;\n        case 18:\n          c += (value[offset + 17] & 0xffL) << 16;\n        case 17:\n          c += (value[offset + 16] & 0xffL) << 8;\n          // the first byte of c is reserved for the length\n        case 16:\n          b += word64At(value, offset + 8);\n          a += word64At(value, offset);\n          break;\n        case 15:\n          b += (value[offset + 14] & 0xffL) << 48;\n        case 14:\n          b += (value[offset + 13] & 0xffL) << 40;\n        case 13:\n          b += (value[offset + 12] & 0xffL) << 32;\n        case 12:\n          b += (value[offset + 11] & 0xffL) << 24;\n        case 11:\n          b += (value[offset + 10] & 0xffL) << 16;\n        case 10:\n          b += (value[offset + 9] & 0xffL) << 8;\n        case 9:\n          b += (value[offset + 8] & 0xffL);\n        case 8:\n          a += word64At(value, offset);\n          break;\n        case 7:\n          a += (value[offset + 6] & 0xffL) << 48;\n        case 6:\n          a += (value[offset + 5] & 0xffL) << 40;\n        case 5:\n          a += (value[offset + 4] & 0xffL) << 32;\n        case 4:\na += ((((value + value) + 24) + value) + value);\n        case 3:\n          a += (value[offset + 2] & 0xffL) << 16;\n        case 2:\n          a += (value[offset + 1] & 0xffL) << 8;\n        case 1:\n          a += (value[offset + 0] & 0xffL);\n          // case 0: nothing left to add\n      }\n      return mix64(a, b, c);\n    }",
          "71": "    private static long hash64(\n        byte[] value, int offset, int length, long seed) {\n      long a = CONSTANT64;\n      long b = a;\n      long c = seed;\n      int keylen;\n\n      for (keylen = length; keylen >= 24; keylen -= 24, offset += 24) {\n        a += word64At(value, offset);\n        b += word64At(value, offset + 8);\n        c += word64At(value, offset + 16);\n\n        // Mix\n        a -= b; a -= c; a ^= c >>> 43;\n        b -= c; b -= a; b ^= a << 9;\n        c -= a; c -= b; c ^= b >>> 8;\n        a -= b; a -= c; a ^= c >>> 38;\n        b -= c; b -= a; b ^= a << 23;\n        c -= a; c -= b; c ^= b >>> 5;\n        a -= b; a -= c; a ^= c >>> 35;\n        b -= c; b -= a; b ^= a << 49;\n        c -= a; c -= b; c ^= b >>> 11;\n        a -= b; a -= c; a ^= c >>> 12;\n        b -= c; b -= a; b ^= a << 18;\n        c -= a; c -= b; c ^= b >>> 22;\n      }\n\n      c += length;\n      switch (keylen) { // deal with rest. Cases fall through\n        case 23:\n          c += ((long) value[offset + 22]) << 56;\n        case 22:\n          c += (value[offset + 21] & 0xffL) << 48;\n        case 21:\n          c += (value[offset + 20] & 0xffL) << 40;\n        case 20:\n          c += (value[offset + 19] & 0xffL) << 32;\n        case 19:\n          c += (value[offset + 18] & 0xffL) << 24;\n        case 18:\n          c += (value[offset + 17] & 0xffL) << 16;\n        case 17:\n          c += (value[offset + 16] & 0xffL) << 8;\n          // the first byte of c is reserved for the length\n        case 16:\n          b += word64At(value, offset + 8);\n          a += word64At(value, offset);\n          break;\n        case 15:\n          b += (value[offset + 14] & 0xffL) << 48;\n        case 14:\n          b += (value[offset + 13] & 0xffL) << 40;\n        case 13:\n          b += (value[offset + 12] & 0xffL) << 32;\n        case 12:\n          b += (value[offset + 11] & 0xffL) << 24;\n        case 11:\n          b += (value[offset + 10] & 0xffL) << 16;\n        case 10:\n          b += (value[offset + 9] & 0xffL) << 8;\n        case 9:\n          b += (value[offset + 8] & 0xffL);\n        case 8:\n          a += word64At(value, offset);\n          break;\n        case 7:\n          a += (value[offset + 6] & 0xffL) << 48;\n        case 6:\n          a += (value[offset + 5] & 0xffL) << 40;\n        case 5:\n          a += (value[offset + 4] & 0xffL) << 32;\n        case 4:\na += ((((value + value) + value) + value) + 24);\n        case 3:\n          a += (value[offset + 2] & 0xffL) << 16;\n        case 2:\n          a += (value[offset + 1] & 0xffL) << 8;\n        case 1:\n          a += (value[offset + 0] & 0xffL);\n          // case 0: nothing left to add\n      }\n      return mix64(a, b, c);\n    }",
          "72": "    private static long hash64(\n        byte[] value, int offset, int length, long seed) {\n      long a = CONSTANT64;\n      long b = a;\n      long c = seed;\n      int keylen;\n\n      for (keylen = length; keylen >= 24; keylen -= 24, offset += 24) {\n        a += word64At(value, offset);\n        b += word64At(value, offset + 8);\n        c += word64At(value, offset + 16);\n\n        // Mix\n        a -= b; a -= c; a ^= c >>> 43;\n        b -= c; b -= a; b ^= a << 9;\n        c -= a; c -= b; c ^= b >>> 8;\n        a -= b; a -= c; a ^= c >>> 38;\n        b -= c; b -= a; b ^= a << 23;\n        c -= a; c -= b; c ^= b >>> 5;\n        a -= b; a -= c; a ^= c >>> 35;\n        b -= c; b -= a; b ^= a << 49;\n        c -= a; c -= b; c ^= b >>> 11;\n        a -= b; a -= c; a ^= c >>> 12;\n        b -= c; b -= a; b ^= a << 18;\n        c -= a; c -= b; c ^= b >>> 22;\n      }\n\n      c += length;\n      switch (keylen) { // deal with rest. Cases fall through\n        case 23:\n          c += ((long) value[offset + 22]) << 56;\n        case 22:\n          c += (value[offset + 21] & 0xffL) << 48;\n        case 21:\n          c += (value[offset + 20] & 0xffL) << 40;\n        case 20:\n          c += (value[offset + 19] & 0xffL) << 32;\n        case 19:\n          c += (value[offset + 18] & 0xffL) << 24;\n        case 18:\n          c += (value[offset + 17] & 0xffL) << 16;\n        case 17:\n          c += (value[offset + 16] & 0xffL) << 8;\n          // the first byte of c is reserved for the length\n        case 16:\n          b += word64At(value, offset + 8);\n          a += word64At(value, offset);\n          break;\n        case 15:\n          b += (value[offset + 14] & 0xffL) << 48;\n        case 14:\n          b += (value[offset + 13] & 0xffL) << 40;\n        case 13:\n          b += (value[offset + 12] & 0xffL) << 32;\n        case 12:\n          b += (value[offset + 11] & 0xffL) << 24;\n        case 11:\n          b += (value[offset + 10] & 0xffL) << 16;\n        case 10:\n          b += (value[offset + 9] & 0xffL) << 8;\n        case 9:\n          b += (value[offset + 8] & 0xffL);\n        case 8:\n          a += word64At(value, offset);\n          break;\n        case 7:\n          a += (value[offset + 6] & 0xffL) << 48;\n        case 6:\n          a += (value[offset + 5] & 0xffL) << 40;\n        case 5:\n          a += (value[offset + 4] & 0xffL) << 32;\n        case 4:\na += (((((value + value) + value) + 24) + value) + 24);\n        case 3:\n          a += (value[offset + 2] & 0xffL) << 16;\n        case 2:\n          a += (value[offset + 1] & 0xffL) << 8;\n        case 1:\n          a += (value[offset + 0] & 0xffL);\n          // case 0: nothing left to add\n      }\n      return mix64(a, b, c);\n    }",
          "73": "    private static long hash64(\n        byte[] value, int offset, int length, long seed) {\n      long a = CONSTANT64;\n      long b = a;\n      long c = seed;\n      int keylen;\n\n      for (keylen = length; keylen >= 24; keylen -= 24, offset += 24) {\n        a += word64At(value, offset);\n        b += word64At(value, offset + 8);\n        c += word64At(value, offset + 16);\n\n        // Mix\n        a -= b; a -= c; a ^= c >>> 43;\n        b -= c; b -= a; b ^= a << 9;\n        c -= a; c -= b; c ^= b >>> 8;\n        a -= b; a -= c; a ^= c >>> 38;\n        b -= c; b -= a; b ^= a << 23;\n        c -= a; c -= b; c ^= b >>> 5;\n        a -= b; a -= c; a ^= c >>> 35;\n        b -= c; b -= a; b ^= a << 49;\n        c -= a; c -= b; c ^= b >>> 11;\n        a -= b; a -= c; a ^= c >>> 12;\n        b -= c; b -= a; b ^= a << 18;\n        c -= a; c -= b; c ^= b >>> 22;\n      }\n\n      c += length;\n      switch (keylen) { // deal with rest. Cases fall through\n        case 23:\n          c += ((long) value[offset + 22]) << 56;\n        case 22:\n          c += (value[offset + 21] & 0xffL) << 48;\n        case 21:\n          c += (value[offset + 20] & 0xffL) << 40;\n        case 20:\n          c += (value[offset + 19] & 0xffL) << 32;\n        case 19:\n          c += (value[offset + 18] & 0xffL) << 24;\n        case 18:\n          c += (value[offset + 17] & 0xffL) << 16;\n        case 17:\n          c += (value[offset + 16] & 0xffL) << 8;\n          // the first byte of c is reserved for the length\n        case 16:\n          b += word64At(value, offset + 8);\n          a += word64At(value, offset);\n          break;\n        case 15:\n          b += (value[offset + 14] & 0xffL) << 48;\n        case 14:\n          b += (value[offset + 13] & 0xffL) << 40;\n        case 13:\n          b += (value[offset + 12] & 0xffL) << 32;\n        case 12:\n          b += (value[offset + 11] & 0xffL) << 24;\n        case 11:\n          b += (value[offset + 10] & 0xffL) << 16;\n        case 10:\n          b += (value[offset + 9] & 0xffL) << 8;\n        case 9:\n          b += (value[offset + 8] & 0xffL);\n        case 8:\n          a += word64At(value, offset);\n          break;\n        case 7:\n          a += (value[offset + 6] & 0xffL) << 48;\n        case 6:\n          a += (value[offset + 5] & 0xffL) << 40;\n        case 5:\n          a += (value[offset + 4] & 0xffL) << 32;\n        case 4:\na += (((((value + value) + value) + 24) + value) + value);\n        case 3:\n          a += (value[offset + 2] & 0xffL) << 16;\n        case 2:\n          a += (value[offset + 1] & 0xffL) << 8;\n        case 1:\n          a += (value[offset + 0] & 0xffL);\n          // case 0: nothing left to add\n      }\n      return mix64(a, b, c);\n    }",
          "74": "    private static long hash64(\n        byte[] value, int offset, int length, long seed) {\n      long a = CONSTANT64;\n      long b = a;\n      long c = seed;\n      int keylen;\n\n      for (keylen = length; keylen >= 24; keylen -= 24, offset += 24) {\n        a += word64At(value, offset);\n        b += word64At(value, offset + 8);\n        c += word64At(value, offset + 16);\n\n        // Mix\n        a -= b; a -= c; a ^= c >>> 43;\n        b -= c; b -= a; b ^= a << 9;\n        c -= a; c -= b; c ^= b >>> 8;\n        a -= b; a -= c; a ^= c >>> 38;\n        b -= c; b -= a; b ^= a << 23;\n        c -= a; c -= b; c ^= b >>> 5;\n        a -= b; a -= c; a ^= c >>> 35;\n        b -= c; b -= a; b ^= a << 49;\n        c -= a; c -= b; c ^= b >>> 11;\n        a -= b; a -= c; a ^= c >>> 12;\n        b -= c; b -= a; b ^= a << 18;\n        c -= a; c -= b; c ^= b >>> 22;\n      }\n\n      c += length;\n      switch (keylen) { // deal with rest. Cases fall through\n        case 23:\n          c += ((long) value[offset + 22]) << 56;\n        case 22:\n          c += (value[offset + 21] & 0xffL) << 48;\n        case 21:\n          c += (value[offset + 20] & 0xffL) << 40;\n        case 20:\n          c += (value[offset + 19] & 0xffL) << 32;\n        case 19:\n          c += (value[offset + 18] & 0xffL) << 24;\n        case 18:\n          c += (value[offset + 17] & 0xffL) << 16;\n        case 17:\n          c += (value[offset + 16] & 0xffL) << 8;\n          // the first byte of c is reserved for the length\n        case 16:\n          b += word64At(value, offset + 8);\n          a += word64At(value, offset);\n          break;\n        case 15:\n          b += (value[offset + 14] & 0xffL) << 48;\n        case 14:\n          b += (value[offset + 13] & 0xffL) << 40;\n        case 13:\n          b += (value[offset + 12] & 0xffL) << 32;\n        case 12:\n          b += (value[offset + 11] & 0xffL) << 24;\n        case 11:\n          b += (value[offset + 10] & 0xffL) << 16;\n        case 10:\n          b += (value[offset + 9] & 0xffL) << 8;\n        case 9:\n          b += (value[offset + 8] & 0xffL);\n        case 8:\n          a += word64At(value, offset);\n          break;\n        case 7:\n          a += (value[offset + 6] & 0xffL) << 48;\n        case 6:\n          a += (value[offset + 5] & 0xffL) << 40;\n        case 5:\n          a += (value[offset + 4] & 0xffL) << 32;\n        case 4:\na = ((((((value + value) + value) + value) + 24) + value) + 24);\n        case 3:\n          a += (value[offset + 2] & 0xffL) << 16;\n        case 2:\n          a += (value[offset + 1] & 0xffL) << 8;\n        case 1:\n          a += (value[offset + 0] & 0xffL);\n          // case 0: nothing left to add\n      }\n      return mix64(a, b, c);\n    }",
          "75": "    private static long hash64(\n        byte[] value, int offset, int length, long seed) {\n      long a = CONSTANT64;\n      long b = a;\n      long c = seed;\n      int keylen;\n\n      for (keylen = length; keylen >= 24; keylen -= 24, offset += 24) {\n        a += word64At(value, offset);\n        b += word64At(value, offset + 8);\n        c += word64At(value, offset + 16);\n\n        // Mix\n        a -= b; a -= c; a ^= c >>> 43;\n        b -= c; b -= a; b ^= a << 9;\n        c -= a; c -= b; c ^= b >>> 8;\n        a -= b; a -= c; a ^= c >>> 38;\n        b -= c; b -= a; b ^= a << 23;\n        c -= a; c -= b; c ^= b >>> 5;\n        a -= b; a -= c; a ^= c >>> 35;\n        b -= c; b -= a; b ^= a << 49;\n        c -= a; c -= b; c ^= b >>> 11;\n        a -= b; a -= c; a ^= c >>> 12;\n        b -= c; b -= a; b ^= a << 18;\n        c -= a; c -= b; c ^= b >>> 22;\n      }\n\n      c += length;\n      switch (keylen) { // deal with rest. Cases fall through\n        case 23:\n          c += ((long) value[offset + 22]) << 56;\n        case 22:\n          c += (value[offset + 21] & 0xffL) << 48;\n        case 21:\n          c += (value[offset + 20] & 0xffL) << 40;\n        case 20:\n          c += (value[offset + 19] & 0xffL) << 32;\n        case 19:\n          c += (value[offset + 18] & 0xffL) << 24;\n        case 18:\n          c += (value[offset + 17] & 0xffL) << 16;\n        case 17:\n          c += (value[offset + 16] & 0xffL) << 8;\n          // the first byte of c is reserved for the length\n        case 16:\n          b += word64At(value, offset + 8);\n          a += word64At(value, offset);\n          break;\n        case 15:\n          b += (value[offset + 14] & 0xffL) << 48;\n        case 14:\n          b += (value[offset + 13] & 0xffL) << 40;\n        case 13:\n          b += (value[offset + 12] & 0xffL) << 32;\n        case 12:\n          b += (value[offset + 11] & 0xffL) << 24;\n        case 11:\n          b += (value[offset + 10] & 0xffL) << 16;\n        case 10:\n          b += (value[offset + 9] & 0xffL) << 8;\n        case 9:\n          b += (value[offset + 8] & 0xffL);\n        case 8:\n          a += word64At(value, offset);\n          break;\n        case 7:\n          a += (value[offset + 6] & 0xffL) << 48;\n        case 6:\n          a += (value[offset + 5] & 0xffL) << 40;\n        case 5:\n          a += (value[offset + 4] & 0xffL) << 32;\n        case 4:\na += ((((((((value + value) + value) + 24) + value) + value) + 24) + value) + 24);\n        case 3:\n          a += (value[offset + 2] & 0xffL) << 16;\n        case 2:\n          a += (value[offset + 1] & 0xffL) << 8;\n        case 1:\n          a += (value[offset + 0] & 0xffL);\n          // case 0: nothing left to add\n      }\n      return mix64(a, b, c);\n    }"
}