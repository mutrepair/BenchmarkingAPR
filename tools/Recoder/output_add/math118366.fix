{
          "0": "    public static float scalb(final float f, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -127) && (n < 128)) {\n            return f * Float.intBitsToFloat((n + 127) << 23);\n        }\n\n        // handle special cases\n        if (Float.isNaN(f) || Float.isInfinite(f) || (f == 0f)) {\n            return f;\n        }\n        if (n < -277) {\n            return (f > 0) ? 0.0f : -0.0f;\n        }\n        if (n > 276) {\n            return (f > 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n        }\n\n        // decompose f\n        final int bits = Float.floatToIntBits(f);\nfinal int sign = (bits | 1);\n        int  exponent  = (bits >>> 23) & 0xff;\n        int mantissa   = bits & 0x007fffff;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -127\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n            } else if (scaledExponent > -24) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\n                mantissa = mantissa | (1 << 23);\n\n                // scales down complete mantissa, hence losing least significant bits\n                final int mostSignificantLostBit = mantissa & (1 << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Float.intBitsToFloat(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0) ? 0.0f : -0.0f;\n            }\n        } else {\n            // we are really in the case n >= 128\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 23) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x007fffff;\n\n                if (scaledExponent < 255) {\n                    return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n                } else {\n                    return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 255) {\n                return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n            } else {\n                return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "1": "    public static float scalb(final float f, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -127) && (n < 128)) {\n            return f * Float.intBitsToFloat((n + 127) << 23);\n        }\n\n        // handle special cases\n        if (Float.isNaN(f) || Float.isInfinite(f) || (f == 0f)) {\n            return f;\n        }\n        if (n < -277) {\n            return (f > 0) ? 0.0f : -0.0f;\n        }\n        if (n > 276) {\n            return (f > 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n        }\n\n        // decompose f\n        final int bits = Float.floatToIntBits(f);\nfinal int sign = (bits | 0);\n        int  exponent  = (bits >>> 23) & 0xff;\n        int mantissa   = bits & 0x007fffff;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -127\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n            } else if (scaledExponent > -24) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\n                mantissa = mantissa | (1 << 23);\n\n                // scales down complete mantissa, hence losing least significant bits\n                final int mostSignificantLostBit = mantissa & (1 << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Float.intBitsToFloat(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0) ? 0.0f : -0.0f;\n            }\n        } else {\n            // we are really in the case n >= 128\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 23) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x007fffff;\n\n                if (scaledExponent < 255) {\n                    return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n                } else {\n                    return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 255) {\n                return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n            } else {\n                return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "2": "    public static float scalb(final float f, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -127) && (n < 128)) {\n            return f * Float.intBitsToFloat((n + 127) << 23);\n        }\n\n        // handle special cases\n        if (Float.isNaN(f) || Float.isInfinite(f) || (f == 0f)) {\n            return f;\n        }\n        if (n < -277) {\n            return (f > 0) ? 0.0f : -0.0f;\n        }\n        if (n > 276) {\n            return (f > 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n        }\n\n        // decompose f\n        final int bits = Float.floatToIntBits(f);\nfinal int sign = (bits | 2);\n        int  exponent  = (bits >>> 23) & 0xff;\n        int mantissa   = bits & 0x007fffff;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -127\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n            } else if (scaledExponent > -24) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\n                mantissa = mantissa | (1 << 23);\n\n                // scales down complete mantissa, hence losing least significant bits\n                final int mostSignificantLostBit = mantissa & (1 << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Float.intBitsToFloat(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0) ? 0.0f : -0.0f;\n            }\n        } else {\n            // we are really in the case n >= 128\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 23) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x007fffff;\n\n                if (scaledExponent < 255) {\n                    return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n                } else {\n                    return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 255) {\n                return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n            } else {\n                return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "3": "    public static float scalb(final float f, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -127) && (n < 128)) {\n            return f * Float.intBitsToFloat((n + 127) << 23);\n        }\n\n        // handle special cases\n        if (Float.isNaN(f) || Float.isInfinite(f) || (f == 0f)) {\n            return f;\n        }\n        if (n < -277) {\n            return (f > 0) ? 0.0f : -0.0f;\n        }\n        if (n > 276) {\n            return (f > 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n        }\n\n        // decompose f\n        final int bits = Float.floatToIntBits(f);\nfinal int sign = (bits - -2147483648);\n        int  exponent  = (bits >>> 23) & 0xff;\n        int mantissa   = bits & 0x007fffff;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -127\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n            } else if (scaledExponent > -24) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\n                mantissa = mantissa | (1 << 23);\n\n                // scales down complete mantissa, hence losing least significant bits\n                final int mostSignificantLostBit = mantissa & (1 << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Float.intBitsToFloat(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0) ? 0.0f : -0.0f;\n            }\n        } else {\n            // we are really in the case n >= 128\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 23) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x007fffff;\n\n                if (scaledExponent < 255) {\n                    return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n                } else {\n                    return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 255) {\n                return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n            } else {\n                return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "4": "    public static float scalb(final float f, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -127) && (n < 128)) {\n            return f * Float.intBitsToFloat((n + 127) << 23);\n        }\n\n        // handle special cases\n        if (Float.isNaN(f) || Float.isInfinite(f) || (f == 0f)) {\n            return f;\n        }\n        if (n < -277) {\n            return (f > 0) ? 0.0f : -0.0f;\n        }\n        if (n > 276) {\n            return (f > 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n        }\n\n        // decompose f\n        final int bits = Float.floatToIntBits(f);\nfinal int sign = (bits <= -2147483648);\n        int  exponent  = (bits >>> 23) & 0xff;\n        int mantissa   = bits & 0x007fffff;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -127\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n            } else if (scaledExponent > -24) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\n                mantissa = mantissa | (1 << 23);\n\n                // scales down complete mantissa, hence losing least significant bits\n                final int mostSignificantLostBit = mantissa & (1 << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Float.intBitsToFloat(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0) ? 0.0f : -0.0f;\n            }\n        } else {\n            // we are really in the case n >= 128\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 23) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x007fffff;\n\n                if (scaledExponent < 255) {\n                    return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n                } else {\n                    return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 255) {\n                return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n            } else {\n                return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "5": "    public static float scalb(final float f, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -127) && (n < 128)) {\n            return f * Float.intBitsToFloat((n + 127) << 23);\n        }\n\n        // handle special cases\n        if (Float.isNaN(f) || Float.isInfinite(f) || (f == 0f)) {\n            return f;\n        }\n        if (n < -277) {\n            return (f > 0) ? 0.0f : -0.0f;\n        }\n        if (n > 276) {\n            return (f > 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n        }\n\n        // decompose f\n        final int bits = Float.floatToIntBits(f);\nfinal long sign = (bits | -2147483648);\n        int  exponent  = (bits >>> 23) & 0xff;\n        int mantissa   = bits & 0x007fffff;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -127\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n            } else if (scaledExponent > -24) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\n                mantissa = mantissa | (1 << 23);\n\n                // scales down complete mantissa, hence losing least significant bits\n                final int mostSignificantLostBit = mantissa & (1 << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Float.intBitsToFloat(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0) ? 0.0f : -0.0f;\n            }\n        } else {\n            // we are really in the case n >= 128\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 23) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x007fffff;\n\n                if (scaledExponent < 255) {\n                    return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n                } else {\n                    return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 255) {\n                return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n            } else {\n                return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "6": "    public static float scalb(final float f, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -127) && (n < 128)) {\n            return f * Float.intBitsToFloat((n + 127) << 23);\n        }\n\n        // handle special cases\n        if (Float.isNaN(f) || Float.isInfinite(f) || (f == 0f)) {\n            return f;\n        }\n        if (n < -277) {\n            return (f > 0) ? 0.0f : -0.0f;\n        }\n        if (n > 276) {\n            return (f > 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n        }\n\n        // decompose f\n        final int bits = Float.floatToIntBits(f);\nfinal int sign = (bits < -2147483648);\n        int  exponent  = (bits >>> 23) & 0xff;\n        int mantissa   = bits & 0x007fffff;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -127\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n            } else if (scaledExponent > -24) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\n                mantissa = mantissa | (1 << 23);\n\n                // scales down complete mantissa, hence losing least significant bits\n                final int mostSignificantLostBit = mantissa & (1 << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Float.intBitsToFloat(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0) ? 0.0f : -0.0f;\n            }\n        } else {\n            // we are really in the case n >= 128\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 23) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x007fffff;\n\n                if (scaledExponent < 255) {\n                    return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n                } else {\n                    return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 255) {\n                return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n            } else {\n                return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "7": "    public static float scalb(final float f, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -127) && (n < 128)) {\n            return f * Float.intBitsToFloat((n + 127) << 23);\n        }\n\n        // handle special cases\n        if (Float.isNaN(f) || Float.isInfinite(f) || (f == 0f)) {\n            return f;\n        }\n        if (n < -277) {\n            return (f > 0) ? 0.0f : -0.0f;\n        }\n        if (n > 276) {\n            return (f > 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n        }\n\n        // decompose f\n        final int bits = Float.floatToIntBits(f);\nfinal int sign = (bits | false);\n        int  exponent  = (bits >>> 23) & 0xff;\n        int mantissa   = bits & 0x007fffff;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -127\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n            } else if (scaledExponent > -24) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\n                mantissa = mantissa | (1 << 23);\n\n                // scales down complete mantissa, hence losing least significant bits\n                final int mostSignificantLostBit = mantissa & (1 << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Float.intBitsToFloat(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0) ? 0.0f : -0.0f;\n            }\n        } else {\n            // we are really in the case n >= 128\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 23) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x007fffff;\n\n                if (scaledExponent < 255) {\n                    return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n                } else {\n                    return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 255) {\n                return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n            } else {\n                return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "8": "    public static float scalb(final float f, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -127) && (n < 128)) {\n            return f * Float.intBitsToFloat((n + 127) << 23);\n        }\n\n        // handle special cases\n        if (Float.isNaN(f) || Float.isInfinite(f) || (f == 0f)) {\n            return f;\n        }\n        if (n < -277) {\n            return (f > 0) ? 0.0f : -0.0f;\n        }\n        if (n > 276) {\n            return (f > 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n        }\n\n        // decompose f\n        final int bits = Float.floatToIntBits(f);\nfinal int sign = (bits > -2147483648);\n        int  exponent  = (bits >>> 23) & 0xff;\n        int mantissa   = bits & 0x007fffff;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -127\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n            } else if (scaledExponent > -24) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\n                mantissa = mantissa | (1 << 23);\n\n                // scales down complete mantissa, hence losing least significant bits\n                final int mostSignificantLostBit = mantissa & (1 << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Float.intBitsToFloat(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0) ? 0.0f : -0.0f;\n            }\n        } else {\n            // we are really in the case n >= 128\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 23) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x007fffff;\n\n                if (scaledExponent < 255) {\n                    return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n                } else {\n                    return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 255) {\n                return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n            } else {\n                return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "9": "    public static float scalb(final float f, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -127) && (n < 128)) {\n            return f * Float.intBitsToFloat((n + 127) << 23);\n        }\n\n        // handle special cases\n        if (Float.isNaN(f) || Float.isInfinite(f) || (f == 0f)) {\n            return f;\n        }\n        if (n < -277) {\n            return (f > 0) ? 0.0f : -0.0f;\n        }\n        if (n > 276) {\n            return (f > 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n        }\n\n        // decompose f\n        final int bits = Float.floatToIntBits(f);\nfinal int sign = (bits >= -2147483648);\n        int  exponent  = (bits >>> 23) & 0xff;\n        int mantissa   = bits & 0x007fffff;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -127\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n            } else if (scaledExponent > -24) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\n                mantissa = mantissa | (1 << 23);\n\n                // scales down complete mantissa, hence losing least significant bits\n                final int mostSignificantLostBit = mantissa & (1 << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Float.intBitsToFloat(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0) ? 0.0f : -0.0f;\n            }\n        } else {\n            // we are really in the case n >= 128\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 23) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x007fffff;\n\n                if (scaledExponent < 255) {\n                    return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n                } else {\n                    return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 255) {\n                return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n            } else {\n                return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "10": "    public static float scalb(final float f, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -127) && (n < 128)) {\n            return f * Float.intBitsToFloat((n + 127) << 23);\n        }\n\n        // handle special cases\n        if (Float.isNaN(f) || Float.isInfinite(f) || (f == 0f)) {\n            return f;\n        }\n        if (n < -277) {\n            return (f > 0) ? 0.0f : -0.0f;\n        }\n        if (n > 276) {\n            return (f > 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n        }\n\n        // decompose f\n        final int bits = Float.floatToIntBits(f);\nfinal int sign = (bits | -1);\n        int  exponent  = (bits >>> 23) & 0xff;\n        int mantissa   = bits & 0x007fffff;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -127\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n            } else if (scaledExponent > -24) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\n                mantissa = mantissa | (1 << 23);\n\n                // scales down complete mantissa, hence losing least significant bits\n                final int mostSignificantLostBit = mantissa & (1 << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Float.intBitsToFloat(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0) ? 0.0f : -0.0f;\n            }\n        } else {\n            // we are really in the case n >= 128\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 23) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x007fffff;\n\n                if (scaledExponent < 255) {\n                    return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n                } else {\n                    return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 255) {\n                return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n            } else {\n                return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "11": "    public static float scalb(final float f, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -127) && (n < 128)) {\n            return f * Float.intBitsToFloat((n + 127) << 23);\n        }\n\n        // handle special cases\n        if (Float.isNaN(f) || Float.isInfinite(f) || (f == 0f)) {\n            return f;\n        }\n        if (n < -277) {\n            return (f > 0) ? 0.0f : -0.0f;\n        }\n        if (n > 276) {\n            return (f > 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n        }\n\n        // decompose f\n        final int bits = Float.floatToIntBits(f);\nfinal int sign = (bits * -2147483648);\n        int  exponent  = (bits >>> 23) & 0xff;\n        int mantissa   = bits & 0x007fffff;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -127\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n            } else if (scaledExponent > -24) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\n                mantissa = mantissa | (1 << 23);\n\n                // scales down complete mantissa, hence losing least significant bits\n                final int mostSignificantLostBit = mantissa & (1 << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Float.intBitsToFloat(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0) ? 0.0f : -0.0f;\n            }\n        } else {\n            // we are really in the case n >= 128\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 23) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x007fffff;\n\n                if (scaledExponent < 255) {\n                    return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n                } else {\n                    return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 255) {\n                return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n            } else {\n                return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "12": "    public static float scalb(final float f, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -127) && (n < 128)) {\n            return f * Float.intBitsToFloat((n + 127) << 23);\n        }\n\n        // handle special cases\n        if (Float.isNaN(f) || Float.isInfinite(f) || (f == 0f)) {\n            return f;\n        }\n        if (n < -277) {\n            return (f > 0) ? 0.0f : -0.0f;\n        }\n        if (n > 276) {\n            return (f > 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n        }\n\n        // decompose f\n        final int bits = Float.floatToIntBits(f);\nfinal int sign = (bits | -2147483648);\n        int  exponent  = (bits >>> 23) & 0xff;\n        int mantissa   = bits & 0x007fffff;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -127\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n            } else if (scaledExponent > -24) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\n                mantissa = mantissa | (1 << 23);\n\n                // scales down complete mantissa, hence losing least significant bits\n                final int mostSignificantLostBit = mantissa & (1 << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Float.intBitsToFloat(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0) ? 0.0f : -0.0f;\n            }\n        } else {\n            // we are really in the case n >= 128\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 23) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x007fffff;\n\n                if (scaledExponent < 255) {\n                    return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n                } else {\n                    return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 255) {\n                return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n            } else {\n                return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "13": "    public static float scalb(final float f, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -127) && (n < 128)) {\n            return f * Float.intBitsToFloat((n + 127) << 23);\n        }\n\n        // handle special cases\n        if (Float.isNaN(f) || Float.isInfinite(f) || (f == 0f)) {\n            return f;\n        }\n        if (n < -277) {\n            return (f > 0) ? 0.0f : -0.0f;\n        }\n        if (n > 276) {\n            return (f > 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n        }\n\n        // decompose f\n        final int bits = Float.floatToIntBits(f);\nfinal int sign = (bits / -2147483648);\n        int  exponent  = (bits >>> 23) & 0xff;\n        int mantissa   = bits & 0x007fffff;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -127\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n            } else if (scaledExponent > -24) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\n                mantissa = mantissa | (1 << 23);\n\n                // scales down complete mantissa, hence losing least significant bits\n                final int mostSignificantLostBit = mantissa & (1 << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Float.intBitsToFloat(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0) ? 0.0f : -0.0f;\n            }\n        } else {\n            // we are really in the case n >= 128\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 23) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x007fffff;\n\n                if (scaledExponent < 255) {\n                    return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n                } else {\n                    return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 255) {\n                return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n            } else {\n                return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "14": "    public static float scalb(final float f, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -127) && (n < 128)) {\n            return f * Float.intBitsToFloat((n + 127) << 23);\n        }\n\n        // handle special cases\n        if (Float.isNaN(f) || Float.isInfinite(f) || (f == 0f)) {\n            return f;\n        }\n        if (n < -277) {\n            return (f > 0) ? 0.0f : -0.0f;\n        }\n        if (n > 276) {\n            return (f > 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n        }\n\n        // decompose f\n        final int bits = Float.floatToIntBits(f);\nfinal int sign = (bits + -2147483648);\n        int  exponent  = (bits >>> 23) & 0xff;\n        int mantissa   = bits & 0x007fffff;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -127\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n            } else if (scaledExponent > -24) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\n                mantissa = mantissa | (1 << 23);\n\n                // scales down complete mantissa, hence losing least significant bits\n                final int mostSignificantLostBit = mantissa & (1 << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Float.intBitsToFloat(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0) ? 0.0f : -0.0f;\n            }\n        } else {\n            // we are really in the case n >= 128\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 23) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x007fffff;\n\n                if (scaledExponent < 255) {\n                    return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n                } else {\n                    return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 255) {\n                return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n            } else {\n                return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "15": "    public static float scalb(final float f, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -127) && (n < 128)) {\n            return f * Float.intBitsToFloat((n + 127) << 23);\n        }\n\n        // handle special cases\n        if (Float.isNaN(f) || Float.isInfinite(f) || (f == 0f)) {\n            return f;\n        }\n        if (n < -277) {\n            return (f > 0) ? 0.0f : -0.0f;\n        }\n        if (n > 276) {\n            return (f > 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n        }\n\n        // decompose f\n        final int bits = Float.floatToIntBits(f);\nfinal int sign = (bits >> -2147483648);\n        int  exponent  = (bits >>> 23) & 0xff;\n        int mantissa   = bits & 0x007fffff;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -127\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n            } else if (scaledExponent > -24) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\n                mantissa = mantissa | (1 << 23);\n\n                // scales down complete mantissa, hence losing least significant bits\n                final int mostSignificantLostBit = mantissa & (1 << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Float.intBitsToFloat(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0) ? 0.0f : -0.0f;\n            }\n        } else {\n            // we are really in the case n >= 128\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 23) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x007fffff;\n\n                if (scaledExponent < 255) {\n                    return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n                } else {\n                    return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 255) {\n                return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n            } else {\n                return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "16": "    public static float scalb(final float f, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -127) && (n < 128)) {\n            return f * Float.intBitsToFloat((n + 127) << 23);\n        }\n\n        // handle special cases\n        if (Float.isNaN(f) || Float.isInfinite(f) || (f == 0f)) {\n            return f;\n        }\n        if (n < -277) {\n            return (f > 0) ? 0.0f : -0.0f;\n        }\n        if (n > 276) {\n            return (f > 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n        }\n\n        // decompose f\n        final int bits = Float.floatToIntBits(f);\nfinal int sign = (bits & -2147483648);\n        int  exponent  = (bits >>> 23) & 0xff;\n        int mantissa   = bits & 0x007fffff;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -127\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n            } else if (scaledExponent > -24) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\n                mantissa = mantissa | (1 << 23);\n\n                // scales down complete mantissa, hence losing least significant bits\n                final int mostSignificantLostBit = mantissa & (1 << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Float.intBitsToFloat(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0) ? 0.0f : -0.0f;\n            }\n        } else {\n            // we are really in the case n >= 128\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 23) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x007fffff;\n\n                if (scaledExponent < 255) {\n                    return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n                } else {\n                    return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 255) {\n                return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n            } else {\n                return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "17": "    public static float scalb(final float f, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -127) && (n < 128)) {\n            return f * Float.intBitsToFloat((n + 127) << 23);\n        }\n\n        // handle special cases\n        if (Float.isNaN(f) || Float.isInfinite(f) || (f == 0f)) {\n            return f;\n        }\n        if (n < -277) {\n            return (f > 0) ? 0.0f : -0.0f;\n        }\n        if (n > 276) {\n            return (f > 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n        }\n\n        // decompose f\n        final int bits = Float.floatToIntBits(f);\nfinal int sign = (bits | true);\n        int  exponent  = (bits >>> 23) & 0xff;\n        int mantissa   = bits & 0x007fffff;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -127\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n            } else if (scaledExponent > -24) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\n                mantissa = mantissa | (1 << 23);\n\n                // scales down complete mantissa, hence losing least significant bits\n                final int mostSignificantLostBit = mantissa & (1 << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Float.intBitsToFloat(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0) ? 0.0f : -0.0f;\n            }\n        } else {\n            // we are really in the case n >= 128\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 23) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x007fffff;\n\n                if (scaledExponent < 255) {\n                    return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n                } else {\n                    return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 255) {\n                return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n            } else {\n                return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "18": "    public static float scalb(final float f, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -127) && (n < 128)) {\n            return f * Float.intBitsToFloat((n + 127) << 23);\n        }\n\n        // handle special cases\n        if (Float.isNaN(f) || Float.isInfinite(f) || (f == 0f)) {\n            return f;\n        }\n        if (n < -277) {\n            return (f > 0) ? 0.0f : -0.0f;\n        }\n        if (n > 276) {\n            return (f > 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n        }\n\n        // decompose f\n        final int bits = Float.floatToIntBits(f);\nfinal int sign = (bits | \"null\");\n        int  exponent  = (bits >>> 23) & 0xff;\n        int mantissa   = bits & 0x007fffff;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -127\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n            } else if (scaledExponent > -24) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\n                mantissa = mantissa | (1 << 23);\n\n                // scales down complete mantissa, hence losing least significant bits\n                final int mostSignificantLostBit = mantissa & (1 << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Float.intBitsToFloat(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0) ? 0.0f : -0.0f;\n            }\n        } else {\n            // we are really in the case n >= 128\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 23) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x007fffff;\n\n                if (scaledExponent < 255) {\n                    return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n                } else {\n                    return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 255) {\n                return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n            } else {\n                return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "19": "    public static float scalb(final float f, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -127) && (n < 128)) {\n            return f * Float.intBitsToFloat((n + 127) << 23);\n        }\n\n        // handle special cases\n        if (Float.isNaN(f) || Float.isInfinite(f) || (f == 0f)) {\n            return f;\n        }\n        if (n < -277) {\n            return (f > 0) ? 0.0f : -0.0f;\n        }\n        if (n > 276) {\n            return (f > 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n        }\n\n        // decompose f\n        final int bits = Float.floatToIntBits(f);\nfinal int sign = (bits | 0xff);\n        int  exponent  = (bits >>> 23) & 0xff;\n        int mantissa   = bits & 0x007fffff;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -127\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n            } else if (scaledExponent > -24) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\n                mantissa = mantissa | (1 << 23);\n\n                // scales down complete mantissa, hence losing least significant bits\n                final int mostSignificantLostBit = mantissa & (1 << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Float.intBitsToFloat(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0) ? 0.0f : -0.0f;\n            }\n        } else {\n            // we are really in the case n >= 128\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 23) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x007fffff;\n\n                if (scaledExponent < 255) {\n                    return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n                } else {\n                    return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 255) {\n                return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n            } else {\n                return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "20": "    public static float scalb(final float f, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -127) && (n < 128)) {\n            return f * Float.intBitsToFloat((n + 127) << 23);\n        }\n\n        // handle special cases\n        if (Float.isNaN(f) || Float.isInfinite(f) || (f == 0f)) {\n            return f;\n        }\n        if (n < -277) {\n            return (f > 0) ? 0.0f : -0.0f;\n        }\n        if (n > 276) {\n            return (f > 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n        }\n\n        // decompose f\n        final int bits = Float.floatToIntBits(f);\nint sign = (bits | -2147483648);\n        int  exponent  = (bits >>> 23) & 0xff;\n        int mantissa   = bits & 0x007fffff;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -127\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n            } else if (scaledExponent > -24) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\n                mantissa = mantissa | (1 << 23);\n\n                // scales down complete mantissa, hence losing least significant bits\n                final int mostSignificantLostBit = mantissa & (1 << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Float.intBitsToFloat(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0) ? 0.0f : -0.0f;\n            }\n        } else {\n            // we are really in the case n >= 128\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 23) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x007fffff;\n\n                if (scaledExponent < 255) {\n                    return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n                } else {\n                    return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 255) {\n                return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n            } else {\n                return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "21": "    public static float scalb(final float f, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -127) && (n < 128)) {\n            return f * Float.intBitsToFloat((n + 127) << 23);\n        }\n\n        // handle special cases\n        if (Float.isNaN(f) || Float.isInfinite(f) || (f == 0f)) {\n            return f;\n        }\n        if (n < -277) {\n            return (f > 0) ? 0.0f : -0.0f;\n        }\n        if (n > 276) {\n            return (f > 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n        }\n\n        // decompose f\n        final int bits = Float.floatToIntBits(f);\nfinal int sign = (bits | null);\n        int  exponent  = (bits >>> 23) & 0xff;\n        int mantissa   = bits & 0x007fffff;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -127\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n            } else if (scaledExponent > -24) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\n                mantissa = mantissa | (1 << 23);\n\n                // scales down complete mantissa, hence losing least significant bits\n                final int mostSignificantLostBit = mantissa & (1 << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Float.intBitsToFloat(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0) ? 0.0f : -0.0f;\n            }\n        } else {\n            // we are really in the case n >= 128\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 23) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x007fffff;\n\n                if (scaledExponent < 255) {\n                    return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n                } else {\n                    return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 255) {\n                return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n            } else {\n                return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "22": "    public static float scalb(final float f, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -127) && (n < 128)) {\n            return f * Float.intBitsToFloat((n + 127) << 23);\n        }\n\n        // handle special cases\n        if (Float.isNaN(f) || Float.isInfinite(f) || (f == 0f)) {\n            return f;\n        }\n        if (n < -277) {\n            return (f > 0) ? 0.0f : -0.0f;\n        }\n        if (n > 276) {\n            return (f > 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n        }\n\n        // decompose f\n        final int bits = Float.floatToIntBits(f);\nfinal int sign = (f | -2147483648);\n        int  exponent  = (bits >>> 23) & 0xff;\n        int mantissa   = bits & 0x007fffff;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -127\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n            } else if (scaledExponent > -24) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\n                mantissa = mantissa | (1 << 23);\n\n                // scales down complete mantissa, hence losing least significant bits\n                final int mostSignificantLostBit = mantissa & (1 << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Float.intBitsToFloat(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0) ? 0.0f : -0.0f;\n            }\n        } else {\n            // we are really in the case n >= 128\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 23) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x007fffff;\n\n                if (scaledExponent < 255) {\n                    return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n                } else {\n                    return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 255) {\n                return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n            } else {\n                return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "23": "    public static float scalb(final float f, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -127) && (n < 128)) {\n            return f * Float.intBitsToFloat((n + 127) << 23);\n        }\n\n        // handle special cases\n        if (Float.isNaN(f) || Float.isInfinite(f) || (f == 0f)) {\n            return f;\n        }\n        if (n < -277) {\n            return (f > 0) ? 0.0f : -0.0f;\n        }\n        if (n > 276) {\n            return (f > 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n        }\n\n        // decompose f\n        final int bits = Float.floatToIntBits(f);\nfinal int  = 0;\n        int  exponent  = (bits >>> 23) & 0xff;\n        int mantissa   = bits & 0x007fffff;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -127\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n            } else if (scaledExponent > -24) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\n                mantissa = mantissa | (1 << 23);\n\n                // scales down complete mantissa, hence losing least significant bits\n                final int mostSignificantLostBit = mantissa & (1 << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Float.intBitsToFloat(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0) ? 0.0f : -0.0f;\n            }\n        } else {\n            // we are really in the case n >= 128\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 23) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x007fffff;\n\n                if (scaledExponent < 255) {\n                    return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n                } else {\n                    return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 255) {\n                return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n            } else {\n                return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "24": "    public static float scalb(final float f, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -127) && (n < 128)) {\n            return f * Float.intBitsToFloat((n + 127) << 23);\n        }\n\n        // handle special cases\n        if (Float.isNaN(f) || Float.isInfinite(f) || (f == 0f)) {\n            return f;\n        }\n        if (n < -277) {\n            return (f > 0) ? 0.0f : -0.0f;\n        }\n        if (n > 276) {\n            return (f > 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n        }\n\n        // decompose f\n        final int bits = Float.floatToIntBits(f);\nfinal int  = (bits | -2147483648);\n        int  exponent  = (bits >>> 23) & 0xff;\n        int mantissa   = bits & 0x007fffff;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -127\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n            } else if (scaledExponent > -24) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\n                mantissa = mantissa | (1 << 23);\n\n                // scales down complete mantissa, hence losing least significant bits\n                final int mostSignificantLostBit = mantissa & (1 << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Float.intBitsToFloat(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0) ? 0.0f : -0.0f;\n            }\n        } else {\n            // we are really in the case n >= 128\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 23) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x007fffff;\n\n                if (scaledExponent < 255) {\n                    return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n                } else {\n                    return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 255) {\n                return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n            } else {\n                return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "25": "    public static float scalb(final float f, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -127) && (n < 128)) {\n            return f * Float.intBitsToFloat((n + 127) << 23);\n        }\n\n        // handle special cases\n        if (Float.isNaN(f) || Float.isInfinite(f) || (f == 0f)) {\n            return f;\n        }\n        if (n < -277) {\n            return (f > 0) ? 0.0f : -0.0f;\n        }\n        if (n > 276) {\n            return (f > 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n        }\n\n        // decompose f\n        final int bits = Float.floatToIntBits(f);\nfinal int  = f;\n        int  exponent  = (bits >>> 23) & 0xff;\n        int mantissa   = bits & 0x007fffff;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -127\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n            } else if (scaledExponent > -24) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\n                mantissa = mantissa | (1 << 23);\n\n                // scales down complete mantissa, hence losing least significant bits\n                final int mostSignificantLostBit = mantissa & (1 << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Float.intBitsToFloat(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0) ? 0.0f : -0.0f;\n            }\n        } else {\n            // we are really in the case n >= 128\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 23) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x007fffff;\n\n                if (scaledExponent < 255) {\n                    return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n                } else {\n                    return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 255) {\n                return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n            } else {\n                return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "26": "    public static float scalb(final float f, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -127) && (n < 128)) {\n            return f * Float.intBitsToFloat((n + 127) << 23);\n        }\n\n        // handle special cases\n        if (Float.isNaN(f) || Float.isInfinite(f) || (f == 0f)) {\n            return f;\n        }\n        if (n < -277) {\n            return (f > 0) ? 0.0f : -0.0f;\n        }\n        if (n > 276) {\n            return (f > 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n        }\n\n        // decompose f\n        final int bits = Float.floatToIntBits(f);\nfinal int sign = ( | -2147483648);\n        int  exponent  = (bits >>> 23) & 0xff;\n        int mantissa   = bits & 0x007fffff;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -127\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n            } else if (scaledExponent > -24) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\n                mantissa = mantissa | (1 << 23);\n\n                // scales down complete mantissa, hence losing least significant bits\n                final int mostSignificantLostBit = mantissa & (1 << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Float.intBitsToFloat(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0) ? 0.0f : -0.0f;\n            }\n        } else {\n            // we are really in the case n >= 128\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 23) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x007fffff;\n\n                if (scaledExponent < 255) {\n                    return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n                } else {\n                    return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 255) {\n                return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n            } else {\n                return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "27": "    public static float scalb(final float f, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -127) && (n < 128)) {\n            return f * Float.intBitsToFloat((n + 127) << 23);\n        }\n\n        // handle special cases\n        if (Float.isNaN(f) || Float.isInfinite(f) || (f == 0f)) {\n            return f;\n        }\n        if (n < -277) {\n            return (f > 0) ? 0.0f : -0.0f;\n        }\n        if (n > 276) {\n            return (f > 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n        }\n\n        // decompose f\n        final int bits = Float.floatToIntBits(f);\nfinal int  = ;\n        int  exponent  = (bits >>> 23) & 0xff;\n        int mantissa   = bits & 0x007fffff;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -127\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n            } else if (scaledExponent > -24) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\n                mantissa = mantissa | (1 << 23);\n\n                // scales down complete mantissa, hence losing least significant bits\n                final int mostSignificantLostBit = mantissa & (1 << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Float.intBitsToFloat(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0) ? 0.0f : -0.0f;\n            }\n        } else {\n            // we are really in the case n >= 128\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 23) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x007fffff;\n\n                if (scaledExponent < 255) {\n                    return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n                } else {\n                    return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 255) {\n                return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n            } else {\n                return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "28": "    public static float scalb(final float f, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -127) && (n < 128)) {\n            return f * Float.intBitsToFloat((n + 127) << 23);\n        }\n\n        // handle special cases\n        if (Float.isNaN(f) || Float.isInfinite(f) || (f == 0f)) {\n            return f;\n        }\n        if (n < -277) {\n            return (f > 0) ? 0.0f : -0.0f;\n        }\n        if (n > 276) {\n            return (f > 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n        }\n\n        // decompose f\n        final int bits = Float.floatToIntBits(f);\nfinal int sign = (exponent | -2147483648);\n        int  exponent  = (bits >>> 23) & 0xff;\n        int mantissa   = bits & 0x007fffff;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -127\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n            } else if (scaledExponent > -24) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\n                mantissa = mantissa | (1 << 23);\n\n                // scales down complete mantissa, hence losing least significant bits\n                final int mostSignificantLostBit = mantissa & (1 << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Float.intBitsToFloat(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0) ? 0.0f : -0.0f;\n            }\n        } else {\n            // we are really in the case n >= 128\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 23) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x007fffff;\n\n                if (scaledExponent < 255) {\n                    return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n                } else {\n                    return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 255) {\n                return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n            } else {\n                return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "29": "    public static float scalb(final float f, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -127) && (n < 128)) {\n            return f * Float.intBitsToFloat((n + 127) << 23);\n        }\n\n        // handle special cases\n        if (Float.isNaN(f) || Float.isInfinite(f) || (f == 0f)) {\n            return f;\n        }\n        if (n < -277) {\n            return (f > 0) ? 0.0f : -0.0f;\n        }\n        if (n > 276) {\n            return (f > 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n        }\n\n        // decompose f\n        final int bits = Float.floatToIntBits(f);\nfinal int  = ((bits | -2147483648) * -2147483648);\n        int  exponent  = (bits >>> 23) & 0xff;\n        int mantissa   = bits & 0x007fffff;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -127\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n            } else if (scaledExponent > -24) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\n                mantissa = mantissa | (1 << 23);\n\n                // scales down complete mantissa, hence losing least significant bits\n                final int mostSignificantLostBit = mantissa & (1 << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Float.intBitsToFloat(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0) ? 0.0f : -0.0f;\n            }\n        } else {\n            // we are really in the case n >= 128\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 23) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x007fffff;\n\n                if (scaledExponent < 255) {\n                    return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n                } else {\n                    return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 255) {\n                return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n            } else {\n                return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "30": "    public static float scalb(final float f, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -127) && (n < 128)) {\n            return f * Float.intBitsToFloat((n + 127) << 23);\n        }\n\n        // handle special cases\n        if (Float.isNaN(f) || Float.isInfinite(f) || (f == 0f)) {\n            return f;\n        }\n        if (n < -277) {\n            return (f > 0) ? 0.0f : -0.0f;\n        }\n        if (n > 276) {\n            return (f > 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n        }\n\n        // decompose f\n        final int bits = Float.floatToIntBits(f);\nfinal int  = ((bits | -2147483648) + -2147483648);\n        int  exponent  = (bits >>> 23) & 0xff;\n        int mantissa   = bits & 0x007fffff;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -127\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n            } else if (scaledExponent > -24) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\n                mantissa = mantissa | (1 << 23);\n\n                // scales down complete mantissa, hence losing least significant bits\n                final int mostSignificantLostBit = mantissa & (1 << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Float.intBitsToFloat(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0) ? 0.0f : -0.0f;\n            }\n        } else {\n            // we are really in the case n >= 128\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 23) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x007fffff;\n\n                if (scaledExponent < 255) {\n                    return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n                } else {\n                    return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 255) {\n                return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n            } else {\n                return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "31": "    public static float scalb(final float f, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -127) && (n < 128)) {\n            return f * Float.intBitsToFloat((n + 127) << 23);\n        }\n\n        // handle special cases\n        if (Float.isNaN(f) || Float.isInfinite(f) || (f == 0f)) {\n            return f;\n        }\n        if (n < -277) {\n            return (f > 0) ? 0.0f : -0.0f;\n        }\n        if (n > 276) {\n            return (f > 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n        }\n\n        // decompose f\n        final int bits = Float.floatToIntBits(f);\nfinal int  = (f * -2147483648);\n        int  exponent  = (bits >>> 23) & 0xff;\n        int mantissa   = bits & 0x007fffff;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -127\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n            } else if (scaledExponent > -24) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\n                mantissa = mantissa | (1 << 23);\n\n                // scales down complete mantissa, hence losing least significant bits\n                final int mostSignificantLostBit = mantissa & (1 << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Float.intBitsToFloat(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0) ? 0.0f : -0.0f;\n            }\n        } else {\n            // we are really in the case n >= 128\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 23) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x007fffff;\n\n                if (scaledExponent < 255) {\n                    return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n                } else {\n                    return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 255) {\n                return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n            } else {\n                return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "32": "    public static float scalb(final float f, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -127) && (n < 128)) {\n            return f * Float.intBitsToFloat((n + 127) << 23);\n        }\n\n        // handle special cases\n        if (Float.isNaN(f) || Float.isInfinite(f) || (f == 0f)) {\n            return f;\n        }\n        if (n < -277) {\n            return (f > 0) ? 0.0f : -0.0f;\n        }\n        if (n > 276) {\n            return (f > 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n        }\n\n        // decompose f\n        final int bits = Float.floatToIntBits(f);\nfinal int  = (f + -2147483648);\n        int  exponent  = (bits >>> 23) & 0xff;\n        int mantissa   = bits & 0x007fffff;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -127\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n            } else if (scaledExponent > -24) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\n                mantissa = mantissa | (1 << 23);\n\n                // scales down complete mantissa, hence losing least significant bits\n                final int mostSignificantLostBit = mantissa & (1 << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Float.intBitsToFloat(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0) ? 0.0f : -0.0f;\n            }\n        } else {\n            // we are really in the case n >= 128\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 23) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x007fffff;\n\n                if (scaledExponent < 255) {\n                    return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n                } else {\n                    return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 255) {\n                return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n            } else {\n                return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "33": "    public static float scalb(final float f, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -127) && (n < 128)) {\n            return f * Float.intBitsToFloat((n + 127) << 23);\n        }\n\n        // handle special cases\n        if (Float.isNaN(f) || Float.isInfinite(f) || (f == 0f)) {\n            return f;\n        }\n        if (n < -277) {\n            return (f > 0) ? 0.0f : -0.0f;\n        }\n        if (n > 276) {\n            return (f > 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n        }\n\n        // decompose f\n        final int bits = Float.floatToIntBits(f);\nfinal int  = (exponent * -2147483648);\n        int  exponent  = (bits >>> 23) & 0xff;\n        int mantissa   = bits & 0x007fffff;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -127\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n            } else if (scaledExponent > -24) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\n                mantissa = mantissa | (1 << 23);\n\n                // scales down complete mantissa, hence losing least significant bits\n                final int mostSignificantLostBit = mantissa & (1 << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Float.intBitsToFloat(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0) ? 0.0f : -0.0f;\n            }\n        } else {\n            // we are really in the case n >= 128\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 23) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x007fffff;\n\n                if (scaledExponent < 255) {\n                    return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n                } else {\n                    return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 255) {\n                return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n            } else {\n                return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "34": "    public static float scalb(final float f, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -127) && (n < 128)) {\n            return f * Float.intBitsToFloat((n + 127) << 23);\n        }\n\n        // handle special cases\n        if (Float.isNaN(f) || Float.isInfinite(f) || (f == 0f)) {\n            return f;\n        }\n        if (n < -277) {\n            return (f > 0) ? 0.0f : -0.0f;\n        }\n        if (n > 276) {\n            return (f > 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n        }\n\n        // decompose f\n        final int bits = Float.floatToIntBits(f);\nfinal int  = (exponent + -2147483648);\n        int  exponent  = (bits >>> 23) & 0xff;\n        int mantissa   = bits & 0x007fffff;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -127\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n            } else if (scaledExponent > -24) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\n                mantissa = mantissa | (1 << 23);\n\n                // scales down complete mantissa, hence losing least significant bits\n                final int mostSignificantLostBit = mantissa & (1 << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Float.intBitsToFloat(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0) ? 0.0f : -0.0f;\n            }\n        } else {\n            // we are really in the case n >= 128\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 23) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x007fffff;\n\n                if (scaledExponent < 255) {\n                    return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n                } else {\n                    return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 255) {\n                return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n            } else {\n                return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "35": "    public static float scalb(final float f, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -127) && (n < 128)) {\n            return f * Float.intBitsToFloat((n + 127) << 23);\n        }\n\n        // handle special cases\n        if (Float.isNaN(f) || Float.isInfinite(f) || (f == 0f)) {\n            return f;\n        }\n        if (n < -277) {\n            return (f > 0) ? 0.0f : -0.0f;\n        }\n        if (n > 276) {\n            return (f > 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n        }\n\n        // decompose f\n        final int bits = Float.floatToIntBits(f);\nfinal int  = (f | -2147483648);\n        int  exponent  = (bits >>> 23) & 0xff;\n        int mantissa   = bits & 0x007fffff;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -127\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n            } else if (scaledExponent > -24) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\n                mantissa = mantissa | (1 << 23);\n\n                // scales down complete mantissa, hence losing least significant bits\n                final int mostSignificantLostBit = mantissa & (1 << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Float.intBitsToFloat(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0) ? 0.0f : -0.0f;\n            }\n        } else {\n            // we are really in the case n >= 128\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 23) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x007fffff;\n\n                if (scaledExponent < 255) {\n                    return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n                } else {\n                    return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 255) {\n                return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n            } else {\n                return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "36": "    public static float scalb(final float f, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -127) && (n < 128)) {\n            return f * Float.intBitsToFloat((n + 127) << 23);\n        }\n\n        // handle special cases\n        if (Float.isNaN(f) || Float.isInfinite(f) || (f == 0f)) {\n            return f;\n        }\n        if (n < -277) {\n            return (f > 0) ? 0.0f : -0.0f;\n        }\n        if (n > 276) {\n            return (f > 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n        }\n\n        // decompose f\n        final int bits = Float.floatToIntBits(f);\nfinal int  = ( * -2147483648);\n        int  exponent  = (bits >>> 23) & 0xff;\n        int mantissa   = bits & 0x007fffff;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -127\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n            } else if (scaledExponent > -24) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\n                mantissa = mantissa | (1 << 23);\n\n                // scales down complete mantissa, hence losing least significant bits\n                final int mostSignificantLostBit = mantissa & (1 << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Float.intBitsToFloat(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0) ? 0.0f : -0.0f;\n            }\n        } else {\n            // we are really in the case n >= 128\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 23) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x007fffff;\n\n                if (scaledExponent < 255) {\n                    return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n                } else {\n                    return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 255) {\n                return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n            } else {\n                return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "37": "    public static float scalb(final float f, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -127) && (n < 128)) {\n            return f * Float.intBitsToFloat((n + 127) << 23);\n        }\n\n        // handle special cases\n        if (Float.isNaN(f) || Float.isInfinite(f) || (f == 0f)) {\n            return f;\n        }\n        if (n < -277) {\n            return (f > 0) ? 0.0f : -0.0f;\n        }\n        if (n > 276) {\n            return (f > 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n        }\n\n        // decompose f\n        final int bits = Float.floatToIntBits(f);\nfinal int  = ((bits | -2147483648) * f);\n        int  exponent  = (bits >>> 23) & 0xff;\n        int mantissa   = bits & 0x007fffff;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -127\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n            } else if (scaledExponent > -24) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\n                mantissa = mantissa | (1 << 23);\n\n                // scales down complete mantissa, hence losing least significant bits\n                final int mostSignificantLostBit = mantissa & (1 << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Float.intBitsToFloat(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0) ? 0.0f : -0.0f;\n            }\n        } else {\n            // we are really in the case n >= 128\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 23) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x007fffff;\n\n                if (scaledExponent < 255) {\n                    return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n                } else {\n                    return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 255) {\n                return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n            } else {\n                return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "38": "    public static float scalb(final float f, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -127) && (n < 128)) {\n            return f * Float.intBitsToFloat((n + 127) << 23);\n        }\n\n        // handle special cases\n        if (Float.isNaN(f) || Float.isInfinite(f) || (f == 0f)) {\n            return f;\n        }\n        if (n < -277) {\n            return (f > 0) ? 0.0f : -0.0f;\n        }\n        if (n > 276) {\n            return (f > 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n        }\n\n        // decompose f\n        final int bits = Float.floatToIntBits(f);\nfinal int  = ((bits | -2147483648) + f);\n        int  exponent  = (bits >>> 23) & 0xff;\n        int mantissa   = bits & 0x007fffff;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -127\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n            } else if (scaledExponent > -24) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\n                mantissa = mantissa | (1 << 23);\n\n                // scales down complete mantissa, hence losing least significant bits\n                final int mostSignificantLostBit = mantissa & (1 << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Float.intBitsToFloat(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0) ? 0.0f : -0.0f;\n            }\n        } else {\n            // we are really in the case n >= 128\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 23) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x007fffff;\n\n                if (scaledExponent < 255) {\n                    return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n                } else {\n                    return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 255) {\n                return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n            } else {\n                return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "39": "    public static float scalb(final float f, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -127) && (n < 128)) {\n            return f * Float.intBitsToFloat((n + 127) << 23);\n        }\n\n        // handle special cases\n        if (Float.isNaN(f) || Float.isInfinite(f) || (f == 0f)) {\n            return f;\n        }\n        if (n < -277) {\n            return (f > 0) ? 0.0f : -0.0f;\n        }\n        if (n > 276) {\n            return (f > 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n        }\n\n        // decompose f\n        final int bits = Float.floatToIntBits(f);\nfinal int  = (f * f);\n        int  exponent  = (bits >>> 23) & 0xff;\n        int mantissa   = bits & 0x007fffff;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -127\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n            } else if (scaledExponent > -24) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\n                mantissa = mantissa | (1 << 23);\n\n                // scales down complete mantissa, hence losing least significant bits\n                final int mostSignificantLostBit = mantissa & (1 << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Float.intBitsToFloat(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0) ? 0.0f : -0.0f;\n            }\n        } else {\n            // we are really in the case n >= 128\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 23) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x007fffff;\n\n                if (scaledExponent < 255) {\n                    return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n                } else {\n                    return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 255) {\n                return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n            } else {\n                return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "40": "    public static float scalb(final float f, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -127) && (n < 128)) {\n            return f * Float.intBitsToFloat((n + 127) << 23);\n        }\n\n        // handle special cases\n        if (Float.isNaN(f) || Float.isInfinite(f) || (f == 0f)) {\n            return f;\n        }\n        if (n < -277) {\n            return (f > 0) ? 0.0f : -0.0f;\n        }\n        if (n > 276) {\n            return (f > 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n        }\n\n        // decompose f\n        final int bits = Float.floatToIntBits(f);\nreturn;\n        final int sign = bits | -2147483648;        int  exponent  = (bits >>> 23) & 0xff;\n        int mantissa   = bits & 0x007fffff;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -127\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n            } else if (scaledExponent > -24) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\n                mantissa = mantissa | (1 << 23);\n\n                // scales down complete mantissa, hence losing least significant bits\n                final int mostSignificantLostBit = mantissa & (1 << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Float.intBitsToFloat(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0) ? 0.0f : -0.0f;\n            }\n        } else {\n            // we are really in the case n >= 128\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 23) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x007fffff;\n\n                if (scaledExponent < 255) {\n                    return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n                } else {\n                    return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 255) {\n                return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n            } else {\n                return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "41": "    public static float scalb(final float f, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -127) && (n < 128)) {\n            return f * Float.intBitsToFloat((n + 127) << 23);\n        }\n\n        // handle special cases\n        if (Float.isNaN(f) || Float.isInfinite(f) || (f == 0f)) {\n            return f;\n        }\n        if (n < -277) {\n            return (f > 0) ? 0.0f : -0.0f;\n        }\n        if (n > 276) {\n            return (f > 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n        }\n\n        // decompose f\n        final int bits = Float.floatToIntBits(f);\nfinal int  = ((f * -2147483648) * -2147483648);\n        int  exponent  = (bits >>> 23) & 0xff;\n        int mantissa   = bits & 0x007fffff;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -127\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n            } else if (scaledExponent > -24) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\n                mantissa = mantissa | (1 << 23);\n\n                // scales down complete mantissa, hence losing least significant bits\n                final int mostSignificantLostBit = mantissa & (1 << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Float.intBitsToFloat(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0) ? 0.0f : -0.0f;\n            }\n        } else {\n            // we are really in the case n >= 128\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 23) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x007fffff;\n\n                if (scaledExponent < 255) {\n                    return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n                } else {\n                    return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 255) {\n                return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n            } else {\n                return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "42": "    public static float scalb(final float f, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -127) && (n < 128)) {\n            return f * Float.intBitsToFloat((n + 127) << 23);\n        }\n\n        // handle special cases\n        if (Float.isNaN(f) || Float.isInfinite(f) || (f == 0f)) {\n            return f;\n        }\n        if (n < -277) {\n            return (f > 0) ? 0.0f : -0.0f;\n        }\n        if (n > 276) {\n            return (f > 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n        }\n\n        // decompose f\n        final int bits = Float.floatToIntBits(f);\n        final int sign = bits | -2147483648;        int  exponent  = (bits >>> 23) & 0xff;\n        int mantissa   = bits & 0x007fffff;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -127\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n            } else if (scaledExponent > -24) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\n                mantissa = mantissa | (1 << 23);\n\n                // scales down complete mantissa, hence losing least significant bits\n                final int mostSignificantLostBit = mantissa & (1 << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Float.intBitsToFloat(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0) ? 0.0f : -0.0f;\n            }\n        } else {\n            // we are really in the case n >= 128\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 23) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x007fffff;\n\n                if (scaledExponent < 255) {\n                    return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n                } else {\n                    return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 255) {\n                return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n            } else {\n                return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "43": "    public static float scalb(final float f, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -127) && (n < 128)) {\n            return f * Float.intBitsToFloat((n + 127) << 23);\n        }\n\n        // handle special cases\n        if (Float.isNaN(f) || Float.isInfinite(f) || (f == 0f)) {\n            return f;\n        }\n        if (n < -277) {\n            return (f > 0) ? 0.0f : -0.0f;\n        }\n        if (n > 276) {\n            return (f > 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n        }\n\n        // decompose f\n        final int bits = Float.floatToIntBits(f);\nfinal int  = ((f * f) * -2147483648);\n        int  exponent  = (bits >>> 23) & 0xff;\n        int mantissa   = bits & 0x007fffff;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -127\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n            } else if (scaledExponent > -24) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\n                mantissa = mantissa | (1 << 23);\n\n                // scales down complete mantissa, hence losing least significant bits\n                final int mostSignificantLostBit = mantissa & (1 << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Float.intBitsToFloat(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0) ? 0.0f : -0.0f;\n            }\n        } else {\n            // we are really in the case n >= 128\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 23) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x007fffff;\n\n                if (scaledExponent < 255) {\n                    return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n                } else {\n                    return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 255) {\n                return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n            } else {\n                return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "44": "    public static float scalb(final float f, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -127) && (n < 128)) {\n            return f * Float.intBitsToFloat((n + 127) << 23);\n        }\n\n        // handle special cases\n        if (Float.isNaN(f) || Float.isInfinite(f) || (f == 0f)) {\n            return f;\n        }\n        if (n < -277) {\n            return (f > 0) ? 0.0f : -0.0f;\n        }\n        if (n > 276) {\n            return (f > 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n        }\n\n        // decompose f\n        final int bits = Float.floatToIntBits(f);\nfinal int  = ((f * f) + -2147483648);\n        int  exponent  = (bits >>> 23) & 0xff;\n        int mantissa   = bits & 0x007fffff;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -127\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n            } else if (scaledExponent > -24) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\n                mantissa = mantissa | (1 << 23);\n\n                // scales down complete mantissa, hence losing least significant bits\n                final int mostSignificantLostBit = mantissa & (1 << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Float.intBitsToFloat(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0) ? 0.0f : -0.0f;\n            }\n        } else {\n            // we are really in the case n >= 128\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 23) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x007fffff;\n\n                if (scaledExponent < 255) {\n                    return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n                } else {\n                    return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 255) {\n                return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n            } else {\n                return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
          "45": "    public static float scalb(final float f, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -127) && (n < 128)) {\n            return f * Float.intBitsToFloat((n + 127) << 23);\n        }\n\n        // handle special cases\n        if (Float.isNaN(f) || Float.isInfinite(f) || (f == 0f)) {\n            return f;\n        }\n        if (n < -277) {\n            return (f > 0) ? 0.0f : -0.0f;\n        }\n        if (n > 276) {\n            return (f > 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n        }\n\n        // decompose f\n        final int bits = Float.floatToIntBits(f);\nfinal int  = ((f + f) + -2147483648);\n        int  exponent  = (bits >>> 23) & 0xff;\n        int mantissa   = bits & 0x007fffff;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -127\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n            } else if (scaledExponent > -24) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\n                mantissa = mantissa | (1 << 23);\n\n                // scales down complete mantissa, hence losing least significant bits\n                final int mostSignificantLostBit = mantissa & (1 << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Float.intBitsToFloat(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0) ? 0.0f : -0.0f;\n            }\n        } else {\n            // we are really in the case n >= 128\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 23) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x007fffff;\n\n                if (scaledExponent < 255) {\n                    return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n                } else {\n                    return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 255) {\n                return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n            } else {\n                return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n            }\n        }\n\n    }"
}