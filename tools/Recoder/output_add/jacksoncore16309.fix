{
          "0": "    private int _prependOrWriteCharacterEscape(char[] buffer, int ptr, int end,\n            char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (ptr > 1 && ptr < end) { // fits, just prepend\n                ptr -= 2;\n                buffer[ptr] = '\\\\';\n                buffer[ptr+1] = (char) escCode;\n            } else { // won't fit, write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                ent[1] = (char) escCode;\n                _writer.write(ent, 0, 2);\n            }\n            return ptr;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\n            if (ptr > 5 && ptr < end) { // fits, prepend to buffer\n                ptr -= 6;\n                buffer[ptr++] = '\\\\';\n                buffer[ptr++] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    buffer[ptr++] = HEX_CHARS[hi & 0xF];\n                    ch &= 0xFF;\n                } else {\n                    buffer[ptr++] = '0';\n                    buffer[ptr++] = '0';\n                }\n                buffer[ptr++] = HEX_CHARS[ch >> 4];\n                buffer[ptr] = HEX_CHARS[ch & 0xF];\n                ptr -= 5;\n            } else {\n                // won't fit, flush and write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                _outputHead = _outputTail;\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    int lo = ch & 0xFF;\n                    ent[10] = HEX_CHARS[hi >> 4];\n                    ent[11] = HEX_CHARS[hi & 0xF];\n                    ent[12] = HEX_CHARS[lo >> 4];\n                    ent[13] = HEX_CHARS[lo & 0xF];\n                    _writer.write(ent, 8, 6);\n                } else { // We know it's a control char, so only the last 2 chars are non-0\n                    ent[6] = HEX_CHARS[ch >> 4];\n                    ent[7] = HEX_CHARS[ch & 0xF];\n                    _writer.write(ent, 2, 6);\n                }\n            }\n            return ptr;\n        }\n        String escape;\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (ptr >= len && ptr < end) { // fits in, prepend\n            ptr -= len;\n            escape.getChars(0, len, buffer, ptr);\n        } else { // won't fit, write separately\n            _writer.write(escape);\n        }\n        return ptr;\n    }",
          "1": "    private int _prependOrWriteCharacterEscape(char[] buffer, int ptr, int end,\n            char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (ptr > 1 && ptr < end) { // fits, just prepend\n                ptr -= 2;\n                buffer[ptr] = '\\\\';\n                buffer[ptr+1] = (char) escCode;\n            } else { // won't fit, write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                ent[1] = (char) escCode;\n                _writer.write(ent, 0, 2);\n            }\n            return ptr;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\n            if (ptr > 5 && ptr < end) { // fits, prepend to buffer\n                ptr -= 6;\n                buffer[ptr++] = '\\\\';\n                buffer[ptr++] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\nbuffer[ptr++] = (hi << 4);\n                    buffer[ptr++] = HEX_CHARS[hi & 0xF];\n                    ch &= 0xFF;\n                } else {\n                    buffer[ptr++] = '0';\n                    buffer[ptr++] = '0';\n                }\n                buffer[ptr++] = HEX_CHARS[ch >> 4];\n                buffer[ptr] = HEX_CHARS[ch & 0xF];\n                ptr -= 5;\n            } else {\n                // won't fit, flush and write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                _outputHead = _outputTail;\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    int lo = ch & 0xFF;\n                    ent[10] = HEX_CHARS[hi >> 4];\n                    ent[11] = HEX_CHARS[hi & 0xF];\n                    ent[12] = HEX_CHARS[lo >> 4];\n                    ent[13] = HEX_CHARS[lo & 0xF];\n                    _writer.write(ent, 8, 6);\n                } else { // We know it's a control char, so only the last 2 chars are non-0\n                    ent[6] = HEX_CHARS[ch >> 4];\n                    ent[7] = HEX_CHARS[ch & 0xF];\n                    _writer.write(ent, 2, 6);\n                }\n            }\n            return ptr;\n        }\n        String escape;\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (ptr >= len && ptr < end) { // fits in, prepend\n            ptr -= len;\n            escape.getChars(0, len, buffer, ptr);\n        } else { // won't fit, write separately\n            _writer.write(escape);\n        }\n        return ptr;\n    }",
          "2": "    private int _prependOrWriteCharacterEscape(char[] buffer, int ptr, int end,\n            char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (ptr > 1 && ptr < end) { // fits, just prepend\n                ptr -= 2;\n                buffer[ptr] = '\\\\';\n                buffer[ptr+1] = (char) escCode;\n            } else { // won't fit, write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                ent[1] = (char) escCode;\n                _writer.write(ent, 0, 2);\n            }\n            return ptr;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\n            if (ptr > 5 && ptr < end) { // fits, prepend to buffer\n                ptr -= 6;\n                buffer[ptr++] = '\\\\';\n                buffer[ptr++] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\nbuffer[ptr++] = HEX_CHARS[(hi << 4)];\n                    buffer[ptr++] = HEX_CHARS[hi & 0xF];\n                    ch &= 0xFF;\n                } else {\n                    buffer[ptr++] = '0';\n                    buffer[ptr++] = '0';\n                }\n                buffer[ptr++] = HEX_CHARS[ch >> 4];\n                buffer[ptr] = HEX_CHARS[ch & 0xF];\n                ptr -= 5;\n            } else {\n                // won't fit, flush and write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                _outputHead = _outputTail;\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    int lo = ch & 0xFF;\n                    ent[10] = HEX_CHARS[hi >> 4];\n                    ent[11] = HEX_CHARS[hi & 0xF];\n                    ent[12] = HEX_CHARS[lo >> 4];\n                    ent[13] = HEX_CHARS[lo & 0xF];\n                    _writer.write(ent, 8, 6);\n                } else { // We know it's a control char, so only the last 2 chars are non-0\n                    ent[6] = HEX_CHARS[ch >> 4];\n                    ent[7] = HEX_CHARS[ch & 0xF];\n                    _writer.write(ent, 2, 6);\n                }\n            }\n            return ptr;\n        }\n        String escape;\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (ptr >= len && ptr < end) { // fits in, prepend\n            ptr -= len;\n            escape.getChars(0, len, buffer, ptr);\n        } else { // won't fit, write separately\n            _writer.write(escape);\n        }\n        return ptr;\n    }",
          "3": "    private int _prependOrWriteCharacterEscape(char[] buffer, int ptr, int end,\n            char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (ptr > 1 && ptr < end) { // fits, just prepend\n                ptr -= 2;\n                buffer[ptr] = '\\\\';\n                buffer[ptr+1] = (char) escCode;\n            } else { // won't fit, write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                ent[1] = (char) escCode;\n                _writer.write(ent, 0, 2);\n            }\n            return ptr;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\n            if (ptr > 5 && ptr < end) { // fits, prepend to buffer\n                ptr -= 6;\n                buffer[ptr++] = '\\\\';\n                buffer[ptr++] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\nbuffer[ptr++] = _outputBuffer[(hi << 4)];\n                    buffer[ptr++] = HEX_CHARS[hi & 0xF];\n                    ch &= 0xFF;\n                } else {\n                    buffer[ptr++] = '0';\n                    buffer[ptr++] = '0';\n                }\n                buffer[ptr++] = HEX_CHARS[ch >> 4];\n                buffer[ptr] = HEX_CHARS[ch & 0xF];\n                ptr -= 5;\n            } else {\n                // won't fit, flush and write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                _outputHead = _outputTail;\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    int lo = ch & 0xFF;\n                    ent[10] = HEX_CHARS[hi >> 4];\n                    ent[11] = HEX_CHARS[hi & 0xF];\n                    ent[12] = HEX_CHARS[lo >> 4];\n                    ent[13] = HEX_CHARS[lo & 0xF];\n                    _writer.write(ent, 8, 6);\n                } else { // We know it's a control char, so only the last 2 chars are non-0\n                    ent[6] = HEX_CHARS[ch >> 4];\n                    ent[7] = HEX_CHARS[ch & 0xF];\n                    _writer.write(ent, 2, 6);\n                }\n            }\n            return ptr;\n        }\n        String escape;\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (ptr >= len && ptr < end) { // fits in, prepend\n            ptr -= len;\n            escape.getChars(0, len, buffer, ptr);\n        } else { // won't fit, write separately\n            _writer.write(escape);\n        }\n        return ptr;\n    }",
          "4": "    private int _prependOrWriteCharacterEscape(char[] buffer, int ptr, int end,\n            char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (ptr > 1 && ptr < end) { // fits, just prepend\n                ptr -= 2;\n                buffer[ptr] = '\\\\';\n                buffer[ptr+1] = (char) escCode;\n            } else { // won't fit, write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                ent[1] = (char) escCode;\n                _writer.write(ent, 0, 2);\n            }\n            return ptr;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\n            if (ptr > 5 && ptr < end) { // fits, prepend to buffer\n                ptr -= 6;\n                buffer[ptr++] = '\\\\';\n                buffer[ptr++] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\nbuffer[ptr++] = _entityBuffer[(hi << 4)];\n                    buffer[ptr++] = HEX_CHARS[hi & 0xF];\n                    ch &= 0xFF;\n                } else {\n                    buffer[ptr++] = '0';\n                    buffer[ptr++] = '0';\n                }\n                buffer[ptr++] = HEX_CHARS[ch >> 4];\n                buffer[ptr] = HEX_CHARS[ch & 0xF];\n                ptr -= 5;\n            } else {\n                // won't fit, flush and write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                _outputHead = _outputTail;\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    int lo = ch & 0xFF;\n                    ent[10] = HEX_CHARS[hi >> 4];\n                    ent[11] = HEX_CHARS[hi & 0xF];\n                    ent[12] = HEX_CHARS[lo >> 4];\n                    ent[13] = HEX_CHARS[lo & 0xF];\n                    _writer.write(ent, 8, 6);\n                } else { // We know it's a control char, so only the last 2 chars are non-0\n                    ent[6] = HEX_CHARS[ch >> 4];\n                    ent[7] = HEX_CHARS[ch & 0xF];\n                    _writer.write(ent, 2, 6);\n                }\n            }\n            return ptr;\n        }\n        String escape;\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (ptr >= len && ptr < end) { // fits in, prepend\n            ptr -= len;\n            escape.getChars(0, len, buffer, ptr);\n        } else { // won't fit, write separately\n            _writer.write(escape);\n        }\n        return ptr;\n    }",
          "5": "    private int _prependOrWriteCharacterEscape(char[] buffer, int ptr, int end,\n            char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (ptr > 1 && ptr < end) { // fits, just prepend\n                ptr -= 2;\n                buffer[ptr] = '\\\\';\n                buffer[ptr+1] = (char) escCode;\n            } else { // won't fit, write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                ent[1] = (char) escCode;\n                _writer.write(ent, 0, 2);\n            }\n            return ptr;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\n            if (ptr > 5 && ptr < end) { // fits, prepend to buffer\n                ptr -= 6;\n                buffer[ptr++] = '\\\\';\n                buffer[ptr++] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\nbuffer[ptr++] = HEX_CHARS[(hi << 0)];\n                    buffer[ptr++] = HEX_CHARS[hi & 0xF];\n                    ch &= 0xFF;\n                } else {\n                    buffer[ptr++] = '0';\n                    buffer[ptr++] = '0';\n                }\n                buffer[ptr++] = HEX_CHARS[ch >> 4];\n                buffer[ptr] = HEX_CHARS[ch & 0xF];\n                ptr -= 5;\n            } else {\n                // won't fit, flush and write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                _outputHead = _outputTail;\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    int lo = ch & 0xFF;\n                    ent[10] = HEX_CHARS[hi >> 4];\n                    ent[11] = HEX_CHARS[hi & 0xF];\n                    ent[12] = HEX_CHARS[lo >> 4];\n                    ent[13] = HEX_CHARS[lo & 0xF];\n                    _writer.write(ent, 8, 6);\n                } else { // We know it's a control char, so only the last 2 chars are non-0\n                    ent[6] = HEX_CHARS[ch >> 4];\n                    ent[7] = HEX_CHARS[ch & 0xF];\n                    _writer.write(ent, 2, 6);\n                }\n            }\n            return ptr;\n        }\n        String escape;\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (ptr >= len && ptr < end) { // fits in, prepend\n            ptr -= len;\n            escape.getChars(0, len, buffer, ptr);\n        } else { // won't fit, write separately\n            _writer.write(escape);\n        }\n        return ptr;\n    }",
          "6": "    private int _prependOrWriteCharacterEscape(char[] buffer, int ptr, int end,\n            char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (ptr > 1 && ptr < end) { // fits, just prepend\n                ptr -= 2;\n                buffer[ptr] = '\\\\';\n                buffer[ptr+1] = (char) escCode;\n            } else { // won't fit, write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                ent[1] = (char) escCode;\n                _writer.write(ent, 0, 2);\n            }\n            return ptr;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\n            if (ptr > 5 && ptr < end) { // fits, prepend to buffer\n                ptr -= 6;\n                buffer[ptr++] = '\\\\';\n                buffer[ptr++] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\nif((ch > 0xFF)){\n                    buffer[ptr++] = HEX_CHARS[hi << 4];                    buffer[ptr++] = HEX_CHARS[hi & 0xF];\n                    ch &= 0xFF;\n                } else {\n                    buffer[ptr++] = '0';\n                    buffer[ptr++] = '0';\n}\n                }\n                buffer[ptr++] = HEX_CHARS[ch >> 4];\n                buffer[ptr] = HEX_CHARS[ch & 0xF];\n                ptr -= 5;\n            } else {\n                // won't fit, flush and write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                _outputHead = _outputTail;\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    int lo = ch & 0xFF;\n                    ent[10] = HEX_CHARS[hi >> 4];\n                    ent[11] = HEX_CHARS[hi & 0xF];\n                    ent[12] = HEX_CHARS[lo >> 4];\n                    ent[13] = HEX_CHARS[lo & 0xF];\n                    _writer.write(ent, 8, 6);\n                } else { // We know it's a control char, so only the last 2 chars are non-0\n                    ent[6] = HEX_CHARS[ch >> 4];\n                    ent[7] = HEX_CHARS[ch & 0xF];\n                    _writer.write(ent, 2, 6);\n                }\n            }\n            return ptr;\n        }\n        String escape;\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (ptr >= len && ptr < end) { // fits in, prepend\n            ptr -= len;\n            escape.getChars(0, len, buffer, ptr);\n        } else { // won't fit, write separately\n            _writer.write(escape);\n        }\n        return ptr;\n    }",
          "7": "    private int _prependOrWriteCharacterEscape(char[] buffer, int ptr, int end,\n            char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (ptr > 1 && ptr < end) { // fits, just prepend\n                ptr -= 2;\n                buffer[ptr] = '\\\\';\n                buffer[ptr+1] = (char) escCode;\n            } else { // won't fit, write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                ent[1] = (char) escCode;\n                _writer.write(ent, 0, 2);\n            }\n            return ptr;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\n            if (ptr > 5 && ptr < end) { // fits, prepend to buffer\n                ptr -= 6;\n                buffer[ptr++] = '\\\\';\n                buffer[ptr++] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\nch &= 0xFF;\n                    buffer[ptr++] = HEX_CHARS[hi << 4];                    buffer[ptr++] = HEX_CHARS[hi & 0xF];\n                    ch &= 0xFF;\n                } else {\n                    buffer[ptr++] = '0';\n                    buffer[ptr++] = '0';\n                }\n                buffer[ptr++] = HEX_CHARS[ch >> 4];\n                buffer[ptr] = HEX_CHARS[ch & 0xF];\n                ptr -= 5;\n            } else {\n                // won't fit, flush and write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                _outputHead = _outputTail;\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    int lo = ch & 0xFF;\n                    ent[10] = HEX_CHARS[hi >> 4];\n                    ent[11] = HEX_CHARS[hi & 0xF];\n                    ent[12] = HEX_CHARS[lo >> 4];\n                    ent[13] = HEX_CHARS[lo & 0xF];\n                    _writer.write(ent, 8, 6);\n                } else { // We know it's a control char, so only the last 2 chars are non-0\n                    ent[6] = HEX_CHARS[ch >> 4];\n                    ent[7] = HEX_CHARS[ch & 0xF];\n                    _writer.write(ent, 2, 6);\n                }\n            }\n            return ptr;\n        }\n        String escape;\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (ptr >= len && ptr < end) { // fits in, prepend\n            ptr -= len;\n            escape.getChars(0, len, buffer, ptr);\n        } else { // won't fit, write separately\n            _writer.write(escape);\n        }\n        return ptr;\n    }",
          "8": "    private int _prependOrWriteCharacterEscape(char[] buffer, int ptr, int end,\n            char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (ptr > 1 && ptr < end) { // fits, just prepend\n                ptr -= 2;\n                buffer[ptr] = '\\\\';\n                buffer[ptr+1] = (char) escCode;\n            } else { // won't fit, write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                ent[1] = (char) escCode;\n                _writer.write(ent, 0, 2);\n            }\n            return ptr;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\n            if (ptr > 5 && ptr < end) { // fits, prepend to buffer\n                ptr -= 6;\n                buffer[ptr++] = '\\\\';\n                buffer[ptr++] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\nbuffer[ptr++] = HEX_CHARS[ptr++];\n                    buffer[ptr++] = HEX_CHARS[hi & 0xF];\n                    ch &= 0xFF;\n                } else {\n                    buffer[ptr++] = '0';\n                    buffer[ptr++] = '0';\n                }\n                buffer[ptr++] = HEX_CHARS[ch >> 4];\n                buffer[ptr] = HEX_CHARS[ch & 0xF];\n                ptr -= 5;\n            } else {\n                // won't fit, flush and write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                _outputHead = _outputTail;\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    int lo = ch & 0xFF;\n                    ent[10] = HEX_CHARS[hi >> 4];\n                    ent[11] = HEX_CHARS[hi & 0xF];\n                    ent[12] = HEX_CHARS[lo >> 4];\n                    ent[13] = HEX_CHARS[lo & 0xF];\n                    _writer.write(ent, 8, 6);\n                } else { // We know it's a control char, so only the last 2 chars are non-0\n                    ent[6] = HEX_CHARS[ch >> 4];\n                    ent[7] = HEX_CHARS[ch & 0xF];\n                    _writer.write(ent, 2, 6);\n                }\n            }\n            return ptr;\n        }\n        String escape;\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (ptr >= len && ptr < end) { // fits in, prepend\n            ptr -= len;\n            escape.getChars(0, len, buffer, ptr);\n        } else { // won't fit, write separately\n            _writer.write(escape);\n        }\n        return ptr;\n    }",
          "9": "    private int _prependOrWriteCharacterEscape(char[] buffer, int ptr, int end,\n            char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (ptr > 1 && ptr < end) { // fits, just prepend\n                ptr -= 2;\n                buffer[ptr] = '\\\\';\n                buffer[ptr+1] = (char) escCode;\n            } else { // won't fit, write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                ent[1] = (char) escCode;\n                _writer.write(ent, 0, 2);\n            }\n            return ptr;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\n            if (ptr > 5 && ptr < end) { // fits, prepend to buffer\n                ptr -= 6;\n                buffer[ptr++] = '\\\\';\n                buffer[ptr++] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\nbuffer[ptr++] = HEX_CHARS[(hi & 0xF)];\n                    buffer[ptr++] = HEX_CHARS[hi << 4];                    buffer[ptr++] = HEX_CHARS[hi & 0xF];\n                    ch &= 0xFF;\n                } else {\n                    buffer[ptr++] = '0';\n                    buffer[ptr++] = '0';\n                }\n                buffer[ptr++] = HEX_CHARS[ch >> 4];\n                buffer[ptr] = HEX_CHARS[ch & 0xF];\n                ptr -= 5;\n            } else {\n                // won't fit, flush and write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                _outputHead = _outputTail;\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    int lo = ch & 0xFF;\n                    ent[10] = HEX_CHARS[hi >> 4];\n                    ent[11] = HEX_CHARS[hi & 0xF];\n                    ent[12] = HEX_CHARS[lo >> 4];\n                    ent[13] = HEX_CHARS[lo & 0xF];\n                    _writer.write(ent, 8, 6);\n                } else { // We know it's a control char, so only the last 2 chars are non-0\n                    ent[6] = HEX_CHARS[ch >> 4];\n                    ent[7] = HEX_CHARS[ch & 0xF];\n                    _writer.write(ent, 2, 6);\n                }\n            }\n            return ptr;\n        }\n        String escape;\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (ptr >= len && ptr < end) { // fits in, prepend\n            ptr -= len;\n            escape.getChars(0, len, buffer, ptr);\n        } else { // won't fit, write separately\n            _writer.write(escape);\n        }\n        return ptr;\n    }",
          "10": "    private int _prependOrWriteCharacterEscape(char[] buffer, int ptr, int end,\n            char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (ptr > 1 && ptr < end) { // fits, just prepend\n                ptr -= 2;\n                buffer[ptr] = '\\\\';\n                buffer[ptr+1] = (char) escCode;\n            } else { // won't fit, write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                ent[1] = (char) escCode;\n                _writer.write(ent, 0, 2);\n            }\n            return ptr;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\n            if (ptr > 5 && ptr < end) { // fits, prepend to buffer\n                ptr -= 6;\n                buffer[ptr++] = '\\\\';\n                buffer[ptr++] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\nbuffer[ptr++] = hi;\n                    buffer[ptr++] = HEX_CHARS[hi & 0xF];\n                    ch &= 0xFF;\n                } else {\n                    buffer[ptr++] = '0';\n                    buffer[ptr++] = '0';\n                }\n                buffer[ptr++] = HEX_CHARS[ch >> 4];\n                buffer[ptr] = HEX_CHARS[ch & 0xF];\n                ptr -= 5;\n            } else {\n                // won't fit, flush and write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                _outputHead = _outputTail;\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    int lo = ch & 0xFF;\n                    ent[10] = HEX_CHARS[hi >> 4];\n                    ent[11] = HEX_CHARS[hi & 0xF];\n                    ent[12] = HEX_CHARS[lo >> 4];\n                    ent[13] = HEX_CHARS[lo & 0xF];\n                    _writer.write(ent, 8, 6);\n                } else { // We know it's a control char, so only the last 2 chars are non-0\n                    ent[6] = HEX_CHARS[ch >> 4];\n                    ent[7] = HEX_CHARS[ch & 0xF];\n                    _writer.write(ent, 2, 6);\n                }\n            }\n            return ptr;\n        }\n        String escape;\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (ptr >= len && ptr < end) { // fits in, prepend\n            ptr -= len;\n            escape.getChars(0, len, buffer, ptr);\n        } else { // won't fit, write separately\n            _writer.write(escape);\n        }\n        return ptr;\n    }",
          "11": "    private int _prependOrWriteCharacterEscape(char[] buffer, int ptr, int end,\n            char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (ptr > 1 && ptr < end) { // fits, just prepend\n                ptr -= 2;\n                buffer[ptr] = '\\\\';\n                buffer[ptr+1] = (char) escCode;\n            } else { // won't fit, write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                ent[1] = (char) escCode;\n                _writer.write(ent, 0, 2);\n            }\n            return ptr;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\n            if (ptr > 5 && ptr < end) { // fits, prepend to buffer\n                ptr -= 6;\n                buffer[ptr++] = '\\\\';\n                buffer[ptr++] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\nch &= 0xFF;\n                    buffer[ptr++] = HEX_CHARS[hi & 0xF];\n                    ch &= 0xFF;\n                } else {\n                    buffer[ptr++] = '0';\n                    buffer[ptr++] = '0';\n                }\n                buffer[ptr++] = HEX_CHARS[ch >> 4];\n                buffer[ptr] = HEX_CHARS[ch & 0xF];\n                ptr -= 5;\n            } else {\n                // won't fit, flush and write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                _outputHead = _outputTail;\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    int lo = ch & 0xFF;\n                    ent[10] = HEX_CHARS[hi >> 4];\n                    ent[11] = HEX_CHARS[hi & 0xF];\n                    ent[12] = HEX_CHARS[lo >> 4];\n                    ent[13] = HEX_CHARS[lo & 0xF];\n                    _writer.write(ent, 8, 6);\n                } else { // We know it's a control char, so only the last 2 chars are non-0\n                    ent[6] = HEX_CHARS[ch >> 4];\n                    ent[7] = HEX_CHARS[ch & 0xF];\n                    _writer.write(ent, 2, 6);\n                }\n            }\n            return ptr;\n        }\n        String escape;\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (ptr >= len && ptr < end) { // fits in, prepend\n            ptr -= len;\n            escape.getChars(0, len, buffer, ptr);\n        } else { // won't fit, write separately\n            _writer.write(escape);\n        }\n        return ptr;\n    }",
          "12": "    private int _prependOrWriteCharacterEscape(char[] buffer, int ptr, int end,\n            char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (ptr > 1 && ptr < end) { // fits, just prepend\n                ptr -= 2;\n                buffer[ptr] = '\\\\';\n                buffer[ptr+1] = (char) escCode;\n            } else { // won't fit, write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                ent[1] = (char) escCode;\n                _writer.write(ent, 0, 2);\n            }\n            return ptr;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\n            if (ptr > 5 && ptr < end) { // fits, prepend to buffer\n                ptr -= 6;\n                buffer[ptr++] = '\\\\';\n                buffer[ptr++] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\nbuffer[ptr++] = buffer[(hi << 4)];\n                    buffer[ptr++] = HEX_CHARS[hi & 0xF];\n                    ch &= 0xFF;\n                } else {\n                    buffer[ptr++] = '0';\n                    buffer[ptr++] = '0';\n                }\n                buffer[ptr++] = HEX_CHARS[ch >> 4];\n                buffer[ptr] = HEX_CHARS[ch & 0xF];\n                ptr -= 5;\n            } else {\n                // won't fit, flush and write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                _outputHead = _outputTail;\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    int lo = ch & 0xFF;\n                    ent[10] = HEX_CHARS[hi >> 4];\n                    ent[11] = HEX_CHARS[hi & 0xF];\n                    ent[12] = HEX_CHARS[lo >> 4];\n                    ent[13] = HEX_CHARS[lo & 0xF];\n                    _writer.write(ent, 8, 6);\n                } else { // We know it's a control char, so only the last 2 chars are non-0\n                    ent[6] = HEX_CHARS[ch >> 4];\n                    ent[7] = HEX_CHARS[ch & 0xF];\n                    _writer.write(ent, 2, 6);\n                }\n            }\n            return ptr;\n        }\n        String escape;\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (ptr >= len && ptr < end) { // fits in, prepend\n            ptr -= len;\n            escape.getChars(0, len, buffer, ptr);\n        } else { // won't fit, write separately\n            _writer.write(escape);\n        }\n        return ptr;\n    }",
          "13": "    private int _prependOrWriteCharacterEscape(char[] buffer, int ptr, int end,\n            char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (ptr > 1 && ptr < end) { // fits, just prepend\n                ptr -= 2;\n                buffer[ptr] = '\\\\';\n                buffer[ptr+1] = (char) escCode;\n            } else { // won't fit, write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                ent[1] = (char) escCode;\n                _writer.write(ent, 0, 2);\n            }\n            return ptr;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\n            if (ptr > 5 && ptr < end) { // fits, prepend to buffer\n                ptr -= 6;\n                buffer[ptr++] = '\\\\';\n                buffer[ptr++] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\nbuffer[ptr++] = HEX_CHARS[(hi & 0xF)];\n                    buffer[ptr++] = HEX_CHARS[hi & 0xF];\n                    ch &= 0xFF;\n                } else {\n                    buffer[ptr++] = '0';\n                    buffer[ptr++] = '0';\n                }\n                buffer[ptr++] = HEX_CHARS[ch >> 4];\n                buffer[ptr] = HEX_CHARS[ch & 0xF];\n                ptr -= 5;\n            } else {\n                // won't fit, flush and write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                _outputHead = _outputTail;\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    int lo = ch & 0xFF;\n                    ent[10] = HEX_CHARS[hi >> 4];\n                    ent[11] = HEX_CHARS[hi & 0xF];\n                    ent[12] = HEX_CHARS[lo >> 4];\n                    ent[13] = HEX_CHARS[lo & 0xF];\n                    _writer.write(ent, 8, 6);\n                } else { // We know it's a control char, so only the last 2 chars are non-0\n                    ent[6] = HEX_CHARS[ch >> 4];\n                    ent[7] = HEX_CHARS[ch & 0xF];\n                    _writer.write(ent, 2, 6);\n                }\n            }\n            return ptr;\n        }\n        String escape;\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (ptr >= len && ptr < end) { // fits in, prepend\n            ptr -= len;\n            escape.getChars(0, len, buffer, ptr);\n        } else { // won't fit, write separately\n            _writer.write(escape);\n        }\n        return ptr;\n    }",
          "14": "    private int _prependOrWriteCharacterEscape(char[] buffer, int ptr, int end,\n            char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (ptr > 1 && ptr < end) { // fits, just prepend\n                ptr -= 2;\n                buffer[ptr] = '\\\\';\n                buffer[ptr+1] = (char) escCode;\n            } else { // won't fit, write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                ent[1] = (char) escCode;\n                _writer.write(ent, 0, 2);\n            }\n            return ptr;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\n            if (ptr > 5 && ptr < end) { // fits, prepend to buffer\n                ptr -= 6;\n                buffer[ptr++] = '\\\\';\n                buffer[ptr++] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\nHEX_CHARS[(hi << 4)] = HEX_CHARS[(hi << 4)];\n                    buffer[ptr++] = HEX_CHARS[hi & 0xF];\n                    ch &= 0xFF;\n                } else {\n                    buffer[ptr++] = '0';\n                    buffer[ptr++] = '0';\n                }\n                buffer[ptr++] = HEX_CHARS[ch >> 4];\n                buffer[ptr] = HEX_CHARS[ch & 0xF];\n                ptr -= 5;\n            } else {\n                // won't fit, flush and write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                _outputHead = _outputTail;\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    int lo = ch & 0xFF;\n                    ent[10] = HEX_CHARS[hi >> 4];\n                    ent[11] = HEX_CHARS[hi & 0xF];\n                    ent[12] = HEX_CHARS[lo >> 4];\n                    ent[13] = HEX_CHARS[lo & 0xF];\n                    _writer.write(ent, 8, 6);\n                } else { // We know it's a control char, so only the last 2 chars are non-0\n                    ent[6] = HEX_CHARS[ch >> 4];\n                    ent[7] = HEX_CHARS[ch & 0xF];\n                    _writer.write(ent, 2, 6);\n                }\n            }\n            return ptr;\n        }\n        String escape;\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (ptr >= len && ptr < end) { // fits in, prepend\n            ptr -= len;\n            escape.getChars(0, len, buffer, ptr);\n        } else { // won't fit, write separately\n            _writer.write(escape);\n        }\n        return ptr;\n    }",
          "15": "    private int _prependOrWriteCharacterEscape(char[] buffer, int ptr, int end,\n            char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (ptr > 1 && ptr < end) { // fits, just prepend\n                ptr -= 2;\n                buffer[ptr] = '\\\\';\n                buffer[ptr+1] = (char) escCode;\n            } else { // won't fit, write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                ent[1] = (char) escCode;\n                _writer.write(ent, 0, 2);\n            }\n            return ptr;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\n            if (ptr > 5 && ptr < end) { // fits, prepend to buffer\n                ptr -= 6;\n                buffer[ptr++] = '\\\\';\n                buffer[ptr++] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\nbuffer[ptr++] = \"null\";\n                    buffer[ptr++] = HEX_CHARS[hi << 4];                    buffer[ptr++] = HEX_CHARS[hi & 0xF];\n                    ch &= 0xFF;\n                } else {\n                    buffer[ptr++] = '0';\n                    buffer[ptr++] = '0';\n                }\n                buffer[ptr++] = HEX_CHARS[ch >> 4];\n                buffer[ptr] = HEX_CHARS[ch & 0xF];\n                ptr -= 5;\n            } else {\n                // won't fit, flush and write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                _outputHead = _outputTail;\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    int lo = ch & 0xFF;\n                    ent[10] = HEX_CHARS[hi >> 4];\n                    ent[11] = HEX_CHARS[hi & 0xF];\n                    ent[12] = HEX_CHARS[lo >> 4];\n                    ent[13] = HEX_CHARS[lo & 0xF];\n                    _writer.write(ent, 8, 6);\n                } else { // We know it's a control char, so only the last 2 chars are non-0\n                    ent[6] = HEX_CHARS[ch >> 4];\n                    ent[7] = HEX_CHARS[ch & 0xF];\n                    _writer.write(ent, 2, 6);\n                }\n            }\n            return ptr;\n        }\n        String escape;\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (ptr >= len && ptr < end) { // fits in, prepend\n            ptr -= len;\n            escape.getChars(0, len, buffer, ptr);\n        } else { // won't fit, write separately\n            _writer.write(escape);\n        }\n        return ptr;\n    }",
          "16": "    private int _prependOrWriteCharacterEscape(char[] buffer, int ptr, int end,\n            char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (ptr > 1 && ptr < end) { // fits, just prepend\n                ptr -= 2;\n                buffer[ptr] = '\\\\';\n                buffer[ptr+1] = (char) escCode;\n            } else { // won't fit, write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                ent[1] = (char) escCode;\n                _writer.write(ent, 0, 2);\n            }\n            return ptr;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\n            if (ptr > 5 && ptr < end) { // fits, prepend to buffer\n                ptr -= 6;\n                buffer[ptr++] = '\\\\';\n                buffer[ptr++] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\nbuffer[ptr++] = buffer[ptr++];\n                    buffer[ptr++] = HEX_CHARS[hi & 0xF];\n                    ch &= 0xFF;\n                } else {\n                    buffer[ptr++] = '0';\n                    buffer[ptr++] = '0';\n                }\n                buffer[ptr++] = HEX_CHARS[ch >> 4];\n                buffer[ptr] = HEX_CHARS[ch & 0xF];\n                ptr -= 5;\n            } else {\n                // won't fit, flush and write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                _outputHead = _outputTail;\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    int lo = ch & 0xFF;\n                    ent[10] = HEX_CHARS[hi >> 4];\n                    ent[11] = HEX_CHARS[hi & 0xF];\n                    ent[12] = HEX_CHARS[lo >> 4];\n                    ent[13] = HEX_CHARS[lo & 0xF];\n                    _writer.write(ent, 8, 6);\n                } else { // We know it's a control char, so only the last 2 chars are non-0\n                    ent[6] = HEX_CHARS[ch >> 4];\n                    ent[7] = HEX_CHARS[ch & 0xF];\n                    _writer.write(ent, 2, 6);\n                }\n            }\n            return ptr;\n        }\n        String escape;\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (ptr >= len && ptr < end) { // fits in, prepend\n            ptr -= len;\n            escape.getChars(0, len, buffer, ptr);\n        } else { // won't fit, write separately\n            _writer.write(escape);\n        }\n        return ptr;\n    }",
          "17": "    private int _prependOrWriteCharacterEscape(char[] buffer, int ptr, int end,\n            char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (ptr > 1 && ptr < end) { // fits, just prepend\n                ptr -= 2;\n                buffer[ptr] = '\\\\';\n                buffer[ptr+1] = (char) escCode;\n            } else { // won't fit, write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                ent[1] = (char) escCode;\n                _writer.write(ent, 0, 2);\n            }\n            return ptr;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\n            if (ptr > 5 && ptr < end) { // fits, prepend to buffer\n                ptr -= 6;\n                buffer[ptr++] = '\\\\';\n                buffer[ptr++] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\nbuffer[ptr++] = hi[(hi << 4)];\n                    buffer[ptr++] = HEX_CHARS[hi & 0xF];\n                    ch &= 0xFF;\n                } else {\n                    buffer[ptr++] = '0';\n                    buffer[ptr++] = '0';\n                }\n                buffer[ptr++] = HEX_CHARS[ch >> 4];\n                buffer[ptr] = HEX_CHARS[ch & 0xF];\n                ptr -= 5;\n            } else {\n                // won't fit, flush and write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                _outputHead = _outputTail;\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    int lo = ch & 0xFF;\n                    ent[10] = HEX_CHARS[hi >> 4];\n                    ent[11] = HEX_CHARS[hi & 0xF];\n                    ent[12] = HEX_CHARS[lo >> 4];\n                    ent[13] = HEX_CHARS[lo & 0xF];\n                    _writer.write(ent, 8, 6);\n                } else { // We know it's a control char, so only the last 2 chars are non-0\n                    ent[6] = HEX_CHARS[ch >> 4];\n                    ent[7] = HEX_CHARS[ch & 0xF];\n                    _writer.write(ent, 2, 6);\n                }\n            }\n            return ptr;\n        }\n        String escape;\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (ptr >= len && ptr < end) { // fits in, prepend\n            ptr -= len;\n            escape.getChars(0, len, buffer, ptr);\n        } else { // won't fit, write separately\n            _writer.write(escape);\n        }\n        return ptr;\n    }",
          "18": "    private int _prependOrWriteCharacterEscape(char[] buffer, int ptr, int end,\n            char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (ptr > 1 && ptr < end) { // fits, just prepend\n                ptr -= 2;\n                buffer[ptr] = '\\\\';\n                buffer[ptr+1] = (char) escCode;\n            } else { // won't fit, write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                ent[1] = (char) escCode;\n                _writer.write(ent, 0, 2);\n            }\n            return ptr;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\n            if (ptr > 5 && ptr < end) { // fits, prepend to buffer\n                ptr -= 6;\n                buffer[ptr++] = '\\\\';\n                buffer[ptr++] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\nbuffer[ptr++] = \"null\";\n                    buffer[ptr++] = HEX_CHARS[hi & 0xF];\n                    ch &= 0xFF;\n                } else {\n                    buffer[ptr++] = '0';\n                    buffer[ptr++] = '0';\n                }\n                buffer[ptr++] = HEX_CHARS[ch >> 4];\n                buffer[ptr] = HEX_CHARS[ch & 0xF];\n                ptr -= 5;\n            } else {\n                // won't fit, flush and write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                _outputHead = _outputTail;\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    int lo = ch & 0xFF;\n                    ent[10] = HEX_CHARS[hi >> 4];\n                    ent[11] = HEX_CHARS[hi & 0xF];\n                    ent[12] = HEX_CHARS[lo >> 4];\n                    ent[13] = HEX_CHARS[lo & 0xF];\n                    _writer.write(ent, 8, 6);\n                } else { // We know it's a control char, so only the last 2 chars are non-0\n                    ent[6] = HEX_CHARS[ch >> 4];\n                    ent[7] = HEX_CHARS[ch & 0xF];\n                    _writer.write(ent, 2, 6);\n                }\n            }\n            return ptr;\n        }\n        String escape;\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (ptr >= len && ptr < end) { // fits in, prepend\n            ptr -= len;\n            escape.getChars(0, len, buffer, ptr);\n        } else { // won't fit, write separately\n            _writer.write(escape);\n        }\n        return ptr;\n    }",
          "19": "    private int _prependOrWriteCharacterEscape(char[] buffer, int ptr, int end,\n            char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (ptr > 1 && ptr < end) { // fits, just prepend\n                ptr -= 2;\n                buffer[ptr] = '\\\\';\n                buffer[ptr+1] = (char) escCode;\n            } else { // won't fit, write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                ent[1] = (char) escCode;\n                _writer.write(ent, 0, 2);\n            }\n            return ptr;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\n            if (ptr > 5 && ptr < end) { // fits, prepend to buffer\n                ptr -= 6;\n                buffer[ptr++] = '\\\\';\n                buffer[ptr++] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\nbuffer[ptr++] = _outputBuffer[ptr++];\n                    buffer[ptr++] = HEX_CHARS[hi & 0xF];\n                    ch &= 0xFF;\n                } else {\n                    buffer[ptr++] = '0';\n                    buffer[ptr++] = '0';\n                }\n                buffer[ptr++] = HEX_CHARS[ch >> 4];\n                buffer[ptr] = HEX_CHARS[ch & 0xF];\n                ptr -= 5;\n            } else {\n                // won't fit, flush and write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                _outputHead = _outputTail;\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    int lo = ch & 0xFF;\n                    ent[10] = HEX_CHARS[hi >> 4];\n                    ent[11] = HEX_CHARS[hi & 0xF];\n                    ent[12] = HEX_CHARS[lo >> 4];\n                    ent[13] = HEX_CHARS[lo & 0xF];\n                    _writer.write(ent, 8, 6);\n                } else { // We know it's a control char, so only the last 2 chars are non-0\n                    ent[6] = HEX_CHARS[ch >> 4];\n                    ent[7] = HEX_CHARS[ch & 0xF];\n                    _writer.write(ent, 2, 6);\n                }\n            }\n            return ptr;\n        }\n        String escape;\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (ptr >= len && ptr < end) { // fits in, prepend\n            ptr -= len;\n            escape.getChars(0, len, buffer, ptr);\n        } else { // won't fit, write separately\n            _writer.write(escape);\n        }\n        return ptr;\n    }",
          "20": "    private int _prependOrWriteCharacterEscape(char[] buffer, int ptr, int end,\n            char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (ptr > 1 && ptr < end) { // fits, just prepend\n                ptr -= 2;\n                buffer[ptr] = '\\\\';\n                buffer[ptr+1] = (char) escCode;\n            } else { // won't fit, write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                ent[1] = (char) escCode;\n                _writer.write(ent, 0, 2);\n            }\n            return ptr;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\n            if (ptr > 5 && ptr < end) { // fits, prepend to buffer\n                ptr -= 6;\n                buffer[ptr++] = '\\\\';\n                buffer[ptr++] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\nbuffer[ptr++] = _entityBuffer[ptr++];\n                    buffer[ptr++] = HEX_CHARS[hi & 0xF];\n                    ch &= 0xFF;\n                } else {\n                    buffer[ptr++] = '0';\n                    buffer[ptr++] = '0';\n                }\n                buffer[ptr++] = HEX_CHARS[ch >> 4];\n                buffer[ptr] = HEX_CHARS[ch & 0xF];\n                ptr -= 5;\n            } else {\n                // won't fit, flush and write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                _outputHead = _outputTail;\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    int lo = ch & 0xFF;\n                    ent[10] = HEX_CHARS[hi >> 4];\n                    ent[11] = HEX_CHARS[hi & 0xF];\n                    ent[12] = HEX_CHARS[lo >> 4];\n                    ent[13] = HEX_CHARS[lo & 0xF];\n                    _writer.write(ent, 8, 6);\n                } else { // We know it's a control char, so only the last 2 chars are non-0\n                    ent[6] = HEX_CHARS[ch >> 4];\n                    ent[7] = HEX_CHARS[ch & 0xF];\n                    _writer.write(ent, 2, 6);\n                }\n            }\n            return ptr;\n        }\n        String escape;\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (ptr >= len && ptr < end) { // fits in, prepend\n            ptr -= len;\n            escape.getChars(0, len, buffer, ptr);\n        } else { // won't fit, write separately\n            _writer.write(escape);\n        }\n        return ptr;\n    }",
          "21": "    private int _prependOrWriteCharacterEscape(char[] buffer, int ptr, int end,\n            char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (ptr > 1 && ptr < end) { // fits, just prepend\n                ptr -= 2;\n                buffer[ptr] = '\\\\';\n                buffer[ptr+1] = (char) escCode;\n            } else { // won't fit, write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                ent[1] = (char) escCode;\n                _writer.write(ent, 0, 2);\n            }\n            return ptr;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\n            if (ptr > 5 && ptr < end) { // fits, prepend to buffer\n                ptr -= 6;\n                buffer[ptr++] = '\\\\';\n                buffer[ptr++] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\nbuffer[ptr++] = HEX_CHARS[(ch >> 4)];\n                    buffer[ptr++] = HEX_CHARS[hi & 0xF];\n                    ch &= 0xFF;\n                } else {\n                    buffer[ptr++] = '0';\n                    buffer[ptr++] = '0';\n                }\n                buffer[ptr++] = HEX_CHARS[ch >> 4];\n                buffer[ptr] = HEX_CHARS[ch & 0xF];\n                ptr -= 5;\n            } else {\n                // won't fit, flush and write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                _outputHead = _outputTail;\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    int lo = ch & 0xFF;\n                    ent[10] = HEX_CHARS[hi >> 4];\n                    ent[11] = HEX_CHARS[hi & 0xF];\n                    ent[12] = HEX_CHARS[lo >> 4];\n                    ent[13] = HEX_CHARS[lo & 0xF];\n                    _writer.write(ent, 8, 6);\n                } else { // We know it's a control char, so only the last 2 chars are non-0\n                    ent[6] = HEX_CHARS[ch >> 4];\n                    ent[7] = HEX_CHARS[ch & 0xF];\n                    _writer.write(ent, 2, 6);\n                }\n            }\n            return ptr;\n        }\n        String escape;\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (ptr >= len && ptr < end) { // fits in, prepend\n            ptr -= len;\n            escape.getChars(0, len, buffer, ptr);\n        } else { // won't fit, write separately\n            _writer.write(escape);\n        }\n        return ptr;\n    }",
          "22": "    private int _prependOrWriteCharacterEscape(char[] buffer, int ptr, int end,\n            char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (ptr > 1 && ptr < end) { // fits, just prepend\n                ptr -= 2;\n                buffer[ptr] = '\\\\';\n                buffer[ptr+1] = (char) escCode;\n            } else { // won't fit, write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                ent[1] = (char) escCode;\n                _writer.write(ent, 0, 2);\n            }\n            return ptr;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\n            if (ptr > 5 && ptr < end) { // fits, prepend to buffer\n                ptr -= 6;\n                buffer[ptr++] = '\\\\';\n                buffer[ptr++] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\nreturn;\n                    buffer[ptr++] = HEX_CHARS[hi << 4];                    buffer[ptr++] = HEX_CHARS[hi & 0xF];\n                    ch &= 0xFF;\n                } else {\n                    buffer[ptr++] = '0';\n                    buffer[ptr++] = '0';\n                }\n                buffer[ptr++] = HEX_CHARS[ch >> 4];\n                buffer[ptr] = HEX_CHARS[ch & 0xF];\n                ptr -= 5;\n            } else {\n                // won't fit, flush and write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                _outputHead = _outputTail;\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    int lo = ch & 0xFF;\n                    ent[10] = HEX_CHARS[hi >> 4];\n                    ent[11] = HEX_CHARS[hi & 0xF];\n                    ent[12] = HEX_CHARS[lo >> 4];\n                    ent[13] = HEX_CHARS[lo & 0xF];\n                    _writer.write(ent, 8, 6);\n                } else { // We know it's a control char, so only the last 2 chars are non-0\n                    ent[6] = HEX_CHARS[ch >> 4];\n                    ent[7] = HEX_CHARS[ch & 0xF];\n                    _writer.write(ent, 2, 6);\n                }\n            }\n            return ptr;\n        }\n        String escape;\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (ptr >= len && ptr < end) { // fits in, prepend\n            ptr -= len;\n            escape.getChars(0, len, buffer, ptr);\n        } else { // won't fit, write separately\n            _writer.write(escape);\n        }\n        return ptr;\n    }",
          "23": "    private int _prependOrWriteCharacterEscape(char[] buffer, int ptr, int end,\n            char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (ptr > 1 && ptr < end) { // fits, just prepend\n                ptr -= 2;\n                buffer[ptr] = '\\\\';\n                buffer[ptr+1] = (char) escCode;\n            } else { // won't fit, write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                ent[1] = (char) escCode;\n                _writer.write(ent, 0, 2);\n            }\n            return ptr;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\n            if (ptr > 5 && ptr < end) { // fits, prepend to buffer\n                ptr -= 6;\n                buffer[ptr++] = '\\\\';\n                buffer[ptr++] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\nbuffer[ptr++] = buffer[(hi & 0xF)];\n                    buffer[ptr++] = HEX_CHARS[hi & 0xF];\n                    ch &= 0xFF;\n                } else {\n                    buffer[ptr++] = '0';\n                    buffer[ptr++] = '0';\n                }\n                buffer[ptr++] = HEX_CHARS[ch >> 4];\n                buffer[ptr] = HEX_CHARS[ch & 0xF];\n                ptr -= 5;\n            } else {\n                // won't fit, flush and write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                _outputHead = _outputTail;\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    int lo = ch & 0xFF;\n                    ent[10] = HEX_CHARS[hi >> 4];\n                    ent[11] = HEX_CHARS[hi & 0xF];\n                    ent[12] = HEX_CHARS[lo >> 4];\n                    ent[13] = HEX_CHARS[lo & 0xF];\n                    _writer.write(ent, 8, 6);\n                } else { // We know it's a control char, so only the last 2 chars are non-0\n                    ent[6] = HEX_CHARS[ch >> 4];\n                    ent[7] = HEX_CHARS[ch & 0xF];\n                    _writer.write(ent, 2, 6);\n                }\n            }\n            return ptr;\n        }\n        String escape;\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (ptr >= len && ptr < end) { // fits in, prepend\n            ptr -= len;\n            escape.getChars(0, len, buffer, ptr);\n        } else { // won't fit, write separately\n            _writer.write(escape);\n        }\n        return ptr;\n    }",
          "24": "    private int _prependOrWriteCharacterEscape(char[] buffer, int ptr, int end,\n            char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (ptr > 1 && ptr < end) { // fits, just prepend\n                ptr -= 2;\n                buffer[ptr] = '\\\\';\n                buffer[ptr+1] = (char) escCode;\n            } else { // won't fit, write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                ent[1] = (char) escCode;\n                _writer.write(ent, 0, 2);\n            }\n            return ptr;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\n            if (ptr > 5 && ptr < end) { // fits, prepend to buffer\n                ptr -= 6;\n                buffer[ptr++] = '\\\\';\n                buffer[ptr++] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\nbuffer[ptr++] = (ptr < end);\n                    buffer[ptr++] = HEX_CHARS[hi & 0xF];\n                    ch &= 0xFF;\n                } else {\n                    buffer[ptr++] = '0';\n                    buffer[ptr++] = '0';\n                }\n                buffer[ptr++] = HEX_CHARS[ch >> 4];\n                buffer[ptr] = HEX_CHARS[ch & 0xF];\n                ptr -= 5;\n            } else {\n                // won't fit, flush and write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                _outputHead = _outputTail;\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    int lo = ch & 0xFF;\n                    ent[10] = HEX_CHARS[hi >> 4];\n                    ent[11] = HEX_CHARS[hi & 0xF];\n                    ent[12] = HEX_CHARS[lo >> 4];\n                    ent[13] = HEX_CHARS[lo & 0xF];\n                    _writer.write(ent, 8, 6);\n                } else { // We know it's a control char, so only the last 2 chars are non-0\n                    ent[6] = HEX_CHARS[ch >> 4];\n                    ent[7] = HEX_CHARS[ch & 0xF];\n                    _writer.write(ent, 2, 6);\n                }\n            }\n            return ptr;\n        }\n        String escape;\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (ptr >= len && ptr < end) { // fits in, prepend\n            ptr -= len;\n            escape.getChars(0, len, buffer, ptr);\n        } else { // won't fit, write separately\n            _writer.write(escape);\n        }\n        return ptr;\n    }",
          "25": "    private int _prependOrWriteCharacterEscape(char[] buffer, int ptr, int end,\n            char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (ptr > 1 && ptr < end) { // fits, just prepend\n                ptr -= 2;\n                buffer[ptr] = '\\\\';\n                buffer[ptr+1] = (char) escCode;\n            } else { // won't fit, write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                ent[1] = (char) escCode;\n                _writer.write(ent, 0, 2);\n            }\n            return ptr;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\n            if (ptr > 5 && ptr < end) { // fits, prepend to buffer\n                ptr -= 6;\n                buffer[ptr++] = '\\\\';\n                buffer[ptr++] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\nbuffer[ptr++] = HEX_CHARS[(ch & 0xF)];\n                    buffer[ptr++] = HEX_CHARS[hi & 0xF];\n                    ch &= 0xFF;\n                } else {\n                    buffer[ptr++] = '0';\n                    buffer[ptr++] = '0';\n                }\n                buffer[ptr++] = HEX_CHARS[ch >> 4];\n                buffer[ptr] = HEX_CHARS[ch & 0xF];\n                ptr -= 5;\n            } else {\n                // won't fit, flush and write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                _outputHead = _outputTail;\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    int lo = ch & 0xFF;\n                    ent[10] = HEX_CHARS[hi >> 4];\n                    ent[11] = HEX_CHARS[hi & 0xF];\n                    ent[12] = HEX_CHARS[lo >> 4];\n                    ent[13] = HEX_CHARS[lo & 0xF];\n                    _writer.write(ent, 8, 6);\n                } else { // We know it's a control char, so only the last 2 chars are non-0\n                    ent[6] = HEX_CHARS[ch >> 4];\n                    ent[7] = HEX_CHARS[ch & 0xF];\n                    _writer.write(ent, 2, 6);\n                }\n            }\n            return ptr;\n        }\n        String escape;\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (ptr >= len && ptr < end) { // fits in, prepend\n            ptr -= len;\n            escape.getChars(0, len, buffer, ptr);\n        } else { // won't fit, write separately\n            _writer.write(escape);\n        }\n        return ptr;\n    }",
          "26": "    private int _prependOrWriteCharacterEscape(char[] buffer, int ptr, int end,\n            char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (ptr > 1 && ptr < end) { // fits, just prepend\n                ptr -= 2;\n                buffer[ptr] = '\\\\';\n                buffer[ptr+1] = (char) escCode;\n            } else { // won't fit, write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                ent[1] = (char) escCode;\n                _writer.write(ent, 0, 2);\n            }\n            return ptr;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\n            if (ptr > 5 && ptr < end) { // fits, prepend to buffer\n                ptr -= 6;\n                buffer[ptr++] = '\\\\';\n                buffer[ptr++] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\nHEX_CHARS[ptr++] = HEX_CHARS[(hi << 4)];\n                    buffer[ptr++] = HEX_CHARS[hi & 0xF];\n                    ch &= 0xFF;\n                } else {\n                    buffer[ptr++] = '0';\n                    buffer[ptr++] = '0';\n                }\n                buffer[ptr++] = HEX_CHARS[ch >> 4];\n                buffer[ptr] = HEX_CHARS[ch & 0xF];\n                ptr -= 5;\n            } else {\n                // won't fit, flush and write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                _outputHead = _outputTail;\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    int lo = ch & 0xFF;\n                    ent[10] = HEX_CHARS[hi >> 4];\n                    ent[11] = HEX_CHARS[hi & 0xF];\n                    ent[12] = HEX_CHARS[lo >> 4];\n                    ent[13] = HEX_CHARS[lo & 0xF];\n                    _writer.write(ent, 8, 6);\n                } else { // We know it's a control char, so only the last 2 chars are non-0\n                    ent[6] = HEX_CHARS[ch >> 4];\n                    ent[7] = HEX_CHARS[ch & 0xF];\n                    _writer.write(ent, 2, 6);\n                }\n            }\n            return ptr;\n        }\n        String escape;\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (ptr >= len && ptr < end) { // fits in, prepend\n            ptr -= len;\n            escape.getChars(0, len, buffer, ptr);\n        } else { // won't fit, write separately\n            _writer.write(escape);\n        }\n        return ptr;\n    }",
          "27": "    private int _prependOrWriteCharacterEscape(char[] buffer, int ptr, int end,\n            char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (ptr > 1 && ptr < end) { // fits, just prepend\n                ptr -= 2;\n                buffer[ptr] = '\\\\';\n                buffer[ptr+1] = (char) escCode;\n            } else { // won't fit, write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                ent[1] = (char) escCode;\n                _writer.write(ent, 0, 2);\n            }\n            return ptr;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\n            if (ptr > 5 && ptr < end) { // fits, prepend to buffer\n                ptr -= 6;\n                buffer[ptr++] = '\\\\';\n                buffer[ptr++] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\nbuffer[ptr++] = hi[ptr++];\n                    buffer[ptr++] = HEX_CHARS[hi & 0xF];\n                    ch &= 0xFF;\n                } else {\n                    buffer[ptr++] = '0';\n                    buffer[ptr++] = '0';\n                }\n                buffer[ptr++] = HEX_CHARS[ch >> 4];\n                buffer[ptr] = HEX_CHARS[ch & 0xF];\n                ptr -= 5;\n            } else {\n                // won't fit, flush and write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                _outputHead = _outputTail;\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    int lo = ch & 0xFF;\n                    ent[10] = HEX_CHARS[hi >> 4];\n                    ent[11] = HEX_CHARS[hi & 0xF];\n                    ent[12] = HEX_CHARS[lo >> 4];\n                    ent[13] = HEX_CHARS[lo & 0xF];\n                    _writer.write(ent, 8, 6);\n                } else { // We know it's a control char, so only the last 2 chars are non-0\n                    ent[6] = HEX_CHARS[ch >> 4];\n                    ent[7] = HEX_CHARS[ch & 0xF];\n                    _writer.write(ent, 2, 6);\n                }\n            }\n            return ptr;\n        }\n        String escape;\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (ptr >= len && ptr < end) { // fits in, prepend\n            ptr -= len;\n            escape.getChars(0, len, buffer, ptr);\n        } else { // won't fit, write separately\n            _writer.write(escape);\n        }\n        return ptr;\n    }",
          "28": "    private int _prependOrWriteCharacterEscape(char[] buffer, int ptr, int end,\n            char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (ptr > 1 && ptr < end) { // fits, just prepend\n                ptr -= 2;\n                buffer[ptr] = '\\\\';\n                buffer[ptr+1] = (char) escCode;\n            } else { // won't fit, write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                ent[1] = (char) escCode;\n                _writer.write(ent, 0, 2);\n            }\n            return ptr;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\n            if (ptr > 5 && ptr < end) { // fits, prepend to buffer\n                ptr -= 6;\n                buffer[ptr++] = '\\\\';\n                buffer[ptr++] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\nbuffer[ptr++] = HEX_CHARS;\n                    buffer[ptr++] = HEX_CHARS[hi & 0xF];\n                    ch &= 0xFF;\n                } else {\n                    buffer[ptr++] = '0';\n                    buffer[ptr++] = '0';\n                }\n                buffer[ptr++] = HEX_CHARS[ch >> 4];\n                buffer[ptr] = HEX_CHARS[ch & 0xF];\n                ptr -= 5;\n            } else {\n                // won't fit, flush and write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                _outputHead = _outputTail;\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    int lo = ch & 0xFF;\n                    ent[10] = HEX_CHARS[hi >> 4];\n                    ent[11] = HEX_CHARS[hi & 0xF];\n                    ent[12] = HEX_CHARS[lo >> 4];\n                    ent[13] = HEX_CHARS[lo & 0xF];\n                    _writer.write(ent, 8, 6);\n                } else { // We know it's a control char, so only the last 2 chars are non-0\n                    ent[6] = HEX_CHARS[ch >> 4];\n                    ent[7] = HEX_CHARS[ch & 0xF];\n                    _writer.write(ent, 2, 6);\n                }\n            }\n            return ptr;\n        }\n        String escape;\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (ptr >= len && ptr < end) { // fits in, prepend\n            ptr -= len;\n            escape.getChars(0, len, buffer, ptr);\n        } else { // won't fit, write separately\n            _writer.write(escape);\n        }\n        return ptr;\n    }",
          "29": "    private int _prependOrWriteCharacterEscape(char[] buffer, int ptr, int end,\n            char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (ptr > 1 && ptr < end) { // fits, just prepend\n                ptr -= 2;\n                buffer[ptr] = '\\\\';\n                buffer[ptr+1] = (char) escCode;\n            } else { // won't fit, write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                ent[1] = (char) escCode;\n                _writer.write(ent, 0, 2);\n            }\n            return ptr;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\n            if (ptr > 5 && ptr < end) { // fits, prepend to buffer\n                ptr -= 6;\n                buffer[ptr++] = '\\\\';\n                buffer[ptr++] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\nbuffer[ptr++] = _outputBuffer;\n                    buffer[ptr++] = HEX_CHARS[hi & 0xF];\n                    ch &= 0xFF;\n                } else {\n                    buffer[ptr++] = '0';\n                    buffer[ptr++] = '0';\n                }\n                buffer[ptr++] = HEX_CHARS[ch >> 4];\n                buffer[ptr] = HEX_CHARS[ch & 0xF];\n                ptr -= 5;\n            } else {\n                // won't fit, flush and write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                _outputHead = _outputTail;\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    int lo = ch & 0xFF;\n                    ent[10] = HEX_CHARS[hi >> 4];\n                    ent[11] = HEX_CHARS[hi & 0xF];\n                    ent[12] = HEX_CHARS[lo >> 4];\n                    ent[13] = HEX_CHARS[lo & 0xF];\n                    _writer.write(ent, 8, 6);\n                } else { // We know it's a control char, so only the last 2 chars are non-0\n                    ent[6] = HEX_CHARS[ch >> 4];\n                    ent[7] = HEX_CHARS[ch & 0xF];\n                    _writer.write(ent, 2, 6);\n                }\n            }\n            return ptr;\n        }\n        String escape;\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (ptr >= len && ptr < end) { // fits in, prepend\n            ptr -= len;\n            escape.getChars(0, len, buffer, ptr);\n        } else { // won't fit, write separately\n            _writer.write(escape);\n        }\n        return ptr;\n    }",
          "30": "    private int _prependOrWriteCharacterEscape(char[] buffer, int ptr, int end,\n            char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (ptr > 1 && ptr < end) { // fits, just prepend\n                ptr -= 2;\n                buffer[ptr] = '\\\\';\n                buffer[ptr+1] = (char) escCode;\n            } else { // won't fit, write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                ent[1] = (char) escCode;\n                _writer.write(ent, 0, 2);\n            }\n            return ptr;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\n            if (ptr > 5 && ptr < end) { // fits, prepend to buffer\n                ptr -= 6;\n                buffer[ptr++] = '\\\\';\n                buffer[ptr++] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\nbuffer[ptr++] = _entityBuffer;\n                    buffer[ptr++] = HEX_CHARS[hi & 0xF];\n                    ch &= 0xFF;\n                } else {\n                    buffer[ptr++] = '0';\n                    buffer[ptr++] = '0';\n                }\n                buffer[ptr++] = HEX_CHARS[ch >> 4];\n                buffer[ptr] = HEX_CHARS[ch & 0xF];\n                ptr -= 5;\n            } else {\n                // won't fit, flush and write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                _outputHead = _outputTail;\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    int lo = ch & 0xFF;\n                    ent[10] = HEX_CHARS[hi >> 4];\n                    ent[11] = HEX_CHARS[hi & 0xF];\n                    ent[12] = HEX_CHARS[lo >> 4];\n                    ent[13] = HEX_CHARS[lo & 0xF];\n                    _writer.write(ent, 8, 6);\n                } else { // We know it's a control char, so only the last 2 chars are non-0\n                    ent[6] = HEX_CHARS[ch >> 4];\n                    ent[7] = HEX_CHARS[ch & 0xF];\n                    _writer.write(ent, 2, 6);\n                }\n            }\n            return ptr;\n        }\n        String escape;\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (ptr >= len && ptr < end) { // fits in, prepend\n            ptr -= len;\n            escape.getChars(0, len, buffer, ptr);\n        } else { // won't fit, write separately\n            _writer.write(escape);\n        }\n        return ptr;\n    }",
          "31": "    private int _prependOrWriteCharacterEscape(char[] buffer, int ptr, int end,\n            char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (ptr > 1 && ptr < end) { // fits, just prepend\n                ptr -= 2;\n                buffer[ptr] = '\\\\';\n                buffer[ptr+1] = (char) escCode;\n            } else { // won't fit, write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                ent[1] = (char) escCode;\n                _writer.write(ent, 0, 2);\n            }\n            return ptr;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\n            if (ptr > 5 && ptr < end) { // fits, prepend to buffer\n                ptr -= 6;\n                buffer[ptr++] = '\\\\';\n                buffer[ptr++] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\nbuffer[(hi << 4)] = HEX_CHARS[(hi << 4)];\n                    buffer[ptr++] = HEX_CHARS[hi & 0xF];\n                    ch &= 0xFF;\n                } else {\n                    buffer[ptr++] = '0';\n                    buffer[ptr++] = '0';\n                }\n                buffer[ptr++] = HEX_CHARS[ch >> 4];\n                buffer[ptr] = HEX_CHARS[ch & 0xF];\n                ptr -= 5;\n            } else {\n                // won't fit, flush and write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                _outputHead = _outputTail;\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    int lo = ch & 0xFF;\n                    ent[10] = HEX_CHARS[hi >> 4];\n                    ent[11] = HEX_CHARS[hi & 0xF];\n                    ent[12] = HEX_CHARS[lo >> 4];\n                    ent[13] = HEX_CHARS[lo & 0xF];\n                    _writer.write(ent, 8, 6);\n                } else { // We know it's a control char, so only the last 2 chars are non-0\n                    ent[6] = HEX_CHARS[ch >> 4];\n                    ent[7] = HEX_CHARS[ch & 0xF];\n                    _writer.write(ent, 2, 6);\n                }\n            }\n            return ptr;\n        }\n        String escape;\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (ptr >= len && ptr < end) { // fits in, prepend\n            ptr -= len;\n            escape.getChars(0, len, buffer, ptr);\n        } else { // won't fit, write separately\n            _writer.write(escape);\n        }\n        return ptr;\n    }",
          "32": "    private int _prependOrWriteCharacterEscape(char[] buffer, int ptr, int end,\n            char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (ptr > 1 && ptr < end) { // fits, just prepend\n                ptr -= 2;\n                buffer[ptr] = '\\\\';\n                buffer[ptr+1] = (char) escCode;\n            } else { // won't fit, write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                ent[1] = (char) escCode;\n                _writer.write(ent, 0, 2);\n            }\n            return ptr;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\n            if (ptr > 5 && ptr < end) { // fits, prepend to buffer\n                ptr -= 6;\n                buffer[ptr++] = '\\\\';\n                buffer[ptr++] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\nbuffer[ptr++] = hi[(hi & 0xF)];\n                    buffer[ptr++] = HEX_CHARS[hi & 0xF];\n                    ch &= 0xFF;\n                } else {\n                    buffer[ptr++] = '0';\n                    buffer[ptr++] = '0';\n                }\n                buffer[ptr++] = HEX_CHARS[ch >> 4];\n                buffer[ptr] = HEX_CHARS[ch & 0xF];\n                ptr -= 5;\n            } else {\n                // won't fit, flush and write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                _outputHead = _outputTail;\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    int lo = ch & 0xFF;\n                    ent[10] = HEX_CHARS[hi >> 4];\n                    ent[11] = HEX_CHARS[hi & 0xF];\n                    ent[12] = HEX_CHARS[lo >> 4];\n                    ent[13] = HEX_CHARS[lo & 0xF];\n                    _writer.write(ent, 8, 6);\n                } else { // We know it's a control char, so only the last 2 chars are non-0\n                    ent[6] = HEX_CHARS[ch >> 4];\n                    ent[7] = HEX_CHARS[ch & 0xF];\n                    _writer.write(ent, 2, 6);\n                }\n            }\n            return ptr;\n        }\n        String escape;\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (ptr >= len && ptr < end) { // fits in, prepend\n            ptr -= len;\n            escape.getChars(0, len, buffer, ptr);\n        } else { // won't fit, write separately\n            _writer.write(escape);\n        }\n        return ptr;\n    }",
          "33": "    private int _prependOrWriteCharacterEscape(char[] buffer, int ptr, int end,\n            char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (ptr > 1 && ptr < end) { // fits, just prepend\n                ptr -= 2;\n                buffer[ptr] = '\\\\';\n                buffer[ptr+1] = (char) escCode;\n            } else { // won't fit, write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                ent[1] = (char) escCode;\n                _writer.write(ent, 0, 2);\n            }\n            return ptr;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\n            if (ptr > 5 && ptr < end) { // fits, prepend to buffer\n                ptr -= 6;\n                buffer[ptr++] = '\\\\';\n                buffer[ptr++] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\nbuffer[ptr] = HEX_CHARS[(ch & 0xF)];\n                    buffer[ptr++] = HEX_CHARS[hi << 4];                    buffer[ptr++] = HEX_CHARS[hi & 0xF];\n                    ch &= 0xFF;\n                } else {\n                    buffer[ptr++] = '0';\n                    buffer[ptr++] = '0';\n                }\n                buffer[ptr++] = HEX_CHARS[ch >> 4];\n                buffer[ptr] = HEX_CHARS[ch & 0xF];\n                ptr -= 5;\n            } else {\n                // won't fit, flush and write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                _outputHead = _outputTail;\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    int lo = ch & 0xFF;\n                    ent[10] = HEX_CHARS[hi >> 4];\n                    ent[11] = HEX_CHARS[hi & 0xF];\n                    ent[12] = HEX_CHARS[lo >> 4];\n                    ent[13] = HEX_CHARS[lo & 0xF];\n                    _writer.write(ent, 8, 6);\n                } else { // We know it's a control char, so only the last 2 chars are non-0\n                    ent[6] = HEX_CHARS[ch >> 4];\n                    ent[7] = HEX_CHARS[ch & 0xF];\n                    _writer.write(ent, 2, 6);\n                }\n            }\n            return ptr;\n        }\n        String escape;\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (ptr >= len && ptr < end) { // fits in, prepend\n            ptr -= len;\n            escape.getChars(0, len, buffer, ptr);\n        } else { // won't fit, write separately\n            _writer.write(escape);\n        }\n        return ptr;\n    }",
          "34": "    private int _prependOrWriteCharacterEscape(char[] buffer, int ptr, int end,\n            char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (ptr > 1 && ptr < end) { // fits, just prepend\n                ptr -= 2;\n                buffer[ptr] = '\\\\';\n                buffer[ptr+1] = (char) escCode;\n            } else { // won't fit, write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                ent[1] = (char) escCode;\n                _writer.write(ent, 0, 2);\n            }\n            return ptr;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\n            if (ptr > 5 && ptr < end) { // fits, prepend to buffer\n                ptr -= 6;\n                buffer[ptr++] = '\\\\';\n                buffer[ptr++] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\nif((hi != null)){\n                    buffer[ptr++] = HEX_CHARS[hi << 4];                    buffer[ptr++] = HEX_CHARS[hi & 0xF];\n                    ch &= 0xFF;\n                } else {\n                    buffer[ptr++] = '0';\n                    buffer[ptr++] = '0';\n}\n                }\n                buffer[ptr++] = HEX_CHARS[ch >> 4];\n                buffer[ptr] = HEX_CHARS[ch & 0xF];\n                ptr -= 5;\n            } else {\n                // won't fit, flush and write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                _outputHead = _outputTail;\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    int lo = ch & 0xFF;\n                    ent[10] = HEX_CHARS[hi >> 4];\n                    ent[11] = HEX_CHARS[hi & 0xF];\n                    ent[12] = HEX_CHARS[lo >> 4];\n                    ent[13] = HEX_CHARS[lo & 0xF];\n                    _writer.write(ent, 8, 6);\n                } else { // We know it's a control char, so only the last 2 chars are non-0\n                    ent[6] = HEX_CHARS[ch >> 4];\n                    ent[7] = HEX_CHARS[ch & 0xF];\n                    _writer.write(ent, 2, 6);\n                }\n            }\n            return ptr;\n        }\n        String escape;\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (ptr >= len && ptr < end) { // fits in, prepend\n            ptr -= len;\n            escape.getChars(0, len, buffer, ptr);\n        } else { // won't fit, write separately\n            _writer.write(escape);\n        }\n        return ptr;\n    }",
          "35": "    private int _prependOrWriteCharacterEscape(char[] buffer, int ptr, int end,\n            char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (ptr > 1 && ptr < end) { // fits, just prepend\n                ptr -= 2;\n                buffer[ptr] = '\\\\';\n                buffer[ptr+1] = (char) escCode;\n            } else { // won't fit, write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                ent[1] = (char) escCode;\n                _writer.write(ent, 0, 2);\n            }\n            return ptr;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\n            if (ptr > 5 && ptr < end) { // fits, prepend to buffer\n                ptr -= 6;\n                buffer[ptr++] = '\\\\';\n                buffer[ptr++] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\nif((ptr < end)){\n                    buffer[ptr++] = HEX_CHARS[hi << 4];                    buffer[ptr++] = HEX_CHARS[hi & 0xF];\n                    ch &= 0xFF;\n                } else {\n                    buffer[ptr++] = '0';\n                    buffer[ptr++] = '0';\n}\n                }\n                buffer[ptr++] = HEX_CHARS[ch >> 4];\n                buffer[ptr] = HEX_CHARS[ch & 0xF];\n                ptr -= 5;\n            } else {\n                // won't fit, flush and write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                _outputHead = _outputTail;\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    int lo = ch & 0xFF;\n                    ent[10] = HEX_CHARS[hi >> 4];\n                    ent[11] = HEX_CHARS[hi & 0xF];\n                    ent[12] = HEX_CHARS[lo >> 4];\n                    ent[13] = HEX_CHARS[lo & 0xF];\n                    _writer.write(ent, 8, 6);\n                } else { // We know it's a control char, so only the last 2 chars are non-0\n                    ent[6] = HEX_CHARS[ch >> 4];\n                    ent[7] = HEX_CHARS[ch & 0xF];\n                    _writer.write(ent, 2, 6);\n                }\n            }\n            return ptr;\n        }\n        String escape;\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (ptr >= len && ptr < end) { // fits in, prepend\n            ptr -= len;\n            escape.getChars(0, len, buffer, ptr);\n        } else { // won't fit, write separately\n            _writer.write(escape);\n        }\n        return ptr;\n    }",
          "36": "    private int _prependOrWriteCharacterEscape(char[] buffer, int ptr, int end,\n            char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (ptr > 1 && ptr < end) { // fits, just prepend\n                ptr -= 2;\n                buffer[ptr] = '\\\\';\n                buffer[ptr+1] = (char) escCode;\n            } else { // won't fit, write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                ent[1] = (char) escCode;\n                _writer.write(ent, 0, 2);\n            }\n            return ptr;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\n            if (ptr > 5 && ptr < end) { // fits, prepend to buffer\n                ptr -= 6;\n                buffer[ptr++] = '\\\\';\n                buffer[ptr++] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\nbuffer[ptr++] = HEX_CHARS[(ch >> 4)];\n                    buffer[ptr++] = HEX_CHARS[hi << 4];                    buffer[ptr++] = HEX_CHARS[hi & 0xF];\n                    ch &= 0xFF;\n                } else {\n                    buffer[ptr++] = '0';\n                    buffer[ptr++] = '0';\n                }\n                buffer[ptr++] = HEX_CHARS[ch >> 4];\n                buffer[ptr] = HEX_CHARS[ch & 0xF];\n                ptr -= 5;\n            } else {\n                // won't fit, flush and write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                _outputHead = _outputTail;\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    int lo = ch & 0xFF;\n                    ent[10] = HEX_CHARS[hi >> 4];\n                    ent[11] = HEX_CHARS[hi & 0xF];\n                    ent[12] = HEX_CHARS[lo >> 4];\n                    ent[13] = HEX_CHARS[lo & 0xF];\n                    _writer.write(ent, 8, 6);\n                } else { // We know it's a control char, so only the last 2 chars are non-0\n                    ent[6] = HEX_CHARS[ch >> 4];\n                    ent[7] = HEX_CHARS[ch & 0xF];\n                    _writer.write(ent, 2, 6);\n                }\n            }\n            return ptr;\n        }\n        String escape;\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (ptr >= len && ptr < end) { // fits in, prepend\n            ptr -= len;\n            escape.getChars(0, len, buffer, ptr);\n        } else { // won't fit, write separately\n            _writer.write(escape);\n        }\n        return ptr;\n    }",
          "37": "    private int _prependOrWriteCharacterEscape(char[] buffer, int ptr, int end,\n            char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (ptr > 1 && ptr < end) { // fits, just prepend\n                ptr -= 2;\n                buffer[ptr] = '\\\\';\n                buffer[ptr+1] = (char) escCode;\n            } else { // won't fit, write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                ent[1] = (char) escCode;\n                _writer.write(ent, 0, 2);\n            }\n            return ptr;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\n            if (ptr > 5 && ptr < end) { // fits, prepend to buffer\n                ptr -= 6;\n                buffer[ptr++] = '\\\\';\n                buffer[ptr++] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\nbuffer[ptr++] = HEX_CHARS[ptr];\n                    buffer[ptr++] = HEX_CHARS[hi & 0xF];\n                    ch &= 0xFF;\n                } else {\n                    buffer[ptr++] = '0';\n                    buffer[ptr++] = '0';\n                }\n                buffer[ptr++] = HEX_CHARS[ch >> 4];\n                buffer[ptr] = HEX_CHARS[ch & 0xF];\n                ptr -= 5;\n            } else {\n                // won't fit, flush and write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                _outputHead = _outputTail;\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    int lo = ch & 0xFF;\n                    ent[10] = HEX_CHARS[hi >> 4];\n                    ent[11] = HEX_CHARS[hi & 0xF];\n                    ent[12] = HEX_CHARS[lo >> 4];\n                    ent[13] = HEX_CHARS[lo & 0xF];\n                    _writer.write(ent, 8, 6);\n                } else { // We know it's a control char, so only the last 2 chars are non-0\n                    ent[6] = HEX_CHARS[ch >> 4];\n                    ent[7] = HEX_CHARS[ch & 0xF];\n                    _writer.write(ent, 2, 6);\n                }\n            }\n            return ptr;\n        }\n        String escape;\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (ptr >= len && ptr < end) { // fits in, prepend\n            ptr -= len;\n            escape.getChars(0, len, buffer, ptr);\n        } else { // won't fit, write separately\n            _writer.write(escape);\n        }\n        return ptr;\n    }",
          "38": "    private int _prependOrWriteCharacterEscape(char[] buffer, int ptr, int end,\n            char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (ptr > 1 && ptr < end) { // fits, just prepend\n                ptr -= 2;\n                buffer[ptr] = '\\\\';\n                buffer[ptr+1] = (char) escCode;\n            } else { // won't fit, write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                ent[1] = (char) escCode;\n                _writer.write(ent, 0, 2);\n            }\n            return ptr;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\n            if (ptr > 5 && ptr < end) { // fits, prepend to buffer\n                ptr -= 6;\n                buffer[ptr++] = '\\\\';\n                buffer[ptr++] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\nbuffer[ptr++] = (hi & 0xF);\n                    buffer[ptr++] = HEX_CHARS[hi & 0xF];\n                    ch &= 0xFF;\n                } else {\n                    buffer[ptr++] = '0';\n                    buffer[ptr++] = '0';\n                }\n                buffer[ptr++] = HEX_CHARS[ch >> 4];\n                buffer[ptr] = HEX_CHARS[ch & 0xF];\n                ptr -= 5;\n            } else {\n                // won't fit, flush and write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                _outputHead = _outputTail;\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    int lo = ch & 0xFF;\n                    ent[10] = HEX_CHARS[hi >> 4];\n                    ent[11] = HEX_CHARS[hi & 0xF];\n                    ent[12] = HEX_CHARS[lo >> 4];\n                    ent[13] = HEX_CHARS[lo & 0xF];\n                    _writer.write(ent, 8, 6);\n                } else { // We know it's a control char, so only the last 2 chars are non-0\n                    ent[6] = HEX_CHARS[ch >> 4];\n                    ent[7] = HEX_CHARS[ch & 0xF];\n                    _writer.write(ent, 2, 6);\n                }\n            }\n            return ptr;\n        }\n        String escape;\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (ptr >= len && ptr < end) { // fits in, prepend\n            ptr -= len;\n            escape.getChars(0, len, buffer, ptr);\n        } else { // won't fit, write separately\n            _writer.write(escape);\n        }\n        return ptr;\n    }",
          "39": "    private int _prependOrWriteCharacterEscape(char[] buffer, int ptr, int end,\n            char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (ptr > 1 && ptr < end) { // fits, just prepend\n                ptr -= 2;\n                buffer[ptr] = '\\\\';\n                buffer[ptr+1] = (char) escCode;\n            } else { // won't fit, write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                ent[1] = (char) escCode;\n                _writer.write(ent, 0, 2);\n            }\n            return ptr;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\n            if (ptr > 5 && ptr < end) { // fits, prepend to buffer\n                ptr -= 6;\n                buffer[ptr++] = '\\\\';\n                buffer[ptr++] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\nbuffer[ptr++] = HEX_CHARS[(hi << 1)];\n                    buffer[ptr++] = HEX_CHARS[hi & 0xF];\n                    ch &= 0xFF;\n                } else {\n                    buffer[ptr++] = '0';\n                    buffer[ptr++] = '0';\n                }\n                buffer[ptr++] = HEX_CHARS[ch >> 4];\n                buffer[ptr] = HEX_CHARS[ch & 0xF];\n                ptr -= 5;\n            } else {\n                // won't fit, flush and write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                _outputHead = _outputTail;\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    int lo = ch & 0xFF;\n                    ent[10] = HEX_CHARS[hi >> 4];\n                    ent[11] = HEX_CHARS[hi & 0xF];\n                    ent[12] = HEX_CHARS[lo >> 4];\n                    ent[13] = HEX_CHARS[lo & 0xF];\n                    _writer.write(ent, 8, 6);\n                } else { // We know it's a control char, so only the last 2 chars are non-0\n                    ent[6] = HEX_CHARS[ch >> 4];\n                    ent[7] = HEX_CHARS[ch & 0xF];\n                    _writer.write(ent, 2, 6);\n                }\n            }\n            return ptr;\n        }\n        String escape;\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (ptr >= len && ptr < end) { // fits in, prepend\n            ptr -= len;\n            escape.getChars(0, len, buffer, ptr);\n        } else { // won't fit, write separately\n            _writer.write(escape);\n        }\n        return ptr;\n    }",
          "40": "    private int _prependOrWriteCharacterEscape(char[] buffer, int ptr, int end,\n            char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (ptr > 1 && ptr < end) { // fits, just prepend\n                ptr -= 2;\n                buffer[ptr] = '\\\\';\n                buffer[ptr+1] = (char) escCode;\n            } else { // won't fit, write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                ent[1] = (char) escCode;\n                _writer.write(ent, 0, 2);\n            }\n            return ptr;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\n            if (ptr > 5 && ptr < end) { // fits, prepend to buffer\n                ptr -= 6;\n                buffer[ptr++] = '\\\\';\n                buffer[ptr++] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\nhi = HEX_CHARS[(hi << 4)];\n                    buffer[ptr++] = HEX_CHARS[hi & 0xF];\n                    ch &= 0xFF;\n                } else {\n                    buffer[ptr++] = '0';\n                    buffer[ptr++] = '0';\n                }\n                buffer[ptr++] = HEX_CHARS[ch >> 4];\n                buffer[ptr] = HEX_CHARS[ch & 0xF];\n                ptr -= 5;\n            } else {\n                // won't fit, flush and write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                _outputHead = _outputTail;\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    int lo = ch & 0xFF;\n                    ent[10] = HEX_CHARS[hi >> 4];\n                    ent[11] = HEX_CHARS[hi & 0xF];\n                    ent[12] = HEX_CHARS[lo >> 4];\n                    ent[13] = HEX_CHARS[lo & 0xF];\n                    _writer.write(ent, 8, 6);\n                } else { // We know it's a control char, so only the last 2 chars are non-0\n                    ent[6] = HEX_CHARS[ch >> 4];\n                    ent[7] = HEX_CHARS[ch & 0xF];\n                    _writer.write(ent, 2, 6);\n                }\n            }\n            return ptr;\n        }\n        String escape;\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (ptr >= len && ptr < end) { // fits in, prepend\n            ptr -= len;\n            escape.getChars(0, len, buffer, ptr);\n        } else { // won't fit, write separately\n            _writer.write(escape);\n        }\n        return ptr;\n    }",
          "41": "    private int _prependOrWriteCharacterEscape(char[] buffer, int ptr, int end,\n            char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (ptr > 1 && ptr < end) { // fits, just prepend\n                ptr -= 2;\n                buffer[ptr] = '\\\\';\n                buffer[ptr+1] = (char) escCode;\n            } else { // won't fit, write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                ent[1] = (char) escCode;\n                _writer.write(ent, 0, 2);\n            }\n            return ptr;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\n            if (ptr > 5 && ptr < end) { // fits, prepend to buffer\n                ptr -= 6;\n                buffer[ptr++] = '\\\\';\n                buffer[ptr++] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\nif((ptr > 5)){\n                    buffer[ptr++] = HEX_CHARS[hi << 4];                    buffer[ptr++] = HEX_CHARS[hi & 0xF];\n                    ch &= 0xFF;\n                } else {\n                    buffer[ptr++] = '0';\n                    buffer[ptr++] = '0';\n}\n                }\n                buffer[ptr++] = HEX_CHARS[ch >> 4];\n                buffer[ptr] = HEX_CHARS[ch & 0xF];\n                ptr -= 5;\n            } else {\n                // won't fit, flush and write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                _outputHead = _outputTail;\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    int lo = ch & 0xFF;\n                    ent[10] = HEX_CHARS[hi >> 4];\n                    ent[11] = HEX_CHARS[hi & 0xF];\n                    ent[12] = HEX_CHARS[lo >> 4];\n                    ent[13] = HEX_CHARS[lo & 0xF];\n                    _writer.write(ent, 8, 6);\n                } else { // We know it's a control char, so only the last 2 chars are non-0\n                    ent[6] = HEX_CHARS[ch >> 4];\n                    ent[7] = HEX_CHARS[ch & 0xF];\n                    _writer.write(ent, 2, 6);\n                }\n            }\n            return ptr;\n        }\n        String escape;\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (ptr >= len && ptr < end) { // fits in, prepend\n            ptr -= len;\n            escape.getChars(0, len, buffer, ptr);\n        } else { // won't fit, write separately\n            _writer.write(escape);\n        }\n        return ptr;\n    }",
          "42": "    private int _prependOrWriteCharacterEscape(char[] buffer, int ptr, int end,\n            char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (ptr > 1 && ptr < end) { // fits, just prepend\n                ptr -= 2;\n                buffer[ptr] = '\\\\';\n                buffer[ptr+1] = (char) escCode;\n            } else { // won't fit, write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                ent[1] = (char) escCode;\n                _writer.write(ent, 0, 2);\n            }\n            return ptr;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\n            if (ptr > 5 && ptr < end) { // fits, prepend to buffer\n                ptr -= 6;\n                buffer[ptr++] = '\\\\';\n                buffer[ptr++] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\nptr -= 6;\n                    buffer[ptr++] = HEX_CHARS[hi << 4];                    buffer[ptr++] = HEX_CHARS[hi & 0xF];\n                    ch &= 0xFF;\n                } else {\n                    buffer[ptr++] = '0';\n                    buffer[ptr++] = '0';\n                }\n                buffer[ptr++] = HEX_CHARS[ch >> 4];\n                buffer[ptr] = HEX_CHARS[ch & 0xF];\n                ptr -= 5;\n            } else {\n                // won't fit, flush and write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                _outputHead = _outputTail;\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    int lo = ch & 0xFF;\n                    ent[10] = HEX_CHARS[hi >> 4];\n                    ent[11] = HEX_CHARS[hi & 0xF];\n                    ent[12] = HEX_CHARS[lo >> 4];\n                    ent[13] = HEX_CHARS[lo & 0xF];\n                    _writer.write(ent, 8, 6);\n                } else { // We know it's a control char, so only the last 2 chars are non-0\n                    ent[6] = HEX_CHARS[ch >> 4];\n                    ent[7] = HEX_CHARS[ch & 0xF];\n                    _writer.write(ent, 2, 6);\n                }\n            }\n            return ptr;\n        }\n        String escape;\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (ptr >= len && ptr < end) { // fits in, prepend\n            ptr -= len;\n            escape.getChars(0, len, buffer, ptr);\n        } else { // won't fit, write separately\n            _writer.write(escape);\n        }\n        return ptr;\n    }",
          "43": "    private int _prependOrWriteCharacterEscape(char[] buffer, int ptr, int end,\n            char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (ptr > 1 && ptr < end) { // fits, just prepend\n                ptr -= 2;\n                buffer[ptr] = '\\\\';\n                buffer[ptr+1] = (char) escCode;\n            } else { // won't fit, write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                ent[1] = (char) escCode;\n                _writer.write(ent, 0, 2);\n            }\n            return ptr;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\n            if (ptr > 5 && ptr < end) { // fits, prepend to buffer\n                ptr -= 6;\n                buffer[ptr++] = '\\\\';\n                buffer[ptr++] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\nbuffer[ptr++] = buffer[(ch >> 4)];\n                    buffer[ptr++] = HEX_CHARS[hi & 0xF];\n                    ch &= 0xFF;\n                } else {\n                    buffer[ptr++] = '0';\n                    buffer[ptr++] = '0';\n                }\n                buffer[ptr++] = HEX_CHARS[ch >> 4];\n                buffer[ptr] = HEX_CHARS[ch & 0xF];\n                ptr -= 5;\n            } else {\n                // won't fit, flush and write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                _outputHead = _outputTail;\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    int lo = ch & 0xFF;\n                    ent[10] = HEX_CHARS[hi >> 4];\n                    ent[11] = HEX_CHARS[hi & 0xF];\n                    ent[12] = HEX_CHARS[lo >> 4];\n                    ent[13] = HEX_CHARS[lo & 0xF];\n                    _writer.write(ent, 8, 6);\n                } else { // We know it's a control char, so only the last 2 chars are non-0\n                    ent[6] = HEX_CHARS[ch >> 4];\n                    ent[7] = HEX_CHARS[ch & 0xF];\n                    _writer.write(ent, 2, 6);\n                }\n            }\n            return ptr;\n        }\n        String escape;\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (ptr >= len && ptr < end) { // fits in, prepend\n            ptr -= len;\n            escape.getChars(0, len, buffer, ptr);\n        } else { // won't fit, write separately\n            _writer.write(escape);\n        }\n        return ptr;\n    }",
          "44": "    private int _prependOrWriteCharacterEscape(char[] buffer, int ptr, int end,\n            char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (ptr > 1 && ptr < end) { // fits, just prepend\n                ptr -= 2;\n                buffer[ptr] = '\\\\';\n                buffer[ptr+1] = (char) escCode;\n            } else { // won't fit, write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                ent[1] = (char) escCode;\n                _writer.write(ent, 0, 2);\n            }\n            return ptr;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\n            if (ptr > 5 && ptr < end) { // fits, prepend to buffer\n                ptr -= 6;\n                buffer[ptr++] = '\\\\';\n                buffer[ptr++] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\nreturn;\n                    buffer[ptr++] = HEX_CHARS[hi & 0xF];\n                    ch &= 0xFF;\n                } else {\n                    buffer[ptr++] = '0';\n                    buffer[ptr++] = '0';\n                }\n                buffer[ptr++] = HEX_CHARS[ch >> 4];\n                buffer[ptr] = HEX_CHARS[ch & 0xF];\n                ptr -= 5;\n            } else {\n                // won't fit, flush and write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                _outputHead = _outputTail;\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    int lo = ch & 0xFF;\n                    ent[10] = HEX_CHARS[hi >> 4];\n                    ent[11] = HEX_CHARS[hi & 0xF];\n                    ent[12] = HEX_CHARS[lo >> 4];\n                    ent[13] = HEX_CHARS[lo & 0xF];\n                    _writer.write(ent, 8, 6);\n                } else { // We know it's a control char, so only the last 2 chars are non-0\n                    ent[6] = HEX_CHARS[ch >> 4];\n                    ent[7] = HEX_CHARS[ch & 0xF];\n                    _writer.write(ent, 2, 6);\n                }\n            }\n            return ptr;\n        }\n        String escape;\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (ptr >= len && ptr < end) { // fits in, prepend\n            ptr -= len;\n            escape.getChars(0, len, buffer, ptr);\n        } else { // won't fit, write separately\n            _writer.write(escape);\n        }\n        return ptr;\n    }",
          "45": "    private int _prependOrWriteCharacterEscape(char[] buffer, int ptr, int end,\n            char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (ptr > 1 && ptr < end) { // fits, just prepend\n                ptr -= 2;\n                buffer[ptr] = '\\\\';\n                buffer[ptr+1] = (char) escCode;\n            } else { // won't fit, write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                ent[1] = (char) escCode;\n                _writer.write(ent, 0, 2);\n            }\n            return ptr;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\n            if (ptr > 5 && ptr < end) { // fits, prepend to buffer\n                ptr -= 6;\n                buffer[ptr++] = '\\\\';\n                buffer[ptr++] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\nbuffer[ptr] = HEX_CHARS[(ch & 0xF)];\n                    buffer[ptr++] = HEX_CHARS[hi & 0xF];\n                    ch &= 0xFF;\n                } else {\n                    buffer[ptr++] = '0';\n                    buffer[ptr++] = '0';\n                }\n                buffer[ptr++] = HEX_CHARS[ch >> 4];\n                buffer[ptr] = HEX_CHARS[ch & 0xF];\n                ptr -= 5;\n            } else {\n                // won't fit, flush and write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                _outputHead = _outputTail;\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    int lo = ch & 0xFF;\n                    ent[10] = HEX_CHARS[hi >> 4];\n                    ent[11] = HEX_CHARS[hi & 0xF];\n                    ent[12] = HEX_CHARS[lo >> 4];\n                    ent[13] = HEX_CHARS[lo & 0xF];\n                    _writer.write(ent, 8, 6);\n                } else { // We know it's a control char, so only the last 2 chars are non-0\n                    ent[6] = HEX_CHARS[ch >> 4];\n                    ent[7] = HEX_CHARS[ch & 0xF];\n                    _writer.write(ent, 2, 6);\n                }\n            }\n            return ptr;\n        }\n        String escape;\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (ptr >= len && ptr < end) { // fits in, prepend\n            ptr -= len;\n            escape.getChars(0, len, buffer, ptr);\n        } else { // won't fit, write separately\n            _writer.write(escape);\n        }\n        return ptr;\n    }",
          "46": "    private int _prependOrWriteCharacterEscape(char[] buffer, int ptr, int end,\n            char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (ptr > 1 && ptr < end) { // fits, just prepend\n                ptr -= 2;\n                buffer[ptr] = '\\\\';\n                buffer[ptr+1] = (char) escCode;\n            } else { // won't fit, write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                ent[1] = (char) escCode;\n                _writer.write(ent, 0, 2);\n            }\n            return ptr;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\n            if (ptr > 5 && ptr < end) { // fits, prepend to buffer\n                ptr -= 6;\n                buffer[ptr++] = '\\\\';\n                buffer[ptr++] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\nptr -= 5;\n                    buffer[ptr++] = HEX_CHARS[hi & 0xF];\n                    ch &= 0xFF;\n                } else {\n                    buffer[ptr++] = '0';\n                    buffer[ptr++] = '0';\n                }\n                buffer[ptr++] = HEX_CHARS[ch >> 4];\n                buffer[ptr] = HEX_CHARS[ch & 0xF];\n                ptr -= 5;\n            } else {\n                // won't fit, flush and write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                _outputHead = _outputTail;\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    int lo = ch & 0xFF;\n                    ent[10] = HEX_CHARS[hi >> 4];\n                    ent[11] = HEX_CHARS[hi & 0xF];\n                    ent[12] = HEX_CHARS[lo >> 4];\n                    ent[13] = HEX_CHARS[lo & 0xF];\n                    _writer.write(ent, 8, 6);\n                } else { // We know it's a control char, so only the last 2 chars are non-0\n                    ent[6] = HEX_CHARS[ch >> 4];\n                    ent[7] = HEX_CHARS[ch & 0xF];\n                    _writer.write(ent, 2, 6);\n                }\n            }\n            return ptr;\n        }\n        String escape;\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (ptr >= len && ptr < end) { // fits in, prepend\n            ptr -= len;\n            escape.getChars(0, len, buffer, ptr);\n        } else { // won't fit, write separately\n            _writer.write(escape);\n        }\n        return ptr;\n    }",
          "47": "    private int _prependOrWriteCharacterEscape(char[] buffer, int ptr, int end,\n            char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (ptr > 1 && ptr < end) { // fits, just prepend\n                ptr -= 2;\n                buffer[ptr] = '\\\\';\n                buffer[ptr+1] = (char) escCode;\n            } else { // won't fit, write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                ent[1] = (char) escCode;\n                _writer.write(ent, 0, 2);\n            }\n            return ptr;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\n            if (ptr > 5 && ptr < end) { // fits, prepend to buffer\n                ptr -= 6;\n                buffer[ptr++] = '\\\\';\n                buffer[ptr++] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\nptr -= 6;\n                    buffer[ptr++] = HEX_CHARS[hi & 0xF];\n                    ch &= 0xFF;\n                } else {\n                    buffer[ptr++] = '0';\n                    buffer[ptr++] = '0';\n                }\n                buffer[ptr++] = HEX_CHARS[ch >> 4];\n                buffer[ptr] = HEX_CHARS[ch & 0xF];\n                ptr -= 5;\n            } else {\n                // won't fit, flush and write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                _outputHead = _outputTail;\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    int lo = ch & 0xFF;\n                    ent[10] = HEX_CHARS[hi >> 4];\n                    ent[11] = HEX_CHARS[hi & 0xF];\n                    ent[12] = HEX_CHARS[lo >> 4];\n                    ent[13] = HEX_CHARS[lo & 0xF];\n                    _writer.write(ent, 8, 6);\n                } else { // We know it's a control char, so only the last 2 chars are non-0\n                    ent[6] = HEX_CHARS[ch >> 4];\n                    ent[7] = HEX_CHARS[ch & 0xF];\n                    _writer.write(ent, 2, 6);\n                }\n            }\n            return ptr;\n        }\n        String escape;\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (ptr >= len && ptr < end) { // fits in, prepend\n            ptr -= len;\n            escape.getChars(0, len, buffer, ptr);\n        } else { // won't fit, write separately\n            _writer.write(escape);\n        }\n        return ptr;\n    }",
          "48": "    private int _prependOrWriteCharacterEscape(char[] buffer, int ptr, int end,\n            char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (ptr > 1 && ptr < end) { // fits, just prepend\n                ptr -= 2;\n                buffer[ptr] = '\\\\';\n                buffer[ptr+1] = (char) escCode;\n            } else { // won't fit, write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                ent[1] = (char) escCode;\n                _writer.write(ent, 0, 2);\n            }\n            return ptr;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\n            if (ptr > 5 && ptr < end) { // fits, prepend to buffer\n                ptr -= 6;\n                buffer[ptr++] = '\\\\';\n                buffer[ptr++] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\nbuffer[ptr++] = HEX_CHARS[(hi <= 4)];\n                    buffer[ptr++] = HEX_CHARS[hi & 0xF];\n                    ch &= 0xFF;\n                } else {\n                    buffer[ptr++] = '0';\n                    buffer[ptr++] = '0';\n                }\n                buffer[ptr++] = HEX_CHARS[ch >> 4];\n                buffer[ptr] = HEX_CHARS[ch & 0xF];\n                ptr -= 5;\n            } else {\n                // won't fit, flush and write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                _outputHead = _outputTail;\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    int lo = ch & 0xFF;\n                    ent[10] = HEX_CHARS[hi >> 4];\n                    ent[11] = HEX_CHARS[hi & 0xF];\n                    ent[12] = HEX_CHARS[lo >> 4];\n                    ent[13] = HEX_CHARS[lo & 0xF];\n                    _writer.write(ent, 8, 6);\n                } else { // We know it's a control char, so only the last 2 chars are non-0\n                    ent[6] = HEX_CHARS[ch >> 4];\n                    ent[7] = HEX_CHARS[ch & 0xF];\n                    _writer.write(ent, 2, 6);\n                }\n            }\n            return ptr;\n        }\n        String escape;\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (ptr >= len && ptr < end) { // fits in, prepend\n            ptr -= len;\n            escape.getChars(0, len, buffer, ptr);\n        } else { // won't fit, write separately\n            _writer.write(escape);\n        }\n        return ptr;\n    }",
          "49": "    private int _prependOrWriteCharacterEscape(char[] buffer, int ptr, int end,\n            char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (ptr > 1 && ptr < end) { // fits, just prepend\n                ptr -= 2;\n                buffer[ptr] = '\\\\';\n                buffer[ptr+1] = (char) escCode;\n            } else { // won't fit, write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                ent[1] = (char) escCode;\n                _writer.write(ent, 0, 2);\n            }\n            return ptr;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\n            if (ptr > 5 && ptr < end) { // fits, prepend to buffer\n                ptr -= 6;\n                buffer[ptr++] = '\\\\';\n                buffer[ptr++] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\nbuffer[ptr++] = HEX_CHARS[(hi > 4)];\n                    buffer[ptr++] = HEX_CHARS[hi & 0xF];\n                    ch &= 0xFF;\n                } else {\n                    buffer[ptr++] = '0';\n                    buffer[ptr++] = '0';\n                }\n                buffer[ptr++] = HEX_CHARS[ch >> 4];\n                buffer[ptr] = HEX_CHARS[ch & 0xF];\n                ptr -= 5;\n            } else {\n                // won't fit, flush and write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                _outputHead = _outputTail;\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    int lo = ch & 0xFF;\n                    ent[10] = HEX_CHARS[hi >> 4];\n                    ent[11] = HEX_CHARS[hi & 0xF];\n                    ent[12] = HEX_CHARS[lo >> 4];\n                    ent[13] = HEX_CHARS[lo & 0xF];\n                    _writer.write(ent, 8, 6);\n                } else { // We know it's a control char, so only the last 2 chars are non-0\n                    ent[6] = HEX_CHARS[ch >> 4];\n                    ent[7] = HEX_CHARS[ch & 0xF];\n                    _writer.write(ent, 2, 6);\n                }\n            }\n            return ptr;\n        }\n        String escape;\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (ptr >= len && ptr < end) { // fits in, prepend\n            ptr -= len;\n            escape.getChars(0, len, buffer, ptr);\n        } else { // won't fit, write separately\n            _writer.write(escape);\n        }\n        return ptr;\n    }",
          "50": "    private int _prependOrWriteCharacterEscape(char[] buffer, int ptr, int end,\n            char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (ptr > 1 && ptr < end) { // fits, just prepend\n                ptr -= 2;\n                buffer[ptr] = '\\\\';\n                buffer[ptr+1] = (char) escCode;\n            } else { // won't fit, write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                ent[1] = (char) escCode;\n                _writer.write(ent, 0, 2);\n            }\n            return ptr;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\n            if (ptr > 5 && ptr < end) { // fits, prepend to buffer\n                ptr -= 6;\n                buffer[ptr++] = '\\\\';\n                buffer[ptr++] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\nbuffer[ptr++] = HEX_CHARS[(hi >= 4)];\n                    buffer[ptr++] = HEX_CHARS[hi & 0xF];\n                    ch &= 0xFF;\n                } else {\n                    buffer[ptr++] = '0';\n                    buffer[ptr++] = '0';\n                }\n                buffer[ptr++] = HEX_CHARS[ch >> 4];\n                buffer[ptr] = HEX_CHARS[ch & 0xF];\n                ptr -= 5;\n            } else {\n                // won't fit, flush and write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                _outputHead = _outputTail;\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    int lo = ch & 0xFF;\n                    ent[10] = HEX_CHARS[hi >> 4];\n                    ent[11] = HEX_CHARS[hi & 0xF];\n                    ent[12] = HEX_CHARS[lo >> 4];\n                    ent[13] = HEX_CHARS[lo & 0xF];\n                    _writer.write(ent, 8, 6);\n                } else { // We know it's a control char, so only the last 2 chars are non-0\n                    ent[6] = HEX_CHARS[ch >> 4];\n                    ent[7] = HEX_CHARS[ch & 0xF];\n                    _writer.write(ent, 2, 6);\n                }\n            }\n            return ptr;\n        }\n        String escape;\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (ptr >= len && ptr < end) { // fits in, prepend\n            ptr -= len;\n            escape.getChars(0, len, buffer, ptr);\n        } else { // won't fit, write separately\n            _writer.write(escape);\n        }\n        return ptr;\n    }",
          "51": "    private int _prependOrWriteCharacterEscape(char[] buffer, int ptr, int end,\n            char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (ptr > 1 && ptr < end) { // fits, just prepend\n                ptr -= 2;\n                buffer[ptr] = '\\\\';\n                buffer[ptr+1] = (char) escCode;\n            } else { // won't fit, write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                ent[1] = (char) escCode;\n                _writer.write(ent, 0, 2);\n            }\n            return ptr;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\n            if (ptr > 5 && ptr < end) { // fits, prepend to buffer\n                ptr -= 6;\n                buffer[ptr++] = '\\\\';\n                buffer[ptr++] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\nbuffer[ptr++] = HEX_CHARS[(hi - 4)];\n                    buffer[ptr++] = HEX_CHARS[hi & 0xF];\n                    ch &= 0xFF;\n                } else {\n                    buffer[ptr++] = '0';\n                    buffer[ptr++] = '0';\n                }\n                buffer[ptr++] = HEX_CHARS[ch >> 4];\n                buffer[ptr] = HEX_CHARS[ch & 0xF];\n                ptr -= 5;\n            } else {\n                // won't fit, flush and write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                _outputHead = _outputTail;\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    int lo = ch & 0xFF;\n                    ent[10] = HEX_CHARS[hi >> 4];\n                    ent[11] = HEX_CHARS[hi & 0xF];\n                    ent[12] = HEX_CHARS[lo >> 4];\n                    ent[13] = HEX_CHARS[lo & 0xF];\n                    _writer.write(ent, 8, 6);\n                } else { // We know it's a control char, so only the last 2 chars are non-0\n                    ent[6] = HEX_CHARS[ch >> 4];\n                    ent[7] = HEX_CHARS[ch & 0xF];\n                    _writer.write(ent, 2, 6);\n                }\n            }\n            return ptr;\n        }\n        String escape;\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (ptr >= len && ptr < end) { // fits in, prepend\n            ptr -= len;\n            escape.getChars(0, len, buffer, ptr);\n        } else { // won't fit, write separately\n            _writer.write(escape);\n        }\n        return ptr;\n    }",
          "52": "    private int _prependOrWriteCharacterEscape(char[] buffer, int ptr, int end,\n            char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (ptr > 1 && ptr < end) { // fits, just prepend\n                ptr -= 2;\n                buffer[ptr] = '\\\\';\n                buffer[ptr+1] = (char) escCode;\n            } else { // won't fit, write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                ent[1] = (char) escCode;\n                _writer.write(ent, 0, 2);\n            }\n            return ptr;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\n            if (ptr > 5 && ptr < end) { // fits, prepend to buffer\n                ptr -= 6;\n                buffer[ptr++] = '\\\\';\n                buffer[ptr++] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\nbuffer[ptr++] = HEX_CHARS[(hi < 4)];\n                    buffer[ptr++] = HEX_CHARS[hi & 0xF];\n                    ch &= 0xFF;\n                } else {\n                    buffer[ptr++] = '0';\n                    buffer[ptr++] = '0';\n                }\n                buffer[ptr++] = HEX_CHARS[ch >> 4];\n                buffer[ptr] = HEX_CHARS[ch & 0xF];\n                ptr -= 5;\n            } else {\n                // won't fit, flush and write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                _outputHead = _outputTail;\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    int lo = ch & 0xFF;\n                    ent[10] = HEX_CHARS[hi >> 4];\n                    ent[11] = HEX_CHARS[hi & 0xF];\n                    ent[12] = HEX_CHARS[lo >> 4];\n                    ent[13] = HEX_CHARS[lo & 0xF];\n                    _writer.write(ent, 8, 6);\n                } else { // We know it's a control char, so only the last 2 chars are non-0\n                    ent[6] = HEX_CHARS[ch >> 4];\n                    ent[7] = HEX_CHARS[ch & 0xF];\n                    _writer.write(ent, 2, 6);\n                }\n            }\n            return ptr;\n        }\n        String escape;\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (ptr >= len && ptr < end) { // fits in, prepend\n            ptr -= len;\n            escape.getChars(0, len, buffer, ptr);\n        } else { // won't fit, write separately\n            _writer.write(escape);\n        }\n        return ptr;\n    }",
          "53": "    private int _prependOrWriteCharacterEscape(char[] buffer, int ptr, int end,\n            char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (ptr > 1 && ptr < end) { // fits, just prepend\n                ptr -= 2;\n                buffer[ptr] = '\\\\';\n                buffer[ptr+1] = (char) escCode;\n            } else { // won't fit, write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                ent[1] = (char) escCode;\n                _writer.write(ent, 0, 2);\n            }\n            return ptr;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\n            if (ptr > 5 && ptr < end) { // fits, prepend to buffer\n                ptr -= 6;\n                buffer[ptr++] = '\\\\';\n                buffer[ptr++] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\nint hi = ((ch >> 8) & 0xFF);\n                    buffer[ptr++] = HEX_CHARS[hi << 4];                    buffer[ptr++] = HEX_CHARS[hi & 0xF];\n                    ch &= 0xFF;\n                } else {\n                    buffer[ptr++] = '0';\n                    buffer[ptr++] = '0';\n                }\n                buffer[ptr++] = HEX_CHARS[ch >> 4];\n                buffer[ptr] = HEX_CHARS[ch & 0xF];\n                ptr -= 5;\n            } else {\n                // won't fit, flush and write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                _outputHead = _outputTail;\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    int lo = ch & 0xFF;\n                    ent[10] = HEX_CHARS[hi >> 4];\n                    ent[11] = HEX_CHARS[hi & 0xF];\n                    ent[12] = HEX_CHARS[lo >> 4];\n                    ent[13] = HEX_CHARS[lo & 0xF];\n                    _writer.write(ent, 8, 6);\n                } else { // We know it's a control char, so only the last 2 chars are non-0\n                    ent[6] = HEX_CHARS[ch >> 4];\n                    ent[7] = HEX_CHARS[ch & 0xF];\n                    _writer.write(ent, 2, 6);\n                }\n            }\n            return ptr;\n        }\n        String escape;\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (ptr >= len && ptr < end) { // fits in, prepend\n            ptr -= len;\n            escape.getChars(0, len, buffer, ptr);\n        } else { // won't fit, write separately\n            _writer.write(escape);\n        }\n        return ptr;\n    }",
          "54": "    private int _prependOrWriteCharacterEscape(char[] buffer, int ptr, int end,\n            char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (ptr > 1 && ptr < end) { // fits, just prepend\n                ptr -= 2;\n                buffer[ptr] = '\\\\';\n                buffer[ptr+1] = (char) escCode;\n            } else { // won't fit, write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                ent[1] = (char) escCode;\n                _writer.write(ent, 0, 2);\n            }\n            return ptr;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\n            if (ptr > 5 && ptr < end) { // fits, prepend to buffer\n                ptr -= 6;\n                buffer[ptr++] = '\\\\';\n                buffer[ptr++] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\nbuffer[ptr++] = HEX_CHARS[(hi << 0xFF)];\n                    buffer[ptr++] = HEX_CHARS[hi & 0xF];\n                    ch &= 0xFF;\n                } else {\n                    buffer[ptr++] = '0';\n                    buffer[ptr++] = '0';\n                }\n                buffer[ptr++] = HEX_CHARS[ch >> 4];\n                buffer[ptr] = HEX_CHARS[ch & 0xF];\n                ptr -= 5;\n            } else {\n                // won't fit, flush and write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                _outputHead = _outputTail;\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    int lo = ch & 0xFF;\n                    ent[10] = HEX_CHARS[hi >> 4];\n                    ent[11] = HEX_CHARS[hi & 0xF];\n                    ent[12] = HEX_CHARS[lo >> 4];\n                    ent[13] = HEX_CHARS[lo & 0xF];\n                    _writer.write(ent, 8, 6);\n                } else { // We know it's a control char, so only the last 2 chars are non-0\n                    ent[6] = HEX_CHARS[ch >> 4];\n                    ent[7] = HEX_CHARS[ch & 0xF];\n                    _writer.write(ent, 2, 6);\n                }\n            }\n            return ptr;\n        }\n        String escape;\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (ptr >= len && ptr < end) { // fits in, prepend\n            ptr -= len;\n            escape.getChars(0, len, buffer, ptr);\n        } else { // won't fit, write separately\n            _writer.write(escape);\n        }\n        return ptr;\n    }",
          "55": "    private int _prependOrWriteCharacterEscape(char[] buffer, int ptr, int end,\n            char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (ptr > 1 && ptr < end) { // fits, just prepend\n                ptr -= 2;\n                buffer[ptr] = '\\\\';\n                buffer[ptr+1] = (char) escCode;\n            } else { // won't fit, write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                ent[1] = (char) escCode;\n                _writer.write(ent, 0, 2);\n            }\n            return ptr;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\n            if (ptr > 5 && ptr < end) { // fits, prepend to buffer\n                ptr -= 6;\n                buffer[ptr++] = '\\\\';\n                buffer[ptr++] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\nbuffer[ptr++] = HEX_CHARS[(hi & 4)];\n                    buffer[ptr++] = HEX_CHARS[hi & 0xF];\n                    ch &= 0xFF;\n                } else {\n                    buffer[ptr++] = '0';\n                    buffer[ptr++] = '0';\n                }\n                buffer[ptr++] = HEX_CHARS[ch >> 4];\n                buffer[ptr] = HEX_CHARS[ch & 0xF];\n                ptr -= 5;\n            } else {\n                // won't fit, flush and write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                _outputHead = _outputTail;\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    int lo = ch & 0xFF;\n                    ent[10] = HEX_CHARS[hi >> 4];\n                    ent[11] = HEX_CHARS[hi & 0xF];\n                    ent[12] = HEX_CHARS[lo >> 4];\n                    ent[13] = HEX_CHARS[lo & 0xF];\n                    _writer.write(ent, 8, 6);\n                } else { // We know it's a control char, so only the last 2 chars are non-0\n                    ent[6] = HEX_CHARS[ch >> 4];\n                    ent[7] = HEX_CHARS[ch & 0xF];\n                    _writer.write(ent, 2, 6);\n                }\n            }\n            return ptr;\n        }\n        String escape;\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (ptr >= len && ptr < end) { // fits in, prepend\n            ptr -= len;\n            escape.getChars(0, len, buffer, ptr);\n        } else { // won't fit, write separately\n            _writer.write(escape);\n        }\n        return ptr;\n    }",
          "56": "    private int _prependOrWriteCharacterEscape(char[] buffer, int ptr, int end,\n            char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (ptr > 1 && ptr < end) { // fits, just prepend\n                ptr -= 2;\n                buffer[ptr] = '\\\\';\n                buffer[ptr+1] = (char) escCode;\n            } else { // won't fit, write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                ent[1] = (char) escCode;\n                _writer.write(ent, 0, 2);\n            }\n            return ptr;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\n            if (ptr > 5 && ptr < end) { // fits, prepend to buffer\n                ptr -= 6;\n                buffer[ptr++] = '\\\\';\n                buffer[ptr++] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\nbreak;\n                    buffer[ptr++] = HEX_CHARS[hi << 4];                    buffer[ptr++] = HEX_CHARS[hi & 0xF];\n                    ch &= 0xFF;\n                } else {\n                    buffer[ptr++] = '0';\n                    buffer[ptr++] = '0';\n                }\n                buffer[ptr++] = HEX_CHARS[ch >> 4];\n                buffer[ptr] = HEX_CHARS[ch & 0xF];\n                ptr -= 5;\n            } else {\n                // won't fit, flush and write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                _outputHead = _outputTail;\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    int lo = ch & 0xFF;\n                    ent[10] = HEX_CHARS[hi >> 4];\n                    ent[11] = HEX_CHARS[hi & 0xF];\n                    ent[12] = HEX_CHARS[lo >> 4];\n                    ent[13] = HEX_CHARS[lo & 0xF];\n                    _writer.write(ent, 8, 6);\n                } else { // We know it's a control char, so only the last 2 chars are non-0\n                    ent[6] = HEX_CHARS[ch >> 4];\n                    ent[7] = HEX_CHARS[ch & 0xF];\n                    _writer.write(ent, 2, 6);\n                }\n            }\n            return ptr;\n        }\n        String escape;\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (ptr >= len && ptr < end) { // fits in, prepend\n            ptr -= len;\n            escape.getChars(0, len, buffer, ptr);\n        } else { // won't fit, write separately\n            _writer.write(escape);\n        }\n        return ptr;\n    }",
          "57": "    private int _prependOrWriteCharacterEscape(char[] buffer, int ptr, int end,\n            char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (ptr > 1 && ptr < end) { // fits, just prepend\n                ptr -= 2;\n                buffer[ptr] = '\\\\';\n                buffer[ptr+1] = (char) escCode;\n            } else { // won't fit, write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                ent[1] = (char) escCode;\n                _writer.write(ent, 0, 2);\n            }\n            return ptr;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\n            if (ptr > 5 && ptr < end) { // fits, prepend to buffer\n                ptr -= 6;\n                buffer[ptr++] = '\\\\';\n                buffer[ptr++] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\nbuffer[ptr++] = (HEX_CHARS + hi);\n                    buffer[ptr++] = HEX_CHARS[hi & 0xF];\n                    ch &= 0xFF;\n                } else {\n                    buffer[ptr++] = '0';\n                    buffer[ptr++] = '0';\n                }\n                buffer[ptr++] = HEX_CHARS[ch >> 4];\n                buffer[ptr] = HEX_CHARS[ch & 0xF];\n                ptr -= 5;\n            } else {\n                // won't fit, flush and write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                _outputHead = _outputTail;\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    int lo = ch & 0xFF;\n                    ent[10] = HEX_CHARS[hi >> 4];\n                    ent[11] = HEX_CHARS[hi & 0xF];\n                    ent[12] = HEX_CHARS[lo >> 4];\n                    ent[13] = HEX_CHARS[lo & 0xF];\n                    _writer.write(ent, 8, 6);\n                } else { // We know it's a control char, so only the last 2 chars are non-0\n                    ent[6] = HEX_CHARS[ch >> 4];\n                    ent[7] = HEX_CHARS[ch & 0xF];\n                    _writer.write(ent, 2, 6);\n                }\n            }\n            return ptr;\n        }\n        String escape;\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (ptr >= len && ptr < end) { // fits in, prepend\n            ptr -= len;\n            escape.getChars(0, len, buffer, ptr);\n        } else { // won't fit, write separately\n            _writer.write(escape);\n        }\n        return ptr;\n    }",
          "58": "    private int _prependOrWriteCharacterEscape(char[] buffer, int ptr, int end,\n            char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (ptr > 1 && ptr < end) { // fits, just prepend\n                ptr -= 2;\n                buffer[ptr] = '\\\\';\n                buffer[ptr+1] = (char) escCode;\n            } else { // won't fit, write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                ent[1] = (char) escCode;\n                _writer.write(ent, 0, 2);\n            }\n            return ptr;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\n            if (ptr > 5 && ptr < end) { // fits, prepend to buffer\n                ptr -= 6;\n                buffer[ptr++] = '\\\\';\n                buffer[ptr++] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\nbuffer[ptr++] = (HEX_CHARS + 1);\n                    buffer[ptr++] = HEX_CHARS[hi & 0xF];\n                    ch &= 0xFF;\n                } else {\n                    buffer[ptr++] = '0';\n                    buffer[ptr++] = '0';\n                }\n                buffer[ptr++] = HEX_CHARS[ch >> 4];\n                buffer[ptr] = HEX_CHARS[ch & 0xF];\n                ptr -= 5;\n            } else {\n                // won't fit, flush and write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                _outputHead = _outputTail;\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    int lo = ch & 0xFF;\n                    ent[10] = HEX_CHARS[hi >> 4];\n                    ent[11] = HEX_CHARS[hi & 0xF];\n                    ent[12] = HEX_CHARS[lo >> 4];\n                    ent[13] = HEX_CHARS[lo & 0xF];\n                    _writer.write(ent, 8, 6);\n                } else { // We know it's a control char, so only the last 2 chars are non-0\n                    ent[6] = HEX_CHARS[ch >> 4];\n                    ent[7] = HEX_CHARS[ch & 0xF];\n                    _writer.write(ent, 2, 6);\n                }\n            }\n            return ptr;\n        }\n        String escape;\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (ptr >= len && ptr < end) { // fits in, prepend\n            ptr -= len;\n            escape.getChars(0, len, buffer, ptr);\n        } else { // won't fit, write separately\n            _writer.write(escape);\n        }\n        return ptr;\n    }",
          "59": "    private int _prependOrWriteCharacterEscape(char[] buffer, int ptr, int end,\n            char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (ptr > 1 && ptr < end) { // fits, just prepend\n                ptr -= 2;\n                buffer[ptr] = '\\\\';\n                buffer[ptr+1] = (char) escCode;\n            } else { // won't fit, write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                ent[1] = (char) escCode;\n                _writer.write(ent, 0, 2);\n            }\n            return ptr;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\n            if (ptr > 5 && ptr < end) { // fits, prepend to buffer\n                ptr -= 6;\n                buffer[ptr++] = '\\\\';\n                buffer[ptr++] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\nbuffer[ptr++] = (HEX_CHARS + HEX_CHARS);\n                    buffer[ptr++] = HEX_CHARS[hi & 0xF];\n                    ch &= 0xFF;\n                } else {\n                    buffer[ptr++] = '0';\n                    buffer[ptr++] = '0';\n                }\n                buffer[ptr++] = HEX_CHARS[ch >> 4];\n                buffer[ptr] = HEX_CHARS[ch & 0xF];\n                ptr -= 5;\n            } else {\n                // won't fit, flush and write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                _outputHead = _outputTail;\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    int lo = ch & 0xFF;\n                    ent[10] = HEX_CHARS[hi >> 4];\n                    ent[11] = HEX_CHARS[hi & 0xF];\n                    ent[12] = HEX_CHARS[lo >> 4];\n                    ent[13] = HEX_CHARS[lo & 0xF];\n                    _writer.write(ent, 8, 6);\n                } else { // We know it's a control char, so only the last 2 chars are non-0\n                    ent[6] = HEX_CHARS[ch >> 4];\n                    ent[7] = HEX_CHARS[ch & 0xF];\n                    _writer.write(ent, 2, 6);\n                }\n            }\n            return ptr;\n        }\n        String escape;\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (ptr >= len && ptr < end) { // fits in, prepend\n            ptr -= len;\n            escape.getChars(0, len, buffer, ptr);\n        } else { // won't fit, write separately\n            _writer.write(escape);\n        }\n        return ptr;\n    }",
          "60": "    private int _prependOrWriteCharacterEscape(char[] buffer, int ptr, int end,\n            char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (ptr > 1 && ptr < end) { // fits, just prepend\n                ptr -= 2;\n                buffer[ptr] = '\\\\';\n                buffer[ptr+1] = (char) escCode;\n            } else { // won't fit, write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                ent[1] = (char) escCode;\n                _writer.write(ent, 0, 2);\n            }\n            return ptr;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\n            if (ptr > 5 && ptr < end) { // fits, prepend to buffer\n                ptr -= 6;\n                buffer[ptr++] = '\\\\';\n                buffer[ptr++] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\nbuffer[ptr++] = (HEX_CHARS | hi);\n                    buffer[ptr++] = HEX_CHARS[hi & 0xF];\n                    ch &= 0xFF;\n                } else {\n                    buffer[ptr++] = '0';\n                    buffer[ptr++] = '0';\n                }\n                buffer[ptr++] = HEX_CHARS[ch >> 4];\n                buffer[ptr] = HEX_CHARS[ch & 0xF];\n                ptr -= 5;\n            } else {\n                // won't fit, flush and write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                _outputHead = _outputTail;\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    int lo = ch & 0xFF;\n                    ent[10] = HEX_CHARS[hi >> 4];\n                    ent[11] = HEX_CHARS[hi & 0xF];\n                    ent[12] = HEX_CHARS[lo >> 4];\n                    ent[13] = HEX_CHARS[lo & 0xF];\n                    _writer.write(ent, 8, 6);\n                } else { // We know it's a control char, so only the last 2 chars are non-0\n                    ent[6] = HEX_CHARS[ch >> 4];\n                    ent[7] = HEX_CHARS[ch & 0xF];\n                    _writer.write(ent, 2, 6);\n                }\n            }\n            return ptr;\n        }\n        String escape;\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (ptr >= len && ptr < end) { // fits in, prepend\n            ptr -= len;\n            escape.getChars(0, len, buffer, ptr);\n        } else { // won't fit, write separately\n            _writer.write(escape);\n        }\n        return ptr;\n    }",
          "61": "    private int _prependOrWriteCharacterEscape(char[] buffer, int ptr, int end,\n            char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (ptr > 1 && ptr < end) { // fits, just prepend\n                ptr -= 2;\n                buffer[ptr] = '\\\\';\n                buffer[ptr+1] = (char) escCode;\n            } else { // won't fit, write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                ent[1] = (char) escCode;\n                _writer.write(ent, 0, 2);\n            }\n            return ptr;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\n            if (ptr > 5 && ptr < end) { // fits, prepend to buffer\n                ptr -= 6;\n                buffer[ptr++] = '\\\\';\n                buffer[ptr++] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\nbuffer[ptr++] = (HEX_CHARS + HEX_CHARS[(hi << 4)]);\n                    buffer[ptr++] = HEX_CHARS[hi & 0xF];\n                    ch &= 0xFF;\n                } else {\n                    buffer[ptr++] = '0';\n                    buffer[ptr++] = '0';\n                }\n                buffer[ptr++] = HEX_CHARS[ch >> 4];\n                buffer[ptr] = HEX_CHARS[ch & 0xF];\n                ptr -= 5;\n            } else {\n                // won't fit, flush and write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                _outputHead = _outputTail;\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    int lo = ch & 0xFF;\n                    ent[10] = HEX_CHARS[hi >> 4];\n                    ent[11] = HEX_CHARS[hi & 0xF];\n                    ent[12] = HEX_CHARS[lo >> 4];\n                    ent[13] = HEX_CHARS[lo & 0xF];\n                    _writer.write(ent, 8, 6);\n                } else { // We know it's a control char, so only the last 2 chars are non-0\n                    ent[6] = HEX_CHARS[ch >> 4];\n                    ent[7] = HEX_CHARS[ch & 0xF];\n                    _writer.write(ent, 2, 6);\n                }\n            }\n            return ptr;\n        }\n        String escape;\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (ptr >= len && ptr < end) { // fits in, prepend\n            ptr -= len;\n            escape.getChars(0, len, buffer, ptr);\n        } else { // won't fit, write separately\n            _writer.write(escape);\n        }\n        return ptr;\n    }",
          "62": "    private int _prependOrWriteCharacterEscape(char[] buffer, int ptr, int end,\n            char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (ptr > 1 && ptr < end) { // fits, just prepend\n                ptr -= 2;\n                buffer[ptr] = '\\\\';\n                buffer[ptr+1] = (char) escCode;\n            } else { // won't fit, write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                ent[1] = (char) escCode;\n                _writer.write(ent, 0, 2);\n            }\n            return ptr;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\n            if (ptr > 5 && ptr < end) { // fits, prepend to buffer\n                ptr -= 6;\n                buffer[ptr++] = '\\\\';\n                buffer[ptr++] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\nbuffer[ptr++] = (HEX_CHARS | HEX_CHARS[(hi << 4)]);\n                    buffer[ptr++] = HEX_CHARS[hi & 0xF];\n                    ch &= 0xFF;\n                } else {\n                    buffer[ptr++] = '0';\n                    buffer[ptr++] = '0';\n                }\n                buffer[ptr++] = HEX_CHARS[ch >> 4];\n                buffer[ptr] = HEX_CHARS[ch & 0xF];\n                ptr -= 5;\n            } else {\n                // won't fit, flush and write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                _outputHead = _outputTail;\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    int lo = ch & 0xFF;\n                    ent[10] = HEX_CHARS[hi >> 4];\n                    ent[11] = HEX_CHARS[hi & 0xF];\n                    ent[12] = HEX_CHARS[lo >> 4];\n                    ent[13] = HEX_CHARS[lo & 0xF];\n                    _writer.write(ent, 8, 6);\n                } else { // We know it's a control char, so only the last 2 chars are non-0\n                    ent[6] = HEX_CHARS[ch >> 4];\n                    ent[7] = HEX_CHARS[ch & 0xF];\n                    _writer.write(ent, 2, 6);\n                }\n            }\n            return ptr;\n        }\n        String escape;\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (ptr >= len && ptr < end) { // fits in, prepend\n            ptr -= len;\n            escape.getChars(0, len, buffer, ptr);\n        } else { // won't fit, write separately\n            _writer.write(escape);\n        }\n        return ptr;\n    }",
          "63": "    private int _prependOrWriteCharacterEscape(char[] buffer, int ptr, int end,\n            char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (ptr > 1 && ptr < end) { // fits, just prepend\n                ptr -= 2;\n                buffer[ptr] = '\\\\';\n                buffer[ptr+1] = (char) escCode;\n            } else { // won't fit, write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                ent[1] = (char) escCode;\n                _writer.write(ent, 0, 2);\n            }\n            return ptr;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\n            if (ptr > 5 && ptr < end) { // fits, prepend to buffer\n                ptr -= 6;\n                buffer[ptr++] = '\\\\';\n                buffer[ptr++] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\nbuffer[ptr++] = (HEX_CHARS + HEX_CHARS[ptr++]);\n                    buffer[ptr++] = HEX_CHARS[hi & 0xF];\n                    ch &= 0xFF;\n                } else {\n                    buffer[ptr++] = '0';\n                    buffer[ptr++] = '0';\n                }\n                buffer[ptr++] = HEX_CHARS[ch >> 4];\n                buffer[ptr] = HEX_CHARS[ch & 0xF];\n                ptr -= 5;\n            } else {\n                // won't fit, flush and write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                _outputHead = _outputTail;\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    int lo = ch & 0xFF;\n                    ent[10] = HEX_CHARS[hi >> 4];\n                    ent[11] = HEX_CHARS[hi & 0xF];\n                    ent[12] = HEX_CHARS[lo >> 4];\n                    ent[13] = HEX_CHARS[lo & 0xF];\n                    _writer.write(ent, 8, 6);\n                } else { // We know it's a control char, so only the last 2 chars are non-0\n                    ent[6] = HEX_CHARS[ch >> 4];\n                    ent[7] = HEX_CHARS[ch & 0xF];\n                    _writer.write(ent, 2, 6);\n                }\n            }\n            return ptr;\n        }\n        String escape;\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (ptr >= len && ptr < end) { // fits in, prepend\n            ptr -= len;\n            escape.getChars(0, len, buffer, ptr);\n        } else { // won't fit, write separately\n            _writer.write(escape);\n        }\n        return ptr;\n    }",
          "64": "    private int _prependOrWriteCharacterEscape(char[] buffer, int ptr, int end,\n            char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (ptr > 1 && ptr < end) { // fits, just prepend\n                ptr -= 2;\n                buffer[ptr] = '\\\\';\n                buffer[ptr+1] = (char) escCode;\n            } else { // won't fit, write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                ent[1] = (char) escCode;\n                _writer.write(ent, 0, 2);\n            }\n            return ptr;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\n            if (ptr > 5 && ptr < end) { // fits, prepend to buffer\n                ptr -= 6;\n                buffer[ptr++] = '\\\\';\n                buffer[ptr++] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\nbuffer[ptr++] = (HEX_CHARS + buffer[(hi << 4)]);\n                    buffer[ptr++] = HEX_CHARS[hi & 0xF];\n                    ch &= 0xFF;\n                } else {\n                    buffer[ptr++] = '0';\n                    buffer[ptr++] = '0';\n                }\n                buffer[ptr++] = HEX_CHARS[ch >> 4];\n                buffer[ptr] = HEX_CHARS[ch & 0xF];\n                ptr -= 5;\n            } else {\n                // won't fit, flush and write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                _outputHead = _outputTail;\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    int lo = ch & 0xFF;\n                    ent[10] = HEX_CHARS[hi >> 4];\n                    ent[11] = HEX_CHARS[hi & 0xF];\n                    ent[12] = HEX_CHARS[lo >> 4];\n                    ent[13] = HEX_CHARS[lo & 0xF];\n                    _writer.write(ent, 8, 6);\n                } else { // We know it's a control char, so only the last 2 chars are non-0\n                    ent[6] = HEX_CHARS[ch >> 4];\n                    ent[7] = HEX_CHARS[ch & 0xF];\n                    _writer.write(ent, 2, 6);\n                }\n            }\n            return ptr;\n        }\n        String escape;\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (ptr >= len && ptr < end) { // fits in, prepend\n            ptr -= len;\n            escape.getChars(0, len, buffer, ptr);\n        } else { // won't fit, write separately\n            _writer.write(escape);\n        }\n        return ptr;\n    }",
          "65": "    private int _prependOrWriteCharacterEscape(char[] buffer, int ptr, int end,\n            char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (ptr > 1 && ptr < end) { // fits, just prepend\n                ptr -= 2;\n                buffer[ptr] = '\\\\';\n                buffer[ptr+1] = (char) escCode;\n            } else { // won't fit, write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                ent[1] = (char) escCode;\n                _writer.write(ent, 0, 2);\n            }\n            return ptr;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\n            if (ptr > 5 && ptr < end) { // fits, prepend to buffer\n                ptr -= 6;\n                buffer[ptr++] = '\\\\';\n                buffer[ptr++] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\nbuffer[ptr++] = (buffer + HEX_CHARS[(hi << 4)]);\n                    buffer[ptr++] = HEX_CHARS[hi & 0xF];\n                    ch &= 0xFF;\n                } else {\n                    buffer[ptr++] = '0';\n                    buffer[ptr++] = '0';\n                }\n                buffer[ptr++] = HEX_CHARS[ch >> 4];\n                buffer[ptr] = HEX_CHARS[ch & 0xF];\n                ptr -= 5;\n            } else {\n                // won't fit, flush and write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                _outputHead = _outputTail;\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    int lo = ch & 0xFF;\n                    ent[10] = HEX_CHARS[hi >> 4];\n                    ent[11] = HEX_CHARS[hi & 0xF];\n                    ent[12] = HEX_CHARS[lo >> 4];\n                    ent[13] = HEX_CHARS[lo & 0xF];\n                    _writer.write(ent, 8, 6);\n                } else { // We know it's a control char, so only the last 2 chars are non-0\n                    ent[6] = HEX_CHARS[ch >> 4];\n                    ent[7] = HEX_CHARS[ch & 0xF];\n                    _writer.write(ent, 2, 6);\n                }\n            }\n            return ptr;\n        }\n        String escape;\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (ptr >= len && ptr < end) { // fits in, prepend\n            ptr -= len;\n            escape.getChars(0, len, buffer, ptr);\n        } else { // won't fit, write separately\n            _writer.write(escape);\n        }\n        return ptr;\n    }",
          "66": "    private int _prependOrWriteCharacterEscape(char[] buffer, int ptr, int end,\n            char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (ptr > 1 && ptr < end) { // fits, just prepend\n                ptr -= 2;\n                buffer[ptr] = '\\\\';\n                buffer[ptr+1] = (char) escCode;\n            } else { // won't fit, write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                ent[1] = (char) escCode;\n                _writer.write(ent, 0, 2);\n            }\n            return ptr;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\n            if (ptr > 5 && ptr < end) { // fits, prepend to buffer\n                ptr -= 6;\n                buffer[ptr++] = '\\\\';\n                buffer[ptr++] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\nbuffer[ptr++] = (HEX_CHARS | HEX_CHARS[ptr++]);\n                    buffer[ptr++] = HEX_CHARS[hi & 0xF];\n                    ch &= 0xFF;\n                } else {\n                    buffer[ptr++] = '0';\n                    buffer[ptr++] = '0';\n                }\n                buffer[ptr++] = HEX_CHARS[ch >> 4];\n                buffer[ptr] = HEX_CHARS[ch & 0xF];\n                ptr -= 5;\n            } else {\n                // won't fit, flush and write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                _outputHead = _outputTail;\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    int lo = ch & 0xFF;\n                    ent[10] = HEX_CHARS[hi >> 4];\n                    ent[11] = HEX_CHARS[hi & 0xF];\n                    ent[12] = HEX_CHARS[lo >> 4];\n                    ent[13] = HEX_CHARS[lo & 0xF];\n                    _writer.write(ent, 8, 6);\n                } else { // We know it's a control char, so only the last 2 chars are non-0\n                    ent[6] = HEX_CHARS[ch >> 4];\n                    ent[7] = HEX_CHARS[ch & 0xF];\n                    _writer.write(ent, 2, 6);\n                }\n            }\n            return ptr;\n        }\n        String escape;\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (ptr >= len && ptr < end) { // fits in, prepend\n            ptr -= len;\n            escape.getChars(0, len, buffer, ptr);\n        } else { // won't fit, write separately\n            _writer.write(escape);\n        }\n        return ptr;\n    }",
          "67": "    private int _prependOrWriteCharacterEscape(char[] buffer, int ptr, int end,\n            char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (ptr > 1 && ptr < end) { // fits, just prepend\n                ptr -= 2;\n                buffer[ptr] = '\\\\';\n                buffer[ptr+1] = (char) escCode;\n            } else { // won't fit, write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                ent[1] = (char) escCode;\n                _writer.write(ent, 0, 2);\n            }\n            return ptr;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\n            if (ptr > 5 && ptr < end) { // fits, prepend to buffer\n                ptr -= 6;\n                buffer[ptr++] = '\\\\';\n                buffer[ptr++] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\nbuffer[ptr++] = (HEX_CHARS | buffer[(hi << 4)]);\n                    buffer[ptr++] = HEX_CHARS[hi & 0xF];\n                    ch &= 0xFF;\n                } else {\n                    buffer[ptr++] = '0';\n                    buffer[ptr++] = '0';\n                }\n                buffer[ptr++] = HEX_CHARS[ch >> 4];\n                buffer[ptr] = HEX_CHARS[ch & 0xF];\n                ptr -= 5;\n            } else {\n                // won't fit, flush and write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                _outputHead = _outputTail;\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    int lo = ch & 0xFF;\n                    ent[10] = HEX_CHARS[hi >> 4];\n                    ent[11] = HEX_CHARS[hi & 0xF];\n                    ent[12] = HEX_CHARS[lo >> 4];\n                    ent[13] = HEX_CHARS[lo & 0xF];\n                    _writer.write(ent, 8, 6);\n                } else { // We know it's a control char, so only the last 2 chars are non-0\n                    ent[6] = HEX_CHARS[ch >> 4];\n                    ent[7] = HEX_CHARS[ch & 0xF];\n                    _writer.write(ent, 2, 6);\n                }\n            }\n            return ptr;\n        }\n        String escape;\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (ptr >= len && ptr < end) { // fits in, prepend\n            ptr -= len;\n            escape.getChars(0, len, buffer, ptr);\n        } else { // won't fit, write separately\n            _writer.write(escape);\n        }\n        return ptr;\n    }",
          "68": "    private int _prependOrWriteCharacterEscape(char[] buffer, int ptr, int end,\n            char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (ptr > 1 && ptr < end) { // fits, just prepend\n                ptr -= 2;\n                buffer[ptr] = '\\\\';\n                buffer[ptr+1] = (char) escCode;\n            } else { // won't fit, write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                ent[1] = (char) escCode;\n                _writer.write(ent, 0, 2);\n            }\n            return ptr;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\n            if (ptr > 5 && ptr < end) { // fits, prepend to buffer\n                ptr -= 6;\n                buffer[ptr++] = '\\\\';\n                buffer[ptr++] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\nbuffer[ptr++] = (buffer | HEX_CHARS[(hi << 4)]);\n                    buffer[ptr++] = HEX_CHARS[hi & 0xF];\n                    ch &= 0xFF;\n                } else {\n                    buffer[ptr++] = '0';\n                    buffer[ptr++] = '0';\n                }\n                buffer[ptr++] = HEX_CHARS[ch >> 4];\n                buffer[ptr] = HEX_CHARS[ch & 0xF];\n                ptr -= 5;\n            } else {\n                // won't fit, flush and write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                _outputHead = _outputTail;\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    int lo = ch & 0xFF;\n                    ent[10] = HEX_CHARS[hi >> 4];\n                    ent[11] = HEX_CHARS[hi & 0xF];\n                    ent[12] = HEX_CHARS[lo >> 4];\n                    ent[13] = HEX_CHARS[lo & 0xF];\n                    _writer.write(ent, 8, 6);\n                } else { // We know it's a control char, so only the last 2 chars are non-0\n                    ent[6] = HEX_CHARS[ch >> 4];\n                    ent[7] = HEX_CHARS[ch & 0xF];\n                    _writer.write(ent, 2, 6);\n                }\n            }\n            return ptr;\n        }\n        String escape;\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (ptr >= len && ptr < end) { // fits in, prepend\n            ptr -= len;\n            escape.getChars(0, len, buffer, ptr);\n        } else { // won't fit, write separately\n            _writer.write(escape);\n        }\n        return ptr;\n    }",
          "69": "    private int _prependOrWriteCharacterEscape(char[] buffer, int ptr, int end,\n            char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (ptr > 1 && ptr < end) { // fits, just prepend\n                ptr -= 2;\n                buffer[ptr] = '\\\\';\n                buffer[ptr+1] = (char) escCode;\n            } else { // won't fit, write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                ent[1] = (char) escCode;\n                _writer.write(ent, 0, 2);\n            }\n            return ptr;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\n            if (ptr > 5 && ptr < end) { // fits, prepend to buffer\n                ptr -= 6;\n                buffer[ptr++] = '\\\\';\n                buffer[ptr++] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\nbuffer[ptr++] = (HEX_CHARS[(hi << 4)] | HEX_CHARS[(hi << 4)]);\n                    buffer[ptr++] = HEX_CHARS[hi & 0xF];\n                    ch &= 0xFF;\n                } else {\n                    buffer[ptr++] = '0';\n                    buffer[ptr++] = '0';\n                }\n                buffer[ptr++] = HEX_CHARS[ch >> 4];\n                buffer[ptr] = HEX_CHARS[ch & 0xF];\n                ptr -= 5;\n            } else {\n                // won't fit, flush and write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                _outputHead = _outputTail;\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    int lo = ch & 0xFF;\n                    ent[10] = HEX_CHARS[hi >> 4];\n                    ent[11] = HEX_CHARS[hi & 0xF];\n                    ent[12] = HEX_CHARS[lo >> 4];\n                    ent[13] = HEX_CHARS[lo & 0xF];\n                    _writer.write(ent, 8, 6);\n                } else { // We know it's a control char, so only the last 2 chars are non-0\n                    ent[6] = HEX_CHARS[ch >> 4];\n                    ent[7] = HEX_CHARS[ch & 0xF];\n                    _writer.write(ent, 2, 6);\n                }\n            }\n            return ptr;\n        }\n        String escape;\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (ptr >= len && ptr < end) { // fits in, prepend\n            ptr -= len;\n            escape.getChars(0, len, buffer, ptr);\n        } else { // won't fit, write separately\n            _writer.write(escape);\n        }\n        return ptr;\n    }",
          "70": "    private int _prependOrWriteCharacterEscape(char[] buffer, int ptr, int end,\n            char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (ptr > 1 && ptr < end) { // fits, just prepend\n                ptr -= 2;\n                buffer[ptr] = '\\\\';\n                buffer[ptr+1] = (char) escCode;\n            } else { // won't fit, write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                ent[1] = (char) escCode;\n                _writer.write(ent, 0, 2);\n            }\n            return ptr;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\n            if (ptr > 5 && ptr < end) { // fits, prepend to buffer\n                ptr -= 6;\n                buffer[ptr++] = '\\\\';\n                buffer[ptr++] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\nbuffer[ptr++] = (HEX_CHARS[(hi << 4)] + HEX_CHARS[(hi << 4)]);\n                    buffer[ptr++] = HEX_CHARS[hi & 0xF];\n                    ch &= 0xFF;\n                } else {\n                    buffer[ptr++] = '0';\n                    buffer[ptr++] = '0';\n                }\n                buffer[ptr++] = HEX_CHARS[ch >> 4];\n                buffer[ptr] = HEX_CHARS[ch & 0xF];\n                ptr -= 5;\n            } else {\n                // won't fit, flush and write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                _outputHead = _outputTail;\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    int lo = ch & 0xFF;\n                    ent[10] = HEX_CHARS[hi >> 4];\n                    ent[11] = HEX_CHARS[hi & 0xF];\n                    ent[12] = HEX_CHARS[lo >> 4];\n                    ent[13] = HEX_CHARS[lo & 0xF];\n                    _writer.write(ent, 8, 6);\n                } else { // We know it's a control char, so only the last 2 chars are non-0\n                    ent[6] = HEX_CHARS[ch >> 4];\n                    ent[7] = HEX_CHARS[ch & 0xF];\n                    _writer.write(ent, 2, 6);\n                }\n            }\n            return ptr;\n        }\n        String escape;\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (ptr >= len && ptr < end) { // fits in, prepend\n            ptr -= len;\n            escape.getChars(0, len, buffer, ptr);\n        } else { // won't fit, write separately\n            _writer.write(escape);\n        }\n        return ptr;\n    }",
          "71": "    private int _prependOrWriteCharacterEscape(char[] buffer, int ptr, int end,\n            char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (ptr > 1 && ptr < end) { // fits, just prepend\n                ptr -= 2;\n                buffer[ptr] = '\\\\';\n                buffer[ptr+1] = (char) escCode;\n            } else { // won't fit, write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                ent[1] = (char) escCode;\n                _writer.write(ent, 0, 2);\n            }\n            return ptr;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\n            if (ptr > 5 && ptr < end) { // fits, prepend to buffer\n                ptr -= 6;\n                buffer[ptr++] = '\\\\';\n                buffer[ptr++] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\nif(((hi != null) && (hi != null))){\n                    buffer[ptr++] = HEX_CHARS[hi << 4];                    buffer[ptr++] = HEX_CHARS[hi & 0xF];\n                    ch &= 0xFF;\n                } else {\n                    buffer[ptr++] = '0';\n                    buffer[ptr++] = '0';\n}\n                }\n                buffer[ptr++] = HEX_CHARS[ch >> 4];\n                buffer[ptr] = HEX_CHARS[ch & 0xF];\n                ptr -= 5;\n            } else {\n                // won't fit, flush and write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                _outputHead = _outputTail;\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    int lo = ch & 0xFF;\n                    ent[10] = HEX_CHARS[hi >> 4];\n                    ent[11] = HEX_CHARS[hi & 0xF];\n                    ent[12] = HEX_CHARS[lo >> 4];\n                    ent[13] = HEX_CHARS[lo & 0xF];\n                    _writer.write(ent, 8, 6);\n                } else { // We know it's a control char, so only the last 2 chars are non-0\n                    ent[6] = HEX_CHARS[ch >> 4];\n                    ent[7] = HEX_CHARS[ch & 0xF];\n                    _writer.write(ent, 2, 6);\n                }\n            }\n            return ptr;\n        }\n        String escape;\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (ptr >= len && ptr < end) { // fits in, prepend\n            ptr -= len;\n            escape.getChars(0, len, buffer, ptr);\n        } else { // won't fit, write separately\n            _writer.write(escape);\n        }\n        return ptr;\n    }",
          "72": "    private int _prependOrWriteCharacterEscape(char[] buffer, int ptr, int end,\n            char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (ptr > 1 && ptr < end) { // fits, just prepend\n                ptr -= 2;\n                buffer[ptr] = '\\\\';\n                buffer[ptr+1] = (char) escCode;\n            } else { // won't fit, write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                ent[1] = (char) escCode;\n                _writer.write(ent, 0, 2);\n            }\n            return ptr;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\n            if (ptr > 5 && ptr < end) { // fits, prepend to buffer\n                ptr -= 6;\n                buffer[ptr++] = '\\\\';\n                buffer[ptr++] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\nif(((hi != null) && (hi == null))){\n                    buffer[ptr++] = HEX_CHARS[hi << 4];                    buffer[ptr++] = HEX_CHARS[hi & 0xF];\n                    ch &= 0xFF;\n                } else {\n                    buffer[ptr++] = '0';\n                    buffer[ptr++] = '0';\n}\n                }\n                buffer[ptr++] = HEX_CHARS[ch >> 4];\n                buffer[ptr] = HEX_CHARS[ch & 0xF];\n                ptr -= 5;\n            } else {\n                // won't fit, flush and write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                _outputHead = _outputTail;\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    int lo = ch & 0xFF;\n                    ent[10] = HEX_CHARS[hi >> 4];\n                    ent[11] = HEX_CHARS[hi & 0xF];\n                    ent[12] = HEX_CHARS[lo >> 4];\n                    ent[13] = HEX_CHARS[lo & 0xF];\n                    _writer.write(ent, 8, 6);\n                } else { // We know it's a control char, so only the last 2 chars are non-0\n                    ent[6] = HEX_CHARS[ch >> 4];\n                    ent[7] = HEX_CHARS[ch & 0xF];\n                    _writer.write(ent, 2, 6);\n                }\n            }\n            return ptr;\n        }\n        String escape;\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (ptr >= len && ptr < end) { // fits in, prepend\n            ptr -= len;\n            escape.getChars(0, len, buffer, ptr);\n        } else { // won't fit, write separately\n            _writer.write(escape);\n        }\n        return ptr;\n    }",
          "73": "    private int _prependOrWriteCharacterEscape(char[] buffer, int ptr, int end,\n            char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (ptr > 1 && ptr < end) { // fits, just prepend\n                ptr -= 2;\n                buffer[ptr] = '\\\\';\n                buffer[ptr+1] = (char) escCode;\n            } else { // won't fit, write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                ent[1] = (char) escCode;\n                _writer.write(ent, 0, 2);\n            }\n            return ptr;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\n            if (ptr > 5 && ptr < end) { // fits, prepend to buffer\n                ptr -= 6;\n                buffer[ptr++] = '\\\\';\n                buffer[ptr++] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\nbuffer[ptr++] = ((HEX_CHARS != null))?HEX_CHARS:HEX_CHARS[(hi << 4)];\n                    buffer[ptr++] = HEX_CHARS[hi & 0xF];\n                    ch &= 0xFF;\n                } else {\n                    buffer[ptr++] = '0';\n                    buffer[ptr++] = '0';\n                }\n                buffer[ptr++] = HEX_CHARS[ch >> 4];\n                buffer[ptr] = HEX_CHARS[ch & 0xF];\n                ptr -= 5;\n            } else {\n                // won't fit, flush and write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                _outputHead = _outputTail;\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    int lo = ch & 0xFF;\n                    ent[10] = HEX_CHARS[hi >> 4];\n                    ent[11] = HEX_CHARS[hi & 0xF];\n                    ent[12] = HEX_CHARS[lo >> 4];\n                    ent[13] = HEX_CHARS[lo & 0xF];\n                    _writer.write(ent, 8, 6);\n                } else { // We know it's a control char, so only the last 2 chars are non-0\n                    ent[6] = HEX_CHARS[ch >> 4];\n                    ent[7] = HEX_CHARS[ch & 0xF];\n                    _writer.write(ent, 2, 6);\n                }\n            }\n            return ptr;\n        }\n        String escape;\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (ptr >= len && ptr < end) { // fits in, prepend\n            ptr -= len;\n            escape.getChars(0, len, buffer, ptr);\n        } else { // won't fit, write separately\n            _writer.write(escape);\n        }\n        return ptr;\n    }",
          "74": "    private int _prependOrWriteCharacterEscape(char[] buffer, int ptr, int end,\n            char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (ptr > 1 && ptr < end) { // fits, just prepend\n                ptr -= 2;\n                buffer[ptr] = '\\\\';\n                buffer[ptr+1] = (char) escCode;\n            } else { // won't fit, write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                ent[1] = (char) escCode;\n                _writer.write(ent, 0, 2);\n            }\n            return ptr;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\n            if (ptr > 5 && ptr < end) { // fits, prepend to buffer\n                ptr -= 6;\n                buffer[ptr++] = '\\\\';\n                buffer[ptr++] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\nbuffer[ptr++] = ((HEX_CHARS != null))?HEX_CHARS[(hi << 4)]:HEX_CHARS[(hi << 4)];\n                    buffer[ptr++] = HEX_CHARS[hi & 0xF];\n                    ch &= 0xFF;\n                } else {\n                    buffer[ptr++] = '0';\n                    buffer[ptr++] = '0';\n                }\n                buffer[ptr++] = HEX_CHARS[ch >> 4];\n                buffer[ptr] = HEX_CHARS[ch & 0xF];\n                ptr -= 5;\n            } else {\n                // won't fit, flush and write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                _outputHead = _outputTail;\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    int lo = ch & 0xFF;\n                    ent[10] = HEX_CHARS[hi >> 4];\n                    ent[11] = HEX_CHARS[hi & 0xF];\n                    ent[12] = HEX_CHARS[lo >> 4];\n                    ent[13] = HEX_CHARS[lo & 0xF];\n                    _writer.write(ent, 8, 6);\n                } else { // We know it's a control char, so only the last 2 chars are non-0\n                    ent[6] = HEX_CHARS[ch >> 4];\n                    ent[7] = HEX_CHARS[ch & 0xF];\n                    _writer.write(ent, 2, 6);\n                }\n            }\n            return ptr;\n        }\n        String escape;\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (ptr >= len && ptr < end) { // fits in, prepend\n            ptr -= len;\n            escape.getChars(0, len, buffer, ptr);\n        } else { // won't fit, write separately\n            _writer.write(escape);\n        }\n        return ptr;\n    }",
          "75": "    private int _prependOrWriteCharacterEscape(char[] buffer, int ptr, int end,\n            char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (ptr > 1 && ptr < end) { // fits, just prepend\n                ptr -= 2;\n                buffer[ptr] = '\\\\';\n                buffer[ptr+1] = (char) escCode;\n            } else { // won't fit, write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                ent[1] = (char) escCode;\n                _writer.write(ent, 0, 2);\n            }\n            return ptr;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\n            if (ptr > 5 && ptr < end) { // fits, prepend to buffer\n                ptr -= 6;\n                buffer[ptr++] = '\\\\';\n                buffer[ptr++] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\nif(((hi != null) && (hi == hi))){\n                    buffer[ptr++] = HEX_CHARS[hi << 4];                    buffer[ptr++] = HEX_CHARS[hi & 0xF];\n                    ch &= 0xFF;\n                } else {\n                    buffer[ptr++] = '0';\n                    buffer[ptr++] = '0';\n}\n                }\n                buffer[ptr++] = HEX_CHARS[ch >> 4];\n                buffer[ptr] = HEX_CHARS[ch & 0xF];\n                ptr -= 5;\n            } else {\n                // won't fit, flush and write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                _outputHead = _outputTail;\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    int lo = ch & 0xFF;\n                    ent[10] = HEX_CHARS[hi >> 4];\n                    ent[11] = HEX_CHARS[hi & 0xF];\n                    ent[12] = HEX_CHARS[lo >> 4];\n                    ent[13] = HEX_CHARS[lo & 0xF];\n                    _writer.write(ent, 8, 6);\n                } else { // We know it's a control char, so only the last 2 chars are non-0\n                    ent[6] = HEX_CHARS[ch >> 4];\n                    ent[7] = HEX_CHARS[ch & 0xF];\n                    _writer.write(ent, 2, 6);\n                }\n            }\n            return ptr;\n        }\n        String escape;\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (ptr >= len && ptr < end) { // fits in, prepend\n            ptr -= len;\n            escape.getChars(0, len, buffer, ptr);\n        } else { // won't fit, write separately\n            _writer.write(escape);\n        }\n        return ptr;\n    }",
          "76": "    private int _prependOrWriteCharacterEscape(char[] buffer, int ptr, int end,\n            char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (ptr > 1 && ptr < end) { // fits, just prepend\n                ptr -= 2;\n                buffer[ptr] = '\\\\';\n                buffer[ptr+1] = (char) escCode;\n            } else { // won't fit, write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                ent[1] = (char) escCode;\n                _writer.write(ent, 0, 2);\n            }\n            return ptr;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\n            if (ptr > 5 && ptr < end) { // fits, prepend to buffer\n                ptr -= 6;\n                buffer[ptr++] = '\\\\';\n                buffer[ptr++] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\nif(((hi != null) && (hi == 0))){\n                    buffer[ptr++] = HEX_CHARS[hi << 4];                    buffer[ptr++] = HEX_CHARS[hi & 0xF];\n                    ch &= 0xFF;\n                } else {\n                    buffer[ptr++] = '0';\n                    buffer[ptr++] = '0';\n}\n                }\n                buffer[ptr++] = HEX_CHARS[ch >> 4];\n                buffer[ptr] = HEX_CHARS[ch & 0xF];\n                ptr -= 5;\n            } else {\n                // won't fit, flush and write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                _outputHead = _outputTail;\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    int lo = ch & 0xFF;\n                    ent[10] = HEX_CHARS[hi >> 4];\n                    ent[11] = HEX_CHARS[hi & 0xF];\n                    ent[12] = HEX_CHARS[lo >> 4];\n                    ent[13] = HEX_CHARS[lo & 0xF];\n                    _writer.write(ent, 8, 6);\n                } else { // We know it's a control char, so only the last 2 chars are non-0\n                    ent[6] = HEX_CHARS[ch >> 4];\n                    ent[7] = HEX_CHARS[ch & 0xF];\n                    _writer.write(ent, 2, 6);\n                }\n            }\n            return ptr;\n        }\n        String escape;\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (ptr >= len && ptr < end) { // fits in, prepend\n            ptr -= len;\n            escape.getChars(0, len, buffer, ptr);\n        } else { // won't fit, write separately\n            _writer.write(escape);\n        }\n        return ptr;\n    }",
          "77": "    private int _prependOrWriteCharacterEscape(char[] buffer, int ptr, int end,\n            char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (ptr > 1 && ptr < end) { // fits, just prepend\n                ptr -= 2;\n                buffer[ptr] = '\\\\';\n                buffer[ptr+1] = (char) escCode;\n            } else { // won't fit, write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                ent[1] = (char) escCode;\n                _writer.write(ent, 0, 2);\n            }\n            return ptr;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\n            if (ptr > 5 && ptr < end) { // fits, prepend to buffer\n                ptr -= 6;\n                buffer[ptr++] = '\\\\';\n                buffer[ptr++] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\nbuffer[ptr++] = ((HEX_CHARS[(hi << 4)] == null))?0:HEX_CHARS[(hi << 4)];\n                    buffer[ptr++] = HEX_CHARS[hi & 0xF];\n                    ch &= 0xFF;\n                } else {\n                    buffer[ptr++] = '0';\n                    buffer[ptr++] = '0';\n                }\n                buffer[ptr++] = HEX_CHARS[ch >> 4];\n                buffer[ptr] = HEX_CHARS[ch & 0xF];\n                ptr -= 5;\n            } else {\n                // won't fit, flush and write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                _outputHead = _outputTail;\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    int lo = ch & 0xFF;\n                    ent[10] = HEX_CHARS[hi >> 4];\n                    ent[11] = HEX_CHARS[hi & 0xF];\n                    ent[12] = HEX_CHARS[lo >> 4];\n                    ent[13] = HEX_CHARS[lo & 0xF];\n                    _writer.write(ent, 8, 6);\n                } else { // We know it's a control char, so only the last 2 chars are non-0\n                    ent[6] = HEX_CHARS[ch >> 4];\n                    ent[7] = HEX_CHARS[ch & 0xF];\n                    _writer.write(ent, 2, 6);\n                }\n            }\n            return ptr;\n        }\n        String escape;\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (ptr >= len && ptr < end) { // fits in, prepend\n            ptr -= len;\n            escape.getChars(0, len, buffer, ptr);\n        } else { // won't fit, write separately\n            _writer.write(escape);\n        }\n        return ptr;\n    }",
          "78": "    private int _prependOrWriteCharacterEscape(char[] buffer, int ptr, int end,\n            char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (ptr > 1 && ptr < end) { // fits, just prepend\n                ptr -= 2;\n                buffer[ptr] = '\\\\';\n                buffer[ptr+1] = (char) escCode;\n            } else { // won't fit, write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                ent[1] = (char) escCode;\n                _writer.write(ent, 0, 2);\n            }\n            return ptr;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\n            if (ptr > 5 && ptr < end) { // fits, prepend to buffer\n                ptr -= 6;\n                buffer[ptr++] = '\\\\';\n                buffer[ptr++] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\nbuffer[ptr++] = ((HEX_CHARS[(hi << 4)] != null))?HEX_CHARS[(hi << 4)]:HEX_CHARS[(hi << 4)];\n                    buffer[ptr++] = HEX_CHARS[hi & 0xF];\n                    ch &= 0xFF;\n                } else {\n                    buffer[ptr++] = '0';\n                    buffer[ptr++] = '0';\n                }\n                buffer[ptr++] = HEX_CHARS[ch >> 4];\n                buffer[ptr] = HEX_CHARS[ch & 0xF];\n                ptr -= 5;\n            } else {\n                // won't fit, flush and write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                _outputHead = _outputTail;\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    int lo = ch & 0xFF;\n                    ent[10] = HEX_CHARS[hi >> 4];\n                    ent[11] = HEX_CHARS[hi & 0xF];\n                    ent[12] = HEX_CHARS[lo >> 4];\n                    ent[13] = HEX_CHARS[lo & 0xF];\n                    _writer.write(ent, 8, 6);\n                } else { // We know it's a control char, so only the last 2 chars are non-0\n                    ent[6] = HEX_CHARS[ch >> 4];\n                    ent[7] = HEX_CHARS[ch & 0xF];\n                    _writer.write(ent, 2, 6);\n                }\n            }\n            return ptr;\n        }\n        String escape;\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (ptr >= len && ptr < end) { // fits in, prepend\n            ptr -= len;\n            escape.getChars(0, len, buffer, ptr);\n        } else { // won't fit, write separately\n            _writer.write(escape);\n        }\n        return ptr;\n    }",
          "79": "    private int _prependOrWriteCharacterEscape(char[] buffer, int ptr, int end,\n            char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (ptr > 1 && ptr < end) { // fits, just prepend\n                ptr -= 2;\n                buffer[ptr] = '\\\\';\n                buffer[ptr+1] = (char) escCode;\n            } else { // won't fit, write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                ent[1] = (char) escCode;\n                _writer.write(ent, 0, 2);\n            }\n            return ptr;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\n            if (ptr > 5 && ptr < end) { // fits, prepend to buffer\n                ptr -= 6;\n                buffer[ptr++] = '\\\\';\n                buffer[ptr++] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\nbuffer[ptr++] = ((HEX_CHARS[(hi << 4)] != null))?0:HEX_CHARS[(hi << 4)];\n                    buffer[ptr++] = HEX_CHARS[hi & 0xF];\n                    ch &= 0xFF;\n                } else {\n                    buffer[ptr++] = '0';\n                    buffer[ptr++] = '0';\n                }\n                buffer[ptr++] = HEX_CHARS[ch >> 4];\n                buffer[ptr] = HEX_CHARS[ch & 0xF];\n                ptr -= 5;\n            } else {\n                // won't fit, flush and write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                _outputHead = _outputTail;\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    int lo = ch & 0xFF;\n                    ent[10] = HEX_CHARS[hi >> 4];\n                    ent[11] = HEX_CHARS[hi & 0xF];\n                    ent[12] = HEX_CHARS[lo >> 4];\n                    ent[13] = HEX_CHARS[lo & 0xF];\n                    _writer.write(ent, 8, 6);\n                } else { // We know it's a control char, so only the last 2 chars are non-0\n                    ent[6] = HEX_CHARS[ch >> 4];\n                    ent[7] = HEX_CHARS[ch & 0xF];\n                    _writer.write(ent, 2, 6);\n                }\n            }\n            return ptr;\n        }\n        String escape;\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (ptr >= len && ptr < end) { // fits in, prepend\n            ptr -= len;\n            escape.getChars(0, len, buffer, ptr);\n        } else { // won't fit, write separately\n            _writer.write(escape);\n        }\n        return ptr;\n    }",
          "80": "    private int _prependOrWriteCharacterEscape(char[] buffer, int ptr, int end,\n            char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (ptr > 1 && ptr < end) { // fits, just prepend\n                ptr -= 2;\n                buffer[ptr] = '\\\\';\n                buffer[ptr+1] = (char) escCode;\n            } else { // won't fit, write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                ent[1] = (char) escCode;\n                _writer.write(ent, 0, 2);\n            }\n            return ptr;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\n            if (ptr > 5 && ptr < end) { // fits, prepend to buffer\n                ptr -= 6;\n                buffer[ptr++] = '\\\\';\n                buffer[ptr++] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\nbuffer[ptr++] = ((HEX_CHARS[(hi << 4)] == null))?0:buffer[(hi << 4)];\n                    buffer[ptr++] = HEX_CHARS[hi & 0xF];\n                    ch &= 0xFF;\n                } else {\n                    buffer[ptr++] = '0';\n                    buffer[ptr++] = '0';\n                }\n                buffer[ptr++] = HEX_CHARS[ch >> 4];\n                buffer[ptr] = HEX_CHARS[ch & 0xF];\n                ptr -= 5;\n            } else {\n                // won't fit, flush and write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                _outputHead = _outputTail;\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    int lo = ch & 0xFF;\n                    ent[10] = HEX_CHARS[hi >> 4];\n                    ent[11] = HEX_CHARS[hi & 0xF];\n                    ent[12] = HEX_CHARS[lo >> 4];\n                    ent[13] = HEX_CHARS[lo & 0xF];\n                    _writer.write(ent, 8, 6);\n                } else { // We know it's a control char, so only the last 2 chars are non-0\n                    ent[6] = HEX_CHARS[ch >> 4];\n                    ent[7] = HEX_CHARS[ch & 0xF];\n                    _writer.write(ent, 2, 6);\n                }\n            }\n            return ptr;\n        }\n        String escape;\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (ptr >= len && ptr < end) { // fits in, prepend\n            ptr -= len;\n            escape.getChars(0, len, buffer, ptr);\n        } else { // won't fit, write separately\n            _writer.write(escape);\n        }\n        return ptr;\n    }",
          "81": "    private int _prependOrWriteCharacterEscape(char[] buffer, int ptr, int end,\n            char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (ptr > 1 && ptr < end) { // fits, just prepend\n                ptr -= 2;\n                buffer[ptr] = '\\\\';\n                buffer[ptr+1] = (char) escCode;\n            } else { // won't fit, write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                ent[1] = (char) escCode;\n                _writer.write(ent, 0, 2);\n            }\n            return ptr;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\n            if (ptr > 5 && ptr < end) { // fits, prepend to buffer\n                ptr -= 6;\n                buffer[ptr++] = '\\\\';\n                buffer[ptr++] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\nbuffer[ptr++] = ((HEX_CHARS[(hi << 4)] == null))?HEX_CHARS[(hi << 4)]:HEX_CHARS[(hi << 4)];\n                    buffer[ptr++] = HEX_CHARS[hi & 0xF];\n                    ch &= 0xFF;\n                } else {\n                    buffer[ptr++] = '0';\n                    buffer[ptr++] = '0';\n                }\n                buffer[ptr++] = HEX_CHARS[ch >> 4];\n                buffer[ptr] = HEX_CHARS[ch & 0xF];\n                ptr -= 5;\n            } else {\n                // won't fit, flush and write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                _outputHead = _outputTail;\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    int lo = ch & 0xFF;\n                    ent[10] = HEX_CHARS[hi >> 4];\n                    ent[11] = HEX_CHARS[hi & 0xF];\n                    ent[12] = HEX_CHARS[lo >> 4];\n                    ent[13] = HEX_CHARS[lo & 0xF];\n                    _writer.write(ent, 8, 6);\n                } else { // We know it's a control char, so only the last 2 chars are non-0\n                    ent[6] = HEX_CHARS[ch >> 4];\n                    ent[7] = HEX_CHARS[ch & 0xF];\n                    _writer.write(ent, 2, 6);\n                }\n            }\n            return ptr;\n        }\n        String escape;\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (ptr >= len && ptr < end) { // fits in, prepend\n            ptr -= len;\n            escape.getChars(0, len, buffer, ptr);\n        } else { // won't fit, write separately\n            _writer.write(escape);\n        }\n        return ptr;\n    }",
          "82": "    private int _prependOrWriteCharacterEscape(char[] buffer, int ptr, int end,\n            char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (ptr > 1 && ptr < end) { // fits, just prepend\n                ptr -= 2;\n                buffer[ptr] = '\\\\';\n                buffer[ptr+1] = (char) escCode;\n            } else { // won't fit, write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                ent[1] = (char) escCode;\n                _writer.write(ent, 0, 2);\n            }\n            return ptr;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\n            if (ptr > 5 && ptr < end) { // fits, prepend to buffer\n                ptr -= 6;\n                buffer[ptr++] = '\\\\';\n                buffer[ptr++] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\nbuffer[ptr++] = ((HEX_CHARS[ptr++] != null))?HEX_CHARS[(hi << 4)]:HEX_CHARS[(hi << 4)];\n                    buffer[ptr++] = HEX_CHARS[hi & 0xF];\n                    ch &= 0xFF;\n                } else {\n                    buffer[ptr++] = '0';\n                    buffer[ptr++] = '0';\n                }\n                buffer[ptr++] = HEX_CHARS[ch >> 4];\n                buffer[ptr] = HEX_CHARS[ch & 0xF];\n                ptr -= 5;\n            } else {\n                // won't fit, flush and write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                _outputHead = _outputTail;\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    int lo = ch & 0xFF;\n                    ent[10] = HEX_CHARS[hi >> 4];\n                    ent[11] = HEX_CHARS[hi & 0xF];\n                    ent[12] = HEX_CHARS[lo >> 4];\n                    ent[13] = HEX_CHARS[lo & 0xF];\n                    _writer.write(ent, 8, 6);\n                } else { // We know it's a control char, so only the last 2 chars are non-0\n                    ent[6] = HEX_CHARS[ch >> 4];\n                    ent[7] = HEX_CHARS[ch & 0xF];\n                    _writer.write(ent, 2, 6);\n                }\n            }\n            return ptr;\n        }\n        String escape;\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (ptr >= len && ptr < end) { // fits in, prepend\n            ptr -= len;\n            escape.getChars(0, len, buffer, ptr);\n        } else { // won't fit, write separately\n            _writer.write(escape);\n        }\n        return ptr;\n    }",
          "83": "    private int _prependOrWriteCharacterEscape(char[] buffer, int ptr, int end,\n            char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (ptr > 1 && ptr < end) { // fits, just prepend\n                ptr -= 2;\n                buffer[ptr] = '\\\\';\n                buffer[ptr+1] = (char) escCode;\n            } else { // won't fit, write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                ent[1] = (char) escCode;\n                _writer.write(ent, 0, 2);\n            }\n            return ptr;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\n            if (ptr > 5 && ptr < end) { // fits, prepend to buffer\n                ptr -= 6;\n                buffer[ptr++] = '\\\\';\n                buffer[ptr++] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\nbuffer[ptr++] = ((HEX_CHARS[(hi << 4)] != null))?HEX_CHARS[(hi << 4)]:HEX_CHARS[ptr++];\n                    buffer[ptr++] = HEX_CHARS[hi & 0xF];\n                    ch &= 0xFF;\n                } else {\n                    buffer[ptr++] = '0';\n                    buffer[ptr++] = '0';\n                }\n                buffer[ptr++] = HEX_CHARS[ch >> 4];\n                buffer[ptr] = HEX_CHARS[ch & 0xF];\n                ptr -= 5;\n            } else {\n                // won't fit, flush and write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                _outputHead = _outputTail;\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    int lo = ch & 0xFF;\n                    ent[10] = HEX_CHARS[hi >> 4];\n                    ent[11] = HEX_CHARS[hi & 0xF];\n                    ent[12] = HEX_CHARS[lo >> 4];\n                    ent[13] = HEX_CHARS[lo & 0xF];\n                    _writer.write(ent, 8, 6);\n                } else { // We know it's a control char, so only the last 2 chars are non-0\n                    ent[6] = HEX_CHARS[ch >> 4];\n                    ent[7] = HEX_CHARS[ch & 0xF];\n                    _writer.write(ent, 2, 6);\n                }\n            }\n            return ptr;\n        }\n        String escape;\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (ptr >= len && ptr < end) { // fits in, prepend\n            ptr -= len;\n            escape.getChars(0, len, buffer, ptr);\n        } else { // won't fit, write separately\n            _writer.write(escape);\n        }\n        return ptr;\n    }",
          "84": "    private int _prependOrWriteCharacterEscape(char[] buffer, int ptr, int end,\n            char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (ptr > 1 && ptr < end) { // fits, just prepend\n                ptr -= 2;\n                buffer[ptr] = '\\\\';\n                buffer[ptr+1] = (char) escCode;\n            } else { // won't fit, write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                ent[1] = (char) escCode;\n                _writer.write(ent, 0, 2);\n            }\n            return ptr;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\n            if (ptr > 5 && ptr < end) { // fits, prepend to buffer\n                ptr -= 6;\n                buffer[ptr++] = '\\\\';\n                buffer[ptr++] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\nbuffer[ptr++] = ((HEX_CHARS[(hi << 4)] != null))?HEX_CHARS[(hi << 4)]:buffer[(hi << 4)];\n                    buffer[ptr++] = HEX_CHARS[hi & 0xF];\n                    ch &= 0xFF;\n                } else {\n                    buffer[ptr++] = '0';\n                    buffer[ptr++] = '0';\n                }\n                buffer[ptr++] = HEX_CHARS[ch >> 4];\n                buffer[ptr] = HEX_CHARS[ch & 0xF];\n                ptr -= 5;\n            } else {\n                // won't fit, flush and write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                _outputHead = _outputTail;\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    int lo = ch & 0xFF;\n                    ent[10] = HEX_CHARS[hi >> 4];\n                    ent[11] = HEX_CHARS[hi & 0xF];\n                    ent[12] = HEX_CHARS[lo >> 4];\n                    ent[13] = HEX_CHARS[lo & 0xF];\n                    _writer.write(ent, 8, 6);\n                } else { // We know it's a control char, so only the last 2 chars are non-0\n                    ent[6] = HEX_CHARS[ch >> 4];\n                    ent[7] = HEX_CHARS[ch & 0xF];\n                    _writer.write(ent, 2, 6);\n                }\n            }\n            return ptr;\n        }\n        String escape;\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (ptr >= len && ptr < end) { // fits in, prepend\n            ptr -= len;\n            escape.getChars(0, len, buffer, ptr);\n        } else { // won't fit, write separately\n            _writer.write(escape);\n        }\n        return ptr;\n    }",
          "85": "    private int _prependOrWriteCharacterEscape(char[] buffer, int ptr, int end,\n            char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (ptr > 1 && ptr < end) { // fits, just prepend\n                ptr -= 2;\n                buffer[ptr] = '\\\\';\n                buffer[ptr+1] = (char) escCode;\n            } else { // won't fit, write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                ent[1] = (char) escCode;\n                _writer.write(ent, 0, 2);\n            }\n            return ptr;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\n            if (ptr > 5 && ptr < end) { // fits, prepend to buffer\n                ptr -= 6;\n                buffer[ptr++] = '\\\\';\n                buffer[ptr++] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\nbuffer[ptr++] = ((HEX_CHARS[ptr++] == null))?HEX_CHARS[(hi << 4)]:HEX_CHARS[(hi << 4)];\n                    buffer[ptr++] = HEX_CHARS[hi & 0xF];\n                    ch &= 0xFF;\n                } else {\n                    buffer[ptr++] = '0';\n                    buffer[ptr++] = '0';\n                }\n                buffer[ptr++] = HEX_CHARS[ch >> 4];\n                buffer[ptr] = HEX_CHARS[ch & 0xF];\n                ptr -= 5;\n            } else {\n                // won't fit, flush and write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                _outputHead = _outputTail;\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    int lo = ch & 0xFF;\n                    ent[10] = HEX_CHARS[hi >> 4];\n                    ent[11] = HEX_CHARS[hi & 0xF];\n                    ent[12] = HEX_CHARS[lo >> 4];\n                    ent[13] = HEX_CHARS[lo & 0xF];\n                    _writer.write(ent, 8, 6);\n                } else { // We know it's a control char, so only the last 2 chars are non-0\n                    ent[6] = HEX_CHARS[ch >> 4];\n                    ent[7] = HEX_CHARS[ch & 0xF];\n                    _writer.write(ent, 2, 6);\n                }\n            }\n            return ptr;\n        }\n        String escape;\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (ptr >= len && ptr < end) { // fits in, prepend\n            ptr -= len;\n            escape.getChars(0, len, buffer, ptr);\n        } else { // won't fit, write separately\n            _writer.write(escape);\n        }\n        return ptr;\n    }",
          "86": "    private int _prependOrWriteCharacterEscape(char[] buffer, int ptr, int end,\n            char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (ptr > 1 && ptr < end) { // fits, just prepend\n                ptr -= 2;\n                buffer[ptr] = '\\\\';\n                buffer[ptr+1] = (char) escCode;\n            } else { // won't fit, write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                ent[1] = (char) escCode;\n                _writer.write(ent, 0, 2);\n            }\n            return ptr;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\n            if (ptr > 5 && ptr < end) { // fits, prepend to buffer\n                ptr -= 6;\n                buffer[ptr++] = '\\\\';\n                buffer[ptr++] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\nbuffer[ptr++] = ((HEX_CHARS[(hi << 4)] == null))?HEX_CHARS[(hi << 4)]:HEX_CHARS[ptr++];\n                    buffer[ptr++] = HEX_CHARS[hi & 0xF];\n                    ch &= 0xFF;\n                } else {\n                    buffer[ptr++] = '0';\n                    buffer[ptr++] = '0';\n                }\n                buffer[ptr++] = HEX_CHARS[ch >> 4];\n                buffer[ptr] = HEX_CHARS[ch & 0xF];\n                ptr -= 5;\n            } else {\n                // won't fit, flush and write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                _outputHead = _outputTail;\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    int lo = ch & 0xFF;\n                    ent[10] = HEX_CHARS[hi >> 4];\n                    ent[11] = HEX_CHARS[hi & 0xF];\n                    ent[12] = HEX_CHARS[lo >> 4];\n                    ent[13] = HEX_CHARS[lo & 0xF];\n                    _writer.write(ent, 8, 6);\n                } else { // We know it's a control char, so only the last 2 chars are non-0\n                    ent[6] = HEX_CHARS[ch >> 4];\n                    ent[7] = HEX_CHARS[ch & 0xF];\n                    _writer.write(ent, 2, 6);\n                }\n            }\n            return ptr;\n        }\n        String escape;\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (ptr >= len && ptr < end) { // fits in, prepend\n            ptr -= len;\n            escape.getChars(0, len, buffer, ptr);\n        } else { // won't fit, write separately\n            _writer.write(escape);\n        }\n        return ptr;\n    }",
          "87": "    private int _prependOrWriteCharacterEscape(char[] buffer, int ptr, int end,\n            char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (ptr > 1 && ptr < end) { // fits, just prepend\n                ptr -= 2;\n                buffer[ptr] = '\\\\';\n                buffer[ptr+1] = (char) escCode;\n            } else { // won't fit, write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                ent[1] = (char) escCode;\n                _writer.write(ent, 0, 2);\n            }\n            return ptr;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\n            if (ptr > 5 && ptr < end) { // fits, prepend to buffer\n                ptr -= 6;\n                buffer[ptr++] = '\\\\';\n                buffer[ptr++] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\nbuffer[ptr++] = ((HEX_CHARS[(hi << 4)] == null))?HEX_CHARS[(hi << 4)]:buffer[(hi << 4)];\n                    buffer[ptr++] = HEX_CHARS[hi & 0xF];\n                    ch &= 0xFF;\n                } else {\n                    buffer[ptr++] = '0';\n                    buffer[ptr++] = '0';\n                }\n                buffer[ptr++] = HEX_CHARS[ch >> 4];\n                buffer[ptr] = HEX_CHARS[ch & 0xF];\n                ptr -= 5;\n            } else {\n                // won't fit, flush and write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                _outputHead = _outputTail;\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    int lo = ch & 0xFF;\n                    ent[10] = HEX_CHARS[hi >> 4];\n                    ent[11] = HEX_CHARS[hi & 0xF];\n                    ent[12] = HEX_CHARS[lo >> 4];\n                    ent[13] = HEX_CHARS[lo & 0xF];\n                    _writer.write(ent, 8, 6);\n                } else { // We know it's a control char, so only the last 2 chars are non-0\n                    ent[6] = HEX_CHARS[ch >> 4];\n                    ent[7] = HEX_CHARS[ch & 0xF];\n                    _writer.write(ent, 2, 6);\n                }\n            }\n            return ptr;\n        }\n        String escape;\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (ptr >= len && ptr < end) { // fits in, prepend\n            ptr -= len;\n            escape.getChars(0, len, buffer, ptr);\n        } else { // won't fit, write separately\n            _writer.write(escape);\n        }\n        return ptr;\n    }",
          "88": "    private int _prependOrWriteCharacterEscape(char[] buffer, int ptr, int end,\n            char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (ptr > 1 && ptr < end) { // fits, just prepend\n                ptr -= 2;\n                buffer[ptr] = '\\\\';\n                buffer[ptr+1] = (char) escCode;\n            } else { // won't fit, write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                ent[1] = (char) escCode;\n                _writer.write(ent, 0, 2);\n            }\n            return ptr;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\n            if (ptr > 5 && ptr < end) { // fits, prepend to buffer\n                ptr -= 6;\n                buffer[ptr++] = '\\\\';\n                buffer[ptr++] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\nbuffer[ptr++] = ((HEX_CHARS[(hi << 4)] != null))?buffer[(hi << 4)]:HEX_CHARS[(hi << 4)];\n                    buffer[ptr++] = HEX_CHARS[hi & 0xF];\n                    ch &= 0xFF;\n                } else {\n                    buffer[ptr++] = '0';\n                    buffer[ptr++] = '0';\n                }\n                buffer[ptr++] = HEX_CHARS[ch >> 4];\n                buffer[ptr] = HEX_CHARS[ch & 0xF];\n                ptr -= 5;\n            } else {\n                // won't fit, flush and write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                _outputHead = _outputTail;\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    int lo = ch & 0xFF;\n                    ent[10] = HEX_CHARS[hi >> 4];\n                    ent[11] = HEX_CHARS[hi & 0xF];\n                    ent[12] = HEX_CHARS[lo >> 4];\n                    ent[13] = HEX_CHARS[lo & 0xF];\n                    _writer.write(ent, 8, 6);\n                } else { // We know it's a control char, so only the last 2 chars are non-0\n                    ent[6] = HEX_CHARS[ch >> 4];\n                    ent[7] = HEX_CHARS[ch & 0xF];\n                    _writer.write(ent, 2, 6);\n                }\n            }\n            return ptr;\n        }\n        String escape;\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (ptr >= len && ptr < end) { // fits in, prepend\n            ptr -= len;\n            escape.getChars(0, len, buffer, ptr);\n        } else { // won't fit, write separately\n            _writer.write(escape);\n        }\n        return ptr;\n    }",
          "89": "    private int _prependOrWriteCharacterEscape(char[] buffer, int ptr, int end,\n            char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (ptr > 1 && ptr < end) { // fits, just prepend\n                ptr -= 2;\n                buffer[ptr] = '\\\\';\n                buffer[ptr+1] = (char) escCode;\n            } else { // won't fit, write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                ent[1] = (char) escCode;\n                _writer.write(ent, 0, 2);\n            }\n            return ptr;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\n            if (ptr > 5 && ptr < end) { // fits, prepend to buffer\n                ptr -= 6;\n                buffer[ptr++] = '\\\\';\n                buffer[ptr++] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\nbuffer[ptr++] = ((buffer[(hi << 4)] != null))?HEX_CHARS[(hi << 4)]:HEX_CHARS[(hi << 4)];\n                    buffer[ptr++] = HEX_CHARS[hi & 0xF];\n                    ch &= 0xFF;\n                } else {\n                    buffer[ptr++] = '0';\n                    buffer[ptr++] = '0';\n                }\n                buffer[ptr++] = HEX_CHARS[ch >> 4];\n                buffer[ptr] = HEX_CHARS[ch & 0xF];\n                ptr -= 5;\n            } else {\n                // won't fit, flush and write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                _outputHead = _outputTail;\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    int lo = ch & 0xFF;\n                    ent[10] = HEX_CHARS[hi >> 4];\n                    ent[11] = HEX_CHARS[hi & 0xF];\n                    ent[12] = HEX_CHARS[lo >> 4];\n                    ent[13] = HEX_CHARS[lo & 0xF];\n                    _writer.write(ent, 8, 6);\n                } else { // We know it's a control char, so only the last 2 chars are non-0\n                    ent[6] = HEX_CHARS[ch >> 4];\n                    ent[7] = HEX_CHARS[ch & 0xF];\n                    _writer.write(ent, 2, 6);\n                }\n            }\n            return ptr;\n        }\n        String escape;\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (ptr >= len && ptr < end) { // fits in, prepend\n            ptr -= len;\n            escape.getChars(0, len, buffer, ptr);\n        } else { // won't fit, write separately\n            _writer.write(escape);\n        }\n        return ptr;\n    }",
          "90": "    private int _prependOrWriteCharacterEscape(char[] buffer, int ptr, int end,\n            char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (ptr > 1 && ptr < end) { // fits, just prepend\n                ptr -= 2;\n                buffer[ptr] = '\\\\';\n                buffer[ptr+1] = (char) escCode;\n            } else { // won't fit, write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                ent[1] = (char) escCode;\n                _writer.write(ent, 0, 2);\n            }\n            return ptr;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\n            if (ptr > 5 && ptr < end) { // fits, prepend to buffer\n                ptr -= 6;\n                buffer[ptr++] = '\\\\';\n                buffer[ptr++] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\nbuffer[ptr++] = ((HEX_CHARS[(hi << 4)] == null))?buffer[(hi << 4)]:HEX_CHARS[(hi << 4)];\n                    buffer[ptr++] = HEX_CHARS[hi & 0xF];\n                    ch &= 0xFF;\n                } else {\n                    buffer[ptr++] = '0';\n                    buffer[ptr++] = '0';\n                }\n                buffer[ptr++] = HEX_CHARS[ch >> 4];\n                buffer[ptr] = HEX_CHARS[ch & 0xF];\n                ptr -= 5;\n            } else {\n                // won't fit, flush and write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                _outputHead = _outputTail;\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    int lo = ch & 0xFF;\n                    ent[10] = HEX_CHARS[hi >> 4];\n                    ent[11] = HEX_CHARS[hi & 0xF];\n                    ent[12] = HEX_CHARS[lo >> 4];\n                    ent[13] = HEX_CHARS[lo & 0xF];\n                    _writer.write(ent, 8, 6);\n                } else { // We know it's a control char, so only the last 2 chars are non-0\n                    ent[6] = HEX_CHARS[ch >> 4];\n                    ent[7] = HEX_CHARS[ch & 0xF];\n                    _writer.write(ent, 2, 6);\n                }\n            }\n            return ptr;\n        }\n        String escape;\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (ptr >= len && ptr < end) { // fits in, prepend\n            ptr -= len;\n            escape.getChars(0, len, buffer, ptr);\n        } else { // won't fit, write separately\n            _writer.write(escape);\n        }\n        return ptr;\n    }",
          "91": "    private int _prependOrWriteCharacterEscape(char[] buffer, int ptr, int end,\n            char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (ptr > 1 && ptr < end) { // fits, just prepend\n                ptr -= 2;\n                buffer[ptr] = '\\\\';\n                buffer[ptr+1] = (char) escCode;\n            } else { // won't fit, write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                ent[1] = (char) escCode;\n                _writer.write(ent, 0, 2);\n            }\n            return ptr;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\n            if (ptr > 5 && ptr < end) { // fits, prepend to buffer\n                ptr -= 6;\n                buffer[ptr++] = '\\\\';\n                buffer[ptr++] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\nbuffer[ptr++] = ((buffer[(hi << 4)] == null))?HEX_CHARS[(hi << 4)]:HEX_CHARS[(hi << 4)];\n                    buffer[ptr++] = HEX_CHARS[hi & 0xF];\n                    ch &= 0xFF;\n                } else {\n                    buffer[ptr++] = '0';\n                    buffer[ptr++] = '0';\n                }\n                buffer[ptr++] = HEX_CHARS[ch >> 4];\n                buffer[ptr] = HEX_CHARS[ch & 0xF];\n                ptr -= 5;\n            } else {\n                // won't fit, flush and write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                _outputHead = _outputTail;\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    int lo = ch & 0xFF;\n                    ent[10] = HEX_CHARS[hi >> 4];\n                    ent[11] = HEX_CHARS[hi & 0xF];\n                    ent[12] = HEX_CHARS[lo >> 4];\n                    ent[13] = HEX_CHARS[lo & 0xF];\n                    _writer.write(ent, 8, 6);\n                } else { // We know it's a control char, so only the last 2 chars are non-0\n                    ent[6] = HEX_CHARS[ch >> 4];\n                    ent[7] = HEX_CHARS[ch & 0xF];\n                    _writer.write(ent, 2, 6);\n                }\n            }\n            return ptr;\n        }\n        String escape;\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (ptr >= len && ptr < end) { // fits in, prepend\n            ptr -= len;\n            escape.getChars(0, len, buffer, ptr);\n        } else { // won't fit, write separately\n            _writer.write(escape);\n        }\n        return ptr;\n    }",
          "92": "    private int _prependOrWriteCharacterEscape(char[] buffer, int ptr, int end,\n            char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (ptr > 1 && ptr < end) { // fits, just prepend\n                ptr -= 2;\n                buffer[ptr] = '\\\\';\n                buffer[ptr+1] = (char) escCode;\n            } else { // won't fit, write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                ent[1] = (char) escCode;\n                _writer.write(ent, 0, 2);\n            }\n            return ptr;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\n            if (ptr > 5 && ptr < end) { // fits, prepend to buffer\n                ptr -= 6;\n                buffer[ptr++] = '\\\\';\n                buffer[ptr++] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\nbuffer[ptr++] = ((HEX_CHARS[(hi << 4)] != null))?HEX_CHARS[(hi << 4)]:buffer[ptr++];\n                    buffer[ptr++] = HEX_CHARS[hi & 0xF];\n                    ch &= 0xFF;\n                } else {\n                    buffer[ptr++] = '0';\n                    buffer[ptr++] = '0';\n                }\n                buffer[ptr++] = HEX_CHARS[ch >> 4];\n                buffer[ptr] = HEX_CHARS[ch & 0xF];\n                ptr -= 5;\n            } else {\n                // won't fit, flush and write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                _outputHead = _outputTail;\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    int lo = ch & 0xFF;\n                    ent[10] = HEX_CHARS[hi >> 4];\n                    ent[11] = HEX_CHARS[hi & 0xF];\n                    ent[12] = HEX_CHARS[lo >> 4];\n                    ent[13] = HEX_CHARS[lo & 0xF];\n                    _writer.write(ent, 8, 6);\n                } else { // We know it's a control char, so only the last 2 chars are non-0\n                    ent[6] = HEX_CHARS[ch >> 4];\n                    ent[7] = HEX_CHARS[ch & 0xF];\n                    _writer.write(ent, 2, 6);\n                }\n            }\n            return ptr;\n        }\n        String escape;\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (ptr >= len && ptr < end) { // fits in, prepend\n            ptr -= len;\n            escape.getChars(0, len, buffer, ptr);\n        } else { // won't fit, write separately\n            _writer.write(escape);\n        }\n        return ptr;\n    }",
          "93": "    private int _prependOrWriteCharacterEscape(char[] buffer, int ptr, int end,\n            char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (ptr > 1 && ptr < end) { // fits, just prepend\n                ptr -= 2;\n                buffer[ptr] = '\\\\';\n                buffer[ptr+1] = (char) escCode;\n            } else { // won't fit, write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                ent[1] = (char) escCode;\n                _writer.write(ent, 0, 2);\n            }\n            return ptr;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\n            if (ptr > 5 && ptr < end) { // fits, prepend to buffer\n                ptr -= 6;\n                buffer[ptr++] = '\\\\';\n                buffer[ptr++] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\nbuffer[ptr++] = ((HEX_CHARS[ptr++] != null))?HEX_CHARS[(hi << 4)]:HEX_CHARS[ptr++];\n                    buffer[ptr++] = HEX_CHARS[hi & 0xF];\n                    ch &= 0xFF;\n                } else {\n                    buffer[ptr++] = '0';\n                    buffer[ptr++] = '0';\n                }\n                buffer[ptr++] = HEX_CHARS[ch >> 4];\n                buffer[ptr] = HEX_CHARS[ch & 0xF];\n                ptr -= 5;\n            } else {\n                // won't fit, flush and write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                _outputHead = _outputTail;\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    int lo = ch & 0xFF;\n                    ent[10] = HEX_CHARS[hi >> 4];\n                    ent[11] = HEX_CHARS[hi & 0xF];\n                    ent[12] = HEX_CHARS[lo >> 4];\n                    ent[13] = HEX_CHARS[lo & 0xF];\n                    _writer.write(ent, 8, 6);\n                } else { // We know it's a control char, so only the last 2 chars are non-0\n                    ent[6] = HEX_CHARS[ch >> 4];\n                    ent[7] = HEX_CHARS[ch & 0xF];\n                    _writer.write(ent, 2, 6);\n                }\n            }\n            return ptr;\n        }\n        String escape;\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (ptr >= len && ptr < end) { // fits in, prepend\n            ptr -= len;\n            escape.getChars(0, len, buffer, ptr);\n        } else { // won't fit, write separately\n            _writer.write(escape);\n        }\n        return ptr;\n    }"
}