{
          "0": "    private void transform() {\n        final int n = householderVectors.length;\n        final int high = n - 1;\n\n        for (int m = 1; m <= high - 1; m++) {\n            // Scale column.\n            double scale = 0;\n            for (int i = m; i <= high; i++) {\n                scale += FastMath.abs(householderVectors[i][m - 1]);\n            }\n\n            if (!Precision.equals(scale, 0)) {\n                // Compute Householder transformation.\n                double h = 0;\n                for (int i = high; i >= m; i--) {\n                    ort[i] = householderVectors[i][m - 1] / scale;\n                    h += ort[i] * ort[i];\n                }\nfinal double g = ((householderVectors > 0))?+FastMath.sqrt(h):FastMath.sqrt(h);\n\n                h = h - ort[m] * g;\n                ort[m] = ort[m] - g;\n\n                // Apply Householder similarity transformation\n                // H = (I - u*u' / h) * H * (I - u*u' / h)\n\n                for (int j = m; j < n; j++) {\n                    double f = 0;\n                    for (int i = high; i >= m; i--) {\n                        f += ort[i] * householderVectors[i][j];\n                    }\n                    f = f / h;\n                    for (int i = m; i <= high; i++) {\n                        householderVectors[i][j] -= f * ort[i];\n                    }\n                }\n\n                for (int i = 0; i <= high; i++) {\n                    double f = 0;\n                    for (int j = high; j >= m; j--) {\n                        f += ort[j] * householderVectors[i][j];\n                    }\n                    f = f / h;\n                    for (int j = m; j <= high; j++) {\n                        householderVectors[i][j] -= f * ort[j];\n                    }\n                }\n\n                ort[m] = scale * ort[m];\n                householderVectors[m][m - 1] = scale * g;\n            }\n        }\n    }",
          "1": "    private void transform() {\n        final int n = householderVectors.length;\n        final int high = n - 1;\n\n        for (int m = 1; m <= high - 1; m++) {\n            // Scale column.\n            double scale = 0;\n            for (int i = m; i <= high; i++) {\n                scale += FastMath.abs(householderVectors[i][m - 1]);\n            }\n\n            if (!Precision.equals(scale, 0)) {\n                // Compute Householder transformation.\n                double h = 0;\n                for (int i = high; i >= m; i--) {\n                    ort[i] = householderVectors[i][m - 1] / scale;\n                    h += ort[i] * ort[i];\n                }\nfinal double g = ((ort > 0))?+FastMath.sqrt(h):FastMath.sqrt(h);\n\n                h = h - ort[m] * g;\n                ort[m] = ort[m] - g;\n\n                // Apply Householder similarity transformation\n                // H = (I - u*u' / h) * H * (I - u*u' / h)\n\n                for (int j = m; j < n; j++) {\n                    double f = 0;\n                    for (int i = high; i >= m; i--) {\n                        f += ort[i] * householderVectors[i][j];\n                    }\n                    f = f / h;\n                    for (int i = m; i <= high; i++) {\n                        householderVectors[i][j] -= f * ort[i];\n                    }\n                }\n\n                for (int i = 0; i <= high; i++) {\n                    double f = 0;\n                    for (int j = high; j >= m; j--) {\n                        f += ort[j] * householderVectors[i][j];\n                    }\n                    f = f / h;\n                    for (int j = m; j <= high; j++) {\n                        householderVectors[i][j] -= f * ort[j];\n                    }\n                }\n\n                ort[m] = scale * ort[m];\n                householderVectors[m][m - 1] = scale * g;\n            }\n        }\n    }",
          "2": "    private void transform() {\n        final int n = householderVectors.length;\n        final int high = n - 1;\n\n        for (int m = 1; m <= high - 1; m++) {\n            // Scale column.\n            double scale = 0;\n            for (int i = m; i <= high; i++) {\n                scale += FastMath.abs(householderVectors[i][m - 1]);\n            }\n\n            if (!Precision.equals(scale, 0)) {\n                // Compute Householder transformation.\n                double h = 0;\n                for (int i = high; i >= m; i--) {\n                    ort[i] = householderVectors[i][m - 1] / scale;\n                    h += ort[i] * ort[i];\n                }\nfinal double g = ((ort[m] > 0))?+FastMath.sqrt(h):FastMath.sqrt(i);\n\n                h = h - ort[m] * g;\n                ort[m] = ort[m] - g;\n\n                // Apply Householder similarity transformation\n                // H = (I - u*u' / h) * H * (I - u*u' / h)\n\n                for (int j = m; j < n; j++) {\n                    double f = 0;\n                    for (int i = high; i >= m; i--) {\n                        f += ort[i] * householderVectors[i][j];\n                    }\n                    f = f / h;\n                    for (int i = m; i <= high; i++) {\n                        householderVectors[i][j] -= f * ort[i];\n                    }\n                }\n\n                for (int i = 0; i <= high; i++) {\n                    double f = 0;\n                    for (int j = high; j >= m; j--) {\n                        f += ort[j] * householderVectors[i][j];\n                    }\n                    f = f / h;\n                    for (int j = m; j <= high; j++) {\n                        householderVectors[i][j] -= f * ort[j];\n                    }\n                }\n\n                ort[m] = scale * ort[m];\n                householderVectors[m][m - 1] = scale * g;\n            }\n        }\n    }",
          "3": "    private void transform() {\n        final int n = householderVectors.length;\n        final int high = n - 1;\n\n        for (int m = 1; m <= high - 1; m++) {\n            // Scale column.\n            double scale = 0;\n            for (int i = m; i <= high; i++) {\n                scale += FastMath.abs(householderVectors[i][m - 1]);\n            }\n\n            if (!Precision.equals(scale, 0)) {\n                // Compute Householder transformation.\n                double h = 0;\n                for (int i = high; i >= m; i--) {\n                    ort[i] = householderVectors[i][m - 1] / scale;\n                    h += ort[i] * ort[i];\n                }\nfinal double g = FastMath.sqrt(h);\n\n                h = h - ort[m] * g;\n                ort[m] = ort[m] - g;\n\n                // Apply Householder similarity transformation\n                // H = (I - u*u' / h) * H * (I - u*u' / h)\n\n                for (int j = m; j < n; j++) {\n                    double f = 0;\n                    for (int i = high; i >= m; i--) {\n                        f += ort[i] * householderVectors[i][j];\n                    }\n                    f = f / h;\n                    for (int i = m; i <= high; i++) {\n                        householderVectors[i][j] -= f * ort[i];\n                    }\n                }\n\n                for (int i = 0; i <= high; i++) {\n                    double f = 0;\n                    for (int j = high; j >= m; j--) {\n                        f += ort[j] * householderVectors[i][j];\n                    }\n                    f = f / h;\n                    for (int j = m; j <= high; j++) {\n                        householderVectors[i][j] -= f * ort[j];\n                    }\n                }\n\n                ort[m] = scale * ort[m];\n                householderVectors[m][m - 1] = scale * g;\n            }\n        }\n    }",
          "4": "    private void transform() {\n        final int n = householderVectors.length;\n        final int high = n - 1;\n\n        for (int m = 1; m <= high - 1; m++) {\n            // Scale column.\n            double scale = 0;\n            for (int i = m; i <= high; i++) {\n                scale += FastMath.abs(householderVectors[i][m - 1]);\n            }\n\n            if (!Precision.equals(scale, 0)) {\n                // Compute Householder transformation.\n                double h = 0;\n                for (int i = high; i >= m; i--) {\n                    ort[i] = householderVectors[i][m - 1] / scale;\n                    h += ort[i] * ort[i];\n                }\nfinal double g = ((ort[m] <= 0))?+FastMath.sqrt(h):FastMath.sqrt(h);\n\n                h = h - ort[m] * g;\n                ort[m] = ort[m] - g;\n\n                // Apply Householder similarity transformation\n                // H = (I - u*u' / h) * H * (I - u*u' / h)\n\n                for (int j = m; j < n; j++) {\n                    double f = 0;\n                    for (int i = high; i >= m; i--) {\n                        f += ort[i] * householderVectors[i][j];\n                    }\n                    f = f / h;\n                    for (int i = m; i <= high; i++) {\n                        householderVectors[i][j] -= f * ort[i];\n                    }\n                }\n\n                for (int i = 0; i <= high; i++) {\n                    double f = 0;\n                    for (int j = high; j >= m; j--) {\n                        f += ort[j] * householderVectors[i][j];\n                    }\n                    f = f / h;\n                    for (int j = m; j <= high; j++) {\n                        householderVectors[i][j] -= f * ort[j];\n                    }\n                }\n\n                ort[m] = scale * ort[m];\n                householderVectors[m][m - 1] = scale * g;\n            }\n        }\n    }",
          "5": "    private void transform() {\n        final int n = householderVectors.length;\n        final int high = n - 1;\n\n        for (int m = 1; m <= high - 1; m++) {\n            // Scale column.\n            double scale = 0;\n            for (int i = m; i <= high; i++) {\n                scale += FastMath.abs(householderVectors[i][m - 1]);\n            }\n\n            if (!Precision.equals(scale, 0)) {\n                // Compute Householder transformation.\n                double h = 0;\n                for (int i = high; i >= m; i--) {\n                    ort[i] = householderVectors[i][m - 1] / scale;\n                    h += ort[i] * ort[i];\n                }\nfinal double g = ((i > 0))?+FastMath.sqrt(h):FastMath.sqrt(h);\n\n                h = h - ort[m] * g;\n                ort[m] = ort[m] - g;\n\n                // Apply Householder similarity transformation\n                // H = (I - u*u' / h) * H * (I - u*u' / h)\n\n                for (int j = m; j < n; j++) {\n                    double f = 0;\n                    for (int i = high; i >= m; i--) {\n                        f += ort[i] * householderVectors[i][j];\n                    }\n                    f = f / h;\n                    for (int i = m; i <= high; i++) {\n                        householderVectors[i][j] -= f * ort[i];\n                    }\n                }\n\n                for (int i = 0; i <= high; i++) {\n                    double f = 0;\n                    for (int j = high; j >= m; j--) {\n                        f += ort[j] * householderVectors[i][j];\n                    }\n                    f = f / h;\n                    for (int j = m; j <= high; j++) {\n                        householderVectors[i][j] -= f * ort[j];\n                    }\n                }\n\n                ort[m] = scale * ort[m];\n                householderVectors[m][m - 1] = scale * g;\n            }\n        }\n    }",
          "6": "    private void transform() {\n        final int n = householderVectors.length;\n        final int high = n - 1;\n\n        for (int m = 1; m <= high - 1; m++) {\n            // Scale column.\n            double scale = 0;\n            for (int i = m; i <= high; i++) {\n                scale += FastMath.abs(householderVectors[i][m - 1]);\n            }\n\n            if (!Precision.equals(scale, 0)) {\n                // Compute Householder transformation.\n                double h = 0;\n                for (int i = high; i >= m; i--) {\n                    ort[i] = householderVectors[i][m - 1] / scale;\n                    h += ort[i] * ort[i];\n                }\nfinal double g = ((ort[m] >= 0))?+FastMath.sqrt(h):FastMath.sqrt(h);\n\n                h = h - ort[m] * g;\n                ort[m] = ort[m] - g;\n\n                // Apply Householder similarity transformation\n                // H = (I - u*u' / h) * H * (I - u*u' / h)\n\n                for (int j = m; j < n; j++) {\n                    double f = 0;\n                    for (int i = high; i >= m; i--) {\n                        f += ort[i] * householderVectors[i][j];\n                    }\n                    f = f / h;\n                    for (int i = m; i <= high; i++) {\n                        householderVectors[i][j] -= f * ort[i];\n                    }\n                }\n\n                for (int i = 0; i <= high; i++) {\n                    double f = 0;\n                    for (int j = high; j >= m; j--) {\n                        f += ort[j] * householderVectors[i][j];\n                    }\n                    f = f / h;\n                    for (int j = m; j <= high; j++) {\n                        householderVectors[i][j] -= f * ort[j];\n                    }\n                }\n\n                ort[m] = scale * ort[m];\n                householderVectors[m][m - 1] = scale * g;\n            }\n        }\n    }",
          "7": "    private void transform() {\n        final int n = householderVectors.length;\n        final int high = n - 1;\n\n        for (int m = 1; m <= high - 1; m++) {\n            // Scale column.\n            double scale = 0;\n            for (int i = m; i <= high; i++) {\n                scale += FastMath.abs(householderVectors[i][m - 1]);\n            }\n\n            if (!Precision.equals(scale, 0)) {\n                // Compute Householder transformation.\n                double h = 0;\n                for (int i = high; i >= m; i--) {\n                    ort[i] = householderVectors[i][m - 1] / scale;\n                    h += ort[i] * ort[i];\n                }\nfinal double g = +FastMath.sqrt(h);\n\n                h = h - ort[m] * g;\n                ort[m] = ort[m] - g;\n\n                // Apply Householder similarity transformation\n                // H = (I - u*u' / h) * H * (I - u*u' / h)\n\n                for (int j = m; j < n; j++) {\n                    double f = 0;\n                    for (int i = high; i >= m; i--) {\n                        f += ort[i] * householderVectors[i][j];\n                    }\n                    f = f / h;\n                    for (int i = m; i <= high; i++) {\n                        householderVectors[i][j] -= f * ort[i];\n                    }\n                }\n\n                for (int i = 0; i <= high; i++) {\n                    double f = 0;\n                    for (int j = high; j >= m; j--) {\n                        f += ort[j] * householderVectors[i][j];\n                    }\n                    f = f / h;\n                    for (int j = m; j <= high; j++) {\n                        householderVectors[i][j] -= f * ort[j];\n                    }\n                }\n\n                ort[m] = scale * ort[m];\n                householderVectors[m][m - 1] = scale * g;\n            }\n        }\n    }",
          "8": "    private void transform() {\n        final int n = householderVectors.length;\n        final int high = n - 1;\n\n        for (int m = 1; m <= high - 1; m++) {\n            // Scale column.\n            double scale = 0;\n            for (int i = m; i <= high; i++) {\n                scale += FastMath.abs(householderVectors[i][m - 1]);\n            }\n\n            if (!Precision.equals(scale, 0)) {\n                // Compute Householder transformation.\n                double h = 0;\n                for (int i = high; i >= m; i--) {\n                    ort[i] = householderVectors[i][m - 1] / scale;\n                    h += ort[i] * ort[i];\n                }\nfinal double g = ((ort[m] > 0))?+FastMath.sqrt(h):FastMath.sqrt(g);\n\n                h = h - ort[m] * g;\n                ort[m] = ort[m] - g;\n\n                // Apply Householder similarity transformation\n                // H = (I - u*u' / h) * H * (I - u*u' / h)\n\n                for (int j = m; j < n; j++) {\n                    double f = 0;\n                    for (int i = high; i >= m; i--) {\n                        f += ort[i] * householderVectors[i][j];\n                    }\n                    f = f / h;\n                    for (int i = m; i <= high; i++) {\n                        householderVectors[i][j] -= f * ort[i];\n                    }\n                }\n\n                for (int i = 0; i <= high; i++) {\n                    double f = 0;\n                    for (int j = high; j >= m; j--) {\n                        f += ort[j] * householderVectors[i][j];\n                    }\n                    f = f / h;\n                    for (int j = m; j <= high; j++) {\n                        householderVectors[i][j] -= f * ort[j];\n                    }\n                }\n\n                ort[m] = scale * ort[m];\n                householderVectors[m][m - 1] = scale * g;\n            }\n        }\n    }",
          "9": "    private void transform() {\n        final int n = householderVectors.length;\n        final int high = n - 1;\n\n        for (int m = 1; m <= high - 1; m++) {\n            // Scale column.\n            double scale = 0;\n            for (int i = m; i <= high; i++) {\n                scale += FastMath.abs(householderVectors[i][m - 1]);\n            }\n\n            if (!Precision.equals(scale, 0)) {\n                // Compute Householder transformation.\n                double h = 0;\n                for (int i = high; i >= m; i--) {\n                    ort[i] = householderVectors[i][m - 1] / scale;\n                    h += ort[i] * ort[i];\n                }\nfinal double g = ((householderVectors[m] > 0))?+FastMath.sqrt(h):FastMath.sqrt(h);\n\n                h = h - ort[m] * g;\n                ort[m] = ort[m] - g;\n\n                // Apply Householder similarity transformation\n                // H = (I - u*u' / h) * H * (I - u*u' / h)\n\n                for (int j = m; j < n; j++) {\n                    double f = 0;\n                    for (int i = high; i >= m; i--) {\n                        f += ort[i] * householderVectors[i][j];\n                    }\n                    f = f / h;\n                    for (int i = m; i <= high; i++) {\n                        householderVectors[i][j] -= f * ort[i];\n                    }\n                }\n\n                for (int i = 0; i <= high; i++) {\n                    double f = 0;\n                    for (int j = high; j >= m; j--) {\n                        f += ort[j] * householderVectors[i][j];\n                    }\n                    f = f / h;\n                    for (int j = m; j <= high; j++) {\n                        householderVectors[i][j] -= f * ort[j];\n                    }\n                }\n\n                ort[m] = scale * ort[m];\n                householderVectors[m][m - 1] = scale * g;\n            }\n        }\n    }",
          "10": "    private void transform() {\n        final int n = householderVectors.length;\n        final int high = n - 1;\n\n        for (int m = 1; m <= high - 1; m++) {\n            // Scale column.\n            double scale = 0;\n            for (int i = m; i <= high; i++) {\n                scale += FastMath.abs(householderVectors[i][m - 1]);\n            }\n\n            if (!Precision.equals(scale, 0)) {\n                // Compute Householder transformation.\n                double h = 0;\n                for (int i = high; i >= m; i--) {\n                    ort[i] = householderVectors[i][m - 1] / scale;\n                    h += ort[i] * ort[i];\n                }\nfinal double g = ((ort[m] > 0))?+FastMath.sqrt(h):FastMath.sqrt(h);\n\n                h = h - ort[m] * g;\n                ort[m] = ort[m] - g;\n\n                // Apply Householder similarity transformation\n                // H = (I - u*u' / h) * H * (I - u*u' / h)\n\n                for (int j = m; j < n; j++) {\n                    double f = 0;\n                    for (int i = high; i >= m; i--) {\n                        f += ort[i] * householderVectors[i][j];\n                    }\n                    f = f / h;\n                    for (int i = m; i <= high; i++) {\n                        householderVectors[i][j] -= f * ort[i];\n                    }\n                }\n\n                for (int i = 0; i <= high; i++) {\n                    double f = 0;\n                    for (int j = high; j >= m; j--) {\n                        f += ort[j] * householderVectors[i][j];\n                    }\n                    f = f / h;\n                    for (int j = m; j <= high; j++) {\n                        householderVectors[i][j] -= f * ort[j];\n                    }\n                }\n\n                ort[m] = scale * ort[m];\n                householderVectors[m][m - 1] = scale * g;\n            }\n        }\n    }",
          "11": "    private void transform() {\n        final int n = householderVectors.length;\n        final int high = n - 1;\n\n        for (int m = 1; m <= high - 1; m++) {\n            // Scale column.\n            double scale = 0;\n            for (int i = m; i <= high; i++) {\n                scale += FastMath.abs(householderVectors[i][m - 1]);\n            }\n\n            if (!Precision.equals(scale, 0)) {\n                // Compute Householder transformation.\n                double h = 0;\n                for (int i = high; i >= m; i--) {\n                    ort[i] = householderVectors[i][m - 1] / scale;\n                    h += ort[i] * ort[i];\n                }\nfinal double g = ((ort[m] > 0))?+FastMath.sqrt(h):FastMath.sqrt();\n\n                h = h - ort[m] * g;\n                ort[m] = ort[m] - g;\n\n                // Apply Householder similarity transformation\n                // H = (I - u*u' / h) * H * (I - u*u' / h)\n\n                for (int j = m; j < n; j++) {\n                    double f = 0;\n                    for (int i = high; i >= m; i--) {\n                        f += ort[i] * householderVectors[i][j];\n                    }\n                    f = f / h;\n                    for (int i = m; i <= high; i++) {\n                        householderVectors[i][j] -= f * ort[i];\n                    }\n                }\n\n                for (int i = 0; i <= high; i++) {\n                    double f = 0;\n                    for (int j = high; j >= m; j--) {\n                        f += ort[j] * householderVectors[i][j];\n                    }\n                    f = f / h;\n                    for (int j = m; j <= high; j++) {\n                        householderVectors[i][j] -= f * ort[j];\n                    }\n                }\n\n                ort[m] = scale * ort[m];\n                householderVectors[m][m - 1] = scale * g;\n            }\n        }\n    }",
          "12": "    private void transform() {\n        final int n = householderVectors.length;\n        final int high = n - 1;\n\n        for (int m = 1; m <= high - 1; m++) {\n            // Scale column.\n            double scale = 0;\n            for (int i = m; i <= high; i++) {\n                scale += FastMath.abs(householderVectors[i][m - 1]);\n            }\n\n            if (!Precision.equals(scale, 0)) {\n                // Compute Householder transformation.\n                double h = 0;\n                for (int i = high; i >= m; i--) {\n                    ort[i] = householderVectors[i][m - 1] / scale;\n                    h += ort[i] * ort[i];\n                }\nfinal double g = ((ort[m] > 0))?+FastMath.sqrt(h):FastMath.sqrt(ort);\n\n                h = h - ort[m] * g;\n                ort[m] = ort[m] - g;\n\n                // Apply Householder similarity transformation\n                // H = (I - u*u' / h) * H * (I - u*u' / h)\n\n                for (int j = m; j < n; j++) {\n                    double f = 0;\n                    for (int i = high; i >= m; i--) {\n                        f += ort[i] * householderVectors[i][j];\n                    }\n                    f = f / h;\n                    for (int i = m; i <= high; i++) {\n                        householderVectors[i][j] -= f * ort[i];\n                    }\n                }\n\n                for (int i = 0; i <= high; i++) {\n                    double f = 0;\n                    for (int j = high; j >= m; j--) {\n                        f += ort[j] * householderVectors[i][j];\n                    }\n                    f = f / h;\n                    for (int j = m; j <= high; j++) {\n                        householderVectors[i][j] -= f * ort[j];\n                    }\n                }\n\n                ort[m] = scale * ort[m];\n                householderVectors[m][m - 1] = scale * g;\n            }\n        }\n    }",
          "13": "    private void transform() {\n        final int n = householderVectors.length;\n        final int high = n - 1;\n\n        for (int m = 1; m <= high - 1; m++) {\n            // Scale column.\n            double scale = 0;\n            for (int i = m; i <= high; i++) {\n                scale += FastMath.abs(householderVectors[i][m - 1]);\n            }\n\n            if (!Precision.equals(scale, 0)) {\n                // Compute Householder transformation.\n                double h = 0;\n                for (int i = high; i >= m; i--) {\n                    ort[i] = householderVectors[i][m - 1] / scale;\n                    h += ort[i] * ort[i];\n                }\nfinal double g = ((ort[m] > 0))?+FastMath.sqrt(h):FastMath.transform(h);\n\n                h = h - ort[m] * g;\n                ort[m] = ort[m] - g;\n\n                // Apply Householder similarity transformation\n                // H = (I - u*u' / h) * H * (I - u*u' / h)\n\n                for (int j = m; j < n; j++) {\n                    double f = 0;\n                    for (int i = high; i >= m; i--) {\n                        f += ort[i] * householderVectors[i][j];\n                    }\n                    f = f / h;\n                    for (int i = m; i <= high; i++) {\n                        householderVectors[i][j] -= f * ort[i];\n                    }\n                }\n\n                for (int i = 0; i <= high; i++) {\n                    double f = 0;\n                    for (int j = high; j >= m; j--) {\n                        f += ort[j] * householderVectors[i][j];\n                    }\n                    f = f / h;\n                    for (int j = m; j <= high; j++) {\n                        householderVectors[i][j] -= f * ort[j];\n                    }\n                }\n\n                ort[m] = scale * ort[m];\n                householderVectors[m][m - 1] = scale * g;\n            }\n        }\n    }",
          "14": "    private void transform() {\n        final int n = householderVectors.length;\n        final int high = n - 1;\n\n        for (int m = 1; m <= high - 1; m++) {\n            // Scale column.\n            double scale = 0;\n            for (int i = m; i <= high; i++) {\n                scale += FastMath.abs(householderVectors[i][m - 1]);\n            }\n\n            if (!Precision.equals(scale, 0)) {\n                // Compute Householder transformation.\n                double h = 0;\n                for (int i = high; i >= m; i--) {\n                    ort[i] = householderVectors[i][m - 1] / scale;\n                    h += ort[i] * ort[i];\n                }\nfinal double g = ((ort[m] > 0))?+FastMath.sqrt(h):FastMath.sqrt();\n\n                h = h - ort[m] * g;\n                ort[m] = ort[m] - g;\n\n                // Apply Householder similarity transformation\n                // H = (I - u*u' / h) * H * (I - u*u' / h)\n\n                for (int j = m; j < n; j++) {\n                    double f = 0;\n                    for (int i = high; i >= m; i--) {\n                        f += ort[i] * householderVectors[i][j];\n                    }\n                    f = f / h;\n                    for (int i = m; i <= high; i++) {\n                        householderVectors[i][j] -= f * ort[i];\n                    }\n                }\n\n                for (int i = 0; i <= high; i++) {\n                    double f = 0;\n                    for (int j = high; j >= m; j--) {\n                        f += ort[j] * householderVectors[i][j];\n                    }\n                    f = f / h;\n                    for (int j = m; j <= high; j++) {\n                        householderVectors[i][j] -= f * ort[j];\n                    }\n                }\n\n                ort[m] = scale * ort[m];\n                householderVectors[m][m - 1] = scale * g;\n            }\n        }\n    }",
          "15": "    private void transform() {\n        final int n = householderVectors.length;\n        final int high = n - 1;\n\n        for (int m = 1; m <= high - 1; m++) {\n            // Scale column.\n            double scale = 0;\n            for (int i = m; i <= high; i++) {\n                scale += FastMath.abs(householderVectors[i][m - 1]);\n            }\n\n            if (!Precision.equals(scale, 0)) {\n                // Compute Householder transformation.\n                double h = 0;\n                for (int i = high; i >= m; i--) {\n                    ort[i] = householderVectors[i][m - 1] / scale;\n                    h += ort[i] * ort[i];\n                }\nfinal double g = ((ort[m] > 0))?+FastMath.sqrt(h):FastMath.sqrt();\n\n                h = h - ort[m] * g;\n                ort[m] = ort[m] - g;\n\n                // Apply Householder similarity transformation\n                // H = (I - u*u' / h) * H * (I - u*u' / h)\n\n                for (int j = m; j < n; j++) {\n                    double f = 0;\n                    for (int i = high; i >= m; i--) {\n                        f += ort[i] * householderVectors[i][j];\n                    }\n                    f = f / h;\n                    for (int i = m; i <= high; i++) {\n                        householderVectors[i][j] -= f * ort[i];\n                    }\n                }\n\n                for (int i = 0; i <= high; i++) {\n                    double f = 0;\n                    for (int j = high; j >= m; j--) {\n                        f += ort[j] * householderVectors[i][j];\n                    }\n                    f = f / h;\n                    for (int j = m; j <= high; j++) {\n                        householderVectors[i][j] -= f * ort[j];\n                    }\n                }\n\n                ort[m] = scale * ort[m];\n                householderVectors[m][m - 1] = scale * g;\n            }\n        }\n    }",
          "16": "    private void transform() {\n        final int n = householderVectors.length;\n        final int high = n - 1;\n\n        for (int m = 1; m <= high - 1; m++) {\n            // Scale column.\n            double scale = 0;\n            for (int i = m; i <= high; i++) {\n                scale += FastMath.abs(householderVectors[i][m - 1]);\n            }\n\n            if (!Precision.equals(scale, 0)) {\n                // Compute Householder transformation.\n                double h = 0;\n                for (int i = high; i >= m; i--) {\n                    ort[i] = householderVectors[i][m - 1] / scale;\n                    h += ort[i] * ort[i];\n                }\nfinal double g = (( > 0))?+FastMath.sqrt(h):FastMath.sqrt(h);\n\n                h = h - ort[m] * g;\n                ort[m] = ort[m] - g;\n\n                // Apply Householder similarity transformation\n                // H = (I - u*u' / h) * H * (I - u*u' / h)\n\n                for (int j = m; j < n; j++) {\n                    double f = 0;\n                    for (int i = high; i >= m; i--) {\n                        f += ort[i] * householderVectors[i][j];\n                    }\n                    f = f / h;\n                    for (int i = m; i <= high; i++) {\n                        householderVectors[i][j] -= f * ort[i];\n                    }\n                }\n\n                for (int i = 0; i <= high; i++) {\n                    double f = 0;\n                    for (int j = high; j >= m; j--) {\n                        f += ort[j] * householderVectors[i][j];\n                    }\n                    f = f / h;\n                    for (int j = m; j <= high; j++) {\n                        householderVectors[i][j] -= f * ort[j];\n                    }\n                }\n\n                ort[m] = scale * ort[m];\n                householderVectors[m][m - 1] = scale * g;\n            }\n        }\n    }",
          "17": "    private void transform() {\n        final int n = householderVectors.length;\n        final int high = n - 1;\n\n        for (int m = 1; m <= high - 1; m++) {\n            // Scale column.\n            double scale = 0;\n            for (int i = m; i <= high; i++) {\n                scale += FastMath.abs(householderVectors[i][m - 1]);\n            }\n\n            if (!Precision.equals(scale, 0)) {\n                // Compute Householder transformation.\n                double h = 0;\n                for (int i = high; i >= m; i--) {\n                    ort[i] = householderVectors[i][m - 1] / scale;\n                    h += ort[i] * ort[i];\n                }\nfinal double g = ((h > 0))?+FastMath.sqrt(h):FastMath.sqrt(h);\n\n                h = h - ort[m] * g;\n                ort[m] = ort[m] - g;\n\n                // Apply Householder similarity transformation\n                // H = (I - u*u' / h) * H * (I - u*u' / h)\n\n                for (int j = m; j < n; j++) {\n                    double f = 0;\n                    for (int i = high; i >= m; i--) {\n                        f += ort[i] * householderVectors[i][j];\n                    }\n                    f = f / h;\n                    for (int i = m; i <= high; i++) {\n                        householderVectors[i][j] -= f * ort[i];\n                    }\n                }\n\n                for (int i = 0; i <= high; i++) {\n                    double f = 0;\n                    for (int j = high; j >= m; j--) {\n                        f += ort[j] * householderVectors[i][j];\n                    }\n                    f = f / h;\n                    for (int j = m; j <= high; j++) {\n                        householderVectors[i][j] -= f * ort[j];\n                    }\n                }\n\n                ort[m] = scale * ort[m];\n                householderVectors[m][m - 1] = scale * g;\n            }\n        }\n    }",
          "18": "    private void transform() {\n        final int n = householderVectors.length;\n        final int high = n - 1;\n\n        for (int m = 1; m <= high - 1; m++) {\n            // Scale column.\n            double scale = 0;\n            for (int i = m; i <= high; i++) {\n                scale += FastMath.abs(householderVectors[i][m - 1]);\n            }\n\n            if (!Precision.equals(scale, 0)) {\n                // Compute Householder transformation.\n                double h = 0;\n                for (int i = high; i >= m; i--) {\n                    ort[i] = householderVectors[i][m - 1] / scale;\n                    h += ort[i] * ort[i];\n                }\nfinal double g = ((ort[m] - 0))?+FastMath.sqrt(h):FastMath.sqrt(h);\n\n                h = h - ort[m] * g;\n                ort[m] = ort[m] - g;\n\n                // Apply Householder similarity transformation\n                // H = (I - u*u' / h) * H * (I - u*u' / h)\n\n                for (int j = m; j < n; j++) {\n                    double f = 0;\n                    for (int i = high; i >= m; i--) {\n                        f += ort[i] * householderVectors[i][j];\n                    }\n                    f = f / h;\n                    for (int i = m; i <= high; i++) {\n                        householderVectors[i][j] -= f * ort[i];\n                    }\n                }\n\n                for (int i = 0; i <= high; i++) {\n                    double f = 0;\n                    for (int j = high; j >= m; j--) {\n                        f += ort[j] * householderVectors[i][j];\n                    }\n                    f = f / h;\n                    for (int j = m; j <= high; j++) {\n                        householderVectors[i][j] -= f * ort[j];\n                    }\n                }\n\n                ort[m] = scale * ort[m];\n                householderVectors[m][m - 1] = scale * g;\n            }\n        }\n    }",
          "19": "    private void transform() {\n        final int n = householderVectors.length;\n        final int high = n - 1;\n\n        for (int m = 1; m <= high - 1; m++) {\n            // Scale column.\n            double scale = 0;\n            for (int i = m; i <= high; i++) {\n                scale += FastMath.abs(householderVectors[i][m - 1]);\n            }\n\n            if (!Precision.equals(scale, 0)) {\n                // Compute Householder transformation.\n                double h = 0;\n                for (int i = high; i >= m; i--) {\n                    ort[i] = householderVectors[i][m - 1] / scale;\n                    h += ort[i] * ort[i];\n                }\nfinal double g = ((ort[m] < 0))?+FastMath.sqrt(h):FastMath.sqrt(h);\n\n                h = h - ort[m] * g;\n                ort[m] = ort[m] - g;\n\n                // Apply Householder similarity transformation\n                // H = (I - u*u' / h) * H * (I - u*u' / h)\n\n                for (int j = m; j < n; j++) {\n                    double f = 0;\n                    for (int i = high; i >= m; i--) {\n                        f += ort[i] * householderVectors[i][j];\n                    }\n                    f = f / h;\n                    for (int i = m; i <= high; i++) {\n                        householderVectors[i][j] -= f * ort[i];\n                    }\n                }\n\n                for (int i = 0; i <= high; i++) {\n                    double f = 0;\n                    for (int j = high; j >= m; j--) {\n                        f += ort[j] * householderVectors[i][j];\n                    }\n                    f = f / h;\n                    for (int j = m; j <= high; j++) {\n                        householderVectors[i][j] -= f * ort[j];\n                    }\n                }\n\n                ort[m] = scale * ort[m];\n                householderVectors[m][m - 1] = scale * g;\n            }\n        }\n    }",
          "20": "    private void transform() {\n        final int n = householderVectors.length;\n        final int high = n - 1;\n\n        for (int m = 1; m <= high - 1; m++) {\n            // Scale column.\n            double scale = 0;\n            for (int i = m; i <= high; i++) {\n                scale += FastMath.abs(householderVectors[i][m - 1]);\n            }\n\n            if (!Precision.equals(scale, 0)) {\n                // Compute Householder transformation.\n                double h = 0;\n                for (int i = high; i >= m; i--) {\n                    ort[i] = householderVectors[i][m - 1] / scale;\n                    h += ort[i] * ort[i];\n                }\nfinal double g = (double)FastMath.sqrt(h);\n\n                h = h - ort[m] * g;\n                ort[m] = ort[m] - g;\n\n                // Apply Householder similarity transformation\n                // H = (I - u*u' / h) * H * (I - u*u' / h)\n\n                for (int j = m; j < n; j++) {\n                    double f = 0;\n                    for (int i = high; i >= m; i--) {\n                        f += ort[i] * householderVectors[i][j];\n                    }\n                    f = f / h;\n                    for (int i = m; i <= high; i++) {\n                        householderVectors[i][j] -= f * ort[i];\n                    }\n                }\n\n                for (int i = 0; i <= high; i++) {\n                    double f = 0;\n                    for (int j = high; j >= m; j--) {\n                        f += ort[j] * householderVectors[i][j];\n                    }\n                    f = f / h;\n                    for (int j = m; j <= high; j++) {\n                        householderVectors[i][j] -= f * ort[j];\n                    }\n                }\n\n                ort[m] = scale * ort[m];\n                householderVectors[m][m - 1] = scale * g;\n            }\n        }\n    }",
          "21": "    private void transform() {\n        final int n = householderVectors.length;\n        final int high = n - 1;\n\n        for (int m = 1; m <= high - 1; m++) {\n            // Scale column.\n            double scale = 0;\n            for (int i = m; i <= high; i++) {\n                scale += FastMath.abs(householderVectors[i][m - 1]);\n            }\n\n            if (!Precision.equals(scale, 0)) {\n                // Compute Householder transformation.\n                double h = 0;\n                for (int i = high; i >= m; i--) {\n                    ort[i] = householderVectors[i][m - 1] / scale;\n                    h += ort[i] * ort[i];\n                }\nfinal double g = ((ort[m] > 0))?+FastMath.sqrt(h):FastMath.get(h);\n\n                h = h - ort[m] * g;\n                ort[m] = ort[m] - g;\n\n                // Apply Householder similarity transformation\n                // H = (I - u*u' / h) * H * (I - u*u' / h)\n\n                for (int j = m; j < n; j++) {\n                    double f = 0;\n                    for (int i = high; i >= m; i--) {\n                        f += ort[i] * householderVectors[i][j];\n                    }\n                    f = f / h;\n                    for (int i = m; i <= high; i++) {\n                        householderVectors[i][j] -= f * ort[i];\n                    }\n                }\n\n                for (int i = 0; i <= high; i++) {\n                    double f = 0;\n                    for (int j = high; j >= m; j--) {\n                        f += ort[j] * householderVectors[i][j];\n                    }\n                    f = f / h;\n                    for (int j = m; j <= high; j++) {\n                        householderVectors[i][j] -= f * ort[j];\n                    }\n                }\n\n                ort[m] = scale * ort[m];\n                householderVectors[m][m - 1] = scale * g;\n            }\n        }\n    }",
          "22": "    private void transform() {\n        final int n = householderVectors.length;\n        final int high = n - 1;\n\n        for (int m = 1; m <= high - 1; m++) {\n            // Scale column.\n            double scale = 0;\n            for (int i = m; i <= high; i++) {\n                scale += FastMath.abs(householderVectors[i][m - 1]);\n            }\n\n            if (!Precision.equals(scale, 0)) {\n                // Compute Householder transformation.\n                double h = 0;\n                for (int i = high; i >= m; i--) {\n                    ort[i] = householderVectors[i][m - 1] / scale;\n                    h += ort[i] * ort[i];\n                }\nfinal double g = (double)+FastMath.sqrt(h);\n\n                h = h - ort[m] * g;\n                ort[m] = ort[m] - g;\n\n                // Apply Householder similarity transformation\n                // H = (I - u*u' / h) * H * (I - u*u' / h)\n\n                for (int j = m; j < n; j++) {\n                    double f = 0;\n                    for (int i = high; i >= m; i--) {\n                        f += ort[i] * householderVectors[i][j];\n                    }\n                    f = f / h;\n                    for (int i = m; i <= high; i++) {\n                        householderVectors[i][j] -= f * ort[i];\n                    }\n                }\n\n                for (int i = 0; i <= high; i++) {\n                    double f = 0;\n                    for (int j = high; j >= m; j--) {\n                        f += ort[j] * householderVectors[i][j];\n                    }\n                    f = f / h;\n                    for (int j = m; j <= high; j++) {\n                        householderVectors[i][j] -= f * ort[j];\n                    }\n                }\n\n                ort[m] = scale * ort[m];\n                householderVectors[m][m - 1] = scale * g;\n            }\n        }\n    }",
          "23": "    private void transform() {\n        final int n = householderVectors.length;\n        final int high = n - 1;\n\n        for (int m = 1; m <= high - 1; m++) {\n            // Scale column.\n            double scale = 0;\n            for (int i = m; i <= high; i++) {\n                scale += FastMath.abs(householderVectors[i][m - 1]);\n            }\n\n            if (!Precision.equals(scale, 0)) {\n                // Compute Householder transformation.\n                double h = 0;\n                for (int i = high; i >= m; i--) {\n                    ort[i] = householderVectors[i][m - 1] / scale;\n                    h += ort[i] * ort[i];\n                }\nfinal double g = (ort[m] > 0);\n\n                h = h - ort[m] * g;\n                ort[m] = ort[m] - g;\n\n                // Apply Householder similarity transformation\n                // H = (I - u*u' / h) * H * (I - u*u' / h)\n\n                for (int j = m; j < n; j++) {\n                    double f = 0;\n                    for (int i = high; i >= m; i--) {\n                        f += ort[i] * householderVectors[i][j];\n                    }\n                    f = f / h;\n                    for (int i = m; i <= high; i++) {\n                        householderVectors[i][j] -= f * ort[i];\n                    }\n                }\n\n                for (int i = 0; i <= high; i++) {\n                    double f = 0;\n                    for (int j = high; j >= m; j--) {\n                        f += ort[j] * householderVectors[i][j];\n                    }\n                    f = f / h;\n                    for (int j = m; j <= high; j++) {\n                        householderVectors[i][j] -= f * ort[j];\n                    }\n                }\n\n                ort[m] = scale * ort[m];\n                householderVectors[m][m - 1] = scale * g;\n            }\n        }\n    }",
          "24": "    private void transform() {\n        final int n = householderVectors.length;\n        final int high = n - 1;\n\n        for (int m = 1; m <= high - 1; m++) {\n            // Scale column.\n            double scale = 0;\n            for (int i = m; i <= high; i++) {\n                scale += FastMath.abs(householderVectors[i][m - 1]);\n            }\n\n            if (!Precision.equals(scale, 0)) {\n                // Compute Householder transformation.\n                double h = 0;\n                for (int i = high; i >= m; i--) {\n                    ort[i] = householderVectors[i][m - 1] / scale;\n                    h += ort[i] * ort[i];\n                }\nfinal double g = ((ort[m] > 0))?+FastMath.sqrt(h):FastMath.ort(h);\n\n                h = h - ort[m] * g;\n                ort[m] = ort[m] - g;\n\n                // Apply Householder similarity transformation\n                // H = (I - u*u' / h) * H * (I - u*u' / h)\n\n                for (int j = m; j < n; j++) {\n                    double f = 0;\n                    for (int i = high; i >= m; i--) {\n                        f += ort[i] * householderVectors[i][j];\n                    }\n                    f = f / h;\n                    for (int i = m; i <= high; i++) {\n                        householderVectors[i][j] -= f * ort[i];\n                    }\n                }\n\n                for (int i = 0; i <= high; i++) {\n                    double f = 0;\n                    for (int j = high; j >= m; j--) {\n                        f += ort[j] * householderVectors[i][j];\n                    }\n                    f = f / h;\n                    for (int j = m; j <= high; j++) {\n                        householderVectors[i][j] -= f * ort[j];\n                    }\n                }\n\n                ort[m] = scale * ort[m];\n                householderVectors[m][m - 1] = scale * g;\n            }\n        }\n    }",
          "25": "    private void transform() {\n        final int n = householderVectors.length;\n        final int high = n - 1;\n\n        for (int m = 1; m <= high - 1; m++) {\n            // Scale column.\n            double scale = 0;\n            for (int i = m; i <= high; i++) {\n                scale += FastMath.abs(householderVectors[i][m - 1]);\n            }\n\n            if (!Precision.equals(scale, 0)) {\n                // Compute Householder transformation.\n                double h = 0;\n                for (int i = high; i >= m; i--) {\n                    ort[i] = householderVectors[i][m - 1] / scale;\n                    h += ort[i] * ort[i];\n                }\nfinal double g = ((ort[m] > 0))?+FastMath.sqrt(h):+FastMath.sqrt(h);\n\n                h = h - ort[m] * g;\n                ort[m] = ort[m] - g;\n\n                // Apply Householder similarity transformation\n                // H = (I - u*u' / h) * H * (I - u*u' / h)\n\n                for (int j = m; j < n; j++) {\n                    double f = 0;\n                    for (int i = high; i >= m; i--) {\n                        f += ort[i] * householderVectors[i][j];\n                    }\n                    f = f / h;\n                    for (int i = m; i <= high; i++) {\n                        householderVectors[i][j] -= f * ort[i];\n                    }\n                }\n\n                for (int i = 0; i <= high; i++) {\n                    double f = 0;\n                    for (int j = high; j >= m; j--) {\n                        f += ort[j] * householderVectors[i][j];\n                    }\n                    f = f / h;\n                    for (int j = m; j <= high; j++) {\n                        householderVectors[i][j] -= f * ort[j];\n                    }\n                }\n\n                ort[m] = scale * ort[m];\n                householderVectors[m][m - 1] = scale * g;\n            }\n        }\n    }",
          "26": "    private void transform() {\n        final int n = householderVectors.length;\n        final int high = n - 1;\n\n        for (int m = 1; m <= high - 1; m++) {\n            // Scale column.\n            double scale = 0;\n            for (int i = m; i <= high; i++) {\n                scale += FastMath.abs(householderVectors[i][m - 1]);\n            }\n\n            if (!Precision.equals(scale, 0)) {\n                // Compute Householder transformation.\n                double h = 0;\n                for (int i = high; i >= m; i--) {\n                    ort[i] = householderVectors[i][m - 1] / scale;\n                    h += ort[i] * ort[i];\n                }\nfinal double g = ((ort[m] > 0))?+FastMath.sqrt(h):(ort[m] > 0);\n\n                h = h - ort[m] * g;\n                ort[m] = ort[m] - g;\n\n                // Apply Householder similarity transformation\n                // H = (I - u*u' / h) * H * (I - u*u' / h)\n\n                for (int j = m; j < n; j++) {\n                    double f = 0;\n                    for (int i = high; i >= m; i--) {\n                        f += ort[i] * householderVectors[i][j];\n                    }\n                    f = f / h;\n                    for (int i = m; i <= high; i++) {\n                        householderVectors[i][j] -= f * ort[i];\n                    }\n                }\n\n                for (int i = 0; i <= high; i++) {\n                    double f = 0;\n                    for (int j = high; j >= m; j--) {\n                        f += ort[j] * householderVectors[i][j];\n                    }\n                    f = f / h;\n                    for (int j = m; j <= high; j++) {\n                        householderVectors[i][j] -= f * ort[j];\n                    }\n                }\n\n                ort[m] = scale * ort[m];\n                householderVectors[m][m - 1] = scale * g;\n            }\n        }\n    }",
          "27": "    private void transform() {\n        final int n = householderVectors.length;\n        final int high = n - 1;\n\n        for (int m = 1; m <= high - 1; m++) {\n            // Scale column.\n            double scale = 0;\n            for (int i = m; i <= high; i++) {\n                scale += FastMath.abs(householderVectors[i][m - 1]);\n            }\n\n            if (!Precision.equals(scale, 0)) {\n                // Compute Householder transformation.\n                double h = 0;\n                for (int i = high; i >= m; i--) {\n                    ort[i] = householderVectors[i][m - 1] / scale;\n                    h += ort[i] * ort[i];\n                }\nfinal double g = ((ort[m] == 0))?+FastMath.sqrt(h):FastMath.sqrt(h);\n\n                h = h - ort[m] * g;\n                ort[m] = ort[m] - g;\n\n                // Apply Householder similarity transformation\n                // H = (I - u*u' / h) * H * (I - u*u' / h)\n\n                for (int j = m; j < n; j++) {\n                    double f = 0;\n                    for (int i = high; i >= m; i--) {\n                        f += ort[i] * householderVectors[i][j];\n                    }\n                    f = f / h;\n                    for (int i = m; i <= high; i++) {\n                        householderVectors[i][j] -= f * ort[i];\n                    }\n                }\n\n                for (int i = 0; i <= high; i++) {\n                    double f = 0;\n                    for (int j = high; j >= m; j--) {\n                        f += ort[j] * householderVectors[i][j];\n                    }\n                    f = f / h;\n                    for (int j = m; j <= high; j++) {\n                        householderVectors[i][j] -= f * ort[j];\n                    }\n                }\n\n                ort[m] = scale * ort[m];\n                householderVectors[m][m - 1] = scale * g;\n            }\n        }\n    }",
          "28": "    private void transform() {\n        final int n = householderVectors.length;\n        final int high = n - 1;\n\n        for (int m = 1; m <= high - 1; m++) {\n            // Scale column.\n            double scale = 0;\n            for (int i = m; i <= high; i++) {\n                scale += FastMath.abs(householderVectors[i][m - 1]);\n            }\n\n            if (!Precision.equals(scale, 0)) {\n                // Compute Householder transformation.\n                double h = 0;\n                for (int i = high; i >= m; i--) {\n                    ort[i] = householderVectors[i][m - 1] / scale;\n                    h += ort[i] * ort[i];\n                }\nfinal double g = ((ort[m] > 0))?+FastMath.sqrt(h):FastMath.debug(h);\n\n                h = h - ort[m] * g;\n                ort[m] = ort[m] - g;\n\n                // Apply Householder similarity transformation\n                // H = (I - u*u' / h) * H * (I - u*u' / h)\n\n                for (int j = m; j < n; j++) {\n                    double f = 0;\n                    for (int i = high; i >= m; i--) {\n                        f += ort[i] * householderVectors[i][j];\n                    }\n                    f = f / h;\n                    for (int i = m; i <= high; i++) {\n                        householderVectors[i][j] -= f * ort[i];\n                    }\n                }\n\n                for (int i = 0; i <= high; i++) {\n                    double f = 0;\n                    for (int j = high; j >= m; j--) {\n                        f += ort[j] * householderVectors[i][j];\n                    }\n                    f = f / h;\n                    for (int j = m; j <= high; j++) {\n                        householderVectors[i][j] -= f * ort[j];\n                    }\n                }\n\n                ort[m] = scale * ort[m];\n                householderVectors[m][m - 1] = scale * g;\n            }\n        }\n    }",
          "29": "    private void transform() {\n        final int n = householderVectors.length;\n        final int high = n - 1;\n\n        for (int m = 1; m <= high - 1; m++) {\n            // Scale column.\n            double scale = 0;\n            for (int i = m; i <= high; i++) {\n                scale += FastMath.abs(householderVectors[i][m - 1]);\n            }\n\n            if (!Precision.equals(scale, 0)) {\n                // Compute Householder transformation.\n                double h = 0;\n                for (int i = high; i >= m; i--) {\n                    ort[i] = householderVectors[i][m - 1] / scale;\n                    h += ort[i] * ort[i];\n                }\nfinal double g = ((ort[m] > 0))?+FastMath.sqrt(h):FastMath.getName(h);\n\n                h = h - ort[m] * g;\n                ort[m] = ort[m] - g;\n\n                // Apply Householder similarity transformation\n                // H = (I - u*u' / h) * H * (I - u*u' / h)\n\n                for (int j = m; j < n; j++) {\n                    double f = 0;\n                    for (int i = high; i >= m; i--) {\n                        f += ort[i] * householderVectors[i][j];\n                    }\n                    f = f / h;\n                    for (int i = m; i <= high; i++) {\n                        householderVectors[i][j] -= f * ort[i];\n                    }\n                }\n\n                for (int i = 0; i <= high; i++) {\n                    double f = 0;\n                    for (int j = high; j >= m; j--) {\n                        f += ort[j] * householderVectors[i][j];\n                    }\n                    f = f / h;\n                    for (int j = m; j <= high; j++) {\n                        householderVectors[i][j] -= f * ort[j];\n                    }\n                }\n\n                ort[m] = scale * ort[m];\n                householderVectors[m][m - 1] = scale * g;\n            }\n        }\n    }",
          "30": "    private void transform() {\n        final int n = householderVectors.length;\n        final int high = n - 1;\n\n        for (int m = 1; m <= high - 1; m++) {\n            // Scale column.\n            double scale = 0;\n            for (int i = m; i <= high; i++) {\n                scale += FastMath.abs(householderVectors[i][m - 1]);\n            }\n\n            if (!Precision.equals(scale, 0)) {\n                // Compute Householder transformation.\n                double h = 0;\n                for (int i = high; i >= m; i--) {\n                    ort[i] = householderVectors[i][m - 1] / scale;\n                    h += ort[i] * ort[i];\n                }\nfinal double g = ((ort[m] > 0))?FastMath.sqrt(h):FastMath.sqrt(h);\n\n                h = h - ort[m] * g;\n                ort[m] = ort[m] - g;\n\n                // Apply Householder similarity transformation\n                // H = (I - u*u' / h) * H * (I - u*u' / h)\n\n                for (int j = m; j < n; j++) {\n                    double f = 0;\n                    for (int i = high; i >= m; i--) {\n                        f += ort[i] * householderVectors[i][j];\n                    }\n                    f = f / h;\n                    for (int i = m; i <= high; i++) {\n                        householderVectors[i][j] -= f * ort[i];\n                    }\n                }\n\n                for (int i = 0; i <= high; i++) {\n                    double f = 0;\n                    for (int j = high; j >= m; j--) {\n                        f += ort[j] * householderVectors[i][j];\n                    }\n                    f = f / h;\n                    for (int j = m; j <= high; j++) {\n                        householderVectors[i][j] -= f * ort[j];\n                    }\n                }\n\n                ort[m] = scale * ort[m];\n                householderVectors[m][m - 1] = scale * g;\n            }\n        }\n    }",
          "31": "    private void transform() {\n        final int n = householderVectors.length;\n        final int high = n - 1;\n\n        for (int m = 1; m <= high - 1; m++) {\n            // Scale column.\n            double scale = 0;\n            for (int i = m; i <= high; i++) {\n                scale += FastMath.abs(householderVectors[i][m - 1]);\n            }\n\n            if (!Precision.equals(scale, 0)) {\n                // Compute Householder transformation.\n                double h = 0;\n                for (int i = high; i >= m; i--) {\n                    ort[i] = householderVectors[i][m - 1] / scale;\n                    h += ort[i] * ort[i];\n                }\nfinal double g = (double)(ort[m] > 0);\n\n                h = h - ort[m] * g;\n                ort[m] = ort[m] - g;\n\n                // Apply Householder similarity transformation\n                // H = (I - u*u' / h) * H * (I - u*u' / h)\n\n                for (int j = m; j < n; j++) {\n                    double f = 0;\n                    for (int i = high; i >= m; i--) {\n                        f += ort[i] * householderVectors[i][j];\n                    }\n                    f = f / h;\n                    for (int i = m; i <= high; i++) {\n                        householderVectors[i][j] -= f * ort[i];\n                    }\n                }\n\n                for (int i = 0; i <= high; i++) {\n                    double f = 0;\n                    for (int j = high; j >= m; j--) {\n                        f += ort[j] * householderVectors[i][j];\n                    }\n                    f = f / h;\n                    for (int j = m; j <= high; j++) {\n                        householderVectors[i][j] -= f * ort[j];\n                    }\n                }\n\n                ort[m] = scale * ort[m];\n                householderVectors[m][m - 1] = scale * g;\n            }\n        }\n    }",
          "32": "    private void transform() {\n        final int n = householderVectors.length;\n        final int high = n - 1;\n\n        for (int m = 1; m <= high - 1; m++) {\n            // Scale column.\n            double scale = 0;\n            for (int i = m; i <= high; i++) {\n                scale += FastMath.abs(householderVectors[i][m - 1]);\n            }\n\n            if (!Precision.equals(scale, 0)) {\n                // Compute Householder transformation.\n                double h = 0;\n                for (int i = high; i >= m; i--) {\n                    ort[i] = householderVectors[i][m - 1] / scale;\n                    h += ort[i] * ort[i];\n                }\nreturn;\n                final double g = (ort[m] > 0) ? +FastMath.sqrt(h) : FastMath.sqrt(h);\n                h = h - ort[m] * g;\n                ort[m] = ort[m] - g;\n\n                // Apply Householder similarity transformation\n                // H = (I - u*u' / h) * H * (I - u*u' / h)\n\n                for (int j = m; j < n; j++) {\n                    double f = 0;\n                    for (int i = high; i >= m; i--) {\n                        f += ort[i] * householderVectors[i][j];\n                    }\n                    f = f / h;\n                    for (int i = m; i <= high; i++) {\n                        householderVectors[i][j] -= f * ort[i];\n                    }\n                }\n\n                for (int i = 0; i <= high; i++) {\n                    double f = 0;\n                    for (int j = high; j >= m; j--) {\n                        f += ort[j] * householderVectors[i][j];\n                    }\n                    f = f / h;\n                    for (int j = m; j <= high; j++) {\n                        householderVectors[i][j] -= f * ort[j];\n                    }\n                }\n\n                ort[m] = scale * ort[m];\n                householderVectors[m][m - 1] = scale * g;\n            }\n        }\n    }",
          "33": "    private void transform() {\n        final int n = householderVectors.length;\n        final int high = n - 1;\n\n        for (int m = 1; m <= high - 1; m++) {\n            // Scale column.\n            double scale = 0;\n            for (int i = m; i <= high; i++) {\n                scale += FastMath.abs(householderVectors[i][m - 1]);\n            }\n\n            if (!Precision.equals(scale, 0)) {\n                // Compute Householder transformation.\n                double h = 0;\n                for (int i = high; i >= m; i--) {\n                    ort[i] = householderVectors[i][m - 1] / scale;\n                    h += ort[i] * ort[i];\n                }\nbreak;\n                final double g = (ort[m] > 0) ? +FastMath.sqrt(h) : FastMath.sqrt(h);\n                h = h - ort[m] * g;\n                ort[m] = ort[m] - g;\n\n                // Apply Householder similarity transformation\n                // H = (I - u*u' / h) * H * (I - u*u' / h)\n\n                for (int j = m; j < n; j++) {\n                    double f = 0;\n                    for (int i = high; i >= m; i--) {\n                        f += ort[i] * householderVectors[i][j];\n                    }\n                    f = f / h;\n                    for (int i = m; i <= high; i++) {\n                        householderVectors[i][j] -= f * ort[i];\n                    }\n                }\n\n                for (int i = 0; i <= high; i++) {\n                    double f = 0;\n                    for (int j = high; j >= m; j--) {\n                        f += ort[j] * householderVectors[i][j];\n                    }\n                    f = f / h;\n                    for (int j = m; j <= high; j++) {\n                        householderVectors[i][j] -= f * ort[j];\n                    }\n                }\n\n                ort[m] = scale * ort[m];\n                householderVectors[m][m - 1] = scale * g;\n            }\n        }\n    }",
          "34": "    private void transform() {\n        final int n = householderVectors.length;\n        final int high = n - 1;\n\n        for (int m = 1; m <= high - 1; m++) {\n            // Scale column.\n            double scale = 0;\n            for (int i = m; i <= high; i++) {\n                scale += FastMath.abs(householderVectors[i][m - 1]);\n            }\n\n            if (!Precision.equals(scale, 0)) {\n                // Compute Householder transformation.\n                double h = 0;\n                for (int i = high; i >= m; i--) {\n                    ort[i] = householderVectors[i][m - 1] / scale;\n                    h += ort[i] * ort[i];\n                }\ncontinue;\n                final double g = (ort[m] > 0) ? +FastMath.sqrt(h) : FastMath.sqrt(h);\n                h = h - ort[m] * g;\n                ort[m] = ort[m] - g;\n\n                // Apply Householder similarity transformation\n                // H = (I - u*u' / h) * H * (I - u*u' / h)\n\n                for (int j = m; j < n; j++) {\n                    double f = 0;\n                    for (int i = high; i >= m; i--) {\n                        f += ort[i] * householderVectors[i][j];\n                    }\n                    f = f / h;\n                    for (int i = m; i <= high; i++) {\n                        householderVectors[i][j] -= f * ort[i];\n                    }\n                }\n\n                for (int i = 0; i <= high; i++) {\n                    double f = 0;\n                    for (int j = high; j >= m; j--) {\n                        f += ort[j] * householderVectors[i][j];\n                    }\n                    f = f / h;\n                    for (int j = m; j <= high; j++) {\n                        householderVectors[i][j] -= f * ort[j];\n                    }\n                }\n\n                ort[m] = scale * ort[m];\n                householderVectors[m][m - 1] = scale * g;\n            }\n        }\n    }",
          "35": "    private void transform() {\n        final int n = householderVectors.length;\n        final int high = n - 1;\n\n        for (int m = 1; m <= high - 1; m++) {\n            // Scale column.\n            double scale = 0;\n            for (int i = m; i <= high; i++) {\n                scale += FastMath.abs(householderVectors[i][m - 1]);\n            }\n\n            if (!Precision.equals(scale, 0)) {\n                // Compute Householder transformation.\n                double h = 0;\n                for (int i = high; i >= m; i--) {\n                    ort[i] = householderVectors[i][m - 1] / scale;\n                    h += ort[i] * ort[i];\n                }\nfinal double g = ((ort[m] > 0))?FastMath.sqrt(h[m]):FastMath.sqrt(h);\n\n                h = h - ort[m] * g;\n                ort[m] = ort[m] - g;\n\n                // Apply Householder similarity transformation\n                // H = (I - u*u' / h) * H * (I - u*u' / h)\n\n                for (int j = m; j < n; j++) {\n                    double f = 0;\n                    for (int i = high; i >= m; i--) {\n                        f += ort[i] * householderVectors[i][j];\n                    }\n                    f = f / h;\n                    for (int i = m; i <= high; i++) {\n                        householderVectors[i][j] -= f * ort[i];\n                    }\n                }\n\n                for (int i = 0; i <= high; i++) {\n                    double f = 0;\n                    for (int j = high; j >= m; j--) {\n                        f += ort[j] * householderVectors[i][j];\n                    }\n                    f = f / h;\n                    for (int j = m; j <= high; j++) {\n                        householderVectors[i][j] -= f * ort[j];\n                    }\n                }\n\n                ort[m] = scale * ort[m];\n                householderVectors[m][m - 1] = scale * g;\n            }\n        }\n    }",
          "36": "    private void transform() {\n        final int n = householderVectors.length;\n        final int high = n - 1;\n\n        for (int m = 1; m <= high - 1; m++) {\n            // Scale column.\n            double scale = 0;\n            for (int i = m; i <= high; i++) {\n                scale += FastMath.abs(householderVectors[i][m - 1]);\n            }\n\n            if (!Precision.equals(scale, 0)) {\n                // Compute Householder transformation.\n                double h = 0;\n                for (int i = high; i >= m; i--) {\n                    ort[i] = householderVectors[i][m - 1] / scale;\n                    h += ort[i] * ort[i];\n                }\nfinal double g = ((ort[m] > 0))?+FastMath.sqrt(h):FastMath.sqrt(h[m]);\n\n                h = h - ort[m] * g;\n                ort[m] = ort[m] - g;\n\n                // Apply Householder similarity transformation\n                // H = (I - u*u' / h) * H * (I - u*u' / h)\n\n                for (int j = m; j < n; j++) {\n                    double f = 0;\n                    for (int i = high; i >= m; i--) {\n                        f += ort[i] * householderVectors[i][j];\n                    }\n                    f = f / h;\n                    for (int i = m; i <= high; i++) {\n                        householderVectors[i][j] -= f * ort[i];\n                    }\n                }\n\n                for (int i = 0; i <= high; i++) {\n                    double f = 0;\n                    for (int j = high; j >= m; j--) {\n                        f += ort[j] * householderVectors[i][j];\n                    }\n                    f = f / h;\n                    for (int j = m; j <= high; j++) {\n                        householderVectors[i][j] -= f * ort[j];\n                    }\n                }\n\n                ort[m] = scale * ort[m];\n                householderVectors[m][m - 1] = scale * g;\n            }\n        }\n    }",
          "37": "    private void transform() {\n        final int n = householderVectors.length;\n        final int high = n - 1;\n\n        for (int m = 1; m <= high - 1; m++) {\n            // Scale column.\n            double scale = 0;\n            for (int i = m; i <= high; i++) {\n                scale += FastMath.abs(householderVectors[i][m - 1]);\n            }\n\n            if (!Precision.equals(scale, 0)) {\n                // Compute Householder transformation.\n                double h = 0;\n                for (int i = high; i >= m; i--) {\n                    ort[i] = householderVectors[i][m - 1] / scale;\n                    h += ort[i] * ort[i];\n                }\nfinal double g = ((ort[m] > 0))?FastMath.sqrt(ort[m]):FastMath.sqrt(h);\n\n                h = h - ort[m] * g;\n                ort[m] = ort[m] - g;\n\n                // Apply Householder similarity transformation\n                // H = (I - u*u' / h) * H * (I - u*u' / h)\n\n                for (int j = m; j < n; j++) {\n                    double f = 0;\n                    for (int i = high; i >= m; i--) {\n                        f += ort[i] * householderVectors[i][j];\n                    }\n                    f = f / h;\n                    for (int i = m; i <= high; i++) {\n                        householderVectors[i][j] -= f * ort[i];\n                    }\n                }\n\n                for (int i = 0; i <= high; i++) {\n                    double f = 0;\n                    for (int j = high; j >= m; j--) {\n                        f += ort[j] * householderVectors[i][j];\n                    }\n                    f = f / h;\n                    for (int j = m; j <= high; j++) {\n                        householderVectors[i][j] -= f * ort[j];\n                    }\n                }\n\n                ort[m] = scale * ort[m];\n                householderVectors[m][m - 1] = scale * g;\n            }\n        }\n    }",
          "38": "    private void transform() {\n        final int n = householderVectors.length;\n        final int high = n - 1;\n\n        for (int m = 1; m <= high - 1; m++) {\n            // Scale column.\n            double scale = 0;\n            for (int i = m; i <= high; i++) {\n                scale += FastMath.abs(householderVectors[i][m - 1]);\n            }\n\n            if (!Precision.equals(scale, 0)) {\n                // Compute Householder transformation.\n                double h = 0;\n                for (int i = high; i >= m; i--) {\n                    ort[i] = householderVectors[i][m - 1] / scale;\n                    h += ort[i] * ort[i];\n                }\nfinal double g = ((ort[m] > 0))?(double)FastMath.sqrt(h[m]):FastMath.sqrt(h);\n\n                h = h - ort[m] * g;\n                ort[m] = ort[m] - g;\n\n                // Apply Householder similarity transformation\n                // H = (I - u*u' / h) * H * (I - u*u' / h)\n\n                for (int j = m; j < n; j++) {\n                    double f = 0;\n                    for (int i = high; i >= m; i--) {\n                        f += ort[i] * householderVectors[i][j];\n                    }\n                    f = f / h;\n                    for (int i = m; i <= high; i++) {\n                        householderVectors[i][j] -= f * ort[i];\n                    }\n                }\n\n                for (int i = 0; i <= high; i++) {\n                    double f = 0;\n                    for (int j = high; j >= m; j--) {\n                        f += ort[j] * householderVectors[i][j];\n                    }\n                    f = f / h;\n                    for (int j = m; j <= high; j++) {\n                        householderVectors[i][j] -= f * ort[j];\n                    }\n                }\n\n                ort[m] = scale * ort[m];\n                householderVectors[m][m - 1] = scale * g;\n            }\n        }\n    }",
          "39": "    private void transform() {\n        final int n = householderVectors.length;\n        final int high = n - 1;\n\n        for (int m = 1; m <= high - 1; m++) {\n            // Scale column.\n            double scale = 0;\n            for (int i = m; i <= high; i++) {\n                scale += FastMath.abs(householderVectors[i][m - 1]);\n            }\n\n            if (!Precision.equals(scale, 0)) {\n                // Compute Householder transformation.\n                double h = 0;\n                for (int i = high; i >= m; i--) {\n                    ort[i] = householderVectors[i][m - 1] / scale;\n                    h += ort[i] * ort[i];\n                }\nfinal double g = ((ort[m] > 0))?(double)FastMath.sqrt(ort[m]):FastMath.sqrt(h);\n\n                h = h - ort[m] * g;\n                ort[m] = ort[m] - g;\n\n                // Apply Householder similarity transformation\n                // H = (I - u*u' / h) * H * (I - u*u' / h)\n\n                for (int j = m; j < n; j++) {\n                    double f = 0;\n                    for (int i = high; i >= m; i--) {\n                        f += ort[i] * householderVectors[i][j];\n                    }\n                    f = f / h;\n                    for (int i = m; i <= high; i++) {\n                        householderVectors[i][j] -= f * ort[i];\n                    }\n                }\n\n                for (int i = 0; i <= high; i++) {\n                    double f = 0;\n                    for (int j = high; j >= m; j--) {\n                        f += ort[j] * householderVectors[i][j];\n                    }\n                    f = f / h;\n                    for (int j = m; j <= high; j++) {\n                        householderVectors[i][j] -= f * ort[j];\n                    }\n                }\n\n                ort[m] = scale * ort[m];\n                householderVectors[m][m - 1] = scale * g;\n            }\n        }\n    }",
          "40": "    private void transform() {\n        final int n = householderVectors.length;\n        final int high = n - 1;\n\n        for (int m = 1; m <= high - 1; m++) {\n            // Scale column.\n            double scale = 0;\n            for (int i = m; i <= high; i++) {\n                scale += FastMath.abs(householderVectors[i][m - 1]);\n            }\n\n            if (!Precision.equals(scale, 0)) {\n                // Compute Householder transformation.\n                double h = 0;\n                for (int i = high; i >= m; i--) {\n                    ort[i] = householderVectors[i][m - 1] / scale;\n                    h += ort[i] * ort[i];\n                }\nfinal double g = ((ort[m] > 0))?(double)FastMath.sqrt(h[0]):FastMath.sqrt(h);\n\n                h = h - ort[m] * g;\n                ort[m] = ort[m] - g;\n\n                // Apply Householder similarity transformation\n                // H = (I - u*u' / h) * H * (I - u*u' / h)\n\n                for (int j = m; j < n; j++) {\n                    double f = 0;\n                    for (int i = high; i >= m; i--) {\n                        f += ort[i] * householderVectors[i][j];\n                    }\n                    f = f / h;\n                    for (int i = m; i <= high; i++) {\n                        householderVectors[i][j] -= f * ort[i];\n                    }\n                }\n\n                for (int i = 0; i <= high; i++) {\n                    double f = 0;\n                    for (int j = high; j >= m; j--) {\n                        f += ort[j] * householderVectors[i][j];\n                    }\n                    f = f / h;\n                    for (int j = m; j <= high; j++) {\n                        householderVectors[i][j] -= f * ort[j];\n                    }\n                }\n\n                ort[m] = scale * ort[m];\n                householderVectors[m][m - 1] = scale * g;\n            }\n        }\n    }"
}