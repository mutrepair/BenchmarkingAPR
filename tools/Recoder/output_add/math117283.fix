{
          "0": "    public static double asin(double x) {\n      if (x != x) {\n          return Double.NaN;\n      }\n\n      if (x > 1.0 || x < -1.0) {\n          return Double.NaN;\n      }\n\n      if (x == 1.0) {\n          return Math.PI/2.0;\n      }\n\n      if (x == -1.0) {\n          return -Math.PI/2.0;\n      }\n\n      if (x == 0.0) { // Matches +/- 0.0; return correct sign\n          return x;\n      }\n\n      /* Compute asin(x) = atan(x/sqrt(1-x*x)) */\n\n      /* Split x */\n      double temp = x * HEX_40000000;\n      final double xa = x + temp - temp;\n      final double xb = x - xa;\n\n      /* Square it */\n      double ya = xa*xa;\n      double yb = xa*xb*2.0 + xb*xb;\n\n      /* Subtract from 1 */\n      ya = -ya;\n      yb = -yb;\n\n      double za = 1.0 + ya;\n      double zb = -(za - 1.0 - ya);\n\n      temp = za + yb;\n      zb += -(temp - za - yb);\n      za = temp;\n\n      /* Square root */\n      double y;\n      y = sqrt(za);\n      temp = y * HEX_40000000;\n      ya = y + temp - temp;\n      yb = y - ya;\n\n      /* Extend precision of sqrt */\n      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      /* Contribution of zb to sqrt */\n      double dx = zb / (2.0*y);\n\n      // Compute ratio r = x/y\n      double r = x/y;\n      temp = r * HEX_40000000;\n      double ra = r + temp - temp;\n      double rb = r - ra;\n\n      rb += (x - ra*ya - ra*yb - rb*ya - rb*yb) / y;  // Correct for rounding in division\nrb = (((+x * dx) / y) / y);\n\n      temp = ra + rb;\n      rb = -(temp - ra - rb);\n      ra = temp;\n\n      return atan(ra, rb, false);\n    }",
          "1": "    public static double asin(double x) {\n      if (x != x) {\n          return Double.NaN;\n      }\n\n      if (x > 1.0 || x < -1.0) {\n          return Double.NaN;\n      }\n\n      if (x == 1.0) {\n          return Math.PI/2.0;\n      }\n\n      if (x == -1.0) {\n          return -Math.PI/2.0;\n      }\n\n      if (x == 0.0) { // Matches +/- 0.0; return correct sign\n          return x;\n      }\n\n      /* Compute asin(x) = atan(x/sqrt(1-x*x)) */\n\n      /* Split x */\n      double temp = x * HEX_40000000;\n      final double xa = x + temp - temp;\n      final double xb = x - xa;\n\n      /* Square it */\n      double ya = xa*xa;\n      double yb = xa*xb*2.0 + xb*xb;\n\n      /* Subtract from 1 */\n      ya = -ya;\n      yb = -yb;\n\n      double za = 1.0 + ya;\n      double zb = -(za - 1.0 - ya);\n\n      temp = za + yb;\n      zb += -(temp - za - yb);\n      za = temp;\n\n      /* Square root */\n      double y;\n      y = sqrt(za);\n      temp = y * HEX_40000000;\n      ya = y + temp - temp;\n      yb = y - ya;\n\n      /* Extend precision of sqrt */\n      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      /* Contribution of zb to sqrt */\n      double dx = zb / (2.0*y);\n\n      // Compute ratio r = x/y\n      double r = x/y;\n      temp = r * HEX_40000000;\n      double ra = r + temp - temp;\n      double rb = r - ra;\n\n      rb += (x - ra*ya - ra*yb - rb*ya - rb*yb) / y;  // Correct for rounding in division\ntemp += (((+x * dx) / y) / y);\n\n      temp = ra + rb;\n      rb = -(temp - ra - rb);\n      ra = temp;\n\n      return atan(ra, rb, false);\n    }",
          "2": "    public static double asin(double x) {\n      if (x != x) {\n          return Double.NaN;\n      }\n\n      if (x > 1.0 || x < -1.0) {\n          return Double.NaN;\n      }\n\n      if (x == 1.0) {\n          return Math.PI/2.0;\n      }\n\n      if (x == -1.0) {\n          return -Math.PI/2.0;\n      }\n\n      if (x == 0.0) { // Matches +/- 0.0; return correct sign\n          return x;\n      }\n\n      /* Compute asin(x) = atan(x/sqrt(1-x*x)) */\n\n      /* Split x */\n      double temp = x * HEX_40000000;\n      final double xa = x + temp - temp;\n      final double xb = x - xa;\n\n      /* Square it */\n      double ya = xa*xa;\n      double yb = xa*xb*2.0 + xb*xb;\n\n      /* Subtract from 1 */\n      ya = -ya;\n      yb = -yb;\n\n      double za = 1.0 + ya;\n      double zb = -(za - 1.0 - ya);\n\n      temp = za + yb;\n      zb += -(temp - za - yb);\n      za = temp;\n\n      /* Square root */\n      double y;\n      y = sqrt(za);\n      temp = y * HEX_40000000;\n      ya = y + temp - temp;\n      yb = y - ya;\n\n      /* Extend precision of sqrt */\n      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      /* Contribution of zb to sqrt */\n      double dx = zb / (2.0*y);\n\n      // Compute ratio r = x/y\n      double r = x/y;\n      temp = r * HEX_40000000;\n      double ra = r + temp - temp;\n      double rb = r - ra;\n\n      rb += (x - ra*ya - ra*yb - rb*ya - rb*yb) / y;  // Correct for rounding in division\nra += (((+x * dx) / y) / y);\n\n      temp = ra + rb;\n      rb = -(temp - ra - rb);\n      ra = temp;\n\n      return atan(ra, rb, false);\n    }",
          "3": "    public static double asin(double x) {\n      if (x != x) {\n          return Double.NaN;\n      }\n\n      if (x > 1.0 || x < -1.0) {\n          return Double.NaN;\n      }\n\n      if (x == 1.0) {\n          return Math.PI/2.0;\n      }\n\n      if (x == -1.0) {\n          return -Math.PI/2.0;\n      }\n\n      if (x == 0.0) { // Matches +/- 0.0; return correct sign\n          return x;\n      }\n\n      /* Compute asin(x) = atan(x/sqrt(1-x*x)) */\n\n      /* Split x */\n      double temp = x * HEX_40000000;\n      final double xa = x + temp - temp;\n      final double xb = x - xa;\n\n      /* Square it */\n      double ya = xa*xa;\n      double yb = xa*xb*2.0 + xb*xb;\n\n      /* Subtract from 1 */\n      ya = -ya;\n      yb = -yb;\n\n      double za = 1.0 + ya;\n      double zb = -(za - 1.0 - ya);\n\n      temp = za + yb;\n      zb += -(temp - za - yb);\n      za = temp;\n\n      /* Square root */\n      double y;\n      y = sqrt(za);\n      temp = y * HEX_40000000;\n      ya = y + temp - temp;\n      yb = y - ya;\n\n      /* Extend precision of sqrt */\n      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      /* Contribution of zb to sqrt */\n      double dx = zb / (2.0*y);\n\n      // Compute ratio r = x/y\n      double r = x/y;\n      temp = r * HEX_40000000;\n      double ra = r + temp - temp;\n      double rb = r - ra;\n\n      rb += (x - ra*ya - ra*yb - rb*ya - rb*yb) / y;  // Correct for rounding in division\nrb -= (((+x * dx) / y) / y);\n\n      temp = ra + rb;\n      rb = -(temp - ra - rb);\n      ra = temp;\n\n      return atan(ra, rb, false);\n    }",
          "4": "    public static double asin(double x) {\n      if (x != x) {\n          return Double.NaN;\n      }\n\n      if (x > 1.0 || x < -1.0) {\n          return Double.NaN;\n      }\n\n      if (x == 1.0) {\n          return Math.PI/2.0;\n      }\n\n      if (x == -1.0) {\n          return -Math.PI/2.0;\n      }\n\n      if (x == 0.0) { // Matches +/- 0.0; return correct sign\n          return x;\n      }\n\n      /* Compute asin(x) = atan(x/sqrt(1-x*x)) */\n\n      /* Split x */\n      double temp = x * HEX_40000000;\n      final double xa = x + temp - temp;\n      final double xb = x - xa;\n\n      /* Square it */\n      double ya = xa*xa;\n      double yb = xa*xb*2.0 + xb*xb;\n\n      /* Subtract from 1 */\n      ya = -ya;\n      yb = -yb;\n\n      double za = 1.0 + ya;\n      double zb = -(za - 1.0 - ya);\n\n      temp = za + yb;\n      zb += -(temp - za - yb);\n      za = temp;\n\n      /* Square root */\n      double y;\n      y = sqrt(za);\n      temp = y * HEX_40000000;\n      ya = y + temp - temp;\n      yb = y - ya;\n\n      /* Extend precision of sqrt */\n      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      /* Contribution of zb to sqrt */\n      double dx = zb / (2.0*y);\n\n      // Compute ratio r = x/y\n      double r = x/y;\n      temp = r * HEX_40000000;\n      double ra = r + temp - temp;\n      double rb = r - ra;\n\n      rb += (x - ra*ya - ra*yb - rb*ya - rb*yb) / y;  // Correct for rounding in division\nrb += (((+x * dx) / y) - y);\n\n      temp = ra + rb;\n      rb = -(temp - ra - rb);\n      ra = temp;\n\n      return atan(ra, rb, false);\n    }",
          "5": "    public static double asin(double x) {\n      if (x != x) {\n          return Double.NaN;\n      }\n\n      if (x > 1.0 || x < -1.0) {\n          return Double.NaN;\n      }\n\n      if (x == 1.0) {\n          return Math.PI/2.0;\n      }\n\n      if (x == -1.0) {\n          return -Math.PI/2.0;\n      }\n\n      if (x == 0.0) { // Matches +/- 0.0; return correct sign\n          return x;\n      }\n\n      /* Compute asin(x) = atan(x/sqrt(1-x*x)) */\n\n      /* Split x */\n      double temp = x * HEX_40000000;\n      final double xa = x + temp - temp;\n      final double xb = x - xa;\n\n      /* Square it */\n      double ya = xa*xa;\n      double yb = xa*xb*2.0 + xb*xb;\n\n      /* Subtract from 1 */\n      ya = -ya;\n      yb = -yb;\n\n      double za = 1.0 + ya;\n      double zb = -(za - 1.0 - ya);\n\n      temp = za + yb;\n      zb += -(temp - za - yb);\n      za = temp;\n\n      /* Square root */\n      double y;\n      y = sqrt(za);\n      temp = y * HEX_40000000;\n      ya = y + temp - temp;\n      yb = y - ya;\n\n      /* Extend precision of sqrt */\n      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      /* Contribution of zb to sqrt */\n      double dx = zb / (2.0*y);\n\n      // Compute ratio r = x/y\n      double r = x/y;\n      temp = r * HEX_40000000;\n      double ra = r + temp - temp;\n      double rb = r - ra;\n\n      rb += (x - ra*ya - ra*yb - rb*ya - rb*yb) / y;  // Correct for rounding in division\nrb += (((+x * temp) / y) / y);\n\n      temp = ra + rb;\n      rb = -(temp - ra - rb);\n      ra = temp;\n\n      return atan(ra, rb, false);\n    }",
          "6": "    public static double asin(double x) {\n      if (x != x) {\n          return Double.NaN;\n      }\n\n      if (x > 1.0 || x < -1.0) {\n          return Double.NaN;\n      }\n\n      if (x == 1.0) {\n          return Math.PI/2.0;\n      }\n\n      if (x == -1.0) {\n          return -Math.PI/2.0;\n      }\n\n      if (x == 0.0) { // Matches +/- 0.0; return correct sign\n          return x;\n      }\n\n      /* Compute asin(x) = atan(x/sqrt(1-x*x)) */\n\n      /* Split x */\n      double temp = x * HEX_40000000;\n      final double xa = x + temp - temp;\n      final double xb = x - xa;\n\n      /* Square it */\n      double ya = xa*xa;\n      double yb = xa*xb*2.0 + xb*xb;\n\n      /* Subtract from 1 */\n      ya = -ya;\n      yb = -yb;\n\n      double za = 1.0 + ya;\n      double zb = -(za - 1.0 - ya);\n\n      temp = za + yb;\n      zb += -(temp - za - yb);\n      za = temp;\n\n      /* Square root */\n      double y;\n      y = sqrt(za);\n      temp = y * HEX_40000000;\n      ya = y + temp - temp;\n      yb = y - ya;\n\n      /* Extend precision of sqrt */\n      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      /* Contribution of zb to sqrt */\n      double dx = zb / (2.0*y);\n\n      // Compute ratio r = x/y\n      double r = x/y;\n      temp = r * HEX_40000000;\n      double ra = r + temp - temp;\n      double rb = r - ra;\n\n      rb += (x - ra*ya - ra*yb - rb*ya - rb*yb) / y;  // Correct for rounding in division\nrb += ((+x * dx) / y);\n\n      temp = ra + rb;\n      rb = -(temp - ra - rb);\n      ra = temp;\n\n      return atan(ra, rb, false);\n    }",
          "7": "    public static double asin(double x) {\n      if (x != x) {\n          return Double.NaN;\n      }\n\n      if (x > 1.0 || x < -1.0) {\n          return Double.NaN;\n      }\n\n      if (x == 1.0) {\n          return Math.PI/2.0;\n      }\n\n      if (x == -1.0) {\n          return -Math.PI/2.0;\n      }\n\n      if (x == 0.0) { // Matches +/- 0.0; return correct sign\n          return x;\n      }\n\n      /* Compute asin(x) = atan(x/sqrt(1-x*x)) */\n\n      /* Split x */\n      double temp = x * HEX_40000000;\n      final double xa = x + temp - temp;\n      final double xb = x - xa;\n\n      /* Square it */\n      double ya = xa*xa;\n      double yb = xa*xb*2.0 + xb*xb;\n\n      /* Subtract from 1 */\n      ya = -ya;\n      yb = -yb;\n\n      double za = 1.0 + ya;\n      double zb = -(za - 1.0 - ya);\n\n      temp = za + yb;\n      zb += -(temp - za - yb);\n      za = temp;\n\n      /* Square root */\n      double y;\n      y = sqrt(za);\n      temp = y * HEX_40000000;\n      ya = y + temp - temp;\n      yb = y - ya;\n\n      /* Extend precision of sqrt */\n      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      /* Contribution of zb to sqrt */\n      double dx = zb / (2.0*y);\n\n      // Compute ratio r = x/y\n      double r = x/y;\n      temp = r * HEX_40000000;\n      double ra = r + temp - temp;\n      double rb = r - ra;\n\n      rb += (x - ra*ya - ra*yb - rb*ya - rb*yb) / y;  // Correct for rounding in division\n\n      temp = ra + rb;\n      rb = -(temp - ra - rb);\n      ra = temp;\n\n      return atan(ra, rb, false);\n    }",
          "8": "    public static double asin(double x) {\n      if (x != x) {\n          return Double.NaN;\n      }\n\n      if (x > 1.0 || x < -1.0) {\n          return Double.NaN;\n      }\n\n      if (x == 1.0) {\n          return Math.PI/2.0;\n      }\n\n      if (x == -1.0) {\n          return -Math.PI/2.0;\n      }\n\n      if (x == 0.0) { // Matches +/- 0.0; return correct sign\n          return x;\n      }\n\n      /* Compute asin(x) = atan(x/sqrt(1-x*x)) */\n\n      /* Split x */\n      double temp = x * HEX_40000000;\n      final double xa = x + temp - temp;\n      final double xb = x - xa;\n\n      /* Square it */\n      double ya = xa*xa;\n      double yb = xa*xb*2.0 + xb*xb;\n\n      /* Subtract from 1 */\n      ya = -ya;\n      yb = -yb;\n\n      double za = 1.0 + ya;\n      double zb = -(za - 1.0 - ya);\n\n      temp = za + yb;\n      zb += -(temp - za - yb);\n      za = temp;\n\n      /* Square root */\n      double y;\n      y = sqrt(za);\n      temp = y * HEX_40000000;\n      ya = y + temp - temp;\n      yb = y - ya;\n\n      /* Extend precision of sqrt */\n      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      /* Contribution of zb to sqrt */\n      double dx = zb / (2.0*y);\n\n      // Compute ratio r = x/y\n      double r = x/y;\n      temp = r * HEX_40000000;\n      double ra = r + temp - temp;\n      double rb = r - ra;\n\n      rb += (x - ra*ya - ra*yb - rb*ya - rb*yb) / y;  // Correct for rounding in division\nrb += (((+x * dx) / y) <= y);\n\n      temp = ra + rb;\n      rb = -(temp - ra - rb);\n      ra = temp;\n\n      return atan(ra, rb, false);\n    }",
          "9": "    public static double asin(double x) {\n      if (x != x) {\n          return Double.NaN;\n      }\n\n      if (x > 1.0 || x < -1.0) {\n          return Double.NaN;\n      }\n\n      if (x == 1.0) {\n          return Math.PI/2.0;\n      }\n\n      if (x == -1.0) {\n          return -Math.PI/2.0;\n      }\n\n      if (x == 0.0) { // Matches +/- 0.0; return correct sign\n          return x;\n      }\n\n      /* Compute asin(x) = atan(x/sqrt(1-x*x)) */\n\n      /* Split x */\n      double temp = x * HEX_40000000;\n      final double xa = x + temp - temp;\n      final double xb = x - xa;\n\n      /* Square it */\n      double ya = xa*xa;\n      double yb = xa*xb*2.0 + xb*xb;\n\n      /* Subtract from 1 */\n      ya = -ya;\n      yb = -yb;\n\n      double za = 1.0 + ya;\n      double zb = -(za - 1.0 - ya);\n\n      temp = za + yb;\n      zb += -(temp - za - yb);\n      za = temp;\n\n      /* Square root */\n      double y;\n      y = sqrt(za);\n      temp = y * HEX_40000000;\n      ya = y + temp - temp;\n      yb = y - ya;\n\n      /* Extend precision of sqrt */\n      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      /* Contribution of zb to sqrt */\n      double dx = zb / (2.0*y);\n\n      // Compute ratio r = x/y\n      double r = x/y;\n      temp = r * HEX_40000000;\n      double ra = r + temp - temp;\n      double rb = r - ra;\n\n      rb += (x - ra*ya - ra*yb - rb*ya - rb*yb) / y;  // Correct for rounding in division\nrb += (((+x * ra) / y) / y);\n\n      temp = ra + rb;\n      rb = -(temp - ra - rb);\n      ra = temp;\n\n      return atan(ra, rb, false);\n    }",
          "10": "    public static double asin(double x) {\n      if (x != x) {\n          return Double.NaN;\n      }\n\n      if (x > 1.0 || x < -1.0) {\n          return Double.NaN;\n      }\n\n      if (x == 1.0) {\n          return Math.PI/2.0;\n      }\n\n      if (x == -1.0) {\n          return -Math.PI/2.0;\n      }\n\n      if (x == 0.0) { // Matches +/- 0.0; return correct sign\n          return x;\n      }\n\n      /* Compute asin(x) = atan(x/sqrt(1-x*x)) */\n\n      /* Split x */\n      double temp = x * HEX_40000000;\n      final double xa = x + temp - temp;\n      final double xb = x - xa;\n\n      /* Square it */\n      double ya = xa*xa;\n      double yb = xa*xb*2.0 + xb*xb;\n\n      /* Subtract from 1 */\n      ya = -ya;\n      yb = -yb;\n\n      double za = 1.0 + ya;\n      double zb = -(za - 1.0 - ya);\n\n      temp = za + yb;\n      zb += -(temp - za - yb);\n      za = temp;\n\n      /* Square root */\n      double y;\n      y = sqrt(za);\n      temp = y * HEX_40000000;\n      ya = y + temp - temp;\n      yb = y - ya;\n\n      /* Extend precision of sqrt */\n      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      /* Contribution of zb to sqrt */\n      double dx = zb / (2.0*y);\n\n      // Compute ratio r = x/y\n      double r = x/y;\n      temp = r * HEX_40000000;\n      double ra = r + temp - temp;\n      double rb = r - ra;\n\n      rb += (x - ra*ya - ra*yb - rb*ya - rb*yb) / y;  // Correct for rounding in division\nrb += (((+x * dx) / y) + y);\n\n      temp = ra + rb;\n      rb = -(temp - ra - rb);\n      ra = temp;\n\n      return atan(ra, rb, false);\n    }",
          "11": "    public static double asin(double x) {\n      if (x != x) {\n          return Double.NaN;\n      }\n\n      if (x > 1.0 || x < -1.0) {\n          return Double.NaN;\n      }\n\n      if (x == 1.0) {\n          return Math.PI/2.0;\n      }\n\n      if (x == -1.0) {\n          return -Math.PI/2.0;\n      }\n\n      if (x == 0.0) { // Matches +/- 0.0; return correct sign\n          return x;\n      }\n\n      /* Compute asin(x) = atan(x/sqrt(1-x*x)) */\n\n      /* Split x */\n      double temp = x * HEX_40000000;\n      final double xa = x + temp - temp;\n      final double xb = x - xa;\n\n      /* Square it */\n      double ya = xa*xa;\n      double yb = xa*xb*2.0 + xb*xb;\n\n      /* Subtract from 1 */\n      ya = -ya;\n      yb = -yb;\n\n      double za = 1.0 + ya;\n      double zb = -(za - 1.0 - ya);\n\n      temp = za + yb;\n      zb += -(temp - za - yb);\n      za = temp;\n\n      /* Square root */\n      double y;\n      y = sqrt(za);\n      temp = y * HEX_40000000;\n      ya = y + temp - temp;\n      yb = y - ya;\n\n      /* Extend precision of sqrt */\n      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      /* Contribution of zb to sqrt */\n      double dx = zb / (2.0*y);\n\n      // Compute ratio r = x/y\n      double r = x/y;\n      temp = r * HEX_40000000;\n      double ra = r + temp - temp;\n      double rb = r - ra;\n\n      rb += (x - ra*ya - ra*yb - rb*ya - rb*yb) / y;  // Correct for rounding in division\nra = temp;\n\n      temp = ra + rb;\n      rb = -(temp - ra - rb);\n      ra = temp;\n\n      return atan(ra, rb, false);\n    }",
          "12": "    public static double asin(double x) {\n      if (x != x) {\n          return Double.NaN;\n      }\n\n      if (x > 1.0 || x < -1.0) {\n          return Double.NaN;\n      }\n\n      if (x == 1.0) {\n          return Math.PI/2.0;\n      }\n\n      if (x == -1.0) {\n          return -Math.PI/2.0;\n      }\n\n      if (x == 0.0) { // Matches +/- 0.0; return correct sign\n          return x;\n      }\n\n      /* Compute asin(x) = atan(x/sqrt(1-x*x)) */\n\n      /* Split x */\n      double temp = x * HEX_40000000;\n      final double xa = x + temp - temp;\n      final double xb = x - xa;\n\n      /* Square it */\n      double ya = xa*xa;\n      double yb = xa*xb*2.0 + xb*xb;\n\n      /* Subtract from 1 */\n      ya = -ya;\n      yb = -yb;\n\n      double za = 1.0 + ya;\n      double zb = -(za - 1.0 - ya);\n\n      temp = za + yb;\n      zb += -(temp - za - yb);\n      za = temp;\n\n      /* Square root */\n      double y;\n      y = sqrt(za);\n      temp = y * HEX_40000000;\n      ya = y + temp - temp;\n      yb = y - ya;\n\n      /* Extend precision of sqrt */\n      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      /* Contribution of zb to sqrt */\n      double dx = zb / (2.0*y);\n\n      // Compute ratio r = x/y\n      double r = x/y;\n      temp = r * HEX_40000000;\n      double ra = r + temp - temp;\n      double rb = r - ra;\n\n      rb += (x - ra*ya - ra*yb - rb*ya - rb*yb) / y;  // Correct for rounding in division\nrb = ((temp - ra) - rb);\n\n      temp = ra + rb;\n      rb = -(temp - ra - rb);\n      ra = temp;\n\n      return atan(ra, rb, false);\n    }",
          "13": "    public static double asin(double x) {\n      if (x != x) {\n          return Double.NaN;\n      }\n\n      if (x > 1.0 || x < -1.0) {\n          return Double.NaN;\n      }\n\n      if (x == 1.0) {\n          return Math.PI/2.0;\n      }\n\n      if (x == -1.0) {\n          return -Math.PI/2.0;\n      }\n\n      if (x == 0.0) { // Matches +/- 0.0; return correct sign\n          return x;\n      }\n\n      /* Compute asin(x) = atan(x/sqrt(1-x*x)) */\n\n      /* Split x */\n      double temp = x * HEX_40000000;\n      final double xa = x + temp - temp;\n      final double xb = x - xa;\n\n      /* Square it */\n      double ya = xa*xa;\n      double yb = xa*xb*2.0 + xb*xb;\n\n      /* Subtract from 1 */\n      ya = -ya;\n      yb = -yb;\n\n      double za = 1.0 + ya;\n      double zb = -(za - 1.0 - ya);\n\n      temp = za + yb;\n      zb += -(temp - za - yb);\n      za = temp;\n\n      /* Square root */\n      double y;\n      y = sqrt(za);\n      temp = y * HEX_40000000;\n      ya = y + temp - temp;\n      yb = y - ya;\n\n      /* Extend precision of sqrt */\n      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      /* Contribution of zb to sqrt */\n      double dx = zb / (2.0*y);\n\n      // Compute ratio r = x/y\n      double r = x/y;\n      temp = r * HEX_40000000;\n      double ra = r + temp - temp;\n      double rb = r - ra;\n\n      rb += (x - ra*ya - ra*yb - rb*ya - rb*yb) / y;  // Correct for rounding in division\ntemp = (((+x * dx) / y) / y);\n\n      temp = ra + rb;\n      rb = -(temp - ra - rb);\n      ra = temp;\n\n      return atan(ra, rb, false);\n    }",
          "14": "    public static double asin(double x) {\n      if (x != x) {\n          return Double.NaN;\n      }\n\n      if (x > 1.0 || x < -1.0) {\n          return Double.NaN;\n      }\n\n      if (x == 1.0) {\n          return Math.PI/2.0;\n      }\n\n      if (x == -1.0) {\n          return -Math.PI/2.0;\n      }\n\n      if (x == 0.0) { // Matches +/- 0.0; return correct sign\n          return x;\n      }\n\n      /* Compute asin(x) = atan(x/sqrt(1-x*x)) */\n\n      /* Split x */\n      double temp = x * HEX_40000000;\n      final double xa = x + temp - temp;\n      final double xb = x - xa;\n\n      /* Square it */\n      double ya = xa*xa;\n      double yb = xa*xb*2.0 + xb*xb;\n\n      /* Subtract from 1 */\n      ya = -ya;\n      yb = -yb;\n\n      double za = 1.0 + ya;\n      double zb = -(za - 1.0 - ya);\n\n      temp = za + yb;\n      zb += -(temp - za - yb);\n      za = temp;\n\n      /* Square root */\n      double y;\n      y = sqrt(za);\n      temp = y * HEX_40000000;\n      ya = y + temp - temp;\n      yb = y - ya;\n\n      /* Extend precision of sqrt */\n      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      /* Contribution of zb to sqrt */\n      double dx = zb / (2.0*y);\n\n      // Compute ratio r = x/y\n      double r = x/y;\n      temp = r * HEX_40000000;\n      double ra = r + temp - temp;\n      double rb = r - ra;\n\n      rb += (x - ra*ya - ra*yb - rb*ya - rb*yb) / y;  // Correct for rounding in division\nra = (((+x * dx) / y) / y);\n\n      temp = ra + rb;\n      rb = -(temp - ra - rb);\n      ra = temp;\n\n      return atan(ra, rb, false);\n    }",
          "15": "    public static double asin(double x) {\n      if (x != x) {\n          return Double.NaN;\n      }\n\n      if (x > 1.0 || x < -1.0) {\n          return Double.NaN;\n      }\n\n      if (x == 1.0) {\n          return Math.PI/2.0;\n      }\n\n      if (x == -1.0) {\n          return -Math.PI/2.0;\n      }\n\n      if (x == 0.0) { // Matches +/- 0.0; return correct sign\n          return x;\n      }\n\n      /* Compute asin(x) = atan(x/sqrt(1-x*x)) */\n\n      /* Split x */\n      double temp = x * HEX_40000000;\n      final double xa = x + temp - temp;\n      final double xb = x - xa;\n\n      /* Square it */\n      double ya = xa*xa;\n      double yb = xa*xb*2.0 + xb*xb;\n\n      /* Subtract from 1 */\n      ya = -ya;\n      yb = -yb;\n\n      double za = 1.0 + ya;\n      double zb = -(za - 1.0 - ya);\n\n      temp = za + yb;\n      zb += -(temp - za - yb);\n      za = temp;\n\n      /* Square root */\n      double y;\n      y = sqrt(za);\n      temp = y * HEX_40000000;\n      ya = y + temp - temp;\n      yb = y - ya;\n\n      /* Extend precision of sqrt */\n      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      /* Contribution of zb to sqrt */\n      double dx = zb / (2.0*y);\n\n      // Compute ratio r = x/y\n      double r = x/y;\n      temp = r * HEX_40000000;\n      double ra = r + temp - temp;\n      double rb = r - ra;\n\n      rb += (x - ra*ya - ra*yb - rb*ya - rb*yb) / y;  // Correct for rounding in division\nrb += (((+x * dx) / y) / temp);\n\n      temp = ra + rb;\n      rb = -(temp - ra - rb);\n      ra = temp;\n\n      return atan(ra, rb, false);\n    }",
          "16": "    public static double asin(double x) {\n      if (x != x) {\n          return Double.NaN;\n      }\n\n      if (x > 1.0 || x < -1.0) {\n          return Double.NaN;\n      }\n\n      if (x == 1.0) {\n          return Math.PI/2.0;\n      }\n\n      if (x == -1.0) {\n          return -Math.PI/2.0;\n      }\n\n      if (x == 0.0) { // Matches +/- 0.0; return correct sign\n          return x;\n      }\n\n      /* Compute asin(x) = atan(x/sqrt(1-x*x)) */\n\n      /* Split x */\n      double temp = x * HEX_40000000;\n      final double xa = x + temp - temp;\n      final double xb = x - xa;\n\n      /* Square it */\n      double ya = xa*xa;\n      double yb = xa*xb*2.0 + xb*xb;\n\n      /* Subtract from 1 */\n      ya = -ya;\n      yb = -yb;\n\n      double za = 1.0 + ya;\n      double zb = -(za - 1.0 - ya);\n\n      temp = za + yb;\n      zb += -(temp - za - yb);\n      za = temp;\n\n      /* Square root */\n      double y;\n      y = sqrt(za);\n      temp = y * HEX_40000000;\n      ya = y + temp - temp;\n      yb = y - ya;\n\n      /* Extend precision of sqrt */\n      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      /* Contribution of zb to sqrt */\n      double dx = zb / (2.0*y);\n\n      // Compute ratio r = x/y\n      double r = x/y;\n      temp = r * HEX_40000000;\n      double ra = r + temp - temp;\n      double rb = r - ra;\n\n      rb += (x - ra*ya - ra*yb - rb*ya - rb*yb) / y;  // Correct for rounding in division\nrb = ((+x * dx) / y);\n\n      temp = ra + rb;\n      rb = -(temp - ra - rb);\n      ra = temp;\n\n      return atan(ra, rb, false);\n    }",
          "17": "    public static double asin(double x) {\n      if (x != x) {\n          return Double.NaN;\n      }\n\n      if (x > 1.0 || x < -1.0) {\n          return Double.NaN;\n      }\n\n      if (x == 1.0) {\n          return Math.PI/2.0;\n      }\n\n      if (x == -1.0) {\n          return -Math.PI/2.0;\n      }\n\n      if (x == 0.0) { // Matches +/- 0.0; return correct sign\n          return x;\n      }\n\n      /* Compute asin(x) = atan(x/sqrt(1-x*x)) */\n\n      /* Split x */\n      double temp = x * HEX_40000000;\n      final double xa = x + temp - temp;\n      final double xb = x - xa;\n\n      /* Square it */\n      double ya = xa*xa;\n      double yb = xa*xb*2.0 + xb*xb;\n\n      /* Subtract from 1 */\n      ya = -ya;\n      yb = -yb;\n\n      double za = 1.0 + ya;\n      double zb = -(za - 1.0 - ya);\n\n      temp = za + yb;\n      zb += -(temp - za - yb);\n      za = temp;\n\n      /* Square root */\n      double y;\n      y = sqrt(za);\n      temp = y * HEX_40000000;\n      ya = y + temp - temp;\n      yb = y - ya;\n\n      /* Extend precision of sqrt */\n      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      /* Contribution of zb to sqrt */\n      double dx = zb / (2.0*y);\n\n      // Compute ratio r = x/y\n      double r = x/y;\n      temp = r * HEX_40000000;\n      double ra = r + temp - temp;\n      double rb = r - ra;\n\n      rb += (x - ra*ya - ra*yb - rb*ya - rb*yb) / y;  // Correct for rounding in division\nrb *= (((+x * dx) / y) / y);\n\n      temp = ra + rb;\n      rb = -(temp - ra - rb);\n      ra = temp;\n\n      return atan(ra, rb, false);\n    }",
          "18": "    public static double asin(double x) {\n      if (x != x) {\n          return Double.NaN;\n      }\n\n      if (x > 1.0 || x < -1.0) {\n          return Double.NaN;\n      }\n\n      if (x == 1.0) {\n          return Math.PI/2.0;\n      }\n\n      if (x == -1.0) {\n          return -Math.PI/2.0;\n      }\n\n      if (x == 0.0) { // Matches +/- 0.0; return correct sign\n          return x;\n      }\n\n      /* Compute asin(x) = atan(x/sqrt(1-x*x)) */\n\n      /* Split x */\n      double temp = x * HEX_40000000;\n      final double xa = x + temp - temp;\n      final double xb = x - xa;\n\n      /* Square it */\n      double ya = xa*xa;\n      double yb = xa*xb*2.0 + xb*xb;\n\n      /* Subtract from 1 */\n      ya = -ya;\n      yb = -yb;\n\n      double za = 1.0 + ya;\n      double zb = -(za - 1.0 - ya);\n\n      temp = za + yb;\n      zb += -(temp - za - yb);\n      za = temp;\n\n      /* Square root */\n      double y;\n      y = sqrt(za);\n      temp = y * HEX_40000000;\n      ya = y + temp - temp;\n      yb = y - ya;\n\n      /* Extend precision of sqrt */\n      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      /* Contribution of zb to sqrt */\n      double dx = zb / (2.0*y);\n\n      // Compute ratio r = x/y\n      double r = x/y;\n      temp = r * HEX_40000000;\n      double ra = r + temp - temp;\n      double rb = r - ra;\n\n      rb += (x - ra*ya - ra*yb - rb*ya - rb*yb) / y;  // Correct for rounding in division\ntemp += ((+x * dx) / y);\n\n      temp = ra + rb;\n      rb = -(temp - ra - rb);\n      ra = temp;\n\n      return atan(ra, rb, false);\n    }",
          "19": "    public static double asin(double x) {\n      if (x != x) {\n          return Double.NaN;\n      }\n\n      if (x > 1.0 || x < -1.0) {\n          return Double.NaN;\n      }\n\n      if (x == 1.0) {\n          return Math.PI/2.0;\n      }\n\n      if (x == -1.0) {\n          return -Math.PI/2.0;\n      }\n\n      if (x == 0.0) { // Matches +/- 0.0; return correct sign\n          return x;\n      }\n\n      /* Compute asin(x) = atan(x/sqrt(1-x*x)) */\n\n      /* Split x */\n      double temp = x * HEX_40000000;\n      final double xa = x + temp - temp;\n      final double xb = x - xa;\n\n      /* Square it */\n      double ya = xa*xa;\n      double yb = xa*xb*2.0 + xb*xb;\n\n      /* Subtract from 1 */\n      ya = -ya;\n      yb = -yb;\n\n      double za = 1.0 + ya;\n      double zb = -(za - 1.0 - ya);\n\n      temp = za + yb;\n      zb += -(temp - za - yb);\n      za = temp;\n\n      /* Square root */\n      double y;\n      y = sqrt(za);\n      temp = y * HEX_40000000;\n      ya = y + temp - temp;\n      yb = y - ya;\n\n      /* Extend precision of sqrt */\n      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      /* Contribution of zb to sqrt */\n      double dx = zb / (2.0*y);\n\n      // Compute ratio r = x/y\n      double r = x/y;\n      temp = r * HEX_40000000;\n      double ra = r + temp - temp;\n      double rb = r - ra;\n\n      rb += (x - ra*ya - ra*yb - rb*ya - rb*yb) / y;  // Correct for rounding in division\ntemp = (ra + rb);\n\n      temp = ra + rb;\n      rb = -(temp - ra - rb);\n      ra = temp;\n\n      return atan(ra, rb, false);\n    }",
          "20": "    public static double asin(double x) {\n      if (x != x) {\n          return Double.NaN;\n      }\n\n      if (x > 1.0 || x < -1.0) {\n          return Double.NaN;\n      }\n\n      if (x == 1.0) {\n          return Math.PI/2.0;\n      }\n\n      if (x == -1.0) {\n          return -Math.PI/2.0;\n      }\n\n      if (x == 0.0) { // Matches +/- 0.0; return correct sign\n          return x;\n      }\n\n      /* Compute asin(x) = atan(x/sqrt(1-x*x)) */\n\n      /* Split x */\n      double temp = x * HEX_40000000;\n      final double xa = x + temp - temp;\n      final double xb = x - xa;\n\n      /* Square it */\n      double ya = xa*xa;\n      double yb = xa*xb*2.0 + xb*xb;\n\n      /* Subtract from 1 */\n      ya = -ya;\n      yb = -yb;\n\n      double za = 1.0 + ya;\n      double zb = -(za - 1.0 - ya);\n\n      temp = za + yb;\n      zb += -(temp - za - yb);\n      za = temp;\n\n      /* Square root */\n      double y;\n      y = sqrt(za);\n      temp = y * HEX_40000000;\n      ya = y + temp - temp;\n      yb = y - ya;\n\n      /* Extend precision of sqrt */\n      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      /* Contribution of zb to sqrt */\n      double dx = zb / (2.0*y);\n\n      // Compute ratio r = x/y\n      double r = x/y;\n      temp = r * HEX_40000000;\n      double ra = r + temp - temp;\n      double rb = r - ra;\n\n      rb += (x - ra*ya - ra*yb - rb*ya - rb*yb) / y;  // Correct for rounding in division\nrb += (((+x * ya) / y) / y);\n\n      temp = ra + rb;\n      rb = -(temp - ra - rb);\n      ra = temp;\n\n      return atan(ra, rb, false);\n    }",
          "21": "    public static double asin(double x) {\n      if (x != x) {\n          return Double.NaN;\n      }\n\n      if (x > 1.0 || x < -1.0) {\n          return Double.NaN;\n      }\n\n      if (x == 1.0) {\n          return Math.PI/2.0;\n      }\n\n      if (x == -1.0) {\n          return -Math.PI/2.0;\n      }\n\n      if (x == 0.0) { // Matches +/- 0.0; return correct sign\n          return x;\n      }\n\n      /* Compute asin(x) = atan(x/sqrt(1-x*x)) */\n\n      /* Split x */\n      double temp = x * HEX_40000000;\n      final double xa = x + temp - temp;\n      final double xb = x - xa;\n\n      /* Square it */\n      double ya = xa*xa;\n      double yb = xa*xb*2.0 + xb*xb;\n\n      /* Subtract from 1 */\n      ya = -ya;\n      yb = -yb;\n\n      double za = 1.0 + ya;\n      double zb = -(za - 1.0 - ya);\n\n      temp = za + yb;\n      zb += -(temp - za - yb);\n      za = temp;\n\n      /* Square root */\n      double y;\n      y = sqrt(za);\n      temp = y * HEX_40000000;\n      ya = y + temp - temp;\n      yb = y - ya;\n\n      /* Extend precision of sqrt */\n      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      /* Contribution of zb to sqrt */\n      double dx = zb / (2.0*y);\n\n      // Compute ratio r = x/y\n      double r = x/y;\n      temp = r * HEX_40000000;\n      double ra = r + temp - temp;\n      double rb = r - ra;\n\n      rb += (x - ra*ya - ra*yb - rb*ya - rb*yb) / y;  // Correct for rounding in division\nrb += (((+x * dx) / y) >= y);\n\n      temp = ra + rb;\n      rb = -(temp - ra - rb);\n      ra = temp;\n\n      return atan(ra, rb, false);\n    }",
          "22": "    public static double asin(double x) {\n      if (x != x) {\n          return Double.NaN;\n      }\n\n      if (x > 1.0 || x < -1.0) {\n          return Double.NaN;\n      }\n\n      if (x == 1.0) {\n          return Math.PI/2.0;\n      }\n\n      if (x == -1.0) {\n          return -Math.PI/2.0;\n      }\n\n      if (x == 0.0) { // Matches +/- 0.0; return correct sign\n          return x;\n      }\n\n      /* Compute asin(x) = atan(x/sqrt(1-x*x)) */\n\n      /* Split x */\n      double temp = x * HEX_40000000;\n      final double xa = x + temp - temp;\n      final double xb = x - xa;\n\n      /* Square it */\n      double ya = xa*xa;\n      double yb = xa*xb*2.0 + xb*xb;\n\n      /* Subtract from 1 */\n      ya = -ya;\n      yb = -yb;\n\n      double za = 1.0 + ya;\n      double zb = -(za - 1.0 - ya);\n\n      temp = za + yb;\n      zb += -(temp - za - yb);\n      za = temp;\n\n      /* Square root */\n      double y;\n      y = sqrt(za);\n      temp = y * HEX_40000000;\n      ya = y + temp - temp;\n      yb = y - ya;\n\n      /* Extend precision of sqrt */\n      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      /* Contribution of zb to sqrt */\n      double dx = zb / (2.0*y);\n\n      // Compute ratio r = x/y\n      double r = x/y;\n      temp = r * HEX_40000000;\n      double ra = r + temp - temp;\n      double rb = r - ra;\n\n      rb += (x - ra*ya - ra*yb - rb*ya - rb*yb) / y;  // Correct for rounding in division\ntemp -= (((+x * dx) / y) / y);\n\n      temp = ra + rb;\n      rb = -(temp - ra - rb);\n      ra = temp;\n\n      return atan(ra, rb, false);\n    }",
          "23": "    public static double asin(double x) {\n      if (x != x) {\n          return Double.NaN;\n      }\n\n      if (x > 1.0 || x < -1.0) {\n          return Double.NaN;\n      }\n\n      if (x == 1.0) {\n          return Math.PI/2.0;\n      }\n\n      if (x == -1.0) {\n          return -Math.PI/2.0;\n      }\n\n      if (x == 0.0) { // Matches +/- 0.0; return correct sign\n          return x;\n      }\n\n      /* Compute asin(x) = atan(x/sqrt(1-x*x)) */\n\n      /* Split x */\n      double temp = x * HEX_40000000;\n      final double xa = x + temp - temp;\n      final double xb = x - xa;\n\n      /* Square it */\n      double ya = xa*xa;\n      double yb = xa*xb*2.0 + xb*xb;\n\n      /* Subtract from 1 */\n      ya = -ya;\n      yb = -yb;\n\n      double za = 1.0 + ya;\n      double zb = -(za - 1.0 - ya);\n\n      temp = za + yb;\n      zb += -(temp - za - yb);\n      za = temp;\n\n      /* Square root */\n      double y;\n      y = sqrt(za);\n      temp = y * HEX_40000000;\n      ya = y + temp - temp;\n      yb = y - ya;\n\n      /* Extend precision of sqrt */\n      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      /* Contribution of zb to sqrt */\n      double dx = zb / (2.0*y);\n\n      // Compute ratio r = x/y\n      double r = x/y;\n      temp = r * HEX_40000000;\n      double ra = r + temp - temp;\n      double rb = r - ra;\n\n      rb += (x - ra*ya - ra*yb - rb*ya - rb*yb) / y;  // Correct for rounding in division\nrb |= (((+x * dx) / y) / y);\n\n      temp = ra + rb;\n      rb = -(temp - ra - rb);\n      ra = temp;\n\n      return atan(ra, rb, false);\n    }",
          "24": "    public static double asin(double x) {\n      if (x != x) {\n          return Double.NaN;\n      }\n\n      if (x > 1.0 || x < -1.0) {\n          return Double.NaN;\n      }\n\n      if (x == 1.0) {\n          return Math.PI/2.0;\n      }\n\n      if (x == -1.0) {\n          return -Math.PI/2.0;\n      }\n\n      if (x == 0.0) { // Matches +/- 0.0; return correct sign\n          return x;\n      }\n\n      /* Compute asin(x) = atan(x/sqrt(1-x*x)) */\n\n      /* Split x */\n      double temp = x * HEX_40000000;\n      final double xa = x + temp - temp;\n      final double xb = x - xa;\n\n      /* Square it */\n      double ya = xa*xa;\n      double yb = xa*xb*2.0 + xb*xb;\n\n      /* Subtract from 1 */\n      ya = -ya;\n      yb = -yb;\n\n      double za = 1.0 + ya;\n      double zb = -(za - 1.0 - ya);\n\n      temp = za + yb;\n      zb += -(temp - za - yb);\n      za = temp;\n\n      /* Square root */\n      double y;\n      y = sqrt(za);\n      temp = y * HEX_40000000;\n      ya = y + temp - temp;\n      yb = y - ya;\n\n      /* Extend precision of sqrt */\n      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      /* Contribution of zb to sqrt */\n      double dx = zb / (2.0*y);\n\n      // Compute ratio r = x/y\n      double r = x/y;\n      temp = r * HEX_40000000;\n      double ra = r + temp - temp;\n      double rb = r - ra;\n\n      rb += (x - ra*ya - ra*yb - rb*ya - rb*yb) / y;  // Correct for rounding in division\nra -= (((+x * dx) / y) / y);\n\n      temp = ra + rb;\n      rb = -(temp - ra - rb);\n      ra = temp;\n\n      return atan(ra, rb, false);\n    }",
          "25": "    public static double asin(double x) {\n      if (x != x) {\n          return Double.NaN;\n      }\n\n      if (x > 1.0 || x < -1.0) {\n          return Double.NaN;\n      }\n\n      if (x == 1.0) {\n          return Math.PI/2.0;\n      }\n\n      if (x == -1.0) {\n          return -Math.PI/2.0;\n      }\n\n      if (x == 0.0) { // Matches +/- 0.0; return correct sign\n          return x;\n      }\n\n      /* Compute asin(x) = atan(x/sqrt(1-x*x)) */\n\n      /* Split x */\n      double temp = x * HEX_40000000;\n      final double xa = x + temp - temp;\n      final double xb = x - xa;\n\n      /* Square it */\n      double ya = xa*xa;\n      double yb = xa*xb*2.0 + xb*xb;\n\n      /* Subtract from 1 */\n      ya = -ya;\n      yb = -yb;\n\n      double za = 1.0 + ya;\n      double zb = -(za - 1.0 - ya);\n\n      temp = za + yb;\n      zb += -(temp - za - yb);\n      za = temp;\n\n      /* Square root */\n      double y;\n      y = sqrt(za);\n      temp = y * HEX_40000000;\n      ya = y + temp - temp;\n      yb = y - ya;\n\n      /* Extend precision of sqrt */\n      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      /* Contribution of zb to sqrt */\n      double dx = zb / (2.0*y);\n\n      // Compute ratio r = x/y\n      double r = x/y;\n      temp = r * HEX_40000000;\n      double ra = r + temp - temp;\n      double rb = r - ra;\n\n      rb += (x - ra*ya - ra*yb - rb*ya - rb*yb) / y;  // Correct for rounding in division\nrb += (((+x * rb) / y) / y);\n\n      temp = ra + rb;\n      rb = -(temp - ra - rb);\n      ra = temp;\n\n      return atan(ra, rb, false);\n    }",
          "26": "    public static double asin(double x) {\n      if (x != x) {\n          return Double.NaN;\n      }\n\n      if (x > 1.0 || x < -1.0) {\n          return Double.NaN;\n      }\n\n      if (x == 1.0) {\n          return Math.PI/2.0;\n      }\n\n      if (x == -1.0) {\n          return -Math.PI/2.0;\n      }\n\n      if (x == 0.0) { // Matches +/- 0.0; return correct sign\n          return x;\n      }\n\n      /* Compute asin(x) = atan(x/sqrt(1-x*x)) */\n\n      /* Split x */\n      double temp = x * HEX_40000000;\n      final double xa = x + temp - temp;\n      final double xb = x - xa;\n\n      /* Square it */\n      double ya = xa*xa;\n      double yb = xa*xb*2.0 + xb*xb;\n\n      /* Subtract from 1 */\n      ya = -ya;\n      yb = -yb;\n\n      double za = 1.0 + ya;\n      double zb = -(za - 1.0 - ya);\n\n      temp = za + yb;\n      zb += -(temp - za - yb);\n      za = temp;\n\n      /* Square root */\n      double y;\n      y = sqrt(za);\n      temp = y * HEX_40000000;\n      ya = y + temp - temp;\n      yb = y - ya;\n\n      /* Extend precision of sqrt */\n      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      /* Contribution of zb to sqrt */\n      double dx = zb / (2.0*y);\n\n      // Compute ratio r = x/y\n      double r = x/y;\n      temp = r * HEX_40000000;\n      double ra = r + temp - temp;\n      double rb = r - ra;\n\n      rb += (x - ra*ya - ra*yb - rb*ya - rb*yb) / y;  // Correct for rounding in division\nra += ((+x * dx) / y);\n\n      temp = ra + rb;\n      rb = -(temp - ra - rb);\n      ra = temp;\n\n      return atan(ra, rb, false);\n    }",
          "27": "    public static double asin(double x) {\n      if (x != x) {\n          return Double.NaN;\n      }\n\n      if (x > 1.0 || x < -1.0) {\n          return Double.NaN;\n      }\n\n      if (x == 1.0) {\n          return Math.PI/2.0;\n      }\n\n      if (x == -1.0) {\n          return -Math.PI/2.0;\n      }\n\n      if (x == 0.0) { // Matches +/- 0.0; return correct sign\n          return x;\n      }\n\n      /* Compute asin(x) = atan(x/sqrt(1-x*x)) */\n\n      /* Split x */\n      double temp = x * HEX_40000000;\n      final double xa = x + temp - temp;\n      final double xb = x - xa;\n\n      /* Square it */\n      double ya = xa*xa;\n      double yb = xa*xb*2.0 + xb*xb;\n\n      /* Subtract from 1 */\n      ya = -ya;\n      yb = -yb;\n\n      double za = 1.0 + ya;\n      double zb = -(za - 1.0 - ya);\n\n      temp = za + yb;\n      zb += -(temp - za - yb);\n      za = temp;\n\n      /* Square root */\n      double y;\n      y = sqrt(za);\n      temp = y * HEX_40000000;\n      ya = y + temp - temp;\n      yb = y - ya;\n\n      /* Extend precision of sqrt */\n      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      /* Contribution of zb to sqrt */\n      double dx = zb / (2.0*y);\n\n      // Compute ratio r = x/y\n      double r = x/y;\n      temp = r * HEX_40000000;\n      double ra = r + temp - temp;\n      double rb = r - ra;\n\n      rb += (x - ra*ya - ra*yb - rb*ya - rb*yb) / y;  // Correct for rounding in division\nrb += (((+x * dx) / y) < y);\n\n      temp = ra + rb;\n      rb = -(temp - ra - rb);\n      ra = temp;\n\n      return atan(ra, rb, false);\n    }",
          "28": "    public static double asin(double x) {\n      if (x != x) {\n          return Double.NaN;\n      }\n\n      if (x > 1.0 || x < -1.0) {\n          return Double.NaN;\n      }\n\n      if (x == 1.0) {\n          return Math.PI/2.0;\n      }\n\n      if (x == -1.0) {\n          return -Math.PI/2.0;\n      }\n\n      if (x == 0.0) { // Matches +/- 0.0; return correct sign\n          return x;\n      }\n\n      /* Compute asin(x) = atan(x/sqrt(1-x*x)) */\n\n      /* Split x */\n      double temp = x * HEX_40000000;\n      final double xa = x + temp - temp;\n      final double xb = x - xa;\n\n      /* Square it */\n      double ya = xa*xa;\n      double yb = xa*xb*2.0 + xb*xb;\n\n      /* Subtract from 1 */\n      ya = -ya;\n      yb = -yb;\n\n      double za = 1.0 + ya;\n      double zb = -(za - 1.0 - ya);\n\n      temp = za + yb;\n      zb += -(temp - za - yb);\n      za = temp;\n\n      /* Square root */\n      double y;\n      y = sqrt(za);\n      temp = y * HEX_40000000;\n      ya = y + temp - temp;\n      yb = y - ya;\n\n      /* Extend precision of sqrt */\n      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      /* Contribution of zb to sqrt */\n      double dx = zb / (2.0*y);\n\n      // Compute ratio r = x/y\n      double r = x/y;\n      temp = r * HEX_40000000;\n      double ra = r + temp - temp;\n      double rb = r - ra;\n\n      rb += (x - ra*ya - ra*yb - rb*ya - rb*yb) / y;  // Correct for rounding in division\nrb += (((+x * dx) / y) / ra);\n\n      temp = ra + rb;\n      rb = -(temp - ra - rb);\n      ra = temp;\n\n      return atan(ra, rb, false);\n    }",
          "29": "    public static double asin(double x) {\n      if (x != x) {\n          return Double.NaN;\n      }\n\n      if (x > 1.0 || x < -1.0) {\n          return Double.NaN;\n      }\n\n      if (x == 1.0) {\n          return Math.PI/2.0;\n      }\n\n      if (x == -1.0) {\n          return -Math.PI/2.0;\n      }\n\n      if (x == 0.0) { // Matches +/- 0.0; return correct sign\n          return x;\n      }\n\n      /* Compute asin(x) = atan(x/sqrt(1-x*x)) */\n\n      /* Split x */\n      double temp = x * HEX_40000000;\n      final double xa = x + temp - temp;\n      final double xb = x - xa;\n\n      /* Square it */\n      double ya = xa*xa;\n      double yb = xa*xb*2.0 + xb*xb;\n\n      /* Subtract from 1 */\n      ya = -ya;\n      yb = -yb;\n\n      double za = 1.0 + ya;\n      double zb = -(za - 1.0 - ya);\n\n      temp = za + yb;\n      zb += -(temp - za - yb);\n      za = temp;\n\n      /* Square root */\n      double y;\n      y = sqrt(za);\n      temp = y * HEX_40000000;\n      ya = y + temp - temp;\n      yb = y - ya;\n\n      /* Extend precision of sqrt */\n      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      /* Contribution of zb to sqrt */\n      double dx = zb / (2.0*y);\n\n      // Compute ratio r = x/y\n      double r = x/y;\n      temp = r * HEX_40000000;\n      double ra = r + temp - temp;\n      double rb = r - ra;\n\n      rb += (x - ra*ya - ra*yb - rb*ya - rb*yb) / y;  // Correct for rounding in division\nrb += (((((x - (ra * ya)) - (ra * yb)) - (rb * ya)) - (rb * yb)) / y);\n\n      temp = ra + rb;\n      rb = -(temp - ra - rb);\n      ra = temp;\n\n      return atan(ra, rb, false);\n    }",
          "30": "    public static double asin(double x) {\n      if (x != x) {\n          return Double.NaN;\n      }\n\n      if (x > 1.0 || x < -1.0) {\n          return Double.NaN;\n      }\n\n      if (x == 1.0) {\n          return Math.PI/2.0;\n      }\n\n      if (x == -1.0) {\n          return -Math.PI/2.0;\n      }\n\n      if (x == 0.0) { // Matches +/- 0.0; return correct sign\n          return x;\n      }\n\n      /* Compute asin(x) = atan(x/sqrt(1-x*x)) */\n\n      /* Split x */\n      double temp = x * HEX_40000000;\n      final double xa = x + temp - temp;\n      final double xb = x - xa;\n\n      /* Square it */\n      double ya = xa*xa;\n      double yb = xa*xb*2.0 + xb*xb;\n\n      /* Subtract from 1 */\n      ya = -ya;\n      yb = -yb;\n\n      double za = 1.0 + ya;\n      double zb = -(za - 1.0 - ya);\n\n      temp = za + yb;\n      zb += -(temp - za - yb);\n      za = temp;\n\n      /* Square root */\n      double y;\n      y = sqrt(za);\n      temp = y * HEX_40000000;\n      ya = y + temp - temp;\n      yb = y - ya;\n\n      /* Extend precision of sqrt */\n      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      /* Contribution of zb to sqrt */\n      double dx = zb / (2.0*y);\n\n      // Compute ratio r = x/y\n      double r = x/y;\n      temp = r * HEX_40000000;\n      double ra = r + temp - temp;\n      double rb = r - ra;\n\n      rb += (x - ra*ya - ra*yb - rb*ya - rb*yb) / y;  // Correct for rounding in division\nrb -= ((+x * dx) / y);\n\n      temp = ra + rb;\n      rb = -(temp - ra - rb);\n      ra = temp;\n\n      return atan(ra, rb, false);\n    }",
          "31": "    public static double asin(double x) {\n      if (x != x) {\n          return Double.NaN;\n      }\n\n      if (x > 1.0 || x < -1.0) {\n          return Double.NaN;\n      }\n\n      if (x == 1.0) {\n          return Math.PI/2.0;\n      }\n\n      if (x == -1.0) {\n          return -Math.PI/2.0;\n      }\n\n      if (x == 0.0) { // Matches +/- 0.0; return correct sign\n          return x;\n      }\n\n      /* Compute asin(x) = atan(x/sqrt(1-x*x)) */\n\n      /* Split x */\n      double temp = x * HEX_40000000;\n      final double xa = x + temp - temp;\n      final double xb = x - xa;\n\n      /* Square it */\n      double ya = xa*xa;\n      double yb = xa*xb*2.0 + xb*xb;\n\n      /* Subtract from 1 */\n      ya = -ya;\n      yb = -yb;\n\n      double za = 1.0 + ya;\n      double zb = -(za - 1.0 - ya);\n\n      temp = za + yb;\n      zb += -(temp - za - yb);\n      za = temp;\n\n      /* Square root */\n      double y;\n      y = sqrt(za);\n      temp = y * HEX_40000000;\n      ya = y + temp - temp;\n      yb = y - ya;\n\n      /* Extend precision of sqrt */\n      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      /* Contribution of zb to sqrt */\n      double dx = zb / (2.0*y);\n\n      // Compute ratio r = x/y\n      double r = x/y;\n      temp = r * HEX_40000000;\n      double ra = r + temp - temp;\n      double rb = r - ra;\n\n      rb += (x - ra*ya - ra*yb - rb*ya - rb*yb) / y;  // Correct for rounding in division\nrb += (((+x * -ra) / y) / y);\n\n      temp = ra + rb;\n      rb = -(temp - ra - rb);\n      ra = temp;\n\n      return atan(ra, rb, false);\n    }",
          "32": "    public static double asin(double x) {\n      if (x != x) {\n          return Double.NaN;\n      }\n\n      if (x > 1.0 || x < -1.0) {\n          return Double.NaN;\n      }\n\n      if (x == 1.0) {\n          return Math.PI/2.0;\n      }\n\n      if (x == -1.0) {\n          return -Math.PI/2.0;\n      }\n\n      if (x == 0.0) { // Matches +/- 0.0; return correct sign\n          return x;\n      }\n\n      /* Compute asin(x) = atan(x/sqrt(1-x*x)) */\n\n      /* Split x */\n      double temp = x * HEX_40000000;\n      final double xa = x + temp - temp;\n      final double xb = x - xa;\n\n      /* Square it */\n      double ya = xa*xa;\n      double yb = xa*xb*2.0 + xb*xb;\n\n      /* Subtract from 1 */\n      ya = -ya;\n      yb = -yb;\n\n      double za = 1.0 + ya;\n      double zb = -(za - 1.0 - ya);\n\n      temp = za + yb;\n      zb += -(temp - za - yb);\n      za = temp;\n\n      /* Square root */\n      double y;\n      y = sqrt(za);\n      temp = y * HEX_40000000;\n      ya = y + temp - temp;\n      yb = y - ya;\n\n      /* Extend precision of sqrt */\n      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      /* Contribution of zb to sqrt */\n      double dx = zb / (2.0*y);\n\n      // Compute ratio r = x/y\n      double r = x/y;\n      temp = r * HEX_40000000;\n      double ra = r + temp - temp;\n      double rb = r - ra;\n\n      rb += (x - ra*ya - ra*yb - rb*ya - rb*yb) / y;  // Correct for rounding in division\nrb += (((+x * -temp) / y) / y);\n\n      temp = ra + rb;\n      rb = -(temp - ra - rb);\n      ra = temp;\n\n      return atan(ra, rb, false);\n    }",
          "33": "    public static double asin(double x) {\n      if (x != x) {\n          return Double.NaN;\n      }\n\n      if (x > 1.0 || x < -1.0) {\n          return Double.NaN;\n      }\n\n      if (x == 1.0) {\n          return Math.PI/2.0;\n      }\n\n      if (x == -1.0) {\n          return -Math.PI/2.0;\n      }\n\n      if (x == 0.0) { // Matches +/- 0.0; return correct sign\n          return x;\n      }\n\n      /* Compute asin(x) = atan(x/sqrt(1-x*x)) */\n\n      /* Split x */\n      double temp = x * HEX_40000000;\n      final double xa = x + temp - temp;\n      final double xb = x - xa;\n\n      /* Square it */\n      double ya = xa*xa;\n      double yb = xa*xb*2.0 + xb*xb;\n\n      /* Subtract from 1 */\n      ya = -ya;\n      yb = -yb;\n\n      double za = 1.0 + ya;\n      double zb = -(za - 1.0 - ya);\n\n      temp = za + yb;\n      zb += -(temp - za - yb);\n      za = temp;\n\n      /* Square root */\n      double y;\n      y = sqrt(za);\n      temp = y * HEX_40000000;\n      ya = y + temp - temp;\n      yb = y - ya;\n\n      /* Extend precision of sqrt */\n      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      /* Contribution of zb to sqrt */\n      double dx = zb / (2.0*y);\n\n      // Compute ratio r = x/y\n      double r = x/y;\n      temp = r * HEX_40000000;\n      double ra = r + temp - temp;\n      double rb = r - ra;\n\n      rb += (x - ra*ya - ra*yb - rb*ya - rb*yb) / y;  // Correct for rounding in division\nrb += (((+x * dx) / y) / y);\n\n      temp = ra + rb;\n      rb = -(temp - ra - rb);\n      ra = temp;\n\n      return atan(ra, rb, false);\n    }",
          "34": "    public static double asin(double x) {\n      if (x != x) {\n          return Double.NaN;\n      }\n\n      if (x > 1.0 || x < -1.0) {\n          return Double.NaN;\n      }\n\n      if (x == 1.0) {\n          return Math.PI/2.0;\n      }\n\n      if (x == -1.0) {\n          return -Math.PI/2.0;\n      }\n\n      if (x == 0.0) { // Matches +/- 0.0; return correct sign\n          return x;\n      }\n\n      /* Compute asin(x) = atan(x/sqrt(1-x*x)) */\n\n      /* Split x */\n      double temp = x * HEX_40000000;\n      final double xa = x + temp - temp;\n      final double xb = x - xa;\n\n      /* Square it */\n      double ya = xa*xa;\n      double yb = xa*xb*2.0 + xb*xb;\n\n      /* Subtract from 1 */\n      ya = -ya;\n      yb = -yb;\n\n      double za = 1.0 + ya;\n      double zb = -(za - 1.0 - ya);\n\n      temp = za + yb;\n      zb += -(temp - za - yb);\n      za = temp;\n\n      /* Square root */\n      double y;\n      y = sqrt(za);\n      temp = y * HEX_40000000;\n      ya = y + temp - temp;\n      yb = y - ya;\n\n      /* Extend precision of sqrt */\n      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      /* Contribution of zb to sqrt */\n      double dx = zb / (2.0*y);\n\n      // Compute ratio r = x/y\n      double r = x/y;\n      temp = r * HEX_40000000;\n      double ra = r + temp - temp;\n      double rb = r - ra;\n\n      rb += (x - ra*ya - ra*yb - rb*ya - rb*yb) / y;  // Correct for rounding in division\nrb += (((+x * dx) / y) > y);\n\n      temp = ra + rb;\n      rb = -(temp - ra - rb);\n      ra = temp;\n\n      return atan(ra, rb, false);\n    }",
          "35": "    public static double asin(double x) {\n      if (x != x) {\n          return Double.NaN;\n      }\n\n      if (x > 1.0 || x < -1.0) {\n          return Double.NaN;\n      }\n\n      if (x == 1.0) {\n          return Math.PI/2.0;\n      }\n\n      if (x == -1.0) {\n          return -Math.PI/2.0;\n      }\n\n      if (x == 0.0) { // Matches +/- 0.0; return correct sign\n          return x;\n      }\n\n      /* Compute asin(x) = atan(x/sqrt(1-x*x)) */\n\n      /* Split x */\n      double temp = x * HEX_40000000;\n      final double xa = x + temp - temp;\n      final double xb = x - xa;\n\n      /* Square it */\n      double ya = xa*xa;\n      double yb = xa*xb*2.0 + xb*xb;\n\n      /* Subtract from 1 */\n      ya = -ya;\n      yb = -yb;\n\n      double za = 1.0 + ya;\n      double zb = -(za - 1.0 - ya);\n\n      temp = za + yb;\n      zb += -(temp - za - yb);\n      za = temp;\n\n      /* Square root */\n      double y;\n      y = sqrt(za);\n      temp = y * HEX_40000000;\n      ya = y + temp - temp;\n      yb = y - ya;\n\n      /* Extend precision of sqrt */\n      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      /* Contribution of zb to sqrt */\n      double dx = zb / (2.0*y);\n\n      // Compute ratio r = x/y\n      double r = x/y;\n      temp = r * HEX_40000000;\n      double ra = r + temp - temp;\n      double rb = r - ra;\n\n      rb += (x - ra*ya - ra*yb - rb*ya - rb*yb) / y;  // Correct for rounding in division\nrb += (((+x * -dx) / y) / y);\n\n      temp = ra + rb;\n      rb = -(temp - ra - rb);\n      ra = temp;\n\n      return atan(ra, rb, false);\n    }",
          "36": "    public static double asin(double x) {\n      if (x != x) {\n          return Double.NaN;\n      }\n\n      if (x > 1.0 || x < -1.0) {\n          return Double.NaN;\n      }\n\n      if (x == 1.0) {\n          return Math.PI/2.0;\n      }\n\n      if (x == -1.0) {\n          return -Math.PI/2.0;\n      }\n\n      if (x == 0.0) { // Matches +/- 0.0; return correct sign\n          return x;\n      }\n\n      /* Compute asin(x) = atan(x/sqrt(1-x*x)) */\n\n      /* Split x */\n      double temp = x * HEX_40000000;\n      final double xa = x + temp - temp;\n      final double xb = x - xa;\n\n      /* Square it */\n      double ya = xa*xa;\n      double yb = xa*xb*2.0 + xb*xb;\n\n      /* Subtract from 1 */\n      ya = -ya;\n      yb = -yb;\n\n      double za = 1.0 + ya;\n      double zb = -(za - 1.0 - ya);\n\n      temp = za + yb;\n      zb += -(temp - za - yb);\n      za = temp;\n\n      /* Square root */\n      double y;\n      y = sqrt(za);\n      temp = y * HEX_40000000;\n      ya = y + temp - temp;\n      yb = y - ya;\n\n      /* Extend precision of sqrt */\n      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      /* Contribution of zb to sqrt */\n      double dx = zb / (2.0*y);\n\n      // Compute ratio r = x/y\n      double r = x/y;\n      temp = r * HEX_40000000;\n      double ra = r + temp - temp;\n      double rb = r - ra;\n\n      rb += (x - ra*ya - ra*yb - rb*ya - rb*yb) / y;  // Correct for rounding in division\nra;\n\n      temp = ra + rb;\n      rb = -(temp - ra - rb);\n      ra = temp;\n\n      return atan(ra, rb, false);\n    }",
          "37": "    public static double asin(double x) {\n      if (x != x) {\n          return Double.NaN;\n      }\n\n      if (x > 1.0 || x < -1.0) {\n          return Double.NaN;\n      }\n\n      if (x == 1.0) {\n          return Math.PI/2.0;\n      }\n\n      if (x == -1.0) {\n          return -Math.PI/2.0;\n      }\n\n      if (x == 0.0) { // Matches +/- 0.0; return correct sign\n          return x;\n      }\n\n      /* Compute asin(x) = atan(x/sqrt(1-x*x)) */\n\n      /* Split x */\n      double temp = x * HEX_40000000;\n      final double xa = x + temp - temp;\n      final double xb = x - xa;\n\n      /* Square it */\n      double ya = xa*xa;\n      double yb = xa*xb*2.0 + xb*xb;\n\n      /* Subtract from 1 */\n      ya = -ya;\n      yb = -yb;\n\n      double za = 1.0 + ya;\n      double zb = -(za - 1.0 - ya);\n\n      temp = za + yb;\n      zb += -(temp - za - yb);\n      za = temp;\n\n      /* Square root */\n      double y;\n      y = sqrt(za);\n      temp = y * HEX_40000000;\n      ya = y + temp - temp;\n      yb = y - ya;\n\n      /* Extend precision of sqrt */\n      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      /* Contribution of zb to sqrt */\n      double dx = zb / (2.0*y);\n\n      // Compute ratio r = x/y\n      double r = x/y;\n      temp = r * HEX_40000000;\n      double ra = r + temp - temp;\n      double rb = r - ra;\n\n      rb += (x - ra*ya - ra*yb - rb*ya - rb*yb) / y;  // Correct for rounding in division\nrb += (((+x * dx) / y) / ya);\n\n      temp = ra + rb;\n      rb = -(temp - ra - rb);\n      ra = temp;\n\n      return atan(ra, rb, false);\n    }",
          "38": "    public static double asin(double x) {\n      if (x != x) {\n          return Double.NaN;\n      }\n\n      if (x > 1.0 || x < -1.0) {\n          return Double.NaN;\n      }\n\n      if (x == 1.0) {\n          return Math.PI/2.0;\n      }\n\n      if (x == -1.0) {\n          return -Math.PI/2.0;\n      }\n\n      if (x == 0.0) { // Matches +/- 0.0; return correct sign\n          return x;\n      }\n\n      /* Compute asin(x) = atan(x/sqrt(1-x*x)) */\n\n      /* Split x */\n      double temp = x * HEX_40000000;\n      final double xa = x + temp - temp;\n      final double xb = x - xa;\n\n      /* Square it */\n      double ya = xa*xa;\n      double yb = xa*xb*2.0 + xb*xb;\n\n      /* Subtract from 1 */\n      ya = -ya;\n      yb = -yb;\n\n      double za = 1.0 + ya;\n      double zb = -(za - 1.0 - ya);\n\n      temp = za + yb;\n      zb += -(temp - za - yb);\n      za = temp;\n\n      /* Square root */\n      double y;\n      y = sqrt(za);\n      temp = y * HEX_40000000;\n      ya = y + temp - temp;\n      yb = y - ya;\n\n      /* Extend precision of sqrt */\n      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      /* Contribution of zb to sqrt */\n      double dx = zb / (2.0*y);\n\n      // Compute ratio r = x/y\n      double r = x/y;\n      temp = r * HEX_40000000;\n      double ra = r + temp - temp;\n      double rb = r - ra;\n\n      rb += (x - ra*ya - ra*yb - rb*ya - rb*yb) / y;  // Correct for rounding in division\nrb += (((+x * dx) / y) / rb);\n\n      temp = ra + rb;\n      rb = -(temp - ra - rb);\n      ra = temp;\n\n      return atan(ra, rb, false);\n    }",
          "39": "    public static double asin(double x) {\n      if (x != x) {\n          return Double.NaN;\n      }\n\n      if (x > 1.0 || x < -1.0) {\n          return Double.NaN;\n      }\n\n      if (x == 1.0) {\n          return Math.PI/2.0;\n      }\n\n      if (x == -1.0) {\n          return -Math.PI/2.0;\n      }\n\n      if (x == 0.0) { // Matches +/- 0.0; return correct sign\n          return x;\n      }\n\n      /* Compute asin(x) = atan(x/sqrt(1-x*x)) */\n\n      /* Split x */\n      double temp = x * HEX_40000000;\n      final double xa = x + temp - temp;\n      final double xb = x - xa;\n\n      /* Square it */\n      double ya = xa*xa;\n      double yb = xa*xb*2.0 + xb*xb;\n\n      /* Subtract from 1 */\n      ya = -ya;\n      yb = -yb;\n\n      double za = 1.0 + ya;\n      double zb = -(za - 1.0 - ya);\n\n      temp = za + yb;\n      zb += -(temp - za - yb);\n      za = temp;\n\n      /* Square root */\n      double y;\n      y = sqrt(za);\n      temp = y * HEX_40000000;\n      ya = y + temp - temp;\n      yb = y - ya;\n\n      /* Extend precision of sqrt */\n      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      /* Contribution of zb to sqrt */\n      double dx = zb / (2.0*y);\n\n      // Compute ratio r = x/y\n      double r = x/y;\n      temp = r * HEX_40000000;\n      double ra = r + temp - temp;\n      double rb = r - ra;\n\n      rb += (x - ra*ya - ra*yb - rb*ya - rb*yb) / y;  // Correct for rounding in division\nrb += (((+x * dx) / y) * y);\n\n      temp = ra + rb;\n      rb = -(temp - ra - rb);\n      ra = temp;\n\n      return atan(ra, rb, false);\n    }",
          "40": "    public static double asin(double x) {\n      if (x != x) {\n          return Double.NaN;\n      }\n\n      if (x > 1.0 || x < -1.0) {\n          return Double.NaN;\n      }\n\n      if (x == 1.0) {\n          return Math.PI/2.0;\n      }\n\n      if (x == -1.0) {\n          return -Math.PI/2.0;\n      }\n\n      if (x == 0.0) { // Matches +/- 0.0; return correct sign\n          return x;\n      }\n\n      /* Compute asin(x) = atan(x/sqrt(1-x*x)) */\n\n      /* Split x */\n      double temp = x * HEX_40000000;\n      final double xa = x + temp - temp;\n      final double xb = x - xa;\n\n      /* Square it */\n      double ya = xa*xa;\n      double yb = xa*xb*2.0 + xb*xb;\n\n      /* Subtract from 1 */\n      ya = -ya;\n      yb = -yb;\n\n      double za = 1.0 + ya;\n      double zb = -(za - 1.0 - ya);\n\n      temp = za + yb;\n      zb += -(temp - za - yb);\n      za = temp;\n\n      /* Square root */\n      double y;\n      y = sqrt(za);\n      temp = y * HEX_40000000;\n      ya = y + temp - temp;\n      yb = y - ya;\n\n      /* Extend precision of sqrt */\n      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      /* Contribution of zb to sqrt */\n      double dx = zb / (2.0*y);\n\n      // Compute ratio r = x/y\n      double r = x/y;\n      temp = r * HEX_40000000;\n      double ra = r + temp - temp;\n      double rb = r - ra;\n\n      rb += (x - ra*ya - ra*yb - rb*ya - rb*yb) / y;  // Correct for rounding in division\nrb += (((+x * -y) / y) / y);\n\n      temp = ra + rb;\n      rb = -(temp - ra - rb);\n      ra = temp;\n\n      return atan(ra, rb, false);\n    }",
          "41": "    public static double asin(double x) {\n      if (x != x) {\n          return Double.NaN;\n      }\n\n      if (x > 1.0 || x < -1.0) {\n          return Double.NaN;\n      }\n\n      if (x == 1.0) {\n          return Math.PI/2.0;\n      }\n\n      if (x == -1.0) {\n          return -Math.PI/2.0;\n      }\n\n      if (x == 0.0) { // Matches +/- 0.0; return correct sign\n          return x;\n      }\n\n      /* Compute asin(x) = atan(x/sqrt(1-x*x)) */\n\n      /* Split x */\n      double temp = x * HEX_40000000;\n      final double xa = x + temp - temp;\n      final double xb = x - xa;\n\n      /* Square it */\n      double ya = xa*xa;\n      double yb = xa*xb*2.0 + xb*xb;\n\n      /* Subtract from 1 */\n      ya = -ya;\n      yb = -yb;\n\n      double za = 1.0 + ya;\n      double zb = -(za - 1.0 - ya);\n\n      temp = za + yb;\n      zb += -(temp - za - yb);\n      za = temp;\n\n      /* Square root */\n      double y;\n      y = sqrt(za);\n      temp = y * HEX_40000000;\n      ya = y + temp - temp;\n      yb = y - ya;\n\n      /* Extend precision of sqrt */\n      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      /* Contribution of zb to sqrt */\n      double dx = zb / (2.0*y);\n\n      // Compute ratio r = x/y\n      double r = x/y;\n      temp = r * HEX_40000000;\n      double ra = r + temp - temp;\n      double rb = r - ra;\n\n      rb += (x - ra*ya - ra*yb - rb*ya - rb*yb) / y;  // Correct for rounding in division\nrb += (((+x * -rb) / y) / y);\n\n      temp = ra + rb;\n      rb = -(temp - ra - rb);\n      ra = temp;\n\n      return atan(ra, rb, false);\n    }",
          "42": "    public static double asin(double x) {\n      if (x != x) {\n          return Double.NaN;\n      }\n\n      if (x > 1.0 || x < -1.0) {\n          return Double.NaN;\n      }\n\n      if (x == 1.0) {\n          return Math.PI/2.0;\n      }\n\n      if (x == -1.0) {\n          return -Math.PI/2.0;\n      }\n\n      if (x == 0.0) { // Matches +/- 0.0; return correct sign\n          return x;\n      }\n\n      /* Compute asin(x) = atan(x/sqrt(1-x*x)) */\n\n      /* Split x */\n      double temp = x * HEX_40000000;\n      final double xa = x + temp - temp;\n      final double xb = x - xa;\n\n      /* Square it */\n      double ya = xa*xa;\n      double yb = xa*xb*2.0 + xb*xb;\n\n      /* Subtract from 1 */\n      ya = -ya;\n      yb = -yb;\n\n      double za = 1.0 + ya;\n      double zb = -(za - 1.0 - ya);\n\n      temp = za + yb;\n      zb += -(temp - za - yb);\n      za = temp;\n\n      /* Square root */\n      double y;\n      y = sqrt(za);\n      temp = y * HEX_40000000;\n      ya = y + temp - temp;\n      yb = y - ya;\n\n      /* Extend precision of sqrt */\n      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      /* Contribution of zb to sqrt */\n      double dx = zb / (2.0*y);\n\n      // Compute ratio r = x/y\n      double r = x/y;\n      temp = r * HEX_40000000;\n      double ra = r + temp - temp;\n      double rb = r - ra;\n\n      rb += (x - ra*ya - ra*yb - rb*ya - rb*yb) / y;  // Correct for rounding in division\nrb += (((+x * dx) / y) & y);\n\n      temp = ra + rb;\n      rb = -(temp - ra - rb);\n      ra = temp;\n\n      return atan(ra, rb, false);\n    }",
          "43": "    public static double asin(double x) {\n      if (x != x) {\n          return Double.NaN;\n      }\n\n      if (x > 1.0 || x < -1.0) {\n          return Double.NaN;\n      }\n\n      if (x == 1.0) {\n          return Math.PI/2.0;\n      }\n\n      if (x == -1.0) {\n          return -Math.PI/2.0;\n      }\n\n      if (x == 0.0) { // Matches +/- 0.0; return correct sign\n          return x;\n      }\n\n      /* Compute asin(x) = atan(x/sqrt(1-x*x)) */\n\n      /* Split x */\n      double temp = x * HEX_40000000;\n      final double xa = x + temp - temp;\n      final double xb = x - xa;\n\n      /* Square it */\n      double ya = xa*xa;\n      double yb = xa*xb*2.0 + xb*xb;\n\n      /* Subtract from 1 */\n      ya = -ya;\n      yb = -yb;\n\n      double za = 1.0 + ya;\n      double zb = -(za - 1.0 - ya);\n\n      temp = za + yb;\n      zb += -(temp - za - yb);\n      za = temp;\n\n      /* Square root */\n      double y;\n      y = sqrt(za);\n      temp = y * HEX_40000000;\n      ya = y + temp - temp;\n      yb = y - ya;\n\n      /* Extend precision of sqrt */\n      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      /* Contribution of zb to sqrt */\n      double dx = zb / (2.0*y);\n\n      // Compute ratio r = x/y\n      double r = x/y;\n      temp = r * HEX_40000000;\n      double ra = r + temp - temp;\n      double rb = r - ra;\n\n      rb += (x - ra*ya - ra*yb - rb*ya - rb*yb) / y;  // Correct for rounding in division\nrb += (((+x * dx) / y) / -temp);\n\n      temp = ra + rb;\n      rb = -(temp - ra - rb);\n      ra = temp;\n\n      return atan(ra, rb, false);\n    }",
          "44": "    public static double asin(double x) {\n      if (x != x) {\n          return Double.NaN;\n      }\n\n      if (x > 1.0 || x < -1.0) {\n          return Double.NaN;\n      }\n\n      if (x == 1.0) {\n          return Math.PI/2.0;\n      }\n\n      if (x == -1.0) {\n          return -Math.PI/2.0;\n      }\n\n      if (x == 0.0) { // Matches +/- 0.0; return correct sign\n          return x;\n      }\n\n      /* Compute asin(x) = atan(x/sqrt(1-x*x)) */\n\n      /* Split x */\n      double temp = x * HEX_40000000;\n      final double xa = x + temp - temp;\n      final double xb = x - xa;\n\n      /* Square it */\n      double ya = xa*xa;\n      double yb = xa*xb*2.0 + xb*xb;\n\n      /* Subtract from 1 */\n      ya = -ya;\n      yb = -yb;\n\n      double za = 1.0 + ya;\n      double zb = -(za - 1.0 - ya);\n\n      temp = za + yb;\n      zb += -(temp - za - yb);\n      za = temp;\n\n      /* Square root */\n      double y;\n      y = sqrt(za);\n      temp = y * HEX_40000000;\n      ya = y + temp - temp;\n      yb = y - ya;\n\n      /* Extend precision of sqrt */\n      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      /* Contribution of zb to sqrt */\n      double dx = zb / (2.0*y);\n\n      // Compute ratio r = x/y\n      double r = x/y;\n      temp = r * HEX_40000000;\n      double ra = r + temp - temp;\n      double rb = r - ra;\n\n      rb += (x - ra*ya - ra*yb - rb*ya - rb*yb) / y;  // Correct for rounding in division\nrb += (((+x * dx) / y) % y);\n\n      temp = ra + rb;\n      rb = -(temp - ra - rb);\n      ra = temp;\n\n      return atan(ra, rb, false);\n    }",
          "45": "    public static double asin(double x) {\n      if (x != x) {\n          return Double.NaN;\n      }\n\n      if (x > 1.0 || x < -1.0) {\n          return Double.NaN;\n      }\n\n      if (x == 1.0) {\n          return Math.PI/2.0;\n      }\n\n      if (x == -1.0) {\n          return -Math.PI/2.0;\n      }\n\n      if (x == 0.0) { // Matches +/- 0.0; return correct sign\n          return x;\n      }\n\n      /* Compute asin(x) = atan(x/sqrt(1-x*x)) */\n\n      /* Split x */\n      double temp = x * HEX_40000000;\n      final double xa = x + temp - temp;\n      final double xb = x - xa;\n\n      /* Square it */\n      double ya = xa*xa;\n      double yb = xa*xb*2.0 + xb*xb;\n\n      /* Subtract from 1 */\n      ya = -ya;\n      yb = -yb;\n\n      double za = 1.0 + ya;\n      double zb = -(za - 1.0 - ya);\n\n      temp = za + yb;\n      zb += -(temp - za - yb);\n      za = temp;\n\n      /* Square root */\n      double y;\n      y = sqrt(za);\n      temp = y * HEX_40000000;\n      ya = y + temp - temp;\n      yb = y - ya;\n\n      /* Extend precision of sqrt */\n      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      /* Contribution of zb to sqrt */\n      double dx = zb / (2.0*y);\n\n      // Compute ratio r = x/y\n      double r = x/y;\n      temp = r * HEX_40000000;\n      double ra = r + temp - temp;\n      double rb = r - ra;\n\n      rb += (x - ra*ya - ra*yb - rb*ya - rb*yb) / y;  // Correct for rounding in division\nrb += (((+x * dx) / y) / -ra);\n\n      temp = ra + rb;\n      rb = -(temp - ra - rb);\n      ra = temp;\n\n      return atan(ra, rb, false);\n    }",
          "46": "    public static double asin(double x) {\n      if (x != x) {\n          return Double.NaN;\n      }\n\n      if (x > 1.0 || x < -1.0) {\n          return Double.NaN;\n      }\n\n      if (x == 1.0) {\n          return Math.PI/2.0;\n      }\n\n      if (x == -1.0) {\n          return -Math.PI/2.0;\n      }\n\n      if (x == 0.0) { // Matches +/- 0.0; return correct sign\n          return x;\n      }\n\n      /* Compute asin(x) = atan(x/sqrt(1-x*x)) */\n\n      /* Split x */\n      double temp = x * HEX_40000000;\n      final double xa = x + temp - temp;\n      final double xb = x - xa;\n\n      /* Square it */\n      double ya = xa*xa;\n      double yb = xa*xb*2.0 + xb*xb;\n\n      /* Subtract from 1 */\n      ya = -ya;\n      yb = -yb;\n\n      double za = 1.0 + ya;\n      double zb = -(za - 1.0 - ya);\n\n      temp = za + yb;\n      zb += -(temp - za - yb);\n      za = temp;\n\n      /* Square root */\n      double y;\n      y = sqrt(za);\n      temp = y * HEX_40000000;\n      ya = y + temp - temp;\n      yb = y - ya;\n\n      /* Extend precision of sqrt */\n      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      /* Contribution of zb to sqrt */\n      double dx = zb / (2.0*y);\n\n      // Compute ratio r = x/y\n      double r = x/y;\n      temp = r * HEX_40000000;\n      double ra = r + temp - temp;\n      double rb = r - ra;\n\n      rb += (x - ra*ya - ra*yb - rb*ya - rb*yb) / y;  // Correct for rounding in division\nrb += (((+x - dx) / y) / y);\n\n      temp = ra + rb;\n      rb = -(temp - ra - rb);\n      ra = temp;\n\n      return atan(ra, rb, false);\n    }",
          "47": "    public static double asin(double x) {\n      if (x != x) {\n          return Double.NaN;\n      }\n\n      if (x > 1.0 || x < -1.0) {\n          return Double.NaN;\n      }\n\n      if (x == 1.0) {\n          return Math.PI/2.0;\n      }\n\n      if (x == -1.0) {\n          return -Math.PI/2.0;\n      }\n\n      if (x == 0.0) { // Matches +/- 0.0; return correct sign\n          return x;\n      }\n\n      /* Compute asin(x) = atan(x/sqrt(1-x*x)) */\n\n      /* Split x */\n      double temp = x * HEX_40000000;\n      final double xa = x + temp - temp;\n      final double xb = x - xa;\n\n      /* Square it */\n      double ya = xa*xa;\n      double yb = xa*xb*2.0 + xb*xb;\n\n      /* Subtract from 1 */\n      ya = -ya;\n      yb = -yb;\n\n      double za = 1.0 + ya;\n      double zb = -(za - 1.0 - ya);\n\n      temp = za + yb;\n      zb += -(temp - za - yb);\n      za = temp;\n\n      /* Square root */\n      double y;\n      y = sqrt(za);\n      temp = y * HEX_40000000;\n      ya = y + temp - temp;\n      yb = y - ya;\n\n      /* Extend precision of sqrt */\n      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      /* Contribution of zb to sqrt */\n      double dx = zb / (2.0*y);\n\n      // Compute ratio r = x/y\n      double r = x/y;\n      temp = r * HEX_40000000;\n      double ra = r + temp - temp;\n      double rb = r - ra;\n\n      rb += (x - ra*ya - ra*yb - rb*ya - rb*yb) / y;  // Correct for rounding in division\nrb += (((+x <= dx) / y) / y);\n\n      temp = ra + rb;\n      rb = -(temp - ra - rb);\n      ra = temp;\n\n      return atan(ra, rb, false);\n    }",
          "48": "    public static double asin(double x) {\n      if (x != x) {\n          return Double.NaN;\n      }\n\n      if (x > 1.0 || x < -1.0) {\n          return Double.NaN;\n      }\n\n      if (x == 1.0) {\n          return Math.PI/2.0;\n      }\n\n      if (x == -1.0) {\n          return -Math.PI/2.0;\n      }\n\n      if (x == 0.0) { // Matches +/- 0.0; return correct sign\n          return x;\n      }\n\n      /* Compute asin(x) = atan(x/sqrt(1-x*x)) */\n\n      /* Split x */\n      double temp = x * HEX_40000000;\n      final double xa = x + temp - temp;\n      final double xb = x - xa;\n\n      /* Square it */\n      double ya = xa*xa;\n      double yb = xa*xb*2.0 + xb*xb;\n\n      /* Subtract from 1 */\n      ya = -ya;\n      yb = -yb;\n\n      double za = 1.0 + ya;\n      double zb = -(za - 1.0 - ya);\n\n      temp = za + yb;\n      zb += -(temp - za - yb);\n      za = temp;\n\n      /* Square root */\n      double y;\n      y = sqrt(za);\n      temp = y * HEX_40000000;\n      ya = y + temp - temp;\n      yb = y - ya;\n\n      /* Extend precision of sqrt */\n      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      /* Contribution of zb to sqrt */\n      double dx = zb / (2.0*y);\n\n      // Compute ratio r = x/y\n      double r = x/y;\n      temp = r * HEX_40000000;\n      double ra = r + temp - temp;\n      double rb = r - ra;\n\n      rb += (x - ra*ya - ra*yb - rb*ya - rb*yb) / y;  // Correct for rounding in division\nrb += (((+x * dx) >> y) / y);\n\n      temp = ra + rb;\n      rb = -(temp - ra - rb);\n      ra = temp;\n\n      return atan(ra, rb, false);\n    }",
          "49": "    public static double asin(double x) {\n      if (x != x) {\n          return Double.NaN;\n      }\n\n      if (x > 1.0 || x < -1.0) {\n          return Double.NaN;\n      }\n\n      if (x == 1.0) {\n          return Math.PI/2.0;\n      }\n\n      if (x == -1.0) {\n          return -Math.PI/2.0;\n      }\n\n      if (x == 0.0) { // Matches +/- 0.0; return correct sign\n          return x;\n      }\n\n      /* Compute asin(x) = atan(x/sqrt(1-x*x)) */\n\n      /* Split x */\n      double temp = x * HEX_40000000;\n      final double xa = x + temp - temp;\n      final double xb = x - xa;\n\n      /* Square it */\n      double ya = xa*xa;\n      double yb = xa*xb*2.0 + xb*xb;\n\n      /* Subtract from 1 */\n      ya = -ya;\n      yb = -yb;\n\n      double za = 1.0 + ya;\n      double zb = -(za - 1.0 - ya);\n\n      temp = za + yb;\n      zb += -(temp - za - yb);\n      za = temp;\n\n      /* Square root */\n      double y;\n      y = sqrt(za);\n      temp = y * HEX_40000000;\n      ya = y + temp - temp;\n      yb = y - ya;\n\n      /* Extend precision of sqrt */\n      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      /* Contribution of zb to sqrt */\n      double dx = zb / (2.0*y);\n\n      // Compute ratio r = x/y\n      double r = x/y;\n      temp = r * HEX_40000000;\n      double ra = r + temp - temp;\n      double rb = r - ra;\n\n      rb += (x - ra*ya - ra*yb - rb*ya - rb*yb) / y;  // Correct for rounding in division\nra = temp;\n      rb += +x * dx / y / y;  // Add in effect additional bits of sqrt.\n      temp = ra + rb;\n      rb = -(temp - ra - rb);\n      ra = temp;\n\n      return atan(ra, rb, false);\n    }",
          "50": "    public static double asin(double x) {\n      if (x != x) {\n          return Double.NaN;\n      }\n\n      if (x > 1.0 || x < -1.0) {\n          return Double.NaN;\n      }\n\n      if (x == 1.0) {\n          return Math.PI/2.0;\n      }\n\n      if (x == -1.0) {\n          return -Math.PI/2.0;\n      }\n\n      if (x == 0.0) { // Matches +/- 0.0; return correct sign\n          return x;\n      }\n\n      /* Compute asin(x) = atan(x/sqrt(1-x*x)) */\n\n      /* Split x */\n      double temp = x * HEX_40000000;\n      final double xa = x + temp - temp;\n      final double xb = x - xa;\n\n      /* Square it */\n      double ya = xa*xa;\n      double yb = xa*xb*2.0 + xb*xb;\n\n      /* Subtract from 1 */\n      ya = -ya;\n      yb = -yb;\n\n      double za = 1.0 + ya;\n      double zb = -(za - 1.0 - ya);\n\n      temp = za + yb;\n      zb += -(temp - za - yb);\n      za = temp;\n\n      /* Square root */\n      double y;\n      y = sqrt(za);\n      temp = y * HEX_40000000;\n      ya = y + temp - temp;\n      yb = y - ya;\n\n      /* Extend precision of sqrt */\n      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      /* Contribution of zb to sqrt */\n      double dx = zb / (2.0*y);\n\n      // Compute ratio r = x/y\n      double r = x/y;\n      temp = r * HEX_40000000;\n      double ra = r + temp - temp;\n      double rb = r - ra;\n\n      rb += (x - ra*ya - ra*yb - rb*ya - rb*yb) / y;  // Correct for rounding in division\nrb += (((+x + dx) / y) / y);\n\n      temp = ra + rb;\n      rb = -(temp - ra - rb);\n      ra = temp;\n\n      return atan(ra, rb, false);\n    }",
          "51": "    public static double asin(double x) {\n      if (x != x) {\n          return Double.NaN;\n      }\n\n      if (x > 1.0 || x < -1.0) {\n          return Double.NaN;\n      }\n\n      if (x == 1.0) {\n          return Math.PI/2.0;\n      }\n\n      if (x == -1.0) {\n          return -Math.PI/2.0;\n      }\n\n      if (x == 0.0) { // Matches +/- 0.0; return correct sign\n          return x;\n      }\n\n      /* Compute asin(x) = atan(x/sqrt(1-x*x)) */\n\n      /* Split x */\n      double temp = x * HEX_40000000;\n      final double xa = x + temp - temp;\n      final double xb = x - xa;\n\n      /* Square it */\n      double ya = xa*xa;\n      double yb = xa*xb*2.0 + xb*xb;\n\n      /* Subtract from 1 */\n      ya = -ya;\n      yb = -yb;\n\n      double za = 1.0 + ya;\n      double zb = -(za - 1.0 - ya);\n\n      temp = za + yb;\n      zb += -(temp - za - yb);\n      za = temp;\n\n      /* Square root */\n      double y;\n      y = sqrt(za);\n      temp = y * HEX_40000000;\n      ya = y + temp - temp;\n      yb = y - ya;\n\n      /* Extend precision of sqrt */\n      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      /* Contribution of zb to sqrt */\n      double dx = zb / (2.0*y);\n\n      // Compute ratio r = x/y\n      double r = x/y;\n      temp = r * HEX_40000000;\n      double ra = r + temp - temp;\n      double rb = r - ra;\n\n      rb += (x - ra*ya - ra*yb - rb*ya - rb*yb) / y;  // Correct for rounding in division\nrb += (((+x >= dx) / y) / y);\n\n      temp = ra + rb;\n      rb = -(temp - ra - rb);\n      ra = temp;\n\n      return atan(ra, rb, false);\n    }",
          "52": "    public static double asin(double x) {\n      if (x != x) {\n          return Double.NaN;\n      }\n\n      if (x > 1.0 || x < -1.0) {\n          return Double.NaN;\n      }\n\n      if (x == 1.0) {\n          return Math.PI/2.0;\n      }\n\n      if (x == -1.0) {\n          return -Math.PI/2.0;\n      }\n\n      if (x == 0.0) { // Matches +/- 0.0; return correct sign\n          return x;\n      }\n\n      /* Compute asin(x) = atan(x/sqrt(1-x*x)) */\n\n      /* Split x */\n      double temp = x * HEX_40000000;\n      final double xa = x + temp - temp;\n      final double xb = x - xa;\n\n      /* Square it */\n      double ya = xa*xa;\n      double yb = xa*xb*2.0 + xb*xb;\n\n      /* Subtract from 1 */\n      ya = -ya;\n      yb = -yb;\n\n      double za = 1.0 + ya;\n      double zb = -(za - 1.0 - ya);\n\n      temp = za + yb;\n      zb += -(temp - za - yb);\n      za = temp;\n\n      /* Square root */\n      double y;\n      y = sqrt(za);\n      temp = y * HEX_40000000;\n      ya = y + temp - temp;\n      yb = y - ya;\n\n      /* Extend precision of sqrt */\n      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      /* Contribution of zb to sqrt */\n      double dx = zb / (2.0*y);\n\n      // Compute ratio r = x/y\n      double r = x/y;\n      temp = r * HEX_40000000;\n      double ra = r + temp - temp;\n      double rb = r - ra;\n\n      rb += (x - ra*ya - ra*yb - rb*ya - rb*yb) / y;  // Correct for rounding in division\nrb = ((dx * dx) + y);\n\n      temp = ra + rb;\n      rb = -(temp - ra - rb);\n      ra = temp;\n\n      return atan(ra, rb, false);\n    }",
          "53": "    public static double asin(double x) {\n      if (x != x) {\n          return Double.NaN;\n      }\n\n      if (x > 1.0 || x < -1.0) {\n          return Double.NaN;\n      }\n\n      if (x == 1.0) {\n          return Math.PI/2.0;\n      }\n\n      if (x == -1.0) {\n          return -Math.PI/2.0;\n      }\n\n      if (x == 0.0) { // Matches +/- 0.0; return correct sign\n          return x;\n      }\n\n      /* Compute asin(x) = atan(x/sqrt(1-x*x)) */\n\n      /* Split x */\n      double temp = x * HEX_40000000;\n      final double xa = x + temp - temp;\n      final double xb = x - xa;\n\n      /* Square it */\n      double ya = xa*xa;\n      double yb = xa*xb*2.0 + xb*xb;\n\n      /* Subtract from 1 */\n      ya = -ya;\n      yb = -yb;\n\n      double za = 1.0 + ya;\n      double zb = -(za - 1.0 - ya);\n\n      temp = za + yb;\n      zb += -(temp - za - yb);\n      za = temp;\n\n      /* Square root */\n      double y;\n      y = sqrt(za);\n      temp = y * HEX_40000000;\n      ya = y + temp - temp;\n      yb = y - ya;\n\n      /* Extend precision of sqrt */\n      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      /* Contribution of zb to sqrt */\n      double dx = zb / (2.0*y);\n\n      // Compute ratio r = x/y\n      double r = x/y;\n      temp = r * HEX_40000000;\n      double ra = r + temp - temp;\n      double rb = r - ra;\n\n      rb += (x - ra*ya - ra*yb - rb*ya - rb*yb) / y;  // Correct for rounding in division\nrb = ((dx / dx) + y);\n\n      temp = ra + rb;\n      rb = -(temp - ra - rb);\n      ra = temp;\n\n      return atan(ra, rb, false);\n    }",
          "54": "    public static double asin(double x) {\n      if (x != x) {\n          return Double.NaN;\n      }\n\n      if (x > 1.0 || x < -1.0) {\n          return Double.NaN;\n      }\n\n      if (x == 1.0) {\n          return Math.PI/2.0;\n      }\n\n      if (x == -1.0) {\n          return -Math.PI/2.0;\n      }\n\n      if (x == 0.0) { // Matches +/- 0.0; return correct sign\n          return x;\n      }\n\n      /* Compute asin(x) = atan(x/sqrt(1-x*x)) */\n\n      /* Split x */\n      double temp = x * HEX_40000000;\n      final double xa = x + temp - temp;\n      final double xb = x - xa;\n\n      /* Square it */\n      double ya = xa*xa;\n      double yb = xa*xb*2.0 + xb*xb;\n\n      /* Subtract from 1 */\n      ya = -ya;\n      yb = -yb;\n\n      double za = 1.0 + ya;\n      double zb = -(za - 1.0 - ya);\n\n      temp = za + yb;\n      zb += -(temp - za - yb);\n      za = temp;\n\n      /* Square root */\n      double y;\n      y = sqrt(za);\n      temp = y * HEX_40000000;\n      ya = y + temp - temp;\n      yb = y - ya;\n\n      /* Extend precision of sqrt */\n      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      /* Contribution of zb to sqrt */\n      double dx = zb / (2.0*y);\n\n      // Compute ratio r = x/y\n      double r = x/y;\n      temp = r * HEX_40000000;\n      double ra = r + temp - temp;\n      double rb = r - ra;\n\n      rb += (x - ra*ya - ra*yb - rb*ya - rb*yb) / y;  // Correct for rounding in division\nrb = ((dx * dx) - y);\n\n      temp = ra + rb;\n      rb = -(temp - ra - rb);\n      ra = temp;\n\n      return atan(ra, rb, false);\n    }",
          "55": "    public static double asin(double x) {\n      if (x != x) {\n          return Double.NaN;\n      }\n\n      if (x > 1.0 || x < -1.0) {\n          return Double.NaN;\n      }\n\n      if (x == 1.0) {\n          return Math.PI/2.0;\n      }\n\n      if (x == -1.0) {\n          return -Math.PI/2.0;\n      }\n\n      if (x == 0.0) { // Matches +/- 0.0; return correct sign\n          return x;\n      }\n\n      /* Compute asin(x) = atan(x/sqrt(1-x*x)) */\n\n      /* Split x */\n      double temp = x * HEX_40000000;\n      final double xa = x + temp - temp;\n      final double xb = x - xa;\n\n      /* Square it */\n      double ya = xa*xa;\n      double yb = xa*xb*2.0 + xb*xb;\n\n      /* Subtract from 1 */\n      ya = -ya;\n      yb = -yb;\n\n      double za = 1.0 + ya;\n      double zb = -(za - 1.0 - ya);\n\n      temp = za + yb;\n      zb += -(temp - za - yb);\n      za = temp;\n\n      /* Square root */\n      double y;\n      y = sqrt(za);\n      temp = y * HEX_40000000;\n      ya = y + temp - temp;\n      yb = y - ya;\n\n      /* Extend precision of sqrt */\n      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      /* Contribution of zb to sqrt */\n      double dx = zb / (2.0*y);\n\n      // Compute ratio r = x/y\n      double r = x/y;\n      temp = r * HEX_40000000;\n      double ra = r + temp - temp;\n      double rb = r - ra;\n\n      rb += (x - ra*ya - ra*yb - rb*ya - rb*yb) / y;  // Correct for rounding in division\nrb += ((dx * dx) + y);\n\n      temp = ra + rb;\n      rb = -(temp - ra - rb);\n      ra = temp;\n\n      return atan(ra, rb, false);\n    }",
          "56": "    public static double asin(double x) {\n      if (x != x) {\n          return Double.NaN;\n      }\n\n      if (x > 1.0 || x < -1.0) {\n          return Double.NaN;\n      }\n\n      if (x == 1.0) {\n          return Math.PI/2.0;\n      }\n\n      if (x == -1.0) {\n          return -Math.PI/2.0;\n      }\n\n      if (x == 0.0) { // Matches +/- 0.0; return correct sign\n          return x;\n      }\n\n      /* Compute asin(x) = atan(x/sqrt(1-x*x)) */\n\n      /* Split x */\n      double temp = x * HEX_40000000;\n      final double xa = x + temp - temp;\n      final double xb = x - xa;\n\n      /* Square it */\n      double ya = xa*xa;\n      double yb = xa*xb*2.0 + xb*xb;\n\n      /* Subtract from 1 */\n      ya = -ya;\n      yb = -yb;\n\n      double za = 1.0 + ya;\n      double zb = -(za - 1.0 - ya);\n\n      temp = za + yb;\n      zb += -(temp - za - yb);\n      za = temp;\n\n      /* Square root */\n      double y;\n      y = sqrt(za);\n      temp = y * HEX_40000000;\n      ya = y + temp - temp;\n      yb = y - ya;\n\n      /* Extend precision of sqrt */\n      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      /* Contribution of zb to sqrt */\n      double dx = zb / (2.0*y);\n\n      // Compute ratio r = x/y\n      double r = x/y;\n      temp = r * HEX_40000000;\n      double ra = r + temp - temp;\n      double rb = r - ra;\n\n      rb += (x - ra*ya - ra*yb - rb*ya - rb*yb) / y;  // Correct for rounding in division\nrb = ((dx / dx) - y);\n\n      temp = ra + rb;\n      rb = -(temp - ra - rb);\n      ra = temp;\n\n      return atan(ra, rb, false);\n    }",
          "57": "    public static double asin(double x) {\n      if (x != x) {\n          return Double.NaN;\n      }\n\n      if (x > 1.0 || x < -1.0) {\n          return Double.NaN;\n      }\n\n      if (x == 1.0) {\n          return Math.PI/2.0;\n      }\n\n      if (x == -1.0) {\n          return -Math.PI/2.0;\n      }\n\n      if (x == 0.0) { // Matches +/- 0.0; return correct sign\n          return x;\n      }\n\n      /* Compute asin(x) = atan(x/sqrt(1-x*x)) */\n\n      /* Split x */\n      double temp = x * HEX_40000000;\n      final double xa = x + temp - temp;\n      final double xb = x - xa;\n\n      /* Square it */\n      double ya = xa*xa;\n      double yb = xa*xb*2.0 + xb*xb;\n\n      /* Subtract from 1 */\n      ya = -ya;\n      yb = -yb;\n\n      double za = 1.0 + ya;\n      double zb = -(za - 1.0 - ya);\n\n      temp = za + yb;\n      zb += -(temp - za - yb);\n      za = temp;\n\n      /* Square root */\n      double y;\n      y = sqrt(za);\n      temp = y * HEX_40000000;\n      ya = y + temp - temp;\n      yb = y - ya;\n\n      /* Extend precision of sqrt */\n      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      /* Contribution of zb to sqrt */\n      double dx = zb / (2.0*y);\n\n      // Compute ratio r = x/y\n      double r = x/y;\n      temp = r * HEX_40000000;\n      double ra = r + temp - temp;\n      double rb = r - ra;\n\n      rb += (x - ra*ya - ra*yb - rb*ya - rb*yb) / y;  // Correct for rounding in division\nrb = ((dx * dx) + dx);\n\n      temp = ra + rb;\n      rb = -(temp - ra - rb);\n      ra = temp;\n\n      return atan(ra, rb, false);\n    }",
          "58": "    public static double asin(double x) {\n      if (x != x) {\n          return Double.NaN;\n      }\n\n      if (x > 1.0 || x < -1.0) {\n          return Double.NaN;\n      }\n\n      if (x == 1.0) {\n          return Math.PI/2.0;\n      }\n\n      if (x == -1.0) {\n          return -Math.PI/2.0;\n      }\n\n      if (x == 0.0) { // Matches +/- 0.0; return correct sign\n          return x;\n      }\n\n      /* Compute asin(x) = atan(x/sqrt(1-x*x)) */\n\n      /* Split x */\n      double temp = x * HEX_40000000;\n      final double xa = x + temp - temp;\n      final double xb = x - xa;\n\n      /* Square it */\n      double ya = xa*xa;\n      double yb = xa*xb*2.0 + xb*xb;\n\n      /* Subtract from 1 */\n      ya = -ya;\n      yb = -yb;\n\n      double za = 1.0 + ya;\n      double zb = -(za - 1.0 - ya);\n\n      temp = za + yb;\n      zb += -(temp - za - yb);\n      za = temp;\n\n      /* Square root */\n      double y;\n      y = sqrt(za);\n      temp = y * HEX_40000000;\n      ya = y + temp - temp;\n      yb = y - ya;\n\n      /* Extend precision of sqrt */\n      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      /* Contribution of zb to sqrt */\n      double dx = zb / (2.0*y);\n\n      // Compute ratio r = x/y\n      double r = x/y;\n      temp = r * HEX_40000000;\n      double ra = r + temp - temp;\n      double rb = r - ra;\n\n      rb += (x - ra*ya - ra*yb - rb*ya - rb*yb) / y;  // Correct for rounding in division\nrb += ((dx / dx) + y);\n\n      temp = ra + rb;\n      rb = -(temp - ra - rb);\n      ra = temp;\n\n      return atan(ra, rb, false);\n    }",
          "59": "    public static double asin(double x) {\n      if (x != x) {\n          return Double.NaN;\n      }\n\n      if (x > 1.0 || x < -1.0) {\n          return Double.NaN;\n      }\n\n      if (x == 1.0) {\n          return Math.PI/2.0;\n      }\n\n      if (x == -1.0) {\n          return -Math.PI/2.0;\n      }\n\n      if (x == 0.0) { // Matches +/- 0.0; return correct sign\n          return x;\n      }\n\n      /* Compute asin(x) = atan(x/sqrt(1-x*x)) */\n\n      /* Split x */\n      double temp = x * HEX_40000000;\n      final double xa = x + temp - temp;\n      final double xb = x - xa;\n\n      /* Square it */\n      double ya = xa*xa;\n      double yb = xa*xb*2.0 + xb*xb;\n\n      /* Subtract from 1 */\n      ya = -ya;\n      yb = -yb;\n\n      double za = 1.0 + ya;\n      double zb = -(za - 1.0 - ya);\n\n      temp = za + yb;\n      zb += -(temp - za - yb);\n      za = temp;\n\n      /* Square root */\n      double y;\n      y = sqrt(za);\n      temp = y * HEX_40000000;\n      ya = y + temp - temp;\n      yb = y - ya;\n\n      /* Extend precision of sqrt */\n      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      /* Contribution of zb to sqrt */\n      double dx = zb / (2.0*y);\n\n      // Compute ratio r = x/y\n      double r = x/y;\n      temp = r * HEX_40000000;\n      double ra = r + temp - temp;\n      double rb = r - ra;\n\n      rb += (x - ra*ya - ra*yb - rb*ya - rb*yb) / y;  // Correct for rounding in division\nrb += ((dx * dx) + dx);\n\n      temp = ra + rb;\n      rb = -(temp - ra - rb);\n      ra = temp;\n\n      return atan(ra, rb, false);\n    }",
          "60": "    public static double asin(double x) {\n      if (x != x) {\n          return Double.NaN;\n      }\n\n      if (x > 1.0 || x < -1.0) {\n          return Double.NaN;\n      }\n\n      if (x == 1.0) {\n          return Math.PI/2.0;\n      }\n\n      if (x == -1.0) {\n          return -Math.PI/2.0;\n      }\n\n      if (x == 0.0) { // Matches +/- 0.0; return correct sign\n          return x;\n      }\n\n      /* Compute asin(x) = atan(x/sqrt(1-x*x)) */\n\n      /* Split x */\n      double temp = x * HEX_40000000;\n      final double xa = x + temp - temp;\n      final double xb = x - xa;\n\n      /* Square it */\n      double ya = xa*xa;\n      double yb = xa*xb*2.0 + xb*xb;\n\n      /* Subtract from 1 */\n      ya = -ya;\n      yb = -yb;\n\n      double za = 1.0 + ya;\n      double zb = -(za - 1.0 - ya);\n\n      temp = za + yb;\n      zb += -(temp - za - yb);\n      za = temp;\n\n      /* Square root */\n      double y;\n      y = sqrt(za);\n      temp = y * HEX_40000000;\n      ya = y + temp - temp;\n      yb = y - ya;\n\n      /* Extend precision of sqrt */\n      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      /* Contribution of zb to sqrt */\n      double dx = zb / (2.0*y);\n\n      // Compute ratio r = x/y\n      double r = x/y;\n      temp = r * HEX_40000000;\n      double ra = r + temp - temp;\n      double rb = r - ra;\n\n      rb += (x - ra*ya - ra*yb - rb*ya - rb*yb) / y;  // Correct for rounding in division\nrb = ((dx / dx) + dx);\n\n      temp = ra + rb;\n      rb = -(temp - ra - rb);\n      ra = temp;\n\n      return atan(ra, rb, false);\n    }",
          "61": "    public static double asin(double x) {\n      if (x != x) {\n          return Double.NaN;\n      }\n\n      if (x > 1.0 || x < -1.0) {\n          return Double.NaN;\n      }\n\n      if (x == 1.0) {\n          return Math.PI/2.0;\n      }\n\n      if (x == -1.0) {\n          return -Math.PI/2.0;\n      }\n\n      if (x == 0.0) { // Matches +/- 0.0; return correct sign\n          return x;\n      }\n\n      /* Compute asin(x) = atan(x/sqrt(1-x*x)) */\n\n      /* Split x */\n      double temp = x * HEX_40000000;\n      final double xa = x + temp - temp;\n      final double xb = x - xa;\n\n      /* Square it */\n      double ya = xa*xa;\n      double yb = xa*xb*2.0 + xb*xb;\n\n      /* Subtract from 1 */\n      ya = -ya;\n      yb = -yb;\n\n      double za = 1.0 + ya;\n      double zb = -(za - 1.0 - ya);\n\n      temp = za + yb;\n      zb += -(temp - za - yb);\n      za = temp;\n\n      /* Square root */\n      double y;\n      y = sqrt(za);\n      temp = y * HEX_40000000;\n      ya = y + temp - temp;\n      yb = y - ya;\n\n      /* Extend precision of sqrt */\n      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      /* Contribution of zb to sqrt */\n      double dx = zb / (2.0*y);\n\n      // Compute ratio r = x/y\n      double r = x/y;\n      temp = r * HEX_40000000;\n      double ra = r + temp - temp;\n      double rb = r - ra;\n\n      rb += (x - ra*ya - ra*yb - rb*ya - rb*yb) / y;  // Correct for rounding in division\nrb += ((dx / dx) + dx);\n\n      temp = ra + rb;\n      rb = -(temp - ra - rb);\n      ra = temp;\n\n      return atan(ra, rb, false);\n    }",
          "62": "    public static double asin(double x) {\n      if (x != x) {\n          return Double.NaN;\n      }\n\n      if (x > 1.0 || x < -1.0) {\n          return Double.NaN;\n      }\n\n      if (x == 1.0) {\n          return Math.PI/2.0;\n      }\n\n      if (x == -1.0) {\n          return -Math.PI/2.0;\n      }\n\n      if (x == 0.0) { // Matches +/- 0.0; return correct sign\n          return x;\n      }\n\n      /* Compute asin(x) = atan(x/sqrt(1-x*x)) */\n\n      /* Split x */\n      double temp = x * HEX_40000000;\n      final double xa = x + temp - temp;\n      final double xb = x - xa;\n\n      /* Square it */\n      double ya = xa*xa;\n      double yb = xa*xb*2.0 + xb*xb;\n\n      /* Subtract from 1 */\n      ya = -ya;\n      yb = -yb;\n\n      double za = 1.0 + ya;\n      double zb = -(za - 1.0 - ya);\n\n      temp = za + yb;\n      zb += -(temp - za - yb);\n      za = temp;\n\n      /* Square root */\n      double y;\n      y = sqrt(za);\n      temp = y * HEX_40000000;\n      ya = y + temp - temp;\n      yb = y - ya;\n\n      /* Extend precision of sqrt */\n      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      /* Contribution of zb to sqrt */\n      double dx = zb / (2.0*y);\n\n      // Compute ratio r = x/y\n      double r = x/y;\n      temp = r * HEX_40000000;\n      double ra = r + temp - temp;\n      double rb = r - ra;\n\n      rb += (x - ra*ya - ra*yb - rb*ya - rb*yb) / y;  // Correct for rounding in division\nrb = ((dx * dx) - dx);\n\n      temp = ra + rb;\n      rb = -(temp - ra - rb);\n      ra = temp;\n\n      return atan(ra, rb, false);\n    }",
          "63": "    public static double asin(double x) {\n      if (x != x) {\n          return Double.NaN;\n      }\n\n      if (x > 1.0 || x < -1.0) {\n          return Double.NaN;\n      }\n\n      if (x == 1.0) {\n          return Math.PI/2.0;\n      }\n\n      if (x == -1.0) {\n          return -Math.PI/2.0;\n      }\n\n      if (x == 0.0) { // Matches +/- 0.0; return correct sign\n          return x;\n      }\n\n      /* Compute asin(x) = atan(x/sqrt(1-x*x)) */\n\n      /* Split x */\n      double temp = x * HEX_40000000;\n      final double xa = x + temp - temp;\n      final double xb = x - xa;\n\n      /* Square it */\n      double ya = xa*xa;\n      double yb = xa*xb*2.0 + xb*xb;\n\n      /* Subtract from 1 */\n      ya = -ya;\n      yb = -yb;\n\n      double za = 1.0 + ya;\n      double zb = -(za - 1.0 - ya);\n\n      temp = za + yb;\n      zb += -(temp - za - yb);\n      za = temp;\n\n      /* Square root */\n      double y;\n      y = sqrt(za);\n      temp = y * HEX_40000000;\n      ya = y + temp - temp;\n      yb = y - ya;\n\n      /* Extend precision of sqrt */\n      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      /* Contribution of zb to sqrt */\n      double dx = zb / (2.0*y);\n\n      // Compute ratio r = x/y\n      double r = x/y;\n      temp = r * HEX_40000000;\n      double ra = r + temp - temp;\n      double rb = r - ra;\n\n      rb += (x - ra*ya - ra*yb - rb*ya - rb*yb) / y;  // Correct for rounding in division\nrb += ((dx * dx) - dx);\n\n      temp = ra + rb;\n      rb = -(temp - ra - rb);\n      ra = temp;\n\n      return atan(ra, rb, false);\n    }",
          "64": "    public static double asin(double x) {\n      if (x != x) {\n          return Double.NaN;\n      }\n\n      if (x > 1.0 || x < -1.0) {\n          return Double.NaN;\n      }\n\n      if (x == 1.0) {\n          return Math.PI/2.0;\n      }\n\n      if (x == -1.0) {\n          return -Math.PI/2.0;\n      }\n\n      if (x == 0.0) { // Matches +/- 0.0; return correct sign\n          return x;\n      }\n\n      /* Compute asin(x) = atan(x/sqrt(1-x*x)) */\n\n      /* Split x */\n      double temp = x * HEX_40000000;\n      final double xa = x + temp - temp;\n      final double xb = x - xa;\n\n      /* Square it */\n      double ya = xa*xa;\n      double yb = xa*xb*2.0 + xb*xb;\n\n      /* Subtract from 1 */\n      ya = -ya;\n      yb = -yb;\n\n      double za = 1.0 + ya;\n      double zb = -(za - 1.0 - ya);\n\n      temp = za + yb;\n      zb += -(temp - za - yb);\n      za = temp;\n\n      /* Square root */\n      double y;\n      y = sqrt(za);\n      temp = y * HEX_40000000;\n      ya = y + temp - temp;\n      yb = y - ya;\n\n      /* Extend precision of sqrt */\n      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      /* Contribution of zb to sqrt */\n      double dx = zb / (2.0*y);\n\n      // Compute ratio r = x/y\n      double r = x/y;\n      temp = r * HEX_40000000;\n      double ra = r + temp - temp;\n      double rb = r - ra;\n\n      rb += (x - ra*ya - ra*yb - rb*ya - rb*yb) / y;  // Correct for rounding in division\nrb = ((dx / dx) - dx);\n\n      temp = ra + rb;\n      rb = -(temp - ra - rb);\n      ra = temp;\n\n      return atan(ra, rb, false);\n    }",
          "65": "    public static double asin(double x) {\n      if (x != x) {\n          return Double.NaN;\n      }\n\n      if (x > 1.0 || x < -1.0) {\n          return Double.NaN;\n      }\n\n      if (x == 1.0) {\n          return Math.PI/2.0;\n      }\n\n      if (x == -1.0) {\n          return -Math.PI/2.0;\n      }\n\n      if (x == 0.0) { // Matches +/- 0.0; return correct sign\n          return x;\n      }\n\n      /* Compute asin(x) = atan(x/sqrt(1-x*x)) */\n\n      /* Split x */\n      double temp = x * HEX_40000000;\n      final double xa = x + temp - temp;\n      final double xb = x - xa;\n\n      /* Square it */\n      double ya = xa*xa;\n      double yb = xa*xb*2.0 + xb*xb;\n\n      /* Subtract from 1 */\n      ya = -ya;\n      yb = -yb;\n\n      double za = 1.0 + ya;\n      double zb = -(za - 1.0 - ya);\n\n      temp = za + yb;\n      zb += -(temp - za - yb);\n      za = temp;\n\n      /* Square root */\n      double y;\n      y = sqrt(za);\n      temp = y * HEX_40000000;\n      ya = y + temp - temp;\n      yb = y - ya;\n\n      /* Extend precision of sqrt */\n      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      /* Contribution of zb to sqrt */\n      double dx = zb / (2.0*y);\n\n      // Compute ratio r = x/y\n      double r = x/y;\n      temp = r * HEX_40000000;\n      double ra = r + temp - temp;\n      double rb = r - ra;\n\n      rb += (x - ra*ya - ra*yb - rb*ya - rb*yb) / y;  // Correct for rounding in division\nrb += (((dx * dx) * y) + y);\n\n      temp = ra + rb;\n      rb = -(temp - ra - rb);\n      ra = temp;\n\n      return atan(ra, rb, false);\n    }",
          "66": "    public static double asin(double x) {\n      if (x != x) {\n          return Double.NaN;\n      }\n\n      if (x > 1.0 || x < -1.0) {\n          return Double.NaN;\n      }\n\n      if (x == 1.0) {\n          return Math.PI/2.0;\n      }\n\n      if (x == -1.0) {\n          return -Math.PI/2.0;\n      }\n\n      if (x == 0.0) { // Matches +/- 0.0; return correct sign\n          return x;\n      }\n\n      /* Compute asin(x) = atan(x/sqrt(1-x*x)) */\n\n      /* Split x */\n      double temp = x * HEX_40000000;\n      final double xa = x + temp - temp;\n      final double xb = x - xa;\n\n      /* Square it */\n      double ya = xa*xa;\n      double yb = xa*xb*2.0 + xb*xb;\n\n      /* Subtract from 1 */\n      ya = -ya;\n      yb = -yb;\n\n      double za = 1.0 + ya;\n      double zb = -(za - 1.0 - ya);\n\n      temp = za + yb;\n      zb += -(temp - za - yb);\n      za = temp;\n\n      /* Square root */\n      double y;\n      y = sqrt(za);\n      temp = y * HEX_40000000;\n      ya = y + temp - temp;\n      yb = y - ya;\n\n      /* Extend precision of sqrt */\n      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      /* Contribution of zb to sqrt */\n      double dx = zb / (2.0*y);\n\n      // Compute ratio r = x/y\n      double r = x/y;\n      temp = r * HEX_40000000;\n      double ra = r + temp - temp;\n      double rb = r - ra;\n\n      rb += (x - ra*ya - ra*yb - rb*ya - rb*yb) / y;  // Correct for rounding in division\nrb += (((dx * dx) * y) + dx);\n\n      temp = ra + rb;\n      rb = -(temp - ra - rb);\n      ra = temp;\n\n      return atan(ra, rb, false);\n    }",
          "67": "    public static double asin(double x) {\n      if (x != x) {\n          return Double.NaN;\n      }\n\n      if (x > 1.0 || x < -1.0) {\n          return Double.NaN;\n      }\n\n      if (x == 1.0) {\n          return Math.PI/2.0;\n      }\n\n      if (x == -1.0) {\n          return -Math.PI/2.0;\n      }\n\n      if (x == 0.0) { // Matches +/- 0.0; return correct sign\n          return x;\n      }\n\n      /* Compute asin(x) = atan(x/sqrt(1-x*x)) */\n\n      /* Split x */\n      double temp = x * HEX_40000000;\n      final double xa = x + temp - temp;\n      final double xb = x - xa;\n\n      /* Square it */\n      double ya = xa*xa;\n      double yb = xa*xb*2.0 + xb*xb;\n\n      /* Subtract from 1 */\n      ya = -ya;\n      yb = -yb;\n\n      double za = 1.0 + ya;\n      double zb = -(za - 1.0 - ya);\n\n      temp = za + yb;\n      zb += -(temp - za - yb);\n      za = temp;\n\n      /* Square root */\n      double y;\n      y = sqrt(za);\n      temp = y * HEX_40000000;\n      ya = y + temp - temp;\n      yb = y - ya;\n\n      /* Extend precision of sqrt */\n      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      /* Contribution of zb to sqrt */\n      double dx = zb / (2.0*y);\n\n      // Compute ratio r = x/y\n      double r = x/y;\n      temp = r * HEX_40000000;\n      double ra = r + temp - temp;\n      double rb = r - ra;\n\n      rb += (x - ra*ya - ra*yb - rb*ya - rb*yb) / y;  // Correct for rounding in division\nrb = (((dx * dx) * y) + dx);\n\n      temp = ra + rb;\n      rb = -(temp - ra - rb);\n      ra = temp;\n\n      return atan(ra, rb, false);\n    }",
          "68": "    public static double asin(double x) {\n      if (x != x) {\n          return Double.NaN;\n      }\n\n      if (x > 1.0 || x < -1.0) {\n          return Double.NaN;\n      }\n\n      if (x == 1.0) {\n          return Math.PI/2.0;\n      }\n\n      if (x == -1.0) {\n          return -Math.PI/2.0;\n      }\n\n      if (x == 0.0) { // Matches +/- 0.0; return correct sign\n          return x;\n      }\n\n      /* Compute asin(x) = atan(x/sqrt(1-x*x)) */\n\n      /* Split x */\n      double temp = x * HEX_40000000;\n      final double xa = x + temp - temp;\n      final double xb = x - xa;\n\n      /* Square it */\n      double ya = xa*xa;\n      double yb = xa*xb*2.0 + xb*xb;\n\n      /* Subtract from 1 */\n      ya = -ya;\n      yb = -yb;\n\n      double za = 1.0 + ya;\n      double zb = -(za - 1.0 - ya);\n\n      temp = za + yb;\n      zb += -(temp - za - yb);\n      za = temp;\n\n      /* Square root */\n      double y;\n      y = sqrt(za);\n      temp = y * HEX_40000000;\n      ya = y + temp - temp;\n      yb = y - ya;\n\n      /* Extend precision of sqrt */\n      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      /* Contribution of zb to sqrt */\n      double dx = zb / (2.0*y);\n\n      // Compute ratio r = x/y\n      double r = x/y;\n      temp = r * HEX_40000000;\n      double ra = r + temp - temp;\n      double rb = r - ra;\n\n      rb += (x - ra*ya - ra*yb - rb*ya - rb*yb) / y;  // Correct for rounding in division\nreturn;\n      rb += +x * dx / y / y;  // Add in effect additional bits of sqrt.\n      temp = ra + rb;\n      rb = -(temp - ra - rb);\n      ra = temp;\n\n      return atan(ra, rb, false);\n    }",
          "69": "    public static double asin(double x) {\n      if (x != x) {\n          return Double.NaN;\n      }\n\n      if (x > 1.0 || x < -1.0) {\n          return Double.NaN;\n      }\n\n      if (x == 1.0) {\n          return Math.PI/2.0;\n      }\n\n      if (x == -1.0) {\n          return -Math.PI/2.0;\n      }\n\n      if (x == 0.0) { // Matches +/- 0.0; return correct sign\n          return x;\n      }\n\n      /* Compute asin(x) = atan(x/sqrt(1-x*x)) */\n\n      /* Split x */\n      double temp = x * HEX_40000000;\n      final double xa = x + temp - temp;\n      final double xb = x - xa;\n\n      /* Square it */\n      double ya = xa*xa;\n      double yb = xa*xb*2.0 + xb*xb;\n\n      /* Subtract from 1 */\n      ya = -ya;\n      yb = -yb;\n\n      double za = 1.0 + ya;\n      double zb = -(za - 1.0 - ya);\n\n      temp = za + yb;\n      zb += -(temp - za - yb);\n      za = temp;\n\n      /* Square root */\n      double y;\n      y = sqrt(za);\n      temp = y * HEX_40000000;\n      ya = y + temp - temp;\n      yb = y - ya;\n\n      /* Extend precision of sqrt */\n      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      /* Contribution of zb to sqrt */\n      double dx = zb / (2.0*y);\n\n      // Compute ratio r = x/y\n      double r = x/y;\n      temp = r * HEX_40000000;\n      double ra = r + temp - temp;\n      double rb = r - ra;\n\n      rb += (x - ra*ya - ra*yb - rb*ya - rb*yb) / y;  // Correct for rounding in division\nrb = (((dx * dx) * dx) + y);\n\n      temp = ra + rb;\n      rb = -(temp - ra - rb);\n      ra = temp;\n\n      return atan(ra, rb, false);\n    }",
          "70": "    public static double asin(double x) {\n      if (x != x) {\n          return Double.NaN;\n      }\n\n      if (x > 1.0 || x < -1.0) {\n          return Double.NaN;\n      }\n\n      if (x == 1.0) {\n          return Math.PI/2.0;\n      }\n\n      if (x == -1.0) {\n          return -Math.PI/2.0;\n      }\n\n      if (x == 0.0) { // Matches +/- 0.0; return correct sign\n          return x;\n      }\n\n      /* Compute asin(x) = atan(x/sqrt(1-x*x)) */\n\n      /* Split x */\n      double temp = x * HEX_40000000;\n      final double xa = x + temp - temp;\n      final double xb = x - xa;\n\n      /* Square it */\n      double ya = xa*xa;\n      double yb = xa*xb*2.0 + xb*xb;\n\n      /* Subtract from 1 */\n      ya = -ya;\n      yb = -yb;\n\n      double za = 1.0 + ya;\n      double zb = -(za - 1.0 - ya);\n\n      temp = za + yb;\n      zb += -(temp - za - yb);\n      za = temp;\n\n      /* Square root */\n      double y;\n      y = sqrt(za);\n      temp = y * HEX_40000000;\n      ya = y + temp - temp;\n      yb = y - ya;\n\n      /* Extend precision of sqrt */\n      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      /* Contribution of zb to sqrt */\n      double dx = zb / (2.0*y);\n\n      // Compute ratio r = x/y\n      double r = x/y;\n      temp = r * HEX_40000000;\n      double ra = r + temp - temp;\n      double rb = r - ra;\n\n      rb += (x - ra*ya - ra*yb - rb*ya - rb*yb) / y;  // Correct for rounding in division\nrb += (((dx / dx) * y) + dx);\n\n      temp = ra + rb;\n      rb = -(temp - ra - rb);\n      ra = temp;\n\n      return atan(ra, rb, false);\n    }",
          "71": "    public static double asin(double x) {\n      if (x != x) {\n          return Double.NaN;\n      }\n\n      if (x > 1.0 || x < -1.0) {\n          return Double.NaN;\n      }\n\n      if (x == 1.0) {\n          return Math.PI/2.0;\n      }\n\n      if (x == -1.0) {\n          return -Math.PI/2.0;\n      }\n\n      if (x == 0.0) { // Matches +/- 0.0; return correct sign\n          return x;\n      }\n\n      /* Compute asin(x) = atan(x/sqrt(1-x*x)) */\n\n      /* Split x */\n      double temp = x * HEX_40000000;\n      final double xa = x + temp - temp;\n      final double xb = x - xa;\n\n      /* Square it */\n      double ya = xa*xa;\n      double yb = xa*xb*2.0 + xb*xb;\n\n      /* Subtract from 1 */\n      ya = -ya;\n      yb = -yb;\n\n      double za = 1.0 + ya;\n      double zb = -(za - 1.0 - ya);\n\n      temp = za + yb;\n      zb += -(temp - za - yb);\n      za = temp;\n\n      /* Square root */\n      double y;\n      y = sqrt(za);\n      temp = y * HEX_40000000;\n      ya = y + temp - temp;\n      yb = y - ya;\n\n      /* Extend precision of sqrt */\n      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      /* Contribution of zb to sqrt */\n      double dx = zb / (2.0*y);\n\n      // Compute ratio r = x/y\n      double r = x/y;\n      temp = r * HEX_40000000;\n      double ra = r + temp - temp;\n      double rb = r - ra;\n\n      rb += (x - ra*ya - ra*yb - rb*ya - rb*yb) / y;  // Correct for rounding in division\nrb = (((dx / dx) * y) + dx);\n\n      temp = ra + rb;\n      rb = -(temp - ra - rb);\n      ra = temp;\n\n      return atan(ra, rb, false);\n    }",
          "72": "    public static double asin(double x) {\n      if (x != x) {\n          return Double.NaN;\n      }\n\n      if (x > 1.0 || x < -1.0) {\n          return Double.NaN;\n      }\n\n      if (x == 1.0) {\n          return Math.PI/2.0;\n      }\n\n      if (x == -1.0) {\n          return -Math.PI/2.0;\n      }\n\n      if (x == 0.0) { // Matches +/- 0.0; return correct sign\n          return x;\n      }\n\n      /* Compute asin(x) = atan(x/sqrt(1-x*x)) */\n\n      /* Split x */\n      double temp = x * HEX_40000000;\n      final double xa = x + temp - temp;\n      final double xb = x - xa;\n\n      /* Square it */\n      double ya = xa*xa;\n      double yb = xa*xb*2.0 + xb*xb;\n\n      /* Subtract from 1 */\n      ya = -ya;\n      yb = -yb;\n\n      double za = 1.0 + ya;\n      double zb = -(za - 1.0 - ya);\n\n      temp = za + yb;\n      zb += -(temp - za - yb);\n      za = temp;\n\n      /* Square root */\n      double y;\n      y = sqrt(za);\n      temp = y * HEX_40000000;\n      ya = y + temp - temp;\n      yb = y - ya;\n\n      /* Extend precision of sqrt */\n      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      /* Contribution of zb to sqrt */\n      double dx = zb / (2.0*y);\n\n      // Compute ratio r = x/y\n      double r = x/y;\n      temp = r * HEX_40000000;\n      double ra = r + temp - temp;\n      double rb = r - ra;\n\n      rb += (x - ra*ya - ra*yb - rb*ya - rb*yb) / y;  // Correct for rounding in division\nrb = (((dx / dx) * dx) + y);\n\n      temp = ra + rb;\n      rb = -(temp - ra - rb);\n      ra = temp;\n\n      return atan(ra, rb, false);\n    }",
          "73": "    public static double asin(double x) {\n      if (x != x) {\n          return Double.NaN;\n      }\n\n      if (x > 1.0 || x < -1.0) {\n          return Double.NaN;\n      }\n\n      if (x == 1.0) {\n          return Math.PI/2.0;\n      }\n\n      if (x == -1.0) {\n          return -Math.PI/2.0;\n      }\n\n      if (x == 0.0) { // Matches +/- 0.0; return correct sign\n          return x;\n      }\n\n      /* Compute asin(x) = atan(x/sqrt(1-x*x)) */\n\n      /* Split x */\n      double temp = x * HEX_40000000;\n      final double xa = x + temp - temp;\n      final double xb = x - xa;\n\n      /* Square it */\n      double ya = xa*xa;\n      double yb = xa*xb*2.0 + xb*xb;\n\n      /* Subtract from 1 */\n      ya = -ya;\n      yb = -yb;\n\n      double za = 1.0 + ya;\n      double zb = -(za - 1.0 - ya);\n\n      temp = za + yb;\n      zb += -(temp - za - yb);\n      za = temp;\n\n      /* Square root */\n      double y;\n      y = sqrt(za);\n      temp = y * HEX_40000000;\n      ya = y + temp - temp;\n      yb = y - ya;\n\n      /* Extend precision of sqrt */\n      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      /* Contribution of zb to sqrt */\n      double dx = zb / (2.0*y);\n\n      // Compute ratio r = x/y\n      double r = x/y;\n      temp = r * HEX_40000000;\n      double ra = r + temp - temp;\n      double rb = r - ra;\n\n      rb += (x - ra*ya - ra*yb - rb*ya - rb*yb) / y;  // Correct for rounding in division\nrb += (((dx * dx) * dx) + y);\n\n      temp = ra + rb;\n      rb = -(temp - ra - rb);\n      ra = temp;\n\n      return atan(ra, rb, false);\n    }",
          "74": "    public static double asin(double x) {\n      if (x != x) {\n          return Double.NaN;\n      }\n\n      if (x > 1.0 || x < -1.0) {\n          return Double.NaN;\n      }\n\n      if (x == 1.0) {\n          return Math.PI/2.0;\n      }\n\n      if (x == -1.0) {\n          return -Math.PI/2.0;\n      }\n\n      if (x == 0.0) { // Matches +/- 0.0; return correct sign\n          return x;\n      }\n\n      /* Compute asin(x) = atan(x/sqrt(1-x*x)) */\n\n      /* Split x */\n      double temp = x * HEX_40000000;\n      final double xa = x + temp - temp;\n      final double xb = x - xa;\n\n      /* Square it */\n      double ya = xa*xa;\n      double yb = xa*xb*2.0 + xb*xb;\n\n      /* Subtract from 1 */\n      ya = -ya;\n      yb = -yb;\n\n      double za = 1.0 + ya;\n      double zb = -(za - 1.0 - ya);\n\n      temp = za + yb;\n      zb += -(temp - za - yb);\n      za = temp;\n\n      /* Square root */\n      double y;\n      y = sqrt(za);\n      temp = y * HEX_40000000;\n      ya = y + temp - temp;\n      yb = y - ya;\n\n      /* Extend precision of sqrt */\n      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n\n      /* Contribution of zb to sqrt */\n      double dx = zb / (2.0*y);\n\n      // Compute ratio r = x/y\n      double r = x/y;\n      temp = r * HEX_40000000;\n      double ra = r + temp - temp;\n      double rb = r - ra;\n\n      rb += (x - ra*ya - ra*yb - rb*ya - rb*yb) / y;  // Correct for rounding in division\nrb += (((dx * dx) / y) + dx);\n\n      temp = ra + rb;\n      rb = -(temp - ra - rb);\n      ra = temp;\n\n      return atan(ra, rb, false);\n    }"
}