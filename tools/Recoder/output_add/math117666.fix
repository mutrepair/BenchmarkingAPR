{
          "0": "    public static double cbrt(double x) {\n      /* Convert input double to bits */\n      long inbits = Double.doubleToRawLongBits(x);\n      int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n      boolean subnormal = false;\n\n      if (exponent == -1023) {\n          if (x == 0) {\n              return x;\n          }\n\n          /* Subnormal, so normalize */\n          subnormal = true;\n          x *= 1.8014398509481984E16;  // 2^54\n          inbits = Double.doubleToRawLongBits(x);\n          exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n      }\n\n      if (exponent == 1024) {\n          // Nan or infinity.  Don't care which.\n          return x;\n      }\n\n      /* Divide the exponent by 3 */\n      int exp3 = exponent / 3;\n\n      /* p2 will be the nearest power of 2 to x with its exponent divided by 3 */\ndouble p2 = Double.longBitsToDouble(((inbits & 0x8000000000000000L) | ((long)((exp3 + 1023) | 2047) << 1)));\n\n      /* This will be a number between 1 and 2 */\n      final double mant = Double.longBitsToDouble((inbits & 0x000fffffffffffffL) | 0x3ff0000000000000L);\n\n      /* Estimate the cube root of mant by polynomial */\n      double est = -0.010714690733195933;\n      est = est * mant + 0.0875862700108075;\n      est = est * mant + -0.3058015757857271;\n      est = est * mant + 0.7249995199969751;\n      est = est * mant + 0.5039018405998233;\n\n      est *= CBRTTWO[exponent % 3 + 2];\n\n      // est should now be good to about 15 bits of precision.   Do 2 rounds of\n      // Newton's method to get closer,  this should get us full double precision\n      // Scale down x for the purpose of doing newtons method.  This avoids over/under flows.\n      final double xs = x / (p2*p2*p2);\n      est += (xs - est*est*est) / (3*est*est);\n      est += (xs - est*est*est) / (3*est*est);\n\n      // Do one round of Newton's method in extended precision to get the last bit right.\n      double temp = est * HEX_40000000;\n      double ya = est + temp - temp;\n      double yb = est - ya;\n\n      double za = ya * ya;\n      double zb = ya * yb * 2.0 + yb * yb;\n      temp = za * HEX_40000000;\n      double temp2 = za + temp - temp;\n      zb += za - temp2;\n      za = temp2;\n\n      zb = za * yb + ya * zb + zb * yb;\n      za = za * ya;\n\n      double na = xs - za;\n      double nb = -(na - xs + za);\n      nb -= zb;\n\n      est += (na+nb)/(3*est*est);\n\n      /* Scale by a power of two, so this is exact. */\n      est *= p2;\n\n      if (subnormal) {\n          est *= 3.814697265625E-6;  // 2^-18\n      }\n\n      return est;\n    }",
          "1": "    public static double cbrt(double x) {\n      /* Convert input double to bits */\n      long inbits = Double.doubleToRawLongBits(x);\n      int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n      boolean subnormal = false;\n\n      if (exponent == -1023) {\n          if (x == 0) {\n              return x;\n          }\n\n          /* Subnormal, so normalize */\n          subnormal = true;\n          x *= 1.8014398509481984E16;  // 2^54\n          inbits = Double.doubleToRawLongBits(x);\n          exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n      }\n\n      if (exponent == 1024) {\n          // Nan or infinity.  Don't care which.\n          return x;\n      }\n\n      /* Divide the exponent by 3 */\n      int exp3 = exponent / 3;\n\n      /* p2 will be the nearest power of 2 to x with its exponent divided by 3 */\ndouble p2 = Double.longBitsToDouble(((inbits & 0x8000000000000000L) | ((long)((exp3 + 1023) | 2047) << 2)));\n\n      /* This will be a number between 1 and 2 */\n      final double mant = Double.longBitsToDouble((inbits & 0x000fffffffffffffL) | 0x3ff0000000000000L);\n\n      /* Estimate the cube root of mant by polynomial */\n      double est = -0.010714690733195933;\n      est = est * mant + 0.0875862700108075;\n      est = est * mant + -0.3058015757857271;\n      est = est * mant + 0.7249995199969751;\n      est = est * mant + 0.5039018405998233;\n\n      est *= CBRTTWO[exponent % 3 + 2];\n\n      // est should now be good to about 15 bits of precision.   Do 2 rounds of\n      // Newton's method to get closer,  this should get us full double precision\n      // Scale down x for the purpose of doing newtons method.  This avoids over/under flows.\n      final double xs = x / (p2*p2*p2);\n      est += (xs - est*est*est) / (3*est*est);\n      est += (xs - est*est*est) / (3*est*est);\n\n      // Do one round of Newton's method in extended precision to get the last bit right.\n      double temp = est * HEX_40000000;\n      double ya = est + temp - temp;\n      double yb = est - ya;\n\n      double za = ya * ya;\n      double zb = ya * yb * 2.0 + yb * yb;\n      temp = za * HEX_40000000;\n      double temp2 = za + temp - temp;\n      zb += za - temp2;\n      za = temp2;\n\n      zb = za * yb + ya * zb + zb * yb;\n      za = za * ya;\n\n      double na = xs - za;\n      double nb = -(na - xs + za);\n      nb -= zb;\n\n      est += (na+nb)/(3*est*est);\n\n      /* Scale by a power of two, so this is exact. */\n      est *= p2;\n\n      if (subnormal) {\n          est *= 3.814697265625E-6;  // 2^-18\n      }\n\n      return est;\n    }",
          "2": "    public static double cbrt(double x) {\n      /* Convert input double to bits */\n      long inbits = Double.doubleToRawLongBits(x);\n      int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n      boolean subnormal = false;\n\n      if (exponent == -1023) {\n          if (x == 0) {\n              return x;\n          }\n\n          /* Subnormal, so normalize */\n          subnormal = true;\n          x *= 1.8014398509481984E16;  // 2^54\n          inbits = Double.doubleToRawLongBits(x);\n          exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n      }\n\n      if (exponent == 1024) {\n          // Nan or infinity.  Don't care which.\n          return x;\n      }\n\n      /* Divide the exponent by 3 */\n      int exp3 = exponent / 3;\n\n      /* p2 will be the nearest power of 2 to x with its exponent divided by 3 */\ndouble p2 = Double.longBitsToDouble(((inbits & 0x8000000000000000L) | ((long)((exp3 + 1023) | 1) << 52)));\n\n      /* This will be a number between 1 and 2 */\n      final double mant = Double.longBitsToDouble((inbits & 0x000fffffffffffffL) | 0x3ff0000000000000L);\n\n      /* Estimate the cube root of mant by polynomial */\n      double est = -0.010714690733195933;\n      est = est * mant + 0.0875862700108075;\n      est = est * mant + -0.3058015757857271;\n      est = est * mant + 0.7249995199969751;\n      est = est * mant + 0.5039018405998233;\n\n      est *= CBRTTWO[exponent % 3 + 2];\n\n      // est should now be good to about 15 bits of precision.   Do 2 rounds of\n      // Newton's method to get closer,  this should get us full double precision\n      // Scale down x for the purpose of doing newtons method.  This avoids over/under flows.\n      final double xs = x / (p2*p2*p2);\n      est += (xs - est*est*est) / (3*est*est);\n      est += (xs - est*est*est) / (3*est*est);\n\n      // Do one round of Newton's method in extended precision to get the last bit right.\n      double temp = est * HEX_40000000;\n      double ya = est + temp - temp;\n      double yb = est - ya;\n\n      double za = ya * ya;\n      double zb = ya * yb * 2.0 + yb * yb;\n      temp = za * HEX_40000000;\n      double temp2 = za + temp - temp;\n      zb += za - temp2;\n      za = temp2;\n\n      zb = za * yb + ya * zb + zb * yb;\n      za = za * ya;\n\n      double na = xs - za;\n      double nb = -(na - xs + za);\n      nb -= zb;\n\n      est += (na+nb)/(3*est*est);\n\n      /* Scale by a power of two, so this is exact. */\n      est *= p2;\n\n      if (subnormal) {\n          est *= 3.814697265625E-6;  // 2^-18\n      }\n\n      return est;\n    }",
          "3": "    public static double cbrt(double x) {\n      /* Convert input double to bits */\n      long inbits = Double.doubleToRawLongBits(x);\n      int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n      boolean subnormal = false;\n\n      if (exponent == -1023) {\n          if (x == 0) {\n              return x;\n          }\n\n          /* Subnormal, so normalize */\n          subnormal = true;\n          x *= 1.8014398509481984E16;  // 2^54\n          inbits = Double.doubleToRawLongBits(x);\n          exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n      }\n\n      if (exponent == 1024) {\n          // Nan or infinity.  Don't care which.\n          return x;\n      }\n\n      /* Divide the exponent by 3 */\n      int exp3 = exponent / 3;\n\n      /* p2 will be the nearest power of 2 to x with its exponent divided by 3 */\ndouble p2 = Double.longBitsToDouble(((inbits & 0x8000000000000000L) | ((long)((exp3 + 1) | 2047) << 52)));\n\n      /* This will be a number between 1 and 2 */\n      final double mant = Double.longBitsToDouble((inbits & 0x000fffffffffffffL) | 0x3ff0000000000000L);\n\n      /* Estimate the cube root of mant by polynomial */\n      double est = -0.010714690733195933;\n      est = est * mant + 0.0875862700108075;\n      est = est * mant + -0.3058015757857271;\n      est = est * mant + 0.7249995199969751;\n      est = est * mant + 0.5039018405998233;\n\n      est *= CBRTTWO[exponent % 3 + 2];\n\n      // est should now be good to about 15 bits of precision.   Do 2 rounds of\n      // Newton's method to get closer,  this should get us full double precision\n      // Scale down x for the purpose of doing newtons method.  This avoids over/under flows.\n      final double xs = x / (p2*p2*p2);\n      est += (xs - est*est*est) / (3*est*est);\n      est += (xs - est*est*est) / (3*est*est);\n\n      // Do one round of Newton's method in extended precision to get the last bit right.\n      double temp = est * HEX_40000000;\n      double ya = est + temp - temp;\n      double yb = est - ya;\n\n      double za = ya * ya;\n      double zb = ya * yb * 2.0 + yb * yb;\n      temp = za * HEX_40000000;\n      double temp2 = za + temp - temp;\n      zb += za - temp2;\n      za = temp2;\n\n      zb = za * yb + ya * zb + zb * yb;\n      za = za * ya;\n\n      double na = xs - za;\n      double nb = -(na - xs + za);\n      nb -= zb;\n\n      est += (na+nb)/(3*est*est);\n\n      /* Scale by a power of two, so this is exact. */\n      est *= p2;\n\n      if (subnormal) {\n          est *= 3.814697265625E-6;  // 2^-18\n      }\n\n      return est;\n    }",
          "4": "    public static double cbrt(double x) {\n      /* Convert input double to bits */\n      long inbits = Double.doubleToRawLongBits(x);\n      int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n      boolean subnormal = false;\n\n      if (exponent == -1023) {\n          if (x == 0) {\n              return x;\n          }\n\n          /* Subnormal, so normalize */\n          subnormal = true;\n          x *= 1.8014398509481984E16;  // 2^54\n          inbits = Double.doubleToRawLongBits(x);\n          exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n      }\n\n      if (exponent == 1024) {\n          // Nan or infinity.  Don't care which.\n          return x;\n      }\n\n      /* Divide the exponent by 3 */\n      int exp3 = exponent / 3;\n\n      /* p2 will be the nearest power of 2 to x with its exponent divided by 3 */\ndouble p2 = Double.longBitsToDouble(((inbits & 0x8000000000000000L) | ((long)((exp3 + 1023) | 2) << 52)));\n\n      /* This will be a number between 1 and 2 */\n      final double mant = Double.longBitsToDouble((inbits & 0x000fffffffffffffL) | 0x3ff0000000000000L);\n\n      /* Estimate the cube root of mant by polynomial */\n      double est = -0.010714690733195933;\n      est = est * mant + 0.0875862700108075;\n      est = est * mant + -0.3058015757857271;\n      est = est * mant + 0.7249995199969751;\n      est = est * mant + 0.5039018405998233;\n\n      est *= CBRTTWO[exponent % 3 + 2];\n\n      // est should now be good to about 15 bits of precision.   Do 2 rounds of\n      // Newton's method to get closer,  this should get us full double precision\n      // Scale down x for the purpose of doing newtons method.  This avoids over/under flows.\n      final double xs = x / (p2*p2*p2);\n      est += (xs - est*est*est) / (3*est*est);\n      est += (xs - est*est*est) / (3*est*est);\n\n      // Do one round of Newton's method in extended precision to get the last bit right.\n      double temp = est * HEX_40000000;\n      double ya = est + temp - temp;\n      double yb = est - ya;\n\n      double za = ya * ya;\n      double zb = ya * yb * 2.0 + yb * yb;\n      temp = za * HEX_40000000;\n      double temp2 = za + temp - temp;\n      zb += za - temp2;\n      za = temp2;\n\n      zb = za * yb + ya * zb + zb * yb;\n      za = za * ya;\n\n      double na = xs - za;\n      double nb = -(na - xs + za);\n      nb -= zb;\n\n      est += (na+nb)/(3*est*est);\n\n      /* Scale by a power of two, so this is exact. */\n      est *= p2;\n\n      if (subnormal) {\n          est *= 3.814697265625E-6;  // 2^-18\n      }\n\n      return est;\n    }",
          "5": "    public static double cbrt(double x) {\n      /* Convert input double to bits */\n      long inbits = Double.doubleToRawLongBits(x);\n      int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n      boolean subnormal = false;\n\n      if (exponent == -1023) {\n          if (x == 0) {\n              return x;\n          }\n\n          /* Subnormal, so normalize */\n          subnormal = true;\n          x *= 1.8014398509481984E16;  // 2^54\n          inbits = Double.doubleToRawLongBits(x);\n          exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n      }\n\n      if (exponent == 1024) {\n          // Nan or infinity.  Don't care which.\n          return x;\n      }\n\n      /* Divide the exponent by 3 */\n      int exp3 = exponent / 3;\n\n      /* p2 will be the nearest power of 2 to x with its exponent divided by 3 */\ndouble p2 = Double.longBitsToDouble(((inbits & 0x8000000000000000L) | ((long)((exp3 + 1023) | 2047) << 0)));\n\n      /* This will be a number between 1 and 2 */\n      final double mant = Double.longBitsToDouble((inbits & 0x000fffffffffffffL) | 0x3ff0000000000000L);\n\n      /* Estimate the cube root of mant by polynomial */\n      double est = -0.010714690733195933;\n      est = est * mant + 0.0875862700108075;\n      est = est * mant + -0.3058015757857271;\n      est = est * mant + 0.7249995199969751;\n      est = est * mant + 0.5039018405998233;\n\n      est *= CBRTTWO[exponent % 3 + 2];\n\n      // est should now be good to about 15 bits of precision.   Do 2 rounds of\n      // Newton's method to get closer,  this should get us full double precision\n      // Scale down x for the purpose of doing newtons method.  This avoids over/under flows.\n      final double xs = x / (p2*p2*p2);\n      est += (xs - est*est*est) / (3*est*est);\n      est += (xs - est*est*est) / (3*est*est);\n\n      // Do one round of Newton's method in extended precision to get the last bit right.\n      double temp = est * HEX_40000000;\n      double ya = est + temp - temp;\n      double yb = est - ya;\n\n      double za = ya * ya;\n      double zb = ya * yb * 2.0 + yb * yb;\n      temp = za * HEX_40000000;\n      double temp2 = za + temp - temp;\n      zb += za - temp2;\n      za = temp2;\n\n      zb = za * yb + ya * zb + zb * yb;\n      za = za * ya;\n\n      double na = xs - za;\n      double nb = -(na - xs + za);\n      nb -= zb;\n\n      est += (na+nb)/(3*est*est);\n\n      /* Scale by a power of two, so this is exact. */\n      est *= p2;\n\n      if (subnormal) {\n          est *= 3.814697265625E-6;  // 2^-18\n      }\n\n      return est;\n    }",
          "6": "    public static double cbrt(double x) {\n      /* Convert input double to bits */\n      long inbits = Double.doubleToRawLongBits(x);\n      int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n      boolean subnormal = false;\n\n      if (exponent == -1023) {\n          if (x == 0) {\n              return x;\n          }\n\n          /* Subnormal, so normalize */\n          subnormal = true;\n          x *= 1.8014398509481984E16;  // 2^54\n          inbits = Double.doubleToRawLongBits(x);\n          exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n      }\n\n      if (exponent == 1024) {\n          // Nan or infinity.  Don't care which.\n          return x;\n      }\n\n      /* Divide the exponent by 3 */\n      int exp3 = exponent / 3;\n\n      /* p2 will be the nearest power of 2 to x with its exponent divided by 3 */\ndouble p2 = Double.longBitsToDouble(((inbits & 0x8000000000000000L) | ((long)((exp3 + 2) | 2047) << 52)));\n\n      /* This will be a number between 1 and 2 */\n      final double mant = Double.longBitsToDouble((inbits & 0x000fffffffffffffL) | 0x3ff0000000000000L);\n\n      /* Estimate the cube root of mant by polynomial */\n      double est = -0.010714690733195933;\n      est = est * mant + 0.0875862700108075;\n      est = est * mant + -0.3058015757857271;\n      est = est * mant + 0.7249995199969751;\n      est = est * mant + 0.5039018405998233;\n\n      est *= CBRTTWO[exponent % 3 + 2];\n\n      // est should now be good to about 15 bits of precision.   Do 2 rounds of\n      // Newton's method to get closer,  this should get us full double precision\n      // Scale down x for the purpose of doing newtons method.  This avoids over/under flows.\n      final double xs = x / (p2*p2*p2);\n      est += (xs - est*est*est) / (3*est*est);\n      est += (xs - est*est*est) / (3*est*est);\n\n      // Do one round of Newton's method in extended precision to get the last bit right.\n      double temp = est * HEX_40000000;\n      double ya = est + temp - temp;\n      double yb = est - ya;\n\n      double za = ya * ya;\n      double zb = ya * yb * 2.0 + yb * yb;\n      temp = za * HEX_40000000;\n      double temp2 = za + temp - temp;\n      zb += za - temp2;\n      za = temp2;\n\n      zb = za * yb + ya * zb + zb * yb;\n      za = za * ya;\n\n      double na = xs - za;\n      double nb = -(na - xs + za);\n      nb -= zb;\n\n      est += (na+nb)/(3*est*est);\n\n      /* Scale by a power of two, so this is exact. */\n      est *= p2;\n\n      if (subnormal) {\n          est *= 3.814697265625E-6;  // 2^-18\n      }\n\n      return est;\n    }",
          "7": "    public static double cbrt(double x) {\n      /* Convert input double to bits */\n      long inbits = Double.doubleToRawLongBits(x);\n      int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n      boolean subnormal = false;\n\n      if (exponent == -1023) {\n          if (x == 0) {\n              return x;\n          }\n\n          /* Subnormal, so normalize */\n          subnormal = true;\n          x *= 1.8014398509481984E16;  // 2^54\n          inbits = Double.doubleToRawLongBits(x);\n          exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n      }\n\n      if (exponent == 1024) {\n          // Nan or infinity.  Don't care which.\n          return x;\n      }\n\n      /* Divide the exponent by 3 */\n      int exp3 = exponent / 3;\n\n      /* p2 will be the nearest power of 2 to x with its exponent divided by 3 */\ndouble p2 = Double.longBitsToDouble(((inbits & 0x8000000000000000L) | ((long)((exp3 + 1023) | 0) << 52)));\n\n      /* This will be a number between 1 and 2 */\n      final double mant = Double.longBitsToDouble((inbits & 0x000fffffffffffffL) | 0x3ff0000000000000L);\n\n      /* Estimate the cube root of mant by polynomial */\n      double est = -0.010714690733195933;\n      est = est * mant + 0.0875862700108075;\n      est = est * mant + -0.3058015757857271;\n      est = est * mant + 0.7249995199969751;\n      est = est * mant + 0.5039018405998233;\n\n      est *= CBRTTWO[exponent % 3 + 2];\n\n      // est should now be good to about 15 bits of precision.   Do 2 rounds of\n      // Newton's method to get closer,  this should get us full double precision\n      // Scale down x for the purpose of doing newtons method.  This avoids over/under flows.\n      final double xs = x / (p2*p2*p2);\n      est += (xs - est*est*est) / (3*est*est);\n      est += (xs - est*est*est) / (3*est*est);\n\n      // Do one round of Newton's method in extended precision to get the last bit right.\n      double temp = est * HEX_40000000;\n      double ya = est + temp - temp;\n      double yb = est - ya;\n\n      double za = ya * ya;\n      double zb = ya * yb * 2.0 + yb * yb;\n      temp = za * HEX_40000000;\n      double temp2 = za + temp - temp;\n      zb += za - temp2;\n      za = temp2;\n\n      zb = za * yb + ya * zb + zb * yb;\n      za = za * ya;\n\n      double na = xs - za;\n      double nb = -(na - xs + za);\n      nb -= zb;\n\n      est += (na+nb)/(3*est*est);\n\n      /* Scale by a power of two, so this is exact. */\n      est *= p2;\n\n      if (subnormal) {\n          est *= 3.814697265625E-6;  // 2^-18\n      }\n\n      return est;\n    }",
          "8": "    public static double cbrt(double x) {\n      /* Convert input double to bits */\n      long inbits = Double.doubleToRawLongBits(x);\n      int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n      boolean subnormal = false;\n\n      if (exponent == -1023) {\n          if (x == 0) {\n              return x;\n          }\n\n          /* Subnormal, so normalize */\n          subnormal = true;\n          x *= 1.8014398509481984E16;  // 2^54\n          inbits = Double.doubleToRawLongBits(x);\n          exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n      }\n\n      if (exponent == 1024) {\n          // Nan or infinity.  Don't care which.\n          return x;\n      }\n\n      /* Divide the exponent by 3 */\n      int exp3 = exponent / 3;\n\n      /* p2 will be the nearest power of 2 to x with its exponent divided by 3 */\ndouble p2 = Double.longBitsToDouble(((inbits & 0x8000000000000000L) | ((long)((exp3 + 1023) | 2047) & 52)));\n\n      /* This will be a number between 1 and 2 */\n      final double mant = Double.longBitsToDouble((inbits & 0x000fffffffffffffL) | 0x3ff0000000000000L);\n\n      /* Estimate the cube root of mant by polynomial */\n      double est = -0.010714690733195933;\n      est = est * mant + 0.0875862700108075;\n      est = est * mant + -0.3058015757857271;\n      est = est * mant + 0.7249995199969751;\n      est = est * mant + 0.5039018405998233;\n\n      est *= CBRTTWO[exponent % 3 + 2];\n\n      // est should now be good to about 15 bits of precision.   Do 2 rounds of\n      // Newton's method to get closer,  this should get us full double precision\n      // Scale down x for the purpose of doing newtons method.  This avoids over/under flows.\n      final double xs = x / (p2*p2*p2);\n      est += (xs - est*est*est) / (3*est*est);\n      est += (xs - est*est*est) / (3*est*est);\n\n      // Do one round of Newton's method in extended precision to get the last bit right.\n      double temp = est * HEX_40000000;\n      double ya = est + temp - temp;\n      double yb = est - ya;\n\n      double za = ya * ya;\n      double zb = ya * yb * 2.0 + yb * yb;\n      temp = za * HEX_40000000;\n      double temp2 = za + temp - temp;\n      zb += za - temp2;\n      za = temp2;\n\n      zb = za * yb + ya * zb + zb * yb;\n      za = za * ya;\n\n      double na = xs - za;\n      double nb = -(na - xs + za);\n      nb -= zb;\n\n      est += (na+nb)/(3*est*est);\n\n      /* Scale by a power of two, so this is exact. */\n      est *= p2;\n\n      if (subnormal) {\n          est *= 3.814697265625E-6;  // 2^-18\n      }\n\n      return est;\n    }",
          "9": "    public static double cbrt(double x) {\n      /* Convert input double to bits */\n      long inbits = Double.doubleToRawLongBits(x);\n      int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n      boolean subnormal = false;\n\n      if (exponent == -1023) {\n          if (x == 0) {\n              return x;\n          }\n\n          /* Subnormal, so normalize */\n          subnormal = true;\n          x *= 1.8014398509481984E16;  // 2^54\n          inbits = Double.doubleToRawLongBits(x);\n          exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n      }\n\n      if (exponent == 1024) {\n          // Nan or infinity.  Don't care which.\n          return x;\n      }\n\n      /* Divide the exponent by 3 */\n      int exp3 = exponent / 3;\n\n      /* p2 will be the nearest power of 2 to x with its exponent divided by 3 */\ndouble p2 = Double.longBitsToDouble(((inbits & 0x8000000000000000L) | ((long)((exp3 + 0) | 2047) << 52)));\n\n      /* This will be a number between 1 and 2 */\n      final double mant = Double.longBitsToDouble((inbits & 0x000fffffffffffffL) | 0x3ff0000000000000L);\n\n      /* Estimate the cube root of mant by polynomial */\n      double est = -0.010714690733195933;\n      est = est * mant + 0.0875862700108075;\n      est = est * mant + -0.3058015757857271;\n      est = est * mant + 0.7249995199969751;\n      est = est * mant + 0.5039018405998233;\n\n      est *= CBRTTWO[exponent % 3 + 2];\n\n      // est should now be good to about 15 bits of precision.   Do 2 rounds of\n      // Newton's method to get closer,  this should get us full double precision\n      // Scale down x for the purpose of doing newtons method.  This avoids over/under flows.\n      final double xs = x / (p2*p2*p2);\n      est += (xs - est*est*est) / (3*est*est);\n      est += (xs - est*est*est) / (3*est*est);\n\n      // Do one round of Newton's method in extended precision to get the last bit right.\n      double temp = est * HEX_40000000;\n      double ya = est + temp - temp;\n      double yb = est - ya;\n\n      double za = ya * ya;\n      double zb = ya * yb * 2.0 + yb * yb;\n      temp = za * HEX_40000000;\n      double temp2 = za + temp - temp;\n      zb += za - temp2;\n      za = temp2;\n\n      zb = za * yb + ya * zb + zb * yb;\n      za = za * ya;\n\n      double na = xs - za;\n      double nb = -(na - xs + za);\n      nb -= zb;\n\n      est += (na+nb)/(3*est*est);\n\n      /* Scale by a power of two, so this is exact. */\n      est *= p2;\n\n      if (subnormal) {\n          est *= 3.814697265625E-6;  // 2^-18\n      }\n\n      return est;\n    }",
          "10": "    public static double cbrt(double x) {\n      /* Convert input double to bits */\n      long inbits = Double.doubleToRawLongBits(x);\n      int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n      boolean subnormal = false;\n\n      if (exponent == -1023) {\n          if (x == 0) {\n              return x;\n          }\n\n          /* Subnormal, so normalize */\n          subnormal = true;\n          x *= 1.8014398509481984E16;  // 2^54\n          inbits = Double.doubleToRawLongBits(x);\n          exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n      }\n\n      if (exponent == 1024) {\n          // Nan or infinity.  Don't care which.\n          return x;\n      }\n\n      /* Divide the exponent by 3 */\n      int exp3 = exponent / 3;\n\n      /* p2 will be the nearest power of 2 to x with its exponent divided by 3 */\ndouble p2 = Double.longBitsToDouble(((inbits & 0x8000000000000000L) | ((long)((exp3 + 1023) | 2047) | 52)));\n\n      /* This will be a number between 1 and 2 */\n      final double mant = Double.longBitsToDouble((inbits & 0x000fffffffffffffL) | 0x3ff0000000000000L);\n\n      /* Estimate the cube root of mant by polynomial */\n      double est = -0.010714690733195933;\n      est = est * mant + 0.0875862700108075;\n      est = est * mant + -0.3058015757857271;\n      est = est * mant + 0.7249995199969751;\n      est = est * mant + 0.5039018405998233;\n\n      est *= CBRTTWO[exponent % 3 + 2];\n\n      // est should now be good to about 15 bits of precision.   Do 2 rounds of\n      // Newton's method to get closer,  this should get us full double precision\n      // Scale down x for the purpose of doing newtons method.  This avoids over/under flows.\n      final double xs = x / (p2*p2*p2);\n      est += (xs - est*est*est) / (3*est*est);\n      est += (xs - est*est*est) / (3*est*est);\n\n      // Do one round of Newton's method in extended precision to get the last bit right.\n      double temp = est * HEX_40000000;\n      double ya = est + temp - temp;\n      double yb = est - ya;\n\n      double za = ya * ya;\n      double zb = ya * yb * 2.0 + yb * yb;\n      temp = za * HEX_40000000;\n      double temp2 = za + temp - temp;\n      zb += za - temp2;\n      za = temp2;\n\n      zb = za * yb + ya * zb + zb * yb;\n      za = za * ya;\n\n      double na = xs - za;\n      double nb = -(na - xs + za);\n      nb -= zb;\n\n      est += (na+nb)/(3*est*est);\n\n      /* Scale by a power of two, so this is exact. */\n      est *= p2;\n\n      if (subnormal) {\n          est *= 3.814697265625E-6;  // 2^-18\n      }\n\n      return est;\n    }",
          "11": "    public static double cbrt(double x) {\n      /* Convert input double to bits */\n      long inbits = Double.doubleToRawLongBits(x);\n      int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n      boolean subnormal = false;\n\n      if (exponent == -1023) {\n          if (x == 0) {\n              return x;\n          }\n\n          /* Subnormal, so normalize */\n          subnormal = true;\n          x *= 1.8014398509481984E16;  // 2^54\n          inbits = Double.doubleToRawLongBits(x);\n          exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n      }\n\n      if (exponent == 1024) {\n          // Nan or infinity.  Don't care which.\n          return x;\n      }\n\n      /* Divide the exponent by 3 */\n      int exp3 = exponent / 3;\n\n      /* p2 will be the nearest power of 2 to x with its exponent divided by 3 */\ndouble p2 = Double.longBitsToDouble(((inbits & 1) | ((long)((exp3 + 1023) | 2047) << 52)));\n\n      /* This will be a number between 1 and 2 */\n      final double mant = Double.longBitsToDouble((inbits & 0x000fffffffffffffL) | 0x3ff0000000000000L);\n\n      /* Estimate the cube root of mant by polynomial */\n      double est = -0.010714690733195933;\n      est = est * mant + 0.0875862700108075;\n      est = est * mant + -0.3058015757857271;\n      est = est * mant + 0.7249995199969751;\n      est = est * mant + 0.5039018405998233;\n\n      est *= CBRTTWO[exponent % 3 + 2];\n\n      // est should now be good to about 15 bits of precision.   Do 2 rounds of\n      // Newton's method to get closer,  this should get us full double precision\n      // Scale down x for the purpose of doing newtons method.  This avoids over/under flows.\n      final double xs = x / (p2*p2*p2);\n      est += (xs - est*est*est) / (3*est*est);\n      est += (xs - est*est*est) / (3*est*est);\n\n      // Do one round of Newton's method in extended precision to get the last bit right.\n      double temp = est * HEX_40000000;\n      double ya = est + temp - temp;\n      double yb = est - ya;\n\n      double za = ya * ya;\n      double zb = ya * yb * 2.0 + yb * yb;\n      temp = za * HEX_40000000;\n      double temp2 = za + temp - temp;\n      zb += za - temp2;\n      za = temp2;\n\n      zb = za * yb + ya * zb + zb * yb;\n      za = za * ya;\n\n      double na = xs - za;\n      double nb = -(na - xs + za);\n      nb -= zb;\n\n      est += (na+nb)/(3*est*est);\n\n      /* Scale by a power of two, so this is exact. */\n      est *= p2;\n\n      if (subnormal) {\n          est *= 3.814697265625E-6;  // 2^-18\n      }\n\n      return est;\n    }",
          "12": "    public static double cbrt(double x) {\n      /* Convert input double to bits */\n      long inbits = Double.doubleToRawLongBits(x);\n      int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n      boolean subnormal = false;\n\n      if (exponent == -1023) {\n          if (x == 0) {\n              return x;\n          }\n\n          /* Subnormal, so normalize */\n          subnormal = true;\n          x *= 1.8014398509481984E16;  // 2^54\n          inbits = Double.doubleToRawLongBits(x);\n          exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n      }\n\n      if (exponent == 1024) {\n          // Nan or infinity.  Don't care which.\n          return x;\n      }\n\n      /* Divide the exponent by 3 */\n      int exp3 = exponent / 3;\n\n      /* p2 will be the nearest power of 2 to x with its exponent divided by 3 */\ndouble p2 = Double.longBitsToDouble(((inbits & 0x8000000000000000L) | ((long)((exp3 + 1023) | 2047) << false)));\n\n      /* This will be a number between 1 and 2 */\n      final double mant = Double.longBitsToDouble((inbits & 0x000fffffffffffffL) | 0x3ff0000000000000L);\n\n      /* Estimate the cube root of mant by polynomial */\n      double est = -0.010714690733195933;\n      est = est * mant + 0.0875862700108075;\n      est = est * mant + -0.3058015757857271;\n      est = est * mant + 0.7249995199969751;\n      est = est * mant + 0.5039018405998233;\n\n      est *= CBRTTWO[exponent % 3 + 2];\n\n      // est should now be good to about 15 bits of precision.   Do 2 rounds of\n      // Newton's method to get closer,  this should get us full double precision\n      // Scale down x for the purpose of doing newtons method.  This avoids over/under flows.\n      final double xs = x / (p2*p2*p2);\n      est += (xs - est*est*est) / (3*est*est);\n      est += (xs - est*est*est) / (3*est*est);\n\n      // Do one round of Newton's method in extended precision to get the last bit right.\n      double temp = est * HEX_40000000;\n      double ya = est + temp - temp;\n      double yb = est - ya;\n\n      double za = ya * ya;\n      double zb = ya * yb * 2.0 + yb * yb;\n      temp = za * HEX_40000000;\n      double temp2 = za + temp - temp;\n      zb += za - temp2;\n      za = temp2;\n\n      zb = za * yb + ya * zb + zb * yb;\n      za = za * ya;\n\n      double na = xs - za;\n      double nb = -(na - xs + za);\n      nb -= zb;\n\n      est += (na+nb)/(3*est*est);\n\n      /* Scale by a power of two, so this is exact. */\n      est *= p2;\n\n      if (subnormal) {\n          est *= 3.814697265625E-6;  // 2^-18\n      }\n\n      return est;\n    }",
          "13": "    public static double cbrt(double x) {\n      /* Convert input double to bits */\n      long inbits = Double.doubleToRawLongBits(x);\n      int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n      boolean subnormal = false;\n\n      if (exponent == -1023) {\n          if (x == 0) {\n              return x;\n          }\n\n          /* Subnormal, so normalize */\n          subnormal = true;\n          x *= 1.8014398509481984E16;  // 2^54\n          inbits = Double.doubleToRawLongBits(x);\n          exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n      }\n\n      if (exponent == 1024) {\n          // Nan or infinity.  Don't care which.\n          return x;\n      }\n\n      /* Divide the exponent by 3 */\n      int exp3 = exponent / 3;\n\n      /* p2 will be the nearest power of 2 to x with its exponent divided by 3 */\ndouble p2 = Double.longBitsToDouble(((inbits & 0x8000000000000000L) | ((long)((exp3 + 1023) | 2047) < 52)));\n\n      /* This will be a number between 1 and 2 */\n      final double mant = Double.longBitsToDouble((inbits & 0x000fffffffffffffL) | 0x3ff0000000000000L);\n\n      /* Estimate the cube root of mant by polynomial */\n      double est = -0.010714690733195933;\n      est = est * mant + 0.0875862700108075;\n      est = est * mant + -0.3058015757857271;\n      est = est * mant + 0.7249995199969751;\n      est = est * mant + 0.5039018405998233;\n\n      est *= CBRTTWO[exponent % 3 + 2];\n\n      // est should now be good to about 15 bits of precision.   Do 2 rounds of\n      // Newton's method to get closer,  this should get us full double precision\n      // Scale down x for the purpose of doing newtons method.  This avoids over/under flows.\n      final double xs = x / (p2*p2*p2);\n      est += (xs - est*est*est) / (3*est*est);\n      est += (xs - est*est*est) / (3*est*est);\n\n      // Do one round of Newton's method in extended precision to get the last bit right.\n      double temp = est * HEX_40000000;\n      double ya = est + temp - temp;\n      double yb = est - ya;\n\n      double za = ya * ya;\n      double zb = ya * yb * 2.0 + yb * yb;\n      temp = za * HEX_40000000;\n      double temp2 = za + temp - temp;\n      zb += za - temp2;\n      za = temp2;\n\n      zb = za * yb + ya * zb + zb * yb;\n      za = za * ya;\n\n      double na = xs - za;\n      double nb = -(na - xs + za);\n      nb -= zb;\n\n      est += (na+nb)/(3*est*est);\n\n      /* Scale by a power of two, so this is exact. */\n      est *= p2;\n\n      if (subnormal) {\n          est *= 3.814697265625E-6;  // 2^-18\n      }\n\n      return est;\n    }",
          "14": "    public static double cbrt(double x) {\n      /* Convert input double to bits */\n      long inbits = Double.doubleToRawLongBits(x);\n      int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n      boolean subnormal = false;\n\n      if (exponent == -1023) {\n          if (x == 0) {\n              return x;\n          }\n\n          /* Subnormal, so normalize */\n          subnormal = true;\n          x *= 1.8014398509481984E16;  // 2^54\n          inbits = Double.doubleToRawLongBits(x);\n          exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n      }\n\n      if (exponent == 1024) {\n          // Nan or infinity.  Don't care which.\n          return x;\n      }\n\n      /* Divide the exponent by 3 */\n      int exp3 = exponent / 3;\n\n      /* p2 will be the nearest power of 2 to x with its exponent divided by 3 */\ndouble p2 = Double.longBitsToDouble(((inbits & 0x8000000000000000L) | ((long)((exp3 + 1023) | 2047) << true)));\n\n      /* This will be a number between 1 and 2 */\n      final double mant = Double.longBitsToDouble((inbits & 0x000fffffffffffffL) | 0x3ff0000000000000L);\n\n      /* Estimate the cube root of mant by polynomial */\n      double est = -0.010714690733195933;\n      est = est * mant + 0.0875862700108075;\n      est = est * mant + -0.3058015757857271;\n      est = est * mant + 0.7249995199969751;\n      est = est * mant + 0.5039018405998233;\n\n      est *= CBRTTWO[exponent % 3 + 2];\n\n      // est should now be good to about 15 bits of precision.   Do 2 rounds of\n      // Newton's method to get closer,  this should get us full double precision\n      // Scale down x for the purpose of doing newtons method.  This avoids over/under flows.\n      final double xs = x / (p2*p2*p2);\n      est += (xs - est*est*est) / (3*est*est);\n      est += (xs - est*est*est) / (3*est*est);\n\n      // Do one round of Newton's method in extended precision to get the last bit right.\n      double temp = est * HEX_40000000;\n      double ya = est + temp - temp;\n      double yb = est - ya;\n\n      double za = ya * ya;\n      double zb = ya * yb * 2.0 + yb * yb;\n      temp = za * HEX_40000000;\n      double temp2 = za + temp - temp;\n      zb += za - temp2;\n      za = temp2;\n\n      zb = za * yb + ya * zb + zb * yb;\n      za = za * ya;\n\n      double na = xs - za;\n      double nb = -(na - xs + za);\n      nb -= zb;\n\n      est += (na+nb)/(3*est*est);\n\n      /* Scale by a power of two, so this is exact. */\n      est *= p2;\n\n      if (subnormal) {\n          est *= 3.814697265625E-6;  // 2^-18\n      }\n\n      return est;\n    }",
          "15": "    public static double cbrt(double x) {\n      /* Convert input double to bits */\n      long inbits = Double.doubleToRawLongBits(x);\n      int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n      boolean subnormal = false;\n\n      if (exponent == -1023) {\n          if (x == 0) {\n              return x;\n          }\n\n          /* Subnormal, so normalize */\n          subnormal = true;\n          x *= 1.8014398509481984E16;  // 2^54\n          inbits = Double.doubleToRawLongBits(x);\n          exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n      }\n\n      if (exponent == 1024) {\n          // Nan or infinity.  Don't care which.\n          return x;\n      }\n\n      /* Divide the exponent by 3 */\n      int exp3 = exponent / 3;\n\n      /* p2 will be the nearest power of 2 to x with its exponent divided by 3 */\ndouble p2 = Double.longBitsToDouble(((inbits & 0x8000000000000000L) | ((long)((exp3 + 1023) | 2047) << 3)));\n\n      /* This will be a number between 1 and 2 */\n      final double mant = Double.longBitsToDouble((inbits & 0x000fffffffffffffL) | 0x3ff0000000000000L);\n\n      /* Estimate the cube root of mant by polynomial */\n      double est = -0.010714690733195933;\n      est = est * mant + 0.0875862700108075;\n      est = est * mant + -0.3058015757857271;\n      est = est * mant + 0.7249995199969751;\n      est = est * mant + 0.5039018405998233;\n\n      est *= CBRTTWO[exponent % 3 + 2];\n\n      // est should now be good to about 15 bits of precision.   Do 2 rounds of\n      // Newton's method to get closer,  this should get us full double precision\n      // Scale down x for the purpose of doing newtons method.  This avoids over/under flows.\n      final double xs = x / (p2*p2*p2);\n      est += (xs - est*est*est) / (3*est*est);\n      est += (xs - est*est*est) / (3*est*est);\n\n      // Do one round of Newton's method in extended precision to get the last bit right.\n      double temp = est * HEX_40000000;\n      double ya = est + temp - temp;\n      double yb = est - ya;\n\n      double za = ya * ya;\n      double zb = ya * yb * 2.0 + yb * yb;\n      temp = za * HEX_40000000;\n      double temp2 = za + temp - temp;\n      zb += za - temp2;\n      za = temp2;\n\n      zb = za * yb + ya * zb + zb * yb;\n      za = za * ya;\n\n      double na = xs - za;\n      double nb = -(na - xs + za);\n      nb -= zb;\n\n      est += (na+nb)/(3*est*est);\n\n      /* Scale by a power of two, so this is exact. */\n      est *= p2;\n\n      if (subnormal) {\n          est *= 3.814697265625E-6;  // 2^-18\n      }\n\n      return est;\n    }",
          "16": "    public static double cbrt(double x) {\n      /* Convert input double to bits */\n      long inbits = Double.doubleToRawLongBits(x);\n      int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n      boolean subnormal = false;\n\n      if (exponent == -1023) {\n          if (x == 0) {\n              return x;\n          }\n\n          /* Subnormal, so normalize */\n          subnormal = true;\n          x *= 1.8014398509481984E16;  // 2^54\n          inbits = Double.doubleToRawLongBits(x);\n          exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n      }\n\n      if (exponent == 1024) {\n          // Nan or infinity.  Don't care which.\n          return x;\n      }\n\n      /* Divide the exponent by 3 */\n      int exp3 = exponent / 3;\n\n      /* p2 will be the nearest power of 2 to x with its exponent divided by 3 */\ndouble p2 = Double.longBitsToDouble(((inbits & 0x8000000000000000L) | ((long)((exp3 + 1023) | 2047) > 52)));\n\n      /* This will be a number between 1 and 2 */\n      final double mant = Double.longBitsToDouble((inbits & 0x000fffffffffffffL) | 0x3ff0000000000000L);\n\n      /* Estimate the cube root of mant by polynomial */\n      double est = -0.010714690733195933;\n      est = est * mant + 0.0875862700108075;\n      est = est * mant + -0.3058015757857271;\n      est = est * mant + 0.7249995199969751;\n      est = est * mant + 0.5039018405998233;\n\n      est *= CBRTTWO[exponent % 3 + 2];\n\n      // est should now be good to about 15 bits of precision.   Do 2 rounds of\n      // Newton's method to get closer,  this should get us full double precision\n      // Scale down x for the purpose of doing newtons method.  This avoids over/under flows.\n      final double xs = x / (p2*p2*p2);\n      est += (xs - est*est*est) / (3*est*est);\n      est += (xs - est*est*est) / (3*est*est);\n\n      // Do one round of Newton's method in extended precision to get the last bit right.\n      double temp = est * HEX_40000000;\n      double ya = est + temp - temp;\n      double yb = est - ya;\n\n      double za = ya * ya;\n      double zb = ya * yb * 2.0 + yb * yb;\n      temp = za * HEX_40000000;\n      double temp2 = za + temp - temp;\n      zb += za - temp2;\n      za = temp2;\n\n      zb = za * yb + ya * zb + zb * yb;\n      za = za * ya;\n\n      double na = xs - za;\n      double nb = -(na - xs + za);\n      nb -= zb;\n\n      est += (na+nb)/(3*est*est);\n\n      /* Scale by a power of two, so this is exact. */\n      est *= p2;\n\n      if (subnormal) {\n          est *= 3.814697265625E-6;  // 2^-18\n      }\n\n      return est;\n    }",
          "17": "    public static double cbrt(double x) {\n      /* Convert input double to bits */\n      long inbits = Double.doubleToRawLongBits(x);\n      int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n      boolean subnormal = false;\n\n      if (exponent == -1023) {\n          if (x == 0) {\n              return x;\n          }\n\n          /* Subnormal, so normalize */\n          subnormal = true;\n          x *= 1.8014398509481984E16;  // 2^54\n          inbits = Double.doubleToRawLongBits(x);\n          exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n      }\n\n      if (exponent == 1024) {\n          // Nan or infinity.  Don't care which.\n          return x;\n      }\n\n      /* Divide the exponent by 3 */\n      int exp3 = exponent / 3;\n\n      /* p2 will be the nearest power of 2 to x with its exponent divided by 3 */\ndouble p2 = Double.longBitsToDouble(((inbits & 0x8000000000000000L) | ((long)((exp3 + 1023) | 2047) << \"null\")));\n\n      /* This will be a number between 1 and 2 */\n      final double mant = Double.longBitsToDouble((inbits & 0x000fffffffffffffL) | 0x3ff0000000000000L);\n\n      /* Estimate the cube root of mant by polynomial */\n      double est = -0.010714690733195933;\n      est = est * mant + 0.0875862700108075;\n      est = est * mant + -0.3058015757857271;\n      est = est * mant + 0.7249995199969751;\n      est = est * mant + 0.5039018405998233;\n\n      est *= CBRTTWO[exponent % 3 + 2];\n\n      // est should now be good to about 15 bits of precision.   Do 2 rounds of\n      // Newton's method to get closer,  this should get us full double precision\n      // Scale down x for the purpose of doing newtons method.  This avoids over/under flows.\n      final double xs = x / (p2*p2*p2);\n      est += (xs - est*est*est) / (3*est*est);\n      est += (xs - est*est*est) / (3*est*est);\n\n      // Do one round of Newton's method in extended precision to get the last bit right.\n      double temp = est * HEX_40000000;\n      double ya = est + temp - temp;\n      double yb = est - ya;\n\n      double za = ya * ya;\n      double zb = ya * yb * 2.0 + yb * yb;\n      temp = za * HEX_40000000;\n      double temp2 = za + temp - temp;\n      zb += za - temp2;\n      za = temp2;\n\n      zb = za * yb + ya * zb + zb * yb;\n      za = za * ya;\n\n      double na = xs - za;\n      double nb = -(na - xs + za);\n      nb -= zb;\n\n      est += (na+nb)/(3*est*est);\n\n      /* Scale by a power of two, so this is exact. */\n      est *= p2;\n\n      if (subnormal) {\n          est *= 3.814697265625E-6;  // 2^-18\n      }\n\n      return est;\n    }",
          "18": "    public static double cbrt(double x) {\n      /* Convert input double to bits */\n      long inbits = Double.doubleToRawLongBits(x);\n      int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n      boolean subnormal = false;\n\n      if (exponent == -1023) {\n          if (x == 0) {\n              return x;\n          }\n\n          /* Subnormal, so normalize */\n          subnormal = true;\n          x *= 1.8014398509481984E16;  // 2^54\n          inbits = Double.doubleToRawLongBits(x);\n          exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n      }\n\n      if (exponent == 1024) {\n          // Nan or infinity.  Don't care which.\n          return x;\n      }\n\n      /* Divide the exponent by 3 */\n      int exp3 = exponent / 3;\n\n      /* p2 will be the nearest power of 2 to x with its exponent divided by 3 */\ndouble p2 = Double.longBitsToDouble(((inbits & 0x8000000000000000L) | ((long)((exp3 + 1023) | 2047) - 52)));\n\n      /* This will be a number between 1 and 2 */\n      final double mant = Double.longBitsToDouble((inbits & 0x000fffffffffffffL) | 0x3ff0000000000000L);\n\n      /* Estimate the cube root of mant by polynomial */\n      double est = -0.010714690733195933;\n      est = est * mant + 0.0875862700108075;\n      est = est * mant + -0.3058015757857271;\n      est = est * mant + 0.7249995199969751;\n      est = est * mant + 0.5039018405998233;\n\n      est *= CBRTTWO[exponent % 3 + 2];\n\n      // est should now be good to about 15 bits of precision.   Do 2 rounds of\n      // Newton's method to get closer,  this should get us full double precision\n      // Scale down x for the purpose of doing newtons method.  This avoids over/under flows.\n      final double xs = x / (p2*p2*p2);\n      est += (xs - est*est*est) / (3*est*est);\n      est += (xs - est*est*est) / (3*est*est);\n\n      // Do one round of Newton's method in extended precision to get the last bit right.\n      double temp = est * HEX_40000000;\n      double ya = est + temp - temp;\n      double yb = est - ya;\n\n      double za = ya * ya;\n      double zb = ya * yb * 2.0 + yb * yb;\n      temp = za * HEX_40000000;\n      double temp2 = za + temp - temp;\n      zb += za - temp2;\n      za = temp2;\n\n      zb = za * yb + ya * zb + zb * yb;\n      za = za * ya;\n\n      double na = xs - za;\n      double nb = -(na - xs + za);\n      nb -= zb;\n\n      est += (na+nb)/(3*est*est);\n\n      /* Scale by a power of two, so this is exact. */\n      est *= p2;\n\n      if (subnormal) {\n          est *= 3.814697265625E-6;  // 2^-18\n      }\n\n      return est;\n    }",
          "19": "    public static double cbrt(double x) {\n      /* Convert input double to bits */\n      long inbits = Double.doubleToRawLongBits(x);\n      int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n      boolean subnormal = false;\n\n      if (exponent == -1023) {\n          if (x == 0) {\n              return x;\n          }\n\n          /* Subnormal, so normalize */\n          subnormal = true;\n          x *= 1.8014398509481984E16;  // 2^54\n          inbits = Double.doubleToRawLongBits(x);\n          exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n      }\n\n      if (exponent == 1024) {\n          // Nan or infinity.  Don't care which.\n          return x;\n      }\n\n      /* Divide the exponent by 3 */\n      int exp3 = exponent / 3;\n\n      /* p2 will be the nearest power of 2 to x with its exponent divided by 3 */\ndouble p2 = Double.longBitsToDouble(((inbits & 0x8000000000000000L) | ((long)((exp3 + 1023) & 2047) << 52)));\n\n      /* This will be a number between 1 and 2 */\n      final double mant = Double.longBitsToDouble((inbits & 0x000fffffffffffffL) | 0x3ff0000000000000L);\n\n      /* Estimate the cube root of mant by polynomial */\n      double est = -0.010714690733195933;\n      est = est * mant + 0.0875862700108075;\n      est = est * mant + -0.3058015757857271;\n      est = est * mant + 0.7249995199969751;\n      est = est * mant + 0.5039018405998233;\n\n      est *= CBRTTWO[exponent % 3 + 2];\n\n      // est should now be good to about 15 bits of precision.   Do 2 rounds of\n      // Newton's method to get closer,  this should get us full double precision\n      // Scale down x for the purpose of doing newtons method.  This avoids over/under flows.\n      final double xs = x / (p2*p2*p2);\n      est += (xs - est*est*est) / (3*est*est);\n      est += (xs - est*est*est) / (3*est*est);\n\n      // Do one round of Newton's method in extended precision to get the last bit right.\n      double temp = est * HEX_40000000;\n      double ya = est + temp - temp;\n      double yb = est - ya;\n\n      double za = ya * ya;\n      double zb = ya * yb * 2.0 + yb * yb;\n      temp = za * HEX_40000000;\n      double temp2 = za + temp - temp;\n      zb += za - temp2;\n      za = temp2;\n\n      zb = za * yb + ya * zb + zb * yb;\n      za = za * ya;\n\n      double na = xs - za;\n      double nb = -(na - xs + za);\n      nb -= zb;\n\n      est += (na+nb)/(3*est*est);\n\n      /* Scale by a power of two, so this is exact. */\n      est *= p2;\n\n      if (subnormal) {\n          est *= 3.814697265625E-6;  // 2^-18\n      }\n\n      return est;\n    }",
          "20": "    public static double cbrt(double x) {\n      /* Convert input double to bits */\n      long inbits = Double.doubleToRawLongBits(x);\n      int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n      boolean subnormal = false;\n\n      if (exponent == -1023) {\n          if (x == 0) {\n              return x;\n          }\n\n          /* Subnormal, so normalize */\n          subnormal = true;\n          x *= 1.8014398509481984E16;  // 2^54\n          inbits = Double.doubleToRawLongBits(x);\n          exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n      }\n\n      if (exponent == 1024) {\n          // Nan or infinity.  Don't care which.\n          return x;\n      }\n\n      /* Divide the exponent by 3 */\n      int exp3 = exponent / 3;\n\n      /* p2 will be the nearest power of 2 to x with its exponent divided by 3 */\ndouble p2 = Double.longBitsToDouble(((inbits & 0x8000000000000000L) | ((long)((exp3 + 1023) | 2047) + 52)));\n\n      /* This will be a number between 1 and 2 */\n      final double mant = Double.longBitsToDouble((inbits & 0x000fffffffffffffL) | 0x3ff0000000000000L);\n\n      /* Estimate the cube root of mant by polynomial */\n      double est = -0.010714690733195933;\n      est = est * mant + 0.0875862700108075;\n      est = est * mant + -0.3058015757857271;\n      est = est * mant + 0.7249995199969751;\n      est = est * mant + 0.5039018405998233;\n\n      est *= CBRTTWO[exponent % 3 + 2];\n\n      // est should now be good to about 15 bits of precision.   Do 2 rounds of\n      // Newton's method to get closer,  this should get us full double precision\n      // Scale down x for the purpose of doing newtons method.  This avoids over/under flows.\n      final double xs = x / (p2*p2*p2);\n      est += (xs - est*est*est) / (3*est*est);\n      est += (xs - est*est*est) / (3*est*est);\n\n      // Do one round of Newton's method in extended precision to get the last bit right.\n      double temp = est * HEX_40000000;\n      double ya = est + temp - temp;\n      double yb = est - ya;\n\n      double za = ya * ya;\n      double zb = ya * yb * 2.0 + yb * yb;\n      temp = za * HEX_40000000;\n      double temp2 = za + temp - temp;\n      zb += za - temp2;\n      za = temp2;\n\n      zb = za * yb + ya * zb + zb * yb;\n      za = za * ya;\n\n      double na = xs - za;\n      double nb = -(na - xs + za);\n      nb -= zb;\n\n      est += (na+nb)/(3*est*est);\n\n      /* Scale by a power of two, so this is exact. */\n      est *= p2;\n\n      if (subnormal) {\n          est *= 3.814697265625E-6;  // 2^-18\n      }\n\n      return est;\n    }",
          "21": "    public static double cbrt(double x) {\n      /* Convert input double to bits */\n      long inbits = Double.doubleToRawLongBits(x);\n      int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n      boolean subnormal = false;\n\n      if (exponent == -1023) {\n          if (x == 0) {\n              return x;\n          }\n\n          /* Subnormal, so normalize */\n          subnormal = true;\n          x *= 1.8014398509481984E16;  // 2^54\n          inbits = Double.doubleToRawLongBits(x);\n          exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n      }\n\n      if (exponent == 1024) {\n          // Nan or infinity.  Don't care which.\n          return x;\n      }\n\n      /* Divide the exponent by 3 */\n      int exp3 = exponent / 3;\n\n      /* p2 will be the nearest power of 2 to x with its exponent divided by 3 */\ndouble p2 = Double.longBitsToDouble(((inbits & 2) | ((long)((exp3 + 1023) | 2047) << 52)));\n\n      /* This will be a number between 1 and 2 */\n      final double mant = Double.longBitsToDouble((inbits & 0x000fffffffffffffL) | 0x3ff0000000000000L);\n\n      /* Estimate the cube root of mant by polynomial */\n      double est = -0.010714690733195933;\n      est = est * mant + 0.0875862700108075;\n      est = est * mant + -0.3058015757857271;\n      est = est * mant + 0.7249995199969751;\n      est = est * mant + 0.5039018405998233;\n\n      est *= CBRTTWO[exponent % 3 + 2];\n\n      // est should now be good to about 15 bits of precision.   Do 2 rounds of\n      // Newton's method to get closer,  this should get us full double precision\n      // Scale down x for the purpose of doing newtons method.  This avoids over/under flows.\n      final double xs = x / (p2*p2*p2);\n      est += (xs - est*est*est) / (3*est*est);\n      est += (xs - est*est*est) / (3*est*est);\n\n      // Do one round of Newton's method in extended precision to get the last bit right.\n      double temp = est * HEX_40000000;\n      double ya = est + temp - temp;\n      double yb = est - ya;\n\n      double za = ya * ya;\n      double zb = ya * yb * 2.0 + yb * yb;\n      temp = za * HEX_40000000;\n      double temp2 = za + temp - temp;\n      zb += za - temp2;\n      za = temp2;\n\n      zb = za * yb + ya * zb + zb * yb;\n      za = za * ya;\n\n      double na = xs - za;\n      double nb = -(na - xs + za);\n      nb -= zb;\n\n      est += (na+nb)/(3*est*est);\n\n      /* Scale by a power of two, so this is exact. */\n      est *= p2;\n\n      if (subnormal) {\n          est *= 3.814697265625E-6;  // 2^-18\n      }\n\n      return est;\n    }",
          "22": "    public static double cbrt(double x) {\n      /* Convert input double to bits */\n      long inbits = Double.doubleToRawLongBits(x);\n      int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n      boolean subnormal = false;\n\n      if (exponent == -1023) {\n          if (x == 0) {\n              return x;\n          }\n\n          /* Subnormal, so normalize */\n          subnormal = true;\n          x *= 1.8014398509481984E16;  // 2^54\n          inbits = Double.doubleToRawLongBits(x);\n          exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n      }\n\n      if (exponent == 1024) {\n          // Nan or infinity.  Don't care which.\n          return x;\n      }\n\n      /* Divide the exponent by 3 */\n      int exp3 = exponent / 3;\n\n      /* p2 will be the nearest power of 2 to x with its exponent divided by 3 */\ndouble p2 = Double.longBitsToDouble(((inbits & 0x8000000000000000L) | ((long)((exp3 + 1023) | 2047) << 52)));\n\n      /* This will be a number between 1 and 2 */\n      final double mant = Double.longBitsToDouble((inbits & 0x000fffffffffffffL) | 0x3ff0000000000000L);\n\n      /* Estimate the cube root of mant by polynomial */\n      double est = -0.010714690733195933;\n      est = est * mant + 0.0875862700108075;\n      est = est * mant + -0.3058015757857271;\n      est = est * mant + 0.7249995199969751;\n      est = est * mant + 0.5039018405998233;\n\n      est *= CBRTTWO[exponent % 3 + 2];\n\n      // est should now be good to about 15 bits of precision.   Do 2 rounds of\n      // Newton's method to get closer,  this should get us full double precision\n      // Scale down x for the purpose of doing newtons method.  This avoids over/under flows.\n      final double xs = x / (p2*p2*p2);\n      est += (xs - est*est*est) / (3*est*est);\n      est += (xs - est*est*est) / (3*est*est);\n\n      // Do one round of Newton's method in extended precision to get the last bit right.\n      double temp = est * HEX_40000000;\n      double ya = est + temp - temp;\n      double yb = est - ya;\n\n      double za = ya * ya;\n      double zb = ya * yb * 2.0 + yb * yb;\n      temp = za * HEX_40000000;\n      double temp2 = za + temp - temp;\n      zb += za - temp2;\n      za = temp2;\n\n      zb = za * yb + ya * zb + zb * yb;\n      za = za * ya;\n\n      double na = xs - za;\n      double nb = -(na - xs + za);\n      nb -= zb;\n\n      est += (na+nb)/(3*est*est);\n\n      /* Scale by a power of two, so this is exact. */\n      est *= p2;\n\n      if (subnormal) {\n          est *= 3.814697265625E-6;  // 2^-18\n      }\n\n      return est;\n    }",
          "23": "    public static double cbrt(double x) {\n      /* Convert input double to bits */\n      long inbits = Double.doubleToRawLongBits(x);\n      int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n      boolean subnormal = false;\n\n      if (exponent == -1023) {\n          if (x == 0) {\n              return x;\n          }\n\n          /* Subnormal, so normalize */\n          subnormal = true;\n          x *= 1.8014398509481984E16;  // 2^54\n          inbits = Double.doubleToRawLongBits(x);\n          exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n      }\n\n      if (exponent == 1024) {\n          // Nan or infinity.  Don't care which.\n          return x;\n      }\n\n      /* Divide the exponent by 3 */\n      int exp3 = exponent / 3;\n\n      /* p2 will be the nearest power of 2 to x with its exponent divided by 3 */\ndouble p2 = Double.longBitsToDouble(((inbits & 0x8000000000000000L) | ((long)((exp3 + 1023) | 2047) * 52)));\n\n      /* This will be a number between 1 and 2 */\n      final double mant = Double.longBitsToDouble((inbits & 0x000fffffffffffffL) | 0x3ff0000000000000L);\n\n      /* Estimate the cube root of mant by polynomial */\n      double est = -0.010714690733195933;\n      est = est * mant + 0.0875862700108075;\n      est = est * mant + -0.3058015757857271;\n      est = est * mant + 0.7249995199969751;\n      est = est * mant + 0.5039018405998233;\n\n      est *= CBRTTWO[exponent % 3 + 2];\n\n      // est should now be good to about 15 bits of precision.   Do 2 rounds of\n      // Newton's method to get closer,  this should get us full double precision\n      // Scale down x for the purpose of doing newtons method.  This avoids over/under flows.\n      final double xs = x / (p2*p2*p2);\n      est += (xs - est*est*est) / (3*est*est);\n      est += (xs - est*est*est) / (3*est*est);\n\n      // Do one round of Newton's method in extended precision to get the last bit right.\n      double temp = est * HEX_40000000;\n      double ya = est + temp - temp;\n      double yb = est - ya;\n\n      double za = ya * ya;\n      double zb = ya * yb * 2.0 + yb * yb;\n      temp = za * HEX_40000000;\n      double temp2 = za + temp - temp;\n      zb += za - temp2;\n      za = temp2;\n\n      zb = za * yb + ya * zb + zb * yb;\n      za = za * ya;\n\n      double na = xs - za;\n      double nb = -(na - xs + za);\n      nb -= zb;\n\n      est += (na+nb)/(3*est*est);\n\n      /* Scale by a power of two, so this is exact. */\n      est *= p2;\n\n      if (subnormal) {\n          est *= 3.814697265625E-6;  // 2^-18\n      }\n\n      return est;\n    }",
          "24": "    public static double cbrt(double x) {\n      /* Convert input double to bits */\n      long inbits = Double.doubleToRawLongBits(x);\n      int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n      boolean subnormal = false;\n\n      if (exponent == -1023) {\n          if (x == 0) {\n              return x;\n          }\n\n          /* Subnormal, so normalize */\n          subnormal = true;\n          x *= 1.8014398509481984E16;  // 2^54\n          inbits = Double.doubleToRawLongBits(x);\n          exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n      }\n\n      if (exponent == 1024) {\n          // Nan or infinity.  Don't care which.\n          return x;\n      }\n\n      /* Divide the exponent by 3 */\n      int exp3 = exponent / 3;\n\n      /* p2 will be the nearest power of 2 to x with its exponent divided by 3 */\ndouble p2 = Double.longBitsToDouble(((inbits & 0x8000000000000000L) | ((long)((exp3 + 1023) | 2047) % 52)));\n\n      /* This will be a number between 1 and 2 */\n      final double mant = Double.longBitsToDouble((inbits & 0x000fffffffffffffL) | 0x3ff0000000000000L);\n\n      /* Estimate the cube root of mant by polynomial */\n      double est = -0.010714690733195933;\n      est = est * mant + 0.0875862700108075;\n      est = est * mant + -0.3058015757857271;\n      est = est * mant + 0.7249995199969751;\n      est = est * mant + 0.5039018405998233;\n\n      est *= CBRTTWO[exponent % 3 + 2];\n\n      // est should now be good to about 15 bits of precision.   Do 2 rounds of\n      // Newton's method to get closer,  this should get us full double precision\n      // Scale down x for the purpose of doing newtons method.  This avoids over/under flows.\n      final double xs = x / (p2*p2*p2);\n      est += (xs - est*est*est) / (3*est*est);\n      est += (xs - est*est*est) / (3*est*est);\n\n      // Do one round of Newton's method in extended precision to get the last bit right.\n      double temp = est * HEX_40000000;\n      double ya = est + temp - temp;\n      double yb = est - ya;\n\n      double za = ya * ya;\n      double zb = ya * yb * 2.0 + yb * yb;\n      temp = za * HEX_40000000;\n      double temp2 = za + temp - temp;\n      zb += za - temp2;\n      za = temp2;\n\n      zb = za * yb + ya * zb + zb * yb;\n      za = za * ya;\n\n      double na = xs - za;\n      double nb = -(na - xs + za);\n      nb -= zb;\n\n      est += (na+nb)/(3*est*est);\n\n      /* Scale by a power of two, so this is exact. */\n      est *= p2;\n\n      if (subnormal) {\n          est *= 3.814697265625E-6;  // 2^-18\n      }\n\n      return est;\n    }",
          "25": "    public static double cbrt(double x) {\n      /* Convert input double to bits */\n      long inbits = Double.doubleToRawLongBits(x);\n      int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n      boolean subnormal = false;\n\n      if (exponent == -1023) {\n          if (x == 0) {\n              return x;\n          }\n\n          /* Subnormal, so normalize */\n          subnormal = true;\n          x *= 1.8014398509481984E16;  // 2^54\n          inbits = Double.doubleToRawLongBits(x);\n          exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n      }\n\n      if (exponent == 1024) {\n          // Nan or infinity.  Don't care which.\n          return x;\n      }\n\n      /* Divide the exponent by 3 */\n      int exp3 = exponent / 3;\n\n      /* p2 will be the nearest power of 2 to x with its exponent divided by 3 */\ndouble p2 = Double.longBitsToDouble(((inbits & 0x8000000000000000L) | ((long)((exp3 + 1023) | false) << 52)));\n\n      /* This will be a number between 1 and 2 */\n      final double mant = Double.longBitsToDouble((inbits & 0x000fffffffffffffL) | 0x3ff0000000000000L);\n\n      /* Estimate the cube root of mant by polynomial */\n      double est = -0.010714690733195933;\n      est = est * mant + 0.0875862700108075;\n      est = est * mant + -0.3058015757857271;\n      est = est * mant + 0.7249995199969751;\n      est = est * mant + 0.5039018405998233;\n\n      est *= CBRTTWO[exponent % 3 + 2];\n\n      // est should now be good to about 15 bits of precision.   Do 2 rounds of\n      // Newton's method to get closer,  this should get us full double precision\n      // Scale down x for the purpose of doing newtons method.  This avoids over/under flows.\n      final double xs = x / (p2*p2*p2);\n      est += (xs - est*est*est) / (3*est*est);\n      est += (xs - est*est*est) / (3*est*est);\n\n      // Do one round of Newton's method in extended precision to get the last bit right.\n      double temp = est * HEX_40000000;\n      double ya = est + temp - temp;\n      double yb = est - ya;\n\n      double za = ya * ya;\n      double zb = ya * yb * 2.0 + yb * yb;\n      temp = za * HEX_40000000;\n      double temp2 = za + temp - temp;\n      zb += za - temp2;\n      za = temp2;\n\n      zb = za * yb + ya * zb + zb * yb;\n      za = za * ya;\n\n      double na = xs - za;\n      double nb = -(na - xs + za);\n      nb -= zb;\n\n      est += (na+nb)/(3*est*est);\n\n      /* Scale by a power of two, so this is exact. */\n      est *= p2;\n\n      if (subnormal) {\n          est *= 3.814697265625E-6;  // 2^-18\n      }\n\n      return est;\n    }",
          "26": "    public static double cbrt(double x) {\n      /* Convert input double to bits */\n      long inbits = Double.doubleToRawLongBits(x);\n      int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n      boolean subnormal = false;\n\n      if (exponent == -1023) {\n          if (x == 0) {\n              return x;\n          }\n\n          /* Subnormal, so normalize */\n          subnormal = true;\n          x *= 1.8014398509481984E16;  // 2^54\n          inbits = Double.doubleToRawLongBits(x);\n          exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n      }\n\n      if (exponent == 1024) {\n          // Nan or infinity.  Don't care which.\n          return x;\n      }\n\n      /* Divide the exponent by 3 */\n      int exp3 = exponent / 3;\n\n      /* p2 will be the nearest power of 2 to x with its exponent divided by 3 */\ndouble p2 = Double.longBitsToDouble(((inbits & 0x8000000000000000L) | ((long)((exp3 + 1023) | 2047) >>> 52)));\n\n      /* This will be a number between 1 and 2 */\n      final double mant = Double.longBitsToDouble((inbits & 0x000fffffffffffffL) | 0x3ff0000000000000L);\n\n      /* Estimate the cube root of mant by polynomial */\n      double est = -0.010714690733195933;\n      est = est * mant + 0.0875862700108075;\n      est = est * mant + -0.3058015757857271;\n      est = est * mant + 0.7249995199969751;\n      est = est * mant + 0.5039018405998233;\n\n      est *= CBRTTWO[exponent % 3 + 2];\n\n      // est should now be good to about 15 bits of precision.   Do 2 rounds of\n      // Newton's method to get closer,  this should get us full double precision\n      // Scale down x for the purpose of doing newtons method.  This avoids over/under flows.\n      final double xs = x / (p2*p2*p2);\n      est += (xs - est*est*est) / (3*est*est);\n      est += (xs - est*est*est) / (3*est*est);\n\n      // Do one round of Newton's method in extended precision to get the last bit right.\n      double temp = est * HEX_40000000;\n      double ya = est + temp - temp;\n      double yb = est - ya;\n\n      double za = ya * ya;\n      double zb = ya * yb * 2.0 + yb * yb;\n      temp = za * HEX_40000000;\n      double temp2 = za + temp - temp;\n      zb += za - temp2;\n      za = temp2;\n\n      zb = za * yb + ya * zb + zb * yb;\n      za = za * ya;\n\n      double na = xs - za;\n      double nb = -(na - xs + za);\n      nb -= zb;\n\n      est += (na+nb)/(3*est*est);\n\n      /* Scale by a power of two, so this is exact. */\n      est *= p2;\n\n      if (subnormal) {\n          est *= 3.814697265625E-6;  // 2^-18\n      }\n\n      return est;\n    }",
          "27": "    public static double cbrt(double x) {\n      /* Convert input double to bits */\n      long inbits = Double.doubleToRawLongBits(x);\n      int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n      boolean subnormal = false;\n\n      if (exponent == -1023) {\n          if (x == 0) {\n              return x;\n          }\n\n          /* Subnormal, so normalize */\n          subnormal = true;\n          x *= 1.8014398509481984E16;  // 2^54\n          inbits = Double.doubleToRawLongBits(x);\n          exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n      }\n\n      if (exponent == 1024) {\n          // Nan or infinity.  Don't care which.\n          return x;\n      }\n\n      /* Divide the exponent by 3 */\n      int exp3 = exponent / 3;\n\n      /* p2 will be the nearest power of 2 to x with its exponent divided by 3 */\ndouble p2 = Double.longBitsToDouble(((inbits & 0x8000000000000000L) | ((long)((exp3 + 1023) | true) << 52)));\n\n      /* This will be a number between 1 and 2 */\n      final double mant = Double.longBitsToDouble((inbits & 0x000fffffffffffffL) | 0x3ff0000000000000L);\n\n      /* Estimate the cube root of mant by polynomial */\n      double est = -0.010714690733195933;\n      est = est * mant + 0.0875862700108075;\n      est = est * mant + -0.3058015757857271;\n      est = est * mant + 0.7249995199969751;\n      est = est * mant + 0.5039018405998233;\n\n      est *= CBRTTWO[exponent % 3 + 2];\n\n      // est should now be good to about 15 bits of precision.   Do 2 rounds of\n      // Newton's method to get closer,  this should get us full double precision\n      // Scale down x for the purpose of doing newtons method.  This avoids over/under flows.\n      final double xs = x / (p2*p2*p2);\n      est += (xs - est*est*est) / (3*est*est);\n      est += (xs - est*est*est) / (3*est*est);\n\n      // Do one round of Newton's method in extended precision to get the last bit right.\n      double temp = est * HEX_40000000;\n      double ya = est + temp - temp;\n      double yb = est - ya;\n\n      double za = ya * ya;\n      double zb = ya * yb * 2.0 + yb * yb;\n      temp = za * HEX_40000000;\n      double temp2 = za + temp - temp;\n      zb += za - temp2;\n      za = temp2;\n\n      zb = za * yb + ya * zb + zb * yb;\n      za = za * ya;\n\n      double na = xs - za;\n      double nb = -(na - xs + za);\n      nb -= zb;\n\n      est += (na+nb)/(3*est*est);\n\n      /* Scale by a power of two, so this is exact. */\n      est *= p2;\n\n      if (subnormal) {\n          est *= 3.814697265625E-6;  // 2^-18\n      }\n\n      return est;\n    }",
          "28": "    public static double cbrt(double x) {\n      /* Convert input double to bits */\n      long inbits = Double.doubleToRawLongBits(x);\n      int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n      boolean subnormal = false;\n\n      if (exponent == -1023) {\n          if (x == 0) {\n              return x;\n          }\n\n          /* Subnormal, so normalize */\n          subnormal = true;\n          x *= 1.8014398509481984E16;  // 2^54\n          inbits = Double.doubleToRawLongBits(x);\n          exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n      }\n\n      if (exponent == 1024) {\n          // Nan or infinity.  Don't care which.\n          return x;\n      }\n\n      /* Divide the exponent by 3 */\n      int exp3 = exponent / 3;\n\n      /* p2 will be the nearest power of 2 to x with its exponent divided by 3 */\ndouble p2 = Double.longBitsToDouble(((inbits & 0x8000000000000000L) | ((long)((exp3 + 1023) | 3) << 52)));\n\n      /* This will be a number between 1 and 2 */\n      final double mant = Double.longBitsToDouble((inbits & 0x000fffffffffffffL) | 0x3ff0000000000000L);\n\n      /* Estimate the cube root of mant by polynomial */\n      double est = -0.010714690733195933;\n      est = est * mant + 0.0875862700108075;\n      est = est * mant + -0.3058015757857271;\n      est = est * mant + 0.7249995199969751;\n      est = est * mant + 0.5039018405998233;\n\n      est *= CBRTTWO[exponent % 3 + 2];\n\n      // est should now be good to about 15 bits of precision.   Do 2 rounds of\n      // Newton's method to get closer,  this should get us full double precision\n      // Scale down x for the purpose of doing newtons method.  This avoids over/under flows.\n      final double xs = x / (p2*p2*p2);\n      est += (xs - est*est*est) / (3*est*est);\n      est += (xs - est*est*est) / (3*est*est);\n\n      // Do one round of Newton's method in extended precision to get the last bit right.\n      double temp = est * HEX_40000000;\n      double ya = est + temp - temp;\n      double yb = est - ya;\n\n      double za = ya * ya;\n      double zb = ya * yb * 2.0 + yb * yb;\n      temp = za * HEX_40000000;\n      double temp2 = za + temp - temp;\n      zb += za - temp2;\n      za = temp2;\n\n      zb = za * yb + ya * zb + zb * yb;\n      za = za * ya;\n\n      double na = xs - za;\n      double nb = -(na - xs + za);\n      nb -= zb;\n\n      est += (na+nb)/(3*est*est);\n\n      /* Scale by a power of two, so this is exact. */\n      est *= p2;\n\n      if (subnormal) {\n          est *= 3.814697265625E-6;  // 2^-18\n      }\n\n      return est;\n    }",
          "29": "    public static double cbrt(double x) {\n      /* Convert input double to bits */\n      long inbits = Double.doubleToRawLongBits(x);\n      int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n      boolean subnormal = false;\n\n      if (exponent == -1023) {\n          if (x == 0) {\n              return x;\n          }\n\n          /* Subnormal, so normalize */\n          subnormal = true;\n          x *= 1.8014398509481984E16;  // 2^54\n          inbits = Double.doubleToRawLongBits(x);\n          exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n      }\n\n      if (exponent == 1024) {\n          // Nan or infinity.  Don't care which.\n          return x;\n      }\n\n      /* Divide the exponent by 3 */\n      int exp3 = exponent / 3;\n\n      /* p2 will be the nearest power of 2 to x with its exponent divided by 3 */\ndouble p2 = Double.longBitsToDouble(((inbits & 0x8000000000000000L) | ((long)((exp3 + 1023) | \"null\") << 52)));\n\n      /* This will be a number between 1 and 2 */\n      final double mant = Double.longBitsToDouble((inbits & 0x000fffffffffffffL) | 0x3ff0000000000000L);\n\n      /* Estimate the cube root of mant by polynomial */\n      double est = -0.010714690733195933;\n      est = est * mant + 0.0875862700108075;\n      est = est * mant + -0.3058015757857271;\n      est = est * mant + 0.7249995199969751;\n      est = est * mant + 0.5039018405998233;\n\n      est *= CBRTTWO[exponent % 3 + 2];\n\n      // est should now be good to about 15 bits of precision.   Do 2 rounds of\n      // Newton's method to get closer,  this should get us full double precision\n      // Scale down x for the purpose of doing newtons method.  This avoids over/under flows.\n      final double xs = x / (p2*p2*p2);\n      est += (xs - est*est*est) / (3*est*est);\n      est += (xs - est*est*est) / (3*est*est);\n\n      // Do one round of Newton's method in extended precision to get the last bit right.\n      double temp = est * HEX_40000000;\n      double ya = est + temp - temp;\n      double yb = est - ya;\n\n      double za = ya * ya;\n      double zb = ya * yb * 2.0 + yb * yb;\n      temp = za * HEX_40000000;\n      double temp2 = za + temp - temp;\n      zb += za - temp2;\n      za = temp2;\n\n      zb = za * yb + ya * zb + zb * yb;\n      za = za * ya;\n\n      double na = xs - za;\n      double nb = -(na - xs + za);\n      nb -= zb;\n\n      est += (na+nb)/(3*est*est);\n\n      /* Scale by a power of two, so this is exact. */\n      est *= p2;\n\n      if (subnormal) {\n          est *= 3.814697265625E-6;  // 2^-18\n      }\n\n      return est;\n    }",
          "30": "    public static double cbrt(double x) {\n      /* Convert input double to bits */\n      long inbits = Double.doubleToRawLongBits(x);\n      int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n      boolean subnormal = false;\n\n      if (exponent == -1023) {\n          if (x == 0) {\n              return x;\n          }\n\n          /* Subnormal, so normalize */\n          subnormal = true;\n          x *= 1.8014398509481984E16;  // 2^54\n          inbits = Double.doubleToRawLongBits(x);\n          exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n      }\n\n      if (exponent == 1024) {\n          // Nan or infinity.  Don't care which.\n          return x;\n      }\n\n      /* Divide the exponent by 3 */\n      int exp3 = exponent / 3;\n\n      /* p2 will be the nearest power of 2 to x with its exponent divided by 3 */\ndouble p2 = Double.longBitsToDouble(((inbits & 0x8000000000000000L) | ((long)((exp3 + 1023) | 2047) << -1)));\n\n      /* This will be a number between 1 and 2 */\n      final double mant = Double.longBitsToDouble((inbits & 0x000fffffffffffffL) | 0x3ff0000000000000L);\n\n      /* Estimate the cube root of mant by polynomial */\n      double est = -0.010714690733195933;\n      est = est * mant + 0.0875862700108075;\n      est = est * mant + -0.3058015757857271;\n      est = est * mant + 0.7249995199969751;\n      est = est * mant + 0.5039018405998233;\n\n      est *= CBRTTWO[exponent % 3 + 2];\n\n      // est should now be good to about 15 bits of precision.   Do 2 rounds of\n      // Newton's method to get closer,  this should get us full double precision\n      // Scale down x for the purpose of doing newtons method.  This avoids over/under flows.\n      final double xs = x / (p2*p2*p2);\n      est += (xs - est*est*est) / (3*est*est);\n      est += (xs - est*est*est) / (3*est*est);\n\n      // Do one round of Newton's method in extended precision to get the last bit right.\n      double temp = est * HEX_40000000;\n      double ya = est + temp - temp;\n      double yb = est - ya;\n\n      double za = ya * ya;\n      double zb = ya * yb * 2.0 + yb * yb;\n      temp = za * HEX_40000000;\n      double temp2 = za + temp - temp;\n      zb += za - temp2;\n      za = temp2;\n\n      zb = za * yb + ya * zb + zb * yb;\n      za = za * ya;\n\n      double na = xs - za;\n      double nb = -(na - xs + za);\n      nb -= zb;\n\n      est += (na+nb)/(3*est*est);\n\n      /* Scale by a power of two, so this is exact. */\n      est *= p2;\n\n      if (subnormal) {\n          est *= 3.814697265625E-6;  // 2^-18\n      }\n\n      return est;\n    }",
          "31": "    public static double cbrt(double x) {\n      /* Convert input double to bits */\n      long inbits = Double.doubleToRawLongBits(x);\n      int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n      boolean subnormal = false;\n\n      if (exponent == -1023) {\n          if (x == 0) {\n              return x;\n          }\n\n          /* Subnormal, so normalize */\n          subnormal = true;\n          x *= 1.8014398509481984E16;  // 2^54\n          inbits = Double.doubleToRawLongBits(x);\n          exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n      }\n\n      if (exponent == 1024) {\n          // Nan or infinity.  Don't care which.\n          return x;\n      }\n\n      /* Divide the exponent by 3 */\n      int exp3 = exponent / 3;\n\n      /* p2 will be the nearest power of 2 to x with its exponent divided by 3 */\ndouble p2 = Double.longBitsToDouble(((inbits & 0x8000000000000000L) | ((long)((exp3 + 3) | 2047) << 52)));\n\n      /* This will be a number between 1 and 2 */\n      final double mant = Double.longBitsToDouble((inbits & 0x000fffffffffffffL) | 0x3ff0000000000000L);\n\n      /* Estimate the cube root of mant by polynomial */\n      double est = -0.010714690733195933;\n      est = est * mant + 0.0875862700108075;\n      est = est * mant + -0.3058015757857271;\n      est = est * mant + 0.7249995199969751;\n      est = est * mant + 0.5039018405998233;\n\n      est *= CBRTTWO[exponent % 3 + 2];\n\n      // est should now be good to about 15 bits of precision.   Do 2 rounds of\n      // Newton's method to get closer,  this should get us full double precision\n      // Scale down x for the purpose of doing newtons method.  This avoids over/under flows.\n      final double xs = x / (p2*p2*p2);\n      est += (xs - est*est*est) / (3*est*est);\n      est += (xs - est*est*est) / (3*est*est);\n\n      // Do one round of Newton's method in extended precision to get the last bit right.\n      double temp = est * HEX_40000000;\n      double ya = est + temp - temp;\n      double yb = est - ya;\n\n      double za = ya * ya;\n      double zb = ya * yb * 2.0 + yb * yb;\n      temp = za * HEX_40000000;\n      double temp2 = za + temp - temp;\n      zb += za - temp2;\n      za = temp2;\n\n      zb = za * yb + ya * zb + zb * yb;\n      za = za * ya;\n\n      double na = xs - za;\n      double nb = -(na - xs + za);\n      nb -= zb;\n\n      est += (na+nb)/(3*est*est);\n\n      /* Scale by a power of two, so this is exact. */\n      est *= p2;\n\n      if (subnormal) {\n          est *= 3.814697265625E-6;  // 2^-18\n      }\n\n      return est;\n    }",
          "32": "    public static double cbrt(double x) {\n      /* Convert input double to bits */\n      long inbits = Double.doubleToRawLongBits(x);\n      int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n      boolean subnormal = false;\n\n      if (exponent == -1023) {\n          if (x == 0) {\n              return x;\n          }\n\n          /* Subnormal, so normalize */\n          subnormal = true;\n          x *= 1.8014398509481984E16;  // 2^54\n          inbits = Double.doubleToRawLongBits(x);\n          exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n      }\n\n      if (exponent == 1024) {\n          // Nan or infinity.  Don't care which.\n          return x;\n      }\n\n      /* Divide the exponent by 3 */\n      int exp3 = exponent / 3;\n\n      /* p2 will be the nearest power of 2 to x with its exponent divided by 3 */\ndouble p2 = Double.longBitsToDouble(((inbits & 0x8000000000000000L) | ((long)((exp3 + 1023) + 2047) << 52)));\n\n      /* This will be a number between 1 and 2 */\n      final double mant = Double.longBitsToDouble((inbits & 0x000fffffffffffffL) | 0x3ff0000000000000L);\n\n      /* Estimate the cube root of mant by polynomial */\n      double est = -0.010714690733195933;\n      est = est * mant + 0.0875862700108075;\n      est = est * mant + -0.3058015757857271;\n      est = est * mant + 0.7249995199969751;\n      est = est * mant + 0.5039018405998233;\n\n      est *= CBRTTWO[exponent % 3 + 2];\n\n      // est should now be good to about 15 bits of precision.   Do 2 rounds of\n      // Newton's method to get closer,  this should get us full double precision\n      // Scale down x for the purpose of doing newtons method.  This avoids over/under flows.\n      final double xs = x / (p2*p2*p2);\n      est += (xs - est*est*est) / (3*est*est);\n      est += (xs - est*est*est) / (3*est*est);\n\n      // Do one round of Newton's method in extended precision to get the last bit right.\n      double temp = est * HEX_40000000;\n      double ya = est + temp - temp;\n      double yb = est - ya;\n\n      double za = ya * ya;\n      double zb = ya * yb * 2.0 + yb * yb;\n      temp = za * HEX_40000000;\n      double temp2 = za + temp - temp;\n      zb += za - temp2;\n      za = temp2;\n\n      zb = za * yb + ya * zb + zb * yb;\n      za = za * ya;\n\n      double na = xs - za;\n      double nb = -(na - xs + za);\n      nb -= zb;\n\n      est += (na+nb)/(3*est*est);\n\n      /* Scale by a power of two, so this is exact. */\n      est *= p2;\n\n      if (subnormal) {\n          est *= 3.814697265625E-6;  // 2^-18\n      }\n\n      return est;\n    }",
          "33": "    public static double cbrt(double x) {\n      /* Convert input double to bits */\n      long inbits = Double.doubleToRawLongBits(x);\n      int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n      boolean subnormal = false;\n\n      if (exponent == -1023) {\n          if (x == 0) {\n              return x;\n          }\n\n          /* Subnormal, so normalize */\n          subnormal = true;\n          x *= 1.8014398509481984E16;  // 2^54\n          inbits = Double.doubleToRawLongBits(x);\n          exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n      }\n\n      if (exponent == 1024) {\n          // Nan or infinity.  Don't care which.\n          return x;\n      }\n\n      /* Divide the exponent by 3 */\n      int exp3 = exponent / 3;\n\n      /* p2 will be the nearest power of 2 to x with its exponent divided by 3 */\ndouble p2 = Double.longBitsToDouble(((inbits & 0x8000000000000000L) | ((long)((exp3 + 1023) | 2047) << 2047)));\n\n      /* This will be a number between 1 and 2 */\n      final double mant = Double.longBitsToDouble((inbits & 0x000fffffffffffffL) | 0x3ff0000000000000L);\n\n      /* Estimate the cube root of mant by polynomial */\n      double est = -0.010714690733195933;\n      est = est * mant + 0.0875862700108075;\n      est = est * mant + -0.3058015757857271;\n      est = est * mant + 0.7249995199969751;\n      est = est * mant + 0.5039018405998233;\n\n      est *= CBRTTWO[exponent % 3 + 2];\n\n      // est should now be good to about 15 bits of precision.   Do 2 rounds of\n      // Newton's method to get closer,  this should get us full double precision\n      // Scale down x for the purpose of doing newtons method.  This avoids over/under flows.\n      final double xs = x / (p2*p2*p2);\n      est += (xs - est*est*est) / (3*est*est);\n      est += (xs - est*est*est) / (3*est*est);\n\n      // Do one round of Newton's method in extended precision to get the last bit right.\n      double temp = est * HEX_40000000;\n      double ya = est + temp - temp;\n      double yb = est - ya;\n\n      double za = ya * ya;\n      double zb = ya * yb * 2.0 + yb * yb;\n      temp = za * HEX_40000000;\n      double temp2 = za + temp - temp;\n      zb += za - temp2;\n      za = temp2;\n\n      zb = za * yb + ya * zb + zb * yb;\n      za = za * ya;\n\n      double na = xs - za;\n      double nb = -(na - xs + za);\n      nb -= zb;\n\n      est += (na+nb)/(3*est*est);\n\n      /* Scale by a power of two, so this is exact. */\n      est *= p2;\n\n      if (subnormal) {\n          est *= 3.814697265625E-6;  // 2^-18\n      }\n\n      return est;\n    }",
          "34": "    public static double cbrt(double x) {\n      /* Convert input double to bits */\n      long inbits = Double.doubleToRawLongBits(x);\n      int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n      boolean subnormal = false;\n\n      if (exponent == -1023) {\n          if (x == 0) {\n              return x;\n          }\n\n          /* Subnormal, so normalize */\n          subnormal = true;\n          x *= 1.8014398509481984E16;  // 2^54\n          inbits = Double.doubleToRawLongBits(x);\n          exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n      }\n\n      if (exponent == 1024) {\n          // Nan or infinity.  Don't care which.\n          return x;\n      }\n\n      /* Divide the exponent by 3 */\n      int exp3 = exponent / 3;\n\n      /* p2 will be the nearest power of 2 to x with its exponent divided by 3 */\ndouble p2 = Double.longBitsToDouble(((inbits & 0x8000000000000000L) | ((long)((exp3 + 1023) | 2047) << 1023)));\n\n      /* This will be a number between 1 and 2 */\n      final double mant = Double.longBitsToDouble((inbits & 0x000fffffffffffffL) | 0x3ff0000000000000L);\n\n      /* Estimate the cube root of mant by polynomial */\n      double est = -0.010714690733195933;\n      est = est * mant + 0.0875862700108075;\n      est = est * mant + -0.3058015757857271;\n      est = est * mant + 0.7249995199969751;\n      est = est * mant + 0.5039018405998233;\n\n      est *= CBRTTWO[exponent % 3 + 2];\n\n      // est should now be good to about 15 bits of precision.   Do 2 rounds of\n      // Newton's method to get closer,  this should get us full double precision\n      // Scale down x for the purpose of doing newtons method.  This avoids over/under flows.\n      final double xs = x / (p2*p2*p2);\n      est += (xs - est*est*est) / (3*est*est);\n      est += (xs - est*est*est) / (3*est*est);\n\n      // Do one round of Newton's method in extended precision to get the last bit right.\n      double temp = est * HEX_40000000;\n      double ya = est + temp - temp;\n      double yb = est - ya;\n\n      double za = ya * ya;\n      double zb = ya * yb * 2.0 + yb * yb;\n      temp = za * HEX_40000000;\n      double temp2 = za + temp - temp;\n      zb += za - temp2;\n      za = temp2;\n\n      zb = za * yb + ya * zb + zb * yb;\n      za = za * ya;\n\n      double na = xs - za;\n      double nb = -(na - xs + za);\n      nb -= zb;\n\n      est += (na+nb)/(3*est*est);\n\n      /* Scale by a power of two, so this is exact. */\n      est *= p2;\n\n      if (subnormal) {\n          est *= 3.814697265625E-6;  // 2^-18\n      }\n\n      return est;\n    }",
          "35": "    public static double cbrt(double x) {\n      /* Convert input double to bits */\n      long inbits = Double.doubleToRawLongBits(x);\n      int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n      boolean subnormal = false;\n\n      if (exponent == -1023) {\n          if (x == 0) {\n              return x;\n          }\n\n          /* Subnormal, so normalize */\n          subnormal = true;\n          x *= 1.8014398509481984E16;  // 2^54\n          inbits = Double.doubleToRawLongBits(x);\n          exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n      }\n\n      if (exponent == 1024) {\n          // Nan or infinity.  Don't care which.\n          return x;\n      }\n\n      /* Divide the exponent by 3 */\n      int exp3 = exponent / 3;\n\n      /* p2 will be the nearest power of 2 to x with its exponent divided by 3 */\ndouble p2 = Double.longBitsToDouble(((inbits & 0x8000000000000000L) | ((long)((exp3 + true) | 2047) << 52)));\n\n      /* This will be a number between 1 and 2 */\n      final double mant = Double.longBitsToDouble((inbits & 0x000fffffffffffffL) | 0x3ff0000000000000L);\n\n      /* Estimate the cube root of mant by polynomial */\n      double est = -0.010714690733195933;\n      est = est * mant + 0.0875862700108075;\n      est = est * mant + -0.3058015757857271;\n      est = est * mant + 0.7249995199969751;\n      est = est * mant + 0.5039018405998233;\n\n      est *= CBRTTWO[exponent % 3 + 2];\n\n      // est should now be good to about 15 bits of precision.   Do 2 rounds of\n      // Newton's method to get closer,  this should get us full double precision\n      // Scale down x for the purpose of doing newtons method.  This avoids over/under flows.\n      final double xs = x / (p2*p2*p2);\n      est += (xs - est*est*est) / (3*est*est);\n      est += (xs - est*est*est) / (3*est*est);\n\n      // Do one round of Newton's method in extended precision to get the last bit right.\n      double temp = est * HEX_40000000;\n      double ya = est + temp - temp;\n      double yb = est - ya;\n\n      double za = ya * ya;\n      double zb = ya * yb * 2.0 + yb * yb;\n      temp = za * HEX_40000000;\n      double temp2 = za + temp - temp;\n      zb += za - temp2;\n      za = temp2;\n\n      zb = za * yb + ya * zb + zb * yb;\n      za = za * ya;\n\n      double na = xs - za;\n      double nb = -(na - xs + za);\n      nb -= zb;\n\n      est += (na+nb)/(3*est*est);\n\n      /* Scale by a power of two, so this is exact. */\n      est *= p2;\n\n      if (subnormal) {\n          est *= 3.814697265625E-6;  // 2^-18\n      }\n\n      return est;\n    }",
          "36": "    public static double cbrt(double x) {\n      /* Convert input double to bits */\n      long inbits = Double.doubleToRawLongBits(x);\n      int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n      boolean subnormal = false;\n\n      if (exponent == -1023) {\n          if (x == 0) {\n              return x;\n          }\n\n          /* Subnormal, so normalize */\n          subnormal = true;\n          x *= 1.8014398509481984E16;  // 2^54\n          inbits = Double.doubleToRawLongBits(x);\n          exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n      }\n\n      if (exponent == 1024) {\n          // Nan or infinity.  Don't care which.\n          return x;\n      }\n\n      /* Divide the exponent by 3 */\n      int exp3 = exponent / 3;\n\n      /* p2 will be the nearest power of 2 to x with its exponent divided by 3 */\ndouble p2 = Double.longBitsToDouble(((inbits & 0x8000000000000000L) | ((long)((exp3 + false) | 2047) << 52)));\n\n      /* This will be a number between 1 and 2 */\n      final double mant = Double.longBitsToDouble((inbits & 0x000fffffffffffffL) | 0x3ff0000000000000L);\n\n      /* Estimate the cube root of mant by polynomial */\n      double est = -0.010714690733195933;\n      est = est * mant + 0.0875862700108075;\n      est = est * mant + -0.3058015757857271;\n      est = est * mant + 0.7249995199969751;\n      est = est * mant + 0.5039018405998233;\n\n      est *= CBRTTWO[exponent % 3 + 2];\n\n      // est should now be good to about 15 bits of precision.   Do 2 rounds of\n      // Newton's method to get closer,  this should get us full double precision\n      // Scale down x for the purpose of doing newtons method.  This avoids over/under flows.\n      final double xs = x / (p2*p2*p2);\n      est += (xs - est*est*est) / (3*est*est);\n      est += (xs - est*est*est) / (3*est*est);\n\n      // Do one round of Newton's method in extended precision to get the last bit right.\n      double temp = est * HEX_40000000;\n      double ya = est + temp - temp;\n      double yb = est - ya;\n\n      double za = ya * ya;\n      double zb = ya * yb * 2.0 + yb * yb;\n      temp = za * HEX_40000000;\n      double temp2 = za + temp - temp;\n      zb += za - temp2;\n      za = temp2;\n\n      zb = za * yb + ya * zb + zb * yb;\n      za = za * ya;\n\n      double na = xs - za;\n      double nb = -(na - xs + za);\n      nb -= zb;\n\n      est += (na+nb)/(3*est*est);\n\n      /* Scale by a power of two, so this is exact. */\n      est *= p2;\n\n      if (subnormal) {\n          est *= 3.814697265625E-6;  // 2^-18\n      }\n\n      return est;\n    }",
          "37": "    public static double cbrt(double x) {\n      /* Convert input double to bits */\n      long inbits = Double.doubleToRawLongBits(x);\n      int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n      boolean subnormal = false;\n\n      if (exponent == -1023) {\n          if (x == 0) {\n              return x;\n          }\n\n          /* Subnormal, so normalize */\n          subnormal = true;\n          x *= 1.8014398509481984E16;  // 2^54\n          inbits = Double.doubleToRawLongBits(x);\n          exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n      }\n\n      if (exponent == 1024) {\n          // Nan or infinity.  Don't care which.\n          return x;\n      }\n\n      /* Divide the exponent by 3 */\n      int exp3 = exponent / 3;\n\n      /* p2 will be the nearest power of 2 to x with its exponent divided by 3 */\ndouble p2 = Double.longBitsToDouble(((inbits & 0x8000000000000000L) | ((long)((exp3 + \"null\") | 2047) << 52)));\n\n      /* This will be a number between 1 and 2 */\n      final double mant = Double.longBitsToDouble((inbits & 0x000fffffffffffffL) | 0x3ff0000000000000L);\n\n      /* Estimate the cube root of mant by polynomial */\n      double est = -0.010714690733195933;\n      est = est * mant + 0.0875862700108075;\n      est = est * mant + -0.3058015757857271;\n      est = est * mant + 0.7249995199969751;\n      est = est * mant + 0.5039018405998233;\n\n      est *= CBRTTWO[exponent % 3 + 2];\n\n      // est should now be good to about 15 bits of precision.   Do 2 rounds of\n      // Newton's method to get closer,  this should get us full double precision\n      // Scale down x for the purpose of doing newtons method.  This avoids over/under flows.\n      final double xs = x / (p2*p2*p2);\n      est += (xs - est*est*est) / (3*est*est);\n      est += (xs - est*est*est) / (3*est*est);\n\n      // Do one round of Newton's method in extended precision to get the last bit right.\n      double temp = est * HEX_40000000;\n      double ya = est + temp - temp;\n      double yb = est - ya;\n\n      double za = ya * ya;\n      double zb = ya * yb * 2.0 + yb * yb;\n      temp = za * HEX_40000000;\n      double temp2 = za + temp - temp;\n      zb += za - temp2;\n      za = temp2;\n\n      zb = za * yb + ya * zb + zb * yb;\n      za = za * ya;\n\n      double na = xs - za;\n      double nb = -(na - xs + za);\n      nb -= zb;\n\n      est += (na+nb)/(3*est*est);\n\n      /* Scale by a power of two, so this is exact. */\n      est *= p2;\n\n      if (subnormal) {\n          est *= 3.814697265625E-6;  // 2^-18\n      }\n\n      return est;\n    }",
          "38": "    public static double cbrt(double x) {\n      /* Convert input double to bits */\n      long inbits = Double.doubleToRawLongBits(x);\n      int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n      boolean subnormal = false;\n\n      if (exponent == -1023) {\n          if (x == 0) {\n              return x;\n          }\n\n          /* Subnormal, so normalize */\n          subnormal = true;\n          x *= 1.8014398509481984E16;  // 2^54\n          inbits = Double.doubleToRawLongBits(x);\n          exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n      }\n\n      if (exponent == 1024) {\n          // Nan or infinity.  Don't care which.\n          return x;\n      }\n\n      /* Divide the exponent by 3 */\n      int exp3 = exponent / 3;\n\n      /* p2 will be the nearest power of 2 to x with its exponent divided by 3 */\ndouble p2 = Double.longBitsToDouble(((inbits & 0x8000000000000000L) | ((long)((exp3 + 1023) * 2047) << 52)));\n\n      /* This will be a number between 1 and 2 */\n      final double mant = Double.longBitsToDouble((inbits & 0x000fffffffffffffL) | 0x3ff0000000000000L);\n\n      /* Estimate the cube root of mant by polynomial */\n      double est = -0.010714690733195933;\n      est = est * mant + 0.0875862700108075;\n      est = est * mant + -0.3058015757857271;\n      est = est * mant + 0.7249995199969751;\n      est = est * mant + 0.5039018405998233;\n\n      est *= CBRTTWO[exponent % 3 + 2];\n\n      // est should now be good to about 15 bits of precision.   Do 2 rounds of\n      // Newton's method to get closer,  this should get us full double precision\n      // Scale down x for the purpose of doing newtons method.  This avoids over/under flows.\n      final double xs = x / (p2*p2*p2);\n      est += (xs - est*est*est) / (3*est*est);\n      est += (xs - est*est*est) / (3*est*est);\n\n      // Do one round of Newton's method in extended precision to get the last bit right.\n      double temp = est * HEX_40000000;\n      double ya = est + temp - temp;\n      double yb = est - ya;\n\n      double za = ya * ya;\n      double zb = ya * yb * 2.0 + yb * yb;\n      temp = za * HEX_40000000;\n      double temp2 = za + temp - temp;\n      zb += za - temp2;\n      za = temp2;\n\n      zb = za * yb + ya * zb + zb * yb;\n      za = za * ya;\n\n      double na = xs - za;\n      double nb = -(na - xs + za);\n      nb -= zb;\n\n      est += (na+nb)/(3*est*est);\n\n      /* Scale by a power of two, so this is exact. */\n      est *= p2;\n\n      if (subnormal) {\n          est *= 3.814697265625E-6;  // 2^-18\n      }\n\n      return est;\n    }",
          "39": "    public static double cbrt(double x) {\n      /* Convert input double to bits */\n      long inbits = Double.doubleToRawLongBits(x);\n      int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n      boolean subnormal = false;\n\n      if (exponent == -1023) {\n          if (x == 0) {\n              return x;\n          }\n\n          /* Subnormal, so normalize */\n          subnormal = true;\n          x *= 1.8014398509481984E16;  // 2^54\n          inbits = Double.doubleToRawLongBits(x);\n          exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n      }\n\n      if (exponent == 1024) {\n          // Nan or infinity.  Don't care which.\n          return x;\n      }\n\n      /* Divide the exponent by 3 */\n      int exp3 = exponent / 3;\n\n      /* p2 will be the nearest power of 2 to x with its exponent divided by 3 */\ndouble p2 = Double.longBitsToDouble(((inbits & 0x8000000000000000L) | ((long)((exp3 + 1023) | -1) << 52)));\n\n      /* This will be a number between 1 and 2 */\n      final double mant = Double.longBitsToDouble((inbits & 0x000fffffffffffffL) | 0x3ff0000000000000L);\n\n      /* Estimate the cube root of mant by polynomial */\n      double est = -0.010714690733195933;\n      est = est * mant + 0.0875862700108075;\n      est = est * mant + -0.3058015757857271;\n      est = est * mant + 0.7249995199969751;\n      est = est * mant + 0.5039018405998233;\n\n      est *= CBRTTWO[exponent % 3 + 2];\n\n      // est should now be good to about 15 bits of precision.   Do 2 rounds of\n      // Newton's method to get closer,  this should get us full double precision\n      // Scale down x for the purpose of doing newtons method.  This avoids over/under flows.\n      final double xs = x / (p2*p2*p2);\n      est += (xs - est*est*est) / (3*est*est);\n      est += (xs - est*est*est) / (3*est*est);\n\n      // Do one round of Newton's method in extended precision to get the last bit right.\n      double temp = est * HEX_40000000;\n      double ya = est + temp - temp;\n      double yb = est - ya;\n\n      double za = ya * ya;\n      double zb = ya * yb * 2.0 + yb * yb;\n      temp = za * HEX_40000000;\n      double temp2 = za + temp - temp;\n      zb += za - temp2;\n      za = temp2;\n\n      zb = za * yb + ya * zb + zb * yb;\n      za = za * ya;\n\n      double na = xs - za;\n      double nb = -(na - xs + za);\n      nb -= zb;\n\n      est += (na+nb)/(3*est*est);\n\n      /* Scale by a power of two, so this is exact. */\n      est *= p2;\n\n      if (subnormal) {\n          est *= 3.814697265625E-6;  // 2^-18\n      }\n\n      return est;\n    }",
          "40": "    public static double cbrt(double x) {\n      /* Convert input double to bits */\n      long inbits = Double.doubleToRawLongBits(x);\n      int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n      boolean subnormal = false;\n\n      if (exponent == -1023) {\n          if (x == 0) {\n              return x;\n          }\n\n          /* Subnormal, so normalize */\n          subnormal = true;\n          x *= 1.8014398509481984E16;  // 2^54\n          inbits = Double.doubleToRawLongBits(x);\n          exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n      }\n\n      if (exponent == 1024) {\n          // Nan or infinity.  Don't care which.\n          return x;\n      }\n\n      /* Divide the exponent by 3 */\n      int exp3 = exponent / 3;\n\n      /* p2 will be the nearest power of 2 to x with its exponent divided by 3 */\ndouble p2 = Double.longBitsToDouble(((inbits & 0x8000000000000000L) | ((long)((exp3 + 1023) < 2047) << 52)));\n\n      /* This will be a number between 1 and 2 */\n      final double mant = Double.longBitsToDouble((inbits & 0x000fffffffffffffL) | 0x3ff0000000000000L);\n\n      /* Estimate the cube root of mant by polynomial */\n      double est = -0.010714690733195933;\n      est = est * mant + 0.0875862700108075;\n      est = est * mant + -0.3058015757857271;\n      est = est * mant + 0.7249995199969751;\n      est = est * mant + 0.5039018405998233;\n\n      est *= CBRTTWO[exponent % 3 + 2];\n\n      // est should now be good to about 15 bits of precision.   Do 2 rounds of\n      // Newton's method to get closer,  this should get us full double precision\n      // Scale down x for the purpose of doing newtons method.  This avoids over/under flows.\n      final double xs = x / (p2*p2*p2);\n      est += (xs - est*est*est) / (3*est*est);\n      est += (xs - est*est*est) / (3*est*est);\n\n      // Do one round of Newton's method in extended precision to get the last bit right.\n      double temp = est * HEX_40000000;\n      double ya = est + temp - temp;\n      double yb = est - ya;\n\n      double za = ya * ya;\n      double zb = ya * yb * 2.0 + yb * yb;\n      temp = za * HEX_40000000;\n      double temp2 = za + temp - temp;\n      zb += za - temp2;\n      za = temp2;\n\n      zb = za * yb + ya * zb + zb * yb;\n      za = za * ya;\n\n      double na = xs - za;\n      double nb = -(na - xs + za);\n      nb -= zb;\n\n      est += (na+nb)/(3*est*est);\n\n      /* Scale by a power of two, so this is exact. */\n      est *= p2;\n\n      if (subnormal) {\n          est *= 3.814697265625E-6;  // 2^-18\n      }\n\n      return est;\n    }",
          "41": "    public static double cbrt(double x) {\n      /* Convert input double to bits */\n      long inbits = Double.doubleToRawLongBits(x);\n      int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n      boolean subnormal = false;\n\n      if (exponent == -1023) {\n          if (x == 0) {\n              return x;\n          }\n\n          /* Subnormal, so normalize */\n          subnormal = true;\n          x *= 1.8014398509481984E16;  // 2^54\n          inbits = Double.doubleToRawLongBits(x);\n          exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n      }\n\n      if (exponent == 1024) {\n          // Nan or infinity.  Don't care which.\n          return x;\n      }\n\n      /* Divide the exponent by 3 */\n      int exp3 = exponent / 3;\n\n      /* p2 will be the nearest power of 2 to x with its exponent divided by 3 */\ndouble p2 = Double.longBitsToDouble(((inbits & 0x8000000000000000L) | ((long)((exp3 + 1023) | 2047) << null)));\n\n      /* This will be a number between 1 and 2 */\n      final double mant = Double.longBitsToDouble((inbits & 0x000fffffffffffffL) | 0x3ff0000000000000L);\n\n      /* Estimate the cube root of mant by polynomial */\n      double est = -0.010714690733195933;\n      est = est * mant + 0.0875862700108075;\n      est = est * mant + -0.3058015757857271;\n      est = est * mant + 0.7249995199969751;\n      est = est * mant + 0.5039018405998233;\n\n      est *= CBRTTWO[exponent % 3 + 2];\n\n      // est should now be good to about 15 bits of precision.   Do 2 rounds of\n      // Newton's method to get closer,  this should get us full double precision\n      // Scale down x for the purpose of doing newtons method.  This avoids over/under flows.\n      final double xs = x / (p2*p2*p2);\n      est += (xs - est*est*est) / (3*est*est);\n      est += (xs - est*est*est) / (3*est*est);\n\n      // Do one round of Newton's method in extended precision to get the last bit right.\n      double temp = est * HEX_40000000;\n      double ya = est + temp - temp;\n      double yb = est - ya;\n\n      double za = ya * ya;\n      double zb = ya * yb * 2.0 + yb * yb;\n      temp = za * HEX_40000000;\n      double temp2 = za + temp - temp;\n      zb += za - temp2;\n      za = temp2;\n\n      zb = za * yb + ya * zb + zb * yb;\n      za = za * ya;\n\n      double na = xs - za;\n      double nb = -(na - xs + za);\n      nb -= zb;\n\n      est += (na+nb)/(3*est*est);\n\n      /* Scale by a power of two, so this is exact. */\n      est *= p2;\n\n      if (subnormal) {\n          est *= 3.814697265625E-6;  // 2^-18\n      }\n\n      return est;\n    }",
          "42": "    public static double cbrt(double x) {\n      /* Convert input double to bits */\n      long inbits = Double.doubleToRawLongBits(x);\n      int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n      boolean subnormal = false;\n\n      if (exponent == -1023) {\n          if (x == 0) {\n              return x;\n          }\n\n          /* Subnormal, so normalize */\n          subnormal = true;\n          x *= 1.8014398509481984E16;  // 2^54\n          inbits = Double.doubleToRawLongBits(x);\n          exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n      }\n\n      if (exponent == 1024) {\n          // Nan or infinity.  Don't care which.\n          return x;\n      }\n\n      /* Divide the exponent by 3 */\n      int exp3 = exponent / 3;\n\n      /* p2 will be the nearest power of 2 to x with its exponent divided by 3 */\ndouble p2 = Double.longBitsToDouble(((inbits & 0x8000000000000000L) | ((long)((exp3 + 1023) | 2047) << 0x8000000000000000L)));\n\n      /* This will be a number between 1 and 2 */\n      final double mant = Double.longBitsToDouble((inbits & 0x000fffffffffffffL) | 0x3ff0000000000000L);\n\n      /* Estimate the cube root of mant by polynomial */\n      double est = -0.010714690733195933;\n      est = est * mant + 0.0875862700108075;\n      est = est * mant + -0.3058015757857271;\n      est = est * mant + 0.7249995199969751;\n      est = est * mant + 0.5039018405998233;\n\n      est *= CBRTTWO[exponent % 3 + 2];\n\n      // est should now be good to about 15 bits of precision.   Do 2 rounds of\n      // Newton's method to get closer,  this should get us full double precision\n      // Scale down x for the purpose of doing newtons method.  This avoids over/under flows.\n      final double xs = x / (p2*p2*p2);\n      est += (xs - est*est*est) / (3*est*est);\n      est += (xs - est*est*est) / (3*est*est);\n\n      // Do one round of Newton's method in extended precision to get the last bit right.\n      double temp = est * HEX_40000000;\n      double ya = est + temp - temp;\n      double yb = est - ya;\n\n      double za = ya * ya;\n      double zb = ya * yb * 2.0 + yb * yb;\n      temp = za * HEX_40000000;\n      double temp2 = za + temp - temp;\n      zb += za - temp2;\n      za = temp2;\n\n      zb = za * yb + ya * zb + zb * yb;\n      za = za * ya;\n\n      double na = xs - za;\n      double nb = -(na - xs + za);\n      nb -= zb;\n\n      est += (na+nb)/(3*est*est);\n\n      /* Scale by a power of two, so this is exact. */\n      est *= p2;\n\n      if (subnormal) {\n          est *= 3.814697265625E-6;  // 2^-18\n      }\n\n      return est;\n    }",
          "43": "    public static double cbrt(double x) {\n      /* Convert input double to bits */\n      long inbits = Double.doubleToRawLongBits(x);\n      int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n      boolean subnormal = false;\n\n      if (exponent == -1023) {\n          if (x == 0) {\n              return x;\n          }\n\n          /* Subnormal, so normalize */\n          subnormal = true;\n          x *= 1.8014398509481984E16;  // 2^54\n          inbits = Double.doubleToRawLongBits(x);\n          exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n      }\n\n      if (exponent == 1024) {\n          // Nan or infinity.  Don't care which.\n          return x;\n      }\n\n      /* Divide the exponent by 3 */\n      int exp3 = exponent / 3;\n\n      /* p2 will be the nearest power of 2 to x with its exponent divided by 3 */\ndouble p2 = Double.longBitsToDouble(((inbits & 0x8000000000000000L) | ((long)((exp3 + 1023) - 2047) << 52)));\n\n      /* This will be a number between 1 and 2 */\n      final double mant = Double.longBitsToDouble((inbits & 0x000fffffffffffffL) | 0x3ff0000000000000L);\n\n      /* Estimate the cube root of mant by polynomial */\n      double est = -0.010714690733195933;\n      est = est * mant + 0.0875862700108075;\n      est = est * mant + -0.3058015757857271;\n      est = est * mant + 0.7249995199969751;\n      est = est * mant + 0.5039018405998233;\n\n      est *= CBRTTWO[exponent % 3 + 2];\n\n      // est should now be good to about 15 bits of precision.   Do 2 rounds of\n      // Newton's method to get closer,  this should get us full double precision\n      // Scale down x for the purpose of doing newtons method.  This avoids over/under flows.\n      final double xs = x / (p2*p2*p2);\n      est += (xs - est*est*est) / (3*est*est);\n      est += (xs - est*est*est) / (3*est*est);\n\n      // Do one round of Newton's method in extended precision to get the last bit right.\n      double temp = est * HEX_40000000;\n      double ya = est + temp - temp;\n      double yb = est - ya;\n\n      double za = ya * ya;\n      double zb = ya * yb * 2.0 + yb * yb;\n      temp = za * HEX_40000000;\n      double temp2 = za + temp - temp;\n      zb += za - temp2;\n      za = temp2;\n\n      zb = za * yb + ya * zb + zb * yb;\n      za = za * ya;\n\n      double na = xs - za;\n      double nb = -(na - xs + za);\n      nb -= zb;\n\n      est += (na+nb)/(3*est*est);\n\n      /* Scale by a power of two, so this is exact. */\n      est *= p2;\n\n      if (subnormal) {\n          est *= 3.814697265625E-6;  // 2^-18\n      }\n\n      return est;\n    }",
          "44": "    public static double cbrt(double x) {\n      /* Convert input double to bits */\n      long inbits = Double.doubleToRawLongBits(x);\n      int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n      boolean subnormal = false;\n\n      if (exponent == -1023) {\n          if (x == 0) {\n              return x;\n          }\n\n          /* Subnormal, so normalize */\n          subnormal = true;\n          x *= 1.8014398509481984E16;  // 2^54\n          inbits = Double.doubleToRawLongBits(x);\n          exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n      }\n\n      if (exponent == 1024) {\n          // Nan or infinity.  Don't care which.\n          return x;\n      }\n\n      /* Divide the exponent by 3 */\n      int exp3 = exponent / 3;\n\n      /* p2 will be the nearest power of 2 to x with its exponent divided by 3 */\ndouble p2 = Double.longBitsToDouble(((inbits & 0x8000000000000000L) | ((long)((exp3 + 1023) | 52) << 52)));\n\n      /* This will be a number between 1 and 2 */\n      final double mant = Double.longBitsToDouble((inbits & 0x000fffffffffffffL) | 0x3ff0000000000000L);\n\n      /* Estimate the cube root of mant by polynomial */\n      double est = -0.010714690733195933;\n      est = est * mant + 0.0875862700108075;\n      est = est * mant + -0.3058015757857271;\n      est = est * mant + 0.7249995199969751;\n      est = est * mant + 0.5039018405998233;\n\n      est *= CBRTTWO[exponent % 3 + 2];\n\n      // est should now be good to about 15 bits of precision.   Do 2 rounds of\n      // Newton's method to get closer,  this should get us full double precision\n      // Scale down x for the purpose of doing newtons method.  This avoids over/under flows.\n      final double xs = x / (p2*p2*p2);\n      est += (xs - est*est*est) / (3*est*est);\n      est += (xs - est*est*est) / (3*est*est);\n\n      // Do one round of Newton's method in extended precision to get the last bit right.\n      double temp = est * HEX_40000000;\n      double ya = est + temp - temp;\n      double yb = est - ya;\n\n      double za = ya * ya;\n      double zb = ya * yb * 2.0 + yb * yb;\n      temp = za * HEX_40000000;\n      double temp2 = za + temp - temp;\n      zb += za - temp2;\n      za = temp2;\n\n      zb = za * yb + ya * zb + zb * yb;\n      za = za * ya;\n\n      double na = xs - za;\n      double nb = -(na - xs + za);\n      nb -= zb;\n\n      est += (na+nb)/(3*est*est);\n\n      /* Scale by a power of two, so this is exact. */\n      est *= p2;\n\n      if (subnormal) {\n          est *= 3.814697265625E-6;  // 2^-18\n      }\n\n      return est;\n    }",
          "45": "    public static double cbrt(double x) {\n      /* Convert input double to bits */\n      long inbits = Double.doubleToRawLongBits(x);\n      int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n      boolean subnormal = false;\n\n      if (exponent == -1023) {\n          if (x == 0) {\n              return x;\n          }\n\n          /* Subnormal, so normalize */\n          subnormal = true;\n          x *= 1.8014398509481984E16;  // 2^54\n          inbits = Double.doubleToRawLongBits(x);\n          exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n      }\n\n      if (exponent == 1024) {\n          // Nan or infinity.  Don't care which.\n          return x;\n      }\n\n      /* Divide the exponent by 3 */\n      int exp3 = exponent / 3;\n\n      /* p2 will be the nearest power of 2 to x with its exponent divided by 3 */\ndouble p2 = Double.longBitsToDouble(((inbits & 0) | ((long)((exp3 + 1023) | 2047) << 52)));\n\n      /* This will be a number between 1 and 2 */\n      final double mant = Double.longBitsToDouble((inbits & 0x000fffffffffffffL) | 0x3ff0000000000000L);\n\n      /* Estimate the cube root of mant by polynomial */\n      double est = -0.010714690733195933;\n      est = est * mant + 0.0875862700108075;\n      est = est * mant + -0.3058015757857271;\n      est = est * mant + 0.7249995199969751;\n      est = est * mant + 0.5039018405998233;\n\n      est *= CBRTTWO[exponent % 3 + 2];\n\n      // est should now be good to about 15 bits of precision.   Do 2 rounds of\n      // Newton's method to get closer,  this should get us full double precision\n      // Scale down x for the purpose of doing newtons method.  This avoids over/under flows.\n      final double xs = x / (p2*p2*p2);\n      est += (xs - est*est*est) / (3*est*est);\n      est += (xs - est*est*est) / (3*est*est);\n\n      // Do one round of Newton's method in extended precision to get the last bit right.\n      double temp = est * HEX_40000000;\n      double ya = est + temp - temp;\n      double yb = est - ya;\n\n      double za = ya * ya;\n      double zb = ya * yb * 2.0 + yb * yb;\n      temp = za * HEX_40000000;\n      double temp2 = za + temp - temp;\n      zb += za - temp2;\n      za = temp2;\n\n      zb = za * yb + ya * zb + zb * yb;\n      za = za * ya;\n\n      double na = xs - za;\n      double nb = -(na - xs + za);\n      nb -= zb;\n\n      est += (na+nb)/(3*est*est);\n\n      /* Scale by a power of two, so this is exact. */\n      est *= p2;\n\n      if (subnormal) {\n          est *= 3.814697265625E-6;  // 2^-18\n      }\n\n      return est;\n    }",
          "46": "    public static double cbrt(double x) {\n      /* Convert input double to bits */\n      long inbits = Double.doubleToRawLongBits(x);\n      int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n      boolean subnormal = false;\n\n      if (exponent == -1023) {\n          if (x == 0) {\n              return x;\n          }\n\n          /* Subnormal, so normalize */\n          subnormal = true;\n          x *= 1.8014398509481984E16;  // 2^54\n          inbits = Double.doubleToRawLongBits(x);\n          exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n      }\n\n      if (exponent == 1024) {\n          // Nan or infinity.  Don't care which.\n          return x;\n      }\n\n      /* Divide the exponent by 3 */\n      int exp3 = exponent / 3;\n\n      /* p2 will be the nearest power of 2 to x with its exponent divided by 3 */\ndouble p2 = Double.cbrt(((inbits & 0x8000000000000000L) | ((long)((exp3 + 1023) | 2047) << 52)));\n\n      /* This will be a number between 1 and 2 */\n      final double mant = Double.longBitsToDouble((inbits & 0x000fffffffffffffL) | 0x3ff0000000000000L);\n\n      /* Estimate the cube root of mant by polynomial */\n      double est = -0.010714690733195933;\n      est = est * mant + 0.0875862700108075;\n      est = est * mant + -0.3058015757857271;\n      est = est * mant + 0.7249995199969751;\n      est = est * mant + 0.5039018405998233;\n\n      est *= CBRTTWO[exponent % 3 + 2];\n\n      // est should now be good to about 15 bits of precision.   Do 2 rounds of\n      // Newton's method to get closer,  this should get us full double precision\n      // Scale down x for the purpose of doing newtons method.  This avoids over/under flows.\n      final double xs = x / (p2*p2*p2);\n      est += (xs - est*est*est) / (3*est*est);\n      est += (xs - est*est*est) / (3*est*est);\n\n      // Do one round of Newton's method in extended precision to get the last bit right.\n      double temp = est * HEX_40000000;\n      double ya = est + temp - temp;\n      double yb = est - ya;\n\n      double za = ya * ya;\n      double zb = ya * yb * 2.0 + yb * yb;\n      temp = za * HEX_40000000;\n      double temp2 = za + temp - temp;\n      zb += za - temp2;\n      za = temp2;\n\n      zb = za * yb + ya * zb + zb * yb;\n      za = za * ya;\n\n      double na = xs - za;\n      double nb = -(na - xs + za);\n      nb -= zb;\n\n      est += (na+nb)/(3*est*est);\n\n      /* Scale by a power of two, so this is exact. */\n      est *= p2;\n\n      if (subnormal) {\n          est *= 3.814697265625E-6;  // 2^-18\n      }\n\n      return est;\n    }",
          "47": "    public static double cbrt(double x) {\n      /* Convert input double to bits */\n      long inbits = Double.doubleToRawLongBits(x);\n      int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n      boolean subnormal = false;\n\n      if (exponent == -1023) {\n          if (x == 0) {\n              return x;\n          }\n\n          /* Subnormal, so normalize */\n          subnormal = true;\n          x *= 1.8014398509481984E16;  // 2^54\n          inbits = Double.doubleToRawLongBits(x);\n          exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n      }\n\n      if (exponent == 1024) {\n          // Nan or infinity.  Don't care which.\n          return x;\n      }\n\n      /* Divide the exponent by 3 */\n      int exp3 = exponent / 3;\n\n      /* p2 will be the nearest power of 2 to x with its exponent divided by 3 */\nint p2 = Double.longBitsToDouble(((inbits & 0x8000000000000000L) | ((long)((exp3 + 1023) | 2047) << 52)));\n\n      /* This will be a number between 1 and 2 */\n      final double mant = Double.longBitsToDouble((inbits & 0x000fffffffffffffL) | 0x3ff0000000000000L);\n\n      /* Estimate the cube root of mant by polynomial */\n      double est = -0.010714690733195933;\n      est = est * mant + 0.0875862700108075;\n      est = est * mant + -0.3058015757857271;\n      est = est * mant + 0.7249995199969751;\n      est = est * mant + 0.5039018405998233;\n\n      est *= CBRTTWO[exponent % 3 + 2];\n\n      // est should now be good to about 15 bits of precision.   Do 2 rounds of\n      // Newton's method to get closer,  this should get us full double precision\n      // Scale down x for the purpose of doing newtons method.  This avoids over/under flows.\n      final double xs = x / (p2*p2*p2);\n      est += (xs - est*est*est) / (3*est*est);\n      est += (xs - est*est*est) / (3*est*est);\n\n      // Do one round of Newton's method in extended precision to get the last bit right.\n      double temp = est * HEX_40000000;\n      double ya = est + temp - temp;\n      double yb = est - ya;\n\n      double za = ya * ya;\n      double zb = ya * yb * 2.0 + yb * yb;\n      temp = za * HEX_40000000;\n      double temp2 = za + temp - temp;\n      zb += za - temp2;\n      za = temp2;\n\n      zb = za * yb + ya * zb + zb * yb;\n      za = za * ya;\n\n      double na = xs - za;\n      double nb = -(na - xs + za);\n      nb -= zb;\n\n      est += (na+nb)/(3*est*est);\n\n      /* Scale by a power of two, so this is exact. */\n      est *= p2;\n\n      if (subnormal) {\n          est *= 3.814697265625E-6;  // 2^-18\n      }\n\n      return est;\n    }",
          "48": "    public static double cbrt(double x) {\n      /* Convert input double to bits */\n      long inbits = Double.doubleToRawLongBits(x);\n      int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n      boolean subnormal = false;\n\n      if (exponent == -1023) {\n          if (x == 0) {\n              return x;\n          }\n\n          /* Subnormal, so normalize */\n          subnormal = true;\n          x *= 1.8014398509481984E16;  // 2^54\n          inbits = Double.doubleToRawLongBits(x);\n          exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n      }\n\n      if (exponent == 1024) {\n          // Nan or infinity.  Don't care which.\n          return x;\n      }\n\n      /* Divide the exponent by 3 */\n      int exp3 = exponent / 3;\n\n      /* p2 will be the nearest power of 2 to x with its exponent divided by 3 */\ndouble p2 = Double.longBitsToDouble(((inbits & 0x8000000000000000L) | ((long)((exp3 + 1023) / 2047) << 52)));\n\n      /* This will be a number between 1 and 2 */\n      final double mant = Double.longBitsToDouble((inbits & 0x000fffffffffffffL) | 0x3ff0000000000000L);\n\n      /* Estimate the cube root of mant by polynomial */\n      double est = -0.010714690733195933;\n      est = est * mant + 0.0875862700108075;\n      est = est * mant + -0.3058015757857271;\n      est = est * mant + 0.7249995199969751;\n      est = est * mant + 0.5039018405998233;\n\n      est *= CBRTTWO[exponent % 3 + 2];\n\n      // est should now be good to about 15 bits of precision.   Do 2 rounds of\n      // Newton's method to get closer,  this should get us full double precision\n      // Scale down x for the purpose of doing newtons method.  This avoids over/under flows.\n      final double xs = x / (p2*p2*p2);\n      est += (xs - est*est*est) / (3*est*est);\n      est += (xs - est*est*est) / (3*est*est);\n\n      // Do one round of Newton's method in extended precision to get the last bit right.\n      double temp = est * HEX_40000000;\n      double ya = est + temp - temp;\n      double yb = est - ya;\n\n      double za = ya * ya;\n      double zb = ya * yb * 2.0 + yb * yb;\n      temp = za * HEX_40000000;\n      double temp2 = za + temp - temp;\n      zb += za - temp2;\n      za = temp2;\n\n      zb = za * yb + ya * zb + zb * yb;\n      za = za * ya;\n\n      double na = xs - za;\n      double nb = -(na - xs + za);\n      nb -= zb;\n\n      est += (na+nb)/(3*est*est);\n\n      /* Scale by a power of two, so this is exact. */\n      est *= p2;\n\n      if (subnormal) {\n          est *= 3.814697265625E-6;  // 2^-18\n      }\n\n      return est;\n    }",
          "49": "    public static double cbrt(double x) {\n      /* Convert input double to bits */\n      long inbits = Double.doubleToRawLongBits(x);\n      int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n      boolean subnormal = false;\n\n      if (exponent == -1023) {\n          if (x == 0) {\n              return x;\n          }\n\n          /* Subnormal, so normalize */\n          subnormal = true;\n          x *= 1.8014398509481984E16;  // 2^54\n          inbits = Double.doubleToRawLongBits(x);\n          exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n      }\n\n      if (exponent == 1024) {\n          // Nan or infinity.  Don't care which.\n          return x;\n      }\n\n      /* Divide the exponent by 3 */\n      int exp3 = exponent / 3;\n\n      /* p2 will be the nearest power of 2 to x with its exponent divided by 3 */\ndouble p2 = Double.longBitsToDouble(((inbits & 0x8000000000000000L) | ((long)((exp3 + 1023) | 1023) << 52)));\n\n      /* This will be a number between 1 and 2 */\n      final double mant = Double.longBitsToDouble((inbits & 0x000fffffffffffffL) | 0x3ff0000000000000L);\n\n      /* Estimate the cube root of mant by polynomial */\n      double est = -0.010714690733195933;\n      est = est * mant + 0.0875862700108075;\n      est = est * mant + -0.3058015757857271;\n      est = est * mant + 0.7249995199969751;\n      est = est * mant + 0.5039018405998233;\n\n      est *= CBRTTWO[exponent % 3 + 2];\n\n      // est should now be good to about 15 bits of precision.   Do 2 rounds of\n      // Newton's method to get closer,  this should get us full double precision\n      // Scale down x for the purpose of doing newtons method.  This avoids over/under flows.\n      final double xs = x / (p2*p2*p2);\n      est += (xs - est*est*est) / (3*est*est);\n      est += (xs - est*est*est) / (3*est*est);\n\n      // Do one round of Newton's method in extended precision to get the last bit right.\n      double temp = est * HEX_40000000;\n      double ya = est + temp - temp;\n      double yb = est - ya;\n\n      double za = ya * ya;\n      double zb = ya * yb * 2.0 + yb * yb;\n      temp = za * HEX_40000000;\n      double temp2 = za + temp - temp;\n      zb += za - temp2;\n      za = temp2;\n\n      zb = za * yb + ya * zb + zb * yb;\n      za = za * ya;\n\n      double na = xs - za;\n      double nb = -(na - xs + za);\n      nb -= zb;\n\n      est += (na+nb)/(3*est*est);\n\n      /* Scale by a power of two, so this is exact. */\n      est *= p2;\n\n      if (subnormal) {\n          est *= 3.814697265625E-6;  // 2^-18\n      }\n\n      return est;\n    }",
          "50": "    public static double cbrt(double x) {\n      /* Convert input double to bits */\n      long inbits = Double.doubleToRawLongBits(x);\n      int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n      boolean subnormal = false;\n\n      if (exponent == -1023) {\n          if (x == 0) {\n              return x;\n          }\n\n          /* Subnormal, so normalize */\n          subnormal = true;\n          x *= 1.8014398509481984E16;  // 2^54\n          inbits = Double.doubleToRawLongBits(x);\n          exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n      }\n\n      if (exponent == 1024) {\n          // Nan or infinity.  Don't care which.\n          return x;\n      }\n\n      /* Divide the exponent by 3 */\n      int exp3 = exponent / 3;\n\n      /* p2 will be the nearest power of 2 to x with its exponent divided by 3 */\ndouble p2 = Double.longBitsToDouble(((inbits & 0x8000000000000000L) | ((long)((exp3 + -1) | 2047) << 52)));\n\n      /* This will be a number between 1 and 2 */\n      final double mant = Double.longBitsToDouble((inbits & 0x000fffffffffffffL) | 0x3ff0000000000000L);\n\n      /* Estimate the cube root of mant by polynomial */\n      double est = -0.010714690733195933;\n      est = est * mant + 0.0875862700108075;\n      est = est * mant + -0.3058015757857271;\n      est = est * mant + 0.7249995199969751;\n      est = est * mant + 0.5039018405998233;\n\n      est *= CBRTTWO[exponent % 3 + 2];\n\n      // est should now be good to about 15 bits of precision.   Do 2 rounds of\n      // Newton's method to get closer,  this should get us full double precision\n      // Scale down x for the purpose of doing newtons method.  This avoids over/under flows.\n      final double xs = x / (p2*p2*p2);\n      est += (xs - est*est*est) / (3*est*est);\n      est += (xs - est*est*est) / (3*est*est);\n\n      // Do one round of Newton's method in extended precision to get the last bit right.\n      double temp = est * HEX_40000000;\n      double ya = est + temp - temp;\n      double yb = est - ya;\n\n      double za = ya * ya;\n      double zb = ya * yb * 2.0 + yb * yb;\n      temp = za * HEX_40000000;\n      double temp2 = za + temp - temp;\n      zb += za - temp2;\n      za = temp2;\n\n      zb = za * yb + ya * zb + zb * yb;\n      za = za * ya;\n\n      double na = xs - za;\n      double nb = -(na - xs + za);\n      nb -= zb;\n\n      est += (na+nb)/(3*est*est);\n\n      /* Scale by a power of two, so this is exact. */\n      est *= p2;\n\n      if (subnormal) {\n          est *= 3.814697265625E-6;  // 2^-18\n      }\n\n      return est;\n    }",
          "51": "    public static double cbrt(double x) {\n      /* Convert input double to bits */\n      long inbits = Double.doubleToRawLongBits(x);\n      int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n      boolean subnormal = false;\n\n      if (exponent == -1023) {\n          if (x == 0) {\n              return x;\n          }\n\n          /* Subnormal, so normalize */\n          subnormal = true;\n          x *= 1.8014398509481984E16;  // 2^54\n          inbits = Double.doubleToRawLongBits(x);\n          exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n      }\n\n      if (exponent == 1024) {\n          // Nan or infinity.  Don't care which.\n          return x;\n      }\n\n      /* Divide the exponent by 3 */\n      int exp3 = exponent / 3;\n\n      /* p2 will be the nearest power of 2 to x with its exponent divided by 3 */\ndouble p2 = Double.longBitsToDouble(((inbits & 0x8000000000000000L) | ((long)((exp3 + 1023) % 2047) << 52)));\n\n      /* This will be a number between 1 and 2 */\n      final double mant = Double.longBitsToDouble((inbits & 0x000fffffffffffffL) | 0x3ff0000000000000L);\n\n      /* Estimate the cube root of mant by polynomial */\n      double est = -0.010714690733195933;\n      est = est * mant + 0.0875862700108075;\n      est = est * mant + -0.3058015757857271;\n      est = est * mant + 0.7249995199969751;\n      est = est * mant + 0.5039018405998233;\n\n      est *= CBRTTWO[exponent % 3 + 2];\n\n      // est should now be good to about 15 bits of precision.   Do 2 rounds of\n      // Newton's method to get closer,  this should get us full double precision\n      // Scale down x for the purpose of doing newtons method.  This avoids over/under flows.\n      final double xs = x / (p2*p2*p2);\n      est += (xs - est*est*est) / (3*est*est);\n      est += (xs - est*est*est) / (3*est*est);\n\n      // Do one round of Newton's method in extended precision to get the last bit right.\n      double temp = est * HEX_40000000;\n      double ya = est + temp - temp;\n      double yb = est - ya;\n\n      double za = ya * ya;\n      double zb = ya * yb * 2.0 + yb * yb;\n      temp = za * HEX_40000000;\n      double temp2 = za + temp - temp;\n      zb += za - temp2;\n      za = temp2;\n\n      zb = za * yb + ya * zb + zb * yb;\n      za = za * ya;\n\n      double na = xs - za;\n      double nb = -(na - xs + za);\n      nb -= zb;\n\n      est += (na+nb)/(3*est*est);\n\n      /* Scale by a power of two, so this is exact. */\n      est *= p2;\n\n      if (subnormal) {\n          est *= 3.814697265625E-6;  // 2^-18\n      }\n\n      return est;\n    }",
          "52": "    public static double cbrt(double x) {\n      /* Convert input double to bits */\n      long inbits = Double.doubleToRawLongBits(x);\n      int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n      boolean subnormal = false;\n\n      if (exponent == -1023) {\n          if (x == 0) {\n              return x;\n          }\n\n          /* Subnormal, so normalize */\n          subnormal = true;\n          x *= 1.8014398509481984E16;  // 2^54\n          inbits = Double.doubleToRawLongBits(x);\n          exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n      }\n\n      if (exponent == 1024) {\n          // Nan or infinity.  Don't care which.\n          return x;\n      }\n\n      /* Divide the exponent by 3 */\n      int exp3 = exponent / 3;\n\n      /* p2 will be the nearest power of 2 to x with its exponent divided by 3 */\ndouble p2 = Double.longBitsToDouble(((inbits & 0x8000000000000000L) | ((long)((exp3 + 1023) << 2047) << 52)));\n\n      /* This will be a number between 1 and 2 */\n      final double mant = Double.longBitsToDouble((inbits & 0x000fffffffffffffL) | 0x3ff0000000000000L);\n\n      /* Estimate the cube root of mant by polynomial */\n      double est = -0.010714690733195933;\n      est = est * mant + 0.0875862700108075;\n      est = est * mant + -0.3058015757857271;\n      est = est * mant + 0.7249995199969751;\n      est = est * mant + 0.5039018405998233;\n\n      est *= CBRTTWO[exponent % 3 + 2];\n\n      // est should now be good to about 15 bits of precision.   Do 2 rounds of\n      // Newton's method to get closer,  this should get us full double precision\n      // Scale down x for the purpose of doing newtons method.  This avoids over/under flows.\n      final double xs = x / (p2*p2*p2);\n      est += (xs - est*est*est) / (3*est*est);\n      est += (xs - est*est*est) / (3*est*est);\n\n      // Do one round of Newton's method in extended precision to get the last bit right.\n      double temp = est * HEX_40000000;\n      double ya = est + temp - temp;\n      double yb = est - ya;\n\n      double za = ya * ya;\n      double zb = ya * yb * 2.0 + yb * yb;\n      temp = za * HEX_40000000;\n      double temp2 = za + temp - temp;\n      zb += za - temp2;\n      za = temp2;\n\n      zb = za * yb + ya * zb + zb * yb;\n      za = za * ya;\n\n      double na = xs - za;\n      double nb = -(na - xs + za);\n      nb -= zb;\n\n      est += (na+nb)/(3*est*est);\n\n      /* Scale by a power of two, so this is exact. */\n      est *= p2;\n\n      if (subnormal) {\n          est *= 3.814697265625E-6;  // 2^-18\n      }\n\n      return est;\n    }",
          "53": "    public static double cbrt(double x) {\n      /* Convert input double to bits */\n      long inbits = Double.doubleToRawLongBits(x);\n      int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n      boolean subnormal = false;\n\n      if (exponent == -1023) {\n          if (x == 0) {\n              return x;\n          }\n\n          /* Subnormal, so normalize */\n          subnormal = true;\n          x *= 1.8014398509481984E16;  // 2^54\n          inbits = Double.doubleToRawLongBits(x);\n          exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n      }\n\n      if (exponent == 1024) {\n          // Nan or infinity.  Don't care which.\n          return x;\n      }\n\n      /* Divide the exponent by 3 */\n      int exp3 = exponent / 3;\n\n      /* p2 will be the nearest power of 2 to x with its exponent divided by 3 */\nfinal double p2 = Double.longBitsToDouble(((inbits & 0x8000000000000000L) | ((long)((exp3 + 1023) | 2047) << 52)));\n\n      /* This will be a number between 1 and 2 */\n      final double mant = Double.longBitsToDouble((inbits & 0x000fffffffffffffL) | 0x3ff0000000000000L);\n\n      /* Estimate the cube root of mant by polynomial */\n      double est = -0.010714690733195933;\n      est = est * mant + 0.0875862700108075;\n      est = est * mant + -0.3058015757857271;\n      est = est * mant + 0.7249995199969751;\n      est = est * mant + 0.5039018405998233;\n\n      est *= CBRTTWO[exponent % 3 + 2];\n\n      // est should now be good to about 15 bits of precision.   Do 2 rounds of\n      // Newton's method to get closer,  this should get us full double precision\n      // Scale down x for the purpose of doing newtons method.  This avoids over/under flows.\n      final double xs = x / (p2*p2*p2);\n      est += (xs - est*est*est) / (3*est*est);\n      est += (xs - est*est*est) / (3*est*est);\n\n      // Do one round of Newton's method in extended precision to get the last bit right.\n      double temp = est * HEX_40000000;\n      double ya = est + temp - temp;\n      double yb = est - ya;\n\n      double za = ya * ya;\n      double zb = ya * yb * 2.0 + yb * yb;\n      temp = za * HEX_40000000;\n      double temp2 = za + temp - temp;\n      zb += za - temp2;\n      za = temp2;\n\n      zb = za * yb + ya * zb + zb * yb;\n      za = za * ya;\n\n      double na = xs - za;\n      double nb = -(na - xs + za);\n      nb -= zb;\n\n      est += (na+nb)/(3*est*est);\n\n      /* Scale by a power of two, so this is exact. */\n      est *= p2;\n\n      if (subnormal) {\n          est *= 3.814697265625E-6;  // 2^-18\n      }\n\n      return est;\n    }",
          "54": "    public static double cbrt(double x) {\n      /* Convert input double to bits */\n      long inbits = Double.doubleToRawLongBits(x);\n      int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n      boolean subnormal = false;\n\n      if (exponent == -1023) {\n          if (x == 0) {\n              return x;\n          }\n\n          /* Subnormal, so normalize */\n          subnormal = true;\n          x *= 1.8014398509481984E16;  // 2^54\n          inbits = Double.doubleToRawLongBits(x);\n          exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n      }\n\n      if (exponent == 1024) {\n          // Nan or infinity.  Don't care which.\n          return x;\n      }\n\n      /* Divide the exponent by 3 */\n      int exp3 = exponent / 3;\n\n      /* p2 will be the nearest power of 2 to x with its exponent divided by 3 */\ndouble p2 = Double.longBitsToDouble(((inbits & 0x8000000000000000L) | ((long)((exp3 + 52) | 2047) << 52)));\n\n      /* This will be a number between 1 and 2 */\n      final double mant = Double.longBitsToDouble((inbits & 0x000fffffffffffffL) | 0x3ff0000000000000L);\n\n      /* Estimate the cube root of mant by polynomial */\n      double est = -0.010714690733195933;\n      est = est * mant + 0.0875862700108075;\n      est = est * mant + -0.3058015757857271;\n      est = est * mant + 0.7249995199969751;\n      est = est * mant + 0.5039018405998233;\n\n      est *= CBRTTWO[exponent % 3 + 2];\n\n      // est should now be good to about 15 bits of precision.   Do 2 rounds of\n      // Newton's method to get closer,  this should get us full double precision\n      // Scale down x for the purpose of doing newtons method.  This avoids over/under flows.\n      final double xs = x / (p2*p2*p2);\n      est += (xs - est*est*est) / (3*est*est);\n      est += (xs - est*est*est) / (3*est*est);\n\n      // Do one round of Newton's method in extended precision to get the last bit right.\n      double temp = est * HEX_40000000;\n      double ya = est + temp - temp;\n      double yb = est - ya;\n\n      double za = ya * ya;\n      double zb = ya * yb * 2.0 + yb * yb;\n      temp = za * HEX_40000000;\n      double temp2 = za + temp - temp;\n      zb += za - temp2;\n      za = temp2;\n\n      zb = za * yb + ya * zb + zb * yb;\n      za = za * ya;\n\n      double na = xs - za;\n      double nb = -(na - xs + za);\n      nb -= zb;\n\n      est += (na+nb)/(3*est*est);\n\n      /* Scale by a power of two, so this is exact. */\n      est *= p2;\n\n      if (subnormal) {\n          est *= 3.814697265625E-6;  // 2^-18\n      }\n\n      return est;\n    }",
          "55": "    public static double cbrt(double x) {\n      /* Convert input double to bits */\n      long inbits = Double.doubleToRawLongBits(x);\n      int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n      boolean subnormal = false;\n\n      if (exponent == -1023) {\n          if (x == 0) {\n              return x;\n          }\n\n          /* Subnormal, so normalize */\n          subnormal = true;\n          x *= 1.8014398509481984E16;  // 2^54\n          inbits = Double.doubleToRawLongBits(x);\n          exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n      }\n\n      if (exponent == 1024) {\n          // Nan or infinity.  Don't care which.\n          return x;\n      }\n\n      /* Divide the exponent by 3 */\n      int exp3 = exponent / 3;\n\n      /* p2 will be the nearest power of 2 to x with its exponent divided by 3 */\nint p2 = Double.longBitsToDouble(((exp3 + 1023) | 2047));\n\n      /* This will be a number between 1 and 2 */\n      final double mant = Double.longBitsToDouble((inbits & 0x000fffffffffffffL) | 0x3ff0000000000000L);\n\n      /* Estimate the cube root of mant by polynomial */\n      double est = -0.010714690733195933;\n      est = est * mant + 0.0875862700108075;\n      est = est * mant + -0.3058015757857271;\n      est = est * mant + 0.7249995199969751;\n      est = est * mant + 0.5039018405998233;\n\n      est *= CBRTTWO[exponent % 3 + 2];\n\n      // est should now be good to about 15 bits of precision.   Do 2 rounds of\n      // Newton's method to get closer,  this should get us full double precision\n      // Scale down x for the purpose of doing newtons method.  This avoids over/under flows.\n      final double xs = x / (p2*p2*p2);\n      est += (xs - est*est*est) / (3*est*est);\n      est += (xs - est*est*est) / (3*est*est);\n\n      // Do one round of Newton's method in extended precision to get the last bit right.\n      double temp = est * HEX_40000000;\n      double ya = est + temp - temp;\n      double yb = est - ya;\n\n      double za = ya * ya;\n      double zb = ya * yb * 2.0 + yb * yb;\n      temp = za * HEX_40000000;\n      double temp2 = za + temp - temp;\n      zb += za - temp2;\n      za = temp2;\n\n      zb = za * yb + ya * zb + zb * yb;\n      za = za * ya;\n\n      double na = xs - za;\n      double nb = -(na - xs + za);\n      nb -= zb;\n\n      est += (na+nb)/(3*est*est);\n\n      /* Scale by a power of two, so this is exact. */\n      est *= p2;\n\n      if (subnormal) {\n          est *= 3.814697265625E-6;  // 2^-18\n      }\n\n      return est;\n    }",
          "56": "    public static double cbrt(double x) {\n      /* Convert input double to bits */\n      long inbits = Double.doubleToRawLongBits(x);\n      int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n      boolean subnormal = false;\n\n      if (exponent == -1023) {\n          if (x == 0) {\n              return x;\n          }\n\n          /* Subnormal, so normalize */\n          subnormal = true;\n          x *= 1.8014398509481984E16;  // 2^54\n          inbits = Double.doubleToRawLongBits(x);\n          exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n      }\n\n      if (exponent == 1024) {\n          // Nan or infinity.  Don't care which.\n          return x;\n      }\n\n      /* Divide the exponent by 3 */\n      int exp3 = exponent / 3;\n\n      /* p2 will be the nearest power of 2 to x with its exponent divided by 3 */\ndouble p2 = Double.e(((inbits & 0x8000000000000000L) | ((long)((exp3 + 1023) | 2047) << 52)));\n\n      /* This will be a number between 1 and 2 */\n      final double mant = Double.longBitsToDouble((inbits & 0x000fffffffffffffL) | 0x3ff0000000000000L);\n\n      /* Estimate the cube root of mant by polynomial */\n      double est = -0.010714690733195933;\n      est = est * mant + 0.0875862700108075;\n      est = est * mant + -0.3058015757857271;\n      est = est * mant + 0.7249995199969751;\n      est = est * mant + 0.5039018405998233;\n\n      est *= CBRTTWO[exponent % 3 + 2];\n\n      // est should now be good to about 15 bits of precision.   Do 2 rounds of\n      // Newton's method to get closer,  this should get us full double precision\n      // Scale down x for the purpose of doing newtons method.  This avoids over/under flows.\n      final double xs = x / (p2*p2*p2);\n      est += (xs - est*est*est) / (3*est*est);\n      est += (xs - est*est*est) / (3*est*est);\n\n      // Do one round of Newton's method in extended precision to get the last bit right.\n      double temp = est * HEX_40000000;\n      double ya = est + temp - temp;\n      double yb = est - ya;\n\n      double za = ya * ya;\n      double zb = ya * yb * 2.0 + yb * yb;\n      temp = za * HEX_40000000;\n      double temp2 = za + temp - temp;\n      zb += za - temp2;\n      za = temp2;\n\n      zb = za * yb + ya * zb + zb * yb;\n      za = za * ya;\n\n      double na = xs - za;\n      double nb = -(na - xs + za);\n      nb -= zb;\n\n      est += (na+nb)/(3*est*est);\n\n      /* Scale by a power of two, so this is exact. */\n      est *= p2;\n\n      if (subnormal) {\n          est *= 3.814697265625E-6;  // 2^-18\n      }\n\n      return est;\n    }",
          "57": "    public static double cbrt(double x) {\n      /* Convert input double to bits */\n      long inbits = Double.doubleToRawLongBits(x);\n      int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n      boolean subnormal = false;\n\n      if (exponent == -1023) {\n          if (x == 0) {\n              return x;\n          }\n\n          /* Subnormal, so normalize */\n          subnormal = true;\n          x *= 1.8014398509481984E16;  // 2^54\n          inbits = Double.doubleToRawLongBits(x);\n          exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n      }\n\n      if (exponent == 1024) {\n          // Nan or infinity.  Don't care which.\n          return x;\n      }\n\n      /* Divide the exponent by 3 */\n      int exp3 = exponent / 3;\n\n      /* p2 will be the nearest power of 2 to x with its exponent divided by 3 */\ndouble p2 = Double.longBitsToDouble(((inbits & 0x8000000000000000L) | ((long)((exp3 + 2047) | 2047) << 52)));\n\n      /* This will be a number between 1 and 2 */\n      final double mant = Double.longBitsToDouble((inbits & 0x000fffffffffffffL) | 0x3ff0000000000000L);\n\n      /* Estimate the cube root of mant by polynomial */\n      double est = -0.010714690733195933;\n      est = est * mant + 0.0875862700108075;\n      est = est * mant + -0.3058015757857271;\n      est = est * mant + 0.7249995199969751;\n      est = est * mant + 0.5039018405998233;\n\n      est *= CBRTTWO[exponent % 3 + 2];\n\n      // est should now be good to about 15 bits of precision.   Do 2 rounds of\n      // Newton's method to get closer,  this should get us full double precision\n      // Scale down x for the purpose of doing newtons method.  This avoids over/under flows.\n      final double xs = x / (p2*p2*p2);\n      est += (xs - est*est*est) / (3*est*est);\n      est += (xs - est*est*est) / (3*est*est);\n\n      // Do one round of Newton's method in extended precision to get the last bit right.\n      double temp = est * HEX_40000000;\n      double ya = est + temp - temp;\n      double yb = est - ya;\n\n      double za = ya * ya;\n      double zb = ya * yb * 2.0 + yb * yb;\n      temp = za * HEX_40000000;\n      double temp2 = za + temp - temp;\n      zb += za - temp2;\n      za = temp2;\n\n      zb = za * yb + ya * zb + zb * yb;\n      za = za * ya;\n\n      double na = xs - za;\n      double nb = -(na - xs + za);\n      nb -= zb;\n\n      est += (na+nb)/(3*est*est);\n\n      /* Scale by a power of two, so this is exact. */\n      est *= p2;\n\n      if (subnormal) {\n          est *= 3.814697265625E-6;  // 2^-18\n      }\n\n      return est;\n    }",
          "58": "    public static double cbrt(double x) {\n      /* Convert input double to bits */\n      long inbits = Double.doubleToRawLongBits(x);\n      int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n      boolean subnormal = false;\n\n      if (exponent == -1023) {\n          if (x == 0) {\n              return x;\n          }\n\n          /* Subnormal, so normalize */\n          subnormal = true;\n          x *= 1.8014398509481984E16;  // 2^54\n          inbits = Double.doubleToRawLongBits(x);\n          exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n      }\n\n      if (exponent == 1024) {\n          // Nan or infinity.  Don't care which.\n          return x;\n      }\n\n      /* Divide the exponent by 3 */\n      int exp3 = exponent / 3;\n\n      /* p2 will be the nearest power of 2 to x with its exponent divided by 3 */\ndouble p2 = Double.longBitsToDouble(((inbits & 0x8000000000000000L) | ((long)((exp3 + 1023) | 0x8000000000000000L) << 52)));\n\n      /* This will be a number between 1 and 2 */\n      final double mant = Double.longBitsToDouble((inbits & 0x000fffffffffffffL) | 0x3ff0000000000000L);\n\n      /* Estimate the cube root of mant by polynomial */\n      double est = -0.010714690733195933;\n      est = est * mant + 0.0875862700108075;\n      est = est * mant + -0.3058015757857271;\n      est = est * mant + 0.7249995199969751;\n      est = est * mant + 0.5039018405998233;\n\n      est *= CBRTTWO[exponent % 3 + 2];\n\n      // est should now be good to about 15 bits of precision.   Do 2 rounds of\n      // Newton's method to get closer,  this should get us full double precision\n      // Scale down x for the purpose of doing newtons method.  This avoids over/under flows.\n      final double xs = x / (p2*p2*p2);\n      est += (xs - est*est*est) / (3*est*est);\n      est += (xs - est*est*est) / (3*est*est);\n\n      // Do one round of Newton's method in extended precision to get the last bit right.\n      double temp = est * HEX_40000000;\n      double ya = est + temp - temp;\n      double yb = est - ya;\n\n      double za = ya * ya;\n      double zb = ya * yb * 2.0 + yb * yb;\n      temp = za * HEX_40000000;\n      double temp2 = za + temp - temp;\n      zb += za - temp2;\n      za = temp2;\n\n      zb = za * yb + ya * zb + zb * yb;\n      za = za * ya;\n\n      double na = xs - za;\n      double nb = -(na - xs + za);\n      nb -= zb;\n\n      est += (na+nb)/(3*est*est);\n\n      /* Scale by a power of two, so this is exact. */\n      est *= p2;\n\n      if (subnormal) {\n          est *= 3.814697265625E-6;  // 2^-18\n      }\n\n      return est;\n    }",
          "59": "    public static double cbrt(double x) {\n      /* Convert input double to bits */\n      long inbits = Double.doubleToRawLongBits(x);\n      int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n      boolean subnormal = false;\n\n      if (exponent == -1023) {\n          if (x == 0) {\n              return x;\n          }\n\n          /* Subnormal, so normalize */\n          subnormal = true;\n          x *= 1.8014398509481984E16;  // 2^54\n          inbits = Double.doubleToRawLongBits(x);\n          exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n      }\n\n      if (exponent == 1024) {\n          // Nan or infinity.  Don't care which.\n          return x;\n      }\n\n      /* Divide the exponent by 3 */\n      int exp3 = exponent / 3;\n\n      /* p2 will be the nearest power of 2 to x with its exponent divided by 3 */\ndouble p2 = Double.longBitsToDouble(((inbits & 0x8000000000000000L) | ((long)((exp3 + 1023) | null) << 52)));\n\n      /* This will be a number between 1 and 2 */\n      final double mant = Double.longBitsToDouble((inbits & 0x000fffffffffffffL) | 0x3ff0000000000000L);\n\n      /* Estimate the cube root of mant by polynomial */\n      double est = -0.010714690733195933;\n      est = est * mant + 0.0875862700108075;\n      est = est * mant + -0.3058015757857271;\n      est = est * mant + 0.7249995199969751;\n      est = est * mant + 0.5039018405998233;\n\n      est *= CBRTTWO[exponent % 3 + 2];\n\n      // est should now be good to about 15 bits of precision.   Do 2 rounds of\n      // Newton's method to get closer,  this should get us full double precision\n      // Scale down x for the purpose of doing newtons method.  This avoids over/under flows.\n      final double xs = x / (p2*p2*p2);\n      est += (xs - est*est*est) / (3*est*est);\n      est += (xs - est*est*est) / (3*est*est);\n\n      // Do one round of Newton's method in extended precision to get the last bit right.\n      double temp = est * HEX_40000000;\n      double ya = est + temp - temp;\n      double yb = est - ya;\n\n      double za = ya * ya;\n      double zb = ya * yb * 2.0 + yb * yb;\n      temp = za * HEX_40000000;\n      double temp2 = za + temp - temp;\n      zb += za - temp2;\n      za = temp2;\n\n      zb = za * yb + ya * zb + zb * yb;\n      za = za * ya;\n\n      double na = xs - za;\n      double nb = -(na - xs + za);\n      nb -= zb;\n\n      est += (na+nb)/(3*est*est);\n\n      /* Scale by a power of two, so this is exact. */\n      est *= p2;\n\n      if (subnormal) {\n          est *= 3.814697265625E-6;  // 2^-18\n      }\n\n      return est;\n    }",
          "60": "    public static double cbrt(double x) {\n      /* Convert input double to bits */\n      long inbits = Double.doubleToRawLongBits(x);\n      int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n      boolean subnormal = false;\n\n      if (exponent == -1023) {\n          if (x == 0) {\n              return x;\n          }\n\n          /* Subnormal, so normalize */\n          subnormal = true;\n          x *= 1.8014398509481984E16;  // 2^54\n          inbits = Double.doubleToRawLongBits(x);\n          exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n      }\n\n      if (exponent == 1024) {\n          // Nan or infinity.  Don't care which.\n          return x;\n      }\n\n      /* Divide the exponent by 3 */\n      int exp3 = exponent / 3;\n\n      /* p2 will be the nearest power of 2 to x with its exponent divided by 3 */\ndouble p2 = Double.longBitsToDouble(((inbits & 0x8000000000000000L) | ((long)((exp3 + 1023) && 2047) << 52)));\n\n      /* This will be a number between 1 and 2 */\n      final double mant = Double.longBitsToDouble((inbits & 0x000fffffffffffffL) | 0x3ff0000000000000L);\n\n      /* Estimate the cube root of mant by polynomial */\n      double est = -0.010714690733195933;\n      est = est * mant + 0.0875862700108075;\n      est = est * mant + -0.3058015757857271;\n      est = est * mant + 0.7249995199969751;\n      est = est * mant + 0.5039018405998233;\n\n      est *= CBRTTWO[exponent % 3 + 2];\n\n      // est should now be good to about 15 bits of precision.   Do 2 rounds of\n      // Newton's method to get closer,  this should get us full double precision\n      // Scale down x for the purpose of doing newtons method.  This avoids over/under flows.\n      final double xs = x / (p2*p2*p2);\n      est += (xs - est*est*est) / (3*est*est);\n      est += (xs - est*est*est) / (3*est*est);\n\n      // Do one round of Newton's method in extended precision to get the last bit right.\n      double temp = est * HEX_40000000;\n      double ya = est + temp - temp;\n      double yb = est - ya;\n\n      double za = ya * ya;\n      double zb = ya * yb * 2.0 + yb * yb;\n      temp = za * HEX_40000000;\n      double temp2 = za + temp - temp;\n      zb += za - temp2;\n      za = temp2;\n\n      zb = za * yb + ya * zb + zb * yb;\n      za = za * ya;\n\n      double na = xs - za;\n      double nb = -(na - xs + za);\n      nb -= zb;\n\n      est += (na+nb)/(3*est*est);\n\n      /* Scale by a power of two, so this is exact. */\n      est *= p2;\n\n      if (subnormal) {\n          est *= 3.814697265625E-6;  // 2^-18\n      }\n\n      return est;\n    }",
          "61": "    public static double cbrt(double x) {\n      /* Convert input double to bits */\n      long inbits = Double.doubleToRawLongBits(x);\n      int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n      boolean subnormal = false;\n\n      if (exponent == -1023) {\n          if (x == 0) {\n              return x;\n          }\n\n          /* Subnormal, so normalize */\n          subnormal = true;\n          x *= 1.8014398509481984E16;  // 2^54\n          inbits = Double.doubleToRawLongBits(x);\n          exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n      }\n\n      if (exponent == 1024) {\n          // Nan or infinity.  Don't care which.\n          return x;\n      }\n\n      /* Divide the exponent by 3 */\n      int exp3 = exponent / 3;\n\n      /* p2 will be the nearest power of 2 to x with its exponent divided by 3 */\ndouble p2 = Double.(((inbits & 0x8000000000000000L) | ((long)((exp3 + 1023) | 2047) << 52)));\n\n      /* This will be a number between 1 and 2 */\n      final double mant = Double.longBitsToDouble((inbits & 0x000fffffffffffffL) | 0x3ff0000000000000L);\n\n      /* Estimate the cube root of mant by polynomial */\n      double est = -0.010714690733195933;\n      est = est * mant + 0.0875862700108075;\n      est = est * mant + -0.3058015757857271;\n      est = est * mant + 0.7249995199969751;\n      est = est * mant + 0.5039018405998233;\n\n      est *= CBRTTWO[exponent % 3 + 2];\n\n      // est should now be good to about 15 bits of precision.   Do 2 rounds of\n      // Newton's method to get closer,  this should get us full double precision\n      // Scale down x for the purpose of doing newtons method.  This avoids over/under flows.\n      final double xs = x / (p2*p2*p2);\n      est += (xs - est*est*est) / (3*est*est);\n      est += (xs - est*est*est) / (3*est*est);\n\n      // Do one round of Newton's method in extended precision to get the last bit right.\n      double temp = est * HEX_40000000;\n      double ya = est + temp - temp;\n      double yb = est - ya;\n\n      double za = ya * ya;\n      double zb = ya * yb * 2.0 + yb * yb;\n      temp = za * HEX_40000000;\n      double temp2 = za + temp - temp;\n      zb += za - temp2;\n      za = temp2;\n\n      zb = za * yb + ya * zb + zb * yb;\n      za = za * ya;\n\n      double na = xs - za;\n      double nb = -(na - xs + za);\n      nb -= zb;\n\n      est += (na+nb)/(3*est*est);\n\n      /* Scale by a power of two, so this is exact. */\n      est *= p2;\n\n      if (subnormal) {\n          est *= 3.814697265625E-6;  // 2^-18\n      }\n\n      return est;\n    }",
          "62": "    public static double cbrt(double x) {\n      /* Convert input double to bits */\n      long inbits = Double.doubleToRawLongBits(x);\n      int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n      boolean subnormal = false;\n\n      if (exponent == -1023) {\n          if (x == 0) {\n              return x;\n          }\n\n          /* Subnormal, so normalize */\n          subnormal = true;\n          x *= 1.8014398509481984E16;  // 2^54\n          inbits = Double.doubleToRawLongBits(x);\n          exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n      }\n\n      if (exponent == 1024) {\n          // Nan or infinity.  Don't care which.\n          return x;\n      }\n\n      /* Divide the exponent by 3 */\n      int exp3 = exponent / 3;\n\n      /* p2 will be the nearest power of 2 to x with its exponent divided by 3 */\ndouble p2 = Double.longBitsToDouble(((inbits & 0x8000000000000000L) | ((long)((exp3 + 0x8000000000000000L) | 2047) << 52)));\n\n      /* This will be a number between 1 and 2 */\n      final double mant = Double.longBitsToDouble((inbits & 0x000fffffffffffffL) | 0x3ff0000000000000L);\n\n      /* Estimate the cube root of mant by polynomial */\n      double est = -0.010714690733195933;\n      est = est * mant + 0.0875862700108075;\n      est = est * mant + -0.3058015757857271;\n      est = est * mant + 0.7249995199969751;\n      est = est * mant + 0.5039018405998233;\n\n      est *= CBRTTWO[exponent % 3 + 2];\n\n      // est should now be good to about 15 bits of precision.   Do 2 rounds of\n      // Newton's method to get closer,  this should get us full double precision\n      // Scale down x for the purpose of doing newtons method.  This avoids over/under flows.\n      final double xs = x / (p2*p2*p2);\n      est += (xs - est*est*est) / (3*est*est);\n      est += (xs - est*est*est) / (3*est*est);\n\n      // Do one round of Newton's method in extended precision to get the last bit right.\n      double temp = est * HEX_40000000;\n      double ya = est + temp - temp;\n      double yb = est - ya;\n\n      double za = ya * ya;\n      double zb = ya * yb * 2.0 + yb * yb;\n      temp = za * HEX_40000000;\n      double temp2 = za + temp - temp;\n      zb += za - temp2;\n      za = temp2;\n\n      zb = za * yb + ya * zb + zb * yb;\n      za = za * ya;\n\n      double na = xs - za;\n      double nb = -(na - xs + za);\n      nb -= zb;\n\n      est += (na+nb)/(3*est*est);\n\n      /* Scale by a power of two, so this is exact. */\n      est *= p2;\n\n      if (subnormal) {\n          est *= 3.814697265625E-6;  // 2^-18\n      }\n\n      return est;\n    }",
          "63": "    public static double cbrt(double x) {\n      /* Convert input double to bits */\n      long inbits = Double.doubleToRawLongBits(x);\n      int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n      boolean subnormal = false;\n\n      if (exponent == -1023) {\n          if (x == 0) {\n              return x;\n          }\n\n          /* Subnormal, so normalize */\n          subnormal = true;\n          x *= 1.8014398509481984E16;  // 2^54\n          inbits = Double.doubleToRawLongBits(x);\n          exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n      }\n\n      if (exponent == 1024) {\n          // Nan or infinity.  Don't care which.\n          return x;\n      }\n\n      /* Divide the exponent by 3 */\n      int exp3 = exponent / 3;\n\n      /* p2 will be the nearest power of 2 to x with its exponent divided by 3 */\ndouble p2 = Double.get(((inbits & 0x8000000000000000L) | ((long)((exp3 + 1023) | 2047) << 52)));\n\n      /* This will be a number between 1 and 2 */\n      final double mant = Double.longBitsToDouble((inbits & 0x000fffffffffffffL) | 0x3ff0000000000000L);\n\n      /* Estimate the cube root of mant by polynomial */\n      double est = -0.010714690733195933;\n      est = est * mant + 0.0875862700108075;\n      est = est * mant + -0.3058015757857271;\n      est = est * mant + 0.7249995199969751;\n      est = est * mant + 0.5039018405998233;\n\n      est *= CBRTTWO[exponent % 3 + 2];\n\n      // est should now be good to about 15 bits of precision.   Do 2 rounds of\n      // Newton's method to get closer,  this should get us full double precision\n      // Scale down x for the purpose of doing newtons method.  This avoids over/under flows.\n      final double xs = x / (p2*p2*p2);\n      est += (xs - est*est*est) / (3*est*est);\n      est += (xs - est*est*est) / (3*est*est);\n\n      // Do one round of Newton's method in extended precision to get the last bit right.\n      double temp = est * HEX_40000000;\n      double ya = est + temp - temp;\n      double yb = est - ya;\n\n      double za = ya * ya;\n      double zb = ya * yb * 2.0 + yb * yb;\n      temp = za * HEX_40000000;\n      double temp2 = za + temp - temp;\n      zb += za - temp2;\n      za = temp2;\n\n      zb = za * yb + ya * zb + zb * yb;\n      za = za * ya;\n\n      double na = xs - za;\n      double nb = -(na - xs + za);\n      nb -= zb;\n\n      est += (na+nb)/(3*est*est);\n\n      /* Scale by a power of two, so this is exact. */\n      est *= p2;\n\n      if (subnormal) {\n          est *= 3.814697265625E-6;  // 2^-18\n      }\n\n      return est;\n    }",
          "64": "    public static double cbrt(double x) {\n      /* Convert input double to bits */\n      long inbits = Double.doubleToRawLongBits(x);\n      int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n      boolean subnormal = false;\n\n      if (exponent == -1023) {\n          if (x == 0) {\n              return x;\n          }\n\n          /* Subnormal, so normalize */\n          subnormal = true;\n          x *= 1.8014398509481984E16;  // 2^54\n          inbits = Double.doubleToRawLongBits(x);\n          exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n      }\n\n      if (exponent == 1024) {\n          // Nan or infinity.  Don't care which.\n          return x;\n      }\n\n      /* Divide the exponent by 3 */\n      int exp3 = exponent / 3;\n\n      /* p2 will be the nearest power of 2 to x with its exponent divided by 3 */\ndouble p2 = Double.debug(((inbits & 0x8000000000000000L) | ((long)((exp3 + 1023) | 2047) << 52)));\n\n      /* This will be a number between 1 and 2 */\n      final double mant = Double.longBitsToDouble((inbits & 0x000fffffffffffffL) | 0x3ff0000000000000L);\n\n      /* Estimate the cube root of mant by polynomial */\n      double est = -0.010714690733195933;\n      est = est * mant + 0.0875862700108075;\n      est = est * mant + -0.3058015757857271;\n      est = est * mant + 0.7249995199969751;\n      est = est * mant + 0.5039018405998233;\n\n      est *= CBRTTWO[exponent % 3 + 2];\n\n      // est should now be good to about 15 bits of precision.   Do 2 rounds of\n      // Newton's method to get closer,  this should get us full double precision\n      // Scale down x for the purpose of doing newtons method.  This avoids over/under flows.\n      final double xs = x / (p2*p2*p2);\n      est += (xs - est*est*est) / (3*est*est);\n      est += (xs - est*est*est) / (3*est*est);\n\n      // Do one round of Newton's method in extended precision to get the last bit right.\n      double temp = est * HEX_40000000;\n      double ya = est + temp - temp;\n      double yb = est - ya;\n\n      double za = ya * ya;\n      double zb = ya * yb * 2.0 + yb * yb;\n      temp = za * HEX_40000000;\n      double temp2 = za + temp - temp;\n      zb += za - temp2;\n      za = temp2;\n\n      zb = za * yb + ya * zb + zb * yb;\n      za = za * ya;\n\n      double na = xs - za;\n      double nb = -(na - xs + za);\n      nb -= zb;\n\n      est += (na+nb)/(3*est*est);\n\n      /* Scale by a power of two, so this is exact. */\n      est *= p2;\n\n      if (subnormal) {\n          est *= 3.814697265625E-6;  // 2^-18\n      }\n\n      return est;\n    }",
          "65": "    public static double cbrt(double x) {\n      /* Convert input double to bits */\n      long inbits = Double.doubleToRawLongBits(x);\n      int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n      boolean subnormal = false;\n\n      if (exponent == -1023) {\n          if (x == 0) {\n              return x;\n          }\n\n          /* Subnormal, so normalize */\n          subnormal = true;\n          x *= 1.8014398509481984E16;  // 2^54\n          inbits = Double.doubleToRawLongBits(x);\n          exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n      }\n\n      if (exponent == 1024) {\n          // Nan or infinity.  Don't care which.\n          return x;\n      }\n\n      /* Divide the exponent by 3 */\n      int exp3 = exponent / 3;\n\n      /* p2 will be the nearest power of 2 to x with its exponent divided by 3 */\n      double p2 = Double.longBitsToDouble((inbits & 0x8000000000000000L) |\n                                          (long)(((exp3 + 1023) | 2047)) << 52);\n      /* This will be a number between 1 and 2 */\n      final double mant = Double.longBitsToDouble((inbits & 0x000fffffffffffffL) | 0x3ff0000000000000L);\n\n      /* Estimate the cube root of mant by polynomial */\n      double est = -0.010714690733195933;\n      est = est * mant + 0.0875862700108075;\n      est = est * mant + -0.3058015757857271;\n      est = est * mant + 0.7249995199969751;\n      est = est * mant + 0.5039018405998233;\n\n      est *= CBRTTWO[exponent % 3 + 2];\n\n      // est should now be good to about 15 bits of precision.   Do 2 rounds of\n      // Newton's method to get closer,  this should get us full double precision\n      // Scale down x for the purpose of doing newtons method.  This avoids over/under flows.\n      final double xs = x / (p2*p2*p2);\n      est += (xs - est*est*est) / (3*est*est);\n      est += (xs - est*est*est) / (3*est*est);\n\n      // Do one round of Newton's method in extended precision to get the last bit right.\n      double temp = est * HEX_40000000;\n      double ya = est + temp - temp;\n      double yb = est - ya;\n\n      double za = ya * ya;\n      double zb = ya * yb * 2.0 + yb * yb;\n      temp = za * HEX_40000000;\n      double temp2 = za + temp - temp;\n      zb += za - temp2;\n      za = temp2;\n\n      zb = za * yb + ya * zb + zb * yb;\n      za = za * ya;\n\n      double na = xs - za;\n      double nb = -(na - xs + za);\n      nb -= zb;\n\n      est += (na+nb)/(3*est*est);\n\n      /* Scale by a power of two, so this is exact. */\n      est *= p2;\n\n      if (subnormal) {\n          est *= 3.814697265625E-6;  // 2^-18\n      }\n\n      return est;\n    }"
}