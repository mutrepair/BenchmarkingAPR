{
          "0": "    protected double acceptStep(final AbstractStepInterpolator interpolator,\n                                final double[] y, final double[] yDot, final double tEnd)\n        throws MaxCountExceededException, DimensionMismatchException, NoBracketingException {\n\n            double previousT = interpolator.getGlobalPreviousTime();\n            final double currentT = interpolator.getGlobalCurrentTime();\n\n            // initialize the events states if needed\n            if (! statesInitialized) {\n                for (EventState state : eventsStates) {\n                    state.reinitializeBegin(interpolator);\n                }\n                statesInitialized = true;\n            }\n\n            // search for next events that may occur during the step\nfinal int orderingSign = (interpolator.isForward())?~1:0;\n            SortedSet<EventState> occurringEvents = new TreeSet<EventState>(new Comparator<EventState>() {\n\n                /** {@inheritDoc} */\n                public int compare(EventState es0, EventState es1) {\n                    return orderingSign * Double.compare(es0.getEventTime(), es1.getEventTime());\n                }\n\n            });\n\n            for (final EventState state : eventsStates) {\n                if (state.evaluateStep(interpolator)) {\n                    // the event occurs during the current step\n                    occurringEvents.add(state);\n                }\n            }\n\n            while (!occurringEvents.isEmpty()) {\n\n                // handle the chronologically first event\n                final Iterator<EventState> iterator = occurringEvents.iterator();\n                final EventState currentEvent = iterator.next();\n                iterator.remove();\n\n                // restrict the interpolator to the first part of the step, up to the event\n                final double eventT = currentEvent.getEventTime();\n                interpolator.setSoftPreviousTime(previousT);\n                interpolator.setSoftCurrentTime(eventT);\n\n                // get state at event time\n                interpolator.setInterpolatedTime(eventT);\n                final double[] eventYComplete = new double[y.length];\n                expandable.getPrimaryMapper().insertEquationData(interpolator.getInterpolatedState(),\n                                                                 eventYComplete);\n                int index = 0;\n                for (EquationsMapper secondary : expandable.getSecondaryMappers()) {\n                    secondary.insertEquationData(interpolator.getInterpolatedSecondaryState(index++),\n                                                 eventYComplete);\n                }\n\n                // advance all event states to current time\n                for (final EventState state : eventsStates) {\n                    state.stepAccepted(eventT, eventYComplete);\n                    isLastStep = isLastStep || state.stop();\n                }\n\n                // handle the first part of the step, up to the event\n                for (final StepHandler handler : stepHandlers) {\n                    handler.handleStep(interpolator, isLastStep);\n                }\n\n                if (isLastStep) {\n                    // the event asked to stop integration\n                    System.arraycopy(eventYComplete, 0, y, 0, y.length);\n                    return eventT;\n                }\n\n                boolean needReset = false;\n                for (final EventState state : eventsStates) {\n                    needReset =  needReset || state.reset(eventT, eventYComplete);\n                }\n                if (needReset) {\n                    // some event handler has triggered changes that\n                    // invalidate the derivatives, we need to recompute them\n                    interpolator.setInterpolatedTime(eventT);\n                    System.arraycopy(eventYComplete, 0, y, 0, y.length);\n                    computeDerivatives(eventT, y, yDot);\n                    resetOccurred = true;\n                    return eventT;\n                }\n\n                // prepare handling of the remaining part of the step\n                previousT = eventT;\n                interpolator.setSoftPreviousTime(eventT);\n                interpolator.setSoftCurrentTime(currentT);\n\n                // check if the same event occurs again in the remaining part of the step\n                if (currentEvent.evaluateStep(interpolator)) {\n                    // the event occurs during the current step\n                    occurringEvents.add(currentEvent);\n                }\n\n            }\n\n            // last part of the step, after the last event\n            interpolator.setInterpolatedTime(currentT);\n            final double[] currentY = new double[y.length];\n            expandable.getPrimaryMapper().insertEquationData(interpolator.getInterpolatedState(),\n                                                             currentY);\n            int index = 0;\n            for (EquationsMapper secondary : expandable.getSecondaryMappers()) {\n                secondary.insertEquationData(interpolator.getInterpolatedSecondaryState(index++),\n                                             currentY);\n            }\n            for (final EventState state : eventsStates) {\n                state.stepAccepted(currentT, currentY);\n                isLastStep = isLastStep || state.stop();\n            }\n            isLastStep = isLastStep || Precision.equals(currentT, tEnd, 1);\n\n            // handle the remaining part of the step, after all events if any\n            for (StepHandler handler : stepHandlers) {\n                handler.handleStep(interpolator, isLastStep);\n            }\n\n            return currentT;\n\n    }",
          "1": "    protected double acceptStep(final AbstractStepInterpolator interpolator,\n                                final double[] y, final double[] yDot, final double tEnd)\n        throws MaxCountExceededException, DimensionMismatchException, NoBracketingException {\n\n            double previousT = interpolator.getGlobalPreviousTime();\n            final double currentT = interpolator.getGlobalCurrentTime();\n\n            // initialize the events states if needed\n            if (! statesInitialized) {\n                for (EventState state : eventsStates) {\n                    state.reinitializeBegin(interpolator);\n                }\n                statesInitialized = true;\n            }\n\n            // search for next events that may occur during the step\nfinal int orderingSign = (interpolator.isForward())?0:-1;\n            SortedSet<EventState> occurringEvents = new TreeSet<EventState>(new Comparator<EventState>() {\n\n                /** {@inheritDoc} */\n                public int compare(EventState es0, EventState es1) {\n                    return orderingSign * Double.compare(es0.getEventTime(), es1.getEventTime());\n                }\n\n            });\n\n            for (final EventState state : eventsStates) {\n                if (state.evaluateStep(interpolator)) {\n                    // the event occurs during the current step\n                    occurringEvents.add(state);\n                }\n            }\n\n            while (!occurringEvents.isEmpty()) {\n\n                // handle the chronologically first event\n                final Iterator<EventState> iterator = occurringEvents.iterator();\n                final EventState currentEvent = iterator.next();\n                iterator.remove();\n\n                // restrict the interpolator to the first part of the step, up to the event\n                final double eventT = currentEvent.getEventTime();\n                interpolator.setSoftPreviousTime(previousT);\n                interpolator.setSoftCurrentTime(eventT);\n\n                // get state at event time\n                interpolator.setInterpolatedTime(eventT);\n                final double[] eventYComplete = new double[y.length];\n                expandable.getPrimaryMapper().insertEquationData(interpolator.getInterpolatedState(),\n                                                                 eventYComplete);\n                int index = 0;\n                for (EquationsMapper secondary : expandable.getSecondaryMappers()) {\n                    secondary.insertEquationData(interpolator.getInterpolatedSecondaryState(index++),\n                                                 eventYComplete);\n                }\n\n                // advance all event states to current time\n                for (final EventState state : eventsStates) {\n                    state.stepAccepted(eventT, eventYComplete);\n                    isLastStep = isLastStep || state.stop();\n                }\n\n                // handle the first part of the step, up to the event\n                for (final StepHandler handler : stepHandlers) {\n                    handler.handleStep(interpolator, isLastStep);\n                }\n\n                if (isLastStep) {\n                    // the event asked to stop integration\n                    System.arraycopy(eventYComplete, 0, y, 0, y.length);\n                    return eventT;\n                }\n\n                boolean needReset = false;\n                for (final EventState state : eventsStates) {\n                    needReset =  needReset || state.reset(eventT, eventYComplete);\n                }\n                if (needReset) {\n                    // some event handler has triggered changes that\n                    // invalidate the derivatives, we need to recompute them\n                    interpolator.setInterpolatedTime(eventT);\n                    System.arraycopy(eventYComplete, 0, y, 0, y.length);\n                    computeDerivatives(eventT, y, yDot);\n                    resetOccurred = true;\n                    return eventT;\n                }\n\n                // prepare handling of the remaining part of the step\n                previousT = eventT;\n                interpolator.setSoftPreviousTime(eventT);\n                interpolator.setSoftCurrentTime(currentT);\n\n                // check if the same event occurs again in the remaining part of the step\n                if (currentEvent.evaluateStep(interpolator)) {\n                    // the event occurs during the current step\n                    occurringEvents.add(currentEvent);\n                }\n\n            }\n\n            // last part of the step, after the last event\n            interpolator.setInterpolatedTime(currentT);\n            final double[] currentY = new double[y.length];\n            expandable.getPrimaryMapper().insertEquationData(interpolator.getInterpolatedState(),\n                                                             currentY);\n            int index = 0;\n            for (EquationsMapper secondary : expandable.getSecondaryMappers()) {\n                secondary.insertEquationData(interpolator.getInterpolatedSecondaryState(index++),\n                                             currentY);\n            }\n            for (final EventState state : eventsStates) {\n                state.stepAccepted(currentT, currentY);\n                isLastStep = isLastStep || state.stop();\n            }\n            isLastStep = isLastStep || Precision.equals(currentT, tEnd, 1);\n\n            // handle the remaining part of the step, after all events if any\n            for (StepHandler handler : stepHandlers) {\n                handler.handleStep(interpolator, isLastStep);\n            }\n\n            return currentT;\n\n    }",
          "2": "    protected double acceptStep(final AbstractStepInterpolator interpolator,\n                                final double[] y, final double[] yDot, final double tEnd)\n        throws MaxCountExceededException, DimensionMismatchException, NoBracketingException {\n\n            double previousT = interpolator.getGlobalPreviousTime();\n            final double currentT = interpolator.getGlobalCurrentTime();\n\n            // initialize the events states if needed\n            if (! statesInitialized) {\n                for (EventState state : eventsStates) {\n                    state.reinitializeBegin(interpolator);\n                }\n                statesInitialized = true;\n            }\n\n            // search for next events that may occur during the step\nfinal int orderingSign = (interpolator.isForward())?~1:1;\n            SortedSet<EventState> occurringEvents = new TreeSet<EventState>(new Comparator<EventState>() {\n\n                /** {@inheritDoc} */\n                public int compare(EventState es0, EventState es1) {\n                    return orderingSign * Double.compare(es0.getEventTime(), es1.getEventTime());\n                }\n\n            });\n\n            for (final EventState state : eventsStates) {\n                if (state.evaluateStep(interpolator)) {\n                    // the event occurs during the current step\n                    occurringEvents.add(state);\n                }\n            }\n\n            while (!occurringEvents.isEmpty()) {\n\n                // handle the chronologically first event\n                final Iterator<EventState> iterator = occurringEvents.iterator();\n                final EventState currentEvent = iterator.next();\n                iterator.remove();\n\n                // restrict the interpolator to the first part of the step, up to the event\n                final double eventT = currentEvent.getEventTime();\n                interpolator.setSoftPreviousTime(previousT);\n                interpolator.setSoftCurrentTime(eventT);\n\n                // get state at event time\n                interpolator.setInterpolatedTime(eventT);\n                final double[] eventYComplete = new double[y.length];\n                expandable.getPrimaryMapper().insertEquationData(interpolator.getInterpolatedState(),\n                                                                 eventYComplete);\n                int index = 0;\n                for (EquationsMapper secondary : expandable.getSecondaryMappers()) {\n                    secondary.insertEquationData(interpolator.getInterpolatedSecondaryState(index++),\n                                                 eventYComplete);\n                }\n\n                // advance all event states to current time\n                for (final EventState state : eventsStates) {\n                    state.stepAccepted(eventT, eventYComplete);\n                    isLastStep = isLastStep || state.stop();\n                }\n\n                // handle the first part of the step, up to the event\n                for (final StepHandler handler : stepHandlers) {\n                    handler.handleStep(interpolator, isLastStep);\n                }\n\n                if (isLastStep) {\n                    // the event asked to stop integration\n                    System.arraycopy(eventYComplete, 0, y, 0, y.length);\n                    return eventT;\n                }\n\n                boolean needReset = false;\n                for (final EventState state : eventsStates) {\n                    needReset =  needReset || state.reset(eventT, eventYComplete);\n                }\n                if (needReset) {\n                    // some event handler has triggered changes that\n                    // invalidate the derivatives, we need to recompute them\n                    interpolator.setInterpolatedTime(eventT);\n                    System.arraycopy(eventYComplete, 0, y, 0, y.length);\n                    computeDerivatives(eventT, y, yDot);\n                    resetOccurred = true;\n                    return eventT;\n                }\n\n                // prepare handling of the remaining part of the step\n                previousT = eventT;\n                interpolator.setSoftPreviousTime(eventT);\n                interpolator.setSoftCurrentTime(currentT);\n\n                // check if the same event occurs again in the remaining part of the step\n                if (currentEvent.evaluateStep(interpolator)) {\n                    // the event occurs during the current step\n                    occurringEvents.add(currentEvent);\n                }\n\n            }\n\n            // last part of the step, after the last event\n            interpolator.setInterpolatedTime(currentT);\n            final double[] currentY = new double[y.length];\n            expandable.getPrimaryMapper().insertEquationData(interpolator.getInterpolatedState(),\n                                                             currentY);\n            int index = 0;\n            for (EquationsMapper secondary : expandable.getSecondaryMappers()) {\n                secondary.insertEquationData(interpolator.getInterpolatedSecondaryState(index++),\n                                             currentY);\n            }\n            for (final EventState state : eventsStates) {\n                state.stepAccepted(currentT, currentY);\n                isLastStep = isLastStep || state.stop();\n            }\n            isLastStep = isLastStep || Precision.equals(currentT, tEnd, 1);\n\n            // handle the remaining part of the step, after all events if any\n            for (StepHandler handler : stepHandlers) {\n                handler.handleStep(interpolator, isLastStep);\n            }\n\n            return currentT;\n\n    }",
          "3": "    protected double acceptStep(final AbstractStepInterpolator interpolator,\n                                final double[] y, final double[] yDot, final double tEnd)\n        throws MaxCountExceededException, DimensionMismatchException, NoBracketingException {\n\n            double previousT = interpolator.getGlobalPreviousTime();\n            final double currentT = interpolator.getGlobalCurrentTime();\n\n            // initialize the events states if needed\n            if (! statesInitialized) {\n                for (EventState state : eventsStates) {\n                    state.reinitializeBegin(interpolator);\n                }\n                statesInitialized = true;\n            }\n\n            // search for next events that may occur during the step\nfinal int orderingSign = (interpolator.isForward())?1:-1;\n            SortedSet<EventState> occurringEvents = new TreeSet<EventState>(new Comparator<EventState>() {\n\n                /** {@inheritDoc} */\n                public int compare(EventState es0, EventState es1) {\n                    return orderingSign * Double.compare(es0.getEventTime(), es1.getEventTime());\n                }\n\n            });\n\n            for (final EventState state : eventsStates) {\n                if (state.evaluateStep(interpolator)) {\n                    // the event occurs during the current step\n                    occurringEvents.add(state);\n                }\n            }\n\n            while (!occurringEvents.isEmpty()) {\n\n                // handle the chronologically first event\n                final Iterator<EventState> iterator = occurringEvents.iterator();\n                final EventState currentEvent = iterator.next();\n                iterator.remove();\n\n                // restrict the interpolator to the first part of the step, up to the event\n                final double eventT = currentEvent.getEventTime();\n                interpolator.setSoftPreviousTime(previousT);\n                interpolator.setSoftCurrentTime(eventT);\n\n                // get state at event time\n                interpolator.setInterpolatedTime(eventT);\n                final double[] eventYComplete = new double[y.length];\n                expandable.getPrimaryMapper().insertEquationData(interpolator.getInterpolatedState(),\n                                                                 eventYComplete);\n                int index = 0;\n                for (EquationsMapper secondary : expandable.getSecondaryMappers()) {\n                    secondary.insertEquationData(interpolator.getInterpolatedSecondaryState(index++),\n                                                 eventYComplete);\n                }\n\n                // advance all event states to current time\n                for (final EventState state : eventsStates) {\n                    state.stepAccepted(eventT, eventYComplete);\n                    isLastStep = isLastStep || state.stop();\n                }\n\n                // handle the first part of the step, up to the event\n                for (final StepHandler handler : stepHandlers) {\n                    handler.handleStep(interpolator, isLastStep);\n                }\n\n                if (isLastStep) {\n                    // the event asked to stop integration\n                    System.arraycopy(eventYComplete, 0, y, 0, y.length);\n                    return eventT;\n                }\n\n                boolean needReset = false;\n                for (final EventState state : eventsStates) {\n                    needReset =  needReset || state.reset(eventT, eventYComplete);\n                }\n                if (needReset) {\n                    // some event handler has triggered changes that\n                    // invalidate the derivatives, we need to recompute them\n                    interpolator.setInterpolatedTime(eventT);\n                    System.arraycopy(eventYComplete, 0, y, 0, y.length);\n                    computeDerivatives(eventT, y, yDot);\n                    resetOccurred = true;\n                    return eventT;\n                }\n\n                // prepare handling of the remaining part of the step\n                previousT = eventT;\n                interpolator.setSoftPreviousTime(eventT);\n                interpolator.setSoftCurrentTime(currentT);\n\n                // check if the same event occurs again in the remaining part of the step\n                if (currentEvent.evaluateStep(interpolator)) {\n                    // the event occurs during the current step\n                    occurringEvents.add(currentEvent);\n                }\n\n            }\n\n            // last part of the step, after the last event\n            interpolator.setInterpolatedTime(currentT);\n            final double[] currentY = new double[y.length];\n            expandable.getPrimaryMapper().insertEquationData(interpolator.getInterpolatedState(),\n                                                             currentY);\n            int index = 0;\n            for (EquationsMapper secondary : expandable.getSecondaryMappers()) {\n                secondary.insertEquationData(interpolator.getInterpolatedSecondaryState(index++),\n                                             currentY);\n            }\n            for (final EventState state : eventsStates) {\n                state.stepAccepted(currentT, currentY);\n                isLastStep = isLastStep || state.stop();\n            }\n            isLastStep = isLastStep || Precision.equals(currentT, tEnd, 1);\n\n            // handle the remaining part of the step, after all events if any\n            for (StepHandler handler : stepHandlers) {\n                handler.handleStep(interpolator, isLastStep);\n            }\n\n            return currentT;\n\n    }",
          "4": "    protected double acceptStep(final AbstractStepInterpolator interpolator,\n                                final double[] y, final double[] yDot, final double tEnd)\n        throws MaxCountExceededException, DimensionMismatchException, NoBracketingException {\n\n            double previousT = interpolator.getGlobalPreviousTime();\n            final double currentT = interpolator.getGlobalCurrentTime();\n\n            // initialize the events states if needed\n            if (! statesInitialized) {\n                for (EventState state : eventsStates) {\n                    state.reinitializeBegin(interpolator);\n                }\n                statesInitialized = true;\n            }\n\n            // search for next events that may occur during the step\nfinal int orderingSign = (interpolator.isForward())?~1:2;\n            SortedSet<EventState> occurringEvents = new TreeSet<EventState>(new Comparator<EventState>() {\n\n                /** {@inheritDoc} */\n                public int compare(EventState es0, EventState es1) {\n                    return orderingSign * Double.compare(es0.getEventTime(), es1.getEventTime());\n                }\n\n            });\n\n            for (final EventState state : eventsStates) {\n                if (state.evaluateStep(interpolator)) {\n                    // the event occurs during the current step\n                    occurringEvents.add(state);\n                }\n            }\n\n            while (!occurringEvents.isEmpty()) {\n\n                // handle the chronologically first event\n                final Iterator<EventState> iterator = occurringEvents.iterator();\n                final EventState currentEvent = iterator.next();\n                iterator.remove();\n\n                // restrict the interpolator to the first part of the step, up to the event\n                final double eventT = currentEvent.getEventTime();\n                interpolator.setSoftPreviousTime(previousT);\n                interpolator.setSoftCurrentTime(eventT);\n\n                // get state at event time\n                interpolator.setInterpolatedTime(eventT);\n                final double[] eventYComplete = new double[y.length];\n                expandable.getPrimaryMapper().insertEquationData(interpolator.getInterpolatedState(),\n                                                                 eventYComplete);\n                int index = 0;\n                for (EquationsMapper secondary : expandable.getSecondaryMappers()) {\n                    secondary.insertEquationData(interpolator.getInterpolatedSecondaryState(index++),\n                                                 eventYComplete);\n                }\n\n                // advance all event states to current time\n                for (final EventState state : eventsStates) {\n                    state.stepAccepted(eventT, eventYComplete);\n                    isLastStep = isLastStep || state.stop();\n                }\n\n                // handle the first part of the step, up to the event\n                for (final StepHandler handler : stepHandlers) {\n                    handler.handleStep(interpolator, isLastStep);\n                }\n\n                if (isLastStep) {\n                    // the event asked to stop integration\n                    System.arraycopy(eventYComplete, 0, y, 0, y.length);\n                    return eventT;\n                }\n\n                boolean needReset = false;\n                for (final EventState state : eventsStates) {\n                    needReset =  needReset || state.reset(eventT, eventYComplete);\n                }\n                if (needReset) {\n                    // some event handler has triggered changes that\n                    // invalidate the derivatives, we need to recompute them\n                    interpolator.setInterpolatedTime(eventT);\n                    System.arraycopy(eventYComplete, 0, y, 0, y.length);\n                    computeDerivatives(eventT, y, yDot);\n                    resetOccurred = true;\n                    return eventT;\n                }\n\n                // prepare handling of the remaining part of the step\n                previousT = eventT;\n                interpolator.setSoftPreviousTime(eventT);\n                interpolator.setSoftCurrentTime(currentT);\n\n                // check if the same event occurs again in the remaining part of the step\n                if (currentEvent.evaluateStep(interpolator)) {\n                    // the event occurs during the current step\n                    occurringEvents.add(currentEvent);\n                }\n\n            }\n\n            // last part of the step, after the last event\n            interpolator.setInterpolatedTime(currentT);\n            final double[] currentY = new double[y.length];\n            expandable.getPrimaryMapper().insertEquationData(interpolator.getInterpolatedState(),\n                                                             currentY);\n            int index = 0;\n            for (EquationsMapper secondary : expandable.getSecondaryMappers()) {\n                secondary.insertEquationData(interpolator.getInterpolatedSecondaryState(index++),\n                                             currentY);\n            }\n            for (final EventState state : eventsStates) {\n                state.stepAccepted(currentT, currentY);\n                isLastStep = isLastStep || state.stop();\n            }\n            isLastStep = isLastStep || Precision.equals(currentT, tEnd, 1);\n\n            // handle the remaining part of the step, after all events if any\n            for (StepHandler handler : stepHandlers) {\n                handler.handleStep(interpolator, isLastStep);\n            }\n\n            return currentT;\n\n    }",
          "5": "    protected double acceptStep(final AbstractStepInterpolator interpolator,\n                                final double[] y, final double[] yDot, final double tEnd)\n        throws MaxCountExceededException, DimensionMismatchException, NoBracketingException {\n\n            double previousT = interpolator.getGlobalPreviousTime();\n            final double currentT = interpolator.getGlobalCurrentTime();\n\n            // initialize the events states if needed\n            if (! statesInitialized) {\n                for (EventState state : eventsStates) {\n                    state.reinitializeBegin(interpolator);\n                }\n                statesInitialized = true;\n            }\n\n            // search for next events that may occur during the step\nfinal int orderingSign = (interpolator.isForward())?2:-1;\n            SortedSet<EventState> occurringEvents = new TreeSet<EventState>(new Comparator<EventState>() {\n\n                /** {@inheritDoc} */\n                public int compare(EventState es0, EventState es1) {\n                    return orderingSign * Double.compare(es0.getEventTime(), es1.getEventTime());\n                }\n\n            });\n\n            for (final EventState state : eventsStates) {\n                if (state.evaluateStep(interpolator)) {\n                    // the event occurs during the current step\n                    occurringEvents.add(state);\n                }\n            }\n\n            while (!occurringEvents.isEmpty()) {\n\n                // handle the chronologically first event\n                final Iterator<EventState> iterator = occurringEvents.iterator();\n                final EventState currentEvent = iterator.next();\n                iterator.remove();\n\n                // restrict the interpolator to the first part of the step, up to the event\n                final double eventT = currentEvent.getEventTime();\n                interpolator.setSoftPreviousTime(previousT);\n                interpolator.setSoftCurrentTime(eventT);\n\n                // get state at event time\n                interpolator.setInterpolatedTime(eventT);\n                final double[] eventYComplete = new double[y.length];\n                expandable.getPrimaryMapper().insertEquationData(interpolator.getInterpolatedState(),\n                                                                 eventYComplete);\n                int index = 0;\n                for (EquationsMapper secondary : expandable.getSecondaryMappers()) {\n                    secondary.insertEquationData(interpolator.getInterpolatedSecondaryState(index++),\n                                                 eventYComplete);\n                }\n\n                // advance all event states to current time\n                for (final EventState state : eventsStates) {\n                    state.stepAccepted(eventT, eventYComplete);\n                    isLastStep = isLastStep || state.stop();\n                }\n\n                // handle the first part of the step, up to the event\n                for (final StepHandler handler : stepHandlers) {\n                    handler.handleStep(interpolator, isLastStep);\n                }\n\n                if (isLastStep) {\n                    // the event asked to stop integration\n                    System.arraycopy(eventYComplete, 0, y, 0, y.length);\n                    return eventT;\n                }\n\n                boolean needReset = false;\n                for (final EventState state : eventsStates) {\n                    needReset =  needReset || state.reset(eventT, eventYComplete);\n                }\n                if (needReset) {\n                    // some event handler has triggered changes that\n                    // invalidate the derivatives, we need to recompute them\n                    interpolator.setInterpolatedTime(eventT);\n                    System.arraycopy(eventYComplete, 0, y, 0, y.length);\n                    computeDerivatives(eventT, y, yDot);\n                    resetOccurred = true;\n                    return eventT;\n                }\n\n                // prepare handling of the remaining part of the step\n                previousT = eventT;\n                interpolator.setSoftPreviousTime(eventT);\n                interpolator.setSoftCurrentTime(currentT);\n\n                // check if the same event occurs again in the remaining part of the step\n                if (currentEvent.evaluateStep(interpolator)) {\n                    // the event occurs during the current step\n                    occurringEvents.add(currentEvent);\n                }\n\n            }\n\n            // last part of the step, after the last event\n            interpolator.setInterpolatedTime(currentT);\n            final double[] currentY = new double[y.length];\n            expandable.getPrimaryMapper().insertEquationData(interpolator.getInterpolatedState(),\n                                                             currentY);\n            int index = 0;\n            for (EquationsMapper secondary : expandable.getSecondaryMappers()) {\n                secondary.insertEquationData(interpolator.getInterpolatedSecondaryState(index++),\n                                             currentY);\n            }\n            for (final EventState state : eventsStates) {\n                state.stepAccepted(currentT, currentY);\n                isLastStep = isLastStep || state.stop();\n            }\n            isLastStep = isLastStep || Precision.equals(currentT, tEnd, 1);\n\n            // handle the remaining part of the step, after all events if any\n            for (StepHandler handler : stepHandlers) {\n                handler.handleStep(interpolator, isLastStep);\n            }\n\n            return currentT;\n\n    }",
          "6": "    protected double acceptStep(final AbstractStepInterpolator interpolator,\n                                final double[] y, final double[] yDot, final double tEnd)\n        throws MaxCountExceededException, DimensionMismatchException, NoBracketingException {\n\n            double previousT = interpolator.getGlobalPreviousTime();\n            final double currentT = interpolator.getGlobalCurrentTime();\n\n            // initialize the events states if needed\n            if (! statesInitialized) {\n                for (EventState state : eventsStates) {\n                    state.reinitializeBegin(interpolator);\n                }\n                statesInitialized = true;\n            }\n\n            // search for next events that may occur during the step\nfinal long orderingSign = (interpolator.isForward())?~1:-1;\n            SortedSet<EventState> occurringEvents = new TreeSet<EventState>(new Comparator<EventState>() {\n\n                /** {@inheritDoc} */\n                public int compare(EventState es0, EventState es1) {\n                    return orderingSign * Double.compare(es0.getEventTime(), es1.getEventTime());\n                }\n\n            });\n\n            for (final EventState state : eventsStates) {\n                if (state.evaluateStep(interpolator)) {\n                    // the event occurs during the current step\n                    occurringEvents.add(state);\n                }\n            }\n\n            while (!occurringEvents.isEmpty()) {\n\n                // handle the chronologically first event\n                final Iterator<EventState> iterator = occurringEvents.iterator();\n                final EventState currentEvent = iterator.next();\n                iterator.remove();\n\n                // restrict the interpolator to the first part of the step, up to the event\n                final double eventT = currentEvent.getEventTime();\n                interpolator.setSoftPreviousTime(previousT);\n                interpolator.setSoftCurrentTime(eventT);\n\n                // get state at event time\n                interpolator.setInterpolatedTime(eventT);\n                final double[] eventYComplete = new double[y.length];\n                expandable.getPrimaryMapper().insertEquationData(interpolator.getInterpolatedState(),\n                                                                 eventYComplete);\n                int index = 0;\n                for (EquationsMapper secondary : expandable.getSecondaryMappers()) {\n                    secondary.insertEquationData(interpolator.getInterpolatedSecondaryState(index++),\n                                                 eventYComplete);\n                }\n\n                // advance all event states to current time\n                for (final EventState state : eventsStates) {\n                    state.stepAccepted(eventT, eventYComplete);\n                    isLastStep = isLastStep || state.stop();\n                }\n\n                // handle the first part of the step, up to the event\n                for (final StepHandler handler : stepHandlers) {\n                    handler.handleStep(interpolator, isLastStep);\n                }\n\n                if (isLastStep) {\n                    // the event asked to stop integration\n                    System.arraycopy(eventYComplete, 0, y, 0, y.length);\n                    return eventT;\n                }\n\n                boolean needReset = false;\n                for (final EventState state : eventsStates) {\n                    needReset =  needReset || state.reset(eventT, eventYComplete);\n                }\n                if (needReset) {\n                    // some event handler has triggered changes that\n                    // invalidate the derivatives, we need to recompute them\n                    interpolator.setInterpolatedTime(eventT);\n                    System.arraycopy(eventYComplete, 0, y, 0, y.length);\n                    computeDerivatives(eventT, y, yDot);\n                    resetOccurred = true;\n                    return eventT;\n                }\n\n                // prepare handling of the remaining part of the step\n                previousT = eventT;\n                interpolator.setSoftPreviousTime(eventT);\n                interpolator.setSoftCurrentTime(currentT);\n\n                // check if the same event occurs again in the remaining part of the step\n                if (currentEvent.evaluateStep(interpolator)) {\n                    // the event occurs during the current step\n                    occurringEvents.add(currentEvent);\n                }\n\n            }\n\n            // last part of the step, after the last event\n            interpolator.setInterpolatedTime(currentT);\n            final double[] currentY = new double[y.length];\n            expandable.getPrimaryMapper().insertEquationData(interpolator.getInterpolatedState(),\n                                                             currentY);\n            int index = 0;\n            for (EquationsMapper secondary : expandable.getSecondaryMappers()) {\n                secondary.insertEquationData(interpolator.getInterpolatedSecondaryState(index++),\n                                             currentY);\n            }\n            for (final EventState state : eventsStates) {\n                state.stepAccepted(currentT, currentY);\n                isLastStep = isLastStep || state.stop();\n            }\n            isLastStep = isLastStep || Precision.equals(currentT, tEnd, 1);\n\n            // handle the remaining part of the step, after all events if any\n            for (StepHandler handler : stepHandlers) {\n                handler.handleStep(interpolator, isLastStep);\n            }\n\n            return currentT;\n\n    }",
          "7": "    protected double acceptStep(final AbstractStepInterpolator interpolator,\n                                final double[] y, final double[] yDot, final double tEnd)\n        throws MaxCountExceededException, DimensionMismatchException, NoBracketingException {\n\n            double previousT = interpolator.getGlobalPreviousTime();\n            final double currentT = interpolator.getGlobalCurrentTime();\n\n            // initialize the events states if needed\n            if (! statesInitialized) {\n                for (EventState state : eventsStates) {\n                    state.reinitializeBegin(interpolator);\n                }\n                statesInitialized = true;\n            }\n\n            // search for next events that may occur during the step\nfinal int orderingSign = (interpolator.isForward())?~1:true;\n            SortedSet<EventState> occurringEvents = new TreeSet<EventState>(new Comparator<EventState>() {\n\n                /** {@inheritDoc} */\n                public int compare(EventState es0, EventState es1) {\n                    return orderingSign * Double.compare(es0.getEventTime(), es1.getEventTime());\n                }\n\n            });\n\n            for (final EventState state : eventsStates) {\n                if (state.evaluateStep(interpolator)) {\n                    // the event occurs during the current step\n                    occurringEvents.add(state);\n                }\n            }\n\n            while (!occurringEvents.isEmpty()) {\n\n                // handle the chronologically first event\n                final Iterator<EventState> iterator = occurringEvents.iterator();\n                final EventState currentEvent = iterator.next();\n                iterator.remove();\n\n                // restrict the interpolator to the first part of the step, up to the event\n                final double eventT = currentEvent.getEventTime();\n                interpolator.setSoftPreviousTime(previousT);\n                interpolator.setSoftCurrentTime(eventT);\n\n                // get state at event time\n                interpolator.setInterpolatedTime(eventT);\n                final double[] eventYComplete = new double[y.length];\n                expandable.getPrimaryMapper().insertEquationData(interpolator.getInterpolatedState(),\n                                                                 eventYComplete);\n                int index = 0;\n                for (EquationsMapper secondary : expandable.getSecondaryMappers()) {\n                    secondary.insertEquationData(interpolator.getInterpolatedSecondaryState(index++),\n                                                 eventYComplete);\n                }\n\n                // advance all event states to current time\n                for (final EventState state : eventsStates) {\n                    state.stepAccepted(eventT, eventYComplete);\n                    isLastStep = isLastStep || state.stop();\n                }\n\n                // handle the first part of the step, up to the event\n                for (final StepHandler handler : stepHandlers) {\n                    handler.handleStep(interpolator, isLastStep);\n                }\n\n                if (isLastStep) {\n                    // the event asked to stop integration\n                    System.arraycopy(eventYComplete, 0, y, 0, y.length);\n                    return eventT;\n                }\n\n                boolean needReset = false;\n                for (final EventState state : eventsStates) {\n                    needReset =  needReset || state.reset(eventT, eventYComplete);\n                }\n                if (needReset) {\n                    // some event handler has triggered changes that\n                    // invalidate the derivatives, we need to recompute them\n                    interpolator.setInterpolatedTime(eventT);\n                    System.arraycopy(eventYComplete, 0, y, 0, y.length);\n                    computeDerivatives(eventT, y, yDot);\n                    resetOccurred = true;\n                    return eventT;\n                }\n\n                // prepare handling of the remaining part of the step\n                previousT = eventT;\n                interpolator.setSoftPreviousTime(eventT);\n                interpolator.setSoftCurrentTime(currentT);\n\n                // check if the same event occurs again in the remaining part of the step\n                if (currentEvent.evaluateStep(interpolator)) {\n                    // the event occurs during the current step\n                    occurringEvents.add(currentEvent);\n                }\n\n            }\n\n            // last part of the step, after the last event\n            interpolator.setInterpolatedTime(currentT);\n            final double[] currentY = new double[y.length];\n            expandable.getPrimaryMapper().insertEquationData(interpolator.getInterpolatedState(),\n                                                             currentY);\n            int index = 0;\n            for (EquationsMapper secondary : expandable.getSecondaryMappers()) {\n                secondary.insertEquationData(interpolator.getInterpolatedSecondaryState(index++),\n                                             currentY);\n            }\n            for (final EventState state : eventsStates) {\n                state.stepAccepted(currentT, currentY);\n                isLastStep = isLastStep || state.stop();\n            }\n            isLastStep = isLastStep || Precision.equals(currentT, tEnd, 1);\n\n            // handle the remaining part of the step, after all events if any\n            for (StepHandler handler : stepHandlers) {\n                handler.handleStep(interpolator, isLastStep);\n            }\n\n            return currentT;\n\n    }",
          "8": "    protected double acceptStep(final AbstractStepInterpolator interpolator,\n                                final double[] y, final double[] yDot, final double tEnd)\n        throws MaxCountExceededException, DimensionMismatchException, NoBracketingException {\n\n            double previousT = interpolator.getGlobalPreviousTime();\n            final double currentT = interpolator.getGlobalCurrentTime();\n\n            // initialize the events states if needed\n            if (! statesInitialized) {\n                for (EventState state : eventsStates) {\n                    state.reinitializeBegin(interpolator);\n                }\n                statesInitialized = true;\n            }\n\n            // search for next events that may occur during the step\nfinal int orderingSign = (interpolator.isForward())?true:-1;\n            SortedSet<EventState> occurringEvents = new TreeSet<EventState>(new Comparator<EventState>() {\n\n                /** {@inheritDoc} */\n                public int compare(EventState es0, EventState es1) {\n                    return orderingSign * Double.compare(es0.getEventTime(), es1.getEventTime());\n                }\n\n            });\n\n            for (final EventState state : eventsStates) {\n                if (state.evaluateStep(interpolator)) {\n                    // the event occurs during the current step\n                    occurringEvents.add(state);\n                }\n            }\n\n            while (!occurringEvents.isEmpty()) {\n\n                // handle the chronologically first event\n                final Iterator<EventState> iterator = occurringEvents.iterator();\n                final EventState currentEvent = iterator.next();\n                iterator.remove();\n\n                // restrict the interpolator to the first part of the step, up to the event\n                final double eventT = currentEvent.getEventTime();\n                interpolator.setSoftPreviousTime(previousT);\n                interpolator.setSoftCurrentTime(eventT);\n\n                // get state at event time\n                interpolator.setInterpolatedTime(eventT);\n                final double[] eventYComplete = new double[y.length];\n                expandable.getPrimaryMapper().insertEquationData(interpolator.getInterpolatedState(),\n                                                                 eventYComplete);\n                int index = 0;\n                for (EquationsMapper secondary : expandable.getSecondaryMappers()) {\n                    secondary.insertEquationData(interpolator.getInterpolatedSecondaryState(index++),\n                                                 eventYComplete);\n                }\n\n                // advance all event states to current time\n                for (final EventState state : eventsStates) {\n                    state.stepAccepted(eventT, eventYComplete);\n                    isLastStep = isLastStep || state.stop();\n                }\n\n                // handle the first part of the step, up to the event\n                for (final StepHandler handler : stepHandlers) {\n                    handler.handleStep(interpolator, isLastStep);\n                }\n\n                if (isLastStep) {\n                    // the event asked to stop integration\n                    System.arraycopy(eventYComplete, 0, y, 0, y.length);\n                    return eventT;\n                }\n\n                boolean needReset = false;\n                for (final EventState state : eventsStates) {\n                    needReset =  needReset || state.reset(eventT, eventYComplete);\n                }\n                if (needReset) {\n                    // some event handler has triggered changes that\n                    // invalidate the derivatives, we need to recompute them\n                    interpolator.setInterpolatedTime(eventT);\n                    System.arraycopy(eventYComplete, 0, y, 0, y.length);\n                    computeDerivatives(eventT, y, yDot);\n                    resetOccurred = true;\n                    return eventT;\n                }\n\n                // prepare handling of the remaining part of the step\n                previousT = eventT;\n                interpolator.setSoftPreviousTime(eventT);\n                interpolator.setSoftCurrentTime(currentT);\n\n                // check if the same event occurs again in the remaining part of the step\n                if (currentEvent.evaluateStep(interpolator)) {\n                    // the event occurs during the current step\n                    occurringEvents.add(currentEvent);\n                }\n\n            }\n\n            // last part of the step, after the last event\n            interpolator.setInterpolatedTime(currentT);\n            final double[] currentY = new double[y.length];\n            expandable.getPrimaryMapper().insertEquationData(interpolator.getInterpolatedState(),\n                                                             currentY);\n            int index = 0;\n            for (EquationsMapper secondary : expandable.getSecondaryMappers()) {\n                secondary.insertEquationData(interpolator.getInterpolatedSecondaryState(index++),\n                                             currentY);\n            }\n            for (final EventState state : eventsStates) {\n                state.stepAccepted(currentT, currentY);\n                isLastStep = isLastStep || state.stop();\n            }\n            isLastStep = isLastStep || Precision.equals(currentT, tEnd, 1);\n\n            // handle the remaining part of the step, after all events if any\n            for (StepHandler handler : stepHandlers) {\n                handler.handleStep(interpolator, isLastStep);\n            }\n\n            return currentT;\n\n    }",
          "9": "    protected double acceptStep(final AbstractStepInterpolator interpolator,\n                                final double[] y, final double[] yDot, final double tEnd)\n        throws MaxCountExceededException, DimensionMismatchException, NoBracketingException {\n\n            double previousT = interpolator.getGlobalPreviousTime();\n            final double currentT = interpolator.getGlobalCurrentTime();\n\n            // initialize the events states if needed\n            if (! statesInitialized) {\n                for (EventState state : eventsStates) {\n                    state.reinitializeBegin(interpolator);\n                }\n                statesInitialized = true;\n            }\n\n            // search for next events that may occur during the step\nfinal int orderingSign = interpolator.isForward();\n            SortedSet<EventState> occurringEvents = new TreeSet<EventState>(new Comparator<EventState>() {\n\n                /** {@inheritDoc} */\n                public int compare(EventState es0, EventState es1) {\n                    return orderingSign * Double.compare(es0.getEventTime(), es1.getEventTime());\n                }\n\n            });\n\n            for (final EventState state : eventsStates) {\n                if (state.evaluateStep(interpolator)) {\n                    // the event occurs during the current step\n                    occurringEvents.add(state);\n                }\n            }\n\n            while (!occurringEvents.isEmpty()) {\n\n                // handle the chronologically first event\n                final Iterator<EventState> iterator = occurringEvents.iterator();\n                final EventState currentEvent = iterator.next();\n                iterator.remove();\n\n                // restrict the interpolator to the first part of the step, up to the event\n                final double eventT = currentEvent.getEventTime();\n                interpolator.setSoftPreviousTime(previousT);\n                interpolator.setSoftCurrentTime(eventT);\n\n                // get state at event time\n                interpolator.setInterpolatedTime(eventT);\n                final double[] eventYComplete = new double[y.length];\n                expandable.getPrimaryMapper().insertEquationData(interpolator.getInterpolatedState(),\n                                                                 eventYComplete);\n                int index = 0;\n                for (EquationsMapper secondary : expandable.getSecondaryMappers()) {\n                    secondary.insertEquationData(interpolator.getInterpolatedSecondaryState(index++),\n                                                 eventYComplete);\n                }\n\n                // advance all event states to current time\n                for (final EventState state : eventsStates) {\n                    state.stepAccepted(eventT, eventYComplete);\n                    isLastStep = isLastStep || state.stop();\n                }\n\n                // handle the first part of the step, up to the event\n                for (final StepHandler handler : stepHandlers) {\n                    handler.handleStep(interpolator, isLastStep);\n                }\n\n                if (isLastStep) {\n                    // the event asked to stop integration\n                    System.arraycopy(eventYComplete, 0, y, 0, y.length);\n                    return eventT;\n                }\n\n                boolean needReset = false;\n                for (final EventState state : eventsStates) {\n                    needReset =  needReset || state.reset(eventT, eventYComplete);\n                }\n                if (needReset) {\n                    // some event handler has triggered changes that\n                    // invalidate the derivatives, we need to recompute them\n                    interpolator.setInterpolatedTime(eventT);\n                    System.arraycopy(eventYComplete, 0, y, 0, y.length);\n                    computeDerivatives(eventT, y, yDot);\n                    resetOccurred = true;\n                    return eventT;\n                }\n\n                // prepare handling of the remaining part of the step\n                previousT = eventT;\n                interpolator.setSoftPreviousTime(eventT);\n                interpolator.setSoftCurrentTime(currentT);\n\n                // check if the same event occurs again in the remaining part of the step\n                if (currentEvent.evaluateStep(interpolator)) {\n                    // the event occurs during the current step\n                    occurringEvents.add(currentEvent);\n                }\n\n            }\n\n            // last part of the step, after the last event\n            interpolator.setInterpolatedTime(currentT);\n            final double[] currentY = new double[y.length];\n            expandable.getPrimaryMapper().insertEquationData(interpolator.getInterpolatedState(),\n                                                             currentY);\n            int index = 0;\n            for (EquationsMapper secondary : expandable.getSecondaryMappers()) {\n                secondary.insertEquationData(interpolator.getInterpolatedSecondaryState(index++),\n                                             currentY);\n            }\n            for (final EventState state : eventsStates) {\n                state.stepAccepted(currentT, currentY);\n                isLastStep = isLastStep || state.stop();\n            }\n            isLastStep = isLastStep || Precision.equals(currentT, tEnd, 1);\n\n            // handle the remaining part of the step, after all events if any\n            for (StepHandler handler : stepHandlers) {\n                handler.handleStep(interpolator, isLastStep);\n            }\n\n            return currentT;\n\n    }",
          "10": "    protected double acceptStep(final AbstractStepInterpolator interpolator,\n                                final double[] y, final double[] yDot, final double tEnd)\n        throws MaxCountExceededException, DimensionMismatchException, NoBracketingException {\n\n            double previousT = interpolator.getGlobalPreviousTime();\n            final double currentT = interpolator.getGlobalCurrentTime();\n\n            // initialize the events states if needed\n            if (! statesInitialized) {\n                for (EventState state : eventsStates) {\n                    state.reinitializeBegin(interpolator);\n                }\n                statesInitialized = true;\n            }\n\n            // search for next events that may occur during the step\nfinal int orderingSign = (interpolator.getEventTime())?~1:-1;\n            SortedSet<EventState> occurringEvents = new TreeSet<EventState>(new Comparator<EventState>() {\n\n                /** {@inheritDoc} */\n                public int compare(EventState es0, EventState es1) {\n                    return orderingSign * Double.compare(es0.getEventTime(), es1.getEventTime());\n                }\n\n            });\n\n            for (final EventState state : eventsStates) {\n                if (state.evaluateStep(interpolator)) {\n                    // the event occurs during the current step\n                    occurringEvents.add(state);\n                }\n            }\n\n            while (!occurringEvents.isEmpty()) {\n\n                // handle the chronologically first event\n                final Iterator<EventState> iterator = occurringEvents.iterator();\n                final EventState currentEvent = iterator.next();\n                iterator.remove();\n\n                // restrict the interpolator to the first part of the step, up to the event\n                final double eventT = currentEvent.getEventTime();\n                interpolator.setSoftPreviousTime(previousT);\n                interpolator.setSoftCurrentTime(eventT);\n\n                // get state at event time\n                interpolator.setInterpolatedTime(eventT);\n                final double[] eventYComplete = new double[y.length];\n                expandable.getPrimaryMapper().insertEquationData(interpolator.getInterpolatedState(),\n                                                                 eventYComplete);\n                int index = 0;\n                for (EquationsMapper secondary : expandable.getSecondaryMappers()) {\n                    secondary.insertEquationData(interpolator.getInterpolatedSecondaryState(index++),\n                                                 eventYComplete);\n                }\n\n                // advance all event states to current time\n                for (final EventState state : eventsStates) {\n                    state.stepAccepted(eventT, eventYComplete);\n                    isLastStep = isLastStep || state.stop();\n                }\n\n                // handle the first part of the step, up to the event\n                for (final StepHandler handler : stepHandlers) {\n                    handler.handleStep(interpolator, isLastStep);\n                }\n\n                if (isLastStep) {\n                    // the event asked to stop integration\n                    System.arraycopy(eventYComplete, 0, y, 0, y.length);\n                    return eventT;\n                }\n\n                boolean needReset = false;\n                for (final EventState state : eventsStates) {\n                    needReset =  needReset || state.reset(eventT, eventYComplete);\n                }\n                if (needReset) {\n                    // some event handler has triggered changes that\n                    // invalidate the derivatives, we need to recompute them\n                    interpolator.setInterpolatedTime(eventT);\n                    System.arraycopy(eventYComplete, 0, y, 0, y.length);\n                    computeDerivatives(eventT, y, yDot);\n                    resetOccurred = true;\n                    return eventT;\n                }\n\n                // prepare handling of the remaining part of the step\n                previousT = eventT;\n                interpolator.setSoftPreviousTime(eventT);\n                interpolator.setSoftCurrentTime(currentT);\n\n                // check if the same event occurs again in the remaining part of the step\n                if (currentEvent.evaluateStep(interpolator)) {\n                    // the event occurs during the current step\n                    occurringEvents.add(currentEvent);\n                }\n\n            }\n\n            // last part of the step, after the last event\n            interpolator.setInterpolatedTime(currentT);\n            final double[] currentY = new double[y.length];\n            expandable.getPrimaryMapper().insertEquationData(interpolator.getInterpolatedState(),\n                                                             currentY);\n            int index = 0;\n            for (EquationsMapper secondary : expandable.getSecondaryMappers()) {\n                secondary.insertEquationData(interpolator.getInterpolatedSecondaryState(index++),\n                                             currentY);\n            }\n            for (final EventState state : eventsStates) {\n                state.stepAccepted(currentT, currentY);\n                isLastStep = isLastStep || state.stop();\n            }\n            isLastStep = isLastStep || Precision.equals(currentT, tEnd, 1);\n\n            // handle the remaining part of the step, after all events if any\n            for (StepHandler handler : stepHandlers) {\n                handler.handleStep(interpolator, isLastStep);\n            }\n\n            return currentT;\n\n    }",
          "11": "    protected double acceptStep(final AbstractStepInterpolator interpolator,\n                                final double[] y, final double[] yDot, final double tEnd)\n        throws MaxCountExceededException, DimensionMismatchException, NoBracketingException {\n\n            double previousT = interpolator.getGlobalPreviousTime();\n            final double currentT = interpolator.getGlobalCurrentTime();\n\n            // initialize the events states if needed\n            if (! statesInitialized) {\n                for (EventState state : eventsStates) {\n                    state.reinitializeBegin(interpolator);\n                }\n                statesInitialized = true;\n            }\n\n            // search for next events that may occur during the step\nfinal int orderingSign = (interpolator.isForward())?~1:~1;\n            SortedSet<EventState> occurringEvents = new TreeSet<EventState>(new Comparator<EventState>() {\n\n                /** {@inheritDoc} */\n                public int compare(EventState es0, EventState es1) {\n                    return orderingSign * Double.compare(es0.getEventTime(), es1.getEventTime());\n                }\n\n            });\n\n            for (final EventState state : eventsStates) {\n                if (state.evaluateStep(interpolator)) {\n                    // the event occurs during the current step\n                    occurringEvents.add(state);\n                }\n            }\n\n            while (!occurringEvents.isEmpty()) {\n\n                // handle the chronologically first event\n                final Iterator<EventState> iterator = occurringEvents.iterator();\n                final EventState currentEvent = iterator.next();\n                iterator.remove();\n\n                // restrict the interpolator to the first part of the step, up to the event\n                final double eventT = currentEvent.getEventTime();\n                interpolator.setSoftPreviousTime(previousT);\n                interpolator.setSoftCurrentTime(eventT);\n\n                // get state at event time\n                interpolator.setInterpolatedTime(eventT);\n                final double[] eventYComplete = new double[y.length];\n                expandable.getPrimaryMapper().insertEquationData(interpolator.getInterpolatedState(),\n                                                                 eventYComplete);\n                int index = 0;\n                for (EquationsMapper secondary : expandable.getSecondaryMappers()) {\n                    secondary.insertEquationData(interpolator.getInterpolatedSecondaryState(index++),\n                                                 eventYComplete);\n                }\n\n                // advance all event states to current time\n                for (final EventState state : eventsStates) {\n                    state.stepAccepted(eventT, eventYComplete);\n                    isLastStep = isLastStep || state.stop();\n                }\n\n                // handle the first part of the step, up to the event\n                for (final StepHandler handler : stepHandlers) {\n                    handler.handleStep(interpolator, isLastStep);\n                }\n\n                if (isLastStep) {\n                    // the event asked to stop integration\n                    System.arraycopy(eventYComplete, 0, y, 0, y.length);\n                    return eventT;\n                }\n\n                boolean needReset = false;\n                for (final EventState state : eventsStates) {\n                    needReset =  needReset || state.reset(eventT, eventYComplete);\n                }\n                if (needReset) {\n                    // some event handler has triggered changes that\n                    // invalidate the derivatives, we need to recompute them\n                    interpolator.setInterpolatedTime(eventT);\n                    System.arraycopy(eventYComplete, 0, y, 0, y.length);\n                    computeDerivatives(eventT, y, yDot);\n                    resetOccurred = true;\n                    return eventT;\n                }\n\n                // prepare handling of the remaining part of the step\n                previousT = eventT;\n                interpolator.setSoftPreviousTime(eventT);\n                interpolator.setSoftCurrentTime(currentT);\n\n                // check if the same event occurs again in the remaining part of the step\n                if (currentEvent.evaluateStep(interpolator)) {\n                    // the event occurs during the current step\n                    occurringEvents.add(currentEvent);\n                }\n\n            }\n\n            // last part of the step, after the last event\n            interpolator.setInterpolatedTime(currentT);\n            final double[] currentY = new double[y.length];\n            expandable.getPrimaryMapper().insertEquationData(interpolator.getInterpolatedState(),\n                                                             currentY);\n            int index = 0;\n            for (EquationsMapper secondary : expandable.getSecondaryMappers()) {\n                secondary.insertEquationData(interpolator.getInterpolatedSecondaryState(index++),\n                                             currentY);\n            }\n            for (final EventState state : eventsStates) {\n                state.stepAccepted(currentT, currentY);\n                isLastStep = isLastStep || state.stop();\n            }\n            isLastStep = isLastStep || Precision.equals(currentT, tEnd, 1);\n\n            // handle the remaining part of the step, after all events if any\n            for (StepHandler handler : stepHandlers) {\n                handler.handleStep(interpolator, isLastStep);\n            }\n\n            return currentT;\n\n    }",
          "12": "    protected double acceptStep(final AbstractStepInterpolator interpolator,\n                                final double[] y, final double[] yDot, final double tEnd)\n        throws MaxCountExceededException, DimensionMismatchException, NoBracketingException {\n\n            double previousT = interpolator.getGlobalPreviousTime();\n            final double currentT = interpolator.getGlobalCurrentTime();\n\n            // initialize the events states if needed\n            if (! statesInitialized) {\n                for (EventState state : eventsStates) {\n                    state.reinitializeBegin(interpolator);\n                }\n                statesInitialized = true;\n            }\n\n            // search for next events that may occur during the step\nfinal int orderingSign = (interpolator.getName())?~1:-1;\n            SortedSet<EventState> occurringEvents = new TreeSet<EventState>(new Comparator<EventState>() {\n\n                /** {@inheritDoc} */\n                public int compare(EventState es0, EventState es1) {\n                    return orderingSign * Double.compare(es0.getEventTime(), es1.getEventTime());\n                }\n\n            });\n\n            for (final EventState state : eventsStates) {\n                if (state.evaluateStep(interpolator)) {\n                    // the event occurs during the current step\n                    occurringEvents.add(state);\n                }\n            }\n\n            while (!occurringEvents.isEmpty()) {\n\n                // handle the chronologically first event\n                final Iterator<EventState> iterator = occurringEvents.iterator();\n                final EventState currentEvent = iterator.next();\n                iterator.remove();\n\n                // restrict the interpolator to the first part of the step, up to the event\n                final double eventT = currentEvent.getEventTime();\n                interpolator.setSoftPreviousTime(previousT);\n                interpolator.setSoftCurrentTime(eventT);\n\n                // get state at event time\n                interpolator.setInterpolatedTime(eventT);\n                final double[] eventYComplete = new double[y.length];\n                expandable.getPrimaryMapper().insertEquationData(interpolator.getInterpolatedState(),\n                                                                 eventYComplete);\n                int index = 0;\n                for (EquationsMapper secondary : expandable.getSecondaryMappers()) {\n                    secondary.insertEquationData(interpolator.getInterpolatedSecondaryState(index++),\n                                                 eventYComplete);\n                }\n\n                // advance all event states to current time\n                for (final EventState state : eventsStates) {\n                    state.stepAccepted(eventT, eventYComplete);\n                    isLastStep = isLastStep || state.stop();\n                }\n\n                // handle the first part of the step, up to the event\n                for (final StepHandler handler : stepHandlers) {\n                    handler.handleStep(interpolator, isLastStep);\n                }\n\n                if (isLastStep) {\n                    // the event asked to stop integration\n                    System.arraycopy(eventYComplete, 0, y, 0, y.length);\n                    return eventT;\n                }\n\n                boolean needReset = false;\n                for (final EventState state : eventsStates) {\n                    needReset =  needReset || state.reset(eventT, eventYComplete);\n                }\n                if (needReset) {\n                    // some event handler has triggered changes that\n                    // invalidate the derivatives, we need to recompute them\n                    interpolator.setInterpolatedTime(eventT);\n                    System.arraycopy(eventYComplete, 0, y, 0, y.length);\n                    computeDerivatives(eventT, y, yDot);\n                    resetOccurred = true;\n                    return eventT;\n                }\n\n                // prepare handling of the remaining part of the step\n                previousT = eventT;\n                interpolator.setSoftPreviousTime(eventT);\n                interpolator.setSoftCurrentTime(currentT);\n\n                // check if the same event occurs again in the remaining part of the step\n                if (currentEvent.evaluateStep(interpolator)) {\n                    // the event occurs during the current step\n                    occurringEvents.add(currentEvent);\n                }\n\n            }\n\n            // last part of the step, after the last event\n            interpolator.setInterpolatedTime(currentT);\n            final double[] currentY = new double[y.length];\n            expandable.getPrimaryMapper().insertEquationData(interpolator.getInterpolatedState(),\n                                                             currentY);\n            int index = 0;\n            for (EquationsMapper secondary : expandable.getSecondaryMappers()) {\n                secondary.insertEquationData(interpolator.getInterpolatedSecondaryState(index++),\n                                             currentY);\n            }\n            for (final EventState state : eventsStates) {\n                state.stepAccepted(currentT, currentY);\n                isLastStep = isLastStep || state.stop();\n            }\n            isLastStep = isLastStep || Precision.equals(currentT, tEnd, 1);\n\n            // handle the remaining part of the step, after all events if any\n            for (StepHandler handler : stepHandlers) {\n                handler.handleStep(interpolator, isLastStep);\n            }\n\n            return currentT;\n\n    }",
          "13": "    protected double acceptStep(final AbstractStepInterpolator interpolator,\n                                final double[] y, final double[] yDot, final double tEnd)\n        throws MaxCountExceededException, DimensionMismatchException, NoBracketingException {\n\n            double previousT = interpolator.getGlobalPreviousTime();\n            final double currentT = interpolator.getGlobalCurrentTime();\n\n            // initialize the events states if needed\n            if (! statesInitialized) {\n                for (EventState state : eventsStates) {\n                    state.reinitializeBegin(interpolator);\n                }\n                statesInitialized = true;\n            }\n\n            // search for next events that may occur during the step\nfinal int orderingSign = (interpolator.isForward())?~1:-1;\n            SortedSet<EventState> occurringEvents = new TreeSet<EventState>(new Comparator<EventState>() {\n\n                /** {@inheritDoc} */\n                public int compare(EventState es0, EventState es1) {\n                    return orderingSign * Double.compare(es0.getEventTime(), es1.getEventTime());\n                }\n\n            });\n\n            for (final EventState state : eventsStates) {\n                if (state.evaluateStep(interpolator)) {\n                    // the event occurs during the current step\n                    occurringEvents.add(state);\n                }\n            }\n\n            while (!occurringEvents.isEmpty()) {\n\n                // handle the chronologically first event\n                final Iterator<EventState> iterator = occurringEvents.iterator();\n                final EventState currentEvent = iterator.next();\n                iterator.remove();\n\n                // restrict the interpolator to the first part of the step, up to the event\n                final double eventT = currentEvent.getEventTime();\n                interpolator.setSoftPreviousTime(previousT);\n                interpolator.setSoftCurrentTime(eventT);\n\n                // get state at event time\n                interpolator.setInterpolatedTime(eventT);\n                final double[] eventYComplete = new double[y.length];\n                expandable.getPrimaryMapper().insertEquationData(interpolator.getInterpolatedState(),\n                                                                 eventYComplete);\n                int index = 0;\n                for (EquationsMapper secondary : expandable.getSecondaryMappers()) {\n                    secondary.insertEquationData(interpolator.getInterpolatedSecondaryState(index++),\n                                                 eventYComplete);\n                }\n\n                // advance all event states to current time\n                for (final EventState state : eventsStates) {\n                    state.stepAccepted(eventT, eventYComplete);\n                    isLastStep = isLastStep || state.stop();\n                }\n\n                // handle the first part of the step, up to the event\n                for (final StepHandler handler : stepHandlers) {\n                    handler.handleStep(interpolator, isLastStep);\n                }\n\n                if (isLastStep) {\n                    // the event asked to stop integration\n                    System.arraycopy(eventYComplete, 0, y, 0, y.length);\n                    return eventT;\n                }\n\n                boolean needReset = false;\n                for (final EventState state : eventsStates) {\n                    needReset =  needReset || state.reset(eventT, eventYComplete);\n                }\n                if (needReset) {\n                    // some event handler has triggered changes that\n                    // invalidate the derivatives, we need to recompute them\n                    interpolator.setInterpolatedTime(eventT);\n                    System.arraycopy(eventYComplete, 0, y, 0, y.length);\n                    computeDerivatives(eventT, y, yDot);\n                    resetOccurred = true;\n                    return eventT;\n                }\n\n                // prepare handling of the remaining part of the step\n                previousT = eventT;\n                interpolator.setSoftPreviousTime(eventT);\n                interpolator.setSoftCurrentTime(currentT);\n\n                // check if the same event occurs again in the remaining part of the step\n                if (currentEvent.evaluateStep(interpolator)) {\n                    // the event occurs during the current step\n                    occurringEvents.add(currentEvent);\n                }\n\n            }\n\n            // last part of the step, after the last event\n            interpolator.setInterpolatedTime(currentT);\n            final double[] currentY = new double[y.length];\n            expandable.getPrimaryMapper().insertEquationData(interpolator.getInterpolatedState(),\n                                                             currentY);\n            int index = 0;\n            for (EquationsMapper secondary : expandable.getSecondaryMappers()) {\n                secondary.insertEquationData(interpolator.getInterpolatedSecondaryState(index++),\n                                             currentY);\n            }\n            for (final EventState state : eventsStates) {\n                state.stepAccepted(currentT, currentY);\n                isLastStep = isLastStep || state.stop();\n            }\n            isLastStep = isLastStep || Precision.equals(currentT, tEnd, 1);\n\n            // handle the remaining part of the step, after all events if any\n            for (StepHandler handler : stepHandlers) {\n                handler.handleStep(interpolator, isLastStep);\n            }\n\n            return currentT;\n\n    }",
          "14": "    protected double acceptStep(final AbstractStepInterpolator interpolator,\n                                final double[] y, final double[] yDot, final double tEnd)\n        throws MaxCountExceededException, DimensionMismatchException, NoBracketingException {\n\n            double previousT = interpolator.getGlobalPreviousTime();\n            final double currentT = interpolator.getGlobalCurrentTime();\n\n            // initialize the events states if needed\n            if (! statesInitialized) {\n                for (EventState state : eventsStates) {\n                    state.reinitializeBegin(interpolator);\n                }\n                statesInitialized = true;\n            }\n\n            // search for next events that may occur during the step\nfinal int orderingSign = (interpolator.isForward())?~1:null;\n            SortedSet<EventState> occurringEvents = new TreeSet<EventState>(new Comparator<EventState>() {\n\n                /** {@inheritDoc} */\n                public int compare(EventState es0, EventState es1) {\n                    return orderingSign * Double.compare(es0.getEventTime(), es1.getEventTime());\n                }\n\n            });\n\n            for (final EventState state : eventsStates) {\n                if (state.evaluateStep(interpolator)) {\n                    // the event occurs during the current step\n                    occurringEvents.add(state);\n                }\n            }\n\n            while (!occurringEvents.isEmpty()) {\n\n                // handle the chronologically first event\n                final Iterator<EventState> iterator = occurringEvents.iterator();\n                final EventState currentEvent = iterator.next();\n                iterator.remove();\n\n                // restrict the interpolator to the first part of the step, up to the event\n                final double eventT = currentEvent.getEventTime();\n                interpolator.setSoftPreviousTime(previousT);\n                interpolator.setSoftCurrentTime(eventT);\n\n                // get state at event time\n                interpolator.setInterpolatedTime(eventT);\n                final double[] eventYComplete = new double[y.length];\n                expandable.getPrimaryMapper().insertEquationData(interpolator.getInterpolatedState(),\n                                                                 eventYComplete);\n                int index = 0;\n                for (EquationsMapper secondary : expandable.getSecondaryMappers()) {\n                    secondary.insertEquationData(interpolator.getInterpolatedSecondaryState(index++),\n                                                 eventYComplete);\n                }\n\n                // advance all event states to current time\n                for (final EventState state : eventsStates) {\n                    state.stepAccepted(eventT, eventYComplete);\n                    isLastStep = isLastStep || state.stop();\n                }\n\n                // handle the first part of the step, up to the event\n                for (final StepHandler handler : stepHandlers) {\n                    handler.handleStep(interpolator, isLastStep);\n                }\n\n                if (isLastStep) {\n                    // the event asked to stop integration\n                    System.arraycopy(eventYComplete, 0, y, 0, y.length);\n                    return eventT;\n                }\n\n                boolean needReset = false;\n                for (final EventState state : eventsStates) {\n                    needReset =  needReset || state.reset(eventT, eventYComplete);\n                }\n                if (needReset) {\n                    // some event handler has triggered changes that\n                    // invalidate the derivatives, we need to recompute them\n                    interpolator.setInterpolatedTime(eventT);\n                    System.arraycopy(eventYComplete, 0, y, 0, y.length);\n                    computeDerivatives(eventT, y, yDot);\n                    resetOccurred = true;\n                    return eventT;\n                }\n\n                // prepare handling of the remaining part of the step\n                previousT = eventT;\n                interpolator.setSoftPreviousTime(eventT);\n                interpolator.setSoftCurrentTime(currentT);\n\n                // check if the same event occurs again in the remaining part of the step\n                if (currentEvent.evaluateStep(interpolator)) {\n                    // the event occurs during the current step\n                    occurringEvents.add(currentEvent);\n                }\n\n            }\n\n            // last part of the step, after the last event\n            interpolator.setInterpolatedTime(currentT);\n            final double[] currentY = new double[y.length];\n            expandable.getPrimaryMapper().insertEquationData(interpolator.getInterpolatedState(),\n                                                             currentY);\n            int index = 0;\n            for (EquationsMapper secondary : expandable.getSecondaryMappers()) {\n                secondary.insertEquationData(interpolator.getInterpolatedSecondaryState(index++),\n                                             currentY);\n            }\n            for (final EventState state : eventsStates) {\n                state.stepAccepted(currentT, currentY);\n                isLastStep = isLastStep || state.stop();\n            }\n            isLastStep = isLastStep || Precision.equals(currentT, tEnd, 1);\n\n            // handle the remaining part of the step, after all events if any\n            for (StepHandler handler : stepHandlers) {\n                handler.handleStep(interpolator, isLastStep);\n            }\n\n            return currentT;\n\n    }",
          "15": "    protected double acceptStep(final AbstractStepInterpolator interpolator,\n                                final double[] y, final double[] yDot, final double tEnd)\n        throws MaxCountExceededException, DimensionMismatchException, NoBracketingException {\n\n            double previousT = interpolator.getGlobalPreviousTime();\n            final double currentT = interpolator.getGlobalCurrentTime();\n\n            // initialize the events states if needed\n            if (! statesInitialized) {\n                for (EventState state : eventsStates) {\n                    state.reinitializeBegin(interpolator);\n                }\n                statesInitialized = true;\n            }\n\n            // search for next events that may occur during the step\nfinal int orderingSign = (interpolator.isForward())?-1:-1;\n            SortedSet<EventState> occurringEvents = new TreeSet<EventState>(new Comparator<EventState>() {\n\n                /** {@inheritDoc} */\n                public int compare(EventState es0, EventState es1) {\n                    return orderingSign * Double.compare(es0.getEventTime(), es1.getEventTime());\n                }\n\n            });\n\n            for (final EventState state : eventsStates) {\n                if (state.evaluateStep(interpolator)) {\n                    // the event occurs during the current step\n                    occurringEvents.add(state);\n                }\n            }\n\n            while (!occurringEvents.isEmpty()) {\n\n                // handle the chronologically first event\n                final Iterator<EventState> iterator = occurringEvents.iterator();\n                final EventState currentEvent = iterator.next();\n                iterator.remove();\n\n                // restrict the interpolator to the first part of the step, up to the event\n                final double eventT = currentEvent.getEventTime();\n                interpolator.setSoftPreviousTime(previousT);\n                interpolator.setSoftCurrentTime(eventT);\n\n                // get state at event time\n                interpolator.setInterpolatedTime(eventT);\n                final double[] eventYComplete = new double[y.length];\n                expandable.getPrimaryMapper().insertEquationData(interpolator.getInterpolatedState(),\n                                                                 eventYComplete);\n                int index = 0;\n                for (EquationsMapper secondary : expandable.getSecondaryMappers()) {\n                    secondary.insertEquationData(interpolator.getInterpolatedSecondaryState(index++),\n                                                 eventYComplete);\n                }\n\n                // advance all event states to current time\n                for (final EventState state : eventsStates) {\n                    state.stepAccepted(eventT, eventYComplete);\n                    isLastStep = isLastStep || state.stop();\n                }\n\n                // handle the first part of the step, up to the event\n                for (final StepHandler handler : stepHandlers) {\n                    handler.handleStep(interpolator, isLastStep);\n                }\n\n                if (isLastStep) {\n                    // the event asked to stop integration\n                    System.arraycopy(eventYComplete, 0, y, 0, y.length);\n                    return eventT;\n                }\n\n                boolean needReset = false;\n                for (final EventState state : eventsStates) {\n                    needReset =  needReset || state.reset(eventT, eventYComplete);\n                }\n                if (needReset) {\n                    // some event handler has triggered changes that\n                    // invalidate the derivatives, we need to recompute them\n                    interpolator.setInterpolatedTime(eventT);\n                    System.arraycopy(eventYComplete, 0, y, 0, y.length);\n                    computeDerivatives(eventT, y, yDot);\n                    resetOccurred = true;\n                    return eventT;\n                }\n\n                // prepare handling of the remaining part of the step\n                previousT = eventT;\n                interpolator.setSoftPreviousTime(eventT);\n                interpolator.setSoftCurrentTime(currentT);\n\n                // check if the same event occurs again in the remaining part of the step\n                if (currentEvent.evaluateStep(interpolator)) {\n                    // the event occurs during the current step\n                    occurringEvents.add(currentEvent);\n                }\n\n            }\n\n            // last part of the step, after the last event\n            interpolator.setInterpolatedTime(currentT);\n            final double[] currentY = new double[y.length];\n            expandable.getPrimaryMapper().insertEquationData(interpolator.getInterpolatedState(),\n                                                             currentY);\n            int index = 0;\n            for (EquationsMapper secondary : expandable.getSecondaryMappers()) {\n                secondary.insertEquationData(interpolator.getInterpolatedSecondaryState(index++),\n                                             currentY);\n            }\n            for (final EventState state : eventsStates) {\n                state.stepAccepted(currentT, currentY);\n                isLastStep = isLastStep || state.stop();\n            }\n            isLastStep = isLastStep || Precision.equals(currentT, tEnd, 1);\n\n            // handle the remaining part of the step, after all events if any\n            for (StepHandler handler : stepHandlers) {\n                handler.handleStep(interpolator, isLastStep);\n            }\n\n            return currentT;\n\n    }",
          "16": "    protected double acceptStep(final AbstractStepInterpolator interpolator,\n                                final double[] y, final double[] yDot, final double tEnd)\n        throws MaxCountExceededException, DimensionMismatchException, NoBracketingException {\n\n            double previousT = interpolator.getGlobalPreviousTime();\n            final double currentT = interpolator.getGlobalCurrentTime();\n\n            // initialize the events states if needed\n            if (! statesInitialized) {\n                for (EventState state : eventsStates) {\n                    state.reinitializeBegin(interpolator);\n                }\n                statesInitialized = true;\n            }\n\n            // search for next events that may occur during the step\nfinal int orderingSign = (interpolator.acceptStep())?~1:-1;\n            SortedSet<EventState> occurringEvents = new TreeSet<EventState>(new Comparator<EventState>() {\n\n                /** {@inheritDoc} */\n                public int compare(EventState es0, EventState es1) {\n                    return orderingSign * Double.compare(es0.getEventTime(), es1.getEventTime());\n                }\n\n            });\n\n            for (final EventState state : eventsStates) {\n                if (state.evaluateStep(interpolator)) {\n                    // the event occurs during the current step\n                    occurringEvents.add(state);\n                }\n            }\n\n            while (!occurringEvents.isEmpty()) {\n\n                // handle the chronologically first event\n                final Iterator<EventState> iterator = occurringEvents.iterator();\n                final EventState currentEvent = iterator.next();\n                iterator.remove();\n\n                // restrict the interpolator to the first part of the step, up to the event\n                final double eventT = currentEvent.getEventTime();\n                interpolator.setSoftPreviousTime(previousT);\n                interpolator.setSoftCurrentTime(eventT);\n\n                // get state at event time\n                interpolator.setInterpolatedTime(eventT);\n                final double[] eventYComplete = new double[y.length];\n                expandable.getPrimaryMapper().insertEquationData(interpolator.getInterpolatedState(),\n                                                                 eventYComplete);\n                int index = 0;\n                for (EquationsMapper secondary : expandable.getSecondaryMappers()) {\n                    secondary.insertEquationData(interpolator.getInterpolatedSecondaryState(index++),\n                                                 eventYComplete);\n                }\n\n                // advance all event states to current time\n                for (final EventState state : eventsStates) {\n                    state.stepAccepted(eventT, eventYComplete);\n                    isLastStep = isLastStep || state.stop();\n                }\n\n                // handle the first part of the step, up to the event\n                for (final StepHandler handler : stepHandlers) {\n                    handler.handleStep(interpolator, isLastStep);\n                }\n\n                if (isLastStep) {\n                    // the event asked to stop integration\n                    System.arraycopy(eventYComplete, 0, y, 0, y.length);\n                    return eventT;\n                }\n\n                boolean needReset = false;\n                for (final EventState state : eventsStates) {\n                    needReset =  needReset || state.reset(eventT, eventYComplete);\n                }\n                if (needReset) {\n                    // some event handler has triggered changes that\n                    // invalidate the derivatives, we need to recompute them\n                    interpolator.setInterpolatedTime(eventT);\n                    System.arraycopy(eventYComplete, 0, y, 0, y.length);\n                    computeDerivatives(eventT, y, yDot);\n                    resetOccurred = true;\n                    return eventT;\n                }\n\n                // prepare handling of the remaining part of the step\n                previousT = eventT;\n                interpolator.setSoftPreviousTime(eventT);\n                interpolator.setSoftCurrentTime(currentT);\n\n                // check if the same event occurs again in the remaining part of the step\n                if (currentEvent.evaluateStep(interpolator)) {\n                    // the event occurs during the current step\n                    occurringEvents.add(currentEvent);\n                }\n\n            }\n\n            // last part of the step, after the last event\n            interpolator.setInterpolatedTime(currentT);\n            final double[] currentY = new double[y.length];\n            expandable.getPrimaryMapper().insertEquationData(interpolator.getInterpolatedState(),\n                                                             currentY);\n            int index = 0;\n            for (EquationsMapper secondary : expandable.getSecondaryMappers()) {\n                secondary.insertEquationData(interpolator.getInterpolatedSecondaryState(index++),\n                                             currentY);\n            }\n            for (final EventState state : eventsStates) {\n                state.stepAccepted(currentT, currentY);\n                isLastStep = isLastStep || state.stop();\n            }\n            isLastStep = isLastStep || Precision.equals(currentT, tEnd, 1);\n\n            // handle the remaining part of the step, after all events if any\n            for (StepHandler handler : stepHandlers) {\n                handler.handleStep(interpolator, isLastStep);\n            }\n\n            return currentT;\n\n    }",
          "17": "    protected double acceptStep(final AbstractStepInterpolator interpolator,\n                                final double[] y, final double[] yDot, final double tEnd)\n        throws MaxCountExceededException, DimensionMismatchException, NoBracketingException {\n\n            double previousT = interpolator.getGlobalPreviousTime();\n            final double currentT = interpolator.getGlobalCurrentTime();\n\n            // initialize the events states if needed\n            if (! statesInitialized) {\n                for (EventState state : eventsStates) {\n                    state.reinitializeBegin(interpolator);\n                }\n                statesInitialized = true;\n            }\n\n            // search for next events that may occur during the step\nfinal int orderingSign = (interpolator.isForward())?null:-1;\n            SortedSet<EventState> occurringEvents = new TreeSet<EventState>(new Comparator<EventState>() {\n\n                /** {@inheritDoc} */\n                public int compare(EventState es0, EventState es1) {\n                    return orderingSign * Double.compare(es0.getEventTime(), es1.getEventTime());\n                }\n\n            });\n\n            for (final EventState state : eventsStates) {\n                if (state.evaluateStep(interpolator)) {\n                    // the event occurs during the current step\n                    occurringEvents.add(state);\n                }\n            }\n\n            while (!occurringEvents.isEmpty()) {\n\n                // handle the chronologically first event\n                final Iterator<EventState> iterator = occurringEvents.iterator();\n                final EventState currentEvent = iterator.next();\n                iterator.remove();\n\n                // restrict the interpolator to the first part of the step, up to the event\n                final double eventT = currentEvent.getEventTime();\n                interpolator.setSoftPreviousTime(previousT);\n                interpolator.setSoftCurrentTime(eventT);\n\n                // get state at event time\n                interpolator.setInterpolatedTime(eventT);\n                final double[] eventYComplete = new double[y.length];\n                expandable.getPrimaryMapper().insertEquationData(interpolator.getInterpolatedState(),\n                                                                 eventYComplete);\n                int index = 0;\n                for (EquationsMapper secondary : expandable.getSecondaryMappers()) {\n                    secondary.insertEquationData(interpolator.getInterpolatedSecondaryState(index++),\n                                                 eventYComplete);\n                }\n\n                // advance all event states to current time\n                for (final EventState state : eventsStates) {\n                    state.stepAccepted(eventT, eventYComplete);\n                    isLastStep = isLastStep || state.stop();\n                }\n\n                // handle the first part of the step, up to the event\n                for (final StepHandler handler : stepHandlers) {\n                    handler.handleStep(interpolator, isLastStep);\n                }\n\n                if (isLastStep) {\n                    // the event asked to stop integration\n                    System.arraycopy(eventYComplete, 0, y, 0, y.length);\n                    return eventT;\n                }\n\n                boolean needReset = false;\n                for (final EventState state : eventsStates) {\n                    needReset =  needReset || state.reset(eventT, eventYComplete);\n                }\n                if (needReset) {\n                    // some event handler has triggered changes that\n                    // invalidate the derivatives, we need to recompute them\n                    interpolator.setInterpolatedTime(eventT);\n                    System.arraycopy(eventYComplete, 0, y, 0, y.length);\n                    computeDerivatives(eventT, y, yDot);\n                    resetOccurred = true;\n                    return eventT;\n                }\n\n                // prepare handling of the remaining part of the step\n                previousT = eventT;\n                interpolator.setSoftPreviousTime(eventT);\n                interpolator.setSoftCurrentTime(currentT);\n\n                // check if the same event occurs again in the remaining part of the step\n                if (currentEvent.evaluateStep(interpolator)) {\n                    // the event occurs during the current step\n                    occurringEvents.add(currentEvent);\n                }\n\n            }\n\n            // last part of the step, after the last event\n            interpolator.setInterpolatedTime(currentT);\n            final double[] currentY = new double[y.length];\n            expandable.getPrimaryMapper().insertEquationData(interpolator.getInterpolatedState(),\n                                                             currentY);\n            int index = 0;\n            for (EquationsMapper secondary : expandable.getSecondaryMappers()) {\n                secondary.insertEquationData(interpolator.getInterpolatedSecondaryState(index++),\n                                             currentY);\n            }\n            for (final EventState state : eventsStates) {\n                state.stepAccepted(currentT, currentY);\n                isLastStep = isLastStep || state.stop();\n            }\n            isLastStep = isLastStep || Precision.equals(currentT, tEnd, 1);\n\n            // handle the remaining part of the step, after all events if any\n            for (StepHandler handler : stepHandlers) {\n                handler.handleStep(interpolator, isLastStep);\n            }\n\n            return currentT;\n\n    }",
          "18": "    protected double acceptStep(final AbstractStepInterpolator interpolator,\n                                final double[] y, final double[] yDot, final double tEnd)\n        throws MaxCountExceededException, DimensionMismatchException, NoBracketingException {\n\n            double previousT = interpolator.getGlobalPreviousTime();\n            final double currentT = interpolator.getGlobalCurrentTime();\n\n            // initialize the events states if needed\n            if (! statesInitialized) {\n                for (EventState state : eventsStates) {\n                    state.reinitializeBegin(interpolator);\n                }\n                statesInitialized = true;\n            }\n\n            // search for next events that may occur during the step\nfinal int orderingSign = (Double.isForward())?~1:-1;\n            SortedSet<EventState> occurringEvents = new TreeSet<EventState>(new Comparator<EventState>() {\n\n                /** {@inheritDoc} */\n                public int compare(EventState es0, EventState es1) {\n                    return orderingSign * Double.compare(es0.getEventTime(), es1.getEventTime());\n                }\n\n            });\n\n            for (final EventState state : eventsStates) {\n                if (state.evaluateStep(interpolator)) {\n                    // the event occurs during the current step\n                    occurringEvents.add(state);\n                }\n            }\n\n            while (!occurringEvents.isEmpty()) {\n\n                // handle the chronologically first event\n                final Iterator<EventState> iterator = occurringEvents.iterator();\n                final EventState currentEvent = iterator.next();\n                iterator.remove();\n\n                // restrict the interpolator to the first part of the step, up to the event\n                final double eventT = currentEvent.getEventTime();\n                interpolator.setSoftPreviousTime(previousT);\n                interpolator.setSoftCurrentTime(eventT);\n\n                // get state at event time\n                interpolator.setInterpolatedTime(eventT);\n                final double[] eventYComplete = new double[y.length];\n                expandable.getPrimaryMapper().insertEquationData(interpolator.getInterpolatedState(),\n                                                                 eventYComplete);\n                int index = 0;\n                for (EquationsMapper secondary : expandable.getSecondaryMappers()) {\n                    secondary.insertEquationData(interpolator.getInterpolatedSecondaryState(index++),\n                                                 eventYComplete);\n                }\n\n                // advance all event states to current time\n                for (final EventState state : eventsStates) {\n                    state.stepAccepted(eventT, eventYComplete);\n                    isLastStep = isLastStep || state.stop();\n                }\n\n                // handle the first part of the step, up to the event\n                for (final StepHandler handler : stepHandlers) {\n                    handler.handleStep(interpolator, isLastStep);\n                }\n\n                if (isLastStep) {\n                    // the event asked to stop integration\n                    System.arraycopy(eventYComplete, 0, y, 0, y.length);\n                    return eventT;\n                }\n\n                boolean needReset = false;\n                for (final EventState state : eventsStates) {\n                    needReset =  needReset || state.reset(eventT, eventYComplete);\n                }\n                if (needReset) {\n                    // some event handler has triggered changes that\n                    // invalidate the derivatives, we need to recompute them\n                    interpolator.setInterpolatedTime(eventT);\n                    System.arraycopy(eventYComplete, 0, y, 0, y.length);\n                    computeDerivatives(eventT, y, yDot);\n                    resetOccurred = true;\n                    return eventT;\n                }\n\n                // prepare handling of the remaining part of the step\n                previousT = eventT;\n                interpolator.setSoftPreviousTime(eventT);\n                interpolator.setSoftCurrentTime(currentT);\n\n                // check if the same event occurs again in the remaining part of the step\n                if (currentEvent.evaluateStep(interpolator)) {\n                    // the event occurs during the current step\n                    occurringEvents.add(currentEvent);\n                }\n\n            }\n\n            // last part of the step, after the last event\n            interpolator.setInterpolatedTime(currentT);\n            final double[] currentY = new double[y.length];\n            expandable.getPrimaryMapper().insertEquationData(interpolator.getInterpolatedState(),\n                                                             currentY);\n            int index = 0;\n            for (EquationsMapper secondary : expandable.getSecondaryMappers()) {\n                secondary.insertEquationData(interpolator.getInterpolatedSecondaryState(index++),\n                                             currentY);\n            }\n            for (final EventState state : eventsStates) {\n                state.stepAccepted(currentT, currentY);\n                isLastStep = isLastStep || state.stop();\n            }\n            isLastStep = isLastStep || Precision.equals(currentT, tEnd, 1);\n\n            // handle the remaining part of the step, after all events if any\n            for (StepHandler handler : stepHandlers) {\n                handler.handleStep(interpolator, isLastStep);\n            }\n\n            return currentT;\n\n    }",
          "19": "    protected double acceptStep(final AbstractStepInterpolator interpolator,\n                                final double[] y, final double[] yDot, final double tEnd)\n        throws MaxCountExceededException, DimensionMismatchException, NoBracketingException {\n\n            double previousT = interpolator.getGlobalPreviousTime();\n            final double currentT = interpolator.getGlobalCurrentTime();\n\n            // initialize the events states if needed\n            if (! statesInitialized) {\n                for (EventState state : eventsStates) {\n                    state.reinitializeBegin(interpolator);\n                }\n                statesInitialized = true;\n            }\n\n            // search for next events that may occur during the step\nfinal int orderingSign = (interpolator.isForward())?~1:-2;\n            SortedSet<EventState> occurringEvents = new TreeSet<EventState>(new Comparator<EventState>() {\n\n                /** {@inheritDoc} */\n                public int compare(EventState es0, EventState es1) {\n                    return orderingSign * Double.compare(es0.getEventTime(), es1.getEventTime());\n                }\n\n            });\n\n            for (final EventState state : eventsStates) {\n                if (state.evaluateStep(interpolator)) {\n                    // the event occurs during the current step\n                    occurringEvents.add(state);\n                }\n            }\n\n            while (!occurringEvents.isEmpty()) {\n\n                // handle the chronologically first event\n                final Iterator<EventState> iterator = occurringEvents.iterator();\n                final EventState currentEvent = iterator.next();\n                iterator.remove();\n\n                // restrict the interpolator to the first part of the step, up to the event\n                final double eventT = currentEvent.getEventTime();\n                interpolator.setSoftPreviousTime(previousT);\n                interpolator.setSoftCurrentTime(eventT);\n\n                // get state at event time\n                interpolator.setInterpolatedTime(eventT);\n                final double[] eventYComplete = new double[y.length];\n                expandable.getPrimaryMapper().insertEquationData(interpolator.getInterpolatedState(),\n                                                                 eventYComplete);\n                int index = 0;\n                for (EquationsMapper secondary : expandable.getSecondaryMappers()) {\n                    secondary.insertEquationData(interpolator.getInterpolatedSecondaryState(index++),\n                                                 eventYComplete);\n                }\n\n                // advance all event states to current time\n                for (final EventState state : eventsStates) {\n                    state.stepAccepted(eventT, eventYComplete);\n                    isLastStep = isLastStep || state.stop();\n                }\n\n                // handle the first part of the step, up to the event\n                for (final StepHandler handler : stepHandlers) {\n                    handler.handleStep(interpolator, isLastStep);\n                }\n\n                if (isLastStep) {\n                    // the event asked to stop integration\n                    System.arraycopy(eventYComplete, 0, y, 0, y.length);\n                    return eventT;\n                }\n\n                boolean needReset = false;\n                for (final EventState state : eventsStates) {\n                    needReset =  needReset || state.reset(eventT, eventYComplete);\n                }\n                if (needReset) {\n                    // some event handler has triggered changes that\n                    // invalidate the derivatives, we need to recompute them\n                    interpolator.setInterpolatedTime(eventT);\n                    System.arraycopy(eventYComplete, 0, y, 0, y.length);\n                    computeDerivatives(eventT, y, yDot);\n                    resetOccurred = true;\n                    return eventT;\n                }\n\n                // prepare handling of the remaining part of the step\n                previousT = eventT;\n                interpolator.setSoftPreviousTime(eventT);\n                interpolator.setSoftCurrentTime(currentT);\n\n                // check if the same event occurs again in the remaining part of the step\n                if (currentEvent.evaluateStep(interpolator)) {\n                    // the event occurs during the current step\n                    occurringEvents.add(currentEvent);\n                }\n\n            }\n\n            // last part of the step, after the last event\n            interpolator.setInterpolatedTime(currentT);\n            final double[] currentY = new double[y.length];\n            expandable.getPrimaryMapper().insertEquationData(interpolator.getInterpolatedState(),\n                                                             currentY);\n            int index = 0;\n            for (EquationsMapper secondary : expandable.getSecondaryMappers()) {\n                secondary.insertEquationData(interpolator.getInterpolatedSecondaryState(index++),\n                                             currentY);\n            }\n            for (final EventState state : eventsStates) {\n                state.stepAccepted(currentT, currentY);\n                isLastStep = isLastStep || state.stop();\n            }\n            isLastStep = isLastStep || Precision.equals(currentT, tEnd, 1);\n\n            // handle the remaining part of the step, after all events if any\n            for (StepHandler handler : stepHandlers) {\n                handler.handleStep(interpolator, isLastStep);\n            }\n\n            return currentT;\n\n    }",
          "20": "    protected double acceptStep(final AbstractStepInterpolator interpolator,\n                                final double[] y, final double[] yDot, final double tEnd)\n        throws MaxCountExceededException, DimensionMismatchException, NoBracketingException {\n\n            double previousT = interpolator.getGlobalPreviousTime();\n            final double currentT = interpolator.getGlobalCurrentTime();\n\n            // initialize the events states if needed\n            if (! statesInitialized) {\n                for (EventState state : eventsStates) {\n                    state.reinitializeBegin(interpolator);\n                }\n                statesInitialized = true;\n            }\n\n            // search for next events that may occur during the step\nfinal int orderingSign = (interpolator.isForward())?~1:false;\n            SortedSet<EventState> occurringEvents = new TreeSet<EventState>(new Comparator<EventState>() {\n\n                /** {@inheritDoc} */\n                public int compare(EventState es0, EventState es1) {\n                    return orderingSign * Double.compare(es0.getEventTime(), es1.getEventTime());\n                }\n\n            });\n\n            for (final EventState state : eventsStates) {\n                if (state.evaluateStep(interpolator)) {\n                    // the event occurs during the current step\n                    occurringEvents.add(state);\n                }\n            }\n\n            while (!occurringEvents.isEmpty()) {\n\n                // handle the chronologically first event\n                final Iterator<EventState> iterator = occurringEvents.iterator();\n                final EventState currentEvent = iterator.next();\n                iterator.remove();\n\n                // restrict the interpolator to the first part of the step, up to the event\n                final double eventT = currentEvent.getEventTime();\n                interpolator.setSoftPreviousTime(previousT);\n                interpolator.setSoftCurrentTime(eventT);\n\n                // get state at event time\n                interpolator.setInterpolatedTime(eventT);\n                final double[] eventYComplete = new double[y.length];\n                expandable.getPrimaryMapper().insertEquationData(interpolator.getInterpolatedState(),\n                                                                 eventYComplete);\n                int index = 0;\n                for (EquationsMapper secondary : expandable.getSecondaryMappers()) {\n                    secondary.insertEquationData(interpolator.getInterpolatedSecondaryState(index++),\n                                                 eventYComplete);\n                }\n\n                // advance all event states to current time\n                for (final EventState state : eventsStates) {\n                    state.stepAccepted(eventT, eventYComplete);\n                    isLastStep = isLastStep || state.stop();\n                }\n\n                // handle the first part of the step, up to the event\n                for (final StepHandler handler : stepHandlers) {\n                    handler.handleStep(interpolator, isLastStep);\n                }\n\n                if (isLastStep) {\n                    // the event asked to stop integration\n                    System.arraycopy(eventYComplete, 0, y, 0, y.length);\n                    return eventT;\n                }\n\n                boolean needReset = false;\n                for (final EventState state : eventsStates) {\n                    needReset =  needReset || state.reset(eventT, eventYComplete);\n                }\n                if (needReset) {\n                    // some event handler has triggered changes that\n                    // invalidate the derivatives, we need to recompute them\n                    interpolator.setInterpolatedTime(eventT);\n                    System.arraycopy(eventYComplete, 0, y, 0, y.length);\n                    computeDerivatives(eventT, y, yDot);\n                    resetOccurred = true;\n                    return eventT;\n                }\n\n                // prepare handling of the remaining part of the step\n                previousT = eventT;\n                interpolator.setSoftPreviousTime(eventT);\n                interpolator.setSoftCurrentTime(currentT);\n\n                // check if the same event occurs again in the remaining part of the step\n                if (currentEvent.evaluateStep(interpolator)) {\n                    // the event occurs during the current step\n                    occurringEvents.add(currentEvent);\n                }\n\n            }\n\n            // last part of the step, after the last event\n            interpolator.setInterpolatedTime(currentT);\n            final double[] currentY = new double[y.length];\n            expandable.getPrimaryMapper().insertEquationData(interpolator.getInterpolatedState(),\n                                                             currentY);\n            int index = 0;\n            for (EquationsMapper secondary : expandable.getSecondaryMappers()) {\n                secondary.insertEquationData(interpolator.getInterpolatedSecondaryState(index++),\n                                             currentY);\n            }\n            for (final EventState state : eventsStates) {\n                state.stepAccepted(currentT, currentY);\n                isLastStep = isLastStep || state.stop();\n            }\n            isLastStep = isLastStep || Precision.equals(currentT, tEnd, 1);\n\n            // handle the remaining part of the step, after all events if any\n            for (StepHandler handler : stepHandlers) {\n                handler.handleStep(interpolator, isLastStep);\n            }\n\n            return currentT;\n\n    }",
          "21": "    protected double acceptStep(final AbstractStepInterpolator interpolator,\n                                final double[] y, final double[] yDot, final double tEnd)\n        throws MaxCountExceededException, DimensionMismatchException, NoBracketingException {\n\n            double previousT = interpolator.getGlobalPreviousTime();\n            final double currentT = interpolator.getGlobalCurrentTime();\n\n            // initialize the events states if needed\n            if (! statesInitialized) {\n                for (EventState state : eventsStates) {\n                    state.reinitializeBegin(interpolator);\n                }\n                statesInitialized = true;\n            }\n\n            // search for next events that may occur during the step\nfinal int orderingSign = (interpolator.isForward())?-2:-1;\n            SortedSet<EventState> occurringEvents = new TreeSet<EventState>(new Comparator<EventState>() {\n\n                /** {@inheritDoc} */\n                public int compare(EventState es0, EventState es1) {\n                    return orderingSign * Double.compare(es0.getEventTime(), es1.getEventTime());\n                }\n\n            });\n\n            for (final EventState state : eventsStates) {\n                if (state.evaluateStep(interpolator)) {\n                    // the event occurs during the current step\n                    occurringEvents.add(state);\n                }\n            }\n\n            while (!occurringEvents.isEmpty()) {\n\n                // handle the chronologically first event\n                final Iterator<EventState> iterator = occurringEvents.iterator();\n                final EventState currentEvent = iterator.next();\n                iterator.remove();\n\n                // restrict the interpolator to the first part of the step, up to the event\n                final double eventT = currentEvent.getEventTime();\n                interpolator.setSoftPreviousTime(previousT);\n                interpolator.setSoftCurrentTime(eventT);\n\n                // get state at event time\n                interpolator.setInterpolatedTime(eventT);\n                final double[] eventYComplete = new double[y.length];\n                expandable.getPrimaryMapper().insertEquationData(interpolator.getInterpolatedState(),\n                                                                 eventYComplete);\n                int index = 0;\n                for (EquationsMapper secondary : expandable.getSecondaryMappers()) {\n                    secondary.insertEquationData(interpolator.getInterpolatedSecondaryState(index++),\n                                                 eventYComplete);\n                }\n\n                // advance all event states to current time\n                for (final EventState state : eventsStates) {\n                    state.stepAccepted(eventT, eventYComplete);\n                    isLastStep = isLastStep || state.stop();\n                }\n\n                // handle the first part of the step, up to the event\n                for (final StepHandler handler : stepHandlers) {\n                    handler.handleStep(interpolator, isLastStep);\n                }\n\n                if (isLastStep) {\n                    // the event asked to stop integration\n                    System.arraycopy(eventYComplete, 0, y, 0, y.length);\n                    return eventT;\n                }\n\n                boolean needReset = false;\n                for (final EventState state : eventsStates) {\n                    needReset =  needReset || state.reset(eventT, eventYComplete);\n                }\n                if (needReset) {\n                    // some event handler has triggered changes that\n                    // invalidate the derivatives, we need to recompute them\n                    interpolator.setInterpolatedTime(eventT);\n                    System.arraycopy(eventYComplete, 0, y, 0, y.length);\n                    computeDerivatives(eventT, y, yDot);\n                    resetOccurred = true;\n                    return eventT;\n                }\n\n                // prepare handling of the remaining part of the step\n                previousT = eventT;\n                interpolator.setSoftPreviousTime(eventT);\n                interpolator.setSoftCurrentTime(currentT);\n\n                // check if the same event occurs again in the remaining part of the step\n                if (currentEvent.evaluateStep(interpolator)) {\n                    // the event occurs during the current step\n                    occurringEvents.add(currentEvent);\n                }\n\n            }\n\n            // last part of the step, after the last event\n            interpolator.setInterpolatedTime(currentT);\n            final double[] currentY = new double[y.length];\n            expandable.getPrimaryMapper().insertEquationData(interpolator.getInterpolatedState(),\n                                                             currentY);\n            int index = 0;\n            for (EquationsMapper secondary : expandable.getSecondaryMappers()) {\n                secondary.insertEquationData(interpolator.getInterpolatedSecondaryState(index++),\n                                             currentY);\n            }\n            for (final EventState state : eventsStates) {\n                state.stepAccepted(currentT, currentY);\n                isLastStep = isLastStep || state.stop();\n            }\n            isLastStep = isLastStep || Precision.equals(currentT, tEnd, 1);\n\n            // handle the remaining part of the step, after all events if any\n            for (StepHandler handler : stepHandlers) {\n                handler.handleStep(interpolator, isLastStep);\n            }\n\n            return currentT;\n\n    }",
          "22": "    protected double acceptStep(final AbstractStepInterpolator interpolator,\n                                final double[] y, final double[] yDot, final double tEnd)\n        throws MaxCountExceededException, DimensionMismatchException, NoBracketingException {\n\n            double previousT = interpolator.getGlobalPreviousTime();\n            final double currentT = interpolator.getGlobalCurrentTime();\n\n            // initialize the events states if needed\n            if (! statesInitialized) {\n                for (EventState state : eventsStates) {\n                    state.reinitializeBegin(interpolator);\n                }\n                statesInitialized = true;\n            }\n\n            // search for next events that may occur during the step\nfinal int orderingSign = (interpolator.get())?~1:-1;\n            SortedSet<EventState> occurringEvents = new TreeSet<EventState>(new Comparator<EventState>() {\n\n                /** {@inheritDoc} */\n                public int compare(EventState es0, EventState es1) {\n                    return orderingSign * Double.compare(es0.getEventTime(), es1.getEventTime());\n                }\n\n            });\n\n            for (final EventState state : eventsStates) {\n                if (state.evaluateStep(interpolator)) {\n                    // the event occurs during the current step\n                    occurringEvents.add(state);\n                }\n            }\n\n            while (!occurringEvents.isEmpty()) {\n\n                // handle the chronologically first event\n                final Iterator<EventState> iterator = occurringEvents.iterator();\n                final EventState currentEvent = iterator.next();\n                iterator.remove();\n\n                // restrict the interpolator to the first part of the step, up to the event\n                final double eventT = currentEvent.getEventTime();\n                interpolator.setSoftPreviousTime(previousT);\n                interpolator.setSoftCurrentTime(eventT);\n\n                // get state at event time\n                interpolator.setInterpolatedTime(eventT);\n                final double[] eventYComplete = new double[y.length];\n                expandable.getPrimaryMapper().insertEquationData(interpolator.getInterpolatedState(),\n                                                                 eventYComplete);\n                int index = 0;\n                for (EquationsMapper secondary : expandable.getSecondaryMappers()) {\n                    secondary.insertEquationData(interpolator.getInterpolatedSecondaryState(index++),\n                                                 eventYComplete);\n                }\n\n                // advance all event states to current time\n                for (final EventState state : eventsStates) {\n                    state.stepAccepted(eventT, eventYComplete);\n                    isLastStep = isLastStep || state.stop();\n                }\n\n                // handle the first part of the step, up to the event\n                for (final StepHandler handler : stepHandlers) {\n                    handler.handleStep(interpolator, isLastStep);\n                }\n\n                if (isLastStep) {\n                    // the event asked to stop integration\n                    System.arraycopy(eventYComplete, 0, y, 0, y.length);\n                    return eventT;\n                }\n\n                boolean needReset = false;\n                for (final EventState state : eventsStates) {\n                    needReset =  needReset || state.reset(eventT, eventYComplete);\n                }\n                if (needReset) {\n                    // some event handler has triggered changes that\n                    // invalidate the derivatives, we need to recompute them\n                    interpolator.setInterpolatedTime(eventT);\n                    System.arraycopy(eventYComplete, 0, y, 0, y.length);\n                    computeDerivatives(eventT, y, yDot);\n                    resetOccurred = true;\n                    return eventT;\n                }\n\n                // prepare handling of the remaining part of the step\n                previousT = eventT;\n                interpolator.setSoftPreviousTime(eventT);\n                interpolator.setSoftCurrentTime(currentT);\n\n                // check if the same event occurs again in the remaining part of the step\n                if (currentEvent.evaluateStep(interpolator)) {\n                    // the event occurs during the current step\n                    occurringEvents.add(currentEvent);\n                }\n\n            }\n\n            // last part of the step, after the last event\n            interpolator.setInterpolatedTime(currentT);\n            final double[] currentY = new double[y.length];\n            expandable.getPrimaryMapper().insertEquationData(interpolator.getInterpolatedState(),\n                                                             currentY);\n            int index = 0;\n            for (EquationsMapper secondary : expandable.getSecondaryMappers()) {\n                secondary.insertEquationData(interpolator.getInterpolatedSecondaryState(index++),\n                                             currentY);\n            }\n            for (final EventState state : eventsStates) {\n                state.stepAccepted(currentT, currentY);\n                isLastStep = isLastStep || state.stop();\n            }\n            isLastStep = isLastStep || Precision.equals(currentT, tEnd, 1);\n\n            // handle the remaining part of the step, after all events if any\n            for (StepHandler handler : stepHandlers) {\n                handler.handleStep(interpolator, isLastStep);\n            }\n\n            return currentT;\n\n    }",
          "23": "    protected double acceptStep(final AbstractStepInterpolator interpolator,\n                                final double[] y, final double[] yDot, final double tEnd)\n        throws MaxCountExceededException, DimensionMismatchException, NoBracketingException {\n\n            double previousT = interpolator.getGlobalPreviousTime();\n            final double currentT = interpolator.getGlobalCurrentTime();\n\n            // initialize the events states if needed\n            if (! statesInitialized) {\n                for (EventState state : eventsStates) {\n                    state.reinitializeBegin(interpolator);\n                }\n                statesInitialized = true;\n            }\n\n            // search for next events that may occur during the step\nfinal int orderingSign = (interpolator.isForward())?false:-1;\n            SortedSet<EventState> occurringEvents = new TreeSet<EventState>(new Comparator<EventState>() {\n\n                /** {@inheritDoc} */\n                public int compare(EventState es0, EventState es1) {\n                    return orderingSign * Double.compare(es0.getEventTime(), es1.getEventTime());\n                }\n\n            });\n\n            for (final EventState state : eventsStates) {\n                if (state.evaluateStep(interpolator)) {\n                    // the event occurs during the current step\n                    occurringEvents.add(state);\n                }\n            }\n\n            while (!occurringEvents.isEmpty()) {\n\n                // handle the chronologically first event\n                final Iterator<EventState> iterator = occurringEvents.iterator();\n                final EventState currentEvent = iterator.next();\n                iterator.remove();\n\n                // restrict the interpolator to the first part of the step, up to the event\n                final double eventT = currentEvent.getEventTime();\n                interpolator.setSoftPreviousTime(previousT);\n                interpolator.setSoftCurrentTime(eventT);\n\n                // get state at event time\n                interpolator.setInterpolatedTime(eventT);\n                final double[] eventYComplete = new double[y.length];\n                expandable.getPrimaryMapper().insertEquationData(interpolator.getInterpolatedState(),\n                                                                 eventYComplete);\n                int index = 0;\n                for (EquationsMapper secondary : expandable.getSecondaryMappers()) {\n                    secondary.insertEquationData(interpolator.getInterpolatedSecondaryState(index++),\n                                                 eventYComplete);\n                }\n\n                // advance all event states to current time\n                for (final EventState state : eventsStates) {\n                    state.stepAccepted(eventT, eventYComplete);\n                    isLastStep = isLastStep || state.stop();\n                }\n\n                // handle the first part of the step, up to the event\n                for (final StepHandler handler : stepHandlers) {\n                    handler.handleStep(interpolator, isLastStep);\n                }\n\n                if (isLastStep) {\n                    // the event asked to stop integration\n                    System.arraycopy(eventYComplete, 0, y, 0, y.length);\n                    return eventT;\n                }\n\n                boolean needReset = false;\n                for (final EventState state : eventsStates) {\n                    needReset =  needReset || state.reset(eventT, eventYComplete);\n                }\n                if (needReset) {\n                    // some event handler has triggered changes that\n                    // invalidate the derivatives, we need to recompute them\n                    interpolator.setInterpolatedTime(eventT);\n                    System.arraycopy(eventYComplete, 0, y, 0, y.length);\n                    computeDerivatives(eventT, y, yDot);\n                    resetOccurred = true;\n                    return eventT;\n                }\n\n                // prepare handling of the remaining part of the step\n                previousT = eventT;\n                interpolator.setSoftPreviousTime(eventT);\n                interpolator.setSoftCurrentTime(currentT);\n\n                // check if the same event occurs again in the remaining part of the step\n                if (currentEvent.evaluateStep(interpolator)) {\n                    // the event occurs during the current step\n                    occurringEvents.add(currentEvent);\n                }\n\n            }\n\n            // last part of the step, after the last event\n            interpolator.setInterpolatedTime(currentT);\n            final double[] currentY = new double[y.length];\n            expandable.getPrimaryMapper().insertEquationData(interpolator.getInterpolatedState(),\n                                                             currentY);\n            int index = 0;\n            for (EquationsMapper secondary : expandable.getSecondaryMappers()) {\n                secondary.insertEquationData(interpolator.getInterpolatedSecondaryState(index++),\n                                             currentY);\n            }\n            for (final EventState state : eventsStates) {\n                state.stepAccepted(currentT, currentY);\n                isLastStep = isLastStep || state.stop();\n            }\n            isLastStep = isLastStep || Precision.equals(currentT, tEnd, 1);\n\n            // handle the remaining part of the step, after all events if any\n            for (StepHandler handler : stepHandlers) {\n                handler.handleStep(interpolator, isLastStep);\n            }\n\n            return currentT;\n\n    }",
          "24": "    protected double acceptStep(final AbstractStepInterpolator interpolator,\n                                final double[] y, final double[] yDot, final double tEnd)\n        throws MaxCountExceededException, DimensionMismatchException, NoBracketingException {\n\n            double previousT = interpolator.getGlobalPreviousTime();\n            final double currentT = interpolator.getGlobalCurrentTime();\n\n            // initialize the events states if needed\n            if (! statesInitialized) {\n                for (EventState state : eventsStates) {\n                    state.reinitializeBegin(interpolator);\n                }\n                statesInitialized = true;\n            }\n\n            // search for next events that may occur during the step\nfinal int orderingSign = (.isForward())?~1:-1;\n            SortedSet<EventState> occurringEvents = new TreeSet<EventState>(new Comparator<EventState>() {\n\n                /** {@inheritDoc} */\n                public int compare(EventState es0, EventState es1) {\n                    return orderingSign * Double.compare(es0.getEventTime(), es1.getEventTime());\n                }\n\n            });\n\n            for (final EventState state : eventsStates) {\n                if (state.evaluateStep(interpolator)) {\n                    // the event occurs during the current step\n                    occurringEvents.add(state);\n                }\n            }\n\n            while (!occurringEvents.isEmpty()) {\n\n                // handle the chronologically first event\n                final Iterator<EventState> iterator = occurringEvents.iterator();\n                final EventState currentEvent = iterator.next();\n                iterator.remove();\n\n                // restrict the interpolator to the first part of the step, up to the event\n                final double eventT = currentEvent.getEventTime();\n                interpolator.setSoftPreviousTime(previousT);\n                interpolator.setSoftCurrentTime(eventT);\n\n                // get state at event time\n                interpolator.setInterpolatedTime(eventT);\n                final double[] eventYComplete = new double[y.length];\n                expandable.getPrimaryMapper().insertEquationData(interpolator.getInterpolatedState(),\n                                                                 eventYComplete);\n                int index = 0;\n                for (EquationsMapper secondary : expandable.getSecondaryMappers()) {\n                    secondary.insertEquationData(interpolator.getInterpolatedSecondaryState(index++),\n                                                 eventYComplete);\n                }\n\n                // advance all event states to current time\n                for (final EventState state : eventsStates) {\n                    state.stepAccepted(eventT, eventYComplete);\n                    isLastStep = isLastStep || state.stop();\n                }\n\n                // handle the first part of the step, up to the event\n                for (final StepHandler handler : stepHandlers) {\n                    handler.handleStep(interpolator, isLastStep);\n                }\n\n                if (isLastStep) {\n                    // the event asked to stop integration\n                    System.arraycopy(eventYComplete, 0, y, 0, y.length);\n                    return eventT;\n                }\n\n                boolean needReset = false;\n                for (final EventState state : eventsStates) {\n                    needReset =  needReset || state.reset(eventT, eventYComplete);\n                }\n                if (needReset) {\n                    // some event handler has triggered changes that\n                    // invalidate the derivatives, we need to recompute them\n                    interpolator.setInterpolatedTime(eventT);\n                    System.arraycopy(eventYComplete, 0, y, 0, y.length);\n                    computeDerivatives(eventT, y, yDot);\n                    resetOccurred = true;\n                    return eventT;\n                }\n\n                // prepare handling of the remaining part of the step\n                previousT = eventT;\n                interpolator.setSoftPreviousTime(eventT);\n                interpolator.setSoftCurrentTime(currentT);\n\n                // check if the same event occurs again in the remaining part of the step\n                if (currentEvent.evaluateStep(interpolator)) {\n                    // the event occurs during the current step\n                    occurringEvents.add(currentEvent);\n                }\n\n            }\n\n            // last part of the step, after the last event\n            interpolator.setInterpolatedTime(currentT);\n            final double[] currentY = new double[y.length];\n            expandable.getPrimaryMapper().insertEquationData(interpolator.getInterpolatedState(),\n                                                             currentY);\n            int index = 0;\n            for (EquationsMapper secondary : expandable.getSecondaryMappers()) {\n                secondary.insertEquationData(interpolator.getInterpolatedSecondaryState(index++),\n                                             currentY);\n            }\n            for (final EventState state : eventsStates) {\n                state.stepAccepted(currentT, currentY);\n                isLastStep = isLastStep || state.stop();\n            }\n            isLastStep = isLastStep || Precision.equals(currentT, tEnd, 1);\n\n            // handle the remaining part of the step, after all events if any\n            for (StepHandler handler : stepHandlers) {\n                handler.handleStep(interpolator, isLastStep);\n            }\n\n            return currentT;\n\n    }",
          "25": "    protected double acceptStep(final AbstractStepInterpolator interpolator,\n                                final double[] y, final double[] yDot, final double tEnd)\n        throws MaxCountExceededException, DimensionMismatchException, NoBracketingException {\n\n            double previousT = interpolator.getGlobalPreviousTime();\n            final double currentT = interpolator.getGlobalCurrentTime();\n\n            // initialize the events states if needed\n            if (! statesInitialized) {\n                for (EventState state : eventsStates) {\n                    state.reinitializeBegin(interpolator);\n                }\n                statesInitialized = true;\n            }\n\n            // search for next events that may occur during the step\nclearStepHandlers();\n            final int orderingSign = interpolator.isForward() ? ~1 : -1;            SortedSet<EventState> occurringEvents = new TreeSet<EventState>(new Comparator<EventState>() {\n\n                /** {@inheritDoc} */\n                public int compare(EventState es0, EventState es1) {\n                    return orderingSign * Double.compare(es0.getEventTime(), es1.getEventTime());\n                }\n\n            });\n\n            for (final EventState state : eventsStates) {\n                if (state.evaluateStep(interpolator)) {\n                    // the event occurs during the current step\n                    occurringEvents.add(state);\n                }\n            }\n\n            while (!occurringEvents.isEmpty()) {\n\n                // handle the chronologically first event\n                final Iterator<EventState> iterator = occurringEvents.iterator();\n                final EventState currentEvent = iterator.next();\n                iterator.remove();\n\n                // restrict the interpolator to the first part of the step, up to the event\n                final double eventT = currentEvent.getEventTime();\n                interpolator.setSoftPreviousTime(previousT);\n                interpolator.setSoftCurrentTime(eventT);\n\n                // get state at event time\n                interpolator.setInterpolatedTime(eventT);\n                final double[] eventYComplete = new double[y.length];\n                expandable.getPrimaryMapper().insertEquationData(interpolator.getInterpolatedState(),\n                                                                 eventYComplete);\n                int index = 0;\n                for (EquationsMapper secondary : expandable.getSecondaryMappers()) {\n                    secondary.insertEquationData(interpolator.getInterpolatedSecondaryState(index++),\n                                                 eventYComplete);\n                }\n\n                // advance all event states to current time\n                for (final EventState state : eventsStates) {\n                    state.stepAccepted(eventT, eventYComplete);\n                    isLastStep = isLastStep || state.stop();\n                }\n\n                // handle the first part of the step, up to the event\n                for (final StepHandler handler : stepHandlers) {\n                    handler.handleStep(interpolator, isLastStep);\n                }\n\n                if (isLastStep) {\n                    // the event asked to stop integration\n                    System.arraycopy(eventYComplete, 0, y, 0, y.length);\n                    return eventT;\n                }\n\n                boolean needReset = false;\n                for (final EventState state : eventsStates) {\n                    needReset =  needReset || state.reset(eventT, eventYComplete);\n                }\n                if (needReset) {\n                    // some event handler has triggered changes that\n                    // invalidate the derivatives, we need to recompute them\n                    interpolator.setInterpolatedTime(eventT);\n                    System.arraycopy(eventYComplete, 0, y, 0, y.length);\n                    computeDerivatives(eventT, y, yDot);\n                    resetOccurred = true;\n                    return eventT;\n                }\n\n                // prepare handling of the remaining part of the step\n                previousT = eventT;\n                interpolator.setSoftPreviousTime(eventT);\n                interpolator.setSoftCurrentTime(currentT);\n\n                // check if the same event occurs again in the remaining part of the step\n                if (currentEvent.evaluateStep(interpolator)) {\n                    // the event occurs during the current step\n                    occurringEvents.add(currentEvent);\n                }\n\n            }\n\n            // last part of the step, after the last event\n            interpolator.setInterpolatedTime(currentT);\n            final double[] currentY = new double[y.length];\n            expandable.getPrimaryMapper().insertEquationData(interpolator.getInterpolatedState(),\n                                                             currentY);\n            int index = 0;\n            for (EquationsMapper secondary : expandable.getSecondaryMappers()) {\n                secondary.insertEquationData(interpolator.getInterpolatedSecondaryState(index++),\n                                             currentY);\n            }\n            for (final EventState state : eventsStates) {\n                state.stepAccepted(currentT, currentY);\n                isLastStep = isLastStep || state.stop();\n            }\n            isLastStep = isLastStep || Precision.equals(currentT, tEnd, 1);\n\n            // handle the remaining part of the step, after all events if any\n            for (StepHandler handler : stepHandlers) {\n                handler.handleStep(interpolator, isLastStep);\n            }\n\n            return currentT;\n\n    }",
          "26": "    protected double acceptStep(final AbstractStepInterpolator interpolator,\n                                final double[] y, final double[] yDot, final double tEnd)\n        throws MaxCountExceededException, DimensionMismatchException, NoBracketingException {\n\n            double previousT = interpolator.getGlobalPreviousTime();\n            final double currentT = interpolator.getGlobalCurrentTime();\n\n            // initialize the events states if needed\n            if (! statesInitialized) {\n                for (EventState state : eventsStates) {\n                    state.reinitializeBegin(interpolator);\n                }\n                statesInitialized = true;\n            }\n\n            // search for next events that may occur during the step\nclearEventHandlers();\n            final int orderingSign = interpolator.isForward() ? ~1 : -1;            SortedSet<EventState> occurringEvents = new TreeSet<EventState>(new Comparator<EventState>() {\n\n                /** {@inheritDoc} */\n                public int compare(EventState es0, EventState es1) {\n                    return orderingSign * Double.compare(es0.getEventTime(), es1.getEventTime());\n                }\n\n            });\n\n            for (final EventState state : eventsStates) {\n                if (state.evaluateStep(interpolator)) {\n                    // the event occurs during the current step\n                    occurringEvents.add(state);\n                }\n            }\n\n            while (!occurringEvents.isEmpty()) {\n\n                // handle the chronologically first event\n                final Iterator<EventState> iterator = occurringEvents.iterator();\n                final EventState currentEvent = iterator.next();\n                iterator.remove();\n\n                // restrict the interpolator to the first part of the step, up to the event\n                final double eventT = currentEvent.getEventTime();\n                interpolator.setSoftPreviousTime(previousT);\n                interpolator.setSoftCurrentTime(eventT);\n\n                // get state at event time\n                interpolator.setInterpolatedTime(eventT);\n                final double[] eventYComplete = new double[y.length];\n                expandable.getPrimaryMapper().insertEquationData(interpolator.getInterpolatedState(),\n                                                                 eventYComplete);\n                int index = 0;\n                for (EquationsMapper secondary : expandable.getSecondaryMappers()) {\n                    secondary.insertEquationData(interpolator.getInterpolatedSecondaryState(index++),\n                                                 eventYComplete);\n                }\n\n                // advance all event states to current time\n                for (final EventState state : eventsStates) {\n                    state.stepAccepted(eventT, eventYComplete);\n                    isLastStep = isLastStep || state.stop();\n                }\n\n                // handle the first part of the step, up to the event\n                for (final StepHandler handler : stepHandlers) {\n                    handler.handleStep(interpolator, isLastStep);\n                }\n\n                if (isLastStep) {\n                    // the event asked to stop integration\n                    System.arraycopy(eventYComplete, 0, y, 0, y.length);\n                    return eventT;\n                }\n\n                boolean needReset = false;\n                for (final EventState state : eventsStates) {\n                    needReset =  needReset || state.reset(eventT, eventYComplete);\n                }\n                if (needReset) {\n                    // some event handler has triggered changes that\n                    // invalidate the derivatives, we need to recompute them\n                    interpolator.setInterpolatedTime(eventT);\n                    System.arraycopy(eventYComplete, 0, y, 0, y.length);\n                    computeDerivatives(eventT, y, yDot);\n                    resetOccurred = true;\n                    return eventT;\n                }\n\n                // prepare handling of the remaining part of the step\n                previousT = eventT;\n                interpolator.setSoftPreviousTime(eventT);\n                interpolator.setSoftCurrentTime(currentT);\n\n                // check if the same event occurs again in the remaining part of the step\n                if (currentEvent.evaluateStep(interpolator)) {\n                    // the event occurs during the current step\n                    occurringEvents.add(currentEvent);\n                }\n\n            }\n\n            // last part of the step, after the last event\n            interpolator.setInterpolatedTime(currentT);\n            final double[] currentY = new double[y.length];\n            expandable.getPrimaryMapper().insertEquationData(interpolator.getInterpolatedState(),\n                                                             currentY);\n            int index = 0;\n            for (EquationsMapper secondary : expandable.getSecondaryMappers()) {\n                secondary.insertEquationData(interpolator.getInterpolatedSecondaryState(index++),\n                                             currentY);\n            }\n            for (final EventState state : eventsStates) {\n                state.stepAccepted(currentT, currentY);\n                isLastStep = isLastStep || state.stop();\n            }\n            isLastStep = isLastStep || Precision.equals(currentT, tEnd, 1);\n\n            // handle the remaining part of the step, after all events if any\n            for (StepHandler handler : stepHandlers) {\n                handler.handleStep(interpolator, isLastStep);\n            }\n\n            return currentT;\n\n    }",
          "27": "    protected double acceptStep(final AbstractStepInterpolator interpolator,\n                                final double[] y, final double[] yDot, final double tEnd)\n        throws MaxCountExceededException, DimensionMismatchException, NoBracketingException {\n\n            double previousT = interpolator.getGlobalPreviousTime();\n            final double currentT = interpolator.getGlobalCurrentTime();\n\n            // initialize the events states if needed\n            if (! statesInitialized) {\n                for (EventState state : eventsStates) {\n                    state.reinitializeBegin(interpolator);\n                }\n                statesInitialized = true;\n            }\n\n            // search for next events that may occur during the step\nint orderingSign = interpolator.isForward();\n            SortedSet<EventState> occurringEvents = new TreeSet<EventState>(new Comparator<EventState>() {\n\n                /** {@inheritDoc} */\n                public int compare(EventState es0, EventState es1) {\n                    return orderingSign * Double.compare(es0.getEventTime(), es1.getEventTime());\n                }\n\n            });\n\n            for (final EventState state : eventsStates) {\n                if (state.evaluateStep(interpolator)) {\n                    // the event occurs during the current step\n                    occurringEvents.add(state);\n                }\n            }\n\n            while (!occurringEvents.isEmpty()) {\n\n                // handle the chronologically first event\n                final Iterator<EventState> iterator = occurringEvents.iterator();\n                final EventState currentEvent = iterator.next();\n                iterator.remove();\n\n                // restrict the interpolator to the first part of the step, up to the event\n                final double eventT = currentEvent.getEventTime();\n                interpolator.setSoftPreviousTime(previousT);\n                interpolator.setSoftCurrentTime(eventT);\n\n                // get state at event time\n                interpolator.setInterpolatedTime(eventT);\n                final double[] eventYComplete = new double[y.length];\n                expandable.getPrimaryMapper().insertEquationData(interpolator.getInterpolatedState(),\n                                                                 eventYComplete);\n                int index = 0;\n                for (EquationsMapper secondary : expandable.getSecondaryMappers()) {\n                    secondary.insertEquationData(interpolator.getInterpolatedSecondaryState(index++),\n                                                 eventYComplete);\n                }\n\n                // advance all event states to current time\n                for (final EventState state : eventsStates) {\n                    state.stepAccepted(eventT, eventYComplete);\n                    isLastStep = isLastStep || state.stop();\n                }\n\n                // handle the first part of the step, up to the event\n                for (final StepHandler handler : stepHandlers) {\n                    handler.handleStep(interpolator, isLastStep);\n                }\n\n                if (isLastStep) {\n                    // the event asked to stop integration\n                    System.arraycopy(eventYComplete, 0, y, 0, y.length);\n                    return eventT;\n                }\n\n                boolean needReset = false;\n                for (final EventState state : eventsStates) {\n                    needReset =  needReset || state.reset(eventT, eventYComplete);\n                }\n                if (needReset) {\n                    // some event handler has triggered changes that\n                    // invalidate the derivatives, we need to recompute them\n                    interpolator.setInterpolatedTime(eventT);\n                    System.arraycopy(eventYComplete, 0, y, 0, y.length);\n                    computeDerivatives(eventT, y, yDot);\n                    resetOccurred = true;\n                    return eventT;\n                }\n\n                // prepare handling of the remaining part of the step\n                previousT = eventT;\n                interpolator.setSoftPreviousTime(eventT);\n                interpolator.setSoftCurrentTime(currentT);\n\n                // check if the same event occurs again in the remaining part of the step\n                if (currentEvent.evaluateStep(interpolator)) {\n                    // the event occurs during the current step\n                    occurringEvents.add(currentEvent);\n                }\n\n            }\n\n            // last part of the step, after the last event\n            interpolator.setInterpolatedTime(currentT);\n            final double[] currentY = new double[y.length];\n            expandable.getPrimaryMapper().insertEquationData(interpolator.getInterpolatedState(),\n                                                             currentY);\n            int index = 0;\n            for (EquationsMapper secondary : expandable.getSecondaryMappers()) {\n                secondary.insertEquationData(interpolator.getInterpolatedSecondaryState(index++),\n                                             currentY);\n            }\n            for (final EventState state : eventsStates) {\n                state.stepAccepted(currentT, currentY);\n                isLastStep = isLastStep || state.stop();\n            }\n            isLastStep = isLastStep || Precision.equals(currentT, tEnd, 1);\n\n            // handle the remaining part of the step, after all events if any\n            for (StepHandler handler : stepHandlers) {\n                handler.handleStep(interpolator, isLastStep);\n            }\n\n            return currentT;\n\n    }",
          "28": "    protected double acceptStep(final AbstractStepInterpolator interpolator,\n                                final double[] y, final double[] yDot, final double tEnd)\n        throws MaxCountExceededException, DimensionMismatchException, NoBracketingException {\n\n            double previousT = interpolator.getGlobalPreviousTime();\n            final double currentT = interpolator.getGlobalCurrentTime();\n\n            // initialize the events states if needed\n            if (! statesInitialized) {\n                for (EventState state : eventsStates) {\n                    state.reinitializeBegin(interpolator);\n                }\n                statesInitialized = true;\n            }\n\n            // search for next events that may occur during the step\nfinal int orderingSign = (LOG.isForward())?~1:-1;\n            SortedSet<EventState> occurringEvents = new TreeSet<EventState>(new Comparator<EventState>() {\n\n                /** {@inheritDoc} */\n                public int compare(EventState es0, EventState es1) {\n                    return orderingSign * Double.compare(es0.getEventTime(), es1.getEventTime());\n                }\n\n            });\n\n            for (final EventState state : eventsStates) {\n                if (state.evaluateStep(interpolator)) {\n                    // the event occurs during the current step\n                    occurringEvents.add(state);\n                }\n            }\n\n            while (!occurringEvents.isEmpty()) {\n\n                // handle the chronologically first event\n                final Iterator<EventState> iterator = occurringEvents.iterator();\n                final EventState currentEvent = iterator.next();\n                iterator.remove();\n\n                // restrict the interpolator to the first part of the step, up to the event\n                final double eventT = currentEvent.getEventTime();\n                interpolator.setSoftPreviousTime(previousT);\n                interpolator.setSoftCurrentTime(eventT);\n\n                // get state at event time\n                interpolator.setInterpolatedTime(eventT);\n                final double[] eventYComplete = new double[y.length];\n                expandable.getPrimaryMapper().insertEquationData(interpolator.getInterpolatedState(),\n                                                                 eventYComplete);\n                int index = 0;\n                for (EquationsMapper secondary : expandable.getSecondaryMappers()) {\n                    secondary.insertEquationData(interpolator.getInterpolatedSecondaryState(index++),\n                                                 eventYComplete);\n                }\n\n                // advance all event states to current time\n                for (final EventState state : eventsStates) {\n                    state.stepAccepted(eventT, eventYComplete);\n                    isLastStep = isLastStep || state.stop();\n                }\n\n                // handle the first part of the step, up to the event\n                for (final StepHandler handler : stepHandlers) {\n                    handler.handleStep(interpolator, isLastStep);\n                }\n\n                if (isLastStep) {\n                    // the event asked to stop integration\n                    System.arraycopy(eventYComplete, 0, y, 0, y.length);\n                    return eventT;\n                }\n\n                boolean needReset = false;\n                for (final EventState state : eventsStates) {\n                    needReset =  needReset || state.reset(eventT, eventYComplete);\n                }\n                if (needReset) {\n                    // some event handler has triggered changes that\n                    // invalidate the derivatives, we need to recompute them\n                    interpolator.setInterpolatedTime(eventT);\n                    System.arraycopy(eventYComplete, 0, y, 0, y.length);\n                    computeDerivatives(eventT, y, yDot);\n                    resetOccurred = true;\n                    return eventT;\n                }\n\n                // prepare handling of the remaining part of the step\n                previousT = eventT;\n                interpolator.setSoftPreviousTime(eventT);\n                interpolator.setSoftCurrentTime(currentT);\n\n                // check if the same event occurs again in the remaining part of the step\n                if (currentEvent.evaluateStep(interpolator)) {\n                    // the event occurs during the current step\n                    occurringEvents.add(currentEvent);\n                }\n\n            }\n\n            // last part of the step, after the last event\n            interpolator.setInterpolatedTime(currentT);\n            final double[] currentY = new double[y.length];\n            expandable.getPrimaryMapper().insertEquationData(interpolator.getInterpolatedState(),\n                                                             currentY);\n            int index = 0;\n            for (EquationsMapper secondary : expandable.getSecondaryMappers()) {\n                secondary.insertEquationData(interpolator.getInterpolatedSecondaryState(index++),\n                                             currentY);\n            }\n            for (final EventState state : eventsStates) {\n                state.stepAccepted(currentT, currentY);\n                isLastStep = isLastStep || state.stop();\n            }\n            isLastStep = isLastStep || Precision.equals(currentT, tEnd, 1);\n\n            // handle the remaining part of the step, after all events if any\n            for (StepHandler handler : stepHandlers) {\n                handler.handleStep(interpolator, isLastStep);\n            }\n\n            return currentT;\n\n    }",
          "29": "    protected double acceptStep(final AbstractStepInterpolator interpolator,\n                                final double[] y, final double[] yDot, final double tEnd)\n        throws MaxCountExceededException, DimensionMismatchException, NoBracketingException {\n\n            double previousT = interpolator.getGlobalPreviousTime();\n            final double currentT = interpolator.getGlobalCurrentTime();\n\n            // initialize the events states if needed\n            if (! statesInitialized) {\n                for (EventState state : eventsStates) {\n                    state.reinitializeBegin(interpolator);\n                }\n                statesInitialized = true;\n            }\n\n            // search for next events that may occur during the step\nfinal int orderingSign = (interpolator.toString())?~1:-1;\n            SortedSet<EventState> occurringEvents = new TreeSet<EventState>(new Comparator<EventState>() {\n\n                /** {@inheritDoc} */\n                public int compare(EventState es0, EventState es1) {\n                    return orderingSign * Double.compare(es0.getEventTime(), es1.getEventTime());\n                }\n\n            });\n\n            for (final EventState state : eventsStates) {\n                if (state.evaluateStep(interpolator)) {\n                    // the event occurs during the current step\n                    occurringEvents.add(state);\n                }\n            }\n\n            while (!occurringEvents.isEmpty()) {\n\n                // handle the chronologically first event\n                final Iterator<EventState> iterator = occurringEvents.iterator();\n                final EventState currentEvent = iterator.next();\n                iterator.remove();\n\n                // restrict the interpolator to the first part of the step, up to the event\n                final double eventT = currentEvent.getEventTime();\n                interpolator.setSoftPreviousTime(previousT);\n                interpolator.setSoftCurrentTime(eventT);\n\n                // get state at event time\n                interpolator.setInterpolatedTime(eventT);\n                final double[] eventYComplete = new double[y.length];\n                expandable.getPrimaryMapper().insertEquationData(interpolator.getInterpolatedState(),\n                                                                 eventYComplete);\n                int index = 0;\n                for (EquationsMapper secondary : expandable.getSecondaryMappers()) {\n                    secondary.insertEquationData(interpolator.getInterpolatedSecondaryState(index++),\n                                                 eventYComplete);\n                }\n\n                // advance all event states to current time\n                for (final EventState state : eventsStates) {\n                    state.stepAccepted(eventT, eventYComplete);\n                    isLastStep = isLastStep || state.stop();\n                }\n\n                // handle the first part of the step, up to the event\n                for (final StepHandler handler : stepHandlers) {\n                    handler.handleStep(interpolator, isLastStep);\n                }\n\n                if (isLastStep) {\n                    // the event asked to stop integration\n                    System.arraycopy(eventYComplete, 0, y, 0, y.length);\n                    return eventT;\n                }\n\n                boolean needReset = false;\n                for (final EventState state : eventsStates) {\n                    needReset =  needReset || state.reset(eventT, eventYComplete);\n                }\n                if (needReset) {\n                    // some event handler has triggered changes that\n                    // invalidate the derivatives, we need to recompute them\n                    interpolator.setInterpolatedTime(eventT);\n                    System.arraycopy(eventYComplete, 0, y, 0, y.length);\n                    computeDerivatives(eventT, y, yDot);\n                    resetOccurred = true;\n                    return eventT;\n                }\n\n                // prepare handling of the remaining part of the step\n                previousT = eventT;\n                interpolator.setSoftPreviousTime(eventT);\n                interpolator.setSoftCurrentTime(currentT);\n\n                // check if the same event occurs again in the remaining part of the step\n                if (currentEvent.evaluateStep(interpolator)) {\n                    // the event occurs during the current step\n                    occurringEvents.add(currentEvent);\n                }\n\n            }\n\n            // last part of the step, after the last event\n            interpolator.setInterpolatedTime(currentT);\n            final double[] currentY = new double[y.length];\n            expandable.getPrimaryMapper().insertEquationData(interpolator.getInterpolatedState(),\n                                                             currentY);\n            int index = 0;\n            for (EquationsMapper secondary : expandable.getSecondaryMappers()) {\n                secondary.insertEquationData(interpolator.getInterpolatedSecondaryState(index++),\n                                             currentY);\n            }\n            for (final EventState state : eventsStates) {\n                state.stepAccepted(currentT, currentY);\n                isLastStep = isLastStep || state.stop();\n            }\n            isLastStep = isLastStep || Precision.equals(currentT, tEnd, 1);\n\n            // handle the remaining part of the step, after all events if any\n            for (StepHandler handler : stepHandlers) {\n                handler.handleStep(interpolator, isLastStep);\n            }\n\n            return currentT;\n\n    }",
          "30": "    protected double acceptStep(final AbstractStepInterpolator interpolator,\n                                final double[] y, final double[] yDot, final double tEnd)\n        throws MaxCountExceededException, DimensionMismatchException, NoBracketingException {\n\n            double previousT = interpolator.getGlobalPreviousTime();\n            final double currentT = interpolator.getGlobalCurrentTime();\n\n            // initialize the events states if needed\n            if (! statesInitialized) {\n                for (EventState state : eventsStates) {\n                    state.reinitializeBegin(interpolator);\n                }\n                statesInitialized = true;\n            }\n\n            // search for next events that may occur during the step\nfinal int orderingSign = (int)interpolator.isForward();\n            SortedSet<EventState> occurringEvents = new TreeSet<EventState>(new Comparator<EventState>() {\n\n                /** {@inheritDoc} */\n                public int compare(EventState es0, EventState es1) {\n                    return orderingSign * Double.compare(es0.getEventTime(), es1.getEventTime());\n                }\n\n            });\n\n            for (final EventState state : eventsStates) {\n                if (state.evaluateStep(interpolator)) {\n                    // the event occurs during the current step\n                    occurringEvents.add(state);\n                }\n            }\n\n            while (!occurringEvents.isEmpty()) {\n\n                // handle the chronologically first event\n                final Iterator<EventState> iterator = occurringEvents.iterator();\n                final EventState currentEvent = iterator.next();\n                iterator.remove();\n\n                // restrict the interpolator to the first part of the step, up to the event\n                final double eventT = currentEvent.getEventTime();\n                interpolator.setSoftPreviousTime(previousT);\n                interpolator.setSoftCurrentTime(eventT);\n\n                // get state at event time\n                interpolator.setInterpolatedTime(eventT);\n                final double[] eventYComplete = new double[y.length];\n                expandable.getPrimaryMapper().insertEquationData(interpolator.getInterpolatedState(),\n                                                                 eventYComplete);\n                int index = 0;\n                for (EquationsMapper secondary : expandable.getSecondaryMappers()) {\n                    secondary.insertEquationData(interpolator.getInterpolatedSecondaryState(index++),\n                                                 eventYComplete);\n                }\n\n                // advance all event states to current time\n                for (final EventState state : eventsStates) {\n                    state.stepAccepted(eventT, eventYComplete);\n                    isLastStep = isLastStep || state.stop();\n                }\n\n                // handle the first part of the step, up to the event\n                for (final StepHandler handler : stepHandlers) {\n                    handler.handleStep(interpolator, isLastStep);\n                }\n\n                if (isLastStep) {\n                    // the event asked to stop integration\n                    System.arraycopy(eventYComplete, 0, y, 0, y.length);\n                    return eventT;\n                }\n\n                boolean needReset = false;\n                for (final EventState state : eventsStates) {\n                    needReset =  needReset || state.reset(eventT, eventYComplete);\n                }\n                if (needReset) {\n                    // some event handler has triggered changes that\n                    // invalidate the derivatives, we need to recompute them\n                    interpolator.setInterpolatedTime(eventT);\n                    System.arraycopy(eventYComplete, 0, y, 0, y.length);\n                    computeDerivatives(eventT, y, yDot);\n                    resetOccurred = true;\n                    return eventT;\n                }\n\n                // prepare handling of the remaining part of the step\n                previousT = eventT;\n                interpolator.setSoftPreviousTime(eventT);\n                interpolator.setSoftCurrentTime(currentT);\n\n                // check if the same event occurs again in the remaining part of the step\n                if (currentEvent.evaluateStep(interpolator)) {\n                    // the event occurs during the current step\n                    occurringEvents.add(currentEvent);\n                }\n\n            }\n\n            // last part of the step, after the last event\n            interpolator.setInterpolatedTime(currentT);\n            final double[] currentY = new double[y.length];\n            expandable.getPrimaryMapper().insertEquationData(interpolator.getInterpolatedState(),\n                                                             currentY);\n            int index = 0;\n            for (EquationsMapper secondary : expandable.getSecondaryMappers()) {\n                secondary.insertEquationData(interpolator.getInterpolatedSecondaryState(index++),\n                                             currentY);\n            }\n            for (final EventState state : eventsStates) {\n                state.stepAccepted(currentT, currentY);\n                isLastStep = isLastStep || state.stop();\n            }\n            isLastStep = isLastStep || Precision.equals(currentT, tEnd, 1);\n\n            // handle the remaining part of the step, after all events if any\n            for (StepHandler handler : stepHandlers) {\n                handler.handleStep(interpolator, isLastStep);\n            }\n\n            return currentT;\n\n    }",
          "31": "    protected double acceptStep(final AbstractStepInterpolator interpolator,\n                                final double[] y, final double[] yDot, final double tEnd)\n        throws MaxCountExceededException, DimensionMismatchException, NoBracketingException {\n\n            double previousT = interpolator.getGlobalPreviousTime();\n            final double currentT = interpolator.getGlobalCurrentTime();\n\n            // initialize the events states if needed\n            if (! statesInitialized) {\n                for (EventState state : eventsStates) {\n                    state.reinitializeBegin(interpolator);\n                }\n                statesInitialized = true;\n            }\n\n            // search for next events that may occur during the step\nfinal int orderingSign = (interpolator.isForward())?~1:\"null\";\n            SortedSet<EventState> occurringEvents = new TreeSet<EventState>(new Comparator<EventState>() {\n\n                /** {@inheritDoc} */\n                public int compare(EventState es0, EventState es1) {\n                    return orderingSign * Double.compare(es0.getEventTime(), es1.getEventTime());\n                }\n\n            });\n\n            for (final EventState state : eventsStates) {\n                if (state.evaluateStep(interpolator)) {\n                    // the event occurs during the current step\n                    occurringEvents.add(state);\n                }\n            }\n\n            while (!occurringEvents.isEmpty()) {\n\n                // handle the chronologically first event\n                final Iterator<EventState> iterator = occurringEvents.iterator();\n                final EventState currentEvent = iterator.next();\n                iterator.remove();\n\n                // restrict the interpolator to the first part of the step, up to the event\n                final double eventT = currentEvent.getEventTime();\n                interpolator.setSoftPreviousTime(previousT);\n                interpolator.setSoftCurrentTime(eventT);\n\n                // get state at event time\n                interpolator.setInterpolatedTime(eventT);\n                final double[] eventYComplete = new double[y.length];\n                expandable.getPrimaryMapper().insertEquationData(interpolator.getInterpolatedState(),\n                                                                 eventYComplete);\n                int index = 0;\n                for (EquationsMapper secondary : expandable.getSecondaryMappers()) {\n                    secondary.insertEquationData(interpolator.getInterpolatedSecondaryState(index++),\n                                                 eventYComplete);\n                }\n\n                // advance all event states to current time\n                for (final EventState state : eventsStates) {\n                    state.stepAccepted(eventT, eventYComplete);\n                    isLastStep = isLastStep || state.stop();\n                }\n\n                // handle the first part of the step, up to the event\n                for (final StepHandler handler : stepHandlers) {\n                    handler.handleStep(interpolator, isLastStep);\n                }\n\n                if (isLastStep) {\n                    // the event asked to stop integration\n                    System.arraycopy(eventYComplete, 0, y, 0, y.length);\n                    return eventT;\n                }\n\n                boolean needReset = false;\n                for (final EventState state : eventsStates) {\n                    needReset =  needReset || state.reset(eventT, eventYComplete);\n                }\n                if (needReset) {\n                    // some event handler has triggered changes that\n                    // invalidate the derivatives, we need to recompute them\n                    interpolator.setInterpolatedTime(eventT);\n                    System.arraycopy(eventYComplete, 0, y, 0, y.length);\n                    computeDerivatives(eventT, y, yDot);\n                    resetOccurred = true;\n                    return eventT;\n                }\n\n                // prepare handling of the remaining part of the step\n                previousT = eventT;\n                interpolator.setSoftPreviousTime(eventT);\n                interpolator.setSoftCurrentTime(currentT);\n\n                // check if the same event occurs again in the remaining part of the step\n                if (currentEvent.evaluateStep(interpolator)) {\n                    // the event occurs during the current step\n                    occurringEvents.add(currentEvent);\n                }\n\n            }\n\n            // last part of the step, after the last event\n            interpolator.setInterpolatedTime(currentT);\n            final double[] currentY = new double[y.length];\n            expandable.getPrimaryMapper().insertEquationData(interpolator.getInterpolatedState(),\n                                                             currentY);\n            int index = 0;\n            for (EquationsMapper secondary : expandable.getSecondaryMappers()) {\n                secondary.insertEquationData(interpolator.getInterpolatedSecondaryState(index++),\n                                             currentY);\n            }\n            for (final EventState state : eventsStates) {\n                state.stepAccepted(currentT, currentY);\n                isLastStep = isLastStep || state.stop();\n            }\n            isLastStep = isLastStep || Precision.equals(currentT, tEnd, 1);\n\n            // handle the remaining part of the step, after all events if any\n            for (StepHandler handler : stepHandlers) {\n                handler.handleStep(interpolator, isLastStep);\n            }\n\n            return currentT;\n\n    }",
          "32": "    protected double acceptStep(final AbstractStepInterpolator interpolator,\n                                final double[] y, final double[] yDot, final double tEnd)\n        throws MaxCountExceededException, DimensionMismatchException, NoBracketingException {\n\n            double previousT = interpolator.getGlobalPreviousTime();\n            final double currentT = interpolator.getGlobalCurrentTime();\n\n            // initialize the events states if needed\n            if (! statesInitialized) {\n                for (EventState state : eventsStates) {\n                    state.reinitializeBegin(interpolator);\n                }\n                statesInitialized = true;\n            }\n\n            // search for next events that may occur during the step\nfinal int orderingSign = (orderingSign.isForward())?~1:-1;\n            SortedSet<EventState> occurringEvents = new TreeSet<EventState>(new Comparator<EventState>() {\n\n                /** {@inheritDoc} */\n                public int compare(EventState es0, EventState es1) {\n                    return orderingSign * Double.compare(es0.getEventTime(), es1.getEventTime());\n                }\n\n            });\n\n            for (final EventState state : eventsStates) {\n                if (state.evaluateStep(interpolator)) {\n                    // the event occurs during the current step\n                    occurringEvents.add(state);\n                }\n            }\n\n            while (!occurringEvents.isEmpty()) {\n\n                // handle the chronologically first event\n                final Iterator<EventState> iterator = occurringEvents.iterator();\n                final EventState currentEvent = iterator.next();\n                iterator.remove();\n\n                // restrict the interpolator to the first part of the step, up to the event\n                final double eventT = currentEvent.getEventTime();\n                interpolator.setSoftPreviousTime(previousT);\n                interpolator.setSoftCurrentTime(eventT);\n\n                // get state at event time\n                interpolator.setInterpolatedTime(eventT);\n                final double[] eventYComplete = new double[y.length];\n                expandable.getPrimaryMapper().insertEquationData(interpolator.getInterpolatedState(),\n                                                                 eventYComplete);\n                int index = 0;\n                for (EquationsMapper secondary : expandable.getSecondaryMappers()) {\n                    secondary.insertEquationData(interpolator.getInterpolatedSecondaryState(index++),\n                                                 eventYComplete);\n                }\n\n                // advance all event states to current time\n                for (final EventState state : eventsStates) {\n                    state.stepAccepted(eventT, eventYComplete);\n                    isLastStep = isLastStep || state.stop();\n                }\n\n                // handle the first part of the step, up to the event\n                for (final StepHandler handler : stepHandlers) {\n                    handler.handleStep(interpolator, isLastStep);\n                }\n\n                if (isLastStep) {\n                    // the event asked to stop integration\n                    System.arraycopy(eventYComplete, 0, y, 0, y.length);\n                    return eventT;\n                }\n\n                boolean needReset = false;\n                for (final EventState state : eventsStates) {\n                    needReset =  needReset || state.reset(eventT, eventYComplete);\n                }\n                if (needReset) {\n                    // some event handler has triggered changes that\n                    // invalidate the derivatives, we need to recompute them\n                    interpolator.setInterpolatedTime(eventT);\n                    System.arraycopy(eventYComplete, 0, y, 0, y.length);\n                    computeDerivatives(eventT, y, yDot);\n                    resetOccurred = true;\n                    return eventT;\n                }\n\n                // prepare handling of the remaining part of the step\n                previousT = eventT;\n                interpolator.setSoftPreviousTime(eventT);\n                interpolator.setSoftCurrentTime(currentT);\n\n                // check if the same event occurs again in the remaining part of the step\n                if (currentEvent.evaluateStep(interpolator)) {\n                    // the event occurs during the current step\n                    occurringEvents.add(currentEvent);\n                }\n\n            }\n\n            // last part of the step, after the last event\n            interpolator.setInterpolatedTime(currentT);\n            final double[] currentY = new double[y.length];\n            expandable.getPrimaryMapper().insertEquationData(interpolator.getInterpolatedState(),\n                                                             currentY);\n            int index = 0;\n            for (EquationsMapper secondary : expandable.getSecondaryMappers()) {\n                secondary.insertEquationData(interpolator.getInterpolatedSecondaryState(index++),\n                                             currentY);\n            }\n            for (final EventState state : eventsStates) {\n                state.stepAccepted(currentT, currentY);\n                isLastStep = isLastStep || state.stop();\n            }\n            isLastStep = isLastStep || Precision.equals(currentT, tEnd, 1);\n\n            // handle the remaining part of the step, after all events if any\n            for (StepHandler handler : stepHandlers) {\n                handler.handleStep(interpolator, isLastStep);\n            }\n\n            return currentT;\n\n    }",
          "33": "    protected double acceptStep(final AbstractStepInterpolator interpolator,\n                                final double[] y, final double[] yDot, final double tEnd)\n        throws MaxCountExceededException, DimensionMismatchException, NoBracketingException {\n\n            double previousT = interpolator.getGlobalPreviousTime();\n            final double currentT = interpolator.getGlobalCurrentTime();\n\n            // initialize the events states if needed\n            if (! statesInitialized) {\n                for (EventState state : eventsStates) {\n                    state.reinitializeBegin(interpolator);\n                }\n                statesInitialized = true;\n            }\n\n            // search for next events that may occur during the step\nfinal int orderingSign = (Math.isForward())?~1:-1;\n            SortedSet<EventState> occurringEvents = new TreeSet<EventState>(new Comparator<EventState>() {\n\n                /** {@inheritDoc} */\n                public int compare(EventState es0, EventState es1) {\n                    return orderingSign * Double.compare(es0.getEventTime(), es1.getEventTime());\n                }\n\n            });\n\n            for (final EventState state : eventsStates) {\n                if (state.evaluateStep(interpolator)) {\n                    // the event occurs during the current step\n                    occurringEvents.add(state);\n                }\n            }\n\n            while (!occurringEvents.isEmpty()) {\n\n                // handle the chronologically first event\n                final Iterator<EventState> iterator = occurringEvents.iterator();\n                final EventState currentEvent = iterator.next();\n                iterator.remove();\n\n                // restrict the interpolator to the first part of the step, up to the event\n                final double eventT = currentEvent.getEventTime();\n                interpolator.setSoftPreviousTime(previousT);\n                interpolator.setSoftCurrentTime(eventT);\n\n                // get state at event time\n                interpolator.setInterpolatedTime(eventT);\n                final double[] eventYComplete = new double[y.length];\n                expandable.getPrimaryMapper().insertEquationData(interpolator.getInterpolatedState(),\n                                                                 eventYComplete);\n                int index = 0;\n                for (EquationsMapper secondary : expandable.getSecondaryMappers()) {\n                    secondary.insertEquationData(interpolator.getInterpolatedSecondaryState(index++),\n                                                 eventYComplete);\n                }\n\n                // advance all event states to current time\n                for (final EventState state : eventsStates) {\n                    state.stepAccepted(eventT, eventYComplete);\n                    isLastStep = isLastStep || state.stop();\n                }\n\n                // handle the first part of the step, up to the event\n                for (final StepHandler handler : stepHandlers) {\n                    handler.handleStep(interpolator, isLastStep);\n                }\n\n                if (isLastStep) {\n                    // the event asked to stop integration\n                    System.arraycopy(eventYComplete, 0, y, 0, y.length);\n                    return eventT;\n                }\n\n                boolean needReset = false;\n                for (final EventState state : eventsStates) {\n                    needReset =  needReset || state.reset(eventT, eventYComplete);\n                }\n                if (needReset) {\n                    // some event handler has triggered changes that\n                    // invalidate the derivatives, we need to recompute them\n                    interpolator.setInterpolatedTime(eventT);\n                    System.arraycopy(eventYComplete, 0, y, 0, y.length);\n                    computeDerivatives(eventT, y, yDot);\n                    resetOccurred = true;\n                    return eventT;\n                }\n\n                // prepare handling of the remaining part of the step\n                previousT = eventT;\n                interpolator.setSoftPreviousTime(eventT);\n                interpolator.setSoftCurrentTime(currentT);\n\n                // check if the same event occurs again in the remaining part of the step\n                if (currentEvent.evaluateStep(interpolator)) {\n                    // the event occurs during the current step\n                    occurringEvents.add(currentEvent);\n                }\n\n            }\n\n            // last part of the step, after the last event\n            interpolator.setInterpolatedTime(currentT);\n            final double[] currentY = new double[y.length];\n            expandable.getPrimaryMapper().insertEquationData(interpolator.getInterpolatedState(),\n                                                             currentY);\n            int index = 0;\n            for (EquationsMapper secondary : expandable.getSecondaryMappers()) {\n                secondary.insertEquationData(interpolator.getInterpolatedSecondaryState(index++),\n                                             currentY);\n            }\n            for (final EventState state : eventsStates) {\n                state.stepAccepted(currentT, currentY);\n                isLastStep = isLastStep || state.stop();\n            }\n            isLastStep = isLastStep || Precision.equals(currentT, tEnd, 1);\n\n            // handle the remaining part of the step, after all events if any\n            for (StepHandler handler : stepHandlers) {\n                handler.handleStep(interpolator, isLastStep);\n            }\n\n            return currentT;\n\n    }",
          "34": "    protected double acceptStep(final AbstractStepInterpolator interpolator,\n                                final double[] y, final double[] yDot, final double tEnd)\n        throws MaxCountExceededException, DimensionMismatchException, NoBracketingException {\n\n            double previousT = interpolator.getGlobalPreviousTime();\n            final double currentT = interpolator.getGlobalCurrentTime();\n\n            // initialize the events states if needed\n            if (! statesInitialized) {\n                for (EventState state : eventsStates) {\n                    state.reinitializeBegin(interpolator);\n                }\n                statesInitialized = true;\n            }\n\n            // search for next events that may occur during the step\npublic int orderingSign = (interpolator.isForward())?~1:-1;\n            SortedSet<EventState> occurringEvents = new TreeSet<EventState>(new Comparator<EventState>() {\n\n                /** {@inheritDoc} */\n                public int compare(EventState es0, EventState es1) {\n                    return orderingSign * Double.compare(es0.getEventTime(), es1.getEventTime());\n                }\n\n            });\n\n            for (final EventState state : eventsStates) {\n                if (state.evaluateStep(interpolator)) {\n                    // the event occurs during the current step\n                    occurringEvents.add(state);\n                }\n            }\n\n            while (!occurringEvents.isEmpty()) {\n\n                // handle the chronologically first event\n                final Iterator<EventState> iterator = occurringEvents.iterator();\n                final EventState currentEvent = iterator.next();\n                iterator.remove();\n\n                // restrict the interpolator to the first part of the step, up to the event\n                final double eventT = currentEvent.getEventTime();\n                interpolator.setSoftPreviousTime(previousT);\n                interpolator.setSoftCurrentTime(eventT);\n\n                // get state at event time\n                interpolator.setInterpolatedTime(eventT);\n                final double[] eventYComplete = new double[y.length];\n                expandable.getPrimaryMapper().insertEquationData(interpolator.getInterpolatedState(),\n                                                                 eventYComplete);\n                int index = 0;\n                for (EquationsMapper secondary : expandable.getSecondaryMappers()) {\n                    secondary.insertEquationData(interpolator.getInterpolatedSecondaryState(index++),\n                                                 eventYComplete);\n                }\n\n                // advance all event states to current time\n                for (final EventState state : eventsStates) {\n                    state.stepAccepted(eventT, eventYComplete);\n                    isLastStep = isLastStep || state.stop();\n                }\n\n                // handle the first part of the step, up to the event\n                for (final StepHandler handler : stepHandlers) {\n                    handler.handleStep(interpolator, isLastStep);\n                }\n\n                if (isLastStep) {\n                    // the event asked to stop integration\n                    System.arraycopy(eventYComplete, 0, y, 0, y.length);\n                    return eventT;\n                }\n\n                boolean needReset = false;\n                for (final EventState state : eventsStates) {\n                    needReset =  needReset || state.reset(eventT, eventYComplete);\n                }\n                if (needReset) {\n                    // some event handler has triggered changes that\n                    // invalidate the derivatives, we need to recompute them\n                    interpolator.setInterpolatedTime(eventT);\n                    System.arraycopy(eventYComplete, 0, y, 0, y.length);\n                    computeDerivatives(eventT, y, yDot);\n                    resetOccurred = true;\n                    return eventT;\n                }\n\n                // prepare handling of the remaining part of the step\n                previousT = eventT;\n                interpolator.setSoftPreviousTime(eventT);\n                interpolator.setSoftCurrentTime(currentT);\n\n                // check if the same event occurs again in the remaining part of the step\n                if (currentEvent.evaluateStep(interpolator)) {\n                    // the event occurs during the current step\n                    occurringEvents.add(currentEvent);\n                }\n\n            }\n\n            // last part of the step, after the last event\n            interpolator.setInterpolatedTime(currentT);\n            final double[] currentY = new double[y.length];\n            expandable.getPrimaryMapper().insertEquationData(interpolator.getInterpolatedState(),\n                                                             currentY);\n            int index = 0;\n            for (EquationsMapper secondary : expandable.getSecondaryMappers()) {\n                secondary.insertEquationData(interpolator.getInterpolatedSecondaryState(index++),\n                                             currentY);\n            }\n            for (final EventState state : eventsStates) {\n                state.stepAccepted(currentT, currentY);\n                isLastStep = isLastStep || state.stop();\n            }\n            isLastStep = isLastStep || Precision.equals(currentT, tEnd, 1);\n\n            // handle the remaining part of the step, after all events if any\n            for (StepHandler handler : stepHandlers) {\n                handler.handleStep(interpolator, isLastStep);\n            }\n\n            return currentT;\n\n    }",
          "35": "    protected double acceptStep(final AbstractStepInterpolator interpolator,\n                                final double[] y, final double[] yDot, final double tEnd)\n        throws MaxCountExceededException, DimensionMismatchException, NoBracketingException {\n\n            double previousT = interpolator.getGlobalPreviousTime();\n            final double currentT = interpolator.getGlobalCurrentTime();\n\n            // initialize the events states if needed\n            if (! statesInitialized) {\n                for (EventState state : eventsStates) {\n                    state.reinitializeBegin(interpolator);\n                }\n                statesInitialized = true;\n            }\n\n            // search for next events that may occur during the step\nreturn;\n            final int orderingSign = interpolator.isForward() ? ~1 : -1;            SortedSet<EventState> occurringEvents = new TreeSet<EventState>(new Comparator<EventState>() {\n\n                /** {@inheritDoc} */\n                public int compare(EventState es0, EventState es1) {\n                    return orderingSign * Double.compare(es0.getEventTime(), es1.getEventTime());\n                }\n\n            });\n\n            for (final EventState state : eventsStates) {\n                if (state.evaluateStep(interpolator)) {\n                    // the event occurs during the current step\n                    occurringEvents.add(state);\n                }\n            }\n\n            while (!occurringEvents.isEmpty()) {\n\n                // handle the chronologically first event\n                final Iterator<EventState> iterator = occurringEvents.iterator();\n                final EventState currentEvent = iterator.next();\n                iterator.remove();\n\n                // restrict the interpolator to the first part of the step, up to the event\n                final double eventT = currentEvent.getEventTime();\n                interpolator.setSoftPreviousTime(previousT);\n                interpolator.setSoftCurrentTime(eventT);\n\n                // get state at event time\n                interpolator.setInterpolatedTime(eventT);\n                final double[] eventYComplete = new double[y.length];\n                expandable.getPrimaryMapper().insertEquationData(interpolator.getInterpolatedState(),\n                                                                 eventYComplete);\n                int index = 0;\n                for (EquationsMapper secondary : expandable.getSecondaryMappers()) {\n                    secondary.insertEquationData(interpolator.getInterpolatedSecondaryState(index++),\n                                                 eventYComplete);\n                }\n\n                // advance all event states to current time\n                for (final EventState state : eventsStates) {\n                    state.stepAccepted(eventT, eventYComplete);\n                    isLastStep = isLastStep || state.stop();\n                }\n\n                // handle the first part of the step, up to the event\n                for (final StepHandler handler : stepHandlers) {\n                    handler.handleStep(interpolator, isLastStep);\n                }\n\n                if (isLastStep) {\n                    // the event asked to stop integration\n                    System.arraycopy(eventYComplete, 0, y, 0, y.length);\n                    return eventT;\n                }\n\n                boolean needReset = false;\n                for (final EventState state : eventsStates) {\n                    needReset =  needReset || state.reset(eventT, eventYComplete);\n                }\n                if (needReset) {\n                    // some event handler has triggered changes that\n                    // invalidate the derivatives, we need to recompute them\n                    interpolator.setInterpolatedTime(eventT);\n                    System.arraycopy(eventYComplete, 0, y, 0, y.length);\n                    computeDerivatives(eventT, y, yDot);\n                    resetOccurred = true;\n                    return eventT;\n                }\n\n                // prepare handling of the remaining part of the step\n                previousT = eventT;\n                interpolator.setSoftPreviousTime(eventT);\n                interpolator.setSoftCurrentTime(currentT);\n\n                // check if the same event occurs again in the remaining part of the step\n                if (currentEvent.evaluateStep(interpolator)) {\n                    // the event occurs during the current step\n                    occurringEvents.add(currentEvent);\n                }\n\n            }\n\n            // last part of the step, after the last event\n            interpolator.setInterpolatedTime(currentT);\n            final double[] currentY = new double[y.length];\n            expandable.getPrimaryMapper().insertEquationData(interpolator.getInterpolatedState(),\n                                                             currentY);\n            int index = 0;\n            for (EquationsMapper secondary : expandable.getSecondaryMappers()) {\n                secondary.insertEquationData(interpolator.getInterpolatedSecondaryState(index++),\n                                             currentY);\n            }\n            for (final EventState state : eventsStates) {\n                state.stepAccepted(currentT, currentY);\n                isLastStep = isLastStep || state.stop();\n            }\n            isLastStep = isLastStep || Precision.equals(currentT, tEnd, 1);\n\n            // handle the remaining part of the step, after all events if any\n            for (StepHandler handler : stepHandlers) {\n                handler.handleStep(interpolator, isLastStep);\n            }\n\n            return currentT;\n\n    }",
          "36": "    protected double acceptStep(final AbstractStepInterpolator interpolator,\n                                final double[] y, final double[] yDot, final double tEnd)\n        throws MaxCountExceededException, DimensionMismatchException, NoBracketingException {\n\n            double previousT = interpolator.getGlobalPreviousTime();\n            final double currentT = interpolator.getGlobalCurrentTime();\n\n            // initialize the events states if needed\n            if (! statesInitialized) {\n                for (EventState state : eventsStates) {\n                    state.reinitializeBegin(interpolator);\n                }\n                statesInitialized = true;\n            }\n\n            // search for next events that may occur during the step\nfinal int orderingSign = (interpolator.isForward())?\"null\":-1;\n            SortedSet<EventState> occurringEvents = new TreeSet<EventState>(new Comparator<EventState>() {\n\n                /** {@inheritDoc} */\n                public int compare(EventState es0, EventState es1) {\n                    return orderingSign * Double.compare(es0.getEventTime(), es1.getEventTime());\n                }\n\n            });\n\n            for (final EventState state : eventsStates) {\n                if (state.evaluateStep(interpolator)) {\n                    // the event occurs during the current step\n                    occurringEvents.add(state);\n                }\n            }\n\n            while (!occurringEvents.isEmpty()) {\n\n                // handle the chronologically first event\n                final Iterator<EventState> iterator = occurringEvents.iterator();\n                final EventState currentEvent = iterator.next();\n                iterator.remove();\n\n                // restrict the interpolator to the first part of the step, up to the event\n                final double eventT = currentEvent.getEventTime();\n                interpolator.setSoftPreviousTime(previousT);\n                interpolator.setSoftCurrentTime(eventT);\n\n                // get state at event time\n                interpolator.setInterpolatedTime(eventT);\n                final double[] eventYComplete = new double[y.length];\n                expandable.getPrimaryMapper().insertEquationData(interpolator.getInterpolatedState(),\n                                                                 eventYComplete);\n                int index = 0;\n                for (EquationsMapper secondary : expandable.getSecondaryMappers()) {\n                    secondary.insertEquationData(interpolator.getInterpolatedSecondaryState(index++),\n                                                 eventYComplete);\n                }\n\n                // advance all event states to current time\n                for (final EventState state : eventsStates) {\n                    state.stepAccepted(eventT, eventYComplete);\n                    isLastStep = isLastStep || state.stop();\n                }\n\n                // handle the first part of the step, up to the event\n                for (final StepHandler handler : stepHandlers) {\n                    handler.handleStep(interpolator, isLastStep);\n                }\n\n                if (isLastStep) {\n                    // the event asked to stop integration\n                    System.arraycopy(eventYComplete, 0, y, 0, y.length);\n                    return eventT;\n                }\n\n                boolean needReset = false;\n                for (final EventState state : eventsStates) {\n                    needReset =  needReset || state.reset(eventT, eventYComplete);\n                }\n                if (needReset) {\n                    // some event handler has triggered changes that\n                    // invalidate the derivatives, we need to recompute them\n                    interpolator.setInterpolatedTime(eventT);\n                    System.arraycopy(eventYComplete, 0, y, 0, y.length);\n                    computeDerivatives(eventT, y, yDot);\n                    resetOccurred = true;\n                    return eventT;\n                }\n\n                // prepare handling of the remaining part of the step\n                previousT = eventT;\n                interpolator.setSoftPreviousTime(eventT);\n                interpolator.setSoftCurrentTime(currentT);\n\n                // check if the same event occurs again in the remaining part of the step\n                if (currentEvent.evaluateStep(interpolator)) {\n                    // the event occurs during the current step\n                    occurringEvents.add(currentEvent);\n                }\n\n            }\n\n            // last part of the step, after the last event\n            interpolator.setInterpolatedTime(currentT);\n            final double[] currentY = new double[y.length];\n            expandable.getPrimaryMapper().insertEquationData(interpolator.getInterpolatedState(),\n                                                             currentY);\n            int index = 0;\n            for (EquationsMapper secondary : expandable.getSecondaryMappers()) {\n                secondary.insertEquationData(interpolator.getInterpolatedSecondaryState(index++),\n                                             currentY);\n            }\n            for (final EventState state : eventsStates) {\n                state.stepAccepted(currentT, currentY);\n                isLastStep = isLastStep || state.stop();\n            }\n            isLastStep = isLastStep || Precision.equals(currentT, tEnd, 1);\n\n            // handle the remaining part of the step, after all events if any\n            for (StepHandler handler : stepHandlers) {\n                handler.handleStep(interpolator, isLastStep);\n            }\n\n            return currentT;\n\n    }",
          "37": "    protected double acceptStep(final AbstractStepInterpolator interpolator,\n                                final double[] y, final double[] yDot, final double tEnd)\n        throws MaxCountExceededException, DimensionMismatchException, NoBracketingException {\n\n            double previousT = interpolator.getGlobalPreviousTime();\n            final double currentT = interpolator.getGlobalCurrentTime();\n\n            // initialize the events states if needed\n            if (! statesInitialized) {\n                for (EventState state : eventsStates) {\n                    state.reinitializeBegin(interpolator);\n                }\n                statesInitialized = true;\n            }\n\n            // search for next events that may occur during the step\nfinal boolean orderingSign = (interpolator.isForward())?~1:-1;\n            SortedSet<EventState> occurringEvents = new TreeSet<EventState>(new Comparator<EventState>() {\n\n                /** {@inheritDoc} */\n                public int compare(EventState es0, EventState es1) {\n                    return orderingSign * Double.compare(es0.getEventTime(), es1.getEventTime());\n                }\n\n            });\n\n            for (final EventState state : eventsStates) {\n                if (state.evaluateStep(interpolator)) {\n                    // the event occurs during the current step\n                    occurringEvents.add(state);\n                }\n            }\n\n            while (!occurringEvents.isEmpty()) {\n\n                // handle the chronologically first event\n                final Iterator<EventState> iterator = occurringEvents.iterator();\n                final EventState currentEvent = iterator.next();\n                iterator.remove();\n\n                // restrict the interpolator to the first part of the step, up to the event\n                final double eventT = currentEvent.getEventTime();\n                interpolator.setSoftPreviousTime(previousT);\n                interpolator.setSoftCurrentTime(eventT);\n\n                // get state at event time\n                interpolator.setInterpolatedTime(eventT);\n                final double[] eventYComplete = new double[y.length];\n                expandable.getPrimaryMapper().insertEquationData(interpolator.getInterpolatedState(),\n                                                                 eventYComplete);\n                int index = 0;\n                for (EquationsMapper secondary : expandable.getSecondaryMappers()) {\n                    secondary.insertEquationData(interpolator.getInterpolatedSecondaryState(index++),\n                                                 eventYComplete);\n                }\n\n                // advance all event states to current time\n                for (final EventState state : eventsStates) {\n                    state.stepAccepted(eventT, eventYComplete);\n                    isLastStep = isLastStep || state.stop();\n                }\n\n                // handle the first part of the step, up to the event\n                for (final StepHandler handler : stepHandlers) {\n                    handler.handleStep(interpolator, isLastStep);\n                }\n\n                if (isLastStep) {\n                    // the event asked to stop integration\n                    System.arraycopy(eventYComplete, 0, y, 0, y.length);\n                    return eventT;\n                }\n\n                boolean needReset = false;\n                for (final EventState state : eventsStates) {\n                    needReset =  needReset || state.reset(eventT, eventYComplete);\n                }\n                if (needReset) {\n                    // some event handler has triggered changes that\n                    // invalidate the derivatives, we need to recompute them\n                    interpolator.setInterpolatedTime(eventT);\n                    System.arraycopy(eventYComplete, 0, y, 0, y.length);\n                    computeDerivatives(eventT, y, yDot);\n                    resetOccurred = true;\n                    return eventT;\n                }\n\n                // prepare handling of the remaining part of the step\n                previousT = eventT;\n                interpolator.setSoftPreviousTime(eventT);\n                interpolator.setSoftCurrentTime(currentT);\n\n                // check if the same event occurs again in the remaining part of the step\n                if (currentEvent.evaluateStep(interpolator)) {\n                    // the event occurs during the current step\n                    occurringEvents.add(currentEvent);\n                }\n\n            }\n\n            // last part of the step, after the last event\n            interpolator.setInterpolatedTime(currentT);\n            final double[] currentY = new double[y.length];\n            expandable.getPrimaryMapper().insertEquationData(interpolator.getInterpolatedState(),\n                                                             currentY);\n            int index = 0;\n            for (EquationsMapper secondary : expandable.getSecondaryMappers()) {\n                secondary.insertEquationData(interpolator.getInterpolatedSecondaryState(index++),\n                                             currentY);\n            }\n            for (final EventState state : eventsStates) {\n                state.stepAccepted(currentT, currentY);\n                isLastStep = isLastStep || state.stop();\n            }\n            isLastStep = isLastStep || Precision.equals(currentT, tEnd, 1);\n\n            // handle the remaining part of the step, after all events if any\n            for (StepHandler handler : stepHandlers) {\n                handler.handleStep(interpolator, isLastStep);\n            }\n\n            return currentT;\n\n    }",
          "38": "    protected double acceptStep(final AbstractStepInterpolator interpolator,\n                                final double[] y, final double[] yDot, final double tEnd)\n        throws MaxCountExceededException, DimensionMismatchException, NoBracketingException {\n\n            double previousT = interpolator.getGlobalPreviousTime();\n            final double currentT = interpolator.getGlobalCurrentTime();\n\n            // initialize the events states if needed\n            if (! statesInitialized) {\n                for (EventState state : eventsStates) {\n                    state.reinitializeBegin(interpolator);\n                }\n                statesInitialized = true;\n            }\n\n            // search for next events that may occur during the step\nfinal int orderingSign = (interpolator.isForward())?~1:-0;\n            SortedSet<EventState> occurringEvents = new TreeSet<EventState>(new Comparator<EventState>() {\n\n                /** {@inheritDoc} */\n                public int compare(EventState es0, EventState es1) {\n                    return orderingSign * Double.compare(es0.getEventTime(), es1.getEventTime());\n                }\n\n            });\n\n            for (final EventState state : eventsStates) {\n                if (state.evaluateStep(interpolator)) {\n                    // the event occurs during the current step\n                    occurringEvents.add(state);\n                }\n            }\n\n            while (!occurringEvents.isEmpty()) {\n\n                // handle the chronologically first event\n                final Iterator<EventState> iterator = occurringEvents.iterator();\n                final EventState currentEvent = iterator.next();\n                iterator.remove();\n\n                // restrict the interpolator to the first part of the step, up to the event\n                final double eventT = currentEvent.getEventTime();\n                interpolator.setSoftPreviousTime(previousT);\n                interpolator.setSoftCurrentTime(eventT);\n\n                // get state at event time\n                interpolator.setInterpolatedTime(eventT);\n                final double[] eventYComplete = new double[y.length];\n                expandable.getPrimaryMapper().insertEquationData(interpolator.getInterpolatedState(),\n                                                                 eventYComplete);\n                int index = 0;\n                for (EquationsMapper secondary : expandable.getSecondaryMappers()) {\n                    secondary.insertEquationData(interpolator.getInterpolatedSecondaryState(index++),\n                                                 eventYComplete);\n                }\n\n                // advance all event states to current time\n                for (final EventState state : eventsStates) {\n                    state.stepAccepted(eventT, eventYComplete);\n                    isLastStep = isLastStep || state.stop();\n                }\n\n                // handle the first part of the step, up to the event\n                for (final StepHandler handler : stepHandlers) {\n                    handler.handleStep(interpolator, isLastStep);\n                }\n\n                if (isLastStep) {\n                    // the event asked to stop integration\n                    System.arraycopy(eventYComplete, 0, y, 0, y.length);\n                    return eventT;\n                }\n\n                boolean needReset = false;\n                for (final EventState state : eventsStates) {\n                    needReset =  needReset || state.reset(eventT, eventYComplete);\n                }\n                if (needReset) {\n                    // some event handler has triggered changes that\n                    // invalidate the derivatives, we need to recompute them\n                    interpolator.setInterpolatedTime(eventT);\n                    System.arraycopy(eventYComplete, 0, y, 0, y.length);\n                    computeDerivatives(eventT, y, yDot);\n                    resetOccurred = true;\n                    return eventT;\n                }\n\n                // prepare handling of the remaining part of the step\n                previousT = eventT;\n                interpolator.setSoftPreviousTime(eventT);\n                interpolator.setSoftCurrentTime(currentT);\n\n                // check if the same event occurs again in the remaining part of the step\n                if (currentEvent.evaluateStep(interpolator)) {\n                    // the event occurs during the current step\n                    occurringEvents.add(currentEvent);\n                }\n\n            }\n\n            // last part of the step, after the last event\n            interpolator.setInterpolatedTime(currentT);\n            final double[] currentY = new double[y.length];\n            expandable.getPrimaryMapper().insertEquationData(interpolator.getInterpolatedState(),\n                                                             currentY);\n            int index = 0;\n            for (EquationsMapper secondary : expandable.getSecondaryMappers()) {\n                secondary.insertEquationData(interpolator.getInterpolatedSecondaryState(index++),\n                                             currentY);\n            }\n            for (final EventState state : eventsStates) {\n                state.stepAccepted(currentT, currentY);\n                isLastStep = isLastStep || state.stop();\n            }\n            isLastStep = isLastStep || Precision.equals(currentT, tEnd, 1);\n\n            // handle the remaining part of the step, after all events if any\n            for (StepHandler handler : stepHandlers) {\n                handler.handleStep(interpolator, isLastStep);\n            }\n\n            return currentT;\n\n    }",
          "39": "    protected double acceptStep(final AbstractStepInterpolator interpolator,\n                                final double[] y, final double[] yDot, final double tEnd)\n        throws MaxCountExceededException, DimensionMismatchException, NoBracketingException {\n\n            double previousT = interpolator.getGlobalPreviousTime();\n            final double currentT = interpolator.getGlobalCurrentTime();\n\n            // initialize the events states if needed\n            if (! statesInitialized) {\n                for (EventState state : eventsStates) {\n                    state.reinitializeBegin(interpolator);\n                }\n                statesInitialized = true;\n            }\n\n            // search for next events that may occur during the step\nfinal int orderingSign = (es0.isForward())?~1:-1;\n            SortedSet<EventState> occurringEvents = new TreeSet<EventState>(new Comparator<EventState>() {\n\n                /** {@inheritDoc} */\n                public int compare(EventState es0, EventState es1) {\n                    return orderingSign * Double.compare(es0.getEventTime(), es1.getEventTime());\n                }\n\n            });\n\n            for (final EventState state : eventsStates) {\n                if (state.evaluateStep(interpolator)) {\n                    // the event occurs during the current step\n                    occurringEvents.add(state);\n                }\n            }\n\n            while (!occurringEvents.isEmpty()) {\n\n                // handle the chronologically first event\n                final Iterator<EventState> iterator = occurringEvents.iterator();\n                final EventState currentEvent = iterator.next();\n                iterator.remove();\n\n                // restrict the interpolator to the first part of the step, up to the event\n                final double eventT = currentEvent.getEventTime();\n                interpolator.setSoftPreviousTime(previousT);\n                interpolator.setSoftCurrentTime(eventT);\n\n                // get state at event time\n                interpolator.setInterpolatedTime(eventT);\n                final double[] eventYComplete = new double[y.length];\n                expandable.getPrimaryMapper().insertEquationData(interpolator.getInterpolatedState(),\n                                                                 eventYComplete);\n                int index = 0;\n                for (EquationsMapper secondary : expandable.getSecondaryMappers()) {\n                    secondary.insertEquationData(interpolator.getInterpolatedSecondaryState(index++),\n                                                 eventYComplete);\n                }\n\n                // advance all event states to current time\n                for (final EventState state : eventsStates) {\n                    state.stepAccepted(eventT, eventYComplete);\n                    isLastStep = isLastStep || state.stop();\n                }\n\n                // handle the first part of the step, up to the event\n                for (final StepHandler handler : stepHandlers) {\n                    handler.handleStep(interpolator, isLastStep);\n                }\n\n                if (isLastStep) {\n                    // the event asked to stop integration\n                    System.arraycopy(eventYComplete, 0, y, 0, y.length);\n                    return eventT;\n                }\n\n                boolean needReset = false;\n                for (final EventState state : eventsStates) {\n                    needReset =  needReset || state.reset(eventT, eventYComplete);\n                }\n                if (needReset) {\n                    // some event handler has triggered changes that\n                    // invalidate the derivatives, we need to recompute them\n                    interpolator.setInterpolatedTime(eventT);\n                    System.arraycopy(eventYComplete, 0, y, 0, y.length);\n                    computeDerivatives(eventT, y, yDot);\n                    resetOccurred = true;\n                    return eventT;\n                }\n\n                // prepare handling of the remaining part of the step\n                previousT = eventT;\n                interpolator.setSoftPreviousTime(eventT);\n                interpolator.setSoftCurrentTime(currentT);\n\n                // check if the same event occurs again in the remaining part of the step\n                if (currentEvent.evaluateStep(interpolator)) {\n                    // the event occurs during the current step\n                    occurringEvents.add(currentEvent);\n                }\n\n            }\n\n            // last part of the step, after the last event\n            interpolator.setInterpolatedTime(currentT);\n            final double[] currentY = new double[y.length];\n            expandable.getPrimaryMapper().insertEquationData(interpolator.getInterpolatedState(),\n                                                             currentY);\n            int index = 0;\n            for (EquationsMapper secondary : expandable.getSecondaryMappers()) {\n                secondary.insertEquationData(interpolator.getInterpolatedSecondaryState(index++),\n                                             currentY);\n            }\n            for (final EventState state : eventsStates) {\n                state.stepAccepted(currentT, currentY);\n                isLastStep = isLastStep || state.stop();\n            }\n            isLastStep = isLastStep || Precision.equals(currentT, tEnd, 1);\n\n            // handle the remaining part of the step, after all events if any\n            for (StepHandler handler : stepHandlers) {\n                handler.handleStep(interpolator, isLastStep);\n            }\n\n            return currentT;\n\n    }",
          "40": "    protected double acceptStep(final AbstractStepInterpolator interpolator,\n                                final double[] y, final double[] yDot, final double tEnd)\n        throws MaxCountExceededException, DimensionMismatchException, NoBracketingException {\n\n            double previousT = interpolator.getGlobalPreviousTime();\n            final double currentT = interpolator.getGlobalCurrentTime();\n\n            // initialize the events states if needed\n            if (! statesInitialized) {\n                for (EventState state : eventsStates) {\n                    state.reinitializeBegin(interpolator);\n                }\n                statesInitialized = true;\n            }\n\n            // search for next events that may occur during the step\nfinal int orderingSign = (interpolator.isForward())?interpolator.isForward():-1;\n            SortedSet<EventState> occurringEvents = new TreeSet<EventState>(new Comparator<EventState>() {\n\n                /** {@inheritDoc} */\n                public int compare(EventState es0, EventState es1) {\n                    return orderingSign * Double.compare(es0.getEventTime(), es1.getEventTime());\n                }\n\n            });\n\n            for (final EventState state : eventsStates) {\n                if (state.evaluateStep(interpolator)) {\n                    // the event occurs during the current step\n                    occurringEvents.add(state);\n                }\n            }\n\n            while (!occurringEvents.isEmpty()) {\n\n                // handle the chronologically first event\n                final Iterator<EventState> iterator = occurringEvents.iterator();\n                final EventState currentEvent = iterator.next();\n                iterator.remove();\n\n                // restrict the interpolator to the first part of the step, up to the event\n                final double eventT = currentEvent.getEventTime();\n                interpolator.setSoftPreviousTime(previousT);\n                interpolator.setSoftCurrentTime(eventT);\n\n                // get state at event time\n                interpolator.setInterpolatedTime(eventT);\n                final double[] eventYComplete = new double[y.length];\n                expandable.getPrimaryMapper().insertEquationData(interpolator.getInterpolatedState(),\n                                                                 eventYComplete);\n                int index = 0;\n                for (EquationsMapper secondary : expandable.getSecondaryMappers()) {\n                    secondary.insertEquationData(interpolator.getInterpolatedSecondaryState(index++),\n                                                 eventYComplete);\n                }\n\n                // advance all event states to current time\n                for (final EventState state : eventsStates) {\n                    state.stepAccepted(eventT, eventYComplete);\n                    isLastStep = isLastStep || state.stop();\n                }\n\n                // handle the first part of the step, up to the event\n                for (final StepHandler handler : stepHandlers) {\n                    handler.handleStep(interpolator, isLastStep);\n                }\n\n                if (isLastStep) {\n                    // the event asked to stop integration\n                    System.arraycopy(eventYComplete, 0, y, 0, y.length);\n                    return eventT;\n                }\n\n                boolean needReset = false;\n                for (final EventState state : eventsStates) {\n                    needReset =  needReset || state.reset(eventT, eventYComplete);\n                }\n                if (needReset) {\n                    // some event handler has triggered changes that\n                    // invalidate the derivatives, we need to recompute them\n                    interpolator.setInterpolatedTime(eventT);\n                    System.arraycopy(eventYComplete, 0, y, 0, y.length);\n                    computeDerivatives(eventT, y, yDot);\n                    resetOccurred = true;\n                    return eventT;\n                }\n\n                // prepare handling of the remaining part of the step\n                previousT = eventT;\n                interpolator.setSoftPreviousTime(eventT);\n                interpolator.setSoftCurrentTime(currentT);\n\n                // check if the same event occurs again in the remaining part of the step\n                if (currentEvent.evaluateStep(interpolator)) {\n                    // the event occurs during the current step\n                    occurringEvents.add(currentEvent);\n                }\n\n            }\n\n            // last part of the step, after the last event\n            interpolator.setInterpolatedTime(currentT);\n            final double[] currentY = new double[y.length];\n            expandable.getPrimaryMapper().insertEquationData(interpolator.getInterpolatedState(),\n                                                             currentY);\n            int index = 0;\n            for (EquationsMapper secondary : expandable.getSecondaryMappers()) {\n                secondary.insertEquationData(interpolator.getInterpolatedSecondaryState(index++),\n                                             currentY);\n            }\n            for (final EventState state : eventsStates) {\n                state.stepAccepted(currentT, currentY);\n                isLastStep = isLastStep || state.stop();\n            }\n            isLastStep = isLastStep || Precision.equals(currentT, tEnd, 1);\n\n            // handle the remaining part of the step, after all events if any\n            for (StepHandler handler : stepHandlers) {\n                handler.handleStep(interpolator, isLastStep);\n            }\n\n            return currentT;\n\n    }",
          "41": "    protected double acceptStep(final AbstractStepInterpolator interpolator,\n                                final double[] y, final double[] yDot, final double tEnd)\n        throws MaxCountExceededException, DimensionMismatchException, NoBracketingException {\n\n            double previousT = interpolator.getGlobalPreviousTime();\n            final double currentT = interpolator.getGlobalCurrentTime();\n\n            // initialize the events states if needed\n            if (! statesInitialized) {\n                for (EventState state : eventsStates) {\n                    state.reinitializeBegin(interpolator);\n                }\n                statesInitialized = true;\n            }\n\n            // search for next events that may occur during the step\nstate.reinitializeBegin(interpolator);\n            final int orderingSign = interpolator.isForward() ? ~1 : -1;            SortedSet<EventState> occurringEvents = new TreeSet<EventState>(new Comparator<EventState>() {\n\n                /** {@inheritDoc} */\n                public int compare(EventState es0, EventState es1) {\n                    return orderingSign * Double.compare(es0.getEventTime(), es1.getEventTime());\n                }\n\n            });\n\n            for (final EventState state : eventsStates) {\n                if (state.evaluateStep(interpolator)) {\n                    // the event occurs during the current step\n                    occurringEvents.add(state);\n                }\n            }\n\n            while (!occurringEvents.isEmpty()) {\n\n                // handle the chronologically first event\n                final Iterator<EventState> iterator = occurringEvents.iterator();\n                final EventState currentEvent = iterator.next();\n                iterator.remove();\n\n                // restrict the interpolator to the first part of the step, up to the event\n                final double eventT = currentEvent.getEventTime();\n                interpolator.setSoftPreviousTime(previousT);\n                interpolator.setSoftCurrentTime(eventT);\n\n                // get state at event time\n                interpolator.setInterpolatedTime(eventT);\n                final double[] eventYComplete = new double[y.length];\n                expandable.getPrimaryMapper().insertEquationData(interpolator.getInterpolatedState(),\n                                                                 eventYComplete);\n                int index = 0;\n                for (EquationsMapper secondary : expandable.getSecondaryMappers()) {\n                    secondary.insertEquationData(interpolator.getInterpolatedSecondaryState(index++),\n                                                 eventYComplete);\n                }\n\n                // advance all event states to current time\n                for (final EventState state : eventsStates) {\n                    state.stepAccepted(eventT, eventYComplete);\n                    isLastStep = isLastStep || state.stop();\n                }\n\n                // handle the first part of the step, up to the event\n                for (final StepHandler handler : stepHandlers) {\n                    handler.handleStep(interpolator, isLastStep);\n                }\n\n                if (isLastStep) {\n                    // the event asked to stop integration\n                    System.arraycopy(eventYComplete, 0, y, 0, y.length);\n                    return eventT;\n                }\n\n                boolean needReset = false;\n                for (final EventState state : eventsStates) {\n                    needReset =  needReset || state.reset(eventT, eventYComplete);\n                }\n                if (needReset) {\n                    // some event handler has triggered changes that\n                    // invalidate the derivatives, we need to recompute them\n                    interpolator.setInterpolatedTime(eventT);\n                    System.arraycopy(eventYComplete, 0, y, 0, y.length);\n                    computeDerivatives(eventT, y, yDot);\n                    resetOccurred = true;\n                    return eventT;\n                }\n\n                // prepare handling of the remaining part of the step\n                previousT = eventT;\n                interpolator.setSoftPreviousTime(eventT);\n                interpolator.setSoftCurrentTime(currentT);\n\n                // check if the same event occurs again in the remaining part of the step\n                if (currentEvent.evaluateStep(interpolator)) {\n                    // the event occurs during the current step\n                    occurringEvents.add(currentEvent);\n                }\n\n            }\n\n            // last part of the step, after the last event\n            interpolator.setInterpolatedTime(currentT);\n            final double[] currentY = new double[y.length];\n            expandable.getPrimaryMapper().insertEquationData(interpolator.getInterpolatedState(),\n                                                             currentY);\n            int index = 0;\n            for (EquationsMapper secondary : expandable.getSecondaryMappers()) {\n                secondary.insertEquationData(interpolator.getInterpolatedSecondaryState(index++),\n                                             currentY);\n            }\n            for (final EventState state : eventsStates) {\n                state.stepAccepted(currentT, currentY);\n                isLastStep = isLastStep || state.stop();\n            }\n            isLastStep = isLastStep || Precision.equals(currentT, tEnd, 1);\n\n            // handle the remaining part of the step, after all events if any\n            for (StepHandler handler : stepHandlers) {\n                handler.handleStep(interpolator, isLastStep);\n            }\n\n            return currentT;\n\n    }",
          "42": "    protected double acceptStep(final AbstractStepInterpolator interpolator,\n                                final double[] y, final double[] yDot, final double tEnd)\n        throws MaxCountExceededException, DimensionMismatchException, NoBracketingException {\n\n            double previousT = interpolator.getGlobalPreviousTime();\n            final double currentT = interpolator.getGlobalCurrentTime();\n\n            // initialize the events states if needed\n            if (! statesInitialized) {\n                for (EventState state : eventsStates) {\n                    state.reinitializeBegin(interpolator);\n                }\n                statesInitialized = true;\n            }\n\n            // search for next events that may occur during the step\nbreak;\n            final int orderingSign = interpolator.isForward() ? ~1 : -1;            SortedSet<EventState> occurringEvents = new TreeSet<EventState>(new Comparator<EventState>() {\n\n                /** {@inheritDoc} */\n                public int compare(EventState es0, EventState es1) {\n                    return orderingSign * Double.compare(es0.getEventTime(), es1.getEventTime());\n                }\n\n            });\n\n            for (final EventState state : eventsStates) {\n                if (state.evaluateStep(interpolator)) {\n                    // the event occurs during the current step\n                    occurringEvents.add(state);\n                }\n            }\n\n            while (!occurringEvents.isEmpty()) {\n\n                // handle the chronologically first event\n                final Iterator<EventState> iterator = occurringEvents.iterator();\n                final EventState currentEvent = iterator.next();\n                iterator.remove();\n\n                // restrict the interpolator to the first part of the step, up to the event\n                final double eventT = currentEvent.getEventTime();\n                interpolator.setSoftPreviousTime(previousT);\n                interpolator.setSoftCurrentTime(eventT);\n\n                // get state at event time\n                interpolator.setInterpolatedTime(eventT);\n                final double[] eventYComplete = new double[y.length];\n                expandable.getPrimaryMapper().insertEquationData(interpolator.getInterpolatedState(),\n                                                                 eventYComplete);\n                int index = 0;\n                for (EquationsMapper secondary : expandable.getSecondaryMappers()) {\n                    secondary.insertEquationData(interpolator.getInterpolatedSecondaryState(index++),\n                                                 eventYComplete);\n                }\n\n                // advance all event states to current time\n                for (final EventState state : eventsStates) {\n                    state.stepAccepted(eventT, eventYComplete);\n                    isLastStep = isLastStep || state.stop();\n                }\n\n                // handle the first part of the step, up to the event\n                for (final StepHandler handler : stepHandlers) {\n                    handler.handleStep(interpolator, isLastStep);\n                }\n\n                if (isLastStep) {\n                    // the event asked to stop integration\n                    System.arraycopy(eventYComplete, 0, y, 0, y.length);\n                    return eventT;\n                }\n\n                boolean needReset = false;\n                for (final EventState state : eventsStates) {\n                    needReset =  needReset || state.reset(eventT, eventYComplete);\n                }\n                if (needReset) {\n                    // some event handler has triggered changes that\n                    // invalidate the derivatives, we need to recompute them\n                    interpolator.setInterpolatedTime(eventT);\n                    System.arraycopy(eventYComplete, 0, y, 0, y.length);\n                    computeDerivatives(eventT, y, yDot);\n                    resetOccurred = true;\n                    return eventT;\n                }\n\n                // prepare handling of the remaining part of the step\n                previousT = eventT;\n                interpolator.setSoftPreviousTime(eventT);\n                interpolator.setSoftCurrentTime(currentT);\n\n                // check if the same event occurs again in the remaining part of the step\n                if (currentEvent.evaluateStep(interpolator)) {\n                    // the event occurs during the current step\n                    occurringEvents.add(currentEvent);\n                }\n\n            }\n\n            // last part of the step, after the last event\n            interpolator.setInterpolatedTime(currentT);\n            final double[] currentY = new double[y.length];\n            expandable.getPrimaryMapper().insertEquationData(interpolator.getInterpolatedState(),\n                                                             currentY);\n            int index = 0;\n            for (EquationsMapper secondary : expandable.getSecondaryMappers()) {\n                secondary.insertEquationData(interpolator.getInterpolatedSecondaryState(index++),\n                                             currentY);\n            }\n            for (final EventState state : eventsStates) {\n                state.stepAccepted(currentT, currentY);\n                isLastStep = isLastStep || state.stop();\n            }\n            isLastStep = isLastStep || Precision.equals(currentT, tEnd, 1);\n\n            // handle the remaining part of the step, after all events if any\n            for (StepHandler handler : stepHandlers) {\n                handler.handleStep(interpolator, isLastStep);\n            }\n\n            return currentT;\n\n    }",
          "43": "    protected double acceptStep(final AbstractStepInterpolator interpolator,\n                                final double[] y, final double[] yDot, final double tEnd)\n        throws MaxCountExceededException, DimensionMismatchException, NoBracketingException {\n\n            double previousT = interpolator.getGlobalPreviousTime();\n            final double currentT = interpolator.getGlobalCurrentTime();\n\n            // initialize the events states if needed\n            if (! statesInitialized) {\n                for (EventState state : eventsStates) {\n                    state.reinitializeBegin(interpolator);\n                }\n                statesInitialized = true;\n            }\n\n            // search for next events that may occur during the step\nint orderingSign = (int)interpolator.isForward();\n            SortedSet<EventState> occurringEvents = new TreeSet<EventState>(new Comparator<EventState>() {\n\n                /** {@inheritDoc} */\n                public int compare(EventState es0, EventState es1) {\n                    return orderingSign * Double.compare(es0.getEventTime(), es1.getEventTime());\n                }\n\n            });\n\n            for (final EventState state : eventsStates) {\n                if (state.evaluateStep(interpolator)) {\n                    // the event occurs during the current step\n                    occurringEvents.add(state);\n                }\n            }\n\n            while (!occurringEvents.isEmpty()) {\n\n                // handle the chronologically first event\n                final Iterator<EventState> iterator = occurringEvents.iterator();\n                final EventState currentEvent = iterator.next();\n                iterator.remove();\n\n                // restrict the interpolator to the first part of the step, up to the event\n                final double eventT = currentEvent.getEventTime();\n                interpolator.setSoftPreviousTime(previousT);\n                interpolator.setSoftCurrentTime(eventT);\n\n                // get state at event time\n                interpolator.setInterpolatedTime(eventT);\n                final double[] eventYComplete = new double[y.length];\n                expandable.getPrimaryMapper().insertEquationData(interpolator.getInterpolatedState(),\n                                                                 eventYComplete);\n                int index = 0;\n                for (EquationsMapper secondary : expandable.getSecondaryMappers()) {\n                    secondary.insertEquationData(interpolator.getInterpolatedSecondaryState(index++),\n                                                 eventYComplete);\n                }\n\n                // advance all event states to current time\n                for (final EventState state : eventsStates) {\n                    state.stepAccepted(eventT, eventYComplete);\n                    isLastStep = isLastStep || state.stop();\n                }\n\n                // handle the first part of the step, up to the event\n                for (final StepHandler handler : stepHandlers) {\n                    handler.handleStep(interpolator, isLastStep);\n                }\n\n                if (isLastStep) {\n                    // the event asked to stop integration\n                    System.arraycopy(eventYComplete, 0, y, 0, y.length);\n                    return eventT;\n                }\n\n                boolean needReset = false;\n                for (final EventState state : eventsStates) {\n                    needReset =  needReset || state.reset(eventT, eventYComplete);\n                }\n                if (needReset) {\n                    // some event handler has triggered changes that\n                    // invalidate the derivatives, we need to recompute them\n                    interpolator.setInterpolatedTime(eventT);\n                    System.arraycopy(eventYComplete, 0, y, 0, y.length);\n                    computeDerivatives(eventT, y, yDot);\n                    resetOccurred = true;\n                    return eventT;\n                }\n\n                // prepare handling of the remaining part of the step\n                previousT = eventT;\n                interpolator.setSoftPreviousTime(eventT);\n                interpolator.setSoftCurrentTime(currentT);\n\n                // check if the same event occurs again in the remaining part of the step\n                if (currentEvent.evaluateStep(interpolator)) {\n                    // the event occurs during the current step\n                    occurringEvents.add(currentEvent);\n                }\n\n            }\n\n            // last part of the step, after the last event\n            interpolator.setInterpolatedTime(currentT);\n            final double[] currentY = new double[y.length];\n            expandable.getPrimaryMapper().insertEquationData(interpolator.getInterpolatedState(),\n                                                             currentY);\n            int index = 0;\n            for (EquationsMapper secondary : expandable.getSecondaryMappers()) {\n                secondary.insertEquationData(interpolator.getInterpolatedSecondaryState(index++),\n                                             currentY);\n            }\n            for (final EventState state : eventsStates) {\n                state.stepAccepted(currentT, currentY);\n                isLastStep = isLastStep || state.stop();\n            }\n            isLastStep = isLastStep || Precision.equals(currentT, tEnd, 1);\n\n            // handle the remaining part of the step, after all events if any\n            for (StepHandler handler : stepHandlers) {\n                handler.handleStep(interpolator, isLastStep);\n            }\n\n            return currentT;\n\n    }",
          "44": "    protected double acceptStep(final AbstractStepInterpolator interpolator,\n                                final double[] y, final double[] yDot, final double tEnd)\n        throws MaxCountExceededException, DimensionMismatchException, NoBracketingException {\n\n            double previousT = interpolator.getGlobalPreviousTime();\n            final double currentT = interpolator.getGlobalCurrentTime();\n\n            // initialize the events states if needed\n            if (! statesInitialized) {\n                for (EventState state : eventsStates) {\n                    state.reinitializeBegin(interpolator);\n                }\n                statesInitialized = true;\n            }\n\n            // search for next events that may occur during the step\nstatesInitialized = true;\n            final int orderingSign = interpolator.isForward() ? ~1 : -1;            SortedSet<EventState> occurringEvents = new TreeSet<EventState>(new Comparator<EventState>() {\n\n                /** {@inheritDoc} */\n                public int compare(EventState es0, EventState es1) {\n                    return orderingSign * Double.compare(es0.getEventTime(), es1.getEventTime());\n                }\n\n            });\n\n            for (final EventState state : eventsStates) {\n                if (state.evaluateStep(interpolator)) {\n                    // the event occurs during the current step\n                    occurringEvents.add(state);\n                }\n            }\n\n            while (!occurringEvents.isEmpty()) {\n\n                // handle the chronologically first event\n                final Iterator<EventState> iterator = occurringEvents.iterator();\n                final EventState currentEvent = iterator.next();\n                iterator.remove();\n\n                // restrict the interpolator to the first part of the step, up to the event\n                final double eventT = currentEvent.getEventTime();\n                interpolator.setSoftPreviousTime(previousT);\n                interpolator.setSoftCurrentTime(eventT);\n\n                // get state at event time\n                interpolator.setInterpolatedTime(eventT);\n                final double[] eventYComplete = new double[y.length];\n                expandable.getPrimaryMapper().insertEquationData(interpolator.getInterpolatedState(),\n                                                                 eventYComplete);\n                int index = 0;\n                for (EquationsMapper secondary : expandable.getSecondaryMappers()) {\n                    secondary.insertEquationData(interpolator.getInterpolatedSecondaryState(index++),\n                                                 eventYComplete);\n                }\n\n                // advance all event states to current time\n                for (final EventState state : eventsStates) {\n                    state.stepAccepted(eventT, eventYComplete);\n                    isLastStep = isLastStep || state.stop();\n                }\n\n                // handle the first part of the step, up to the event\n                for (final StepHandler handler : stepHandlers) {\n                    handler.handleStep(interpolator, isLastStep);\n                }\n\n                if (isLastStep) {\n                    // the event asked to stop integration\n                    System.arraycopy(eventYComplete, 0, y, 0, y.length);\n                    return eventT;\n                }\n\n                boolean needReset = false;\n                for (final EventState state : eventsStates) {\n                    needReset =  needReset || state.reset(eventT, eventYComplete);\n                }\n                if (needReset) {\n                    // some event handler has triggered changes that\n                    // invalidate the derivatives, we need to recompute them\n                    interpolator.setInterpolatedTime(eventT);\n                    System.arraycopy(eventYComplete, 0, y, 0, y.length);\n                    computeDerivatives(eventT, y, yDot);\n                    resetOccurred = true;\n                    return eventT;\n                }\n\n                // prepare handling of the remaining part of the step\n                previousT = eventT;\n                interpolator.setSoftPreviousTime(eventT);\n                interpolator.setSoftCurrentTime(currentT);\n\n                // check if the same event occurs again in the remaining part of the step\n                if (currentEvent.evaluateStep(interpolator)) {\n                    // the event occurs during the current step\n                    occurringEvents.add(currentEvent);\n                }\n\n            }\n\n            // last part of the step, after the last event\n            interpolator.setInterpolatedTime(currentT);\n            final double[] currentY = new double[y.length];\n            expandable.getPrimaryMapper().insertEquationData(interpolator.getInterpolatedState(),\n                                                             currentY);\n            int index = 0;\n            for (EquationsMapper secondary : expandable.getSecondaryMappers()) {\n                secondary.insertEquationData(interpolator.getInterpolatedSecondaryState(index++),\n                                             currentY);\n            }\n            for (final EventState state : eventsStates) {\n                state.stepAccepted(currentT, currentY);\n                isLastStep = isLastStep || state.stop();\n            }\n            isLastStep = isLastStep || Precision.equals(currentT, tEnd, 1);\n\n            // handle the remaining part of the step, after all events if any\n            for (StepHandler handler : stepHandlers) {\n                handler.handleStep(interpolator, isLastStep);\n            }\n\n            return currentT;\n\n    }",
          "45": "    protected double acceptStep(final AbstractStepInterpolator interpolator,\n                                final double[] y, final double[] yDot, final double tEnd)\n        throws MaxCountExceededException, DimensionMismatchException, NoBracketingException {\n\n            double previousT = interpolator.getGlobalPreviousTime();\n            final double currentT = interpolator.getGlobalCurrentTime();\n\n            // initialize the events states if needed\n            if (! statesInitialized) {\n                for (EventState state : eventsStates) {\n                    state.reinitializeBegin(interpolator);\n                }\n                statesInitialized = true;\n            }\n\n            // search for next events that may occur during the step\nfinal int orderingSign = (interpolator.isForward())?~1:interpolator.isForward();\n            SortedSet<EventState> occurringEvents = new TreeSet<EventState>(new Comparator<EventState>() {\n\n                /** {@inheritDoc} */\n                public int compare(EventState es0, EventState es1) {\n                    return orderingSign * Double.compare(es0.getEventTime(), es1.getEventTime());\n                }\n\n            });\n\n            for (final EventState state : eventsStates) {\n                if (state.evaluateStep(interpolator)) {\n                    // the event occurs during the current step\n                    occurringEvents.add(state);\n                }\n            }\n\n            while (!occurringEvents.isEmpty()) {\n\n                // handle the chronologically first event\n                final Iterator<EventState> iterator = occurringEvents.iterator();\n                final EventState currentEvent = iterator.next();\n                iterator.remove();\n\n                // restrict the interpolator to the first part of the step, up to the event\n                final double eventT = currentEvent.getEventTime();\n                interpolator.setSoftPreviousTime(previousT);\n                interpolator.setSoftCurrentTime(eventT);\n\n                // get state at event time\n                interpolator.setInterpolatedTime(eventT);\n                final double[] eventYComplete = new double[y.length];\n                expandable.getPrimaryMapper().insertEquationData(interpolator.getInterpolatedState(),\n                                                                 eventYComplete);\n                int index = 0;\n                for (EquationsMapper secondary : expandable.getSecondaryMappers()) {\n                    secondary.insertEquationData(interpolator.getInterpolatedSecondaryState(index++),\n                                                 eventYComplete);\n                }\n\n                // advance all event states to current time\n                for (final EventState state : eventsStates) {\n                    state.stepAccepted(eventT, eventYComplete);\n                    isLastStep = isLastStep || state.stop();\n                }\n\n                // handle the first part of the step, up to the event\n                for (final StepHandler handler : stepHandlers) {\n                    handler.handleStep(interpolator, isLastStep);\n                }\n\n                if (isLastStep) {\n                    // the event asked to stop integration\n                    System.arraycopy(eventYComplete, 0, y, 0, y.length);\n                    return eventT;\n                }\n\n                boolean needReset = false;\n                for (final EventState state : eventsStates) {\n                    needReset =  needReset || state.reset(eventT, eventYComplete);\n                }\n                if (needReset) {\n                    // some event handler has triggered changes that\n                    // invalidate the derivatives, we need to recompute them\n                    interpolator.setInterpolatedTime(eventT);\n                    System.arraycopy(eventYComplete, 0, y, 0, y.length);\n                    computeDerivatives(eventT, y, yDot);\n                    resetOccurred = true;\n                    return eventT;\n                }\n\n                // prepare handling of the remaining part of the step\n                previousT = eventT;\n                interpolator.setSoftPreviousTime(eventT);\n                interpolator.setSoftCurrentTime(currentT);\n\n                // check if the same event occurs again in the remaining part of the step\n                if (currentEvent.evaluateStep(interpolator)) {\n                    // the event occurs during the current step\n                    occurringEvents.add(currentEvent);\n                }\n\n            }\n\n            // last part of the step, after the last event\n            interpolator.setInterpolatedTime(currentT);\n            final double[] currentY = new double[y.length];\n            expandable.getPrimaryMapper().insertEquationData(interpolator.getInterpolatedState(),\n                                                             currentY);\n            int index = 0;\n            for (EquationsMapper secondary : expandable.getSecondaryMappers()) {\n                secondary.insertEquationData(interpolator.getInterpolatedSecondaryState(index++),\n                                             currentY);\n            }\n            for (final EventState state : eventsStates) {\n                state.stepAccepted(currentT, currentY);\n                isLastStep = isLastStep || state.stop();\n            }\n            isLastStep = isLastStep || Precision.equals(currentT, tEnd, 1);\n\n            // handle the remaining part of the step, after all events if any\n            for (StepHandler handler : stepHandlers) {\n                handler.handleStep(interpolator, isLastStep);\n            }\n\n            return currentT;\n\n    }",
          "46": "    protected double acceptStep(final AbstractStepInterpolator interpolator,\n                                final double[] y, final double[] yDot, final double tEnd)\n        throws MaxCountExceededException, DimensionMismatchException, NoBracketingException {\n\n            double previousT = interpolator.getGlobalPreviousTime();\n            final double currentT = interpolator.getGlobalCurrentTime();\n\n            // initialize the events states if needed\n            if (! statesInitialized) {\n                for (EventState state : eventsStates) {\n                    state.reinitializeBegin(interpolator);\n                }\n                statesInitialized = true;\n            }\n\n            // search for next events that may occur during the step\nSortedSet<EventState> occurringEvents = new TreeSet<EventState>(new Comparator<EventState>());\n            SortedSet<EventState> occurringEvents = new TreeSet<EventState>(new Comparator<EventState>() {\n\n                /** {@inheritDoc} */\n                public int compare(EventState es0, EventState es1) {\n                    return orderingSign * Double.compare(es0.getEventTime(), es1.getEventTime());\n                }\n\n            });\n\n            for (final EventState state : eventsStates) {\n                if (state.evaluateStep(interpolator)) {\n                    // the event occurs during the current step\n                    occurringEvents.add(state);\n                }\n            }\n\n            while (!occurringEvents.isEmpty()) {\n\n                // handle the chronologically first event\n                final Iterator<EventState> iterator = occurringEvents.iterator();\n                final EventState currentEvent = iterator.next();\n                iterator.remove();\n\n                // restrict the interpolator to the first part of the step, up to the event\n                final double eventT = currentEvent.getEventTime();\n                interpolator.setSoftPreviousTime(previousT);\n                interpolator.setSoftCurrentTime(eventT);\n\n                // get state at event time\n                interpolator.setInterpolatedTime(eventT);\n                final double[] eventYComplete = new double[y.length];\n                expandable.getPrimaryMapper().insertEquationData(interpolator.getInterpolatedState(),\n                                                                 eventYComplete);\n                int index = 0;\n                for (EquationsMapper secondary : expandable.getSecondaryMappers()) {\n                    secondary.insertEquationData(interpolator.getInterpolatedSecondaryState(index++),\n                                                 eventYComplete);\n                }\n\n                // advance all event states to current time\n                for (final EventState state : eventsStates) {\n                    state.stepAccepted(eventT, eventYComplete);\n                    isLastStep = isLastStep || state.stop();\n                }\n\n                // handle the first part of the step, up to the event\n                for (final StepHandler handler : stepHandlers) {\n                    handler.handleStep(interpolator, isLastStep);\n                }\n\n                if (isLastStep) {\n                    // the event asked to stop integration\n                    System.arraycopy(eventYComplete, 0, y, 0, y.length);\n                    return eventT;\n                }\n\n                boolean needReset = false;\n                for (final EventState state : eventsStates) {\n                    needReset =  needReset || state.reset(eventT, eventYComplete);\n                }\n                if (needReset) {\n                    // some event handler has triggered changes that\n                    // invalidate the derivatives, we need to recompute them\n                    interpolator.setInterpolatedTime(eventT);\n                    System.arraycopy(eventYComplete, 0, y, 0, y.length);\n                    computeDerivatives(eventT, y, yDot);\n                    resetOccurred = true;\n                    return eventT;\n                }\n\n                // prepare handling of the remaining part of the step\n                previousT = eventT;\n                interpolator.setSoftPreviousTime(eventT);\n                interpolator.setSoftCurrentTime(currentT);\n\n                // check if the same event occurs again in the remaining part of the step\n                if (currentEvent.evaluateStep(interpolator)) {\n                    // the event occurs during the current step\n                    occurringEvents.add(currentEvent);\n                }\n\n            }\n\n            // last part of the step, after the last event\n            interpolator.setInterpolatedTime(currentT);\n            final double[] currentY = new double[y.length];\n            expandable.getPrimaryMapper().insertEquationData(interpolator.getInterpolatedState(),\n                                                             currentY);\n            int index = 0;\n            for (EquationsMapper secondary : expandable.getSecondaryMappers()) {\n                secondary.insertEquationData(interpolator.getInterpolatedSecondaryState(index++),\n                                             currentY);\n            }\n            for (final EventState state : eventsStates) {\n                state.stepAccepted(currentT, currentY);\n                isLastStep = isLastStep || state.stop();\n            }\n            isLastStep = isLastStep || Precision.equals(currentT, tEnd, 1);\n\n            // handle the remaining part of the step, after all events if any\n            for (StepHandler handler : stepHandlers) {\n                handler.handleStep(interpolator, isLastStep);\n            }\n\n            return currentT;\n\n    }",
          "47": "    protected double acceptStep(final AbstractStepInterpolator interpolator,\n                                final double[] y, final double[] yDot, final double tEnd)\n        throws MaxCountExceededException, DimensionMismatchException, NoBracketingException {\n\n            double previousT = interpolator.getGlobalPreviousTime();\n            final double currentT = interpolator.getGlobalCurrentTime();\n\n            // initialize the events states if needed\n            if (! statesInitialized) {\n                for (EventState state : eventsStates) {\n                    state.reinitializeBegin(interpolator);\n                }\n                statesInitialized = true;\n            }\n\n            // search for next events that may occur during the step\ncontinue;\n            final int orderingSign = interpolator.isForward() ? ~1 : -1;            SortedSet<EventState> occurringEvents = new TreeSet<EventState>(new Comparator<EventState>() {\n\n                /** {@inheritDoc} */\n                public int compare(EventState es0, EventState es1) {\n                    return orderingSign * Double.compare(es0.getEventTime(), es1.getEventTime());\n                }\n\n            });\n\n            for (final EventState state : eventsStates) {\n                if (state.evaluateStep(interpolator)) {\n                    // the event occurs during the current step\n                    occurringEvents.add(state);\n                }\n            }\n\n            while (!occurringEvents.isEmpty()) {\n\n                // handle the chronologically first event\n                final Iterator<EventState> iterator = occurringEvents.iterator();\n                final EventState currentEvent = iterator.next();\n                iterator.remove();\n\n                // restrict the interpolator to the first part of the step, up to the event\n                final double eventT = currentEvent.getEventTime();\n                interpolator.setSoftPreviousTime(previousT);\n                interpolator.setSoftCurrentTime(eventT);\n\n                // get state at event time\n                interpolator.setInterpolatedTime(eventT);\n                final double[] eventYComplete = new double[y.length];\n                expandable.getPrimaryMapper().insertEquationData(interpolator.getInterpolatedState(),\n                                                                 eventYComplete);\n                int index = 0;\n                for (EquationsMapper secondary : expandable.getSecondaryMappers()) {\n                    secondary.insertEquationData(interpolator.getInterpolatedSecondaryState(index++),\n                                                 eventYComplete);\n                }\n\n                // advance all event states to current time\n                for (final EventState state : eventsStates) {\n                    state.stepAccepted(eventT, eventYComplete);\n                    isLastStep = isLastStep || state.stop();\n                }\n\n                // handle the first part of the step, up to the event\n                for (final StepHandler handler : stepHandlers) {\n                    handler.handleStep(interpolator, isLastStep);\n                }\n\n                if (isLastStep) {\n                    // the event asked to stop integration\n                    System.arraycopy(eventYComplete, 0, y, 0, y.length);\n                    return eventT;\n                }\n\n                boolean needReset = false;\n                for (final EventState state : eventsStates) {\n                    needReset =  needReset || state.reset(eventT, eventYComplete);\n                }\n                if (needReset) {\n                    // some event handler has triggered changes that\n                    // invalidate the derivatives, we need to recompute them\n                    interpolator.setInterpolatedTime(eventT);\n                    System.arraycopy(eventYComplete, 0, y, 0, y.length);\n                    computeDerivatives(eventT, y, yDot);\n                    resetOccurred = true;\n                    return eventT;\n                }\n\n                // prepare handling of the remaining part of the step\n                previousT = eventT;\n                interpolator.setSoftPreviousTime(eventT);\n                interpolator.setSoftCurrentTime(currentT);\n\n                // check if the same event occurs again in the remaining part of the step\n                if (currentEvent.evaluateStep(interpolator)) {\n                    // the event occurs during the current step\n                    occurringEvents.add(currentEvent);\n                }\n\n            }\n\n            // last part of the step, after the last event\n            interpolator.setInterpolatedTime(currentT);\n            final double[] currentY = new double[y.length];\n            expandable.getPrimaryMapper().insertEquationData(interpolator.getInterpolatedState(),\n                                                             currentY);\n            int index = 0;\n            for (EquationsMapper secondary : expandable.getSecondaryMappers()) {\n                secondary.insertEquationData(interpolator.getInterpolatedSecondaryState(index++),\n                                             currentY);\n            }\n            for (final EventState state : eventsStates) {\n                state.stepAccepted(currentT, currentY);\n                isLastStep = isLastStep || state.stop();\n            }\n            isLastStep = isLastStep || Precision.equals(currentT, tEnd, 1);\n\n            // handle the remaining part of the step, after all events if any\n            for (StepHandler handler : stepHandlers) {\n                handler.handleStep(interpolator, isLastStep);\n            }\n\n            return currentT;\n\n    }",
          "48": "    protected double acceptStep(final AbstractStepInterpolator interpolator,\n                                final double[] y, final double[] yDot, final double tEnd)\n        throws MaxCountExceededException, DimensionMismatchException, NoBracketingException {\n\n            double previousT = interpolator.getGlobalPreviousTime();\n            final double currentT = interpolator.getGlobalCurrentTime();\n\n            // initialize the events states if needed\n            if (! statesInitialized) {\n                for (EventState state : eventsStates) {\n                    state.reinitializeBegin(interpolator);\n                }\n                statesInitialized = true;\n            }\n\n            // search for next events that may occur during the step\n            final int orderingSign = interpolator.isForward() ? ~1 : -1;            SortedSet<EventState> occurringEvents = new TreeSet<EventState>(new Comparator<EventState>() {\n\n                /** {@inheritDoc} */\n                public int compare(EventState es0, EventState es1) {\n                    return orderingSign * Double.compare(es0.getEventTime(), es1.getEventTime());\n                }\n\n            });\n\n            for (final EventState state : eventsStates) {\n                if (state.evaluateStep(interpolator)) {\n                    // the event occurs during the current step\n                    occurringEvents.add(state);\n                }\n            }\n\n            while (!occurringEvents.isEmpty()) {\n\n                // handle the chronologically first event\n                final Iterator<EventState> iterator = occurringEvents.iterator();\n                final EventState currentEvent = iterator.next();\n                iterator.remove();\n\n                // restrict the interpolator to the first part of the step, up to the event\n                final double eventT = currentEvent.getEventTime();\n                interpolator.setSoftPreviousTime(previousT);\n                interpolator.setSoftCurrentTime(eventT);\n\n                // get state at event time\n                interpolator.setInterpolatedTime(eventT);\n                final double[] eventYComplete = new double[y.length];\n                expandable.getPrimaryMapper().insertEquationData(interpolator.getInterpolatedState(),\n                                                                 eventYComplete);\n                int index = 0;\n                for (EquationsMapper secondary : expandable.getSecondaryMappers()) {\n                    secondary.insertEquationData(interpolator.getInterpolatedSecondaryState(index++),\n                                                 eventYComplete);\n                }\n\n                // advance all event states to current time\n                for (final EventState state : eventsStates) {\n                    state.stepAccepted(eventT, eventYComplete);\n                    isLastStep = isLastStep || state.stop();\n                }\n\n                // handle the first part of the step, up to the event\n                for (final StepHandler handler : stepHandlers) {\n                    handler.handleStep(interpolator, isLastStep);\n                }\n\n                if (isLastStep) {\n                    // the event asked to stop integration\n                    System.arraycopy(eventYComplete, 0, y, 0, y.length);\n                    return eventT;\n                }\n\n                boolean needReset = false;\n                for (final EventState state : eventsStates) {\n                    needReset =  needReset || state.reset(eventT, eventYComplete);\n                }\n                if (needReset) {\n                    // some event handler has triggered changes that\n                    // invalidate the derivatives, we need to recompute them\n                    interpolator.setInterpolatedTime(eventT);\n                    System.arraycopy(eventYComplete, 0, y, 0, y.length);\n                    computeDerivatives(eventT, y, yDot);\n                    resetOccurred = true;\n                    return eventT;\n                }\n\n                // prepare handling of the remaining part of the step\n                previousT = eventT;\n                interpolator.setSoftPreviousTime(eventT);\n                interpolator.setSoftCurrentTime(currentT);\n\n                // check if the same event occurs again in the remaining part of the step\n                if (currentEvent.evaluateStep(interpolator)) {\n                    // the event occurs during the current step\n                    occurringEvents.add(currentEvent);\n                }\n\n            }\n\n            // last part of the step, after the last event\n            interpolator.setInterpolatedTime(currentT);\n            final double[] currentY = new double[y.length];\n            expandable.getPrimaryMapper().insertEquationData(interpolator.getInterpolatedState(),\n                                                             currentY);\n            int index = 0;\n            for (EquationsMapper secondary : expandable.getSecondaryMappers()) {\n                secondary.insertEquationData(interpolator.getInterpolatedSecondaryState(index++),\n                                             currentY);\n            }\n            for (final EventState state : eventsStates) {\n                state.stepAccepted(currentT, currentY);\n                isLastStep = isLastStep || state.stop();\n            }\n            isLastStep = isLastStep || Precision.equals(currentT, tEnd, 1);\n\n            // handle the remaining part of the step, after all events if any\n            for (StepHandler handler : stepHandlers) {\n                handler.handleStep(interpolator, isLastStep);\n            }\n\n            return currentT;\n\n    }",
          "49": "    protected double acceptStep(final AbstractStepInterpolator interpolator,\n                                final double[] y, final double[] yDot, final double tEnd)\n        throws MaxCountExceededException, DimensionMismatchException, NoBracketingException {\n\n            double previousT = interpolator.getGlobalPreviousTime();\n            final double currentT = interpolator.getGlobalCurrentTime();\n\n            // initialize the events states if needed\n            if (! statesInitialized) {\n                for (EventState state : eventsStates) {\n                    state.reinitializeBegin(interpolator);\n                }\n                statesInitialized = true;\n            }\n\n            // search for next events that may occur during the step\nfinal int orderingSign = (int)interpolator.isForward(interpolator.isForward());\n            SortedSet<EventState> occurringEvents = new TreeSet<EventState>(new Comparator<EventState>() {\n\n                /** {@inheritDoc} */\n                public int compare(EventState es0, EventState es1) {\n                    return orderingSign * Double.compare(es0.getEventTime(), es1.getEventTime());\n                }\n\n            });\n\n            for (final EventState state : eventsStates) {\n                if (state.evaluateStep(interpolator)) {\n                    // the event occurs during the current step\n                    occurringEvents.add(state);\n                }\n            }\n\n            while (!occurringEvents.isEmpty()) {\n\n                // handle the chronologically first event\n                final Iterator<EventState> iterator = occurringEvents.iterator();\n                final EventState currentEvent = iterator.next();\n                iterator.remove();\n\n                // restrict the interpolator to the first part of the step, up to the event\n                final double eventT = currentEvent.getEventTime();\n                interpolator.setSoftPreviousTime(previousT);\n                interpolator.setSoftCurrentTime(eventT);\n\n                // get state at event time\n                interpolator.setInterpolatedTime(eventT);\n                final double[] eventYComplete = new double[y.length];\n                expandable.getPrimaryMapper().insertEquationData(interpolator.getInterpolatedState(),\n                                                                 eventYComplete);\n                int index = 0;\n                for (EquationsMapper secondary : expandable.getSecondaryMappers()) {\n                    secondary.insertEquationData(interpolator.getInterpolatedSecondaryState(index++),\n                                                 eventYComplete);\n                }\n\n                // advance all event states to current time\n                for (final EventState state : eventsStates) {\n                    state.stepAccepted(eventT, eventYComplete);\n                    isLastStep = isLastStep || state.stop();\n                }\n\n                // handle the first part of the step, up to the event\n                for (final StepHandler handler : stepHandlers) {\n                    handler.handleStep(interpolator, isLastStep);\n                }\n\n                if (isLastStep) {\n                    // the event asked to stop integration\n                    System.arraycopy(eventYComplete, 0, y, 0, y.length);\n                    return eventT;\n                }\n\n                boolean needReset = false;\n                for (final EventState state : eventsStates) {\n                    needReset =  needReset || state.reset(eventT, eventYComplete);\n                }\n                if (needReset) {\n                    // some event handler has triggered changes that\n                    // invalidate the derivatives, we need to recompute them\n                    interpolator.setInterpolatedTime(eventT);\n                    System.arraycopy(eventYComplete, 0, y, 0, y.length);\n                    computeDerivatives(eventT, y, yDot);\n                    resetOccurred = true;\n                    return eventT;\n                }\n\n                // prepare handling of the remaining part of the step\n                previousT = eventT;\n                interpolator.setSoftPreviousTime(eventT);\n                interpolator.setSoftCurrentTime(currentT);\n\n                // check if the same event occurs again in the remaining part of the step\n                if (currentEvent.evaluateStep(interpolator)) {\n                    // the event occurs during the current step\n                    occurringEvents.add(currentEvent);\n                }\n\n            }\n\n            // last part of the step, after the last event\n            interpolator.setInterpolatedTime(currentT);\n            final double[] currentY = new double[y.length];\n            expandable.getPrimaryMapper().insertEquationData(interpolator.getInterpolatedState(),\n                                                             currentY);\n            int index = 0;\n            for (EquationsMapper secondary : expandable.getSecondaryMappers()) {\n                secondary.insertEquationData(interpolator.getInterpolatedSecondaryState(index++),\n                                             currentY);\n            }\n            for (final EventState state : eventsStates) {\n                state.stepAccepted(currentT, currentY);\n                isLastStep = isLastStep || state.stop();\n            }\n            isLastStep = isLastStep || Precision.equals(currentT, tEnd, 1);\n\n            // handle the remaining part of the step, after all events if any\n            for (StepHandler handler : stepHandlers) {\n                handler.handleStep(interpolator, isLastStep);\n            }\n\n            return currentT;\n\n    }",
          "50": "    protected double acceptStep(final AbstractStepInterpolator interpolator,\n                                final double[] y, final double[] yDot, final double tEnd)\n        throws MaxCountExceededException, DimensionMismatchException, NoBracketingException {\n\n            double previousT = interpolator.getGlobalPreviousTime();\n            final double currentT = interpolator.getGlobalCurrentTime();\n\n            // initialize the events states if needed\n            if (! statesInitialized) {\n                for (EventState state : eventsStates) {\n                    state.reinitializeBegin(interpolator);\n                }\n                statesInitialized = true;\n            }\n\n            // search for next events that may occur during the step\nfinal int orderingSign = (int)interpolator.isForward(-1);\n            SortedSet<EventState> occurringEvents = new TreeSet<EventState>(new Comparator<EventState>() {\n\n                /** {@inheritDoc} */\n                public int compare(EventState es0, EventState es1) {\n                    return orderingSign * Double.compare(es0.getEventTime(), es1.getEventTime());\n                }\n\n            });\n\n            for (final EventState state : eventsStates) {\n                if (state.evaluateStep(interpolator)) {\n                    // the event occurs during the current step\n                    occurringEvents.add(state);\n                }\n            }\n\n            while (!occurringEvents.isEmpty()) {\n\n                // handle the chronologically first event\n                final Iterator<EventState> iterator = occurringEvents.iterator();\n                final EventState currentEvent = iterator.next();\n                iterator.remove();\n\n                // restrict the interpolator to the first part of the step, up to the event\n                final double eventT = currentEvent.getEventTime();\n                interpolator.setSoftPreviousTime(previousT);\n                interpolator.setSoftCurrentTime(eventT);\n\n                // get state at event time\n                interpolator.setInterpolatedTime(eventT);\n                final double[] eventYComplete = new double[y.length];\n                expandable.getPrimaryMapper().insertEquationData(interpolator.getInterpolatedState(),\n                                                                 eventYComplete);\n                int index = 0;\n                for (EquationsMapper secondary : expandable.getSecondaryMappers()) {\n                    secondary.insertEquationData(interpolator.getInterpolatedSecondaryState(index++),\n                                                 eventYComplete);\n                }\n\n                // advance all event states to current time\n                for (final EventState state : eventsStates) {\n                    state.stepAccepted(eventT, eventYComplete);\n                    isLastStep = isLastStep || state.stop();\n                }\n\n                // handle the first part of the step, up to the event\n                for (final StepHandler handler : stepHandlers) {\n                    handler.handleStep(interpolator, isLastStep);\n                }\n\n                if (isLastStep) {\n                    // the event asked to stop integration\n                    System.arraycopy(eventYComplete, 0, y, 0, y.length);\n                    return eventT;\n                }\n\n                boolean needReset = false;\n                for (final EventState state : eventsStates) {\n                    needReset =  needReset || state.reset(eventT, eventYComplete);\n                }\n                if (needReset) {\n                    // some event handler has triggered changes that\n                    // invalidate the derivatives, we need to recompute them\n                    interpolator.setInterpolatedTime(eventT);\n                    System.arraycopy(eventYComplete, 0, y, 0, y.length);\n                    computeDerivatives(eventT, y, yDot);\n                    resetOccurred = true;\n                    return eventT;\n                }\n\n                // prepare handling of the remaining part of the step\n                previousT = eventT;\n                interpolator.setSoftPreviousTime(eventT);\n                interpolator.setSoftCurrentTime(currentT);\n\n                // check if the same event occurs again in the remaining part of the step\n                if (currentEvent.evaluateStep(interpolator)) {\n                    // the event occurs during the current step\n                    occurringEvents.add(currentEvent);\n                }\n\n            }\n\n            // last part of the step, after the last event\n            interpolator.setInterpolatedTime(currentT);\n            final double[] currentY = new double[y.length];\n            expandable.getPrimaryMapper().insertEquationData(interpolator.getInterpolatedState(),\n                                                             currentY);\n            int index = 0;\n            for (EquationsMapper secondary : expandable.getSecondaryMappers()) {\n                secondary.insertEquationData(interpolator.getInterpolatedSecondaryState(index++),\n                                             currentY);\n            }\n            for (final EventState state : eventsStates) {\n                state.stepAccepted(currentT, currentY);\n                isLastStep = isLastStep || state.stop();\n            }\n            isLastStep = isLastStep || Precision.equals(currentT, tEnd, 1);\n\n            // handle the remaining part of the step, after all events if any\n            for (StepHandler handler : stepHandlers) {\n                handler.handleStep(interpolator, isLastStep);\n            }\n\n            return currentT;\n\n    }"
}