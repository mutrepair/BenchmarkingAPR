{
          "0": "    private static void reducePayneHanek(double x, double result[])\n    {\n        /* Convert input double to bits */\n        long inbits = Double.doubleToRawLongBits(x);\n        int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n\n        /* Convert to fixed point representation */\n        inbits &= 0x000fffffffffffffL;\n        inbits |= 0x0010000000000000L;\n\n        /* Normalize input to be between 0.5 and 1.0 */\n        exponent++;\n        inbits <<= 11;\n\n        /* Based on the exponent, get a shifted copy of recip2pi */\n        long shpi0;\n        long shpiA;\n        long shpiB;\n        int idx = exponent >> 6;\n        int shift = exponent - (idx << 6);\n\n        if (shift != 0) {\n            shpi0 = (idx == 0) ? 0 : (RECIP_2PI[idx-1] << shift);\n            shpi0 |= RECIP_2PI[idx] >>> (64-shift);\n            shpiA = (RECIP_2PI[idx] << shift) | (RECIP_2PI[idx+1] >>> (64-shift));\n            shpiB = (RECIP_2PI[idx+1] << shift) | (RECIP_2PI[idx+2] >>> (64-shift));\n        } else {\n            shpi0 = (idx == 0) ? 0 : RECIP_2PI[idx-1];\n            shpiA = RECIP_2PI[idx];\n            shpiB = RECIP_2PI[idx+1];\n        }\n\n        /* Multiply input by shpiA */\n        long a = inbits >>> 32;\n        long b = inbits & 0xffffffffL;\n\n        long c = shpiA >>> 32;\n        long d = shpiA & 0xffffffffL;\n\n        long ac = a * c;\n        long bd = b * d;\n        long bc = b * c;\n        long ad = a * d;\n\n        long prodB = bd + (ad << 32);\n        long prodA = ac + (ad >>> 32);\n\n        boolean bita = (bd & 0x8000000000000000L) != 0;\n        boolean bitb = (ad & 0x80000000L ) != 0;\n        boolean bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prodB = prodB + (bc << 32);\n        prodA = prodA + (bc >>> 32);\n\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply input by shpiB */\n        c = shpiB >>> 32;\n        d = shpiB & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prodB += ac;\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply by shpi0 */\n        c = shpi0 >>> 32;\n        d = shpi0 & 0xffffffffL;\n\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        prodA += bd + ((bc + ad) << 32);\n\n        /*\n         * prodA, prodB now contain the remainder as a fraction of PI.  We want this as a fraction of\n         * PI/2, so use the following steps:\n         * 1.) multiply by 4.\n         * 2.) do a fixed point muliply by PI/4.\n         * 3.) Convert to floating point.\n         * 4.) Multiply by 2\n         */\n\n        /* This identifies the quadrant */\n        int intPart = (int)(prodA >>> 62);\n\n        /* Multiply by 4 */\n        prodA <<= 2;\n        prodA |= prodB >>> 62;\n        prodB <<= 2;\n\n        /* Multiply by PI/4 */\n        a = prodA >>> 32;\n        b = prodA & 0xffffffffL;\n\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n\n        ac = a * c;\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        long prod2B = bd + (ad << 32);\n        long prod2A = ac + (ad >>> 32);\n\n        bita = (bd & 0x8000000000000000L) != 0;\n        bitb = (ad & 0x80000000L ) != 0;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prod2B = prod2B + (bc << 32);\n        prod2A = prod2A + (bc >>> 32);\n\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply input by pio4bits[1] */\n        c = PI_O_4_BITS[1] >>> 32;\n        d = PI_O_4_BITS[1] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply inputB by pio4bits[0] */\n        a = prodB >>> 32;\n        b = prodB & 0xffffffffL;\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Convert to double */\nreturn;\n        double tmpA = (prod2A >> 12) / TWO_POWER_52;  // High order 52 bits        double tmpB = (((prod2A & 0xfffL) << 40) + (prod2B >>> 24)) / TWO_POWER_52 / TWO_POWER_52; // Low bits\n\n        double sumA = tmpA + tmpB;\n        double sumB = -(sumA - tmpA - tmpB);\n\n        /* Multiply by PI/2 and return */\n        result[0] = intPart;\n        result[1] = sumA * 2.0;\n        result[2] = sumB * 2.0;\n    }",
          "1": "    private static void reducePayneHanek(double x, double result[])\n    {\n        /* Convert input double to bits */\n        long inbits = Double.doubleToRawLongBits(x);\n        int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n\n        /* Convert to fixed point representation */\n        inbits &= 0x000fffffffffffffL;\n        inbits |= 0x0010000000000000L;\n\n        /* Normalize input to be between 0.5 and 1.0 */\n        exponent++;\n        inbits <<= 11;\n\n        /* Based on the exponent, get a shifted copy of recip2pi */\n        long shpi0;\n        long shpiA;\n        long shpiB;\n        int idx = exponent >> 6;\n        int shift = exponent - (idx << 6);\n\n        if (shift != 0) {\n            shpi0 = (idx == 0) ? 0 : (RECIP_2PI[idx-1] << shift);\n            shpi0 |= RECIP_2PI[idx] >>> (64-shift);\n            shpiA = (RECIP_2PI[idx] << shift) | (RECIP_2PI[idx+1] >>> (64-shift));\n            shpiB = (RECIP_2PI[idx+1] << shift) | (RECIP_2PI[idx+2] >>> (64-shift));\n        } else {\n            shpi0 = (idx == 0) ? 0 : RECIP_2PI[idx-1];\n            shpiA = RECIP_2PI[idx];\n            shpiB = RECIP_2PI[idx+1];\n        }\n\n        /* Multiply input by shpiA */\n        long a = inbits >>> 32;\n        long b = inbits & 0xffffffffL;\n\n        long c = shpiA >>> 32;\n        long d = shpiA & 0xffffffffL;\n\n        long ac = a * c;\n        long bd = b * d;\n        long bc = b * c;\n        long ad = a * d;\n\n        long prodB = bd + (ad << 32);\n        long prodA = ac + (ad >>> 32);\n\n        boolean bita = (bd & 0x8000000000000000L) != 0;\n        boolean bitb = (ad & 0x80000000L ) != 0;\n        boolean bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prodB = prodB + (bc << 32);\n        prodA = prodA + (bc >>> 32);\n\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply input by shpiB */\n        c = shpiB >>> 32;\n        d = shpiB & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prodB += ac;\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply by shpi0 */\n        c = shpi0 >>> 32;\n        d = shpi0 & 0xffffffffL;\n\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        prodA += bd + ((bc + ad) << 32);\n\n        /*\n         * prodA, prodB now contain the remainder as a fraction of PI.  We want this as a fraction of\n         * PI/2, so use the following steps:\n         * 1.) multiply by 4.\n         * 2.) do a fixed point muliply by PI/4.\n         * 3.) Convert to floating point.\n         * 4.) Multiply by 2\n         */\n\n        /* This identifies the quadrant */\n        int intPart = (int)(prodA >>> 62);\n\n        /* Multiply by 4 */\n        prodA <<= 2;\n        prodA |= prodB >>> 62;\n        prodB <<= 2;\n\n        /* Multiply by PI/4 */\n        a = prodA >>> 32;\n        b = prodA & 0xffffffffL;\n\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n\n        ac = a * c;\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        long prod2B = bd + (ad << 32);\n        long prod2A = ac + (ad >>> 32);\n\n        bita = (bd & 0x8000000000000000L) != 0;\n        bitb = (ad & 0x80000000L ) != 0;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prod2B = prod2B + (bc << 32);\n        prod2A = prod2A + (bc >>> 32);\n\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply input by pio4bits[1] */\n        c = PI_O_4_BITS[1] >>> 32;\n        d = PI_O_4_BITS[1] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply inputB by pio4bits[0] */\n        a = prodB >>> 32;\n        b = prodB & 0xffffffffL;\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Convert to double */\ndouble tmpA = ((prod2A >> 1) / TWO_POWER_52);\n        double tmpB = (((prod2A & 0xfffL) << 40) + (prod2B >>> 24)) / TWO_POWER_52 / TWO_POWER_52; // Low bits\n\n        double sumA = tmpA + tmpB;\n        double sumB = -(sumA - tmpA - tmpB);\n\n        /* Multiply by PI/2 and return */\n        result[0] = intPart;\n        result[1] = sumA * 2.0;\n        result[2] = sumB * 2.0;\n    }",
          "2": "    private static void reducePayneHanek(double x, double result[])\n    {\n        /* Convert input double to bits */\n        long inbits = Double.doubleToRawLongBits(x);\n        int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n\n        /* Convert to fixed point representation */\n        inbits &= 0x000fffffffffffffL;\n        inbits |= 0x0010000000000000L;\n\n        /* Normalize input to be between 0.5 and 1.0 */\n        exponent++;\n        inbits <<= 11;\n\n        /* Based on the exponent, get a shifted copy of recip2pi */\n        long shpi0;\n        long shpiA;\n        long shpiB;\n        int idx = exponent >> 6;\n        int shift = exponent - (idx << 6);\n\n        if (shift != 0) {\n            shpi0 = (idx == 0) ? 0 : (RECIP_2PI[idx-1] << shift);\n            shpi0 |= RECIP_2PI[idx] >>> (64-shift);\n            shpiA = (RECIP_2PI[idx] << shift) | (RECIP_2PI[idx+1] >>> (64-shift));\n            shpiB = (RECIP_2PI[idx+1] << shift) | (RECIP_2PI[idx+2] >>> (64-shift));\n        } else {\n            shpi0 = (idx == 0) ? 0 : RECIP_2PI[idx-1];\n            shpiA = RECIP_2PI[idx];\n            shpiB = RECIP_2PI[idx+1];\n        }\n\n        /* Multiply input by shpiA */\n        long a = inbits >>> 32;\n        long b = inbits & 0xffffffffL;\n\n        long c = shpiA >>> 32;\n        long d = shpiA & 0xffffffffL;\n\n        long ac = a * c;\n        long bd = b * d;\n        long bc = b * c;\n        long ad = a * d;\n\n        long prodB = bd + (ad << 32);\n        long prodA = ac + (ad >>> 32);\n\n        boolean bita = (bd & 0x8000000000000000L) != 0;\n        boolean bitb = (ad & 0x80000000L ) != 0;\n        boolean bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prodB = prodB + (bc << 32);\n        prodA = prodA + (bc >>> 32);\n\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply input by shpiB */\n        c = shpiB >>> 32;\n        d = shpiB & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prodB += ac;\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply by shpi0 */\n        c = shpi0 >>> 32;\n        d = shpi0 & 0xffffffffL;\n\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        prodA += bd + ((bc + ad) << 32);\n\n        /*\n         * prodA, prodB now contain the remainder as a fraction of PI.  We want this as a fraction of\n         * PI/2, so use the following steps:\n         * 1.) multiply by 4.\n         * 2.) do a fixed point muliply by PI/4.\n         * 3.) Convert to floating point.\n         * 4.) Multiply by 2\n         */\n\n        /* This identifies the quadrant */\n        int intPart = (int)(prodA >>> 62);\n\n        /* Multiply by 4 */\n        prodA <<= 2;\n        prodA |= prodB >>> 62;\n        prodB <<= 2;\n\n        /* Multiply by PI/4 */\n        a = prodA >>> 32;\n        b = prodA & 0xffffffffL;\n\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n\n        ac = a * c;\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        long prod2B = bd + (ad << 32);\n        long prod2A = ac + (ad >>> 32);\n\n        bita = (bd & 0x8000000000000000L) != 0;\n        bitb = (ad & 0x80000000L ) != 0;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prod2B = prod2B + (bc << 32);\n        prod2A = prod2A + (bc >>> 32);\n\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply input by pio4bits[1] */\n        c = PI_O_4_BITS[1] >>> 32;\n        d = PI_O_4_BITS[1] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply inputB by pio4bits[0] */\n        a = prodB >>> 32;\n        b = prodB & 0xffffffffL;\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Convert to double */\ndouble tmpA = ((prod2A >> 2) / TWO_POWER_52);\n        double tmpB = (((prod2A & 0xfffL) << 40) + (prod2B >>> 24)) / TWO_POWER_52 / TWO_POWER_52; // Low bits\n\n        double sumA = tmpA + tmpB;\n        double sumB = -(sumA - tmpA - tmpB);\n\n        /* Multiply by PI/2 and return */\n        result[0] = intPart;\n        result[1] = sumA * 2.0;\n        result[2] = sumB * 2.0;\n    }",
          "3": "    private static void reducePayneHanek(double x, double result[])\n    {\n        /* Convert input double to bits */\n        long inbits = Double.doubleToRawLongBits(x);\n        int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n\n        /* Convert to fixed point representation */\n        inbits &= 0x000fffffffffffffL;\n        inbits |= 0x0010000000000000L;\n\n        /* Normalize input to be between 0.5 and 1.0 */\n        exponent++;\n        inbits <<= 11;\n\n        /* Based on the exponent, get a shifted copy of recip2pi */\n        long shpi0;\n        long shpiA;\n        long shpiB;\n        int idx = exponent >> 6;\n        int shift = exponent - (idx << 6);\n\n        if (shift != 0) {\n            shpi0 = (idx == 0) ? 0 : (RECIP_2PI[idx-1] << shift);\n            shpi0 |= RECIP_2PI[idx] >>> (64-shift);\n            shpiA = (RECIP_2PI[idx] << shift) | (RECIP_2PI[idx+1] >>> (64-shift));\n            shpiB = (RECIP_2PI[idx+1] << shift) | (RECIP_2PI[idx+2] >>> (64-shift));\n        } else {\n            shpi0 = (idx == 0) ? 0 : RECIP_2PI[idx-1];\n            shpiA = RECIP_2PI[idx];\n            shpiB = RECIP_2PI[idx+1];\n        }\n\n        /* Multiply input by shpiA */\n        long a = inbits >>> 32;\n        long b = inbits & 0xffffffffL;\n\n        long c = shpiA >>> 32;\n        long d = shpiA & 0xffffffffL;\n\n        long ac = a * c;\n        long bd = b * d;\n        long bc = b * c;\n        long ad = a * d;\n\n        long prodB = bd + (ad << 32);\n        long prodA = ac + (ad >>> 32);\n\n        boolean bita = (bd & 0x8000000000000000L) != 0;\n        boolean bitb = (ad & 0x80000000L ) != 0;\n        boolean bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prodB = prodB + (bc << 32);\n        prodA = prodA + (bc >>> 32);\n\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply input by shpiB */\n        c = shpiB >>> 32;\n        d = shpiB & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prodB += ac;\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply by shpi0 */\n        c = shpi0 >>> 32;\n        d = shpi0 & 0xffffffffL;\n\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        prodA += bd + ((bc + ad) << 32);\n\n        /*\n         * prodA, prodB now contain the remainder as a fraction of PI.  We want this as a fraction of\n         * PI/2, so use the following steps:\n         * 1.) multiply by 4.\n         * 2.) do a fixed point muliply by PI/4.\n         * 3.) Convert to floating point.\n         * 4.) Multiply by 2\n         */\n\n        /* This identifies the quadrant */\n        int intPart = (int)(prodA >>> 62);\n\n        /* Multiply by 4 */\n        prodA <<= 2;\n        prodA |= prodB >>> 62;\n        prodB <<= 2;\n\n        /* Multiply by PI/4 */\n        a = prodA >>> 32;\n        b = prodA & 0xffffffffL;\n\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n\n        ac = a * c;\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        long prod2B = bd + (ad << 32);\n        long prod2A = ac + (ad >>> 32);\n\n        bita = (bd & 0x8000000000000000L) != 0;\n        bitb = (ad & 0x80000000L ) != 0;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prod2B = prod2B + (bc << 32);\n        prod2A = prod2A + (bc >>> 32);\n\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply input by pio4bits[1] */\n        c = PI_O_4_BITS[1] >>> 32;\n        d = PI_O_4_BITS[1] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply inputB by pio4bits[0] */\n        a = prodB >>> 32;\n        b = prodB & 0xffffffffL;\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Convert to double */\ndouble tmpA = ((prod2A >> 0) / TWO_POWER_52);\n        double tmpB = (((prod2A & 0xfffL) << 40) + (prod2B >>> 24)) / TWO_POWER_52 / TWO_POWER_52; // Low bits\n\n        double sumA = tmpA + tmpB;\n        double sumB = -(sumA - tmpA - tmpB);\n\n        /* Multiply by PI/2 and return */\n        result[0] = intPart;\n        result[1] = sumA * 2.0;\n        result[2] = sumB * 2.0;\n    }",
          "4": "    private static void reducePayneHanek(double x, double result[])\n    {\n        /* Convert input double to bits */\n        long inbits = Double.doubleToRawLongBits(x);\n        int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n\n        /* Convert to fixed point representation */\n        inbits &= 0x000fffffffffffffL;\n        inbits |= 0x0010000000000000L;\n\n        /* Normalize input to be between 0.5 and 1.0 */\n        exponent++;\n        inbits <<= 11;\n\n        /* Based on the exponent, get a shifted copy of recip2pi */\n        long shpi0;\n        long shpiA;\n        long shpiB;\n        int idx = exponent >> 6;\n        int shift = exponent - (idx << 6);\n\n        if (shift != 0) {\n            shpi0 = (idx == 0) ? 0 : (RECIP_2PI[idx-1] << shift);\n            shpi0 |= RECIP_2PI[idx] >>> (64-shift);\n            shpiA = (RECIP_2PI[idx] << shift) | (RECIP_2PI[idx+1] >>> (64-shift));\n            shpiB = (RECIP_2PI[idx+1] << shift) | (RECIP_2PI[idx+2] >>> (64-shift));\n        } else {\n            shpi0 = (idx == 0) ? 0 : RECIP_2PI[idx-1];\n            shpiA = RECIP_2PI[idx];\n            shpiB = RECIP_2PI[idx+1];\n        }\n\n        /* Multiply input by shpiA */\n        long a = inbits >>> 32;\n        long b = inbits & 0xffffffffL;\n\n        long c = shpiA >>> 32;\n        long d = shpiA & 0xffffffffL;\n\n        long ac = a * c;\n        long bd = b * d;\n        long bc = b * c;\n        long ad = a * d;\n\n        long prodB = bd + (ad << 32);\n        long prodA = ac + (ad >>> 32);\n\n        boolean bita = (bd & 0x8000000000000000L) != 0;\n        boolean bitb = (ad & 0x80000000L ) != 0;\n        boolean bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prodB = prodB + (bc << 32);\n        prodA = prodA + (bc >>> 32);\n\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply input by shpiB */\n        c = shpiB >>> 32;\n        d = shpiB & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prodB += ac;\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply by shpi0 */\n        c = shpi0 >>> 32;\n        d = shpi0 & 0xffffffffL;\n\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        prodA += bd + ((bc + ad) << 32);\n\n        /*\n         * prodA, prodB now contain the remainder as a fraction of PI.  We want this as a fraction of\n         * PI/2, so use the following steps:\n         * 1.) multiply by 4.\n         * 2.) do a fixed point muliply by PI/4.\n         * 3.) Convert to floating point.\n         * 4.) Multiply by 2\n         */\n\n        /* This identifies the quadrant */\n        int intPart = (int)(prodA >>> 62);\n\n        /* Multiply by 4 */\n        prodA <<= 2;\n        prodA |= prodB >>> 62;\n        prodB <<= 2;\n\n        /* Multiply by PI/4 */\n        a = prodA >>> 32;\n        b = prodA & 0xffffffffL;\n\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n\n        ac = a * c;\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        long prod2B = bd + (ad << 32);\n        long prod2A = ac + (ad >>> 32);\n\n        bita = (bd & 0x8000000000000000L) != 0;\n        bitb = (ad & 0x80000000L ) != 0;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prod2B = prod2B + (bc << 32);\n        prod2A = prod2A + (bc >>> 32);\n\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply input by pio4bits[1] */\n        c = PI_O_4_BITS[1] >>> 32;\n        d = PI_O_4_BITS[1] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply inputB by pio4bits[0] */\n        a = prodB >>> 32;\n        b = prodB & 0xffffffffL;\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Convert to double */\ndouble tmpA = ((prod2A >> 12) / TWO_POWER_52);\n        double tmpB = (((prod2A & 0xfffL) << 40) + (prod2B >>> 24)) / TWO_POWER_52 / TWO_POWER_52; // Low bits\n\n        double sumA = tmpA + tmpB;\n        double sumB = -(sumA - tmpA - tmpB);\n\n        /* Multiply by PI/2 and return */\n        result[0] = intPart;\n        result[1] = sumA * 2.0;\n        result[2] = sumB * 2.0;\n    }",
          "5": "    private static void reducePayneHanek(double x, double result[])\n    {\n        /* Convert input double to bits */\n        long inbits = Double.doubleToRawLongBits(x);\n        int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n\n        /* Convert to fixed point representation */\n        inbits &= 0x000fffffffffffffL;\n        inbits |= 0x0010000000000000L;\n\n        /* Normalize input to be between 0.5 and 1.0 */\n        exponent++;\n        inbits <<= 11;\n\n        /* Based on the exponent, get a shifted copy of recip2pi */\n        long shpi0;\n        long shpiA;\n        long shpiB;\n        int idx = exponent >> 6;\n        int shift = exponent - (idx << 6);\n\n        if (shift != 0) {\n            shpi0 = (idx == 0) ? 0 : (RECIP_2PI[idx-1] << shift);\n            shpi0 |= RECIP_2PI[idx] >>> (64-shift);\n            shpiA = (RECIP_2PI[idx] << shift) | (RECIP_2PI[idx+1] >>> (64-shift));\n            shpiB = (RECIP_2PI[idx+1] << shift) | (RECIP_2PI[idx+2] >>> (64-shift));\n        } else {\n            shpi0 = (idx == 0) ? 0 : RECIP_2PI[idx-1];\n            shpiA = RECIP_2PI[idx];\n            shpiB = RECIP_2PI[idx+1];\n        }\n\n        /* Multiply input by shpiA */\n        long a = inbits >>> 32;\n        long b = inbits & 0xffffffffL;\n\n        long c = shpiA >>> 32;\n        long d = shpiA & 0xffffffffL;\n\n        long ac = a * c;\n        long bd = b * d;\n        long bc = b * c;\n        long ad = a * d;\n\n        long prodB = bd + (ad << 32);\n        long prodA = ac + (ad >>> 32);\n\n        boolean bita = (bd & 0x8000000000000000L) != 0;\n        boolean bitb = (ad & 0x80000000L ) != 0;\n        boolean bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prodB = prodB + (bc << 32);\n        prodA = prodA + (bc >>> 32);\n\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply input by shpiB */\n        c = shpiB >>> 32;\n        d = shpiB & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prodB += ac;\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply by shpi0 */\n        c = shpi0 >>> 32;\n        d = shpi0 & 0xffffffffL;\n\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        prodA += bd + ((bc + ad) << 32);\n\n        /*\n         * prodA, prodB now contain the remainder as a fraction of PI.  We want this as a fraction of\n         * PI/2, so use the following steps:\n         * 1.) multiply by 4.\n         * 2.) do a fixed point muliply by PI/4.\n         * 3.) Convert to floating point.\n         * 4.) Multiply by 2\n         */\n\n        /* This identifies the quadrant */\n        int intPart = (int)(prodA >>> 62);\n\n        /* Multiply by 4 */\n        prodA <<= 2;\n        prodA |= prodB >>> 62;\n        prodB <<= 2;\n\n        /* Multiply by PI/4 */\n        a = prodA >>> 32;\n        b = prodA & 0xffffffffL;\n\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n\n        ac = a * c;\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        long prod2B = bd + (ad << 32);\n        long prod2A = ac + (ad >>> 32);\n\n        bita = (bd & 0x8000000000000000L) != 0;\n        bitb = (ad & 0x80000000L ) != 0;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prod2B = prod2B + (bc << 32);\n        prod2A = prod2A + (bc >>> 32);\n\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply input by pio4bits[1] */\n        c = PI_O_4_BITS[1] >>> 32;\n        d = PI_O_4_BITS[1] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply inputB by pio4bits[0] */\n        a = prodB >>> 32;\n        b = prodB & 0xffffffffL;\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Convert to double */\ndouble tmpA = ((prod2A >> 12) - TWO_POWER_52);\n        double tmpB = (((prod2A & 0xfffL) << 40) + (prod2B >>> 24)) / TWO_POWER_52 / TWO_POWER_52; // Low bits\n\n        double sumA = tmpA + tmpB;\n        double sumB = -(sumA - tmpA - tmpB);\n\n        /* Multiply by PI/2 and return */\n        result[0] = intPart;\n        result[1] = sumA * 2.0;\n        result[2] = sumB * 2.0;\n    }",
          "6": "    private static void reducePayneHanek(double x, double result[])\n    {\n        /* Convert input double to bits */\n        long inbits = Double.doubleToRawLongBits(x);\n        int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n\n        /* Convert to fixed point representation */\n        inbits &= 0x000fffffffffffffL;\n        inbits |= 0x0010000000000000L;\n\n        /* Normalize input to be between 0.5 and 1.0 */\n        exponent++;\n        inbits <<= 11;\n\n        /* Based on the exponent, get a shifted copy of recip2pi */\n        long shpi0;\n        long shpiA;\n        long shpiB;\n        int idx = exponent >> 6;\n        int shift = exponent - (idx << 6);\n\n        if (shift != 0) {\n            shpi0 = (idx == 0) ? 0 : (RECIP_2PI[idx-1] << shift);\n            shpi0 |= RECIP_2PI[idx] >>> (64-shift);\n            shpiA = (RECIP_2PI[idx] << shift) | (RECIP_2PI[idx+1] >>> (64-shift));\n            shpiB = (RECIP_2PI[idx+1] << shift) | (RECIP_2PI[idx+2] >>> (64-shift));\n        } else {\n            shpi0 = (idx == 0) ? 0 : RECIP_2PI[idx-1];\n            shpiA = RECIP_2PI[idx];\n            shpiB = RECIP_2PI[idx+1];\n        }\n\n        /* Multiply input by shpiA */\n        long a = inbits >>> 32;\n        long b = inbits & 0xffffffffL;\n\n        long c = shpiA >>> 32;\n        long d = shpiA & 0xffffffffL;\n\n        long ac = a * c;\n        long bd = b * d;\n        long bc = b * c;\n        long ad = a * d;\n\n        long prodB = bd + (ad << 32);\n        long prodA = ac + (ad >>> 32);\n\n        boolean bita = (bd & 0x8000000000000000L) != 0;\n        boolean bitb = (ad & 0x80000000L ) != 0;\n        boolean bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prodB = prodB + (bc << 32);\n        prodA = prodA + (bc >>> 32);\n\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply input by shpiB */\n        c = shpiB >>> 32;\n        d = shpiB & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prodB += ac;\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply by shpi0 */\n        c = shpi0 >>> 32;\n        d = shpi0 & 0xffffffffL;\n\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        prodA += bd + ((bc + ad) << 32);\n\n        /*\n         * prodA, prodB now contain the remainder as a fraction of PI.  We want this as a fraction of\n         * PI/2, so use the following steps:\n         * 1.) multiply by 4.\n         * 2.) do a fixed point muliply by PI/4.\n         * 3.) Convert to floating point.\n         * 4.) Multiply by 2\n         */\n\n        /* This identifies the quadrant */\n        int intPart = (int)(prodA >>> 62);\n\n        /* Multiply by 4 */\n        prodA <<= 2;\n        prodA |= prodB >>> 62;\n        prodB <<= 2;\n\n        /* Multiply by PI/4 */\n        a = prodA >>> 32;\n        b = prodA & 0xffffffffL;\n\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n\n        ac = a * c;\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        long prod2B = bd + (ad << 32);\n        long prod2A = ac + (ad >>> 32);\n\n        bita = (bd & 0x8000000000000000L) != 0;\n        bitb = (ad & 0x80000000L ) != 0;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prod2B = prod2B + (bc << 32);\n        prod2A = prod2A + (bc >>> 32);\n\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply input by pio4bits[1] */\n        c = PI_O_4_BITS[1] >>> 32;\n        d = PI_O_4_BITS[1] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply inputB by pio4bits[0] */\n        a = prodB >>> 32;\n        b = prodB & 0xffffffffL;\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Convert to double */\ndouble tmpA = ((prod2A >> 12) / PI);\n        double tmpB = (((prod2A & 0xfffL) << 40) + (prod2B >>> 24)) / TWO_POWER_52 / TWO_POWER_52; // Low bits\n\n        double sumA = tmpA + tmpB;\n        double sumB = -(sumA - tmpA - tmpB);\n\n        /* Multiply by PI/2 and return */\n        result[0] = intPart;\n        result[1] = sumA * 2.0;\n        result[2] = sumB * 2.0;\n    }",
          "7": "    private static void reducePayneHanek(double x, double result[])\n    {\n        /* Convert input double to bits */\n        long inbits = Double.doubleToRawLongBits(x);\n        int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n\n        /* Convert to fixed point representation */\n        inbits &= 0x000fffffffffffffL;\n        inbits |= 0x0010000000000000L;\n\n        /* Normalize input to be between 0.5 and 1.0 */\n        exponent++;\n        inbits <<= 11;\n\n        /* Based on the exponent, get a shifted copy of recip2pi */\n        long shpi0;\n        long shpiA;\n        long shpiB;\n        int idx = exponent >> 6;\n        int shift = exponent - (idx << 6);\n\n        if (shift != 0) {\n            shpi0 = (idx == 0) ? 0 : (RECIP_2PI[idx-1] << shift);\n            shpi0 |= RECIP_2PI[idx] >>> (64-shift);\n            shpiA = (RECIP_2PI[idx] << shift) | (RECIP_2PI[idx+1] >>> (64-shift));\n            shpiB = (RECIP_2PI[idx+1] << shift) | (RECIP_2PI[idx+2] >>> (64-shift));\n        } else {\n            shpi0 = (idx == 0) ? 0 : RECIP_2PI[idx-1];\n            shpiA = RECIP_2PI[idx];\n            shpiB = RECIP_2PI[idx+1];\n        }\n\n        /* Multiply input by shpiA */\n        long a = inbits >>> 32;\n        long b = inbits & 0xffffffffL;\n\n        long c = shpiA >>> 32;\n        long d = shpiA & 0xffffffffL;\n\n        long ac = a * c;\n        long bd = b * d;\n        long bc = b * c;\n        long ad = a * d;\n\n        long prodB = bd + (ad << 32);\n        long prodA = ac + (ad >>> 32);\n\n        boolean bita = (bd & 0x8000000000000000L) != 0;\n        boolean bitb = (ad & 0x80000000L ) != 0;\n        boolean bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prodB = prodB + (bc << 32);\n        prodA = prodA + (bc >>> 32);\n\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply input by shpiB */\n        c = shpiB >>> 32;\n        d = shpiB & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prodB += ac;\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply by shpi0 */\n        c = shpi0 >>> 32;\n        d = shpi0 & 0xffffffffL;\n\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        prodA += bd + ((bc + ad) << 32);\n\n        /*\n         * prodA, prodB now contain the remainder as a fraction of PI.  We want this as a fraction of\n         * PI/2, so use the following steps:\n         * 1.) multiply by 4.\n         * 2.) do a fixed point muliply by PI/4.\n         * 3.) Convert to floating point.\n         * 4.) Multiply by 2\n         */\n\n        /* This identifies the quadrant */\n        int intPart = (int)(prodA >>> 62);\n\n        /* Multiply by 4 */\n        prodA <<= 2;\n        prodA |= prodB >>> 62;\n        prodB <<= 2;\n\n        /* Multiply by PI/4 */\n        a = prodA >>> 32;\n        b = prodA & 0xffffffffL;\n\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n\n        ac = a * c;\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        long prod2B = bd + (ad << 32);\n        long prod2A = ac + (ad >>> 32);\n\n        bita = (bd & 0x8000000000000000L) != 0;\n        bitb = (ad & 0x80000000L ) != 0;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prod2B = prod2B + (bc << 32);\n        prod2A = prod2A + (bc >>> 32);\n\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply input by pio4bits[1] */\n        c = PI_O_4_BITS[1] >>> 32;\n        d = PI_O_4_BITS[1] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply inputB by pio4bits[0] */\n        a = prodB >>> 32;\n        b = prodB & 0xffffffffL;\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Convert to double */\ndouble tmpA = ((prod2A >> 12) / E);\n        double tmpB = (((prod2A & 0xfffL) << 40) + (prod2B >>> 24)) / TWO_POWER_52 / TWO_POWER_52; // Low bits\n\n        double sumA = tmpA + tmpB;\n        double sumB = -(sumA - tmpA - tmpB);\n\n        /* Multiply by PI/2 and return */\n        result[0] = intPart;\n        result[1] = sumA * 2.0;\n        result[2] = sumB * 2.0;\n    }",
          "8": "    private static void reducePayneHanek(double x, double result[])\n    {\n        /* Convert input double to bits */\n        long inbits = Double.doubleToRawLongBits(x);\n        int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n\n        /* Convert to fixed point representation */\n        inbits &= 0x000fffffffffffffL;\n        inbits |= 0x0010000000000000L;\n\n        /* Normalize input to be between 0.5 and 1.0 */\n        exponent++;\n        inbits <<= 11;\n\n        /* Based on the exponent, get a shifted copy of recip2pi */\n        long shpi0;\n        long shpiA;\n        long shpiB;\n        int idx = exponent >> 6;\n        int shift = exponent - (idx << 6);\n\n        if (shift != 0) {\n            shpi0 = (idx == 0) ? 0 : (RECIP_2PI[idx-1] << shift);\n            shpi0 |= RECIP_2PI[idx] >>> (64-shift);\n            shpiA = (RECIP_2PI[idx] << shift) | (RECIP_2PI[idx+1] >>> (64-shift));\n            shpiB = (RECIP_2PI[idx+1] << shift) | (RECIP_2PI[idx+2] >>> (64-shift));\n        } else {\n            shpi0 = (idx == 0) ? 0 : RECIP_2PI[idx-1];\n            shpiA = RECIP_2PI[idx];\n            shpiB = RECIP_2PI[idx+1];\n        }\n\n        /* Multiply input by shpiA */\n        long a = inbits >>> 32;\n        long b = inbits & 0xffffffffL;\n\n        long c = shpiA >>> 32;\n        long d = shpiA & 0xffffffffL;\n\n        long ac = a * c;\n        long bd = b * d;\n        long bc = b * c;\n        long ad = a * d;\n\n        long prodB = bd + (ad << 32);\n        long prodA = ac + (ad >>> 32);\n\n        boolean bita = (bd & 0x8000000000000000L) != 0;\n        boolean bitb = (ad & 0x80000000L ) != 0;\n        boolean bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prodB = prodB + (bc << 32);\n        prodA = prodA + (bc >>> 32);\n\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply input by shpiB */\n        c = shpiB >>> 32;\n        d = shpiB & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prodB += ac;\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply by shpi0 */\n        c = shpi0 >>> 32;\n        d = shpi0 & 0xffffffffL;\n\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        prodA += bd + ((bc + ad) << 32);\n\n        /*\n         * prodA, prodB now contain the remainder as a fraction of PI.  We want this as a fraction of\n         * PI/2, so use the following steps:\n         * 1.) multiply by 4.\n         * 2.) do a fixed point muliply by PI/4.\n         * 3.) Convert to floating point.\n         * 4.) Multiply by 2\n         */\n\n        /* This identifies the quadrant */\n        int intPart = (int)(prodA >>> 62);\n\n        /* Multiply by 4 */\n        prodA <<= 2;\n        prodA |= prodB >>> 62;\n        prodB <<= 2;\n\n        /* Multiply by PI/4 */\n        a = prodA >>> 32;\n        b = prodA & 0xffffffffL;\n\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n\n        ac = a * c;\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        long prod2B = bd + (ad << 32);\n        long prod2A = ac + (ad >>> 32);\n\n        bita = (bd & 0x8000000000000000L) != 0;\n        bitb = (ad & 0x80000000L ) != 0;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prod2B = prod2B + (bc << 32);\n        prod2A = prod2A + (bc >>> 32);\n\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply input by pio4bits[1] */\n        c = PI_O_4_BITS[1] >>> 32;\n        d = PI_O_4_BITS[1] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply inputB by pio4bits[0] */\n        a = prodB >>> 32;\n        b = prodB & 0xffffffffL;\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Convert to double */\ndouble tmpA = ((prod2A >> 12) / LOG_MAX_VALUE);\n        double tmpB = (((prod2A & 0xfffL) << 40) + (prod2B >>> 24)) / TWO_POWER_52 / TWO_POWER_52; // Low bits\n\n        double sumA = tmpA + tmpB;\n        double sumB = -(sumA - tmpA - tmpB);\n\n        /* Multiply by PI/2 and return */\n        result[0] = intPart;\n        result[1] = sumA * 2.0;\n        result[2] = sumB * 2.0;\n    }",
          "9": "    private static void reducePayneHanek(double x, double result[])\n    {\n        /* Convert input double to bits */\n        long inbits = Double.doubleToRawLongBits(x);\n        int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n\n        /* Convert to fixed point representation */\n        inbits &= 0x000fffffffffffffL;\n        inbits |= 0x0010000000000000L;\n\n        /* Normalize input to be between 0.5 and 1.0 */\n        exponent++;\n        inbits <<= 11;\n\n        /* Based on the exponent, get a shifted copy of recip2pi */\n        long shpi0;\n        long shpiA;\n        long shpiB;\n        int idx = exponent >> 6;\n        int shift = exponent - (idx << 6);\n\n        if (shift != 0) {\n            shpi0 = (idx == 0) ? 0 : (RECIP_2PI[idx-1] << shift);\n            shpi0 |= RECIP_2PI[idx] >>> (64-shift);\n            shpiA = (RECIP_2PI[idx] << shift) | (RECIP_2PI[idx+1] >>> (64-shift));\n            shpiB = (RECIP_2PI[idx+1] << shift) | (RECIP_2PI[idx+2] >>> (64-shift));\n        } else {\n            shpi0 = (idx == 0) ? 0 : RECIP_2PI[idx-1];\n            shpiA = RECIP_2PI[idx];\n            shpiB = RECIP_2PI[idx+1];\n        }\n\n        /* Multiply input by shpiA */\n        long a = inbits >>> 32;\n        long b = inbits & 0xffffffffL;\n\n        long c = shpiA >>> 32;\n        long d = shpiA & 0xffffffffL;\n\n        long ac = a * c;\n        long bd = b * d;\n        long bc = b * c;\n        long ad = a * d;\n\n        long prodB = bd + (ad << 32);\n        long prodA = ac + (ad >>> 32);\n\n        boolean bita = (bd & 0x8000000000000000L) != 0;\n        boolean bitb = (ad & 0x80000000L ) != 0;\n        boolean bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prodB = prodB + (bc << 32);\n        prodA = prodA + (bc >>> 32);\n\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply input by shpiB */\n        c = shpiB >>> 32;\n        d = shpiB & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prodB += ac;\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply by shpi0 */\n        c = shpi0 >>> 32;\n        d = shpi0 & 0xffffffffL;\n\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        prodA += bd + ((bc + ad) << 32);\n\n        /*\n         * prodA, prodB now contain the remainder as a fraction of PI.  We want this as a fraction of\n         * PI/2, so use the following steps:\n         * 1.) multiply by 4.\n         * 2.) do a fixed point muliply by PI/4.\n         * 3.) Convert to floating point.\n         * 4.) Multiply by 2\n         */\n\n        /* This identifies the quadrant */\n        int intPart = (int)(prodA >>> 62);\n\n        /* Multiply by 4 */\n        prodA <<= 2;\n        prodA |= prodB >>> 62;\n        prodB <<= 2;\n\n        /* Multiply by PI/4 */\n        a = prodA >>> 32;\n        b = prodA & 0xffffffffL;\n\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n\n        ac = a * c;\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        long prod2B = bd + (ad << 32);\n        long prod2A = ac + (ad >>> 32);\n\n        bita = (bd & 0x8000000000000000L) != 0;\n        bitb = (ad & 0x80000000L ) != 0;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prod2B = prod2B + (bc << 32);\n        prod2A = prod2A + (bc >>> 32);\n\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply input by pio4bits[1] */\n        c = PI_O_4_BITS[1] >>> 32;\n        d = PI_O_4_BITS[1] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply inputB by pio4bits[0] */\n        a = prodB >>> 32;\n        b = prodB & 0xffffffffL;\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Convert to double */\ndouble tmpA = ((prod2A >> 12) / LN_2_A);\n        double tmpB = (((prod2A & 0xfffL) << 40) + (prod2B >>> 24)) / TWO_POWER_52 / TWO_POWER_52; // Low bits\n\n        double sumA = tmpA + tmpB;\n        double sumB = -(sumA - tmpA - tmpB);\n\n        /* Multiply by PI/2 and return */\n        result[0] = intPart;\n        result[1] = sumA * 2.0;\n        result[2] = sumB * 2.0;\n    }",
          "10": "    private static void reducePayneHanek(double x, double result[])\n    {\n        /* Convert input double to bits */\n        long inbits = Double.doubleToRawLongBits(x);\n        int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n\n        /* Convert to fixed point representation */\n        inbits &= 0x000fffffffffffffL;\n        inbits |= 0x0010000000000000L;\n\n        /* Normalize input to be between 0.5 and 1.0 */\n        exponent++;\n        inbits <<= 11;\n\n        /* Based on the exponent, get a shifted copy of recip2pi */\n        long shpi0;\n        long shpiA;\n        long shpiB;\n        int idx = exponent >> 6;\n        int shift = exponent - (idx << 6);\n\n        if (shift != 0) {\n            shpi0 = (idx == 0) ? 0 : (RECIP_2PI[idx-1] << shift);\n            shpi0 |= RECIP_2PI[idx] >>> (64-shift);\n            shpiA = (RECIP_2PI[idx] << shift) | (RECIP_2PI[idx+1] >>> (64-shift));\n            shpiB = (RECIP_2PI[idx+1] << shift) | (RECIP_2PI[idx+2] >>> (64-shift));\n        } else {\n            shpi0 = (idx == 0) ? 0 : RECIP_2PI[idx-1];\n            shpiA = RECIP_2PI[idx];\n            shpiB = RECIP_2PI[idx+1];\n        }\n\n        /* Multiply input by shpiA */\n        long a = inbits >>> 32;\n        long b = inbits & 0xffffffffL;\n\n        long c = shpiA >>> 32;\n        long d = shpiA & 0xffffffffL;\n\n        long ac = a * c;\n        long bd = b * d;\n        long bc = b * c;\n        long ad = a * d;\n\n        long prodB = bd + (ad << 32);\n        long prodA = ac + (ad >>> 32);\n\n        boolean bita = (bd & 0x8000000000000000L) != 0;\n        boolean bitb = (ad & 0x80000000L ) != 0;\n        boolean bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prodB = prodB + (bc << 32);\n        prodA = prodA + (bc >>> 32);\n\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply input by shpiB */\n        c = shpiB >>> 32;\n        d = shpiB & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prodB += ac;\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply by shpi0 */\n        c = shpi0 >>> 32;\n        d = shpi0 & 0xffffffffL;\n\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        prodA += bd + ((bc + ad) << 32);\n\n        /*\n         * prodA, prodB now contain the remainder as a fraction of PI.  We want this as a fraction of\n         * PI/2, so use the following steps:\n         * 1.) multiply by 4.\n         * 2.) do a fixed point muliply by PI/4.\n         * 3.) Convert to floating point.\n         * 4.) Multiply by 2\n         */\n\n        /* This identifies the quadrant */\n        int intPart = (int)(prodA >>> 62);\n\n        /* Multiply by 4 */\n        prodA <<= 2;\n        prodA |= prodB >>> 62;\n        prodB <<= 2;\n\n        /* Multiply by PI/4 */\n        a = prodA >>> 32;\n        b = prodA & 0xffffffffL;\n\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n\n        ac = a * c;\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        long prod2B = bd + (ad << 32);\n        long prod2A = ac + (ad >>> 32);\n\n        bita = (bd & 0x8000000000000000L) != 0;\n        bitb = (ad & 0x80000000L ) != 0;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prod2B = prod2B + (bc << 32);\n        prod2A = prod2A + (bc >>> 32);\n\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply input by pio4bits[1] */\n        c = PI_O_4_BITS[1] >>> 32;\n        d = PI_O_4_BITS[1] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply inputB by pio4bits[0] */\n        a = prodB >>> 32;\n        b = prodB & 0xffffffffL;\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Convert to double */\ndouble tmpA = ((prod2A >> 12) / LN_2_B);\n        double tmpB = (((prod2A & 0xfffL) << 40) + (prod2B >>> 24)) / TWO_POWER_52 / TWO_POWER_52; // Low bits\n\n        double sumA = tmpA + tmpB;\n        double sumB = -(sumA - tmpA - tmpB);\n\n        /* Multiply by PI/2 and return */\n        result[0] = intPart;\n        result[1] = sumA * 2.0;\n        result[2] = sumB * 2.0;\n    }",
          "11": "    private static void reducePayneHanek(double x, double result[])\n    {\n        /* Convert input double to bits */\n        long inbits = Double.doubleToRawLongBits(x);\n        int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n\n        /* Convert to fixed point representation */\n        inbits &= 0x000fffffffffffffL;\n        inbits |= 0x0010000000000000L;\n\n        /* Normalize input to be between 0.5 and 1.0 */\n        exponent++;\n        inbits <<= 11;\n\n        /* Based on the exponent, get a shifted copy of recip2pi */\n        long shpi0;\n        long shpiA;\n        long shpiB;\n        int idx = exponent >> 6;\n        int shift = exponent - (idx << 6);\n\n        if (shift != 0) {\n            shpi0 = (idx == 0) ? 0 : (RECIP_2PI[idx-1] << shift);\n            shpi0 |= RECIP_2PI[idx] >>> (64-shift);\n            shpiA = (RECIP_2PI[idx] << shift) | (RECIP_2PI[idx+1] >>> (64-shift));\n            shpiB = (RECIP_2PI[idx+1] << shift) | (RECIP_2PI[idx+2] >>> (64-shift));\n        } else {\n            shpi0 = (idx == 0) ? 0 : RECIP_2PI[idx-1];\n            shpiA = RECIP_2PI[idx];\n            shpiB = RECIP_2PI[idx+1];\n        }\n\n        /* Multiply input by shpiA */\n        long a = inbits >>> 32;\n        long b = inbits & 0xffffffffL;\n\n        long c = shpiA >>> 32;\n        long d = shpiA & 0xffffffffL;\n\n        long ac = a * c;\n        long bd = b * d;\n        long bc = b * c;\n        long ad = a * d;\n\n        long prodB = bd + (ad << 32);\n        long prodA = ac + (ad >>> 32);\n\n        boolean bita = (bd & 0x8000000000000000L) != 0;\n        boolean bitb = (ad & 0x80000000L ) != 0;\n        boolean bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prodB = prodB + (bc << 32);\n        prodA = prodA + (bc >>> 32);\n\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply input by shpiB */\n        c = shpiB >>> 32;\n        d = shpiB & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prodB += ac;\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply by shpi0 */\n        c = shpi0 >>> 32;\n        d = shpi0 & 0xffffffffL;\n\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        prodA += bd + ((bc + ad) << 32);\n\n        /*\n         * prodA, prodB now contain the remainder as a fraction of PI.  We want this as a fraction of\n         * PI/2, so use the following steps:\n         * 1.) multiply by 4.\n         * 2.) do a fixed point muliply by PI/4.\n         * 3.) Convert to floating point.\n         * 4.) Multiply by 2\n         */\n\n        /* This identifies the quadrant */\n        int intPart = (int)(prodA >>> 62);\n\n        /* Multiply by 4 */\n        prodA <<= 2;\n        prodA |= prodB >>> 62;\n        prodB <<= 2;\n\n        /* Multiply by PI/4 */\n        a = prodA >>> 32;\n        b = prodA & 0xffffffffL;\n\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n\n        ac = a * c;\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        long prod2B = bd + (ad << 32);\n        long prod2A = ac + (ad >>> 32);\n\n        bita = (bd & 0x8000000000000000L) != 0;\n        bitb = (ad & 0x80000000L ) != 0;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prod2B = prod2B + (bc << 32);\n        prod2A = prod2A + (bc >>> 32);\n\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply input by pio4bits[1] */\n        c = PI_O_4_BITS[1] >>> 32;\n        d = PI_O_4_BITS[1] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply inputB by pio4bits[0] */\n        a = prodB >>> 32;\n        b = prodB & 0xffffffffL;\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Convert to double */\ndouble tmpA = ((prod2A >> 12) / LN_QUICK_COEF);\n        double tmpB = (((prod2A & 0xfffL) << 40) + (prod2B >>> 24)) / TWO_POWER_52 / TWO_POWER_52; // Low bits\n\n        double sumA = tmpA + tmpB;\n        double sumB = -(sumA - tmpA - tmpB);\n\n        /* Multiply by PI/2 and return */\n        result[0] = intPart;\n        result[1] = sumA * 2.0;\n        result[2] = sumB * 2.0;\n    }",
          "12": "    private static void reducePayneHanek(double x, double result[])\n    {\n        /* Convert input double to bits */\n        long inbits = Double.doubleToRawLongBits(x);\n        int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n\n        /* Convert to fixed point representation */\n        inbits &= 0x000fffffffffffffL;\n        inbits |= 0x0010000000000000L;\n\n        /* Normalize input to be between 0.5 and 1.0 */\n        exponent++;\n        inbits <<= 11;\n\n        /* Based on the exponent, get a shifted copy of recip2pi */\n        long shpi0;\n        long shpiA;\n        long shpiB;\n        int idx = exponent >> 6;\n        int shift = exponent - (idx << 6);\n\n        if (shift != 0) {\n            shpi0 = (idx == 0) ? 0 : (RECIP_2PI[idx-1] << shift);\n            shpi0 |= RECIP_2PI[idx] >>> (64-shift);\n            shpiA = (RECIP_2PI[idx] << shift) | (RECIP_2PI[idx+1] >>> (64-shift));\n            shpiB = (RECIP_2PI[idx+1] << shift) | (RECIP_2PI[idx+2] >>> (64-shift));\n        } else {\n            shpi0 = (idx == 0) ? 0 : RECIP_2PI[idx-1];\n            shpiA = RECIP_2PI[idx];\n            shpiB = RECIP_2PI[idx+1];\n        }\n\n        /* Multiply input by shpiA */\n        long a = inbits >>> 32;\n        long b = inbits & 0xffffffffL;\n\n        long c = shpiA >>> 32;\n        long d = shpiA & 0xffffffffL;\n\n        long ac = a * c;\n        long bd = b * d;\n        long bc = b * c;\n        long ad = a * d;\n\n        long prodB = bd + (ad << 32);\n        long prodA = ac + (ad >>> 32);\n\n        boolean bita = (bd & 0x8000000000000000L) != 0;\n        boolean bitb = (ad & 0x80000000L ) != 0;\n        boolean bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prodB = prodB + (bc << 32);\n        prodA = prodA + (bc >>> 32);\n\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply input by shpiB */\n        c = shpiB >>> 32;\n        d = shpiB & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prodB += ac;\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply by shpi0 */\n        c = shpi0 >>> 32;\n        d = shpi0 & 0xffffffffL;\n\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        prodA += bd + ((bc + ad) << 32);\n\n        /*\n         * prodA, prodB now contain the remainder as a fraction of PI.  We want this as a fraction of\n         * PI/2, so use the following steps:\n         * 1.) multiply by 4.\n         * 2.) do a fixed point muliply by PI/4.\n         * 3.) Convert to floating point.\n         * 4.) Multiply by 2\n         */\n\n        /* This identifies the quadrant */\n        int intPart = (int)(prodA >>> 62);\n\n        /* Multiply by 4 */\n        prodA <<= 2;\n        prodA |= prodB >>> 62;\n        prodB <<= 2;\n\n        /* Multiply by PI/4 */\n        a = prodA >>> 32;\n        b = prodA & 0xffffffffL;\n\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n\n        ac = a * c;\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        long prod2B = bd + (ad << 32);\n        long prod2A = ac + (ad >>> 32);\n\n        bita = (bd & 0x8000000000000000L) != 0;\n        bitb = (ad & 0x80000000L ) != 0;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prod2B = prod2B + (bc << 32);\n        prod2A = prod2A + (bc >>> 32);\n\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply input by pio4bits[1] */\n        c = PI_O_4_BITS[1] >>> 32;\n        d = PI_O_4_BITS[1] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply inputB by pio4bits[0] */\n        a = prodB >>> 32;\n        b = prodB & 0xffffffffL;\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Convert to double */\ndouble tmpA = ((prod2A >> 12) / LN_HI_PREC_COEF);\n        double tmpB = (((prod2A & 0xfffL) << 40) + (prod2B >>> 24)) / TWO_POWER_52 / TWO_POWER_52; // Low bits\n\n        double sumA = tmpA + tmpB;\n        double sumB = -(sumA - tmpA - tmpB);\n\n        /* Multiply by PI/2 and return */\n        result[0] = intPart;\n        result[1] = sumA * 2.0;\n        result[2] = sumB * 2.0;\n    }",
          "13": "    private static void reducePayneHanek(double x, double result[])\n    {\n        /* Convert input double to bits */\n        long inbits = Double.doubleToRawLongBits(x);\n        int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n\n        /* Convert to fixed point representation */\n        inbits &= 0x000fffffffffffffL;\n        inbits |= 0x0010000000000000L;\n\n        /* Normalize input to be between 0.5 and 1.0 */\n        exponent++;\n        inbits <<= 11;\n\n        /* Based on the exponent, get a shifted copy of recip2pi */\n        long shpi0;\n        long shpiA;\n        long shpiB;\n        int idx = exponent >> 6;\n        int shift = exponent - (idx << 6);\n\n        if (shift != 0) {\n            shpi0 = (idx == 0) ? 0 : (RECIP_2PI[idx-1] << shift);\n            shpi0 |= RECIP_2PI[idx] >>> (64-shift);\n            shpiA = (RECIP_2PI[idx] << shift) | (RECIP_2PI[idx+1] >>> (64-shift));\n            shpiB = (RECIP_2PI[idx+1] << shift) | (RECIP_2PI[idx+2] >>> (64-shift));\n        } else {\n            shpi0 = (idx == 0) ? 0 : RECIP_2PI[idx-1];\n            shpiA = RECIP_2PI[idx];\n            shpiB = RECIP_2PI[idx+1];\n        }\n\n        /* Multiply input by shpiA */\n        long a = inbits >>> 32;\n        long b = inbits & 0xffffffffL;\n\n        long c = shpiA >>> 32;\n        long d = shpiA & 0xffffffffL;\n\n        long ac = a * c;\n        long bd = b * d;\n        long bc = b * c;\n        long ad = a * d;\n\n        long prodB = bd + (ad << 32);\n        long prodA = ac + (ad >>> 32);\n\n        boolean bita = (bd & 0x8000000000000000L) != 0;\n        boolean bitb = (ad & 0x80000000L ) != 0;\n        boolean bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prodB = prodB + (bc << 32);\n        prodA = prodA + (bc >>> 32);\n\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply input by shpiB */\n        c = shpiB >>> 32;\n        d = shpiB & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prodB += ac;\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply by shpi0 */\n        c = shpi0 >>> 32;\n        d = shpi0 & 0xffffffffL;\n\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        prodA += bd + ((bc + ad) << 32);\n\n        /*\n         * prodA, prodB now contain the remainder as a fraction of PI.  We want this as a fraction of\n         * PI/2, so use the following steps:\n         * 1.) multiply by 4.\n         * 2.) do a fixed point muliply by PI/4.\n         * 3.) Convert to floating point.\n         * 4.) Multiply by 2\n         */\n\n        /* This identifies the quadrant */\n        int intPart = (int)(prodA >>> 62);\n\n        /* Multiply by 4 */\n        prodA <<= 2;\n        prodA |= prodB >>> 62;\n        prodB <<= 2;\n\n        /* Multiply by PI/4 */\n        a = prodA >>> 32;\n        b = prodA & 0xffffffffL;\n\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n\n        ac = a * c;\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        long prod2B = bd + (ad << 32);\n        long prod2A = ac + (ad >>> 32);\n\n        bita = (bd & 0x8000000000000000L) != 0;\n        bitb = (ad & 0x80000000L ) != 0;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prod2B = prod2B + (bc << 32);\n        prod2A = prod2A + (bc >>> 32);\n\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply input by pio4bits[1] */\n        c = PI_O_4_BITS[1] >>> 32;\n        d = PI_O_4_BITS[1] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply inputB by pio4bits[0] */\n        a = prodB >>> 32;\n        b = prodB & 0xffffffffL;\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Convert to double */\ndouble tmpA = ((prod2A >> 12) / SINE_TABLE_A);\n        double tmpB = (((prod2A & 0xfffL) << 40) + (prod2B >>> 24)) / TWO_POWER_52 / TWO_POWER_52; // Low bits\n\n        double sumA = tmpA + tmpB;\n        double sumB = -(sumA - tmpA - tmpB);\n\n        /* Multiply by PI/2 and return */\n        result[0] = intPart;\n        result[1] = sumA * 2.0;\n        result[2] = sumB * 2.0;\n    }",
          "14": "    private static void reducePayneHanek(double x, double result[])\n    {\n        /* Convert input double to bits */\n        long inbits = Double.doubleToRawLongBits(x);\n        int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n\n        /* Convert to fixed point representation */\n        inbits &= 0x000fffffffffffffL;\n        inbits |= 0x0010000000000000L;\n\n        /* Normalize input to be between 0.5 and 1.0 */\n        exponent++;\n        inbits <<= 11;\n\n        /* Based on the exponent, get a shifted copy of recip2pi */\n        long shpi0;\n        long shpiA;\n        long shpiB;\n        int idx = exponent >> 6;\n        int shift = exponent - (idx << 6);\n\n        if (shift != 0) {\n            shpi0 = (idx == 0) ? 0 : (RECIP_2PI[idx-1] << shift);\n            shpi0 |= RECIP_2PI[idx] >>> (64-shift);\n            shpiA = (RECIP_2PI[idx] << shift) | (RECIP_2PI[idx+1] >>> (64-shift));\n            shpiB = (RECIP_2PI[idx+1] << shift) | (RECIP_2PI[idx+2] >>> (64-shift));\n        } else {\n            shpi0 = (idx == 0) ? 0 : RECIP_2PI[idx-1];\n            shpiA = RECIP_2PI[idx];\n            shpiB = RECIP_2PI[idx+1];\n        }\n\n        /* Multiply input by shpiA */\n        long a = inbits >>> 32;\n        long b = inbits & 0xffffffffL;\n\n        long c = shpiA >>> 32;\n        long d = shpiA & 0xffffffffL;\n\n        long ac = a * c;\n        long bd = b * d;\n        long bc = b * c;\n        long ad = a * d;\n\n        long prodB = bd + (ad << 32);\n        long prodA = ac + (ad >>> 32);\n\n        boolean bita = (bd & 0x8000000000000000L) != 0;\n        boolean bitb = (ad & 0x80000000L ) != 0;\n        boolean bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prodB = prodB + (bc << 32);\n        prodA = prodA + (bc >>> 32);\n\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply input by shpiB */\n        c = shpiB >>> 32;\n        d = shpiB & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prodB += ac;\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply by shpi0 */\n        c = shpi0 >>> 32;\n        d = shpi0 & 0xffffffffL;\n\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        prodA += bd + ((bc + ad) << 32);\n\n        /*\n         * prodA, prodB now contain the remainder as a fraction of PI.  We want this as a fraction of\n         * PI/2, so use the following steps:\n         * 1.) multiply by 4.\n         * 2.) do a fixed point muliply by PI/4.\n         * 3.) Convert to floating point.\n         * 4.) Multiply by 2\n         */\n\n        /* This identifies the quadrant */\n        int intPart = (int)(prodA >>> 62);\n\n        /* Multiply by 4 */\n        prodA <<= 2;\n        prodA |= prodB >>> 62;\n        prodB <<= 2;\n\n        /* Multiply by PI/4 */\n        a = prodA >>> 32;\n        b = prodA & 0xffffffffL;\n\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n\n        ac = a * c;\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        long prod2B = bd + (ad << 32);\n        long prod2A = ac + (ad >>> 32);\n\n        bita = (bd & 0x8000000000000000L) != 0;\n        bitb = (ad & 0x80000000L ) != 0;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prod2B = prod2B + (bc << 32);\n        prod2A = prod2A + (bc >>> 32);\n\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply input by pio4bits[1] */\n        c = PI_O_4_BITS[1] >>> 32;\n        d = PI_O_4_BITS[1] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply inputB by pio4bits[0] */\n        a = prodB >>> 32;\n        b = prodB & 0xffffffffL;\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Convert to double */\ndouble tmpA = ((prod2A >> 12) / SINE_TABLE_B);\n        double tmpB = (((prod2A & 0xfffL) << 40) + (prod2B >>> 24)) / TWO_POWER_52 / TWO_POWER_52; // Low bits\n\n        double sumA = tmpA + tmpB;\n        double sumB = -(sumA - tmpA - tmpB);\n\n        /* Multiply by PI/2 and return */\n        result[0] = intPart;\n        result[1] = sumA * 2.0;\n        result[2] = sumB * 2.0;\n    }",
          "15": "    private static void reducePayneHanek(double x, double result[])\n    {\n        /* Convert input double to bits */\n        long inbits = Double.doubleToRawLongBits(x);\n        int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n\n        /* Convert to fixed point representation */\n        inbits &= 0x000fffffffffffffL;\n        inbits |= 0x0010000000000000L;\n\n        /* Normalize input to be between 0.5 and 1.0 */\n        exponent++;\n        inbits <<= 11;\n\n        /* Based on the exponent, get a shifted copy of recip2pi */\n        long shpi0;\n        long shpiA;\n        long shpiB;\n        int idx = exponent >> 6;\n        int shift = exponent - (idx << 6);\n\n        if (shift != 0) {\n            shpi0 = (idx == 0) ? 0 : (RECIP_2PI[idx-1] << shift);\n            shpi0 |= RECIP_2PI[idx] >>> (64-shift);\n            shpiA = (RECIP_2PI[idx] << shift) | (RECIP_2PI[idx+1] >>> (64-shift));\n            shpiB = (RECIP_2PI[idx+1] << shift) | (RECIP_2PI[idx+2] >>> (64-shift));\n        } else {\n            shpi0 = (idx == 0) ? 0 : RECIP_2PI[idx-1];\n            shpiA = RECIP_2PI[idx];\n            shpiB = RECIP_2PI[idx+1];\n        }\n\n        /* Multiply input by shpiA */\n        long a = inbits >>> 32;\n        long b = inbits & 0xffffffffL;\n\n        long c = shpiA >>> 32;\n        long d = shpiA & 0xffffffffL;\n\n        long ac = a * c;\n        long bd = b * d;\n        long bc = b * c;\n        long ad = a * d;\n\n        long prodB = bd + (ad << 32);\n        long prodA = ac + (ad >>> 32);\n\n        boolean bita = (bd & 0x8000000000000000L) != 0;\n        boolean bitb = (ad & 0x80000000L ) != 0;\n        boolean bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prodB = prodB + (bc << 32);\n        prodA = prodA + (bc >>> 32);\n\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply input by shpiB */\n        c = shpiB >>> 32;\n        d = shpiB & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prodB += ac;\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply by shpi0 */\n        c = shpi0 >>> 32;\n        d = shpi0 & 0xffffffffL;\n\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        prodA += bd + ((bc + ad) << 32);\n\n        /*\n         * prodA, prodB now contain the remainder as a fraction of PI.  We want this as a fraction of\n         * PI/2, so use the following steps:\n         * 1.) multiply by 4.\n         * 2.) do a fixed point muliply by PI/4.\n         * 3.) Convert to floating point.\n         * 4.) Multiply by 2\n         */\n\n        /* This identifies the quadrant */\n        int intPart = (int)(prodA >>> 62);\n\n        /* Multiply by 4 */\n        prodA <<= 2;\n        prodA |= prodB >>> 62;\n        prodB <<= 2;\n\n        /* Multiply by PI/4 */\n        a = prodA >>> 32;\n        b = prodA & 0xffffffffL;\n\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n\n        ac = a * c;\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        long prod2B = bd + (ad << 32);\n        long prod2A = ac + (ad >>> 32);\n\n        bita = (bd & 0x8000000000000000L) != 0;\n        bitb = (ad & 0x80000000L ) != 0;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prod2B = prod2B + (bc << 32);\n        prod2A = prod2A + (bc >>> 32);\n\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply input by pio4bits[1] */\n        c = PI_O_4_BITS[1] >>> 32;\n        d = PI_O_4_BITS[1] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply inputB by pio4bits[0] */\n        a = prodB >>> 32;\n        b = prodB & 0xffffffffL;\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Convert to double */\ndouble tmpA = ((prod2A >> 12) / COSINE_TABLE_A);\n        double tmpB = (((prod2A & 0xfffL) << 40) + (prod2B >>> 24)) / TWO_POWER_52 / TWO_POWER_52; // Low bits\n\n        double sumA = tmpA + tmpB;\n        double sumB = -(sumA - tmpA - tmpB);\n\n        /* Multiply by PI/2 and return */\n        result[0] = intPart;\n        result[1] = sumA * 2.0;\n        result[2] = sumB * 2.0;\n    }",
          "16": "    private static void reducePayneHanek(double x, double result[])\n    {\n        /* Convert input double to bits */\n        long inbits = Double.doubleToRawLongBits(x);\n        int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n\n        /* Convert to fixed point representation */\n        inbits &= 0x000fffffffffffffL;\n        inbits |= 0x0010000000000000L;\n\n        /* Normalize input to be between 0.5 and 1.0 */\n        exponent++;\n        inbits <<= 11;\n\n        /* Based on the exponent, get a shifted copy of recip2pi */\n        long shpi0;\n        long shpiA;\n        long shpiB;\n        int idx = exponent >> 6;\n        int shift = exponent - (idx << 6);\n\n        if (shift != 0) {\n            shpi0 = (idx == 0) ? 0 : (RECIP_2PI[idx-1] << shift);\n            shpi0 |= RECIP_2PI[idx] >>> (64-shift);\n            shpiA = (RECIP_2PI[idx] << shift) | (RECIP_2PI[idx+1] >>> (64-shift));\n            shpiB = (RECIP_2PI[idx+1] << shift) | (RECIP_2PI[idx+2] >>> (64-shift));\n        } else {\n            shpi0 = (idx == 0) ? 0 : RECIP_2PI[idx-1];\n            shpiA = RECIP_2PI[idx];\n            shpiB = RECIP_2PI[idx+1];\n        }\n\n        /* Multiply input by shpiA */\n        long a = inbits >>> 32;\n        long b = inbits & 0xffffffffL;\n\n        long c = shpiA >>> 32;\n        long d = shpiA & 0xffffffffL;\n\n        long ac = a * c;\n        long bd = b * d;\n        long bc = b * c;\n        long ad = a * d;\n\n        long prodB = bd + (ad << 32);\n        long prodA = ac + (ad >>> 32);\n\n        boolean bita = (bd & 0x8000000000000000L) != 0;\n        boolean bitb = (ad & 0x80000000L ) != 0;\n        boolean bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prodB = prodB + (bc << 32);\n        prodA = prodA + (bc >>> 32);\n\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply input by shpiB */\n        c = shpiB >>> 32;\n        d = shpiB & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prodB += ac;\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply by shpi0 */\n        c = shpi0 >>> 32;\n        d = shpi0 & 0xffffffffL;\n\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        prodA += bd + ((bc + ad) << 32);\n\n        /*\n         * prodA, prodB now contain the remainder as a fraction of PI.  We want this as a fraction of\n         * PI/2, so use the following steps:\n         * 1.) multiply by 4.\n         * 2.) do a fixed point muliply by PI/4.\n         * 3.) Convert to floating point.\n         * 4.) Multiply by 2\n         */\n\n        /* This identifies the quadrant */\n        int intPart = (int)(prodA >>> 62);\n\n        /* Multiply by 4 */\n        prodA <<= 2;\n        prodA |= prodB >>> 62;\n        prodB <<= 2;\n\n        /* Multiply by PI/4 */\n        a = prodA >>> 32;\n        b = prodA & 0xffffffffL;\n\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n\n        ac = a * c;\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        long prod2B = bd + (ad << 32);\n        long prod2A = ac + (ad >>> 32);\n\n        bita = (bd & 0x8000000000000000L) != 0;\n        bitb = (ad & 0x80000000L ) != 0;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prod2B = prod2B + (bc << 32);\n        prod2A = prod2A + (bc >>> 32);\n\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply input by pio4bits[1] */\n        c = PI_O_4_BITS[1] >>> 32;\n        d = PI_O_4_BITS[1] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply inputB by pio4bits[0] */\n        a = prodB >>> 32;\n        b = prodB & 0xffffffffL;\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Convert to double */\ndouble tmpA = ((prod2A >> 12) / COSINE_TABLE_B);\n        double tmpB = (((prod2A & 0xfffL) << 40) + (prod2B >>> 24)) / TWO_POWER_52 / TWO_POWER_52; // Low bits\n\n        double sumA = tmpA + tmpB;\n        double sumB = -(sumA - tmpA - tmpB);\n\n        /* Multiply by PI/2 and return */\n        result[0] = intPart;\n        result[1] = sumA * 2.0;\n        result[2] = sumB * 2.0;\n    }",
          "17": "    private static void reducePayneHanek(double x, double result[])\n    {\n        /* Convert input double to bits */\n        long inbits = Double.doubleToRawLongBits(x);\n        int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n\n        /* Convert to fixed point representation */\n        inbits &= 0x000fffffffffffffL;\n        inbits |= 0x0010000000000000L;\n\n        /* Normalize input to be between 0.5 and 1.0 */\n        exponent++;\n        inbits <<= 11;\n\n        /* Based on the exponent, get a shifted copy of recip2pi */\n        long shpi0;\n        long shpiA;\n        long shpiB;\n        int idx = exponent >> 6;\n        int shift = exponent - (idx << 6);\n\n        if (shift != 0) {\n            shpi0 = (idx == 0) ? 0 : (RECIP_2PI[idx-1] << shift);\n            shpi0 |= RECIP_2PI[idx] >>> (64-shift);\n            shpiA = (RECIP_2PI[idx] << shift) | (RECIP_2PI[idx+1] >>> (64-shift));\n            shpiB = (RECIP_2PI[idx+1] << shift) | (RECIP_2PI[idx+2] >>> (64-shift));\n        } else {\n            shpi0 = (idx == 0) ? 0 : RECIP_2PI[idx-1];\n            shpiA = RECIP_2PI[idx];\n            shpiB = RECIP_2PI[idx+1];\n        }\n\n        /* Multiply input by shpiA */\n        long a = inbits >>> 32;\n        long b = inbits & 0xffffffffL;\n\n        long c = shpiA >>> 32;\n        long d = shpiA & 0xffffffffL;\n\n        long ac = a * c;\n        long bd = b * d;\n        long bc = b * c;\n        long ad = a * d;\n\n        long prodB = bd + (ad << 32);\n        long prodA = ac + (ad >>> 32);\n\n        boolean bita = (bd & 0x8000000000000000L) != 0;\n        boolean bitb = (ad & 0x80000000L ) != 0;\n        boolean bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prodB = prodB + (bc << 32);\n        prodA = prodA + (bc >>> 32);\n\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply input by shpiB */\n        c = shpiB >>> 32;\n        d = shpiB & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prodB += ac;\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply by shpi0 */\n        c = shpi0 >>> 32;\n        d = shpi0 & 0xffffffffL;\n\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        prodA += bd + ((bc + ad) << 32);\n\n        /*\n         * prodA, prodB now contain the remainder as a fraction of PI.  We want this as a fraction of\n         * PI/2, so use the following steps:\n         * 1.) multiply by 4.\n         * 2.) do a fixed point muliply by PI/4.\n         * 3.) Convert to floating point.\n         * 4.) Multiply by 2\n         */\n\n        /* This identifies the quadrant */\n        int intPart = (int)(prodA >>> 62);\n\n        /* Multiply by 4 */\n        prodA <<= 2;\n        prodA |= prodB >>> 62;\n        prodB <<= 2;\n\n        /* Multiply by PI/4 */\n        a = prodA >>> 32;\n        b = prodA & 0xffffffffL;\n\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n\n        ac = a * c;\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        long prod2B = bd + (ad << 32);\n        long prod2A = ac + (ad >>> 32);\n\n        bita = (bd & 0x8000000000000000L) != 0;\n        bitb = (ad & 0x80000000L ) != 0;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prod2B = prod2B + (bc << 32);\n        prod2A = prod2A + (bc >>> 32);\n\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply input by pio4bits[1] */\n        c = PI_O_4_BITS[1] >>> 32;\n        d = PI_O_4_BITS[1] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply inputB by pio4bits[0] */\n        a = prodB >>> 32;\n        b = prodB & 0xffffffffL;\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Convert to double */\ndouble tmpA = ((prod2A >> 12) / TANGENT_TABLE_A);\n        double tmpB = (((prod2A & 0xfffL) << 40) + (prod2B >>> 24)) / TWO_POWER_52 / TWO_POWER_52; // Low bits\n\n        double sumA = tmpA + tmpB;\n        double sumB = -(sumA - tmpA - tmpB);\n\n        /* Multiply by PI/2 and return */\n        result[0] = intPart;\n        result[1] = sumA * 2.0;\n        result[2] = sumB * 2.0;\n    }",
          "18": "    private static void reducePayneHanek(double x, double result[])\n    {\n        /* Convert input double to bits */\n        long inbits = Double.doubleToRawLongBits(x);\n        int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n\n        /* Convert to fixed point representation */\n        inbits &= 0x000fffffffffffffL;\n        inbits |= 0x0010000000000000L;\n\n        /* Normalize input to be between 0.5 and 1.0 */\n        exponent++;\n        inbits <<= 11;\n\n        /* Based on the exponent, get a shifted copy of recip2pi */\n        long shpi0;\n        long shpiA;\n        long shpiB;\n        int idx = exponent >> 6;\n        int shift = exponent - (idx << 6);\n\n        if (shift != 0) {\n            shpi0 = (idx == 0) ? 0 : (RECIP_2PI[idx-1] << shift);\n            shpi0 |= RECIP_2PI[idx] >>> (64-shift);\n            shpiA = (RECIP_2PI[idx] << shift) | (RECIP_2PI[idx+1] >>> (64-shift));\n            shpiB = (RECIP_2PI[idx+1] << shift) | (RECIP_2PI[idx+2] >>> (64-shift));\n        } else {\n            shpi0 = (idx == 0) ? 0 : RECIP_2PI[idx-1];\n            shpiA = RECIP_2PI[idx];\n            shpiB = RECIP_2PI[idx+1];\n        }\n\n        /* Multiply input by shpiA */\n        long a = inbits >>> 32;\n        long b = inbits & 0xffffffffL;\n\n        long c = shpiA >>> 32;\n        long d = shpiA & 0xffffffffL;\n\n        long ac = a * c;\n        long bd = b * d;\n        long bc = b * c;\n        long ad = a * d;\n\n        long prodB = bd + (ad << 32);\n        long prodA = ac + (ad >>> 32);\n\n        boolean bita = (bd & 0x8000000000000000L) != 0;\n        boolean bitb = (ad & 0x80000000L ) != 0;\n        boolean bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prodB = prodB + (bc << 32);\n        prodA = prodA + (bc >>> 32);\n\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply input by shpiB */\n        c = shpiB >>> 32;\n        d = shpiB & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prodB += ac;\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply by shpi0 */\n        c = shpi0 >>> 32;\n        d = shpi0 & 0xffffffffL;\n\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        prodA += bd + ((bc + ad) << 32);\n\n        /*\n         * prodA, prodB now contain the remainder as a fraction of PI.  We want this as a fraction of\n         * PI/2, so use the following steps:\n         * 1.) multiply by 4.\n         * 2.) do a fixed point muliply by PI/4.\n         * 3.) Convert to floating point.\n         * 4.) Multiply by 2\n         */\n\n        /* This identifies the quadrant */\n        int intPart = (int)(prodA >>> 62);\n\n        /* Multiply by 4 */\n        prodA <<= 2;\n        prodA |= prodB >>> 62;\n        prodB <<= 2;\n\n        /* Multiply by PI/4 */\n        a = prodA >>> 32;\n        b = prodA & 0xffffffffL;\n\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n\n        ac = a * c;\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        long prod2B = bd + (ad << 32);\n        long prod2A = ac + (ad >>> 32);\n\n        bita = (bd & 0x8000000000000000L) != 0;\n        bitb = (ad & 0x80000000L ) != 0;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prod2B = prod2B + (bc << 32);\n        prod2A = prod2A + (bc >>> 32);\n\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply input by pio4bits[1] */\n        c = PI_O_4_BITS[1] >>> 32;\n        d = PI_O_4_BITS[1] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply inputB by pio4bits[0] */\n        a = prodB >>> 32;\n        b = prodB & 0xffffffffL;\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Convert to double */\ndouble tmpA = ((prod2A >> 12) / TANGENT_TABLE_B);\n        double tmpB = (((prod2A & 0xfffL) << 40) + (prod2B >>> 24)) / TWO_POWER_52 / TWO_POWER_52; // Low bits\n\n        double sumA = tmpA + tmpB;\n        double sumB = -(sumA - tmpA - tmpB);\n\n        /* Multiply by PI/2 and return */\n        result[0] = intPart;\n        result[1] = sumA * 2.0;\n        result[2] = sumB * 2.0;\n    }",
          "19": "    private static void reducePayneHanek(double x, double result[])\n    {\n        /* Convert input double to bits */\n        long inbits = Double.doubleToRawLongBits(x);\n        int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n\n        /* Convert to fixed point representation */\n        inbits &= 0x000fffffffffffffL;\n        inbits |= 0x0010000000000000L;\n\n        /* Normalize input to be between 0.5 and 1.0 */\n        exponent++;\n        inbits <<= 11;\n\n        /* Based on the exponent, get a shifted copy of recip2pi */\n        long shpi0;\n        long shpiA;\n        long shpiB;\n        int idx = exponent >> 6;\n        int shift = exponent - (idx << 6);\n\n        if (shift != 0) {\n            shpi0 = (idx == 0) ? 0 : (RECIP_2PI[idx-1] << shift);\n            shpi0 |= RECIP_2PI[idx] >>> (64-shift);\n            shpiA = (RECIP_2PI[idx] << shift) | (RECIP_2PI[idx+1] >>> (64-shift));\n            shpiB = (RECIP_2PI[idx+1] << shift) | (RECIP_2PI[idx+2] >>> (64-shift));\n        } else {\n            shpi0 = (idx == 0) ? 0 : RECIP_2PI[idx-1];\n            shpiA = RECIP_2PI[idx];\n            shpiB = RECIP_2PI[idx+1];\n        }\n\n        /* Multiply input by shpiA */\n        long a = inbits >>> 32;\n        long b = inbits & 0xffffffffL;\n\n        long c = shpiA >>> 32;\n        long d = shpiA & 0xffffffffL;\n\n        long ac = a * c;\n        long bd = b * d;\n        long bc = b * c;\n        long ad = a * d;\n\n        long prodB = bd + (ad << 32);\n        long prodA = ac + (ad >>> 32);\n\n        boolean bita = (bd & 0x8000000000000000L) != 0;\n        boolean bitb = (ad & 0x80000000L ) != 0;\n        boolean bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prodB = prodB + (bc << 32);\n        prodA = prodA + (bc >>> 32);\n\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply input by shpiB */\n        c = shpiB >>> 32;\n        d = shpiB & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prodB += ac;\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply by shpi0 */\n        c = shpi0 >>> 32;\n        d = shpi0 & 0xffffffffL;\n\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        prodA += bd + ((bc + ad) << 32);\n\n        /*\n         * prodA, prodB now contain the remainder as a fraction of PI.  We want this as a fraction of\n         * PI/2, so use the following steps:\n         * 1.) multiply by 4.\n         * 2.) do a fixed point muliply by PI/4.\n         * 3.) Convert to floating point.\n         * 4.) Multiply by 2\n         */\n\n        /* This identifies the quadrant */\n        int intPart = (int)(prodA >>> 62);\n\n        /* Multiply by 4 */\n        prodA <<= 2;\n        prodA |= prodB >>> 62;\n        prodB <<= 2;\n\n        /* Multiply by PI/4 */\n        a = prodA >>> 32;\n        b = prodA & 0xffffffffL;\n\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n\n        ac = a * c;\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        long prod2B = bd + (ad << 32);\n        long prod2A = ac + (ad >>> 32);\n\n        bita = (bd & 0x8000000000000000L) != 0;\n        bitb = (ad & 0x80000000L ) != 0;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prod2B = prod2B + (bc << 32);\n        prod2A = prod2A + (bc >>> 32);\n\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply input by pio4bits[1] */\n        c = PI_O_4_BITS[1] >>> 32;\n        d = PI_O_4_BITS[1] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply inputB by pio4bits[0] */\n        a = prodB >>> 32;\n        b = prodB & 0xffffffffL;\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Convert to double */\ndouble tmpA = ((prod2A >> 12) / EIGHTHS);\n        double tmpB = (((prod2A & 0xfffL) << 40) + (prod2B >>> 24)) / TWO_POWER_52 / TWO_POWER_52; // Low bits\n\n        double sumA = tmpA + tmpB;\n        double sumB = -(sumA - tmpA - tmpB);\n\n        /* Multiply by PI/2 and return */\n        result[0] = intPart;\n        result[1] = sumA * 2.0;\n        result[2] = sumB * 2.0;\n    }",
          "20": "    private static void reducePayneHanek(double x, double result[])\n    {\n        /* Convert input double to bits */\n        long inbits = Double.doubleToRawLongBits(x);\n        int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n\n        /* Convert to fixed point representation */\n        inbits &= 0x000fffffffffffffL;\n        inbits |= 0x0010000000000000L;\n\n        /* Normalize input to be between 0.5 and 1.0 */\n        exponent++;\n        inbits <<= 11;\n\n        /* Based on the exponent, get a shifted copy of recip2pi */\n        long shpi0;\n        long shpiA;\n        long shpiB;\n        int idx = exponent >> 6;\n        int shift = exponent - (idx << 6);\n\n        if (shift != 0) {\n            shpi0 = (idx == 0) ? 0 : (RECIP_2PI[idx-1] << shift);\n            shpi0 |= RECIP_2PI[idx] >>> (64-shift);\n            shpiA = (RECIP_2PI[idx] << shift) | (RECIP_2PI[idx+1] >>> (64-shift));\n            shpiB = (RECIP_2PI[idx+1] << shift) | (RECIP_2PI[idx+2] >>> (64-shift));\n        } else {\n            shpi0 = (idx == 0) ? 0 : RECIP_2PI[idx-1];\n            shpiA = RECIP_2PI[idx];\n            shpiB = RECIP_2PI[idx+1];\n        }\n\n        /* Multiply input by shpiA */\n        long a = inbits >>> 32;\n        long b = inbits & 0xffffffffL;\n\n        long c = shpiA >>> 32;\n        long d = shpiA & 0xffffffffL;\n\n        long ac = a * c;\n        long bd = b * d;\n        long bc = b * c;\n        long ad = a * d;\n\n        long prodB = bd + (ad << 32);\n        long prodA = ac + (ad >>> 32);\n\n        boolean bita = (bd & 0x8000000000000000L) != 0;\n        boolean bitb = (ad & 0x80000000L ) != 0;\n        boolean bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prodB = prodB + (bc << 32);\n        prodA = prodA + (bc >>> 32);\n\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply input by shpiB */\n        c = shpiB >>> 32;\n        d = shpiB & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prodB += ac;\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply by shpi0 */\n        c = shpi0 >>> 32;\n        d = shpi0 & 0xffffffffL;\n\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        prodA += bd + ((bc + ad) << 32);\n\n        /*\n         * prodA, prodB now contain the remainder as a fraction of PI.  We want this as a fraction of\n         * PI/2, so use the following steps:\n         * 1.) multiply by 4.\n         * 2.) do a fixed point muliply by PI/4.\n         * 3.) Convert to floating point.\n         * 4.) Multiply by 2\n         */\n\n        /* This identifies the quadrant */\n        int intPart = (int)(prodA >>> 62);\n\n        /* Multiply by 4 */\n        prodA <<= 2;\n        prodA |= prodB >>> 62;\n        prodB <<= 2;\n\n        /* Multiply by PI/4 */\n        a = prodA >>> 32;\n        b = prodA & 0xffffffffL;\n\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n\n        ac = a * c;\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        long prod2B = bd + (ad << 32);\n        long prod2A = ac + (ad >>> 32);\n\n        bita = (bd & 0x8000000000000000L) != 0;\n        bitb = (ad & 0x80000000L ) != 0;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prod2B = prod2B + (bc << 32);\n        prod2A = prod2A + (bc >>> 32);\n\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply input by pio4bits[1] */\n        c = PI_O_4_BITS[1] >>> 32;\n        d = PI_O_4_BITS[1] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply inputB by pio4bits[0] */\n        a = prodB >>> 32;\n        b = prodB & 0xffffffffL;\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Convert to double */\ndouble tmpA = ((prod2A >> 12) / CBRTTWO);\n        double tmpB = (((prod2A & 0xfffL) << 40) + (prod2B >>> 24)) / TWO_POWER_52 / TWO_POWER_52; // Low bits\n\n        double sumA = tmpA + tmpB;\n        double sumB = -(sumA - tmpA - tmpB);\n\n        /* Multiply by PI/2 and return */\n        result[0] = intPart;\n        result[1] = sumA * 2.0;\n        result[2] = sumB * 2.0;\n    }",
          "21": "    private static void reducePayneHanek(double x, double result[])\n    {\n        /* Convert input double to bits */\n        long inbits = Double.doubleToRawLongBits(x);\n        int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n\n        /* Convert to fixed point representation */\n        inbits &= 0x000fffffffffffffL;\n        inbits |= 0x0010000000000000L;\n\n        /* Normalize input to be between 0.5 and 1.0 */\n        exponent++;\n        inbits <<= 11;\n\n        /* Based on the exponent, get a shifted copy of recip2pi */\n        long shpi0;\n        long shpiA;\n        long shpiB;\n        int idx = exponent >> 6;\n        int shift = exponent - (idx << 6);\n\n        if (shift != 0) {\n            shpi0 = (idx == 0) ? 0 : (RECIP_2PI[idx-1] << shift);\n            shpi0 |= RECIP_2PI[idx] >>> (64-shift);\n            shpiA = (RECIP_2PI[idx] << shift) | (RECIP_2PI[idx+1] >>> (64-shift));\n            shpiB = (RECIP_2PI[idx+1] << shift) | (RECIP_2PI[idx+2] >>> (64-shift));\n        } else {\n            shpi0 = (idx == 0) ? 0 : RECIP_2PI[idx-1];\n            shpiA = RECIP_2PI[idx];\n            shpiB = RECIP_2PI[idx+1];\n        }\n\n        /* Multiply input by shpiA */\n        long a = inbits >>> 32;\n        long b = inbits & 0xffffffffL;\n\n        long c = shpiA >>> 32;\n        long d = shpiA & 0xffffffffL;\n\n        long ac = a * c;\n        long bd = b * d;\n        long bc = b * c;\n        long ad = a * d;\n\n        long prodB = bd + (ad << 32);\n        long prodA = ac + (ad >>> 32);\n\n        boolean bita = (bd & 0x8000000000000000L) != 0;\n        boolean bitb = (ad & 0x80000000L ) != 0;\n        boolean bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prodB = prodB + (bc << 32);\n        prodA = prodA + (bc >>> 32);\n\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply input by shpiB */\n        c = shpiB >>> 32;\n        d = shpiB & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prodB += ac;\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply by shpi0 */\n        c = shpi0 >>> 32;\n        d = shpi0 & 0xffffffffL;\n\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        prodA += bd + ((bc + ad) << 32);\n\n        /*\n         * prodA, prodB now contain the remainder as a fraction of PI.  We want this as a fraction of\n         * PI/2, so use the following steps:\n         * 1.) multiply by 4.\n         * 2.) do a fixed point muliply by PI/4.\n         * 3.) Convert to floating point.\n         * 4.) Multiply by 2\n         */\n\n        /* This identifies the quadrant */\n        int intPart = (int)(prodA >>> 62);\n\n        /* Multiply by 4 */\n        prodA <<= 2;\n        prodA |= prodB >>> 62;\n        prodB <<= 2;\n\n        /* Multiply by PI/4 */\n        a = prodA >>> 32;\n        b = prodA & 0xffffffffL;\n\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n\n        ac = a * c;\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        long prod2B = bd + (ad << 32);\n        long prod2A = ac + (ad >>> 32);\n\n        bita = (bd & 0x8000000000000000L) != 0;\n        bitb = (ad & 0x80000000L ) != 0;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prod2B = prod2B + (bc << 32);\n        prod2A = prod2A + (bc >>> 32);\n\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply input by pio4bits[1] */\n        c = PI_O_4_BITS[1] >>> 32;\n        d = PI_O_4_BITS[1] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply inputB by pio4bits[0] */\n        a = prodB >>> 32;\n        b = prodB & 0xffffffffL;\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Convert to double */\ndouble tmpA = ((prod2A >> 12) / TWO_POWER_53);\n        double tmpB = (((prod2A & 0xfffL) << 40) + (prod2B >>> 24)) / TWO_POWER_52 / TWO_POWER_52; // Low bits\n\n        double sumA = tmpA + tmpB;\n        double sumB = -(sumA - tmpA - tmpB);\n\n        /* Multiply by PI/2 and return */\n        result[0] = intPart;\n        result[1] = sumA * 2.0;\n        result[2] = sumB * 2.0;\n    }",
          "22": "    private static void reducePayneHanek(double x, double result[])\n    {\n        /* Convert input double to bits */\n        long inbits = Double.doubleToRawLongBits(x);\n        int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n\n        /* Convert to fixed point representation */\n        inbits &= 0x000fffffffffffffL;\n        inbits |= 0x0010000000000000L;\n\n        /* Normalize input to be between 0.5 and 1.0 */\n        exponent++;\n        inbits <<= 11;\n\n        /* Based on the exponent, get a shifted copy of recip2pi */\n        long shpi0;\n        long shpiA;\n        long shpiB;\n        int idx = exponent >> 6;\n        int shift = exponent - (idx << 6);\n\n        if (shift != 0) {\n            shpi0 = (idx == 0) ? 0 : (RECIP_2PI[idx-1] << shift);\n            shpi0 |= RECIP_2PI[idx] >>> (64-shift);\n            shpiA = (RECIP_2PI[idx] << shift) | (RECIP_2PI[idx+1] >>> (64-shift));\n            shpiB = (RECIP_2PI[idx+1] << shift) | (RECIP_2PI[idx+2] >>> (64-shift));\n        } else {\n            shpi0 = (idx == 0) ? 0 : RECIP_2PI[idx-1];\n            shpiA = RECIP_2PI[idx];\n            shpiB = RECIP_2PI[idx+1];\n        }\n\n        /* Multiply input by shpiA */\n        long a = inbits >>> 32;\n        long b = inbits & 0xffffffffL;\n\n        long c = shpiA >>> 32;\n        long d = shpiA & 0xffffffffL;\n\n        long ac = a * c;\n        long bd = b * d;\n        long bc = b * c;\n        long ad = a * d;\n\n        long prodB = bd + (ad << 32);\n        long prodA = ac + (ad >>> 32);\n\n        boolean bita = (bd & 0x8000000000000000L) != 0;\n        boolean bitb = (ad & 0x80000000L ) != 0;\n        boolean bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prodB = prodB + (bc << 32);\n        prodA = prodA + (bc >>> 32);\n\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply input by shpiB */\n        c = shpiB >>> 32;\n        d = shpiB & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prodB += ac;\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply by shpi0 */\n        c = shpi0 >>> 32;\n        d = shpi0 & 0xffffffffL;\n\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        prodA += bd + ((bc + ad) << 32);\n\n        /*\n         * prodA, prodB now contain the remainder as a fraction of PI.  We want this as a fraction of\n         * PI/2, so use the following steps:\n         * 1.) multiply by 4.\n         * 2.) do a fixed point muliply by PI/4.\n         * 3.) Convert to floating point.\n         * 4.) Multiply by 2\n         */\n\n        /* This identifies the quadrant */\n        int intPart = (int)(prodA >>> 62);\n\n        /* Multiply by 4 */\n        prodA <<= 2;\n        prodA |= prodB >>> 62;\n        prodB <<= 2;\n\n        /* Multiply by PI/4 */\n        a = prodA >>> 32;\n        b = prodA & 0xffffffffL;\n\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n\n        ac = a * c;\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        long prod2B = bd + (ad << 32);\n        long prod2A = ac + (ad >>> 32);\n\n        bita = (bd & 0x8000000000000000L) != 0;\n        bitb = (ad & 0x80000000L ) != 0;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prod2B = prod2B + (bc << 32);\n        prod2A = prod2A + (bc >>> 32);\n\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply input by pio4bits[1] */\n        c = PI_O_4_BITS[1] >>> 32;\n        d = PI_O_4_BITS[1] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply inputB by pio4bits[0] */\n        a = prodB >>> 32;\n        b = prodB & 0xffffffffL;\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Convert to double */\ndouble tmpA = ((prod2A >> 12) / F_1_3);\n        double tmpB = (((prod2A & 0xfffL) << 40) + (prod2B >>> 24)) / TWO_POWER_52 / TWO_POWER_52; // Low bits\n\n        double sumA = tmpA + tmpB;\n        double sumB = -(sumA - tmpA - tmpB);\n\n        /* Multiply by PI/2 and return */\n        result[0] = intPart;\n        result[1] = sumA * 2.0;\n        result[2] = sumB * 2.0;\n    }",
          "23": "    private static void reducePayneHanek(double x, double result[])\n    {\n        /* Convert input double to bits */\n        long inbits = Double.doubleToRawLongBits(x);\n        int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n\n        /* Convert to fixed point representation */\n        inbits &= 0x000fffffffffffffL;\n        inbits |= 0x0010000000000000L;\n\n        /* Normalize input to be between 0.5 and 1.0 */\n        exponent++;\n        inbits <<= 11;\n\n        /* Based on the exponent, get a shifted copy of recip2pi */\n        long shpi0;\n        long shpiA;\n        long shpiB;\n        int idx = exponent >> 6;\n        int shift = exponent - (idx << 6);\n\n        if (shift != 0) {\n            shpi0 = (idx == 0) ? 0 : (RECIP_2PI[idx-1] << shift);\n            shpi0 |= RECIP_2PI[idx] >>> (64-shift);\n            shpiA = (RECIP_2PI[idx] << shift) | (RECIP_2PI[idx+1] >>> (64-shift));\n            shpiB = (RECIP_2PI[idx+1] << shift) | (RECIP_2PI[idx+2] >>> (64-shift));\n        } else {\n            shpi0 = (idx == 0) ? 0 : RECIP_2PI[idx-1];\n            shpiA = RECIP_2PI[idx];\n            shpiB = RECIP_2PI[idx+1];\n        }\n\n        /* Multiply input by shpiA */\n        long a = inbits >>> 32;\n        long b = inbits & 0xffffffffL;\n\n        long c = shpiA >>> 32;\n        long d = shpiA & 0xffffffffL;\n\n        long ac = a * c;\n        long bd = b * d;\n        long bc = b * c;\n        long ad = a * d;\n\n        long prodB = bd + (ad << 32);\n        long prodA = ac + (ad >>> 32);\n\n        boolean bita = (bd & 0x8000000000000000L) != 0;\n        boolean bitb = (ad & 0x80000000L ) != 0;\n        boolean bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prodB = prodB + (bc << 32);\n        prodA = prodA + (bc >>> 32);\n\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply input by shpiB */\n        c = shpiB >>> 32;\n        d = shpiB & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prodB += ac;\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply by shpi0 */\n        c = shpi0 >>> 32;\n        d = shpi0 & 0xffffffffL;\n\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        prodA += bd + ((bc + ad) << 32);\n\n        /*\n         * prodA, prodB now contain the remainder as a fraction of PI.  We want this as a fraction of\n         * PI/2, so use the following steps:\n         * 1.) multiply by 4.\n         * 2.) do a fixed point muliply by PI/4.\n         * 3.) Convert to floating point.\n         * 4.) Multiply by 2\n         */\n\n        /* This identifies the quadrant */\n        int intPart = (int)(prodA >>> 62);\n\n        /* Multiply by 4 */\n        prodA <<= 2;\n        prodA |= prodB >>> 62;\n        prodB <<= 2;\n\n        /* Multiply by PI/4 */\n        a = prodA >>> 32;\n        b = prodA & 0xffffffffL;\n\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n\n        ac = a * c;\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        long prod2B = bd + (ad << 32);\n        long prod2A = ac + (ad >>> 32);\n\n        bita = (bd & 0x8000000000000000L) != 0;\n        bitb = (ad & 0x80000000L ) != 0;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prod2B = prod2B + (bc << 32);\n        prod2A = prod2A + (bc >>> 32);\n\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply input by pio4bits[1] */\n        c = PI_O_4_BITS[1] >>> 32;\n        d = PI_O_4_BITS[1] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply inputB by pio4bits[0] */\n        a = prodB >>> 32;\n        b = prodB & 0xffffffffL;\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Convert to double */\ndouble tmpA = ((prod2A >> 12) / F_1_5);\n        double tmpB = (((prod2A & 0xfffL) << 40) + (prod2B >>> 24)) / TWO_POWER_52 / TWO_POWER_52; // Low bits\n\n        double sumA = tmpA + tmpB;\n        double sumB = -(sumA - tmpA - tmpB);\n\n        /* Multiply by PI/2 and return */\n        result[0] = intPart;\n        result[1] = sumA * 2.0;\n        result[2] = sumB * 2.0;\n    }",
          "24": "    private static void reducePayneHanek(double x, double result[])\n    {\n        /* Convert input double to bits */\n        long inbits = Double.doubleToRawLongBits(x);\n        int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n\n        /* Convert to fixed point representation */\n        inbits &= 0x000fffffffffffffL;\n        inbits |= 0x0010000000000000L;\n\n        /* Normalize input to be between 0.5 and 1.0 */\n        exponent++;\n        inbits <<= 11;\n\n        /* Based on the exponent, get a shifted copy of recip2pi */\n        long shpi0;\n        long shpiA;\n        long shpiB;\n        int idx = exponent >> 6;\n        int shift = exponent - (idx << 6);\n\n        if (shift != 0) {\n            shpi0 = (idx == 0) ? 0 : (RECIP_2PI[idx-1] << shift);\n            shpi0 |= RECIP_2PI[idx] >>> (64-shift);\n            shpiA = (RECIP_2PI[idx] << shift) | (RECIP_2PI[idx+1] >>> (64-shift));\n            shpiB = (RECIP_2PI[idx+1] << shift) | (RECIP_2PI[idx+2] >>> (64-shift));\n        } else {\n            shpi0 = (idx == 0) ? 0 : RECIP_2PI[idx-1];\n            shpiA = RECIP_2PI[idx];\n            shpiB = RECIP_2PI[idx+1];\n        }\n\n        /* Multiply input by shpiA */\n        long a = inbits >>> 32;\n        long b = inbits & 0xffffffffL;\n\n        long c = shpiA >>> 32;\n        long d = shpiA & 0xffffffffL;\n\n        long ac = a * c;\n        long bd = b * d;\n        long bc = b * c;\n        long ad = a * d;\n\n        long prodB = bd + (ad << 32);\n        long prodA = ac + (ad >>> 32);\n\n        boolean bita = (bd & 0x8000000000000000L) != 0;\n        boolean bitb = (ad & 0x80000000L ) != 0;\n        boolean bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prodB = prodB + (bc << 32);\n        prodA = prodA + (bc >>> 32);\n\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply input by shpiB */\n        c = shpiB >>> 32;\n        d = shpiB & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prodB += ac;\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply by shpi0 */\n        c = shpi0 >>> 32;\n        d = shpi0 & 0xffffffffL;\n\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        prodA += bd + ((bc + ad) << 32);\n\n        /*\n         * prodA, prodB now contain the remainder as a fraction of PI.  We want this as a fraction of\n         * PI/2, so use the following steps:\n         * 1.) multiply by 4.\n         * 2.) do a fixed point muliply by PI/4.\n         * 3.) Convert to floating point.\n         * 4.) Multiply by 2\n         */\n\n        /* This identifies the quadrant */\n        int intPart = (int)(prodA >>> 62);\n\n        /* Multiply by 4 */\n        prodA <<= 2;\n        prodA |= prodB >>> 62;\n        prodB <<= 2;\n\n        /* Multiply by PI/4 */\n        a = prodA >>> 32;\n        b = prodA & 0xffffffffL;\n\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n\n        ac = a * c;\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        long prod2B = bd + (ad << 32);\n        long prod2A = ac + (ad >>> 32);\n\n        bita = (bd & 0x8000000000000000L) != 0;\n        bitb = (ad & 0x80000000L ) != 0;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prod2B = prod2B + (bc << 32);\n        prod2A = prod2A + (bc >>> 32);\n\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply input by pio4bits[1] */\n        c = PI_O_4_BITS[1] >>> 32;\n        d = PI_O_4_BITS[1] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply inputB by pio4bits[0] */\n        a = prodB >>> 32;\n        b = prodB & 0xffffffffL;\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Convert to double */\ndouble tmpA = ((prod2A >> 12) / F_1_7);\n        double tmpB = (((prod2A & 0xfffL) << 40) + (prod2B >>> 24)) / TWO_POWER_52 / TWO_POWER_52; // Low bits\n\n        double sumA = tmpA + tmpB;\n        double sumB = -(sumA - tmpA - tmpB);\n\n        /* Multiply by PI/2 and return */\n        result[0] = intPart;\n        result[1] = sumA * 2.0;\n        result[2] = sumB * 2.0;\n    }",
          "25": "    private static void reducePayneHanek(double x, double result[])\n    {\n        /* Convert input double to bits */\n        long inbits = Double.doubleToRawLongBits(x);\n        int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n\n        /* Convert to fixed point representation */\n        inbits &= 0x000fffffffffffffL;\n        inbits |= 0x0010000000000000L;\n\n        /* Normalize input to be between 0.5 and 1.0 */\n        exponent++;\n        inbits <<= 11;\n\n        /* Based on the exponent, get a shifted copy of recip2pi */\n        long shpi0;\n        long shpiA;\n        long shpiB;\n        int idx = exponent >> 6;\n        int shift = exponent - (idx << 6);\n\n        if (shift != 0) {\n            shpi0 = (idx == 0) ? 0 : (RECIP_2PI[idx-1] << shift);\n            shpi0 |= RECIP_2PI[idx] >>> (64-shift);\n            shpiA = (RECIP_2PI[idx] << shift) | (RECIP_2PI[idx+1] >>> (64-shift));\n            shpiB = (RECIP_2PI[idx+1] << shift) | (RECIP_2PI[idx+2] >>> (64-shift));\n        } else {\n            shpi0 = (idx == 0) ? 0 : RECIP_2PI[idx-1];\n            shpiA = RECIP_2PI[idx];\n            shpiB = RECIP_2PI[idx+1];\n        }\n\n        /* Multiply input by shpiA */\n        long a = inbits >>> 32;\n        long b = inbits & 0xffffffffL;\n\n        long c = shpiA >>> 32;\n        long d = shpiA & 0xffffffffL;\n\n        long ac = a * c;\n        long bd = b * d;\n        long bc = b * c;\n        long ad = a * d;\n\n        long prodB = bd + (ad << 32);\n        long prodA = ac + (ad >>> 32);\n\n        boolean bita = (bd & 0x8000000000000000L) != 0;\n        boolean bitb = (ad & 0x80000000L ) != 0;\n        boolean bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prodB = prodB + (bc << 32);\n        prodA = prodA + (bc >>> 32);\n\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply input by shpiB */\n        c = shpiB >>> 32;\n        d = shpiB & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prodB += ac;\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply by shpi0 */\n        c = shpi0 >>> 32;\n        d = shpi0 & 0xffffffffL;\n\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        prodA += bd + ((bc + ad) << 32);\n\n        /*\n         * prodA, prodB now contain the remainder as a fraction of PI.  We want this as a fraction of\n         * PI/2, so use the following steps:\n         * 1.) multiply by 4.\n         * 2.) do a fixed point muliply by PI/4.\n         * 3.) Convert to floating point.\n         * 4.) Multiply by 2\n         */\n\n        /* This identifies the quadrant */\n        int intPart = (int)(prodA >>> 62);\n\n        /* Multiply by 4 */\n        prodA <<= 2;\n        prodA |= prodB >>> 62;\n        prodB <<= 2;\n\n        /* Multiply by PI/4 */\n        a = prodA >>> 32;\n        b = prodA & 0xffffffffL;\n\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n\n        ac = a * c;\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        long prod2B = bd + (ad << 32);\n        long prod2A = ac + (ad >>> 32);\n\n        bita = (bd & 0x8000000000000000L) != 0;\n        bitb = (ad & 0x80000000L ) != 0;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prod2B = prod2B + (bc << 32);\n        prod2A = prod2A + (bc >>> 32);\n\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply input by pio4bits[1] */\n        c = PI_O_4_BITS[1] >>> 32;\n        d = PI_O_4_BITS[1] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply inputB by pio4bits[0] */\n        a = prodB >>> 32;\n        b = prodB & 0xffffffffL;\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Convert to double */\ndouble tmpA = ((prod2A >> 12) / F_1_9);\n        double tmpB = (((prod2A & 0xfffL) << 40) + (prod2B >>> 24)) / TWO_POWER_52 / TWO_POWER_52; // Low bits\n\n        double sumA = tmpA + tmpB;\n        double sumB = -(sumA - tmpA - tmpB);\n\n        /* Multiply by PI/2 and return */\n        result[0] = intPart;\n        result[1] = sumA * 2.0;\n        result[2] = sumB * 2.0;\n    }",
          "26": "    private static void reducePayneHanek(double x, double result[])\n    {\n        /* Convert input double to bits */\n        long inbits = Double.doubleToRawLongBits(x);\n        int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n\n        /* Convert to fixed point representation */\n        inbits &= 0x000fffffffffffffL;\n        inbits |= 0x0010000000000000L;\n\n        /* Normalize input to be between 0.5 and 1.0 */\n        exponent++;\n        inbits <<= 11;\n\n        /* Based on the exponent, get a shifted copy of recip2pi */\n        long shpi0;\n        long shpiA;\n        long shpiB;\n        int idx = exponent >> 6;\n        int shift = exponent - (idx << 6);\n\n        if (shift != 0) {\n            shpi0 = (idx == 0) ? 0 : (RECIP_2PI[idx-1] << shift);\n            shpi0 |= RECIP_2PI[idx] >>> (64-shift);\n            shpiA = (RECIP_2PI[idx] << shift) | (RECIP_2PI[idx+1] >>> (64-shift));\n            shpiB = (RECIP_2PI[idx+1] << shift) | (RECIP_2PI[idx+2] >>> (64-shift));\n        } else {\n            shpi0 = (idx == 0) ? 0 : RECIP_2PI[idx-1];\n            shpiA = RECIP_2PI[idx];\n            shpiB = RECIP_2PI[idx+1];\n        }\n\n        /* Multiply input by shpiA */\n        long a = inbits >>> 32;\n        long b = inbits & 0xffffffffL;\n\n        long c = shpiA >>> 32;\n        long d = shpiA & 0xffffffffL;\n\n        long ac = a * c;\n        long bd = b * d;\n        long bc = b * c;\n        long ad = a * d;\n\n        long prodB = bd + (ad << 32);\n        long prodA = ac + (ad >>> 32);\n\n        boolean bita = (bd & 0x8000000000000000L) != 0;\n        boolean bitb = (ad & 0x80000000L ) != 0;\n        boolean bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prodB = prodB + (bc << 32);\n        prodA = prodA + (bc >>> 32);\n\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply input by shpiB */\n        c = shpiB >>> 32;\n        d = shpiB & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prodB += ac;\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply by shpi0 */\n        c = shpi0 >>> 32;\n        d = shpi0 & 0xffffffffL;\n\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        prodA += bd + ((bc + ad) << 32);\n\n        /*\n         * prodA, prodB now contain the remainder as a fraction of PI.  We want this as a fraction of\n         * PI/2, so use the following steps:\n         * 1.) multiply by 4.\n         * 2.) do a fixed point muliply by PI/4.\n         * 3.) Convert to floating point.\n         * 4.) Multiply by 2\n         */\n\n        /* This identifies the quadrant */\n        int intPart = (int)(prodA >>> 62);\n\n        /* Multiply by 4 */\n        prodA <<= 2;\n        prodA |= prodB >>> 62;\n        prodB <<= 2;\n\n        /* Multiply by PI/4 */\n        a = prodA >>> 32;\n        b = prodA & 0xffffffffL;\n\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n\n        ac = a * c;\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        long prod2B = bd + (ad << 32);\n        long prod2A = ac + (ad >>> 32);\n\n        bita = (bd & 0x8000000000000000L) != 0;\n        bitb = (ad & 0x80000000L ) != 0;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prod2B = prod2B + (bc << 32);\n        prod2A = prod2A + (bc >>> 32);\n\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply input by pio4bits[1] */\n        c = PI_O_4_BITS[1] >>> 32;\n        d = PI_O_4_BITS[1] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply inputB by pio4bits[0] */\n        a = prodB >>> 32;\n        b = prodB & 0xffffffffL;\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Convert to double */\ndouble tmpA = ((prod2A >> 12) / F_1_11);\n        double tmpB = (((prod2A & 0xfffL) << 40) + (prod2B >>> 24)) / TWO_POWER_52 / TWO_POWER_52; // Low bits\n\n        double sumA = tmpA + tmpB;\n        double sumB = -(sumA - tmpA - tmpB);\n\n        /* Multiply by PI/2 and return */\n        result[0] = intPart;\n        result[1] = sumA * 2.0;\n        result[2] = sumB * 2.0;\n    }",
          "27": "    private static void reducePayneHanek(double x, double result[])\n    {\n        /* Convert input double to bits */\n        long inbits = Double.doubleToRawLongBits(x);\n        int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n\n        /* Convert to fixed point representation */\n        inbits &= 0x000fffffffffffffL;\n        inbits |= 0x0010000000000000L;\n\n        /* Normalize input to be between 0.5 and 1.0 */\n        exponent++;\n        inbits <<= 11;\n\n        /* Based on the exponent, get a shifted copy of recip2pi */\n        long shpi0;\n        long shpiA;\n        long shpiB;\n        int idx = exponent >> 6;\n        int shift = exponent - (idx << 6);\n\n        if (shift != 0) {\n            shpi0 = (idx == 0) ? 0 : (RECIP_2PI[idx-1] << shift);\n            shpi0 |= RECIP_2PI[idx] >>> (64-shift);\n            shpiA = (RECIP_2PI[idx] << shift) | (RECIP_2PI[idx+1] >>> (64-shift));\n            shpiB = (RECIP_2PI[idx+1] << shift) | (RECIP_2PI[idx+2] >>> (64-shift));\n        } else {\n            shpi0 = (idx == 0) ? 0 : RECIP_2PI[idx-1];\n            shpiA = RECIP_2PI[idx];\n            shpiB = RECIP_2PI[idx+1];\n        }\n\n        /* Multiply input by shpiA */\n        long a = inbits >>> 32;\n        long b = inbits & 0xffffffffL;\n\n        long c = shpiA >>> 32;\n        long d = shpiA & 0xffffffffL;\n\n        long ac = a * c;\n        long bd = b * d;\n        long bc = b * c;\n        long ad = a * d;\n\n        long prodB = bd + (ad << 32);\n        long prodA = ac + (ad >>> 32);\n\n        boolean bita = (bd & 0x8000000000000000L) != 0;\n        boolean bitb = (ad & 0x80000000L ) != 0;\n        boolean bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prodB = prodB + (bc << 32);\n        prodA = prodA + (bc >>> 32);\n\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply input by shpiB */\n        c = shpiB >>> 32;\n        d = shpiB & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prodB += ac;\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply by shpi0 */\n        c = shpi0 >>> 32;\n        d = shpi0 & 0xffffffffL;\n\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        prodA += bd + ((bc + ad) << 32);\n\n        /*\n         * prodA, prodB now contain the remainder as a fraction of PI.  We want this as a fraction of\n         * PI/2, so use the following steps:\n         * 1.) multiply by 4.\n         * 2.) do a fixed point muliply by PI/4.\n         * 3.) Convert to floating point.\n         * 4.) Multiply by 2\n         */\n\n        /* This identifies the quadrant */\n        int intPart = (int)(prodA >>> 62);\n\n        /* Multiply by 4 */\n        prodA <<= 2;\n        prodA |= prodB >>> 62;\n        prodB <<= 2;\n\n        /* Multiply by PI/4 */\n        a = prodA >>> 32;\n        b = prodA & 0xffffffffL;\n\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n\n        ac = a * c;\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        long prod2B = bd + (ad << 32);\n        long prod2A = ac + (ad >>> 32);\n\n        bita = (bd & 0x8000000000000000L) != 0;\n        bitb = (ad & 0x80000000L ) != 0;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prod2B = prod2B + (bc << 32);\n        prod2A = prod2A + (bc >>> 32);\n\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply input by pio4bits[1] */\n        c = PI_O_4_BITS[1] >>> 32;\n        d = PI_O_4_BITS[1] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply inputB by pio4bits[0] */\n        a = prodB >>> 32;\n        b = prodB & 0xffffffffL;\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Convert to double */\ndouble tmpA = ((prod2A >> 12) / F_1_13);\n        double tmpB = (((prod2A & 0xfffL) << 40) + (prod2B >>> 24)) / TWO_POWER_52 / TWO_POWER_52; // Low bits\n\n        double sumA = tmpA + tmpB;\n        double sumB = -(sumA - tmpA - tmpB);\n\n        /* Multiply by PI/2 and return */\n        result[0] = intPart;\n        result[1] = sumA * 2.0;\n        result[2] = sumB * 2.0;\n    }",
          "28": "    private static void reducePayneHanek(double x, double result[])\n    {\n        /* Convert input double to bits */\n        long inbits = Double.doubleToRawLongBits(x);\n        int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n\n        /* Convert to fixed point representation */\n        inbits &= 0x000fffffffffffffL;\n        inbits |= 0x0010000000000000L;\n\n        /* Normalize input to be between 0.5 and 1.0 */\n        exponent++;\n        inbits <<= 11;\n\n        /* Based on the exponent, get a shifted copy of recip2pi */\n        long shpi0;\n        long shpiA;\n        long shpiB;\n        int idx = exponent >> 6;\n        int shift = exponent - (idx << 6);\n\n        if (shift != 0) {\n            shpi0 = (idx == 0) ? 0 : (RECIP_2PI[idx-1] << shift);\n            shpi0 |= RECIP_2PI[idx] >>> (64-shift);\n            shpiA = (RECIP_2PI[idx] << shift) | (RECIP_2PI[idx+1] >>> (64-shift));\n            shpiB = (RECIP_2PI[idx+1] << shift) | (RECIP_2PI[idx+2] >>> (64-shift));\n        } else {\n            shpi0 = (idx == 0) ? 0 : RECIP_2PI[idx-1];\n            shpiA = RECIP_2PI[idx];\n            shpiB = RECIP_2PI[idx+1];\n        }\n\n        /* Multiply input by shpiA */\n        long a = inbits >>> 32;\n        long b = inbits & 0xffffffffL;\n\n        long c = shpiA >>> 32;\n        long d = shpiA & 0xffffffffL;\n\n        long ac = a * c;\n        long bd = b * d;\n        long bc = b * c;\n        long ad = a * d;\n\n        long prodB = bd + (ad << 32);\n        long prodA = ac + (ad >>> 32);\n\n        boolean bita = (bd & 0x8000000000000000L) != 0;\n        boolean bitb = (ad & 0x80000000L ) != 0;\n        boolean bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prodB = prodB + (bc << 32);\n        prodA = prodA + (bc >>> 32);\n\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply input by shpiB */\n        c = shpiB >>> 32;\n        d = shpiB & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prodB += ac;\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply by shpi0 */\n        c = shpi0 >>> 32;\n        d = shpi0 & 0xffffffffL;\n\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        prodA += bd + ((bc + ad) << 32);\n\n        /*\n         * prodA, prodB now contain the remainder as a fraction of PI.  We want this as a fraction of\n         * PI/2, so use the following steps:\n         * 1.) multiply by 4.\n         * 2.) do a fixed point muliply by PI/4.\n         * 3.) Convert to floating point.\n         * 4.) Multiply by 2\n         */\n\n        /* This identifies the quadrant */\n        int intPart = (int)(prodA >>> 62);\n\n        /* Multiply by 4 */\n        prodA <<= 2;\n        prodA |= prodB >>> 62;\n        prodB <<= 2;\n\n        /* Multiply by PI/4 */\n        a = prodA >>> 32;\n        b = prodA & 0xffffffffL;\n\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n\n        ac = a * c;\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        long prod2B = bd + (ad << 32);\n        long prod2A = ac + (ad >>> 32);\n\n        bita = (bd & 0x8000000000000000L) != 0;\n        bitb = (ad & 0x80000000L ) != 0;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prod2B = prod2B + (bc << 32);\n        prod2A = prod2A + (bc >>> 32);\n\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply input by pio4bits[1] */\n        c = PI_O_4_BITS[1] >>> 32;\n        d = PI_O_4_BITS[1] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply inputB by pio4bits[0] */\n        a = prodB >>> 32;\n        b = prodB & 0xffffffffL;\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Convert to double */\ndouble tmpA = ((prod2A >> 12) / F_1_15);\n        double tmpB = (((prod2A & 0xfffL) << 40) + (prod2B >>> 24)) / TWO_POWER_52 / TWO_POWER_52; // Low bits\n\n        double sumA = tmpA + tmpB;\n        double sumB = -(sumA - tmpA - tmpB);\n\n        /* Multiply by PI/2 and return */\n        result[0] = intPart;\n        result[1] = sumA * 2.0;\n        result[2] = sumB * 2.0;\n    }",
          "29": "    private static void reducePayneHanek(double x, double result[])\n    {\n        /* Convert input double to bits */\n        long inbits = Double.doubleToRawLongBits(x);\n        int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n\n        /* Convert to fixed point representation */\n        inbits &= 0x000fffffffffffffL;\n        inbits |= 0x0010000000000000L;\n\n        /* Normalize input to be between 0.5 and 1.0 */\n        exponent++;\n        inbits <<= 11;\n\n        /* Based on the exponent, get a shifted copy of recip2pi */\n        long shpi0;\n        long shpiA;\n        long shpiB;\n        int idx = exponent >> 6;\n        int shift = exponent - (idx << 6);\n\n        if (shift != 0) {\n            shpi0 = (idx == 0) ? 0 : (RECIP_2PI[idx-1] << shift);\n            shpi0 |= RECIP_2PI[idx] >>> (64-shift);\n            shpiA = (RECIP_2PI[idx] << shift) | (RECIP_2PI[idx+1] >>> (64-shift));\n            shpiB = (RECIP_2PI[idx+1] << shift) | (RECIP_2PI[idx+2] >>> (64-shift));\n        } else {\n            shpi0 = (idx == 0) ? 0 : RECIP_2PI[idx-1];\n            shpiA = RECIP_2PI[idx];\n            shpiB = RECIP_2PI[idx+1];\n        }\n\n        /* Multiply input by shpiA */\n        long a = inbits >>> 32;\n        long b = inbits & 0xffffffffL;\n\n        long c = shpiA >>> 32;\n        long d = shpiA & 0xffffffffL;\n\n        long ac = a * c;\n        long bd = b * d;\n        long bc = b * c;\n        long ad = a * d;\n\n        long prodB = bd + (ad << 32);\n        long prodA = ac + (ad >>> 32);\n\n        boolean bita = (bd & 0x8000000000000000L) != 0;\n        boolean bitb = (ad & 0x80000000L ) != 0;\n        boolean bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prodB = prodB + (bc << 32);\n        prodA = prodA + (bc >>> 32);\n\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply input by shpiB */\n        c = shpiB >>> 32;\n        d = shpiB & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prodB += ac;\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply by shpi0 */\n        c = shpi0 >>> 32;\n        d = shpi0 & 0xffffffffL;\n\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        prodA += bd + ((bc + ad) << 32);\n\n        /*\n         * prodA, prodB now contain the remainder as a fraction of PI.  We want this as a fraction of\n         * PI/2, so use the following steps:\n         * 1.) multiply by 4.\n         * 2.) do a fixed point muliply by PI/4.\n         * 3.) Convert to floating point.\n         * 4.) Multiply by 2\n         */\n\n        /* This identifies the quadrant */\n        int intPart = (int)(prodA >>> 62);\n\n        /* Multiply by 4 */\n        prodA <<= 2;\n        prodA |= prodB >>> 62;\n        prodB <<= 2;\n\n        /* Multiply by PI/4 */\n        a = prodA >>> 32;\n        b = prodA & 0xffffffffL;\n\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n\n        ac = a * c;\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        long prod2B = bd + (ad << 32);\n        long prod2A = ac + (ad >>> 32);\n\n        bita = (bd & 0x8000000000000000L) != 0;\n        bitb = (ad & 0x80000000L ) != 0;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prod2B = prod2B + (bc << 32);\n        prod2A = prod2A + (bc >>> 32);\n\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply input by pio4bits[1] */\n        c = PI_O_4_BITS[1] >>> 32;\n        d = PI_O_4_BITS[1] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply inputB by pio4bits[0] */\n        a = prodB >>> 32;\n        b = prodB & 0xffffffffL;\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Convert to double */\ndouble tmpA = ((prod2A >> 12) / F_1_17);\n        double tmpB = (((prod2A & 0xfffL) << 40) + (prod2B >>> 24)) / TWO_POWER_52 / TWO_POWER_52; // Low bits\n\n        double sumA = tmpA + tmpB;\n        double sumB = -(sumA - tmpA - tmpB);\n\n        /* Multiply by PI/2 and return */\n        result[0] = intPart;\n        result[1] = sumA * 2.0;\n        result[2] = sumB * 2.0;\n    }",
          "30": "    private static void reducePayneHanek(double x, double result[])\n    {\n        /* Convert input double to bits */\n        long inbits = Double.doubleToRawLongBits(x);\n        int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n\n        /* Convert to fixed point representation */\n        inbits &= 0x000fffffffffffffL;\n        inbits |= 0x0010000000000000L;\n\n        /* Normalize input to be between 0.5 and 1.0 */\n        exponent++;\n        inbits <<= 11;\n\n        /* Based on the exponent, get a shifted copy of recip2pi */\n        long shpi0;\n        long shpiA;\n        long shpiB;\n        int idx = exponent >> 6;\n        int shift = exponent - (idx << 6);\n\n        if (shift != 0) {\n            shpi0 = (idx == 0) ? 0 : (RECIP_2PI[idx-1] << shift);\n            shpi0 |= RECIP_2PI[idx] >>> (64-shift);\n            shpiA = (RECIP_2PI[idx] << shift) | (RECIP_2PI[idx+1] >>> (64-shift));\n            shpiB = (RECIP_2PI[idx+1] << shift) | (RECIP_2PI[idx+2] >>> (64-shift));\n        } else {\n            shpi0 = (idx == 0) ? 0 : RECIP_2PI[idx-1];\n            shpiA = RECIP_2PI[idx];\n            shpiB = RECIP_2PI[idx+1];\n        }\n\n        /* Multiply input by shpiA */\n        long a = inbits >>> 32;\n        long b = inbits & 0xffffffffL;\n\n        long c = shpiA >>> 32;\n        long d = shpiA & 0xffffffffL;\n\n        long ac = a * c;\n        long bd = b * d;\n        long bc = b * c;\n        long ad = a * d;\n\n        long prodB = bd + (ad << 32);\n        long prodA = ac + (ad >>> 32);\n\n        boolean bita = (bd & 0x8000000000000000L) != 0;\n        boolean bitb = (ad & 0x80000000L ) != 0;\n        boolean bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prodB = prodB + (bc << 32);\n        prodA = prodA + (bc >>> 32);\n\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply input by shpiB */\n        c = shpiB >>> 32;\n        d = shpiB & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prodB += ac;\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply by shpi0 */\n        c = shpi0 >>> 32;\n        d = shpi0 & 0xffffffffL;\n\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        prodA += bd + ((bc + ad) << 32);\n\n        /*\n         * prodA, prodB now contain the remainder as a fraction of PI.  We want this as a fraction of\n         * PI/2, so use the following steps:\n         * 1.) multiply by 4.\n         * 2.) do a fixed point muliply by PI/4.\n         * 3.) Convert to floating point.\n         * 4.) Multiply by 2\n         */\n\n        /* This identifies the quadrant */\n        int intPart = (int)(prodA >>> 62);\n\n        /* Multiply by 4 */\n        prodA <<= 2;\n        prodA |= prodB >>> 62;\n        prodB <<= 2;\n\n        /* Multiply by PI/4 */\n        a = prodA >>> 32;\n        b = prodA & 0xffffffffL;\n\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n\n        ac = a * c;\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        long prod2B = bd + (ad << 32);\n        long prod2A = ac + (ad >>> 32);\n\n        bita = (bd & 0x8000000000000000L) != 0;\n        bitb = (ad & 0x80000000L ) != 0;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prod2B = prod2B + (bc << 32);\n        prod2A = prod2A + (bc >>> 32);\n\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply input by pio4bits[1] */\n        c = PI_O_4_BITS[1] >>> 32;\n        d = PI_O_4_BITS[1] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply inputB by pio4bits[0] */\n        a = prodB >>> 32;\n        b = prodB & 0xffffffffL;\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Convert to double */\ndouble tmpA = ((prod2A >> 12) / F_3_4);\n        double tmpB = (((prod2A & 0xfffL) << 40) + (prod2B >>> 24)) / TWO_POWER_52 / TWO_POWER_52; // Low bits\n\n        double sumA = tmpA + tmpB;\n        double sumB = -(sumA - tmpA - tmpB);\n\n        /* Multiply by PI/2 and return */\n        result[0] = intPart;\n        result[1] = sumA * 2.0;\n        result[2] = sumB * 2.0;\n    }",
          "31": "    private static void reducePayneHanek(double x, double result[])\n    {\n        /* Convert input double to bits */\n        long inbits = Double.doubleToRawLongBits(x);\n        int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n\n        /* Convert to fixed point representation */\n        inbits &= 0x000fffffffffffffL;\n        inbits |= 0x0010000000000000L;\n\n        /* Normalize input to be between 0.5 and 1.0 */\n        exponent++;\n        inbits <<= 11;\n\n        /* Based on the exponent, get a shifted copy of recip2pi */\n        long shpi0;\n        long shpiA;\n        long shpiB;\n        int idx = exponent >> 6;\n        int shift = exponent - (idx << 6);\n\n        if (shift != 0) {\n            shpi0 = (idx == 0) ? 0 : (RECIP_2PI[idx-1] << shift);\n            shpi0 |= RECIP_2PI[idx] >>> (64-shift);\n            shpiA = (RECIP_2PI[idx] << shift) | (RECIP_2PI[idx+1] >>> (64-shift));\n            shpiB = (RECIP_2PI[idx+1] << shift) | (RECIP_2PI[idx+2] >>> (64-shift));\n        } else {\n            shpi0 = (idx == 0) ? 0 : RECIP_2PI[idx-1];\n            shpiA = RECIP_2PI[idx];\n            shpiB = RECIP_2PI[idx+1];\n        }\n\n        /* Multiply input by shpiA */\n        long a = inbits >>> 32;\n        long b = inbits & 0xffffffffL;\n\n        long c = shpiA >>> 32;\n        long d = shpiA & 0xffffffffL;\n\n        long ac = a * c;\n        long bd = b * d;\n        long bc = b * c;\n        long ad = a * d;\n\n        long prodB = bd + (ad << 32);\n        long prodA = ac + (ad >>> 32);\n\n        boolean bita = (bd & 0x8000000000000000L) != 0;\n        boolean bitb = (ad & 0x80000000L ) != 0;\n        boolean bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prodB = prodB + (bc << 32);\n        prodA = prodA + (bc >>> 32);\n\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply input by shpiB */\n        c = shpiB >>> 32;\n        d = shpiB & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prodB += ac;\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply by shpi0 */\n        c = shpi0 >>> 32;\n        d = shpi0 & 0xffffffffL;\n\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        prodA += bd + ((bc + ad) << 32);\n\n        /*\n         * prodA, prodB now contain the remainder as a fraction of PI.  We want this as a fraction of\n         * PI/2, so use the following steps:\n         * 1.) multiply by 4.\n         * 2.) do a fixed point muliply by PI/4.\n         * 3.) Convert to floating point.\n         * 4.) Multiply by 2\n         */\n\n        /* This identifies the quadrant */\n        int intPart = (int)(prodA >>> 62);\n\n        /* Multiply by 4 */\n        prodA <<= 2;\n        prodA |= prodB >>> 62;\n        prodB <<= 2;\n\n        /* Multiply by PI/4 */\n        a = prodA >>> 32;\n        b = prodA & 0xffffffffL;\n\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n\n        ac = a * c;\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        long prod2B = bd + (ad << 32);\n        long prod2A = ac + (ad >>> 32);\n\n        bita = (bd & 0x8000000000000000L) != 0;\n        bitb = (ad & 0x80000000L ) != 0;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prod2B = prod2B + (bc << 32);\n        prod2A = prod2A + (bc >>> 32);\n\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply input by pio4bits[1] */\n        c = PI_O_4_BITS[1] >>> 32;\n        d = PI_O_4_BITS[1] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply inputB by pio4bits[0] */\n        a = prodB >>> 32;\n        b = prodB & 0xffffffffL;\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Convert to double */\ndouble tmpA = ((prod2A >> 12) / F_15_16);\n        double tmpB = (((prod2A & 0xfffL) << 40) + (prod2B >>> 24)) / TWO_POWER_52 / TWO_POWER_52; // Low bits\n\n        double sumA = tmpA + tmpB;\n        double sumB = -(sumA - tmpA - tmpB);\n\n        /* Multiply by PI/2 and return */\n        result[0] = intPart;\n        result[1] = sumA * 2.0;\n        result[2] = sumB * 2.0;\n    }",
          "32": "    private static void reducePayneHanek(double x, double result[])\n    {\n        /* Convert input double to bits */\n        long inbits = Double.doubleToRawLongBits(x);\n        int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n\n        /* Convert to fixed point representation */\n        inbits &= 0x000fffffffffffffL;\n        inbits |= 0x0010000000000000L;\n\n        /* Normalize input to be between 0.5 and 1.0 */\n        exponent++;\n        inbits <<= 11;\n\n        /* Based on the exponent, get a shifted copy of recip2pi */\n        long shpi0;\n        long shpiA;\n        long shpiB;\n        int idx = exponent >> 6;\n        int shift = exponent - (idx << 6);\n\n        if (shift != 0) {\n            shpi0 = (idx == 0) ? 0 : (RECIP_2PI[idx-1] << shift);\n            shpi0 |= RECIP_2PI[idx] >>> (64-shift);\n            shpiA = (RECIP_2PI[idx] << shift) | (RECIP_2PI[idx+1] >>> (64-shift));\n            shpiB = (RECIP_2PI[idx+1] << shift) | (RECIP_2PI[idx+2] >>> (64-shift));\n        } else {\n            shpi0 = (idx == 0) ? 0 : RECIP_2PI[idx-1];\n            shpiA = RECIP_2PI[idx];\n            shpiB = RECIP_2PI[idx+1];\n        }\n\n        /* Multiply input by shpiA */\n        long a = inbits >>> 32;\n        long b = inbits & 0xffffffffL;\n\n        long c = shpiA >>> 32;\n        long d = shpiA & 0xffffffffL;\n\n        long ac = a * c;\n        long bd = b * d;\n        long bc = b * c;\n        long ad = a * d;\n\n        long prodB = bd + (ad << 32);\n        long prodA = ac + (ad >>> 32);\n\n        boolean bita = (bd & 0x8000000000000000L) != 0;\n        boolean bitb = (ad & 0x80000000L ) != 0;\n        boolean bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prodB = prodB + (bc << 32);\n        prodA = prodA + (bc >>> 32);\n\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply input by shpiB */\n        c = shpiB >>> 32;\n        d = shpiB & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prodB += ac;\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply by shpi0 */\n        c = shpi0 >>> 32;\n        d = shpi0 & 0xffffffffL;\n\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        prodA += bd + ((bc + ad) << 32);\n\n        /*\n         * prodA, prodB now contain the remainder as a fraction of PI.  We want this as a fraction of\n         * PI/2, so use the following steps:\n         * 1.) multiply by 4.\n         * 2.) do a fixed point muliply by PI/4.\n         * 3.) Convert to floating point.\n         * 4.) Multiply by 2\n         */\n\n        /* This identifies the quadrant */\n        int intPart = (int)(prodA >>> 62);\n\n        /* Multiply by 4 */\n        prodA <<= 2;\n        prodA |= prodB >>> 62;\n        prodB <<= 2;\n\n        /* Multiply by PI/4 */\n        a = prodA >>> 32;\n        b = prodA & 0xffffffffL;\n\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n\n        ac = a * c;\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        long prod2B = bd + (ad << 32);\n        long prod2A = ac + (ad >>> 32);\n\n        bita = (bd & 0x8000000000000000L) != 0;\n        bitb = (ad & 0x80000000L ) != 0;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prod2B = prod2B + (bc << 32);\n        prod2A = prod2A + (bc >>> 32);\n\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply input by pio4bits[1] */\n        c = PI_O_4_BITS[1] >>> 32;\n        d = PI_O_4_BITS[1] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply inputB by pio4bits[0] */\n        a = prodB >>> 32;\n        b = prodB & 0xffffffffL;\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Convert to double */\ndouble tmpA = ((prod2A >> 12) / F_13_14);\n        double tmpB = (((prod2A & 0xfffL) << 40) + (prod2B >>> 24)) / TWO_POWER_52 / TWO_POWER_52; // Low bits\n\n        double sumA = tmpA + tmpB;\n        double sumB = -(sumA - tmpA - tmpB);\n\n        /* Multiply by PI/2 and return */\n        result[0] = intPart;\n        result[1] = sumA * 2.0;\n        result[2] = sumB * 2.0;\n    }",
          "33": "    private static void reducePayneHanek(double x, double result[])\n    {\n        /* Convert input double to bits */\n        long inbits = Double.doubleToRawLongBits(x);\n        int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n\n        /* Convert to fixed point representation */\n        inbits &= 0x000fffffffffffffL;\n        inbits |= 0x0010000000000000L;\n\n        /* Normalize input to be between 0.5 and 1.0 */\n        exponent++;\n        inbits <<= 11;\n\n        /* Based on the exponent, get a shifted copy of recip2pi */\n        long shpi0;\n        long shpiA;\n        long shpiB;\n        int idx = exponent >> 6;\n        int shift = exponent - (idx << 6);\n\n        if (shift != 0) {\n            shpi0 = (idx == 0) ? 0 : (RECIP_2PI[idx-1] << shift);\n            shpi0 |= RECIP_2PI[idx] >>> (64-shift);\n            shpiA = (RECIP_2PI[idx] << shift) | (RECIP_2PI[idx+1] >>> (64-shift));\n            shpiB = (RECIP_2PI[idx+1] << shift) | (RECIP_2PI[idx+2] >>> (64-shift));\n        } else {\n            shpi0 = (idx == 0) ? 0 : RECIP_2PI[idx-1];\n            shpiA = RECIP_2PI[idx];\n            shpiB = RECIP_2PI[idx+1];\n        }\n\n        /* Multiply input by shpiA */\n        long a = inbits >>> 32;\n        long b = inbits & 0xffffffffL;\n\n        long c = shpiA >>> 32;\n        long d = shpiA & 0xffffffffL;\n\n        long ac = a * c;\n        long bd = b * d;\n        long bc = b * c;\n        long ad = a * d;\n\n        long prodB = bd + (ad << 32);\n        long prodA = ac + (ad >>> 32);\n\n        boolean bita = (bd & 0x8000000000000000L) != 0;\n        boolean bitb = (ad & 0x80000000L ) != 0;\n        boolean bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prodB = prodB + (bc << 32);\n        prodA = prodA + (bc >>> 32);\n\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply input by shpiB */\n        c = shpiB >>> 32;\n        d = shpiB & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prodB += ac;\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply by shpi0 */\n        c = shpi0 >>> 32;\n        d = shpi0 & 0xffffffffL;\n\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        prodA += bd + ((bc + ad) << 32);\n\n        /*\n         * prodA, prodB now contain the remainder as a fraction of PI.  We want this as a fraction of\n         * PI/2, so use the following steps:\n         * 1.) multiply by 4.\n         * 2.) do a fixed point muliply by PI/4.\n         * 3.) Convert to floating point.\n         * 4.) Multiply by 2\n         */\n\n        /* This identifies the quadrant */\n        int intPart = (int)(prodA >>> 62);\n\n        /* Multiply by 4 */\n        prodA <<= 2;\n        prodA |= prodB >>> 62;\n        prodB <<= 2;\n\n        /* Multiply by PI/4 */\n        a = prodA >>> 32;\n        b = prodA & 0xffffffffL;\n\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n\n        ac = a * c;\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        long prod2B = bd + (ad << 32);\n        long prod2A = ac + (ad >>> 32);\n\n        bita = (bd & 0x8000000000000000L) != 0;\n        bitb = (ad & 0x80000000L ) != 0;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prod2B = prod2B + (bc << 32);\n        prod2A = prod2A + (bc >>> 32);\n\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply input by pio4bits[1] */\n        c = PI_O_4_BITS[1] >>> 32;\n        d = PI_O_4_BITS[1] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply inputB by pio4bits[0] */\n        a = prodB >>> 32;\n        b = prodB & 0xffffffffL;\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Convert to double */\ndouble tmpA = ((prod2A >> 12) / F_11_12);\n        double tmpB = (((prod2A & 0xfffL) << 40) + (prod2B >>> 24)) / TWO_POWER_52 / TWO_POWER_52; // Low bits\n\n        double sumA = tmpA + tmpB;\n        double sumB = -(sumA - tmpA - tmpB);\n\n        /* Multiply by PI/2 and return */\n        result[0] = intPart;\n        result[1] = sumA * 2.0;\n        result[2] = sumB * 2.0;\n    }",
          "34": "    private static void reducePayneHanek(double x, double result[])\n    {\n        /* Convert input double to bits */\n        long inbits = Double.doubleToRawLongBits(x);\n        int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n\n        /* Convert to fixed point representation */\n        inbits &= 0x000fffffffffffffL;\n        inbits |= 0x0010000000000000L;\n\n        /* Normalize input to be between 0.5 and 1.0 */\n        exponent++;\n        inbits <<= 11;\n\n        /* Based on the exponent, get a shifted copy of recip2pi */\n        long shpi0;\n        long shpiA;\n        long shpiB;\n        int idx = exponent >> 6;\n        int shift = exponent - (idx << 6);\n\n        if (shift != 0) {\n            shpi0 = (idx == 0) ? 0 : (RECIP_2PI[idx-1] << shift);\n            shpi0 |= RECIP_2PI[idx] >>> (64-shift);\n            shpiA = (RECIP_2PI[idx] << shift) | (RECIP_2PI[idx+1] >>> (64-shift));\n            shpiB = (RECIP_2PI[idx+1] << shift) | (RECIP_2PI[idx+2] >>> (64-shift));\n        } else {\n            shpi0 = (idx == 0) ? 0 : RECIP_2PI[idx-1];\n            shpiA = RECIP_2PI[idx];\n            shpiB = RECIP_2PI[idx+1];\n        }\n\n        /* Multiply input by shpiA */\n        long a = inbits >>> 32;\n        long b = inbits & 0xffffffffL;\n\n        long c = shpiA >>> 32;\n        long d = shpiA & 0xffffffffL;\n\n        long ac = a * c;\n        long bd = b * d;\n        long bc = b * c;\n        long ad = a * d;\n\n        long prodB = bd + (ad << 32);\n        long prodA = ac + (ad >>> 32);\n\n        boolean bita = (bd & 0x8000000000000000L) != 0;\n        boolean bitb = (ad & 0x80000000L ) != 0;\n        boolean bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prodB = prodB + (bc << 32);\n        prodA = prodA + (bc >>> 32);\n\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply input by shpiB */\n        c = shpiB >>> 32;\n        d = shpiB & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prodB += ac;\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply by shpi0 */\n        c = shpi0 >>> 32;\n        d = shpi0 & 0xffffffffL;\n\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        prodA += bd + ((bc + ad) << 32);\n\n        /*\n         * prodA, prodB now contain the remainder as a fraction of PI.  We want this as a fraction of\n         * PI/2, so use the following steps:\n         * 1.) multiply by 4.\n         * 2.) do a fixed point muliply by PI/4.\n         * 3.) Convert to floating point.\n         * 4.) Multiply by 2\n         */\n\n        /* This identifies the quadrant */\n        int intPart = (int)(prodA >>> 62);\n\n        /* Multiply by 4 */\n        prodA <<= 2;\n        prodA |= prodB >>> 62;\n        prodB <<= 2;\n\n        /* Multiply by PI/4 */\n        a = prodA >>> 32;\n        b = prodA & 0xffffffffL;\n\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n\n        ac = a * c;\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        long prod2B = bd + (ad << 32);\n        long prod2A = ac + (ad >>> 32);\n\n        bita = (bd & 0x8000000000000000L) != 0;\n        bitb = (ad & 0x80000000L ) != 0;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prod2B = prod2B + (bc << 32);\n        prod2A = prod2A + (bc >>> 32);\n\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply input by pio4bits[1] */\n        c = PI_O_4_BITS[1] >>> 32;\n        d = PI_O_4_BITS[1] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply inputB by pio4bits[0] */\n        a = prodB >>> 32;\n        b = prodB & 0xffffffffL;\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Convert to double */\ndouble tmpA = ((prod2A >> 12) / F_9_10);\n        double tmpB = (((prod2A & 0xfffL) << 40) + (prod2B >>> 24)) / TWO_POWER_52 / TWO_POWER_52; // Low bits\n\n        double sumA = tmpA + tmpB;\n        double sumB = -(sumA - tmpA - tmpB);\n\n        /* Multiply by PI/2 and return */\n        result[0] = intPart;\n        result[1] = sumA * 2.0;\n        result[2] = sumB * 2.0;\n    }",
          "35": "    private static void reducePayneHanek(double x, double result[])\n    {\n        /* Convert input double to bits */\n        long inbits = Double.doubleToRawLongBits(x);\n        int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n\n        /* Convert to fixed point representation */\n        inbits &= 0x000fffffffffffffL;\n        inbits |= 0x0010000000000000L;\n\n        /* Normalize input to be between 0.5 and 1.0 */\n        exponent++;\n        inbits <<= 11;\n\n        /* Based on the exponent, get a shifted copy of recip2pi */\n        long shpi0;\n        long shpiA;\n        long shpiB;\n        int idx = exponent >> 6;\n        int shift = exponent - (idx << 6);\n\n        if (shift != 0) {\n            shpi0 = (idx == 0) ? 0 : (RECIP_2PI[idx-1] << shift);\n            shpi0 |= RECIP_2PI[idx] >>> (64-shift);\n            shpiA = (RECIP_2PI[idx] << shift) | (RECIP_2PI[idx+1] >>> (64-shift));\n            shpiB = (RECIP_2PI[idx+1] << shift) | (RECIP_2PI[idx+2] >>> (64-shift));\n        } else {\n            shpi0 = (idx == 0) ? 0 : RECIP_2PI[idx-1];\n            shpiA = RECIP_2PI[idx];\n            shpiB = RECIP_2PI[idx+1];\n        }\n\n        /* Multiply input by shpiA */\n        long a = inbits >>> 32;\n        long b = inbits & 0xffffffffL;\n\n        long c = shpiA >>> 32;\n        long d = shpiA & 0xffffffffL;\n\n        long ac = a * c;\n        long bd = b * d;\n        long bc = b * c;\n        long ad = a * d;\n\n        long prodB = bd + (ad << 32);\n        long prodA = ac + (ad >>> 32);\n\n        boolean bita = (bd & 0x8000000000000000L) != 0;\n        boolean bitb = (ad & 0x80000000L ) != 0;\n        boolean bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prodB = prodB + (bc << 32);\n        prodA = prodA + (bc >>> 32);\n\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply input by shpiB */\n        c = shpiB >>> 32;\n        d = shpiB & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prodB += ac;\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply by shpi0 */\n        c = shpi0 >>> 32;\n        d = shpi0 & 0xffffffffL;\n\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        prodA += bd + ((bc + ad) << 32);\n\n        /*\n         * prodA, prodB now contain the remainder as a fraction of PI.  We want this as a fraction of\n         * PI/2, so use the following steps:\n         * 1.) multiply by 4.\n         * 2.) do a fixed point muliply by PI/4.\n         * 3.) Convert to floating point.\n         * 4.) Multiply by 2\n         */\n\n        /* This identifies the quadrant */\n        int intPart = (int)(prodA >>> 62);\n\n        /* Multiply by 4 */\n        prodA <<= 2;\n        prodA |= prodB >>> 62;\n        prodB <<= 2;\n\n        /* Multiply by PI/4 */\n        a = prodA >>> 32;\n        b = prodA & 0xffffffffL;\n\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n\n        ac = a * c;\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        long prod2B = bd + (ad << 32);\n        long prod2A = ac + (ad >>> 32);\n\n        bita = (bd & 0x8000000000000000L) != 0;\n        bitb = (ad & 0x80000000L ) != 0;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prod2B = prod2B + (bc << 32);\n        prod2A = prod2A + (bc >>> 32);\n\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply input by pio4bits[1] */\n        c = PI_O_4_BITS[1] >>> 32;\n        d = PI_O_4_BITS[1] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply inputB by pio4bits[0] */\n        a = prodB >>> 32;\n        b = prodB & 0xffffffffL;\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Convert to double */\ndouble tmpA = ((prod2A >> 12) / F_7_8);\n        double tmpB = (((prod2A & 0xfffL) << 40) + (prod2B >>> 24)) / TWO_POWER_52 / TWO_POWER_52; // Low bits\n\n        double sumA = tmpA + tmpB;\n        double sumB = -(sumA - tmpA - tmpB);\n\n        /* Multiply by PI/2 and return */\n        result[0] = intPart;\n        result[1] = sumA * 2.0;\n        result[2] = sumB * 2.0;\n    }",
          "36": "    private static void reducePayneHanek(double x, double result[])\n    {\n        /* Convert input double to bits */\n        long inbits = Double.doubleToRawLongBits(x);\n        int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n\n        /* Convert to fixed point representation */\n        inbits &= 0x000fffffffffffffL;\n        inbits |= 0x0010000000000000L;\n\n        /* Normalize input to be between 0.5 and 1.0 */\n        exponent++;\n        inbits <<= 11;\n\n        /* Based on the exponent, get a shifted copy of recip2pi */\n        long shpi0;\n        long shpiA;\n        long shpiB;\n        int idx = exponent >> 6;\n        int shift = exponent - (idx << 6);\n\n        if (shift != 0) {\n            shpi0 = (idx == 0) ? 0 : (RECIP_2PI[idx-1] << shift);\n            shpi0 |= RECIP_2PI[idx] >>> (64-shift);\n            shpiA = (RECIP_2PI[idx] << shift) | (RECIP_2PI[idx+1] >>> (64-shift));\n            shpiB = (RECIP_2PI[idx+1] << shift) | (RECIP_2PI[idx+2] >>> (64-shift));\n        } else {\n            shpi0 = (idx == 0) ? 0 : RECIP_2PI[idx-1];\n            shpiA = RECIP_2PI[idx];\n            shpiB = RECIP_2PI[idx+1];\n        }\n\n        /* Multiply input by shpiA */\n        long a = inbits >>> 32;\n        long b = inbits & 0xffffffffL;\n\n        long c = shpiA >>> 32;\n        long d = shpiA & 0xffffffffL;\n\n        long ac = a * c;\n        long bd = b * d;\n        long bc = b * c;\n        long ad = a * d;\n\n        long prodB = bd + (ad << 32);\n        long prodA = ac + (ad >>> 32);\n\n        boolean bita = (bd & 0x8000000000000000L) != 0;\n        boolean bitb = (ad & 0x80000000L ) != 0;\n        boolean bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prodB = prodB + (bc << 32);\n        prodA = prodA + (bc >>> 32);\n\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply input by shpiB */\n        c = shpiB >>> 32;\n        d = shpiB & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prodB += ac;\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply by shpi0 */\n        c = shpi0 >>> 32;\n        d = shpi0 & 0xffffffffL;\n\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        prodA += bd + ((bc + ad) << 32);\n\n        /*\n         * prodA, prodB now contain the remainder as a fraction of PI.  We want this as a fraction of\n         * PI/2, so use the following steps:\n         * 1.) multiply by 4.\n         * 2.) do a fixed point muliply by PI/4.\n         * 3.) Convert to floating point.\n         * 4.) Multiply by 2\n         */\n\n        /* This identifies the quadrant */\n        int intPart = (int)(prodA >>> 62);\n\n        /* Multiply by 4 */\n        prodA <<= 2;\n        prodA |= prodB >>> 62;\n        prodB <<= 2;\n\n        /* Multiply by PI/4 */\n        a = prodA >>> 32;\n        b = prodA & 0xffffffffL;\n\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n\n        ac = a * c;\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        long prod2B = bd + (ad << 32);\n        long prod2A = ac + (ad >>> 32);\n\n        bita = (bd & 0x8000000000000000L) != 0;\n        bitb = (ad & 0x80000000L ) != 0;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prod2B = prod2B + (bc << 32);\n        prod2A = prod2A + (bc >>> 32);\n\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply input by pio4bits[1] */\n        c = PI_O_4_BITS[1] >>> 32;\n        d = PI_O_4_BITS[1] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply inputB by pio4bits[0] */\n        a = prodB >>> 32;\n        b = prodB & 0xffffffffL;\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Convert to double */\ndouble tmpA = ((prod2A >> 12) / F_5_6);\n        double tmpB = (((prod2A & 0xfffL) << 40) + (prod2B >>> 24)) / TWO_POWER_52 / TWO_POWER_52; // Low bits\n\n        double sumA = tmpA + tmpB;\n        double sumB = -(sumA - tmpA - tmpB);\n\n        /* Multiply by PI/2 and return */\n        result[0] = intPart;\n        result[1] = sumA * 2.0;\n        result[2] = sumB * 2.0;\n    }",
          "37": "    private static void reducePayneHanek(double x, double result[])\n    {\n        /* Convert input double to bits */\n        long inbits = Double.doubleToRawLongBits(x);\n        int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n\n        /* Convert to fixed point representation */\n        inbits &= 0x000fffffffffffffL;\n        inbits |= 0x0010000000000000L;\n\n        /* Normalize input to be between 0.5 and 1.0 */\n        exponent++;\n        inbits <<= 11;\n\n        /* Based on the exponent, get a shifted copy of recip2pi */\n        long shpi0;\n        long shpiA;\n        long shpiB;\n        int idx = exponent >> 6;\n        int shift = exponent - (idx << 6);\n\n        if (shift != 0) {\n            shpi0 = (idx == 0) ? 0 : (RECIP_2PI[idx-1] << shift);\n            shpi0 |= RECIP_2PI[idx] >>> (64-shift);\n            shpiA = (RECIP_2PI[idx] << shift) | (RECIP_2PI[idx+1] >>> (64-shift));\n            shpiB = (RECIP_2PI[idx+1] << shift) | (RECIP_2PI[idx+2] >>> (64-shift));\n        } else {\n            shpi0 = (idx == 0) ? 0 : RECIP_2PI[idx-1];\n            shpiA = RECIP_2PI[idx];\n            shpiB = RECIP_2PI[idx+1];\n        }\n\n        /* Multiply input by shpiA */\n        long a = inbits >>> 32;\n        long b = inbits & 0xffffffffL;\n\n        long c = shpiA >>> 32;\n        long d = shpiA & 0xffffffffL;\n\n        long ac = a * c;\n        long bd = b * d;\n        long bc = b * c;\n        long ad = a * d;\n\n        long prodB = bd + (ad << 32);\n        long prodA = ac + (ad >>> 32);\n\n        boolean bita = (bd & 0x8000000000000000L) != 0;\n        boolean bitb = (ad & 0x80000000L ) != 0;\n        boolean bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prodB = prodB + (bc << 32);\n        prodA = prodA + (bc >>> 32);\n\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply input by shpiB */\n        c = shpiB >>> 32;\n        d = shpiB & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prodB += ac;\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply by shpi0 */\n        c = shpi0 >>> 32;\n        d = shpi0 & 0xffffffffL;\n\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        prodA += bd + ((bc + ad) << 32);\n\n        /*\n         * prodA, prodB now contain the remainder as a fraction of PI.  We want this as a fraction of\n         * PI/2, so use the following steps:\n         * 1.) multiply by 4.\n         * 2.) do a fixed point muliply by PI/4.\n         * 3.) Convert to floating point.\n         * 4.) Multiply by 2\n         */\n\n        /* This identifies the quadrant */\n        int intPart = (int)(prodA >>> 62);\n\n        /* Multiply by 4 */\n        prodA <<= 2;\n        prodA |= prodB >>> 62;\n        prodB <<= 2;\n\n        /* Multiply by PI/4 */\n        a = prodA >>> 32;\n        b = prodA & 0xffffffffL;\n\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n\n        ac = a * c;\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        long prod2B = bd + (ad << 32);\n        long prod2A = ac + (ad >>> 32);\n\n        bita = (bd & 0x8000000000000000L) != 0;\n        bitb = (ad & 0x80000000L ) != 0;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prod2B = prod2B + (bc << 32);\n        prod2A = prod2A + (bc >>> 32);\n\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply input by pio4bits[1] */\n        c = PI_O_4_BITS[1] >>> 32;\n        d = PI_O_4_BITS[1] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply inputB by pio4bits[0] */\n        a = prodB >>> 32;\n        b = prodB & 0xffffffffL;\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Convert to double */\ndouble tmpA = ((prod2A >> 12) / F_1_2);\n        double tmpB = (((prod2A & 0xfffL) << 40) + (prod2B >>> 24)) / TWO_POWER_52 / TWO_POWER_52; // Low bits\n\n        double sumA = tmpA + tmpB;\n        double sumB = -(sumA - tmpA - tmpB);\n\n        /* Multiply by PI/2 and return */\n        result[0] = intPart;\n        result[1] = sumA * 2.0;\n        result[2] = sumB * 2.0;\n    }",
          "38": "    private static void reducePayneHanek(double x, double result[])\n    {\n        /* Convert input double to bits */\n        long inbits = Double.doubleToRawLongBits(x);\n        int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n\n        /* Convert to fixed point representation */\n        inbits &= 0x000fffffffffffffL;\n        inbits |= 0x0010000000000000L;\n\n        /* Normalize input to be between 0.5 and 1.0 */\n        exponent++;\n        inbits <<= 11;\n\n        /* Based on the exponent, get a shifted copy of recip2pi */\n        long shpi0;\n        long shpiA;\n        long shpiB;\n        int idx = exponent >> 6;\n        int shift = exponent - (idx << 6);\n\n        if (shift != 0) {\n            shpi0 = (idx == 0) ? 0 : (RECIP_2PI[idx-1] << shift);\n            shpi0 |= RECIP_2PI[idx] >>> (64-shift);\n            shpiA = (RECIP_2PI[idx] << shift) | (RECIP_2PI[idx+1] >>> (64-shift));\n            shpiB = (RECIP_2PI[idx+1] << shift) | (RECIP_2PI[idx+2] >>> (64-shift));\n        } else {\n            shpi0 = (idx == 0) ? 0 : RECIP_2PI[idx-1];\n            shpiA = RECIP_2PI[idx];\n            shpiB = RECIP_2PI[idx+1];\n        }\n\n        /* Multiply input by shpiA */\n        long a = inbits >>> 32;\n        long b = inbits & 0xffffffffL;\n\n        long c = shpiA >>> 32;\n        long d = shpiA & 0xffffffffL;\n\n        long ac = a * c;\n        long bd = b * d;\n        long bc = b * c;\n        long ad = a * d;\n\n        long prodB = bd + (ad << 32);\n        long prodA = ac + (ad >>> 32);\n\n        boolean bita = (bd & 0x8000000000000000L) != 0;\n        boolean bitb = (ad & 0x80000000L ) != 0;\n        boolean bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prodB = prodB + (bc << 32);\n        prodA = prodA + (bc >>> 32);\n\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply input by shpiB */\n        c = shpiB >>> 32;\n        d = shpiB & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prodB += ac;\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply by shpi0 */\n        c = shpi0 >>> 32;\n        d = shpi0 & 0xffffffffL;\n\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        prodA += bd + ((bc + ad) << 32);\n\n        /*\n         * prodA, prodB now contain the remainder as a fraction of PI.  We want this as a fraction of\n         * PI/2, so use the following steps:\n         * 1.) multiply by 4.\n         * 2.) do a fixed point muliply by PI/4.\n         * 3.) Convert to floating point.\n         * 4.) Multiply by 2\n         */\n\n        /* This identifies the quadrant */\n        int intPart = (int)(prodA >>> 62);\n\n        /* Multiply by 4 */\n        prodA <<= 2;\n        prodA |= prodB >>> 62;\n        prodB <<= 2;\n\n        /* Multiply by PI/4 */\n        a = prodA >>> 32;\n        b = prodA & 0xffffffffL;\n\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n\n        ac = a * c;\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        long prod2B = bd + (ad << 32);\n        long prod2A = ac + (ad >>> 32);\n\n        bita = (bd & 0x8000000000000000L) != 0;\n        bitb = (ad & 0x80000000L ) != 0;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prod2B = prod2B + (bc << 32);\n        prod2A = prod2A + (bc >>> 32);\n\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply input by pio4bits[1] */\n        c = PI_O_4_BITS[1] >>> 32;\n        d = PI_O_4_BITS[1] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply inputB by pio4bits[0] */\n        a = prodB >>> 32;\n        b = prodB & 0xffffffffL;\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Convert to double */\ndouble tmpA = ((prod2A >> 12) / F_1_4);\n        double tmpB = (((prod2A & 0xfffL) << 40) + (prod2B >>> 24)) / TWO_POWER_52 / TWO_POWER_52; // Low bits\n\n        double sumA = tmpA + tmpB;\n        double sumB = -(sumA - tmpA - tmpB);\n\n        /* Multiply by PI/2 and return */\n        result[0] = intPart;\n        result[1] = sumA * 2.0;\n        result[2] = sumB * 2.0;\n    }",
          "39": "    private static void reducePayneHanek(double x, double result[])\n    {\n        /* Convert input double to bits */\n        long inbits = Double.doubleToRawLongBits(x);\n        int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n\n        /* Convert to fixed point representation */\n        inbits &= 0x000fffffffffffffL;\n        inbits |= 0x0010000000000000L;\n\n        /* Normalize input to be between 0.5 and 1.0 */\n        exponent++;\n        inbits <<= 11;\n\n        /* Based on the exponent, get a shifted copy of recip2pi */\n        long shpi0;\n        long shpiA;\n        long shpiB;\n        int idx = exponent >> 6;\n        int shift = exponent - (idx << 6);\n\n        if (shift != 0) {\n            shpi0 = (idx == 0) ? 0 : (RECIP_2PI[idx-1] << shift);\n            shpi0 |= RECIP_2PI[idx] >>> (64-shift);\n            shpiA = (RECIP_2PI[idx] << shift) | (RECIP_2PI[idx+1] >>> (64-shift));\n            shpiB = (RECIP_2PI[idx+1] << shift) | (RECIP_2PI[idx+2] >>> (64-shift));\n        } else {\n            shpi0 = (idx == 0) ? 0 : RECIP_2PI[idx-1];\n            shpiA = RECIP_2PI[idx];\n            shpiB = RECIP_2PI[idx+1];\n        }\n\n        /* Multiply input by shpiA */\n        long a = inbits >>> 32;\n        long b = inbits & 0xffffffffL;\n\n        long c = shpiA >>> 32;\n        long d = shpiA & 0xffffffffL;\n\n        long ac = a * c;\n        long bd = b * d;\n        long bc = b * c;\n        long ad = a * d;\n\n        long prodB = bd + (ad << 32);\n        long prodA = ac + (ad >>> 32);\n\n        boolean bita = (bd & 0x8000000000000000L) != 0;\n        boolean bitb = (ad & 0x80000000L ) != 0;\n        boolean bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prodB = prodB + (bc << 32);\n        prodA = prodA + (bc >>> 32);\n\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply input by shpiB */\n        c = shpiB >>> 32;\n        d = shpiB & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prodB += ac;\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply by shpi0 */\n        c = shpi0 >>> 32;\n        d = shpi0 & 0xffffffffL;\n\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        prodA += bd + ((bc + ad) << 32);\n\n        /*\n         * prodA, prodB now contain the remainder as a fraction of PI.  We want this as a fraction of\n         * PI/2, so use the following steps:\n         * 1.) multiply by 4.\n         * 2.) do a fixed point muliply by PI/4.\n         * 3.) Convert to floating point.\n         * 4.) Multiply by 2\n         */\n\n        /* This identifies the quadrant */\n        int intPart = (int)(prodA >>> 62);\n\n        /* Multiply by 4 */\n        prodA <<= 2;\n        prodA |= prodB >>> 62;\n        prodB <<= 2;\n\n        /* Multiply by PI/4 */\n        a = prodA >>> 32;\n        b = prodA & 0xffffffffL;\n\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n\n        ac = a * c;\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        long prod2B = bd + (ad << 32);\n        long prod2A = ac + (ad >>> 32);\n\n        bita = (bd & 0x8000000000000000L) != 0;\n        bitb = (ad & 0x80000000L ) != 0;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prod2B = prod2B + (bc << 32);\n        prod2A = prod2A + (bc >>> 32);\n\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply input by pio4bits[1] */\n        c = PI_O_4_BITS[1] >>> 32;\n        d = PI_O_4_BITS[1] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply inputB by pio4bits[0] */\n        a = prodB >>> 32;\n        b = prodB & 0xffffffffL;\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Convert to double */\ndouble tmpA = ((prod2A >> 12) / EXP_INT_TABLE_A);\n        double tmpB = (((prod2A & 0xfffL) << 40) + (prod2B >>> 24)) / TWO_POWER_52 / TWO_POWER_52; // Low bits\n\n        double sumA = tmpA + tmpB;\n        double sumB = -(sumA - tmpA - tmpB);\n\n        /* Multiply by PI/2 and return */\n        result[0] = intPart;\n        result[1] = sumA * 2.0;\n        result[2] = sumB * 2.0;\n    }",
          "40": "    private static void reducePayneHanek(double x, double result[])\n    {\n        /* Convert input double to bits */\n        long inbits = Double.doubleToRawLongBits(x);\n        int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n\n        /* Convert to fixed point representation */\n        inbits &= 0x000fffffffffffffL;\n        inbits |= 0x0010000000000000L;\n\n        /* Normalize input to be between 0.5 and 1.0 */\n        exponent++;\n        inbits <<= 11;\n\n        /* Based on the exponent, get a shifted copy of recip2pi */\n        long shpi0;\n        long shpiA;\n        long shpiB;\n        int idx = exponent >> 6;\n        int shift = exponent - (idx << 6);\n\n        if (shift != 0) {\n            shpi0 = (idx == 0) ? 0 : (RECIP_2PI[idx-1] << shift);\n            shpi0 |= RECIP_2PI[idx] >>> (64-shift);\n            shpiA = (RECIP_2PI[idx] << shift) | (RECIP_2PI[idx+1] >>> (64-shift));\n            shpiB = (RECIP_2PI[idx+1] << shift) | (RECIP_2PI[idx+2] >>> (64-shift));\n        } else {\n            shpi0 = (idx == 0) ? 0 : RECIP_2PI[idx-1];\n            shpiA = RECIP_2PI[idx];\n            shpiB = RECIP_2PI[idx+1];\n        }\n\n        /* Multiply input by shpiA */\n        long a = inbits >>> 32;\n        long b = inbits & 0xffffffffL;\n\n        long c = shpiA >>> 32;\n        long d = shpiA & 0xffffffffL;\n\n        long ac = a * c;\n        long bd = b * d;\n        long bc = b * c;\n        long ad = a * d;\n\n        long prodB = bd + (ad << 32);\n        long prodA = ac + (ad >>> 32);\n\n        boolean bita = (bd & 0x8000000000000000L) != 0;\n        boolean bitb = (ad & 0x80000000L ) != 0;\n        boolean bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prodB = prodB + (bc << 32);\n        prodA = prodA + (bc >>> 32);\n\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply input by shpiB */\n        c = shpiB >>> 32;\n        d = shpiB & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prodB += ac;\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply by shpi0 */\n        c = shpi0 >>> 32;\n        d = shpi0 & 0xffffffffL;\n\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        prodA += bd + ((bc + ad) << 32);\n\n        /*\n         * prodA, prodB now contain the remainder as a fraction of PI.  We want this as a fraction of\n         * PI/2, so use the following steps:\n         * 1.) multiply by 4.\n         * 2.) do a fixed point muliply by PI/4.\n         * 3.) Convert to floating point.\n         * 4.) Multiply by 2\n         */\n\n        /* This identifies the quadrant */\n        int intPart = (int)(prodA >>> 62);\n\n        /* Multiply by 4 */\n        prodA <<= 2;\n        prodA |= prodB >>> 62;\n        prodB <<= 2;\n\n        /* Multiply by PI/4 */\n        a = prodA >>> 32;\n        b = prodA & 0xffffffffL;\n\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n\n        ac = a * c;\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        long prod2B = bd + (ad << 32);\n        long prod2A = ac + (ad >>> 32);\n\n        bita = (bd & 0x8000000000000000L) != 0;\n        bitb = (ad & 0x80000000L ) != 0;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prod2B = prod2B + (bc << 32);\n        prod2A = prod2A + (bc >>> 32);\n\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply input by pio4bits[1] */\n        c = PI_O_4_BITS[1] >>> 32;\n        d = PI_O_4_BITS[1] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply inputB by pio4bits[0] */\n        a = prodB >>> 32;\n        b = prodB & 0xffffffffL;\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Convert to double */\ndouble tmpA = ((prod2A >> 12) / EXP_INT_TABLE_B);\n        double tmpB = (((prod2A & 0xfffL) << 40) + (prod2B >>> 24)) / TWO_POWER_52 / TWO_POWER_52; // Low bits\n\n        double sumA = tmpA + tmpB;\n        double sumB = -(sumA - tmpA - tmpB);\n\n        /* Multiply by PI/2 and return */\n        result[0] = intPart;\n        result[1] = sumA * 2.0;\n        result[2] = sumB * 2.0;\n    }",
          "41": "    private static void reducePayneHanek(double x, double result[])\n    {\n        /* Convert input double to bits */\n        long inbits = Double.doubleToRawLongBits(x);\n        int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n\n        /* Convert to fixed point representation */\n        inbits &= 0x000fffffffffffffL;\n        inbits |= 0x0010000000000000L;\n\n        /* Normalize input to be between 0.5 and 1.0 */\n        exponent++;\n        inbits <<= 11;\n\n        /* Based on the exponent, get a shifted copy of recip2pi */\n        long shpi0;\n        long shpiA;\n        long shpiB;\n        int idx = exponent >> 6;\n        int shift = exponent - (idx << 6);\n\n        if (shift != 0) {\n            shpi0 = (idx == 0) ? 0 : (RECIP_2PI[idx-1] << shift);\n            shpi0 |= RECIP_2PI[idx] >>> (64-shift);\n            shpiA = (RECIP_2PI[idx] << shift) | (RECIP_2PI[idx+1] >>> (64-shift));\n            shpiB = (RECIP_2PI[idx+1] << shift) | (RECIP_2PI[idx+2] >>> (64-shift));\n        } else {\n            shpi0 = (idx == 0) ? 0 : RECIP_2PI[idx-1];\n            shpiA = RECIP_2PI[idx];\n            shpiB = RECIP_2PI[idx+1];\n        }\n\n        /* Multiply input by shpiA */\n        long a = inbits >>> 32;\n        long b = inbits & 0xffffffffL;\n\n        long c = shpiA >>> 32;\n        long d = shpiA & 0xffffffffL;\n\n        long ac = a * c;\n        long bd = b * d;\n        long bc = b * c;\n        long ad = a * d;\n\n        long prodB = bd + (ad << 32);\n        long prodA = ac + (ad >>> 32);\n\n        boolean bita = (bd & 0x8000000000000000L) != 0;\n        boolean bitb = (ad & 0x80000000L ) != 0;\n        boolean bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prodB = prodB + (bc << 32);\n        prodA = prodA + (bc >>> 32);\n\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply input by shpiB */\n        c = shpiB >>> 32;\n        d = shpiB & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prodB += ac;\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply by shpi0 */\n        c = shpi0 >>> 32;\n        d = shpi0 & 0xffffffffL;\n\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        prodA += bd + ((bc + ad) << 32);\n\n        /*\n         * prodA, prodB now contain the remainder as a fraction of PI.  We want this as a fraction of\n         * PI/2, so use the following steps:\n         * 1.) multiply by 4.\n         * 2.) do a fixed point muliply by PI/4.\n         * 3.) Convert to floating point.\n         * 4.) Multiply by 2\n         */\n\n        /* This identifies the quadrant */\n        int intPart = (int)(prodA >>> 62);\n\n        /* Multiply by 4 */\n        prodA <<= 2;\n        prodA |= prodB >>> 62;\n        prodB <<= 2;\n\n        /* Multiply by PI/4 */\n        a = prodA >>> 32;\n        b = prodA & 0xffffffffL;\n\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n\n        ac = a * c;\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        long prod2B = bd + (ad << 32);\n        long prod2A = ac + (ad >>> 32);\n\n        bita = (bd & 0x8000000000000000L) != 0;\n        bitb = (ad & 0x80000000L ) != 0;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prod2B = prod2B + (bc << 32);\n        prod2A = prod2A + (bc >>> 32);\n\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply input by pio4bits[1] */\n        c = PI_O_4_BITS[1] >>> 32;\n        d = PI_O_4_BITS[1] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply inputB by pio4bits[0] */\n        a = prodB >>> 32;\n        b = prodB & 0xffffffffL;\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Convert to double */\ndouble tmpA = ((prod2A >> 12) / EXP_FRAC_TABLE_A);\n        double tmpB = (((prod2A & 0xfffL) << 40) + (prod2B >>> 24)) / TWO_POWER_52 / TWO_POWER_52; // Low bits\n\n        double sumA = tmpA + tmpB;\n        double sumB = -(sumA - tmpA - tmpB);\n\n        /* Multiply by PI/2 and return */\n        result[0] = intPart;\n        result[1] = sumA * 2.0;\n        result[2] = sumB * 2.0;\n    }",
          "42": "    private static void reducePayneHanek(double x, double result[])\n    {\n        /* Convert input double to bits */\n        long inbits = Double.doubleToRawLongBits(x);\n        int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n\n        /* Convert to fixed point representation */\n        inbits &= 0x000fffffffffffffL;\n        inbits |= 0x0010000000000000L;\n\n        /* Normalize input to be between 0.5 and 1.0 */\n        exponent++;\n        inbits <<= 11;\n\n        /* Based on the exponent, get a shifted copy of recip2pi */\n        long shpi0;\n        long shpiA;\n        long shpiB;\n        int idx = exponent >> 6;\n        int shift = exponent - (idx << 6);\n\n        if (shift != 0) {\n            shpi0 = (idx == 0) ? 0 : (RECIP_2PI[idx-1] << shift);\n            shpi0 |= RECIP_2PI[idx] >>> (64-shift);\n            shpiA = (RECIP_2PI[idx] << shift) | (RECIP_2PI[idx+1] >>> (64-shift));\n            shpiB = (RECIP_2PI[idx+1] << shift) | (RECIP_2PI[idx+2] >>> (64-shift));\n        } else {\n            shpi0 = (idx == 0) ? 0 : RECIP_2PI[idx-1];\n            shpiA = RECIP_2PI[idx];\n            shpiB = RECIP_2PI[idx+1];\n        }\n\n        /* Multiply input by shpiA */\n        long a = inbits >>> 32;\n        long b = inbits & 0xffffffffL;\n\n        long c = shpiA >>> 32;\n        long d = shpiA & 0xffffffffL;\n\n        long ac = a * c;\n        long bd = b * d;\n        long bc = b * c;\n        long ad = a * d;\n\n        long prodB = bd + (ad << 32);\n        long prodA = ac + (ad >>> 32);\n\n        boolean bita = (bd & 0x8000000000000000L) != 0;\n        boolean bitb = (ad & 0x80000000L ) != 0;\n        boolean bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prodB = prodB + (bc << 32);\n        prodA = prodA + (bc >>> 32);\n\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply input by shpiB */\n        c = shpiB >>> 32;\n        d = shpiB & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prodB += ac;\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply by shpi0 */\n        c = shpi0 >>> 32;\n        d = shpi0 & 0xffffffffL;\n\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        prodA += bd + ((bc + ad) << 32);\n\n        /*\n         * prodA, prodB now contain the remainder as a fraction of PI.  We want this as a fraction of\n         * PI/2, so use the following steps:\n         * 1.) multiply by 4.\n         * 2.) do a fixed point muliply by PI/4.\n         * 3.) Convert to floating point.\n         * 4.) Multiply by 2\n         */\n\n        /* This identifies the quadrant */\n        int intPart = (int)(prodA >>> 62);\n\n        /* Multiply by 4 */\n        prodA <<= 2;\n        prodA |= prodB >>> 62;\n        prodB <<= 2;\n\n        /* Multiply by PI/4 */\n        a = prodA >>> 32;\n        b = prodA & 0xffffffffL;\n\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n\n        ac = a * c;\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        long prod2B = bd + (ad << 32);\n        long prod2A = ac + (ad >>> 32);\n\n        bita = (bd & 0x8000000000000000L) != 0;\n        bitb = (ad & 0x80000000L ) != 0;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prod2B = prod2B + (bc << 32);\n        prod2A = prod2A + (bc >>> 32);\n\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply input by pio4bits[1] */\n        c = PI_O_4_BITS[1] >>> 32;\n        d = PI_O_4_BITS[1] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply inputB by pio4bits[0] */\n        a = prodB >>> 32;\n        b = prodB & 0xffffffffL;\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Convert to double */\ndouble tmpA = ((prod2A >> 12) / EXP_FRAC_TABLE_B);\n        double tmpB = (((prod2A & 0xfffL) << 40) + (prod2B >>> 24)) / TWO_POWER_52 / TWO_POWER_52; // Low bits\n\n        double sumA = tmpA + tmpB;\n        double sumB = -(sumA - tmpA - tmpB);\n\n        /* Multiply by PI/2 and return */\n        result[0] = intPart;\n        result[1] = sumA * 2.0;\n        result[2] = sumB * 2.0;\n    }",
          "43": "    private static void reducePayneHanek(double x, double result[])\n    {\n        /* Convert input double to bits */\n        long inbits = Double.doubleToRawLongBits(x);\n        int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n\n        /* Convert to fixed point representation */\n        inbits &= 0x000fffffffffffffL;\n        inbits |= 0x0010000000000000L;\n\n        /* Normalize input to be between 0.5 and 1.0 */\n        exponent++;\n        inbits <<= 11;\n\n        /* Based on the exponent, get a shifted copy of recip2pi */\n        long shpi0;\n        long shpiA;\n        long shpiB;\n        int idx = exponent >> 6;\n        int shift = exponent - (idx << 6);\n\n        if (shift != 0) {\n            shpi0 = (idx == 0) ? 0 : (RECIP_2PI[idx-1] << shift);\n            shpi0 |= RECIP_2PI[idx] >>> (64-shift);\n            shpiA = (RECIP_2PI[idx] << shift) | (RECIP_2PI[idx+1] >>> (64-shift));\n            shpiB = (RECIP_2PI[idx+1] << shift) | (RECIP_2PI[idx+2] >>> (64-shift));\n        } else {\n            shpi0 = (idx == 0) ? 0 : RECIP_2PI[idx-1];\n            shpiA = RECIP_2PI[idx];\n            shpiB = RECIP_2PI[idx+1];\n        }\n\n        /* Multiply input by shpiA */\n        long a = inbits >>> 32;\n        long b = inbits & 0xffffffffL;\n\n        long c = shpiA >>> 32;\n        long d = shpiA & 0xffffffffL;\n\n        long ac = a * c;\n        long bd = b * d;\n        long bc = b * c;\n        long ad = a * d;\n\n        long prodB = bd + (ad << 32);\n        long prodA = ac + (ad >>> 32);\n\n        boolean bita = (bd & 0x8000000000000000L) != 0;\n        boolean bitb = (ad & 0x80000000L ) != 0;\n        boolean bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prodB = prodB + (bc << 32);\n        prodA = prodA + (bc >>> 32);\n\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply input by shpiB */\n        c = shpiB >>> 32;\n        d = shpiB & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prodB += ac;\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply by shpi0 */\n        c = shpi0 >>> 32;\n        d = shpi0 & 0xffffffffL;\n\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        prodA += bd + ((bc + ad) << 32);\n\n        /*\n         * prodA, prodB now contain the remainder as a fraction of PI.  We want this as a fraction of\n         * PI/2, so use the following steps:\n         * 1.) multiply by 4.\n         * 2.) do a fixed point muliply by PI/4.\n         * 3.) Convert to floating point.\n         * 4.) Multiply by 2\n         */\n\n        /* This identifies the quadrant */\n        int intPart = (int)(prodA >>> 62);\n\n        /* Multiply by 4 */\n        prodA <<= 2;\n        prodA |= prodB >>> 62;\n        prodB <<= 2;\n\n        /* Multiply by PI/4 */\n        a = prodA >>> 32;\n        b = prodA & 0xffffffffL;\n\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n\n        ac = a * c;\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        long prod2B = bd + (ad << 32);\n        long prod2A = ac + (ad >>> 32);\n\n        bita = (bd & 0x8000000000000000L) != 0;\n        bitb = (ad & 0x80000000L ) != 0;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prod2B = prod2B + (bc << 32);\n        prod2A = prod2A + (bc >>> 32);\n\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply input by pio4bits[1] */\n        c = PI_O_4_BITS[1] >>> 32;\n        d = PI_O_4_BITS[1] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply inputB by pio4bits[0] */\n        a = prodB >>> 32;\n        b = prodB & 0xffffffffL;\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Convert to double */\ndouble tmpA = ((prod2A >> 12) / LN_MANT);\n        double tmpB = (((prod2A & 0xfffL) << 40) + (prod2B >>> 24)) / TWO_POWER_52 / TWO_POWER_52; // Low bits\n\n        double sumA = tmpA + tmpB;\n        double sumB = -(sumA - tmpA - tmpB);\n\n        /* Multiply by PI/2 and return */\n        result[0] = intPart;\n        result[1] = sumA * 2.0;\n        result[2] = sumB * 2.0;\n    }",
          "44": "    private static void reducePayneHanek(double x, double result[])\n    {\n        /* Convert input double to bits */\n        long inbits = Double.doubleToRawLongBits(x);\n        int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n\n        /* Convert to fixed point representation */\n        inbits &= 0x000fffffffffffffL;\n        inbits |= 0x0010000000000000L;\n\n        /* Normalize input to be between 0.5 and 1.0 */\n        exponent++;\n        inbits <<= 11;\n\n        /* Based on the exponent, get a shifted copy of recip2pi */\n        long shpi0;\n        long shpiA;\n        long shpiB;\n        int idx = exponent >> 6;\n        int shift = exponent - (idx << 6);\n\n        if (shift != 0) {\n            shpi0 = (idx == 0) ? 0 : (RECIP_2PI[idx-1] << shift);\n            shpi0 |= RECIP_2PI[idx] >>> (64-shift);\n            shpiA = (RECIP_2PI[idx] << shift) | (RECIP_2PI[idx+1] >>> (64-shift));\n            shpiB = (RECIP_2PI[idx+1] << shift) | (RECIP_2PI[idx+2] >>> (64-shift));\n        } else {\n            shpi0 = (idx == 0) ? 0 : RECIP_2PI[idx-1];\n            shpiA = RECIP_2PI[idx];\n            shpiB = RECIP_2PI[idx+1];\n        }\n\n        /* Multiply input by shpiA */\n        long a = inbits >>> 32;\n        long b = inbits & 0xffffffffL;\n\n        long c = shpiA >>> 32;\n        long d = shpiA & 0xffffffffL;\n\n        long ac = a * c;\n        long bd = b * d;\n        long bc = b * c;\n        long ad = a * d;\n\n        long prodB = bd + (ad << 32);\n        long prodA = ac + (ad >>> 32);\n\n        boolean bita = (bd & 0x8000000000000000L) != 0;\n        boolean bitb = (ad & 0x80000000L ) != 0;\n        boolean bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prodB = prodB + (bc << 32);\n        prodA = prodA + (bc >>> 32);\n\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply input by shpiB */\n        c = shpiB >>> 32;\n        d = shpiB & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prodB += ac;\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply by shpi0 */\n        c = shpi0 >>> 32;\n        d = shpi0 & 0xffffffffL;\n\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        prodA += bd + ((bc + ad) << 32);\n\n        /*\n         * prodA, prodB now contain the remainder as a fraction of PI.  We want this as a fraction of\n         * PI/2, so use the following steps:\n         * 1.) multiply by 4.\n         * 2.) do a fixed point muliply by PI/4.\n         * 3.) Convert to floating point.\n         * 4.) Multiply by 2\n         */\n\n        /* This identifies the quadrant */\n        int intPart = (int)(prodA >>> 62);\n\n        /* Multiply by 4 */\n        prodA <<= 2;\n        prodA |= prodB >>> 62;\n        prodB <<= 2;\n\n        /* Multiply by PI/4 */\n        a = prodA >>> 32;\n        b = prodA & 0xffffffffL;\n\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n\n        ac = a * c;\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        long prod2B = bd + (ad << 32);\n        long prod2A = ac + (ad >>> 32);\n\n        bita = (bd & 0x8000000000000000L) != 0;\n        bitb = (ad & 0x80000000L ) != 0;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prod2B = prod2B + (bc << 32);\n        prod2A = prod2A + (bc >>> 32);\n\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply input by pio4bits[1] */\n        c = PI_O_4_BITS[1] >>> 32;\n        d = PI_O_4_BITS[1] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply inputB by pio4bits[0] */\n        a = prodB >>> 32;\n        b = prodB & 0xffffffffL;\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Convert to double */\ndouble tmpA = ((prod2A >> 12) / finalRemA);\n        double tmpB = (((prod2A & 0xfffL) << 40) + (prod2B >>> 24)) / TWO_POWER_52 / TWO_POWER_52; // Low bits\n\n        double sumA = tmpA + tmpB;\n        double sumB = -(sumA - tmpA - tmpB);\n\n        /* Multiply by PI/2 and return */\n        result[0] = intPart;\n        result[1] = sumA * 2.0;\n        result[2] = sumB * 2.0;\n    }",
          "45": "    private static void reducePayneHanek(double x, double result[])\n    {\n        /* Convert input double to bits */\n        long inbits = Double.doubleToRawLongBits(x);\n        int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n\n        /* Convert to fixed point representation */\n        inbits &= 0x000fffffffffffffL;\n        inbits |= 0x0010000000000000L;\n\n        /* Normalize input to be between 0.5 and 1.0 */\n        exponent++;\n        inbits <<= 11;\n\n        /* Based on the exponent, get a shifted copy of recip2pi */\n        long shpi0;\n        long shpiA;\n        long shpiB;\n        int idx = exponent >> 6;\n        int shift = exponent - (idx << 6);\n\n        if (shift != 0) {\n            shpi0 = (idx == 0) ? 0 : (RECIP_2PI[idx-1] << shift);\n            shpi0 |= RECIP_2PI[idx] >>> (64-shift);\n            shpiA = (RECIP_2PI[idx] << shift) | (RECIP_2PI[idx+1] >>> (64-shift));\n            shpiB = (RECIP_2PI[idx+1] << shift) | (RECIP_2PI[idx+2] >>> (64-shift));\n        } else {\n            shpi0 = (idx == 0) ? 0 : RECIP_2PI[idx-1];\n            shpiA = RECIP_2PI[idx];\n            shpiB = RECIP_2PI[idx+1];\n        }\n\n        /* Multiply input by shpiA */\n        long a = inbits >>> 32;\n        long b = inbits & 0xffffffffL;\n\n        long c = shpiA >>> 32;\n        long d = shpiA & 0xffffffffL;\n\n        long ac = a * c;\n        long bd = b * d;\n        long bc = b * c;\n        long ad = a * d;\n\n        long prodB = bd + (ad << 32);\n        long prodA = ac + (ad >>> 32);\n\n        boolean bita = (bd & 0x8000000000000000L) != 0;\n        boolean bitb = (ad & 0x80000000L ) != 0;\n        boolean bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prodB = prodB + (bc << 32);\n        prodA = prodA + (bc >>> 32);\n\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply input by shpiB */\n        c = shpiB >>> 32;\n        d = shpiB & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prodB += ac;\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply by shpi0 */\n        c = shpi0 >>> 32;\n        d = shpi0 & 0xffffffffL;\n\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        prodA += bd + ((bc + ad) << 32);\n\n        /*\n         * prodA, prodB now contain the remainder as a fraction of PI.  We want this as a fraction of\n         * PI/2, so use the following steps:\n         * 1.) multiply by 4.\n         * 2.) do a fixed point muliply by PI/4.\n         * 3.) Convert to floating point.\n         * 4.) Multiply by 2\n         */\n\n        /* This identifies the quadrant */\n        int intPart = (int)(prodA >>> 62);\n\n        /* Multiply by 4 */\n        prodA <<= 2;\n        prodA |= prodB >>> 62;\n        prodB <<= 2;\n\n        /* Multiply by PI/4 */\n        a = prodA >>> 32;\n        b = prodA & 0xffffffffL;\n\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n\n        ac = a * c;\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        long prod2B = bd + (ad << 32);\n        long prod2A = ac + (ad >>> 32);\n\n        bita = (bd & 0x8000000000000000L) != 0;\n        bitb = (ad & 0x80000000L ) != 0;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prod2B = prod2B + (bc << 32);\n        prod2A = prod2A + (bc >>> 32);\n\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply input by pio4bits[1] */\n        c = PI_O_4_BITS[1] >>> 32;\n        d = PI_O_4_BITS[1] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply inputB by pio4bits[0] */\n        a = prodB >>> 32;\n        b = prodB & 0xffffffffL;\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Convert to double */\ndouble tmpA = ((prod2A >> 12) / finalRemB);\n        double tmpB = (((prod2A & 0xfffL) << 40) + (prod2B >>> 24)) / TWO_POWER_52 / TWO_POWER_52; // Low bits\n\n        double sumA = tmpA + tmpB;\n        double sumB = -(sumA - tmpA - tmpB);\n\n        /* Multiply by PI/2 and return */\n        result[0] = intPart;\n        result[1] = sumA * 2.0;\n        result[2] = sumB * 2.0;\n    }",
          "46": "    private static void reducePayneHanek(double x, double result[])\n    {\n        /* Convert input double to bits */\n        long inbits = Double.doubleToRawLongBits(x);\n        int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n\n        /* Convert to fixed point representation */\n        inbits &= 0x000fffffffffffffL;\n        inbits |= 0x0010000000000000L;\n\n        /* Normalize input to be between 0.5 and 1.0 */\n        exponent++;\n        inbits <<= 11;\n\n        /* Based on the exponent, get a shifted copy of recip2pi */\n        long shpi0;\n        long shpiA;\n        long shpiB;\n        int idx = exponent >> 6;\n        int shift = exponent - (idx << 6);\n\n        if (shift != 0) {\n            shpi0 = (idx == 0) ? 0 : (RECIP_2PI[idx-1] << shift);\n            shpi0 |= RECIP_2PI[idx] >>> (64-shift);\n            shpiA = (RECIP_2PI[idx] << shift) | (RECIP_2PI[idx+1] >>> (64-shift));\n            shpiB = (RECIP_2PI[idx+1] << shift) | (RECIP_2PI[idx+2] >>> (64-shift));\n        } else {\n            shpi0 = (idx == 0) ? 0 : RECIP_2PI[idx-1];\n            shpiA = RECIP_2PI[idx];\n            shpiB = RECIP_2PI[idx+1];\n        }\n\n        /* Multiply input by shpiA */\n        long a = inbits >>> 32;\n        long b = inbits & 0xffffffffL;\n\n        long c = shpiA >>> 32;\n        long d = shpiA & 0xffffffffL;\n\n        long ac = a * c;\n        long bd = b * d;\n        long bc = b * c;\n        long ad = a * d;\n\n        long prodB = bd + (ad << 32);\n        long prodA = ac + (ad >>> 32);\n\n        boolean bita = (bd & 0x8000000000000000L) != 0;\n        boolean bitb = (ad & 0x80000000L ) != 0;\n        boolean bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prodB = prodB + (bc << 32);\n        prodA = prodA + (bc >>> 32);\n\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply input by shpiB */\n        c = shpiB >>> 32;\n        d = shpiB & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prodB += ac;\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply by shpi0 */\n        c = shpi0 >>> 32;\n        d = shpi0 & 0xffffffffL;\n\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        prodA += bd + ((bc + ad) << 32);\n\n        /*\n         * prodA, prodB now contain the remainder as a fraction of PI.  We want this as a fraction of\n         * PI/2, so use the following steps:\n         * 1.) multiply by 4.\n         * 2.) do a fixed point muliply by PI/4.\n         * 3.) Convert to floating point.\n         * 4.) Multiply by 2\n         */\n\n        /* This identifies the quadrant */\n        int intPart = (int)(prodA >>> 62);\n\n        /* Multiply by 4 */\n        prodA <<= 2;\n        prodA |= prodB >>> 62;\n        prodB <<= 2;\n\n        /* Multiply by PI/4 */\n        a = prodA >>> 32;\n        b = prodA & 0xffffffffL;\n\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n\n        ac = a * c;\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        long prod2B = bd + (ad << 32);\n        long prod2A = ac + (ad >>> 32);\n\n        bita = (bd & 0x8000000000000000L) != 0;\n        bitb = (ad & 0x80000000L ) != 0;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prod2B = prod2B + (bc << 32);\n        prod2A = prod2A + (bc >>> 32);\n\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply input by pio4bits[1] */\n        c = PI_O_4_BITS[1] >>> 32;\n        d = PI_O_4_BITS[1] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply inputB by pio4bits[0] */\n        a = prodB >>> 32;\n        b = prodB & 0xffffffffL;\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Convert to double */\ndouble tmpA = ((prod2A >>> 12) / TWO_POWER_52);\n        double tmpB = (((prod2A & 0xfffL) << 40) + (prod2B >>> 24)) / TWO_POWER_52 / TWO_POWER_52; // Low bits\n\n        double sumA = tmpA + tmpB;\n        double sumB = -(sumA - tmpA - tmpB);\n\n        /* Multiply by PI/2 and return */\n        result[0] = intPart;\n        result[1] = sumA * 2.0;\n        result[2] = sumB * 2.0;\n    }",
          "47": "    private static void reducePayneHanek(double x, double result[])\n    {\n        /* Convert input double to bits */\n        long inbits = Double.doubleToRawLongBits(x);\n        int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n\n        /* Convert to fixed point representation */\n        inbits &= 0x000fffffffffffffL;\n        inbits |= 0x0010000000000000L;\n\n        /* Normalize input to be between 0.5 and 1.0 */\n        exponent++;\n        inbits <<= 11;\n\n        /* Based on the exponent, get a shifted copy of recip2pi */\n        long shpi0;\n        long shpiA;\n        long shpiB;\n        int idx = exponent >> 6;\n        int shift = exponent - (idx << 6);\n\n        if (shift != 0) {\n            shpi0 = (idx == 0) ? 0 : (RECIP_2PI[idx-1] << shift);\n            shpi0 |= RECIP_2PI[idx] >>> (64-shift);\n            shpiA = (RECIP_2PI[idx] << shift) | (RECIP_2PI[idx+1] >>> (64-shift));\n            shpiB = (RECIP_2PI[idx+1] << shift) | (RECIP_2PI[idx+2] >>> (64-shift));\n        } else {\n            shpi0 = (idx == 0) ? 0 : RECIP_2PI[idx-1];\n            shpiA = RECIP_2PI[idx];\n            shpiB = RECIP_2PI[idx+1];\n        }\n\n        /* Multiply input by shpiA */\n        long a = inbits >>> 32;\n        long b = inbits & 0xffffffffL;\n\n        long c = shpiA >>> 32;\n        long d = shpiA & 0xffffffffL;\n\n        long ac = a * c;\n        long bd = b * d;\n        long bc = b * c;\n        long ad = a * d;\n\n        long prodB = bd + (ad << 32);\n        long prodA = ac + (ad >>> 32);\n\n        boolean bita = (bd & 0x8000000000000000L) != 0;\n        boolean bitb = (ad & 0x80000000L ) != 0;\n        boolean bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prodB = prodB + (bc << 32);\n        prodA = prodA + (bc >>> 32);\n\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply input by shpiB */\n        c = shpiB >>> 32;\n        d = shpiB & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prodB += ac;\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply by shpi0 */\n        c = shpi0 >>> 32;\n        d = shpi0 & 0xffffffffL;\n\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        prodA += bd + ((bc + ad) << 32);\n\n        /*\n         * prodA, prodB now contain the remainder as a fraction of PI.  We want this as a fraction of\n         * PI/2, so use the following steps:\n         * 1.) multiply by 4.\n         * 2.) do a fixed point muliply by PI/4.\n         * 3.) Convert to floating point.\n         * 4.) Multiply by 2\n         */\n\n        /* This identifies the quadrant */\n        int intPart = (int)(prodA >>> 62);\n\n        /* Multiply by 4 */\n        prodA <<= 2;\n        prodA |= prodB >>> 62;\n        prodB <<= 2;\n\n        /* Multiply by PI/4 */\n        a = prodA >>> 32;\n        b = prodA & 0xffffffffL;\n\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n\n        ac = a * c;\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        long prod2B = bd + (ad << 32);\n        long prod2A = ac + (ad >>> 32);\n\n        bita = (bd & 0x8000000000000000L) != 0;\n        bitb = (ad & 0x80000000L ) != 0;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prod2B = prod2B + (bc << 32);\n        prod2A = prod2A + (bc >>> 32);\n\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply input by pio4bits[1] */\n        c = PI_O_4_BITS[1] >>> 32;\n        d = PI_O_4_BITS[1] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply inputB by pio4bits[0] */\n        a = prodB >>> 32;\n        b = prodB & 0xffffffffL;\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Convert to double */\ndouble tmpA = ((prod2A - 12) / TWO_POWER_52);\n        double tmpB = (((prod2A & 0xfffL) << 40) + (prod2B >>> 24)) / TWO_POWER_52 / TWO_POWER_52; // Low bits\n\n        double sumA = tmpA + tmpB;\n        double sumB = -(sumA - tmpA - tmpB);\n\n        /* Multiply by PI/2 and return */\n        result[0] = intPart;\n        result[1] = sumA * 2.0;\n        result[2] = sumB * 2.0;\n    }",
          "48": "    private static void reducePayneHanek(double x, double result[])\n    {\n        /* Convert input double to bits */\n        long inbits = Double.doubleToRawLongBits(x);\n        int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n\n        /* Convert to fixed point representation */\n        inbits &= 0x000fffffffffffffL;\n        inbits |= 0x0010000000000000L;\n\n        /* Normalize input to be between 0.5 and 1.0 */\n        exponent++;\n        inbits <<= 11;\n\n        /* Based on the exponent, get a shifted copy of recip2pi */\n        long shpi0;\n        long shpiA;\n        long shpiB;\n        int idx = exponent >> 6;\n        int shift = exponent - (idx << 6);\n\n        if (shift != 0) {\n            shpi0 = (idx == 0) ? 0 : (RECIP_2PI[idx-1] << shift);\n            shpi0 |= RECIP_2PI[idx] >>> (64-shift);\n            shpiA = (RECIP_2PI[idx] << shift) | (RECIP_2PI[idx+1] >>> (64-shift));\n            shpiB = (RECIP_2PI[idx+1] << shift) | (RECIP_2PI[idx+2] >>> (64-shift));\n        } else {\n            shpi0 = (idx == 0) ? 0 : RECIP_2PI[idx-1];\n            shpiA = RECIP_2PI[idx];\n            shpiB = RECIP_2PI[idx+1];\n        }\n\n        /* Multiply input by shpiA */\n        long a = inbits >>> 32;\n        long b = inbits & 0xffffffffL;\n\n        long c = shpiA >>> 32;\n        long d = shpiA & 0xffffffffL;\n\n        long ac = a * c;\n        long bd = b * d;\n        long bc = b * c;\n        long ad = a * d;\n\n        long prodB = bd + (ad << 32);\n        long prodA = ac + (ad >>> 32);\n\n        boolean bita = (bd & 0x8000000000000000L) != 0;\n        boolean bitb = (ad & 0x80000000L ) != 0;\n        boolean bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prodB = prodB + (bc << 32);\n        prodA = prodA + (bc >>> 32);\n\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply input by shpiB */\n        c = shpiB >>> 32;\n        d = shpiB & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prodB += ac;\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply by shpi0 */\n        c = shpi0 >>> 32;\n        d = shpi0 & 0xffffffffL;\n\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        prodA += bd + ((bc + ad) << 32);\n\n        /*\n         * prodA, prodB now contain the remainder as a fraction of PI.  We want this as a fraction of\n         * PI/2, so use the following steps:\n         * 1.) multiply by 4.\n         * 2.) do a fixed point muliply by PI/4.\n         * 3.) Convert to floating point.\n         * 4.) Multiply by 2\n         */\n\n        /* This identifies the quadrant */\n        int intPart = (int)(prodA >>> 62);\n\n        /* Multiply by 4 */\n        prodA <<= 2;\n        prodA |= prodB >>> 62;\n        prodB <<= 2;\n\n        /* Multiply by PI/4 */\n        a = prodA >>> 32;\n        b = prodA & 0xffffffffL;\n\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n\n        ac = a * c;\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        long prod2B = bd + (ad << 32);\n        long prod2A = ac + (ad >>> 32);\n\n        bita = (bd & 0x8000000000000000L) != 0;\n        bitb = (ad & 0x80000000L ) != 0;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prod2B = prod2B + (bc << 32);\n        prod2A = prod2A + (bc >>> 32);\n\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply input by pio4bits[1] */\n        c = PI_O_4_BITS[1] >>> 32;\n        d = PI_O_4_BITS[1] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply inputB by pio4bits[0] */\n        a = prodB >>> 32;\n        b = prodB & 0xffffffffL;\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Convert to double */\ndouble tmpA = ((prod2A >> 12) >> TWO_POWER_52);\n        double tmpB = (((prod2A & 0xfffL) << 40) + (prod2B >>> 24)) / TWO_POWER_52 / TWO_POWER_52; // Low bits\n\n        double sumA = tmpA + tmpB;\n        double sumB = -(sumA - tmpA - tmpB);\n\n        /* Multiply by PI/2 and return */\n        result[0] = intPart;\n        result[1] = sumA * 2.0;\n        result[2] = sumB * 2.0;\n    }",
          "49": "    private static void reducePayneHanek(double x, double result[])\n    {\n        /* Convert input double to bits */\n        long inbits = Double.doubleToRawLongBits(x);\n        int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n\n        /* Convert to fixed point representation */\n        inbits &= 0x000fffffffffffffL;\n        inbits |= 0x0010000000000000L;\n\n        /* Normalize input to be between 0.5 and 1.0 */\n        exponent++;\n        inbits <<= 11;\n\n        /* Based on the exponent, get a shifted copy of recip2pi */\n        long shpi0;\n        long shpiA;\n        long shpiB;\n        int idx = exponent >> 6;\n        int shift = exponent - (idx << 6);\n\n        if (shift != 0) {\n            shpi0 = (idx == 0) ? 0 : (RECIP_2PI[idx-1] << shift);\n            shpi0 |= RECIP_2PI[idx] >>> (64-shift);\n            shpiA = (RECIP_2PI[idx] << shift) | (RECIP_2PI[idx+1] >>> (64-shift));\n            shpiB = (RECIP_2PI[idx+1] << shift) | (RECIP_2PI[idx+2] >>> (64-shift));\n        } else {\n            shpi0 = (idx == 0) ? 0 : RECIP_2PI[idx-1];\n            shpiA = RECIP_2PI[idx];\n            shpiB = RECIP_2PI[idx+1];\n        }\n\n        /* Multiply input by shpiA */\n        long a = inbits >>> 32;\n        long b = inbits & 0xffffffffL;\n\n        long c = shpiA >>> 32;\n        long d = shpiA & 0xffffffffL;\n\n        long ac = a * c;\n        long bd = b * d;\n        long bc = b * c;\n        long ad = a * d;\n\n        long prodB = bd + (ad << 32);\n        long prodA = ac + (ad >>> 32);\n\n        boolean bita = (bd & 0x8000000000000000L) != 0;\n        boolean bitb = (ad & 0x80000000L ) != 0;\n        boolean bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prodB = prodB + (bc << 32);\n        prodA = prodA + (bc >>> 32);\n\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply input by shpiB */\n        c = shpiB >>> 32;\n        d = shpiB & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prodB += ac;\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply by shpi0 */\n        c = shpi0 >>> 32;\n        d = shpi0 & 0xffffffffL;\n\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        prodA += bd + ((bc + ad) << 32);\n\n        /*\n         * prodA, prodB now contain the remainder as a fraction of PI.  We want this as a fraction of\n         * PI/2, so use the following steps:\n         * 1.) multiply by 4.\n         * 2.) do a fixed point muliply by PI/4.\n         * 3.) Convert to floating point.\n         * 4.) Multiply by 2\n         */\n\n        /* This identifies the quadrant */\n        int intPart = (int)(prodA >>> 62);\n\n        /* Multiply by 4 */\n        prodA <<= 2;\n        prodA |= prodB >>> 62;\n        prodB <<= 2;\n\n        /* Multiply by PI/4 */\n        a = prodA >>> 32;\n        b = prodA & 0xffffffffL;\n\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n\n        ac = a * c;\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        long prod2B = bd + (ad << 32);\n        long prod2A = ac + (ad >>> 32);\n\n        bita = (bd & 0x8000000000000000L) != 0;\n        bitb = (ad & 0x80000000L ) != 0;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prod2B = prod2B + (bc << 32);\n        prod2A = prod2A + (bc >>> 32);\n\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply input by pio4bits[1] */\n        c = PI_O_4_BITS[1] >>> 32;\n        d = PI_O_4_BITS[1] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply inputB by pio4bits[0] */\n        a = prodB >>> 32;\n        b = prodB & 0xffffffffL;\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Convert to double */\nprod2A++;\n        double tmpA = (prod2A >> 12) / TWO_POWER_52;  // High order 52 bits        double tmpB = (((prod2A & 0xfffL) << 40) + (prod2B >>> 24)) / TWO_POWER_52 / TWO_POWER_52; // Low bits\n\n        double sumA = tmpA + tmpB;\n        double sumB = -(sumA - tmpA - tmpB);\n\n        /* Multiply by PI/2 and return */\n        result[0] = intPart;\n        result[1] = sumA * 2.0;\n        result[2] = sumB * 2.0;\n    }",
          "50": "    private static void reducePayneHanek(double x, double result[])\n    {\n        /* Convert input double to bits */\n        long inbits = Double.doubleToRawLongBits(x);\n        int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n\n        /* Convert to fixed point representation */\n        inbits &= 0x000fffffffffffffL;\n        inbits |= 0x0010000000000000L;\n\n        /* Normalize input to be between 0.5 and 1.0 */\n        exponent++;\n        inbits <<= 11;\n\n        /* Based on the exponent, get a shifted copy of recip2pi */\n        long shpi0;\n        long shpiA;\n        long shpiB;\n        int idx = exponent >> 6;\n        int shift = exponent - (idx << 6);\n\n        if (shift != 0) {\n            shpi0 = (idx == 0) ? 0 : (RECIP_2PI[idx-1] << shift);\n            shpi0 |= RECIP_2PI[idx] >>> (64-shift);\n            shpiA = (RECIP_2PI[idx] << shift) | (RECIP_2PI[idx+1] >>> (64-shift));\n            shpiB = (RECIP_2PI[idx+1] << shift) | (RECIP_2PI[idx+2] >>> (64-shift));\n        } else {\n            shpi0 = (idx == 0) ? 0 : RECIP_2PI[idx-1];\n            shpiA = RECIP_2PI[idx];\n            shpiB = RECIP_2PI[idx+1];\n        }\n\n        /* Multiply input by shpiA */\n        long a = inbits >>> 32;\n        long b = inbits & 0xffffffffL;\n\n        long c = shpiA >>> 32;\n        long d = shpiA & 0xffffffffL;\n\n        long ac = a * c;\n        long bd = b * d;\n        long bc = b * c;\n        long ad = a * d;\n\n        long prodB = bd + (ad << 32);\n        long prodA = ac + (ad >>> 32);\n\n        boolean bita = (bd & 0x8000000000000000L) != 0;\n        boolean bitb = (ad & 0x80000000L ) != 0;\n        boolean bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prodB = prodB + (bc << 32);\n        prodA = prodA + (bc >>> 32);\n\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply input by shpiB */\n        c = shpiB >>> 32;\n        d = shpiB & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prodB += ac;\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply by shpi0 */\n        c = shpi0 >>> 32;\n        d = shpi0 & 0xffffffffL;\n\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        prodA += bd + ((bc + ad) << 32);\n\n        /*\n         * prodA, prodB now contain the remainder as a fraction of PI.  We want this as a fraction of\n         * PI/2, so use the following steps:\n         * 1.) multiply by 4.\n         * 2.) do a fixed point muliply by PI/4.\n         * 3.) Convert to floating point.\n         * 4.) Multiply by 2\n         */\n\n        /* This identifies the quadrant */\n        int intPart = (int)(prodA >>> 62);\n\n        /* Multiply by 4 */\n        prodA <<= 2;\n        prodA |= prodB >>> 62;\n        prodB <<= 2;\n\n        /* Multiply by PI/4 */\n        a = prodA >>> 32;\n        b = prodA & 0xffffffffL;\n\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n\n        ac = a * c;\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        long prod2B = bd + (ad << 32);\n        long prod2A = ac + (ad >>> 32);\n\n        bita = (bd & 0x8000000000000000L) != 0;\n        bitb = (ad & 0x80000000L ) != 0;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prod2B = prod2B + (bc << 32);\n        prod2A = prod2A + (bc >>> 32);\n\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply input by pio4bits[1] */\n        c = PI_O_4_BITS[1] >>> 32;\n        d = PI_O_4_BITS[1] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply inputB by pio4bits[0] */\n        a = prodB >>> 32;\n        b = prodB & 0xffffffffL;\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Convert to double */\ndouble tmpA = ((prod2A >> 12) % TWO_POWER_52);\n        double tmpB = (((prod2A & 0xfffL) << 40) + (prod2B >>> 24)) / TWO_POWER_52 / TWO_POWER_52; // Low bits\n\n        double sumA = tmpA + tmpB;\n        double sumB = -(sumA - tmpA - tmpB);\n\n        /* Multiply by PI/2 and return */\n        result[0] = intPart;\n        result[1] = sumA * 2.0;\n        result[2] = sumB * 2.0;\n    }",
          "51": "    private static void reducePayneHanek(double x, double result[])\n    {\n        /* Convert input double to bits */\n        long inbits = Double.doubleToRawLongBits(x);\n        int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n\n        /* Convert to fixed point representation */\n        inbits &= 0x000fffffffffffffL;\n        inbits |= 0x0010000000000000L;\n\n        /* Normalize input to be between 0.5 and 1.0 */\n        exponent++;\n        inbits <<= 11;\n\n        /* Based on the exponent, get a shifted copy of recip2pi */\n        long shpi0;\n        long shpiA;\n        long shpiB;\n        int idx = exponent >> 6;\n        int shift = exponent - (idx << 6);\n\n        if (shift != 0) {\n            shpi0 = (idx == 0) ? 0 : (RECIP_2PI[idx-1] << shift);\n            shpi0 |= RECIP_2PI[idx] >>> (64-shift);\n            shpiA = (RECIP_2PI[idx] << shift) | (RECIP_2PI[idx+1] >>> (64-shift));\n            shpiB = (RECIP_2PI[idx+1] << shift) | (RECIP_2PI[idx+2] >>> (64-shift));\n        } else {\n            shpi0 = (idx == 0) ? 0 : RECIP_2PI[idx-1];\n            shpiA = RECIP_2PI[idx];\n            shpiB = RECIP_2PI[idx+1];\n        }\n\n        /* Multiply input by shpiA */\n        long a = inbits >>> 32;\n        long b = inbits & 0xffffffffL;\n\n        long c = shpiA >>> 32;\n        long d = shpiA & 0xffffffffL;\n\n        long ac = a * c;\n        long bd = b * d;\n        long bc = b * c;\n        long ad = a * d;\n\n        long prodB = bd + (ad << 32);\n        long prodA = ac + (ad >>> 32);\n\n        boolean bita = (bd & 0x8000000000000000L) != 0;\n        boolean bitb = (ad & 0x80000000L ) != 0;\n        boolean bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prodB = prodB + (bc << 32);\n        prodA = prodA + (bc >>> 32);\n\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply input by shpiB */\n        c = shpiB >>> 32;\n        d = shpiB & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prodB += ac;\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply by shpi0 */\n        c = shpi0 >>> 32;\n        d = shpi0 & 0xffffffffL;\n\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        prodA += bd + ((bc + ad) << 32);\n\n        /*\n         * prodA, prodB now contain the remainder as a fraction of PI.  We want this as a fraction of\n         * PI/2, so use the following steps:\n         * 1.) multiply by 4.\n         * 2.) do a fixed point muliply by PI/4.\n         * 3.) Convert to floating point.\n         * 4.) Multiply by 2\n         */\n\n        /* This identifies the quadrant */\n        int intPart = (int)(prodA >>> 62);\n\n        /* Multiply by 4 */\n        prodA <<= 2;\n        prodA |= prodB >>> 62;\n        prodB <<= 2;\n\n        /* Multiply by PI/4 */\n        a = prodA >>> 32;\n        b = prodA & 0xffffffffL;\n\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n\n        ac = a * c;\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        long prod2B = bd + (ad << 32);\n        long prod2A = ac + (ad >>> 32);\n\n        bita = (bd & 0x8000000000000000L) != 0;\n        bitb = (ad & 0x80000000L ) != 0;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prod2B = prod2B + (bc << 32);\n        prod2A = prod2A + (bc >>> 32);\n\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply input by pio4bits[1] */\n        c = PI_O_4_BITS[1] >>> 32;\n        d = PI_O_4_BITS[1] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply inputB by pio4bits[0] */\n        a = prodB >>> 32;\n        b = prodB & 0xffffffffL;\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Convert to double */\ndouble tmpA = ((prod2A >> 12) * TWO_POWER_52);\n        double tmpB = (((prod2A & 0xfffL) << 40) + (prod2B >>> 24)) / TWO_POWER_52 / TWO_POWER_52; // Low bits\n\n        double sumA = tmpA + tmpB;\n        double sumB = -(sumA - tmpA - tmpB);\n\n        /* Multiply by PI/2 and return */\n        result[0] = intPart;\n        result[1] = sumA * 2.0;\n        result[2] = sumB * 2.0;\n    }",
          "52": "    private static void reducePayneHanek(double x, double result[])\n    {\n        /* Convert input double to bits */\n        long inbits = Double.doubleToRawLongBits(x);\n        int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n\n        /* Convert to fixed point representation */\n        inbits &= 0x000fffffffffffffL;\n        inbits |= 0x0010000000000000L;\n\n        /* Normalize input to be between 0.5 and 1.0 */\n        exponent++;\n        inbits <<= 11;\n\n        /* Based on the exponent, get a shifted copy of recip2pi */\n        long shpi0;\n        long shpiA;\n        long shpiB;\n        int idx = exponent >> 6;\n        int shift = exponent - (idx << 6);\n\n        if (shift != 0) {\n            shpi0 = (idx == 0) ? 0 : (RECIP_2PI[idx-1] << shift);\n            shpi0 |= RECIP_2PI[idx] >>> (64-shift);\n            shpiA = (RECIP_2PI[idx] << shift) | (RECIP_2PI[idx+1] >>> (64-shift));\n            shpiB = (RECIP_2PI[idx+1] << shift) | (RECIP_2PI[idx+2] >>> (64-shift));\n        } else {\n            shpi0 = (idx == 0) ? 0 : RECIP_2PI[idx-1];\n            shpiA = RECIP_2PI[idx];\n            shpiB = RECIP_2PI[idx+1];\n        }\n\n        /* Multiply input by shpiA */\n        long a = inbits >>> 32;\n        long b = inbits & 0xffffffffL;\n\n        long c = shpiA >>> 32;\n        long d = shpiA & 0xffffffffL;\n\n        long ac = a * c;\n        long bd = b * d;\n        long bc = b * c;\n        long ad = a * d;\n\n        long prodB = bd + (ad << 32);\n        long prodA = ac + (ad >>> 32);\n\n        boolean bita = (bd & 0x8000000000000000L) != 0;\n        boolean bitb = (ad & 0x80000000L ) != 0;\n        boolean bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prodB = prodB + (bc << 32);\n        prodA = prodA + (bc >>> 32);\n\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply input by shpiB */\n        c = shpiB >>> 32;\n        d = shpiB & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prodB += ac;\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply by shpi0 */\n        c = shpi0 >>> 32;\n        d = shpi0 & 0xffffffffL;\n\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        prodA += bd + ((bc + ad) << 32);\n\n        /*\n         * prodA, prodB now contain the remainder as a fraction of PI.  We want this as a fraction of\n         * PI/2, so use the following steps:\n         * 1.) multiply by 4.\n         * 2.) do a fixed point muliply by PI/4.\n         * 3.) Convert to floating point.\n         * 4.) Multiply by 2\n         */\n\n        /* This identifies the quadrant */\n        int intPart = (int)(prodA >>> 62);\n\n        /* Multiply by 4 */\n        prodA <<= 2;\n        prodA |= prodB >>> 62;\n        prodB <<= 2;\n\n        /* Multiply by PI/4 */\n        a = prodA >>> 32;\n        b = prodA & 0xffffffffL;\n\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n\n        ac = a * c;\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        long prod2B = bd + (ad << 32);\n        long prod2A = ac + (ad >>> 32);\n\n        bita = (bd & 0x8000000000000000L) != 0;\n        bitb = (ad & 0x80000000L ) != 0;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prod2B = prod2B + (bc << 32);\n        prod2A = prod2A + (bc >>> 32);\n\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply input by pio4bits[1] */\n        c = PI_O_4_BITS[1] >>> 32;\n        d = PI_O_4_BITS[1] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply inputB by pio4bits[0] */\n        a = prodB >>> 32;\n        b = prodB & 0xffffffffL;\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Convert to double */\ndouble tmpA = ((prod2A % 12) / TWO_POWER_52);\n        double tmpB = (((prod2A & 0xfffL) << 40) + (prod2B >>> 24)) / TWO_POWER_52 / TWO_POWER_52; // Low bits\n\n        double sumA = tmpA + tmpB;\n        double sumB = -(sumA - tmpA - tmpB);\n\n        /* Multiply by PI/2 and return */\n        result[0] = intPart;\n        result[1] = sumA * 2.0;\n        result[2] = sumB * 2.0;\n    }",
          "53": "    private static void reducePayneHanek(double x, double result[])\n    {\n        /* Convert input double to bits */\n        long inbits = Double.doubleToRawLongBits(x);\n        int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n\n        /* Convert to fixed point representation */\n        inbits &= 0x000fffffffffffffL;\n        inbits |= 0x0010000000000000L;\n\n        /* Normalize input to be between 0.5 and 1.0 */\n        exponent++;\n        inbits <<= 11;\n\n        /* Based on the exponent, get a shifted copy of recip2pi */\n        long shpi0;\n        long shpiA;\n        long shpiB;\n        int idx = exponent >> 6;\n        int shift = exponent - (idx << 6);\n\n        if (shift != 0) {\n            shpi0 = (idx == 0) ? 0 : (RECIP_2PI[idx-1] << shift);\n            shpi0 |= RECIP_2PI[idx] >>> (64-shift);\n            shpiA = (RECIP_2PI[idx] << shift) | (RECIP_2PI[idx+1] >>> (64-shift));\n            shpiB = (RECIP_2PI[idx+1] << shift) | (RECIP_2PI[idx+2] >>> (64-shift));\n        } else {\n            shpi0 = (idx == 0) ? 0 : RECIP_2PI[idx-1];\n            shpiA = RECIP_2PI[idx];\n            shpiB = RECIP_2PI[idx+1];\n        }\n\n        /* Multiply input by shpiA */\n        long a = inbits >>> 32;\n        long b = inbits & 0xffffffffL;\n\n        long c = shpiA >>> 32;\n        long d = shpiA & 0xffffffffL;\n\n        long ac = a * c;\n        long bd = b * d;\n        long bc = b * c;\n        long ad = a * d;\n\n        long prodB = bd + (ad << 32);\n        long prodA = ac + (ad >>> 32);\n\n        boolean bita = (bd & 0x8000000000000000L) != 0;\n        boolean bitb = (ad & 0x80000000L ) != 0;\n        boolean bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prodB = prodB + (bc << 32);\n        prodA = prodA + (bc >>> 32);\n\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply input by shpiB */\n        c = shpiB >>> 32;\n        d = shpiB & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prodB += ac;\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply by shpi0 */\n        c = shpi0 >>> 32;\n        d = shpi0 & 0xffffffffL;\n\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        prodA += bd + ((bc + ad) << 32);\n\n        /*\n         * prodA, prodB now contain the remainder as a fraction of PI.  We want this as a fraction of\n         * PI/2, so use the following steps:\n         * 1.) multiply by 4.\n         * 2.) do a fixed point muliply by PI/4.\n         * 3.) Convert to floating point.\n         * 4.) Multiply by 2\n         */\n\n        /* This identifies the quadrant */\n        int intPart = (int)(prodA >>> 62);\n\n        /* Multiply by 4 */\n        prodA <<= 2;\n        prodA |= prodB >>> 62;\n        prodB <<= 2;\n\n        /* Multiply by PI/4 */\n        a = prodA >>> 32;\n        b = prodA & 0xffffffffL;\n\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n\n        ac = a * c;\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        long prod2B = bd + (ad << 32);\n        long prod2A = ac + (ad >>> 32);\n\n        bita = (bd & 0x8000000000000000L) != 0;\n        bitb = (ad & 0x80000000L ) != 0;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prod2B = prod2B + (bc << 32);\n        prod2A = prod2A + (bc >>> 32);\n\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply input by pio4bits[1] */\n        c = PI_O_4_BITS[1] >>> 32;\n        d = PI_O_4_BITS[1] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply inputB by pio4bits[0] */\n        a = prodB >>> 32;\n        b = prodB & 0xffffffffL;\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Convert to double */\ndouble tmpA = ((prod2A >> 12) >>> TWO_POWER_52);\n        double tmpB = (((prod2A & 0xfffL) << 40) + (prod2B >>> 24)) / TWO_POWER_52 / TWO_POWER_52; // Low bits\n\n        double sumA = tmpA + tmpB;\n        double sumB = -(sumA - tmpA - tmpB);\n\n        /* Multiply by PI/2 and return */\n        result[0] = intPart;\n        result[1] = sumA * 2.0;\n        result[2] = sumB * 2.0;\n    }",
          "54": "    private static void reducePayneHanek(double x, double result[])\n    {\n        /* Convert input double to bits */\n        long inbits = Double.doubleToRawLongBits(x);\n        int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n\n        /* Convert to fixed point representation */\n        inbits &= 0x000fffffffffffffL;\n        inbits |= 0x0010000000000000L;\n\n        /* Normalize input to be between 0.5 and 1.0 */\n        exponent++;\n        inbits <<= 11;\n\n        /* Based on the exponent, get a shifted copy of recip2pi */\n        long shpi0;\n        long shpiA;\n        long shpiB;\n        int idx = exponent >> 6;\n        int shift = exponent - (idx << 6);\n\n        if (shift != 0) {\n            shpi0 = (idx == 0) ? 0 : (RECIP_2PI[idx-1] << shift);\n            shpi0 |= RECIP_2PI[idx] >>> (64-shift);\n            shpiA = (RECIP_2PI[idx] << shift) | (RECIP_2PI[idx+1] >>> (64-shift));\n            shpiB = (RECIP_2PI[idx+1] << shift) | (RECIP_2PI[idx+2] >>> (64-shift));\n        } else {\n            shpi0 = (idx == 0) ? 0 : RECIP_2PI[idx-1];\n            shpiA = RECIP_2PI[idx];\n            shpiB = RECIP_2PI[idx+1];\n        }\n\n        /* Multiply input by shpiA */\n        long a = inbits >>> 32;\n        long b = inbits & 0xffffffffL;\n\n        long c = shpiA >>> 32;\n        long d = shpiA & 0xffffffffL;\n\n        long ac = a * c;\n        long bd = b * d;\n        long bc = b * c;\n        long ad = a * d;\n\n        long prodB = bd + (ad << 32);\n        long prodA = ac + (ad >>> 32);\n\n        boolean bita = (bd & 0x8000000000000000L) != 0;\n        boolean bitb = (ad & 0x80000000L ) != 0;\n        boolean bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prodB = prodB + (bc << 32);\n        prodA = prodA + (bc >>> 32);\n\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply input by shpiB */\n        c = shpiB >>> 32;\n        d = shpiB & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prodB += ac;\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply by shpi0 */\n        c = shpi0 >>> 32;\n        d = shpi0 & 0xffffffffL;\n\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        prodA += bd + ((bc + ad) << 32);\n\n        /*\n         * prodA, prodB now contain the remainder as a fraction of PI.  We want this as a fraction of\n         * PI/2, so use the following steps:\n         * 1.) multiply by 4.\n         * 2.) do a fixed point muliply by PI/4.\n         * 3.) Convert to floating point.\n         * 4.) Multiply by 2\n         */\n\n        /* This identifies the quadrant */\n        int intPart = (int)(prodA >>> 62);\n\n        /* Multiply by 4 */\n        prodA <<= 2;\n        prodA |= prodB >>> 62;\n        prodB <<= 2;\n\n        /* Multiply by PI/4 */\n        a = prodA >>> 32;\n        b = prodA & 0xffffffffL;\n\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n\n        ac = a * c;\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        long prod2B = bd + (ad << 32);\n        long prod2A = ac + (ad >>> 32);\n\n        bita = (bd & 0x8000000000000000L) != 0;\n        bitb = (ad & 0x80000000L ) != 0;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prod2B = prod2B + (bc << 32);\n        prod2A = prod2A + (bc >>> 32);\n\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply input by pio4bits[1] */\n        c = PI_O_4_BITS[1] >>> 32;\n        d = PI_O_4_BITS[1] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply inputB by pio4bits[0] */\n        a = prodB >>> 32;\n        b = prodB & 0xffffffffL;\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Convert to double */\nlong tmpA = ((prod2A >> 12) / TWO_POWER_52);\n        double tmpB = (((prod2A & 0xfffL) << 40) + (prod2B >>> 24)) / TWO_POWER_52 / TWO_POWER_52; // Low bits\n\n        double sumA = tmpA + tmpB;\n        double sumB = -(sumA - tmpA - tmpB);\n\n        /* Multiply by PI/2 and return */\n        result[0] = intPart;\n        result[1] = sumA * 2.0;\n        result[2] = sumB * 2.0;\n    }",
          "55": "    private static void reducePayneHanek(double x, double result[])\n    {\n        /* Convert input double to bits */\n        long inbits = Double.doubleToRawLongBits(x);\n        int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n\n        /* Convert to fixed point representation */\n        inbits &= 0x000fffffffffffffL;\n        inbits |= 0x0010000000000000L;\n\n        /* Normalize input to be between 0.5 and 1.0 */\n        exponent++;\n        inbits <<= 11;\n\n        /* Based on the exponent, get a shifted copy of recip2pi */\n        long shpi0;\n        long shpiA;\n        long shpiB;\n        int idx = exponent >> 6;\n        int shift = exponent - (idx << 6);\n\n        if (shift != 0) {\n            shpi0 = (idx == 0) ? 0 : (RECIP_2PI[idx-1] << shift);\n            shpi0 |= RECIP_2PI[idx] >>> (64-shift);\n            shpiA = (RECIP_2PI[idx] << shift) | (RECIP_2PI[idx+1] >>> (64-shift));\n            shpiB = (RECIP_2PI[idx+1] << shift) | (RECIP_2PI[idx+2] >>> (64-shift));\n        } else {\n            shpi0 = (idx == 0) ? 0 : RECIP_2PI[idx-1];\n            shpiA = RECIP_2PI[idx];\n            shpiB = RECIP_2PI[idx+1];\n        }\n\n        /* Multiply input by shpiA */\n        long a = inbits >>> 32;\n        long b = inbits & 0xffffffffL;\n\n        long c = shpiA >>> 32;\n        long d = shpiA & 0xffffffffL;\n\n        long ac = a * c;\n        long bd = b * d;\n        long bc = b * c;\n        long ad = a * d;\n\n        long prodB = bd + (ad << 32);\n        long prodA = ac + (ad >>> 32);\n\n        boolean bita = (bd & 0x8000000000000000L) != 0;\n        boolean bitb = (ad & 0x80000000L ) != 0;\n        boolean bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prodB = prodB + (bc << 32);\n        prodA = prodA + (bc >>> 32);\n\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply input by shpiB */\n        c = shpiB >>> 32;\n        d = shpiB & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prodB += ac;\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply by shpi0 */\n        c = shpi0 >>> 32;\n        d = shpi0 & 0xffffffffL;\n\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        prodA += bd + ((bc + ad) << 32);\n\n        /*\n         * prodA, prodB now contain the remainder as a fraction of PI.  We want this as a fraction of\n         * PI/2, so use the following steps:\n         * 1.) multiply by 4.\n         * 2.) do a fixed point muliply by PI/4.\n         * 3.) Convert to floating point.\n         * 4.) Multiply by 2\n         */\n\n        /* This identifies the quadrant */\n        int intPart = (int)(prodA >>> 62);\n\n        /* Multiply by 4 */\n        prodA <<= 2;\n        prodA |= prodB >>> 62;\n        prodB <<= 2;\n\n        /* Multiply by PI/4 */\n        a = prodA >>> 32;\n        b = prodA & 0xffffffffL;\n\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n\n        ac = a * c;\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        long prod2B = bd + (ad << 32);\n        long prod2A = ac + (ad >>> 32);\n\n        bita = (bd & 0x8000000000000000L) != 0;\n        bitb = (ad & 0x80000000L ) != 0;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prod2B = prod2B + (bc << 32);\n        prod2A = prod2A + (bc >>> 32);\n\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply input by pio4bits[1] */\n        c = PI_O_4_BITS[1] >>> 32;\n        d = PI_O_4_BITS[1] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply inputB by pio4bits[0] */\n        a = prodB >>> 32;\n        b = prodB & 0xffffffffL;\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Convert to double */\ndouble tmpA = ((prod2A >> 12) << TWO_POWER_52);\n        double tmpB = (((prod2A & 0xfffL) << 40) + (prod2B >>> 24)) / TWO_POWER_52 / TWO_POWER_52; // Low bits\n\n        double sumA = tmpA + tmpB;\n        double sumB = -(sumA - tmpA - tmpB);\n\n        /* Multiply by PI/2 and return */\n        result[0] = intPart;\n        result[1] = sumA * 2.0;\n        result[2] = sumB * 2.0;\n    }",
          "56": "    private static void reducePayneHanek(double x, double result[])\n    {\n        /* Convert input double to bits */\n        long inbits = Double.doubleToRawLongBits(x);\n        int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n\n        /* Convert to fixed point representation */\n        inbits &= 0x000fffffffffffffL;\n        inbits |= 0x0010000000000000L;\n\n        /* Normalize input to be between 0.5 and 1.0 */\n        exponent++;\n        inbits <<= 11;\n\n        /* Based on the exponent, get a shifted copy of recip2pi */\n        long shpi0;\n        long shpiA;\n        long shpiB;\n        int idx = exponent >> 6;\n        int shift = exponent - (idx << 6);\n\n        if (shift != 0) {\n            shpi0 = (idx == 0) ? 0 : (RECIP_2PI[idx-1] << shift);\n            shpi0 |= RECIP_2PI[idx] >>> (64-shift);\n            shpiA = (RECIP_2PI[idx] << shift) | (RECIP_2PI[idx+1] >>> (64-shift));\n            shpiB = (RECIP_2PI[idx+1] << shift) | (RECIP_2PI[idx+2] >>> (64-shift));\n        } else {\n            shpi0 = (idx == 0) ? 0 : RECIP_2PI[idx-1];\n            shpiA = RECIP_2PI[idx];\n            shpiB = RECIP_2PI[idx+1];\n        }\n\n        /* Multiply input by shpiA */\n        long a = inbits >>> 32;\n        long b = inbits & 0xffffffffL;\n\n        long c = shpiA >>> 32;\n        long d = shpiA & 0xffffffffL;\n\n        long ac = a * c;\n        long bd = b * d;\n        long bc = b * c;\n        long ad = a * d;\n\n        long prodB = bd + (ad << 32);\n        long prodA = ac + (ad >>> 32);\n\n        boolean bita = (bd & 0x8000000000000000L) != 0;\n        boolean bitb = (ad & 0x80000000L ) != 0;\n        boolean bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prodB = prodB + (bc << 32);\n        prodA = prodA + (bc >>> 32);\n\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply input by shpiB */\n        c = shpiB >>> 32;\n        d = shpiB & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prodB += ac;\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply by shpi0 */\n        c = shpi0 >>> 32;\n        d = shpi0 & 0xffffffffL;\n\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        prodA += bd + ((bc + ad) << 32);\n\n        /*\n         * prodA, prodB now contain the remainder as a fraction of PI.  We want this as a fraction of\n         * PI/2, so use the following steps:\n         * 1.) multiply by 4.\n         * 2.) do a fixed point muliply by PI/4.\n         * 3.) Convert to floating point.\n         * 4.) Multiply by 2\n         */\n\n        /* This identifies the quadrant */\n        int intPart = (int)(prodA >>> 62);\n\n        /* Multiply by 4 */\n        prodA <<= 2;\n        prodA |= prodB >>> 62;\n        prodB <<= 2;\n\n        /* Multiply by PI/4 */\n        a = prodA >>> 32;\n        b = prodA & 0xffffffffL;\n\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n\n        ac = a * c;\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        long prod2B = bd + (ad << 32);\n        long prod2A = ac + (ad >>> 32);\n\n        bita = (bd & 0x8000000000000000L) != 0;\n        bitb = (ad & 0x80000000L ) != 0;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prod2B = prod2B + (bc << 32);\n        prod2A = prod2A + (bc >>> 32);\n\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply input by pio4bits[1] */\n        c = PI_O_4_BITS[1] >>> 32;\n        d = PI_O_4_BITS[1] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply inputB by pio4bits[0] */\n        a = prodB >>> 32;\n        b = prodB & 0xffffffffL;\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Convert to double */\nbita = ((prod2B & 0x8000000000000000L) != 0);\n        double tmpA = (prod2A >> 12) / TWO_POWER_52;  // High order 52 bits        double tmpB = (((prod2A & 0xfffL) << 40) + (prod2B >>> 24)) / TWO_POWER_52 / TWO_POWER_52; // Low bits\n\n        double sumA = tmpA + tmpB;\n        double sumB = -(sumA - tmpA - tmpB);\n\n        /* Multiply by PI/2 and return */\n        result[0] = intPart;\n        result[1] = sumA * 2.0;\n        result[2] = sumB * 2.0;\n    }",
          "57": "    private static void reducePayneHanek(double x, double result[])\n    {\n        /* Convert input double to bits */\n        long inbits = Double.doubleToRawLongBits(x);\n        int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n\n        /* Convert to fixed point representation */\n        inbits &= 0x000fffffffffffffL;\n        inbits |= 0x0010000000000000L;\n\n        /* Normalize input to be between 0.5 and 1.0 */\n        exponent++;\n        inbits <<= 11;\n\n        /* Based on the exponent, get a shifted copy of recip2pi */\n        long shpi0;\n        long shpiA;\n        long shpiB;\n        int idx = exponent >> 6;\n        int shift = exponent - (idx << 6);\n\n        if (shift != 0) {\n            shpi0 = (idx == 0) ? 0 : (RECIP_2PI[idx-1] << shift);\n            shpi0 |= RECIP_2PI[idx] >>> (64-shift);\n            shpiA = (RECIP_2PI[idx] << shift) | (RECIP_2PI[idx+1] >>> (64-shift));\n            shpiB = (RECIP_2PI[idx+1] << shift) | (RECIP_2PI[idx+2] >>> (64-shift));\n        } else {\n            shpi0 = (idx == 0) ? 0 : RECIP_2PI[idx-1];\n            shpiA = RECIP_2PI[idx];\n            shpiB = RECIP_2PI[idx+1];\n        }\n\n        /* Multiply input by shpiA */\n        long a = inbits >>> 32;\n        long b = inbits & 0xffffffffL;\n\n        long c = shpiA >>> 32;\n        long d = shpiA & 0xffffffffL;\n\n        long ac = a * c;\n        long bd = b * d;\n        long bc = b * c;\n        long ad = a * d;\n\n        long prodB = bd + (ad << 32);\n        long prodA = ac + (ad >>> 32);\n\n        boolean bita = (bd & 0x8000000000000000L) != 0;\n        boolean bitb = (ad & 0x80000000L ) != 0;\n        boolean bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prodB = prodB + (bc << 32);\n        prodA = prodA + (bc >>> 32);\n\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply input by shpiB */\n        c = shpiB >>> 32;\n        d = shpiB & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prodB += ac;\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply by shpi0 */\n        c = shpi0 >>> 32;\n        d = shpi0 & 0xffffffffL;\n\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        prodA += bd + ((bc + ad) << 32);\n\n        /*\n         * prodA, prodB now contain the remainder as a fraction of PI.  We want this as a fraction of\n         * PI/2, so use the following steps:\n         * 1.) multiply by 4.\n         * 2.) do a fixed point muliply by PI/4.\n         * 3.) Convert to floating point.\n         * 4.) Multiply by 2\n         */\n\n        /* This identifies the quadrant */\n        int intPart = (int)(prodA >>> 62);\n\n        /* Multiply by 4 */\n        prodA <<= 2;\n        prodA |= prodB >>> 62;\n        prodB <<= 2;\n\n        /* Multiply by PI/4 */\n        a = prodA >>> 32;\n        b = prodA & 0xffffffffL;\n\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n\n        ac = a * c;\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        long prod2B = bd + (ad << 32);\n        long prod2A = ac + (ad >>> 32);\n\n        bita = (bd & 0x8000000000000000L) != 0;\n        bitb = (ad & 0x80000000L ) != 0;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prod2B = prod2B + (bc << 32);\n        prod2A = prod2A + (bc >>> 32);\n\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply input by pio4bits[1] */\n        c = PI_O_4_BITS[1] >>> 32;\n        d = PI_O_4_BITS[1] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply inputB by pio4bits[0] */\n        a = prodB >>> 32;\n        b = prodB & 0xffffffffL;\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Convert to double */\ndouble tmpA = ((prod2A >> -1) / TWO_POWER_52);\n        double tmpB = (((prod2A & 0xfffL) << 40) + (prod2B >>> 24)) / TWO_POWER_52 / TWO_POWER_52; // Low bits\n\n        double sumA = tmpA + tmpB;\n        double sumB = -(sumA - tmpA - tmpB);\n\n        /* Multiply by PI/2 and return */\n        result[0] = intPart;\n        result[1] = sumA * 2.0;\n        result[2] = sumB * 2.0;\n    }",
          "58": "    private static void reducePayneHanek(double x, double result[])\n    {\n        /* Convert input double to bits */\n        long inbits = Double.doubleToRawLongBits(x);\n        int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n\n        /* Convert to fixed point representation */\n        inbits &= 0x000fffffffffffffL;\n        inbits |= 0x0010000000000000L;\n\n        /* Normalize input to be between 0.5 and 1.0 */\n        exponent++;\n        inbits <<= 11;\n\n        /* Based on the exponent, get a shifted copy of recip2pi */\n        long shpi0;\n        long shpiA;\n        long shpiB;\n        int idx = exponent >> 6;\n        int shift = exponent - (idx << 6);\n\n        if (shift != 0) {\n            shpi0 = (idx == 0) ? 0 : (RECIP_2PI[idx-1] << shift);\n            shpi0 |= RECIP_2PI[idx] >>> (64-shift);\n            shpiA = (RECIP_2PI[idx] << shift) | (RECIP_2PI[idx+1] >>> (64-shift));\n            shpiB = (RECIP_2PI[idx+1] << shift) | (RECIP_2PI[idx+2] >>> (64-shift));\n        } else {\n            shpi0 = (idx == 0) ? 0 : RECIP_2PI[idx-1];\n            shpiA = RECIP_2PI[idx];\n            shpiB = RECIP_2PI[idx+1];\n        }\n\n        /* Multiply input by shpiA */\n        long a = inbits >>> 32;\n        long b = inbits & 0xffffffffL;\n\n        long c = shpiA >>> 32;\n        long d = shpiA & 0xffffffffL;\n\n        long ac = a * c;\n        long bd = b * d;\n        long bc = b * c;\n        long ad = a * d;\n\n        long prodB = bd + (ad << 32);\n        long prodA = ac + (ad >>> 32);\n\n        boolean bita = (bd & 0x8000000000000000L) != 0;\n        boolean bitb = (ad & 0x80000000L ) != 0;\n        boolean bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prodB = prodB + (bc << 32);\n        prodA = prodA + (bc >>> 32);\n\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply input by shpiB */\n        c = shpiB >>> 32;\n        d = shpiB & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prodB += ac;\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply by shpi0 */\n        c = shpi0 >>> 32;\n        d = shpi0 & 0xffffffffL;\n\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        prodA += bd + ((bc + ad) << 32);\n\n        /*\n         * prodA, prodB now contain the remainder as a fraction of PI.  We want this as a fraction of\n         * PI/2, so use the following steps:\n         * 1.) multiply by 4.\n         * 2.) do a fixed point muliply by PI/4.\n         * 3.) Convert to floating point.\n         * 4.) Multiply by 2\n         */\n\n        /* This identifies the quadrant */\n        int intPart = (int)(prodA >>> 62);\n\n        /* Multiply by 4 */\n        prodA <<= 2;\n        prodA |= prodB >>> 62;\n        prodB <<= 2;\n\n        /* Multiply by PI/4 */\n        a = prodA >>> 32;\n        b = prodA & 0xffffffffL;\n\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n\n        ac = a * c;\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        long prod2B = bd + (ad << 32);\n        long prod2A = ac + (ad >>> 32);\n\n        bita = (bd & 0x8000000000000000L) != 0;\n        bitb = (ad & 0x80000000L ) != 0;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prod2B = prod2B + (bc << 32);\n        prod2A = prod2A + (bc >>> 32);\n\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply input by pio4bits[1] */\n        c = PI_O_4_BITS[1] >>> 32;\n        d = PI_O_4_BITS[1] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply inputB by pio4bits[0] */\n        a = prodB >>> 32;\n        b = prodB & 0xffffffffL;\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Convert to double */\ndouble tmpA = ((prod2A <= 12) / TWO_POWER_52);\n        double tmpB = (((prod2A & 0xfffL) << 40) + (prod2B >>> 24)) / TWO_POWER_52 / TWO_POWER_52; // Low bits\n\n        double sumA = tmpA + tmpB;\n        double sumB = -(sumA - tmpA - tmpB);\n\n        /* Multiply by PI/2 and return */\n        result[0] = intPart;\n        result[1] = sumA * 2.0;\n        result[2] = sumB * 2.0;\n    }",
          "59": "    private static void reducePayneHanek(double x, double result[])\n    {\n        /* Convert input double to bits */\n        long inbits = Double.doubleToRawLongBits(x);\n        int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n\n        /* Convert to fixed point representation */\n        inbits &= 0x000fffffffffffffL;\n        inbits |= 0x0010000000000000L;\n\n        /* Normalize input to be between 0.5 and 1.0 */\n        exponent++;\n        inbits <<= 11;\n\n        /* Based on the exponent, get a shifted copy of recip2pi */\n        long shpi0;\n        long shpiA;\n        long shpiB;\n        int idx = exponent >> 6;\n        int shift = exponent - (idx << 6);\n\n        if (shift != 0) {\n            shpi0 = (idx == 0) ? 0 : (RECIP_2PI[idx-1] << shift);\n            shpi0 |= RECIP_2PI[idx] >>> (64-shift);\n            shpiA = (RECIP_2PI[idx] << shift) | (RECIP_2PI[idx+1] >>> (64-shift));\n            shpiB = (RECIP_2PI[idx+1] << shift) | (RECIP_2PI[idx+2] >>> (64-shift));\n        } else {\n            shpi0 = (idx == 0) ? 0 : RECIP_2PI[idx-1];\n            shpiA = RECIP_2PI[idx];\n            shpiB = RECIP_2PI[idx+1];\n        }\n\n        /* Multiply input by shpiA */\n        long a = inbits >>> 32;\n        long b = inbits & 0xffffffffL;\n\n        long c = shpiA >>> 32;\n        long d = shpiA & 0xffffffffL;\n\n        long ac = a * c;\n        long bd = b * d;\n        long bc = b * c;\n        long ad = a * d;\n\n        long prodB = bd + (ad << 32);\n        long prodA = ac + (ad >>> 32);\n\n        boolean bita = (bd & 0x8000000000000000L) != 0;\n        boolean bitb = (ad & 0x80000000L ) != 0;\n        boolean bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prodB = prodB + (bc << 32);\n        prodA = prodA + (bc >>> 32);\n\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply input by shpiB */\n        c = shpiB >>> 32;\n        d = shpiB & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prodB += ac;\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply by shpi0 */\n        c = shpi0 >>> 32;\n        d = shpi0 & 0xffffffffL;\n\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        prodA += bd + ((bc + ad) << 32);\n\n        /*\n         * prodA, prodB now contain the remainder as a fraction of PI.  We want this as a fraction of\n         * PI/2, so use the following steps:\n         * 1.) multiply by 4.\n         * 2.) do a fixed point muliply by PI/4.\n         * 3.) Convert to floating point.\n         * 4.) Multiply by 2\n         */\n\n        /* This identifies the quadrant */\n        int intPart = (int)(prodA >>> 62);\n\n        /* Multiply by 4 */\n        prodA <<= 2;\n        prodA |= prodB >>> 62;\n        prodB <<= 2;\n\n        /* Multiply by PI/4 */\n        a = prodA >>> 32;\n        b = prodA & 0xffffffffL;\n\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n\n        ac = a * c;\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        long prod2B = bd + (ad << 32);\n        long prod2A = ac + (ad >>> 32);\n\n        bita = (bd & 0x8000000000000000L) != 0;\n        bitb = (ad & 0x80000000L ) != 0;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prod2B = prod2B + (bc << 32);\n        prod2A = prod2A + (bc >>> 32);\n\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply input by pio4bits[1] */\n        c = PI_O_4_BITS[1] >>> 32;\n        d = PI_O_4_BITS[1] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply inputB by pio4bits[0] */\n        a = prodB >>> 32;\n        b = prodB & 0xffffffffL;\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Convert to double */\ndouble tmpA = ((prod2A >= 12) / TWO_POWER_52);\n        double tmpB = (((prod2A & 0xfffL) << 40) + (prod2B >>> 24)) / TWO_POWER_52 / TWO_POWER_52; // Low bits\n\n        double sumA = tmpA + tmpB;\n        double sumB = -(sumA - tmpA - tmpB);\n\n        /* Multiply by PI/2 and return */\n        result[0] = intPart;\n        result[1] = sumA * 2.0;\n        result[2] = sumB * 2.0;\n    }",
          "60": "    private static void reducePayneHanek(double x, double result[])\n    {\n        /* Convert input double to bits */\n        long inbits = Double.doubleToRawLongBits(x);\n        int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n\n        /* Convert to fixed point representation */\n        inbits &= 0x000fffffffffffffL;\n        inbits |= 0x0010000000000000L;\n\n        /* Normalize input to be between 0.5 and 1.0 */\n        exponent++;\n        inbits <<= 11;\n\n        /* Based on the exponent, get a shifted copy of recip2pi */\n        long shpi0;\n        long shpiA;\n        long shpiB;\n        int idx = exponent >> 6;\n        int shift = exponent - (idx << 6);\n\n        if (shift != 0) {\n            shpi0 = (idx == 0) ? 0 : (RECIP_2PI[idx-1] << shift);\n            shpi0 |= RECIP_2PI[idx] >>> (64-shift);\n            shpiA = (RECIP_2PI[idx] << shift) | (RECIP_2PI[idx+1] >>> (64-shift));\n            shpiB = (RECIP_2PI[idx+1] << shift) | (RECIP_2PI[idx+2] >>> (64-shift));\n        } else {\n            shpi0 = (idx == 0) ? 0 : RECIP_2PI[idx-1];\n            shpiA = RECIP_2PI[idx];\n            shpiB = RECIP_2PI[idx+1];\n        }\n\n        /* Multiply input by shpiA */\n        long a = inbits >>> 32;\n        long b = inbits & 0xffffffffL;\n\n        long c = shpiA >>> 32;\n        long d = shpiA & 0xffffffffL;\n\n        long ac = a * c;\n        long bd = b * d;\n        long bc = b * c;\n        long ad = a * d;\n\n        long prodB = bd + (ad << 32);\n        long prodA = ac + (ad >>> 32);\n\n        boolean bita = (bd & 0x8000000000000000L) != 0;\n        boolean bitb = (ad & 0x80000000L ) != 0;\n        boolean bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prodB = prodB + (bc << 32);\n        prodA = prodA + (bc >>> 32);\n\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply input by shpiB */\n        c = shpiB >>> 32;\n        d = shpiB & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prodB += ac;\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply by shpi0 */\n        c = shpi0 >>> 32;\n        d = shpi0 & 0xffffffffL;\n\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        prodA += bd + ((bc + ad) << 32);\n\n        /*\n         * prodA, prodB now contain the remainder as a fraction of PI.  We want this as a fraction of\n         * PI/2, so use the following steps:\n         * 1.) multiply by 4.\n         * 2.) do a fixed point muliply by PI/4.\n         * 3.) Convert to floating point.\n         * 4.) Multiply by 2\n         */\n\n        /* This identifies the quadrant */\n        int intPart = (int)(prodA >>> 62);\n\n        /* Multiply by 4 */\n        prodA <<= 2;\n        prodA |= prodB >>> 62;\n        prodB <<= 2;\n\n        /* Multiply by PI/4 */\n        a = prodA >>> 32;\n        b = prodA & 0xffffffffL;\n\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n\n        ac = a * c;\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        long prod2B = bd + (ad << 32);\n        long prod2A = ac + (ad >>> 32);\n\n        bita = (bd & 0x8000000000000000L) != 0;\n        bitb = (ad & 0x80000000L ) != 0;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prod2B = prod2B + (bc << 32);\n        prod2A = prod2A + (bc >>> 32);\n\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply input by pio4bits[1] */\n        c = PI_O_4_BITS[1] >>> 32;\n        d = PI_O_4_BITS[1] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply inputB by pio4bits[0] */\n        a = prodB >>> 32;\n        b = prodB & 0xffffffffL;\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Convert to double */\ndouble tmpA = ((prod2A / 12) / TWO_POWER_52);\n        double tmpB = (((prod2A & 0xfffL) << 40) + (prod2B >>> 24)) / TWO_POWER_52 / TWO_POWER_52; // Low bits\n\n        double sumA = tmpA + tmpB;\n        double sumB = -(sumA - tmpA - tmpB);\n\n        /* Multiply by PI/2 and return */\n        result[0] = intPart;\n        result[1] = sumA * 2.0;\n        result[2] = sumB * 2.0;\n    }",
          "61": "    private static void reducePayneHanek(double x, double result[])\n    {\n        /* Convert input double to bits */\n        long inbits = Double.doubleToRawLongBits(x);\n        int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n\n        /* Convert to fixed point representation */\n        inbits &= 0x000fffffffffffffL;\n        inbits |= 0x0010000000000000L;\n\n        /* Normalize input to be between 0.5 and 1.0 */\n        exponent++;\n        inbits <<= 11;\n\n        /* Based on the exponent, get a shifted copy of recip2pi */\n        long shpi0;\n        long shpiA;\n        long shpiB;\n        int idx = exponent >> 6;\n        int shift = exponent - (idx << 6);\n\n        if (shift != 0) {\n            shpi0 = (idx == 0) ? 0 : (RECIP_2PI[idx-1] << shift);\n            shpi0 |= RECIP_2PI[idx] >>> (64-shift);\n            shpiA = (RECIP_2PI[idx] << shift) | (RECIP_2PI[idx+1] >>> (64-shift));\n            shpiB = (RECIP_2PI[idx+1] << shift) | (RECIP_2PI[idx+2] >>> (64-shift));\n        } else {\n            shpi0 = (idx == 0) ? 0 : RECIP_2PI[idx-1];\n            shpiA = RECIP_2PI[idx];\n            shpiB = RECIP_2PI[idx+1];\n        }\n\n        /* Multiply input by shpiA */\n        long a = inbits >>> 32;\n        long b = inbits & 0xffffffffL;\n\n        long c = shpiA >>> 32;\n        long d = shpiA & 0xffffffffL;\n\n        long ac = a * c;\n        long bd = b * d;\n        long bc = b * c;\n        long ad = a * d;\n\n        long prodB = bd + (ad << 32);\n        long prodA = ac + (ad >>> 32);\n\n        boolean bita = (bd & 0x8000000000000000L) != 0;\n        boolean bitb = (ad & 0x80000000L ) != 0;\n        boolean bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prodB = prodB + (bc << 32);\n        prodA = prodA + (bc >>> 32);\n\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply input by shpiB */\n        c = shpiB >>> 32;\n        d = shpiB & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prodB += ac;\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply by shpi0 */\n        c = shpi0 >>> 32;\n        d = shpi0 & 0xffffffffL;\n\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        prodA += bd + ((bc + ad) << 32);\n\n        /*\n         * prodA, prodB now contain the remainder as a fraction of PI.  We want this as a fraction of\n         * PI/2, so use the following steps:\n         * 1.) multiply by 4.\n         * 2.) do a fixed point muliply by PI/4.\n         * 3.) Convert to floating point.\n         * 4.) Multiply by 2\n         */\n\n        /* This identifies the quadrant */\n        int intPart = (int)(prodA >>> 62);\n\n        /* Multiply by 4 */\n        prodA <<= 2;\n        prodA |= prodB >>> 62;\n        prodB <<= 2;\n\n        /* Multiply by PI/4 */\n        a = prodA >>> 32;\n        b = prodA & 0xffffffffL;\n\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n\n        ac = a * c;\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        long prod2B = bd + (ad << 32);\n        long prod2A = ac + (ad >>> 32);\n\n        bita = (bd & 0x8000000000000000L) != 0;\n        bitb = (ad & 0x80000000L ) != 0;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prod2B = prod2B + (bc << 32);\n        prod2A = prod2A + (bc >>> 32);\n\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply input by pio4bits[1] */\n        c = PI_O_4_BITS[1] >>> 32;\n        d = PI_O_4_BITS[1] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply inputB by pio4bits[0] */\n        a = prodB >>> 32;\n        b = prodB & 0xffffffffL;\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Convert to double */\ndouble tmpA = (prod2A >> 12);\n        double tmpB = (((prod2A & 0xfffL) << 40) + (prod2B >>> 24)) / TWO_POWER_52 / TWO_POWER_52; // Low bits\n\n        double sumA = tmpA + tmpB;\n        double sumB = -(sumA - tmpA - tmpB);\n\n        /* Multiply by PI/2 and return */\n        result[0] = intPart;\n        result[1] = sumA * 2.0;\n        result[2] = sumB * 2.0;\n    }",
          "62": "    private static void reducePayneHanek(double x, double result[])\n    {\n        /* Convert input double to bits */\n        long inbits = Double.doubleToRawLongBits(x);\n        int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n\n        /* Convert to fixed point representation */\n        inbits &= 0x000fffffffffffffL;\n        inbits |= 0x0010000000000000L;\n\n        /* Normalize input to be between 0.5 and 1.0 */\n        exponent++;\n        inbits <<= 11;\n\n        /* Based on the exponent, get a shifted copy of recip2pi */\n        long shpi0;\n        long shpiA;\n        long shpiB;\n        int idx = exponent >> 6;\n        int shift = exponent - (idx << 6);\n\n        if (shift != 0) {\n            shpi0 = (idx == 0) ? 0 : (RECIP_2PI[idx-1] << shift);\n            shpi0 |= RECIP_2PI[idx] >>> (64-shift);\n            shpiA = (RECIP_2PI[idx] << shift) | (RECIP_2PI[idx+1] >>> (64-shift));\n            shpiB = (RECIP_2PI[idx+1] << shift) | (RECIP_2PI[idx+2] >>> (64-shift));\n        } else {\n            shpi0 = (idx == 0) ? 0 : RECIP_2PI[idx-1];\n            shpiA = RECIP_2PI[idx];\n            shpiB = RECIP_2PI[idx+1];\n        }\n\n        /* Multiply input by shpiA */\n        long a = inbits >>> 32;\n        long b = inbits & 0xffffffffL;\n\n        long c = shpiA >>> 32;\n        long d = shpiA & 0xffffffffL;\n\n        long ac = a * c;\n        long bd = b * d;\n        long bc = b * c;\n        long ad = a * d;\n\n        long prodB = bd + (ad << 32);\n        long prodA = ac + (ad >>> 32);\n\n        boolean bita = (bd & 0x8000000000000000L) != 0;\n        boolean bitb = (ad & 0x80000000L ) != 0;\n        boolean bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prodB = prodB + (bc << 32);\n        prodA = prodA + (bc >>> 32);\n\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply input by shpiB */\n        c = shpiB >>> 32;\n        d = shpiB & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prodB += ac;\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply by shpi0 */\n        c = shpi0 >>> 32;\n        d = shpi0 & 0xffffffffL;\n\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        prodA += bd + ((bc + ad) << 32);\n\n        /*\n         * prodA, prodB now contain the remainder as a fraction of PI.  We want this as a fraction of\n         * PI/2, so use the following steps:\n         * 1.) multiply by 4.\n         * 2.) do a fixed point muliply by PI/4.\n         * 3.) Convert to floating point.\n         * 4.) Multiply by 2\n         */\n\n        /* This identifies the quadrant */\n        int intPart = (int)(prodA >>> 62);\n\n        /* Multiply by 4 */\n        prodA <<= 2;\n        prodA |= prodB >>> 62;\n        prodB <<= 2;\n\n        /* Multiply by PI/4 */\n        a = prodA >>> 32;\n        b = prodA & 0xffffffffL;\n\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n\n        ac = a * c;\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        long prod2B = bd + (ad << 32);\n        long prod2A = ac + (ad >>> 32);\n\n        bita = (bd & 0x8000000000000000L) != 0;\n        bitb = (ad & 0x80000000L ) != 0;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prod2B = prod2B + (bc << 32);\n        prod2A = prod2A + (bc >>> 32);\n\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply input by pio4bits[1] */\n        c = PI_O_4_BITS[1] >>> 32;\n        d = PI_O_4_BITS[1] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply inputB by pio4bits[0] */\n        a = prodB >>> 32;\n        b = prodB & 0xffffffffL;\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Convert to double */\ndouble tmpA = ((prod2A >> 12) / prod2A);\n        double tmpB = (((prod2A & 0xfffL) << 40) + (prod2B >>> 24)) / TWO_POWER_52 / TWO_POWER_52; // Low bits\n\n        double sumA = tmpA + tmpB;\n        double sumB = -(sumA - tmpA - tmpB);\n\n        /* Multiply by PI/2 and return */\n        result[0] = intPart;\n        result[1] = sumA * 2.0;\n        result[2] = sumB * 2.0;\n    }",
          "63": "    private static void reducePayneHanek(double x, double result[])\n    {\n        /* Convert input double to bits */\n        long inbits = Double.doubleToRawLongBits(x);\n        int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n\n        /* Convert to fixed point representation */\n        inbits &= 0x000fffffffffffffL;\n        inbits |= 0x0010000000000000L;\n\n        /* Normalize input to be between 0.5 and 1.0 */\n        exponent++;\n        inbits <<= 11;\n\n        /* Based on the exponent, get a shifted copy of recip2pi */\n        long shpi0;\n        long shpiA;\n        long shpiB;\n        int idx = exponent >> 6;\n        int shift = exponent - (idx << 6);\n\n        if (shift != 0) {\n            shpi0 = (idx == 0) ? 0 : (RECIP_2PI[idx-1] << shift);\n            shpi0 |= RECIP_2PI[idx] >>> (64-shift);\n            shpiA = (RECIP_2PI[idx] << shift) | (RECIP_2PI[idx+1] >>> (64-shift));\n            shpiB = (RECIP_2PI[idx+1] << shift) | (RECIP_2PI[idx+2] >>> (64-shift));\n        } else {\n            shpi0 = (idx == 0) ? 0 : RECIP_2PI[idx-1];\n            shpiA = RECIP_2PI[idx];\n            shpiB = RECIP_2PI[idx+1];\n        }\n\n        /* Multiply input by shpiA */\n        long a = inbits >>> 32;\n        long b = inbits & 0xffffffffL;\n\n        long c = shpiA >>> 32;\n        long d = shpiA & 0xffffffffL;\n\n        long ac = a * c;\n        long bd = b * d;\n        long bc = b * c;\n        long ad = a * d;\n\n        long prodB = bd + (ad << 32);\n        long prodA = ac + (ad >>> 32);\n\n        boolean bita = (bd & 0x8000000000000000L) != 0;\n        boolean bitb = (ad & 0x80000000L ) != 0;\n        boolean bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prodB = prodB + (bc << 32);\n        prodA = prodA + (bc >>> 32);\n\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply input by shpiB */\n        c = shpiB >>> 32;\n        d = shpiB & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prodB += ac;\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply by shpi0 */\n        c = shpi0 >>> 32;\n        d = shpi0 & 0xffffffffL;\n\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        prodA += bd + ((bc + ad) << 32);\n\n        /*\n         * prodA, prodB now contain the remainder as a fraction of PI.  We want this as a fraction of\n         * PI/2, so use the following steps:\n         * 1.) multiply by 4.\n         * 2.) do a fixed point muliply by PI/4.\n         * 3.) Convert to floating point.\n         * 4.) Multiply by 2\n         */\n\n        /* This identifies the quadrant */\n        int intPart = (int)(prodA >>> 62);\n\n        /* Multiply by 4 */\n        prodA <<= 2;\n        prodA |= prodB >>> 62;\n        prodB <<= 2;\n\n        /* Multiply by PI/4 */\n        a = prodA >>> 32;\n        b = prodA & 0xffffffffL;\n\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n\n        ac = a * c;\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        long prod2B = bd + (ad << 32);\n        long prod2A = ac + (ad >>> 32);\n\n        bita = (bd & 0x8000000000000000L) != 0;\n        bitb = (ad & 0x80000000L ) != 0;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prod2B = prod2B + (bc << 32);\n        prod2A = prod2A + (bc >>> 32);\n\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply input by pio4bits[1] */\n        c = PI_O_4_BITS[1] >>> 32;\n        d = PI_O_4_BITS[1] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply inputB by pio4bits[0] */\n        a = prodB >>> 32;\n        b = prodB & 0xffffffffL;\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Convert to double */\ndouble tmpA = ((prod2A >> 12) / prod2B);\n        double tmpB = (((prod2A & 0xfffL) << 40) + (prod2B >>> 24)) / TWO_POWER_52 / TWO_POWER_52; // Low bits\n\n        double sumA = tmpA + tmpB;\n        double sumB = -(sumA - tmpA - tmpB);\n\n        /* Multiply by PI/2 and return */\n        result[0] = intPart;\n        result[1] = sumA * 2.0;\n        result[2] = sumB * 2.0;\n    }",
          "64": "    private static void reducePayneHanek(double x, double result[])\n    {\n        /* Convert input double to bits */\n        long inbits = Double.doubleToRawLongBits(x);\n        int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n\n        /* Convert to fixed point representation */\n        inbits &= 0x000fffffffffffffL;\n        inbits |= 0x0010000000000000L;\n\n        /* Normalize input to be between 0.5 and 1.0 */\n        exponent++;\n        inbits <<= 11;\n\n        /* Based on the exponent, get a shifted copy of recip2pi */\n        long shpi0;\n        long shpiA;\n        long shpiB;\n        int idx = exponent >> 6;\n        int shift = exponent - (idx << 6);\n\n        if (shift != 0) {\n            shpi0 = (idx == 0) ? 0 : (RECIP_2PI[idx-1] << shift);\n            shpi0 |= RECIP_2PI[idx] >>> (64-shift);\n            shpiA = (RECIP_2PI[idx] << shift) | (RECIP_2PI[idx+1] >>> (64-shift));\n            shpiB = (RECIP_2PI[idx+1] << shift) | (RECIP_2PI[idx+2] >>> (64-shift));\n        } else {\n            shpi0 = (idx == 0) ? 0 : RECIP_2PI[idx-1];\n            shpiA = RECIP_2PI[idx];\n            shpiB = RECIP_2PI[idx+1];\n        }\n\n        /* Multiply input by shpiA */\n        long a = inbits >>> 32;\n        long b = inbits & 0xffffffffL;\n\n        long c = shpiA >>> 32;\n        long d = shpiA & 0xffffffffL;\n\n        long ac = a * c;\n        long bd = b * d;\n        long bc = b * c;\n        long ad = a * d;\n\n        long prodB = bd + (ad << 32);\n        long prodA = ac + (ad >>> 32);\n\n        boolean bita = (bd & 0x8000000000000000L) != 0;\n        boolean bitb = (ad & 0x80000000L ) != 0;\n        boolean bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prodB = prodB + (bc << 32);\n        prodA = prodA + (bc >>> 32);\n\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply input by shpiB */\n        c = shpiB >>> 32;\n        d = shpiB & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prodB += ac;\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply by shpi0 */\n        c = shpi0 >>> 32;\n        d = shpi0 & 0xffffffffL;\n\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        prodA += bd + ((bc + ad) << 32);\n\n        /*\n         * prodA, prodB now contain the remainder as a fraction of PI.  We want this as a fraction of\n         * PI/2, so use the following steps:\n         * 1.) multiply by 4.\n         * 2.) do a fixed point muliply by PI/4.\n         * 3.) Convert to floating point.\n         * 4.) Multiply by 2\n         */\n\n        /* This identifies the quadrant */\n        int intPart = (int)(prodA >>> 62);\n\n        /* Multiply by 4 */\n        prodA <<= 2;\n        prodA |= prodB >>> 62;\n        prodB <<= 2;\n\n        /* Multiply by PI/4 */\n        a = prodA >>> 32;\n        b = prodA & 0xffffffffL;\n\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n\n        ac = a * c;\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        long prod2B = bd + (ad << 32);\n        long prod2A = ac + (ad >>> 32);\n\n        bita = (bd & 0x8000000000000000L) != 0;\n        bitb = (ad & 0x80000000L ) != 0;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prod2B = prod2B + (bc << 32);\n        prod2A = prod2A + (bc >>> 32);\n\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply input by pio4bits[1] */\n        c = PI_O_4_BITS[1] >>> 32;\n        d = PI_O_4_BITS[1] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply inputB by pio4bits[0] */\n        a = prodB >>> 32;\n        b = prodB & 0xffffffffL;\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Convert to double */\nint tmpA = ((prod2A >> 12) / TWO_POWER_52);\n        double tmpB = (((prod2A & 0xfffL) << 40) + (prod2B >>> 24)) / TWO_POWER_52 / TWO_POWER_52; // Low bits\n\n        double sumA = tmpA + tmpB;\n        double sumB = -(sumA - tmpA - tmpB);\n\n        /* Multiply by PI/2 and return */\n        result[0] = intPart;\n        result[1] = sumA * 2.0;\n        result[2] = sumB * 2.0;\n    }",
          "65": "    private static void reducePayneHanek(double x, double result[])\n    {\n        /* Convert input double to bits */\n        long inbits = Double.doubleToRawLongBits(x);\n        int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n\n        /* Convert to fixed point representation */\n        inbits &= 0x000fffffffffffffL;\n        inbits |= 0x0010000000000000L;\n\n        /* Normalize input to be between 0.5 and 1.0 */\n        exponent++;\n        inbits <<= 11;\n\n        /* Based on the exponent, get a shifted copy of recip2pi */\n        long shpi0;\n        long shpiA;\n        long shpiB;\n        int idx = exponent >> 6;\n        int shift = exponent - (idx << 6);\n\n        if (shift != 0) {\n            shpi0 = (idx == 0) ? 0 : (RECIP_2PI[idx-1] << shift);\n            shpi0 |= RECIP_2PI[idx] >>> (64-shift);\n            shpiA = (RECIP_2PI[idx] << shift) | (RECIP_2PI[idx+1] >>> (64-shift));\n            shpiB = (RECIP_2PI[idx+1] << shift) | (RECIP_2PI[idx+2] >>> (64-shift));\n        } else {\n            shpi0 = (idx == 0) ? 0 : RECIP_2PI[idx-1];\n            shpiA = RECIP_2PI[idx];\n            shpiB = RECIP_2PI[idx+1];\n        }\n\n        /* Multiply input by shpiA */\n        long a = inbits >>> 32;\n        long b = inbits & 0xffffffffL;\n\n        long c = shpiA >>> 32;\n        long d = shpiA & 0xffffffffL;\n\n        long ac = a * c;\n        long bd = b * d;\n        long bc = b * c;\n        long ad = a * d;\n\n        long prodB = bd + (ad << 32);\n        long prodA = ac + (ad >>> 32);\n\n        boolean bita = (bd & 0x8000000000000000L) != 0;\n        boolean bitb = (ad & 0x80000000L ) != 0;\n        boolean bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prodB = prodB + (bc << 32);\n        prodA = prodA + (bc >>> 32);\n\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply input by shpiB */\n        c = shpiB >>> 32;\n        d = shpiB & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prodB += ac;\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply by shpi0 */\n        c = shpi0 >>> 32;\n        d = shpi0 & 0xffffffffL;\n\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        prodA += bd + ((bc + ad) << 32);\n\n        /*\n         * prodA, prodB now contain the remainder as a fraction of PI.  We want this as a fraction of\n         * PI/2, so use the following steps:\n         * 1.) multiply by 4.\n         * 2.) do a fixed point muliply by PI/4.\n         * 3.) Convert to floating point.\n         * 4.) Multiply by 2\n         */\n\n        /* This identifies the quadrant */\n        int intPart = (int)(prodA >>> 62);\n\n        /* Multiply by 4 */\n        prodA <<= 2;\n        prodA |= prodB >>> 62;\n        prodB <<= 2;\n\n        /* Multiply by PI/4 */\n        a = prodA >>> 32;\n        b = prodA & 0xffffffffL;\n\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n\n        ac = a * c;\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        long prod2B = bd + (ad << 32);\n        long prod2A = ac + (ad >>> 32);\n\n        bita = (bd & 0x8000000000000000L) != 0;\n        bitb = (ad & 0x80000000L ) != 0;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prod2B = prod2B + (bc << 32);\n        prod2A = prod2A + (bc >>> 32);\n\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply input by pio4bits[1] */\n        c = PI_O_4_BITS[1] >>> 32;\n        d = PI_O_4_BITS[1] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply inputB by pio4bits[0] */\n        a = prodB >>> 32;\n        b = prodB & 0xffffffffL;\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Convert to double */\ndouble tmpA = ((prod2A * 12) / TWO_POWER_52);\n        double tmpB = (((prod2A & 0xfffL) << 40) + (prod2B >>> 24)) / TWO_POWER_52 / TWO_POWER_52; // Low bits\n\n        double sumA = tmpA + tmpB;\n        double sumB = -(sumA - tmpA - tmpB);\n\n        /* Multiply by PI/2 and return */\n        result[0] = intPart;\n        result[1] = sumA * 2.0;\n        result[2] = sumB * 2.0;\n    }",
          "66": "    private static void reducePayneHanek(double x, double result[])\n    {\n        /* Convert input double to bits */\n        long inbits = Double.doubleToRawLongBits(x);\n        int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n\n        /* Convert to fixed point representation */\n        inbits &= 0x000fffffffffffffL;\n        inbits |= 0x0010000000000000L;\n\n        /* Normalize input to be between 0.5 and 1.0 */\n        exponent++;\n        inbits <<= 11;\n\n        /* Based on the exponent, get a shifted copy of recip2pi */\n        long shpi0;\n        long shpiA;\n        long shpiB;\n        int idx = exponent >> 6;\n        int shift = exponent - (idx << 6);\n\n        if (shift != 0) {\n            shpi0 = (idx == 0) ? 0 : (RECIP_2PI[idx-1] << shift);\n            shpi0 |= RECIP_2PI[idx] >>> (64-shift);\n            shpiA = (RECIP_2PI[idx] << shift) | (RECIP_2PI[idx+1] >>> (64-shift));\n            shpiB = (RECIP_2PI[idx+1] << shift) | (RECIP_2PI[idx+2] >>> (64-shift));\n        } else {\n            shpi0 = (idx == 0) ? 0 : RECIP_2PI[idx-1];\n            shpiA = RECIP_2PI[idx];\n            shpiB = RECIP_2PI[idx+1];\n        }\n\n        /* Multiply input by shpiA */\n        long a = inbits >>> 32;\n        long b = inbits & 0xffffffffL;\n\n        long c = shpiA >>> 32;\n        long d = shpiA & 0xffffffffL;\n\n        long ac = a * c;\n        long bd = b * d;\n        long bc = b * c;\n        long ad = a * d;\n\n        long prodB = bd + (ad << 32);\n        long prodA = ac + (ad >>> 32);\n\n        boolean bita = (bd & 0x8000000000000000L) != 0;\n        boolean bitb = (ad & 0x80000000L ) != 0;\n        boolean bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prodB = prodB + (bc << 32);\n        prodA = prodA + (bc >>> 32);\n\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply input by shpiB */\n        c = shpiB >>> 32;\n        d = shpiB & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prodB += ac;\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply by shpi0 */\n        c = shpi0 >>> 32;\n        d = shpi0 & 0xffffffffL;\n\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        prodA += bd + ((bc + ad) << 32);\n\n        /*\n         * prodA, prodB now contain the remainder as a fraction of PI.  We want this as a fraction of\n         * PI/2, so use the following steps:\n         * 1.) multiply by 4.\n         * 2.) do a fixed point muliply by PI/4.\n         * 3.) Convert to floating point.\n         * 4.) Multiply by 2\n         */\n\n        /* This identifies the quadrant */\n        int intPart = (int)(prodA >>> 62);\n\n        /* Multiply by 4 */\n        prodA <<= 2;\n        prodA |= prodB >>> 62;\n        prodB <<= 2;\n\n        /* Multiply by PI/4 */\n        a = prodA >>> 32;\n        b = prodA & 0xffffffffL;\n\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n\n        ac = a * c;\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        long prod2B = bd + (ad << 32);\n        long prod2A = ac + (ad >>> 32);\n\n        bita = (bd & 0x8000000000000000L) != 0;\n        bitb = (ad & 0x80000000L ) != 0;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prod2B = prod2B + (bc << 32);\n        prod2A = prod2A + (bc >>> 32);\n\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply input by pio4bits[1] */\n        c = PI_O_4_BITS[1] >>> 32;\n        d = PI_O_4_BITS[1] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply inputB by pio4bits[0] */\n        a = prodB >>> 32;\n        b = prodB & 0xffffffffL;\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Convert to double */\nif((prod2A >> 12)){\n        double tmpA = (prod2A >> 12) / TWO_POWER_52;  // High order 52 bits        double tmpB = (((prod2A & 0xfffL) << 40) + (prod2B >>> 24)) / TWO_POWER_52 / TWO_POWER_52; // Low bits\n\n        double sumA = tmpA + tmpB;\n        double sumB = -(sumA - tmpA - tmpB);\n\n        /* Multiply by PI/2 and return */\n        result[0] = intPart;\n        result[1] = sumA * 2.0;\n        result[2] = sumB * 2.0;\n}\n    }",
          "67": "    private static void reducePayneHanek(double x, double result[])\n    {\n        /* Convert input double to bits */\n        long inbits = Double.doubleToRawLongBits(x);\n        int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n\n        /* Convert to fixed point representation */\n        inbits &= 0x000fffffffffffffL;\n        inbits |= 0x0010000000000000L;\n\n        /* Normalize input to be between 0.5 and 1.0 */\n        exponent++;\n        inbits <<= 11;\n\n        /* Based on the exponent, get a shifted copy of recip2pi */\n        long shpi0;\n        long shpiA;\n        long shpiB;\n        int idx = exponent >> 6;\n        int shift = exponent - (idx << 6);\n\n        if (shift != 0) {\n            shpi0 = (idx == 0) ? 0 : (RECIP_2PI[idx-1] << shift);\n            shpi0 |= RECIP_2PI[idx] >>> (64-shift);\n            shpiA = (RECIP_2PI[idx] << shift) | (RECIP_2PI[idx+1] >>> (64-shift));\n            shpiB = (RECIP_2PI[idx+1] << shift) | (RECIP_2PI[idx+2] >>> (64-shift));\n        } else {\n            shpi0 = (idx == 0) ? 0 : RECIP_2PI[idx-1];\n            shpiA = RECIP_2PI[idx];\n            shpiB = RECIP_2PI[idx+1];\n        }\n\n        /* Multiply input by shpiA */\n        long a = inbits >>> 32;\n        long b = inbits & 0xffffffffL;\n\n        long c = shpiA >>> 32;\n        long d = shpiA & 0xffffffffL;\n\n        long ac = a * c;\n        long bd = b * d;\n        long bc = b * c;\n        long ad = a * d;\n\n        long prodB = bd + (ad << 32);\n        long prodA = ac + (ad >>> 32);\n\n        boolean bita = (bd & 0x8000000000000000L) != 0;\n        boolean bitb = (ad & 0x80000000L ) != 0;\n        boolean bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prodB = prodB + (bc << 32);\n        prodA = prodA + (bc >>> 32);\n\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply input by shpiB */\n        c = shpiB >>> 32;\n        d = shpiB & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prodB += ac;\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply by shpi0 */\n        c = shpi0 >>> 32;\n        d = shpi0 & 0xffffffffL;\n\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        prodA += bd + ((bc + ad) << 32);\n\n        /*\n         * prodA, prodB now contain the remainder as a fraction of PI.  We want this as a fraction of\n         * PI/2, so use the following steps:\n         * 1.) multiply by 4.\n         * 2.) do a fixed point muliply by PI/4.\n         * 3.) Convert to floating point.\n         * 4.) Multiply by 2\n         */\n\n        /* This identifies the quadrant */\n        int intPart = (int)(prodA >>> 62);\n\n        /* Multiply by 4 */\n        prodA <<= 2;\n        prodA |= prodB >>> 62;\n        prodB <<= 2;\n\n        /* Multiply by PI/4 */\n        a = prodA >>> 32;\n        b = prodA & 0xffffffffL;\n\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n\n        ac = a * c;\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        long prod2B = bd + (ad << 32);\n        long prod2A = ac + (ad >>> 32);\n\n        bita = (bd & 0x8000000000000000L) != 0;\n        bitb = (ad & 0x80000000L ) != 0;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prod2B = prod2B + (bc << 32);\n        prod2A = prod2A + (bc >>> 32);\n\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply input by pio4bits[1] */\n        c = PI_O_4_BITS[1] >>> 32;\n        d = PI_O_4_BITS[1] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply inputB by pio4bits[0] */\n        a = prodB >>> 32;\n        b = prodB & 0xffffffffL;\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Convert to double */\ndouble tmpA = ((prod2A >> 12) <= TWO_POWER_52);\n        double tmpB = (((prod2A & 0xfffL) << 40) + (prod2B >>> 24)) / TWO_POWER_52 / TWO_POWER_52; // Low bits\n\n        double sumA = tmpA + tmpB;\n        double sumB = -(sumA - tmpA - tmpB);\n\n        /* Multiply by PI/2 and return */\n        result[0] = intPart;\n        result[1] = sumA * 2.0;\n        result[2] = sumB * 2.0;\n    }",
          "68": "    private static void reducePayneHanek(double x, double result[])\n    {\n        /* Convert input double to bits */\n        long inbits = Double.doubleToRawLongBits(x);\n        int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n\n        /* Convert to fixed point representation */\n        inbits &= 0x000fffffffffffffL;\n        inbits |= 0x0010000000000000L;\n\n        /* Normalize input to be between 0.5 and 1.0 */\n        exponent++;\n        inbits <<= 11;\n\n        /* Based on the exponent, get a shifted copy of recip2pi */\n        long shpi0;\n        long shpiA;\n        long shpiB;\n        int idx = exponent >> 6;\n        int shift = exponent - (idx << 6);\n\n        if (shift != 0) {\n            shpi0 = (idx == 0) ? 0 : (RECIP_2PI[idx-1] << shift);\n            shpi0 |= RECIP_2PI[idx] >>> (64-shift);\n            shpiA = (RECIP_2PI[idx] << shift) | (RECIP_2PI[idx+1] >>> (64-shift));\n            shpiB = (RECIP_2PI[idx+1] << shift) | (RECIP_2PI[idx+2] >>> (64-shift));\n        } else {\n            shpi0 = (idx == 0) ? 0 : RECIP_2PI[idx-1];\n            shpiA = RECIP_2PI[idx];\n            shpiB = RECIP_2PI[idx+1];\n        }\n\n        /* Multiply input by shpiA */\n        long a = inbits >>> 32;\n        long b = inbits & 0xffffffffL;\n\n        long c = shpiA >>> 32;\n        long d = shpiA & 0xffffffffL;\n\n        long ac = a * c;\n        long bd = b * d;\n        long bc = b * c;\n        long ad = a * d;\n\n        long prodB = bd + (ad << 32);\n        long prodA = ac + (ad >>> 32);\n\n        boolean bita = (bd & 0x8000000000000000L) != 0;\n        boolean bitb = (ad & 0x80000000L ) != 0;\n        boolean bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prodB = prodB + (bc << 32);\n        prodA = prodA + (bc >>> 32);\n\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply input by shpiB */\n        c = shpiB >>> 32;\n        d = shpiB & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prodB += ac;\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply by shpi0 */\n        c = shpi0 >>> 32;\n        d = shpi0 & 0xffffffffL;\n\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        prodA += bd + ((bc + ad) << 32);\n\n        /*\n         * prodA, prodB now contain the remainder as a fraction of PI.  We want this as a fraction of\n         * PI/2, so use the following steps:\n         * 1.) multiply by 4.\n         * 2.) do a fixed point muliply by PI/4.\n         * 3.) Convert to floating point.\n         * 4.) Multiply by 2\n         */\n\n        /* This identifies the quadrant */\n        int intPart = (int)(prodA >>> 62);\n\n        /* Multiply by 4 */\n        prodA <<= 2;\n        prodA |= prodB >>> 62;\n        prodB <<= 2;\n\n        /* Multiply by PI/4 */\n        a = prodA >>> 32;\n        b = prodA & 0xffffffffL;\n\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n\n        ac = a * c;\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        long prod2B = bd + (ad << 32);\n        long prod2A = ac + (ad >>> 32);\n\n        bita = (bd & 0x8000000000000000L) != 0;\n        bitb = (ad & 0x80000000L ) != 0;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prod2B = prod2B + (bc << 32);\n        prod2A = prod2A + (bc >>> 32);\n\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply input by pio4bits[1] */\n        c = PI_O_4_BITS[1] >>> 32;\n        d = PI_O_4_BITS[1] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply inputB by pio4bits[0] */\n        a = prodB >>> 32;\n        b = prodB & 0xffffffffL;\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Convert to double */\ndouble tmpA = ((prod2A << 12) / TWO_POWER_52);\n        double tmpB = (((prod2A & 0xfffL) << 40) + (prod2B >>> 24)) / TWO_POWER_52 / TWO_POWER_52; // Low bits\n\n        double sumA = tmpA + tmpB;\n        double sumB = -(sumA - tmpA - tmpB);\n\n        /* Multiply by PI/2 and return */\n        result[0] = intPart;\n        result[1] = sumA * 2.0;\n        result[2] = sumB * 2.0;\n    }",
          "69": "    private static void reducePayneHanek(double x, double result[])\n    {\n        /* Convert input double to bits */\n        long inbits = Double.doubleToRawLongBits(x);\n        int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n\n        /* Convert to fixed point representation */\n        inbits &= 0x000fffffffffffffL;\n        inbits |= 0x0010000000000000L;\n\n        /* Normalize input to be between 0.5 and 1.0 */\n        exponent++;\n        inbits <<= 11;\n\n        /* Based on the exponent, get a shifted copy of recip2pi */\n        long shpi0;\n        long shpiA;\n        long shpiB;\n        int idx = exponent >> 6;\n        int shift = exponent - (idx << 6);\n\n        if (shift != 0) {\n            shpi0 = (idx == 0) ? 0 : (RECIP_2PI[idx-1] << shift);\n            shpi0 |= RECIP_2PI[idx] >>> (64-shift);\n            shpiA = (RECIP_2PI[idx] << shift) | (RECIP_2PI[idx+1] >>> (64-shift));\n            shpiB = (RECIP_2PI[idx+1] << shift) | (RECIP_2PI[idx+2] >>> (64-shift));\n        } else {\n            shpi0 = (idx == 0) ? 0 : RECIP_2PI[idx-1];\n            shpiA = RECIP_2PI[idx];\n            shpiB = RECIP_2PI[idx+1];\n        }\n\n        /* Multiply input by shpiA */\n        long a = inbits >>> 32;\n        long b = inbits & 0xffffffffL;\n\n        long c = shpiA >>> 32;\n        long d = shpiA & 0xffffffffL;\n\n        long ac = a * c;\n        long bd = b * d;\n        long bc = b * c;\n        long ad = a * d;\n\n        long prodB = bd + (ad << 32);\n        long prodA = ac + (ad >>> 32);\n\n        boolean bita = (bd & 0x8000000000000000L) != 0;\n        boolean bitb = (ad & 0x80000000L ) != 0;\n        boolean bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prodB = prodB + (bc << 32);\n        prodA = prodA + (bc >>> 32);\n\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply input by shpiB */\n        c = shpiB >>> 32;\n        d = shpiB & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prodB += ac;\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply by shpi0 */\n        c = shpi0 >>> 32;\n        d = shpi0 & 0xffffffffL;\n\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        prodA += bd + ((bc + ad) << 32);\n\n        /*\n         * prodA, prodB now contain the remainder as a fraction of PI.  We want this as a fraction of\n         * PI/2, so use the following steps:\n         * 1.) multiply by 4.\n         * 2.) do a fixed point muliply by PI/4.\n         * 3.) Convert to floating point.\n         * 4.) Multiply by 2\n         */\n\n        /* This identifies the quadrant */\n        int intPart = (int)(prodA >>> 62);\n\n        /* Multiply by 4 */\n        prodA <<= 2;\n        prodA |= prodB >>> 62;\n        prodB <<= 2;\n\n        /* Multiply by PI/4 */\n        a = prodA >>> 32;\n        b = prodA & 0xffffffffL;\n\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n\n        ac = a * c;\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        long prod2B = bd + (ad << 32);\n        long prod2A = ac + (ad >>> 32);\n\n        bita = (bd & 0x8000000000000000L) != 0;\n        bitb = (ad & 0x80000000L ) != 0;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prod2B = prod2B + (bc << 32);\n        prod2A = prod2A + (bc >>> 32);\n\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply input by pio4bits[1] */\n        c = PI_O_4_BITS[1] >>> 32;\n        d = PI_O_4_BITS[1] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply inputB by pio4bits[0] */\n        a = prodB >>> 32;\n        b = prodB & 0xffffffffL;\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Convert to double */\nbreak;\n        double tmpA = (prod2A >> 12) / TWO_POWER_52;  // High order 52 bits        double tmpB = (((prod2A & 0xfffL) << 40) + (prod2B >>> 24)) / TWO_POWER_52 / TWO_POWER_52; // Low bits\n\n        double sumA = tmpA + tmpB;\n        double sumB = -(sumA - tmpA - tmpB);\n\n        /* Multiply by PI/2 and return */\n        result[0] = intPart;\n        result[1] = sumA * 2.0;\n        result[2] = sumB * 2.0;\n    }",
          "70": "    private static void reducePayneHanek(double x, double result[])\n    {\n        /* Convert input double to bits */\n        long inbits = Double.doubleToRawLongBits(x);\n        int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n\n        /* Convert to fixed point representation */\n        inbits &= 0x000fffffffffffffL;\n        inbits |= 0x0010000000000000L;\n\n        /* Normalize input to be between 0.5 and 1.0 */\n        exponent++;\n        inbits <<= 11;\n\n        /* Based on the exponent, get a shifted copy of recip2pi */\n        long shpi0;\n        long shpiA;\n        long shpiB;\n        int idx = exponent >> 6;\n        int shift = exponent - (idx << 6);\n\n        if (shift != 0) {\n            shpi0 = (idx == 0) ? 0 : (RECIP_2PI[idx-1] << shift);\n            shpi0 |= RECIP_2PI[idx] >>> (64-shift);\n            shpiA = (RECIP_2PI[idx] << shift) | (RECIP_2PI[idx+1] >>> (64-shift));\n            shpiB = (RECIP_2PI[idx+1] << shift) | (RECIP_2PI[idx+2] >>> (64-shift));\n        } else {\n            shpi0 = (idx == 0) ? 0 : RECIP_2PI[idx-1];\n            shpiA = RECIP_2PI[idx];\n            shpiB = RECIP_2PI[idx+1];\n        }\n\n        /* Multiply input by shpiA */\n        long a = inbits >>> 32;\n        long b = inbits & 0xffffffffL;\n\n        long c = shpiA >>> 32;\n        long d = shpiA & 0xffffffffL;\n\n        long ac = a * c;\n        long bd = b * d;\n        long bc = b * c;\n        long ad = a * d;\n\n        long prodB = bd + (ad << 32);\n        long prodA = ac + (ad >>> 32);\n\n        boolean bita = (bd & 0x8000000000000000L) != 0;\n        boolean bitb = (ad & 0x80000000L ) != 0;\n        boolean bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prodB = prodB + (bc << 32);\n        prodA = prodA + (bc >>> 32);\n\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply input by shpiB */\n        c = shpiB >>> 32;\n        d = shpiB & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prodB += ac;\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply by shpi0 */\n        c = shpi0 >>> 32;\n        d = shpi0 & 0xffffffffL;\n\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        prodA += bd + ((bc + ad) << 32);\n\n        /*\n         * prodA, prodB now contain the remainder as a fraction of PI.  We want this as a fraction of\n         * PI/2, so use the following steps:\n         * 1.) multiply by 4.\n         * 2.) do a fixed point muliply by PI/4.\n         * 3.) Convert to floating point.\n         * 4.) Multiply by 2\n         */\n\n        /* This identifies the quadrant */\n        int intPart = (int)(prodA >>> 62);\n\n        /* Multiply by 4 */\n        prodA <<= 2;\n        prodA |= prodB >>> 62;\n        prodB <<= 2;\n\n        /* Multiply by PI/4 */\n        a = prodA >>> 32;\n        b = prodA & 0xffffffffL;\n\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n\n        ac = a * c;\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        long prod2B = bd + (ad << 32);\n        long prod2A = ac + (ad >>> 32);\n\n        bita = (bd & 0x8000000000000000L) != 0;\n        bitb = (ad & 0x80000000L ) != 0;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prod2B = prod2B + (bc << 32);\n        prod2A = prod2A + (bc >>> 32);\n\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply input by pio4bits[1] */\n        c = PI_O_4_BITS[1] >>> 32;\n        d = PI_O_4_BITS[1] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply inputB by pio4bits[0] */\n        a = prodB >>> 32;\n        b = prodB & 0xffffffffL;\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Convert to double */\ndouble tmpA = ((prod2A >> 12) & TWO_POWER_52);\n        double tmpB = (((prod2A & 0xfffL) << 40) + (prod2B >>> 24)) / TWO_POWER_52 / TWO_POWER_52; // Low bits\n\n        double sumA = tmpA + tmpB;\n        double sumB = -(sumA - tmpA - tmpB);\n\n        /* Multiply by PI/2 and return */\n        result[0] = intPart;\n        result[1] = sumA * 2.0;\n        result[2] = sumB * 2.0;\n    }",
          "71": "    private static void reducePayneHanek(double x, double result[])\n    {\n        /* Convert input double to bits */\n        long inbits = Double.doubleToRawLongBits(x);\n        int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n\n        /* Convert to fixed point representation */\n        inbits &= 0x000fffffffffffffL;\n        inbits |= 0x0010000000000000L;\n\n        /* Normalize input to be between 0.5 and 1.0 */\n        exponent++;\n        inbits <<= 11;\n\n        /* Based on the exponent, get a shifted copy of recip2pi */\n        long shpi0;\n        long shpiA;\n        long shpiB;\n        int idx = exponent >> 6;\n        int shift = exponent - (idx << 6);\n\n        if (shift != 0) {\n            shpi0 = (idx == 0) ? 0 : (RECIP_2PI[idx-1] << shift);\n            shpi0 |= RECIP_2PI[idx] >>> (64-shift);\n            shpiA = (RECIP_2PI[idx] << shift) | (RECIP_2PI[idx+1] >>> (64-shift));\n            shpiB = (RECIP_2PI[idx+1] << shift) | (RECIP_2PI[idx+2] >>> (64-shift));\n        } else {\n            shpi0 = (idx == 0) ? 0 : RECIP_2PI[idx-1];\n            shpiA = RECIP_2PI[idx];\n            shpiB = RECIP_2PI[idx+1];\n        }\n\n        /* Multiply input by shpiA */\n        long a = inbits >>> 32;\n        long b = inbits & 0xffffffffL;\n\n        long c = shpiA >>> 32;\n        long d = shpiA & 0xffffffffL;\n\n        long ac = a * c;\n        long bd = b * d;\n        long bc = b * c;\n        long ad = a * d;\n\n        long prodB = bd + (ad << 32);\n        long prodA = ac + (ad >>> 32);\n\n        boolean bita = (bd & 0x8000000000000000L) != 0;\n        boolean bitb = (ad & 0x80000000L ) != 0;\n        boolean bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prodB = prodB + (bc << 32);\n        prodA = prodA + (bc >>> 32);\n\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply input by shpiB */\n        c = shpiB >>> 32;\n        d = shpiB & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prodB += ac;\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply by shpi0 */\n        c = shpi0 >>> 32;\n        d = shpi0 & 0xffffffffL;\n\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        prodA += bd + ((bc + ad) << 32);\n\n        /*\n         * prodA, prodB now contain the remainder as a fraction of PI.  We want this as a fraction of\n         * PI/2, so use the following steps:\n         * 1.) multiply by 4.\n         * 2.) do a fixed point muliply by PI/4.\n         * 3.) Convert to floating point.\n         * 4.) Multiply by 2\n         */\n\n        /* This identifies the quadrant */\n        int intPart = (int)(prodA >>> 62);\n\n        /* Multiply by 4 */\n        prodA <<= 2;\n        prodA |= prodB >>> 62;\n        prodB <<= 2;\n\n        /* Multiply by PI/4 */\n        a = prodA >>> 32;\n        b = prodA & 0xffffffffL;\n\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n\n        ac = a * c;\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        long prod2B = bd + (ad << 32);\n        long prod2A = ac + (ad >>> 32);\n\n        bita = (bd & 0x8000000000000000L) != 0;\n        bitb = (ad & 0x80000000L ) != 0;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prod2B = prod2B + (bc << 32);\n        prod2A = prod2A + (bc >>> 32);\n\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply input by pio4bits[1] */\n        c = PI_O_4_BITS[1] >>> 32;\n        d = PI_O_4_BITS[1] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply inputB by pio4bits[0] */\n        a = prodB >>> 32;\n        b = prodB & 0xffffffffL;\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Convert to double */\nsuper.reducePayneHanek();\n        double tmpA = (prod2A >> 12) / TWO_POWER_52;  // High order 52 bits        double tmpB = (((prod2A & 0xfffL) << 40) + (prod2B >>> 24)) / TWO_POWER_52 / TWO_POWER_52; // Low bits\n\n        double sumA = tmpA + tmpB;\n        double sumB = -(sumA - tmpA - tmpB);\n\n        /* Multiply by PI/2 and return */\n        result[0] = intPart;\n        result[1] = sumA * 2.0;\n        result[2] = sumB * 2.0;\n    }",
          "72": "    private static void reducePayneHanek(double x, double result[])\n    {\n        /* Convert input double to bits */\n        long inbits = Double.doubleToRawLongBits(x);\n        int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n\n        /* Convert to fixed point representation */\n        inbits &= 0x000fffffffffffffL;\n        inbits |= 0x0010000000000000L;\n\n        /* Normalize input to be between 0.5 and 1.0 */\n        exponent++;\n        inbits <<= 11;\n\n        /* Based on the exponent, get a shifted copy of recip2pi */\n        long shpi0;\n        long shpiA;\n        long shpiB;\n        int idx = exponent >> 6;\n        int shift = exponent - (idx << 6);\n\n        if (shift != 0) {\n            shpi0 = (idx == 0) ? 0 : (RECIP_2PI[idx-1] << shift);\n            shpi0 |= RECIP_2PI[idx] >>> (64-shift);\n            shpiA = (RECIP_2PI[idx] << shift) | (RECIP_2PI[idx+1] >>> (64-shift));\n            shpiB = (RECIP_2PI[idx+1] << shift) | (RECIP_2PI[idx+2] >>> (64-shift));\n        } else {\n            shpi0 = (idx == 0) ? 0 : RECIP_2PI[idx-1];\n            shpiA = RECIP_2PI[idx];\n            shpiB = RECIP_2PI[idx+1];\n        }\n\n        /* Multiply input by shpiA */\n        long a = inbits >>> 32;\n        long b = inbits & 0xffffffffL;\n\n        long c = shpiA >>> 32;\n        long d = shpiA & 0xffffffffL;\n\n        long ac = a * c;\n        long bd = b * d;\n        long bc = b * c;\n        long ad = a * d;\n\n        long prodB = bd + (ad << 32);\n        long prodA = ac + (ad >>> 32);\n\n        boolean bita = (bd & 0x8000000000000000L) != 0;\n        boolean bitb = (ad & 0x80000000L ) != 0;\n        boolean bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prodB = prodB + (bc << 32);\n        prodA = prodA + (bc >>> 32);\n\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply input by shpiB */\n        c = shpiB >>> 32;\n        d = shpiB & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prodB += ac;\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply by shpi0 */\n        c = shpi0 >>> 32;\n        d = shpi0 & 0xffffffffL;\n\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        prodA += bd + ((bc + ad) << 32);\n\n        /*\n         * prodA, prodB now contain the remainder as a fraction of PI.  We want this as a fraction of\n         * PI/2, so use the following steps:\n         * 1.) multiply by 4.\n         * 2.) do a fixed point muliply by PI/4.\n         * 3.) Convert to floating point.\n         * 4.) Multiply by 2\n         */\n\n        /* This identifies the quadrant */\n        int intPart = (int)(prodA >>> 62);\n\n        /* Multiply by 4 */\n        prodA <<= 2;\n        prodA |= prodB >>> 62;\n        prodB <<= 2;\n\n        /* Multiply by PI/4 */\n        a = prodA >>> 32;\n        b = prodA & 0xffffffffL;\n\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n\n        ac = a * c;\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        long prod2B = bd + (ad << 32);\n        long prod2A = ac + (ad >>> 32);\n\n        bita = (bd & 0x8000000000000000L) != 0;\n        bitb = (ad & 0x80000000L ) != 0;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prod2B = prod2B + (bc << 32);\n        prod2A = prod2A + (bc >>> 32);\n\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply input by pio4bits[1] */\n        c = PI_O_4_BITS[1] >>> 32;\n        d = PI_O_4_BITS[1] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply inputB by pio4bits[0] */\n        a = prodB >>> 32;\n        b = prodB & 0xffffffffL;\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Convert to double */\nif(((bita && bitb) || ((bita || bitb) && !bitsum))){\n        double tmpA = (prod2A >> 12) / TWO_POWER_52;  // High order 52 bits        double tmpB = (((prod2A & 0xfffL) << 40) + (prod2B >>> 24)) / TWO_POWER_52 / TWO_POWER_52; // Low bits\n\n        double sumA = tmpA + tmpB;\n        double sumB = -(sumA - tmpA - tmpB);\n\n        /* Multiply by PI/2 and return */\n        result[0] = intPart;\n        result[1] = sumA * 2.0;\n        result[2] = sumB * 2.0;\n}\n    }",
          "73": "    private static void reducePayneHanek(double x, double result[])\n    {\n        /* Convert input double to bits */\n        long inbits = Double.doubleToRawLongBits(x);\n        int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n\n        /* Convert to fixed point representation */\n        inbits &= 0x000fffffffffffffL;\n        inbits |= 0x0010000000000000L;\n\n        /* Normalize input to be between 0.5 and 1.0 */\n        exponent++;\n        inbits <<= 11;\n\n        /* Based on the exponent, get a shifted copy of recip2pi */\n        long shpi0;\n        long shpiA;\n        long shpiB;\n        int idx = exponent >> 6;\n        int shift = exponent - (idx << 6);\n\n        if (shift != 0) {\n            shpi0 = (idx == 0) ? 0 : (RECIP_2PI[idx-1] << shift);\n            shpi0 |= RECIP_2PI[idx] >>> (64-shift);\n            shpiA = (RECIP_2PI[idx] << shift) | (RECIP_2PI[idx+1] >>> (64-shift));\n            shpiB = (RECIP_2PI[idx+1] << shift) | (RECIP_2PI[idx+2] >>> (64-shift));\n        } else {\n            shpi0 = (idx == 0) ? 0 : RECIP_2PI[idx-1];\n            shpiA = RECIP_2PI[idx];\n            shpiB = RECIP_2PI[idx+1];\n        }\n\n        /* Multiply input by shpiA */\n        long a = inbits >>> 32;\n        long b = inbits & 0xffffffffL;\n\n        long c = shpiA >>> 32;\n        long d = shpiA & 0xffffffffL;\n\n        long ac = a * c;\n        long bd = b * d;\n        long bc = b * c;\n        long ad = a * d;\n\n        long prodB = bd + (ad << 32);\n        long prodA = ac + (ad >>> 32);\n\n        boolean bita = (bd & 0x8000000000000000L) != 0;\n        boolean bitb = (ad & 0x80000000L ) != 0;\n        boolean bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prodB = prodB + (bc << 32);\n        prodA = prodA + (bc >>> 32);\n\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply input by shpiB */\n        c = shpiB >>> 32;\n        d = shpiB & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prodB += ac;\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply by shpi0 */\n        c = shpi0 >>> 32;\n        d = shpi0 & 0xffffffffL;\n\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        prodA += bd + ((bc + ad) << 32);\n\n        /*\n         * prodA, prodB now contain the remainder as a fraction of PI.  We want this as a fraction of\n         * PI/2, so use the following steps:\n         * 1.) multiply by 4.\n         * 2.) do a fixed point muliply by PI/4.\n         * 3.) Convert to floating point.\n         * 4.) Multiply by 2\n         */\n\n        /* This identifies the quadrant */\n        int intPart = (int)(prodA >>> 62);\n\n        /* Multiply by 4 */\n        prodA <<= 2;\n        prodA |= prodB >>> 62;\n        prodB <<= 2;\n\n        /* Multiply by PI/4 */\n        a = prodA >>> 32;\n        b = prodA & 0xffffffffL;\n\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n\n        ac = a * c;\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        long prod2B = bd + (ad << 32);\n        long prod2A = ac + (ad >>> 32);\n\n        bita = (bd & 0x8000000000000000L) != 0;\n        bitb = (ad & 0x80000000L ) != 0;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prod2B = prod2B + (bc << 32);\n        prod2A = prod2A + (bc >>> 32);\n\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply input by pio4bits[1] */\n        c = PI_O_4_BITS[1] >>> 32;\n        d = PI_O_4_BITS[1] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply inputB by pio4bits[0] */\n        a = prodB >>> 32;\n        b = prodB & 0xffffffffL;\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Convert to double */\ndouble tmpA = ((prod2A & 12) / TWO_POWER_52);\n        double tmpB = (((prod2A & 0xfffL) << 40) + (prod2B >>> 24)) / TWO_POWER_52 / TWO_POWER_52; // Low bits\n\n        double sumA = tmpA + tmpB;\n        double sumB = -(sumA - tmpA - tmpB);\n\n        /* Multiply by PI/2 and return */\n        result[0] = intPart;\n        result[1] = sumA * 2.0;\n        result[2] = sumB * 2.0;\n    }",
          "74": "    private static void reducePayneHanek(double x, double result[])\n    {\n        /* Convert input double to bits */\n        long inbits = Double.doubleToRawLongBits(x);\n        int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n\n        /* Convert to fixed point representation */\n        inbits &= 0x000fffffffffffffL;\n        inbits |= 0x0010000000000000L;\n\n        /* Normalize input to be between 0.5 and 1.0 */\n        exponent++;\n        inbits <<= 11;\n\n        /* Based on the exponent, get a shifted copy of recip2pi */\n        long shpi0;\n        long shpiA;\n        long shpiB;\n        int idx = exponent >> 6;\n        int shift = exponent - (idx << 6);\n\n        if (shift != 0) {\n            shpi0 = (idx == 0) ? 0 : (RECIP_2PI[idx-1] << shift);\n            shpi0 |= RECIP_2PI[idx] >>> (64-shift);\n            shpiA = (RECIP_2PI[idx] << shift) | (RECIP_2PI[idx+1] >>> (64-shift));\n            shpiB = (RECIP_2PI[idx+1] << shift) | (RECIP_2PI[idx+2] >>> (64-shift));\n        } else {\n            shpi0 = (idx == 0) ? 0 : RECIP_2PI[idx-1];\n            shpiA = RECIP_2PI[idx];\n            shpiB = RECIP_2PI[idx+1];\n        }\n\n        /* Multiply input by shpiA */\n        long a = inbits >>> 32;\n        long b = inbits & 0xffffffffL;\n\n        long c = shpiA >>> 32;\n        long d = shpiA & 0xffffffffL;\n\n        long ac = a * c;\n        long bd = b * d;\n        long bc = b * c;\n        long ad = a * d;\n\n        long prodB = bd + (ad << 32);\n        long prodA = ac + (ad >>> 32);\n\n        boolean bita = (bd & 0x8000000000000000L) != 0;\n        boolean bitb = (ad & 0x80000000L ) != 0;\n        boolean bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prodB = prodB + (bc << 32);\n        prodA = prodA + (bc >>> 32);\n\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply input by shpiB */\n        c = shpiB >>> 32;\n        d = shpiB & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prodB += ac;\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply by shpi0 */\n        c = shpi0 >>> 32;\n        d = shpi0 & 0xffffffffL;\n\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        prodA += bd + ((bc + ad) << 32);\n\n        /*\n         * prodA, prodB now contain the remainder as a fraction of PI.  We want this as a fraction of\n         * PI/2, so use the following steps:\n         * 1.) multiply by 4.\n         * 2.) do a fixed point muliply by PI/4.\n         * 3.) Convert to floating point.\n         * 4.) Multiply by 2\n         */\n\n        /* This identifies the quadrant */\n        int intPart = (int)(prodA >>> 62);\n\n        /* Multiply by 4 */\n        prodA <<= 2;\n        prodA |= prodB >>> 62;\n        prodB <<= 2;\n\n        /* Multiply by PI/4 */\n        a = prodA >>> 32;\n        b = prodA & 0xffffffffL;\n\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n\n        ac = a * c;\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        long prod2B = bd + (ad << 32);\n        long prod2A = ac + (ad >>> 32);\n\n        bita = (bd & 0x8000000000000000L) != 0;\n        bitb = (ad & 0x80000000L ) != 0;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prod2B = prod2B + (bc << 32);\n        prod2A = prod2A + (bc >>> 32);\n\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply input by pio4bits[1] */\n        c = PI_O_4_BITS[1] >>> 32;\n        d = PI_O_4_BITS[1] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply inputB by pio4bits[0] */\n        a = prodB >>> 32;\n        b = prodB & 0xffffffffL;\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Convert to double */\nif((((prod2A & 0xfffL) << 40) + (prod2B >>> 24))){\n        double tmpA = (prod2A >> 12) / TWO_POWER_52;  // High order 52 bits        double tmpB = (((prod2A & 0xfffL) << 40) + (prod2B >>> 24)) / TWO_POWER_52 / TWO_POWER_52; // Low bits\n\n        double sumA = tmpA + tmpB;\n        double sumB = -(sumA - tmpA - tmpB);\n\n        /* Multiply by PI/2 and return */\n        result[0] = intPart;\n        result[1] = sumA * 2.0;\n        result[2] = sumB * 2.0;\n}\n    }",
          "75": "    private static void reducePayneHanek(double x, double result[])\n    {\n        /* Convert input double to bits */\n        long inbits = Double.doubleToRawLongBits(x);\n        int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n\n        /* Convert to fixed point representation */\n        inbits &= 0x000fffffffffffffL;\n        inbits |= 0x0010000000000000L;\n\n        /* Normalize input to be between 0.5 and 1.0 */\n        exponent++;\n        inbits <<= 11;\n\n        /* Based on the exponent, get a shifted copy of recip2pi */\n        long shpi0;\n        long shpiA;\n        long shpiB;\n        int idx = exponent >> 6;\n        int shift = exponent - (idx << 6);\n\n        if (shift != 0) {\n            shpi0 = (idx == 0) ? 0 : (RECIP_2PI[idx-1] << shift);\n            shpi0 |= RECIP_2PI[idx] >>> (64-shift);\n            shpiA = (RECIP_2PI[idx] << shift) | (RECIP_2PI[idx+1] >>> (64-shift));\n            shpiB = (RECIP_2PI[idx+1] << shift) | (RECIP_2PI[idx+2] >>> (64-shift));\n        } else {\n            shpi0 = (idx == 0) ? 0 : RECIP_2PI[idx-1];\n            shpiA = RECIP_2PI[idx];\n            shpiB = RECIP_2PI[idx+1];\n        }\n\n        /* Multiply input by shpiA */\n        long a = inbits >>> 32;\n        long b = inbits & 0xffffffffL;\n\n        long c = shpiA >>> 32;\n        long d = shpiA & 0xffffffffL;\n\n        long ac = a * c;\n        long bd = b * d;\n        long bc = b * c;\n        long ad = a * d;\n\n        long prodB = bd + (ad << 32);\n        long prodA = ac + (ad >>> 32);\n\n        boolean bita = (bd & 0x8000000000000000L) != 0;\n        boolean bitb = (ad & 0x80000000L ) != 0;\n        boolean bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prodB = prodB + (bc << 32);\n        prodA = prodA + (bc >>> 32);\n\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply input by shpiB */\n        c = shpiB >>> 32;\n        d = shpiB & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prodB += ac;\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply by shpi0 */\n        c = shpi0 >>> 32;\n        d = shpi0 & 0xffffffffL;\n\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        prodA += bd + ((bc + ad) << 32);\n\n        /*\n         * prodA, prodB now contain the remainder as a fraction of PI.  We want this as a fraction of\n         * PI/2, so use the following steps:\n         * 1.) multiply by 4.\n         * 2.) do a fixed point muliply by PI/4.\n         * 3.) Convert to floating point.\n         * 4.) Multiply by 2\n         */\n\n        /* This identifies the quadrant */\n        int intPart = (int)(prodA >>> 62);\n\n        /* Multiply by 4 */\n        prodA <<= 2;\n        prodA |= prodB >>> 62;\n        prodB <<= 2;\n\n        /* Multiply by PI/4 */\n        a = prodA >>> 32;\n        b = prodA & 0xffffffffL;\n\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n\n        ac = a * c;\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        long prod2B = bd + (ad << 32);\n        long prod2A = ac + (ad >>> 32);\n\n        bita = (bd & 0x8000000000000000L) != 0;\n        bitb = (ad & 0x80000000L ) != 0;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prod2B = prod2B + (bc << 32);\n        prod2A = prod2A + (bc >>> 32);\n\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply input by pio4bits[1] */\n        c = PI_O_4_BITS[1] >>> 32;\n        d = PI_O_4_BITS[1] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply inputB by pio4bits[0] */\n        a = prodB >>> 32;\n        b = prodB & 0xffffffffL;\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Convert to double */\ndouble tmpA = ((TWO_POWER_52 >> 12) / TWO_POWER_52);\n        double tmpB = (((prod2A & 0xfffL) << 40) + (prod2B >>> 24)) / TWO_POWER_52 / TWO_POWER_52; // Low bits\n\n        double sumA = tmpA + tmpB;\n        double sumB = -(sumA - tmpA - tmpB);\n\n        /* Multiply by PI/2 and return */\n        result[0] = intPart;\n        result[1] = sumA * 2.0;\n        result[2] = sumB * 2.0;\n    }",
          "76": "    private static void reducePayneHanek(double x, double result[])\n    {\n        /* Convert input double to bits */\n        long inbits = Double.doubleToRawLongBits(x);\n        int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n\n        /* Convert to fixed point representation */\n        inbits &= 0x000fffffffffffffL;\n        inbits |= 0x0010000000000000L;\n\n        /* Normalize input to be between 0.5 and 1.0 */\n        exponent++;\n        inbits <<= 11;\n\n        /* Based on the exponent, get a shifted copy of recip2pi */\n        long shpi0;\n        long shpiA;\n        long shpiB;\n        int idx = exponent >> 6;\n        int shift = exponent - (idx << 6);\n\n        if (shift != 0) {\n            shpi0 = (idx == 0) ? 0 : (RECIP_2PI[idx-1] << shift);\n            shpi0 |= RECIP_2PI[idx] >>> (64-shift);\n            shpiA = (RECIP_2PI[idx] << shift) | (RECIP_2PI[idx+1] >>> (64-shift));\n            shpiB = (RECIP_2PI[idx+1] << shift) | (RECIP_2PI[idx+2] >>> (64-shift));\n        } else {\n            shpi0 = (idx == 0) ? 0 : RECIP_2PI[idx-1];\n            shpiA = RECIP_2PI[idx];\n            shpiB = RECIP_2PI[idx+1];\n        }\n\n        /* Multiply input by shpiA */\n        long a = inbits >>> 32;\n        long b = inbits & 0xffffffffL;\n\n        long c = shpiA >>> 32;\n        long d = shpiA & 0xffffffffL;\n\n        long ac = a * c;\n        long bd = b * d;\n        long bc = b * c;\n        long ad = a * d;\n\n        long prodB = bd + (ad << 32);\n        long prodA = ac + (ad >>> 32);\n\n        boolean bita = (bd & 0x8000000000000000L) != 0;\n        boolean bitb = (ad & 0x80000000L ) != 0;\n        boolean bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prodB = prodB + (bc << 32);\n        prodA = prodA + (bc >>> 32);\n\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply input by shpiB */\n        c = shpiB >>> 32;\n        d = shpiB & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prodB += ac;\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply by shpi0 */\n        c = shpi0 >>> 32;\n        d = shpi0 & 0xffffffffL;\n\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        prodA += bd + ((bc + ad) << 32);\n\n        /*\n         * prodA, prodB now contain the remainder as a fraction of PI.  We want this as a fraction of\n         * PI/2, so use the following steps:\n         * 1.) multiply by 4.\n         * 2.) do a fixed point muliply by PI/4.\n         * 3.) Convert to floating point.\n         * 4.) Multiply by 2\n         */\n\n        /* This identifies the quadrant */\n        int intPart = (int)(prodA >>> 62);\n\n        /* Multiply by 4 */\n        prodA <<= 2;\n        prodA |= prodB >>> 62;\n        prodB <<= 2;\n\n        /* Multiply by PI/4 */\n        a = prodA >>> 32;\n        b = prodA & 0xffffffffL;\n\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n\n        ac = a * c;\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        long prod2B = bd + (ad << 32);\n        long prod2A = ac + (ad >>> 32);\n\n        bita = (bd & 0x8000000000000000L) != 0;\n        bitb = (ad & 0x80000000L ) != 0;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prod2B = prod2B + (bc << 32);\n        prod2A = prod2A + (bc >>> 32);\n\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply input by pio4bits[1] */\n        c = PI_O_4_BITS[1] >>> 32;\n        d = PI_O_4_BITS[1] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply inputB by pio4bits[0] */\n        a = prodB >>> 32;\n        b = prodB & 0xffffffffL;\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Convert to double */\ncontinue;\n        double tmpA = (prod2A >> 12) / TWO_POWER_52;  // High order 52 bits        double tmpB = (((prod2A & 0xfffL) << 40) + (prod2B >>> 24)) / TWO_POWER_52 / TWO_POWER_52; // Low bits\n\n        double sumA = tmpA + tmpB;\n        double sumB = -(sumA - tmpA - tmpB);\n\n        /* Multiply by PI/2 and return */\n        result[0] = intPart;\n        result[1] = sumA * 2.0;\n        result[2] = sumB * 2.0;\n    }",
          "77": "    private static void reducePayneHanek(double x, double result[])\n    {\n        /* Convert input double to bits */\n        long inbits = Double.doubleToRawLongBits(x);\n        int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n\n        /* Convert to fixed point representation */\n        inbits &= 0x000fffffffffffffL;\n        inbits |= 0x0010000000000000L;\n\n        /* Normalize input to be between 0.5 and 1.0 */\n        exponent++;\n        inbits <<= 11;\n\n        /* Based on the exponent, get a shifted copy of recip2pi */\n        long shpi0;\n        long shpiA;\n        long shpiB;\n        int idx = exponent >> 6;\n        int shift = exponent - (idx << 6);\n\n        if (shift != 0) {\n            shpi0 = (idx == 0) ? 0 : (RECIP_2PI[idx-1] << shift);\n            shpi0 |= RECIP_2PI[idx] >>> (64-shift);\n            shpiA = (RECIP_2PI[idx] << shift) | (RECIP_2PI[idx+1] >>> (64-shift));\n            shpiB = (RECIP_2PI[idx+1] << shift) | (RECIP_2PI[idx+2] >>> (64-shift));\n        } else {\n            shpi0 = (idx == 0) ? 0 : RECIP_2PI[idx-1];\n            shpiA = RECIP_2PI[idx];\n            shpiB = RECIP_2PI[idx+1];\n        }\n\n        /* Multiply input by shpiA */\n        long a = inbits >>> 32;\n        long b = inbits & 0xffffffffL;\n\n        long c = shpiA >>> 32;\n        long d = shpiA & 0xffffffffL;\n\n        long ac = a * c;\n        long bd = b * d;\n        long bc = b * c;\n        long ad = a * d;\n\n        long prodB = bd + (ad << 32);\n        long prodA = ac + (ad >>> 32);\n\n        boolean bita = (bd & 0x8000000000000000L) != 0;\n        boolean bitb = (ad & 0x80000000L ) != 0;\n        boolean bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prodB = prodB + (bc << 32);\n        prodA = prodA + (bc >>> 32);\n\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply input by shpiB */\n        c = shpiB >>> 32;\n        d = shpiB & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prodB += ac;\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply by shpi0 */\n        c = shpi0 >>> 32;\n        d = shpi0 & 0xffffffffL;\n\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        prodA += bd + ((bc + ad) << 32);\n\n        /*\n         * prodA, prodB now contain the remainder as a fraction of PI.  We want this as a fraction of\n         * PI/2, so use the following steps:\n         * 1.) multiply by 4.\n         * 2.) do a fixed point muliply by PI/4.\n         * 3.) Convert to floating point.\n         * 4.) Multiply by 2\n         */\n\n        /* This identifies the quadrant */\n        int intPart = (int)(prodA >>> 62);\n\n        /* Multiply by 4 */\n        prodA <<= 2;\n        prodA |= prodB >>> 62;\n        prodB <<= 2;\n\n        /* Multiply by PI/4 */\n        a = prodA >>> 32;\n        b = prodA & 0xffffffffL;\n\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n\n        ac = a * c;\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        long prod2B = bd + (ad << 32);\n        long prod2A = ac + (ad >>> 32);\n\n        bita = (bd & 0x8000000000000000L) != 0;\n        bitb = (ad & 0x80000000L ) != 0;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prod2B = prod2B + (bc << 32);\n        prod2A = prod2A + (bc >>> 32);\n\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply input by pio4bits[1] */\n        c = PI_O_4_BITS[1] >>> 32;\n        d = PI_O_4_BITS[1] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply inputB by pio4bits[0] */\n        a = prodB >>> 32;\n        b = prodB & 0xffffffffL;\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Convert to double */\ndouble tmpA = ((prod2A >> 12) + TWO_POWER_52);\n        double tmpB = (((prod2A & 0xfffL) << 40) + (prod2B >>> 24)) / TWO_POWER_52 / TWO_POWER_52; // Low bits\n\n        double sumA = tmpA + tmpB;\n        double sumB = -(sumA - tmpA - tmpB);\n\n        /* Multiply by PI/2 and return */\n        result[0] = intPart;\n        result[1] = sumA * 2.0;\n        result[2] = sumB * 2.0;\n    }",
          "78": "    private static void reducePayneHanek(double x, double result[])\n    {\n        /* Convert input double to bits */\n        long inbits = Double.doubleToRawLongBits(x);\n        int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n\n        /* Convert to fixed point representation */\n        inbits &= 0x000fffffffffffffL;\n        inbits |= 0x0010000000000000L;\n\n        /* Normalize input to be between 0.5 and 1.0 */\n        exponent++;\n        inbits <<= 11;\n\n        /* Based on the exponent, get a shifted copy of recip2pi */\n        long shpi0;\n        long shpiA;\n        long shpiB;\n        int idx = exponent >> 6;\n        int shift = exponent - (idx << 6);\n\n        if (shift != 0) {\n            shpi0 = (idx == 0) ? 0 : (RECIP_2PI[idx-1] << shift);\n            shpi0 |= RECIP_2PI[idx] >>> (64-shift);\n            shpiA = (RECIP_2PI[idx] << shift) | (RECIP_2PI[idx+1] >>> (64-shift));\n            shpiB = (RECIP_2PI[idx+1] << shift) | (RECIP_2PI[idx+2] >>> (64-shift));\n        } else {\n            shpi0 = (idx == 0) ? 0 : RECIP_2PI[idx-1];\n            shpiA = RECIP_2PI[idx];\n            shpiB = RECIP_2PI[idx+1];\n        }\n\n        /* Multiply input by shpiA */\n        long a = inbits >>> 32;\n        long b = inbits & 0xffffffffL;\n\n        long c = shpiA >>> 32;\n        long d = shpiA & 0xffffffffL;\n\n        long ac = a * c;\n        long bd = b * d;\n        long bc = b * c;\n        long ad = a * d;\n\n        long prodB = bd + (ad << 32);\n        long prodA = ac + (ad >>> 32);\n\n        boolean bita = (bd & 0x8000000000000000L) != 0;\n        boolean bitb = (ad & 0x80000000L ) != 0;\n        boolean bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prodB = prodB + (bc << 32);\n        prodA = prodA + (bc >>> 32);\n\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply input by shpiB */\n        c = shpiB >>> 32;\n        d = shpiB & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prodB += ac;\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply by shpi0 */\n        c = shpi0 >>> 32;\n        d = shpi0 & 0xffffffffL;\n\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        prodA += bd + ((bc + ad) << 32);\n\n        /*\n         * prodA, prodB now contain the remainder as a fraction of PI.  We want this as a fraction of\n         * PI/2, so use the following steps:\n         * 1.) multiply by 4.\n         * 2.) do a fixed point muliply by PI/4.\n         * 3.) Convert to floating point.\n         * 4.) Multiply by 2\n         */\n\n        /* This identifies the quadrant */\n        int intPart = (int)(prodA >>> 62);\n\n        /* Multiply by 4 */\n        prodA <<= 2;\n        prodA |= prodB >>> 62;\n        prodB <<= 2;\n\n        /* Multiply by PI/4 */\n        a = prodA >>> 32;\n        b = prodA & 0xffffffffL;\n\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n\n        ac = a * c;\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        long prod2B = bd + (ad << 32);\n        long prod2A = ac + (ad >>> 32);\n\n        bita = (bd & 0x8000000000000000L) != 0;\n        bitb = (ad & 0x80000000L ) != 0;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prod2B = prod2B + (bc << 32);\n        prod2A = prod2A + (bc >>> 32);\n\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply input by pio4bits[1] */\n        c = PI_O_4_BITS[1] >>> 32;\n        d = PI_O_4_BITS[1] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply inputB by pio4bits[0] */\n        a = prodB >>> 32;\n        b = prodB & 0xffffffffL;\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Convert to double */\nif(((bita || bitb) && !bitsum)){\n        double tmpA = (prod2A >> 12) / TWO_POWER_52;  // High order 52 bits        double tmpB = (((prod2A & 0xfffL) << 40) + (prod2B >>> 24)) / TWO_POWER_52 / TWO_POWER_52; // Low bits\n\n        double sumA = tmpA + tmpB;\n        double sumB = -(sumA - tmpA - tmpB);\n\n        /* Multiply by PI/2 and return */\n        result[0] = intPart;\n        result[1] = sumA * 2.0;\n        result[2] = sumB * 2.0;\n}\n    }",
          "79": "    private static void reducePayneHanek(double x, double result[])\n    {\n        /* Convert input double to bits */\n        long inbits = Double.doubleToRawLongBits(x);\n        int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n\n        /* Convert to fixed point representation */\n        inbits &= 0x000fffffffffffffL;\n        inbits |= 0x0010000000000000L;\n\n        /* Normalize input to be between 0.5 and 1.0 */\n        exponent++;\n        inbits <<= 11;\n\n        /* Based on the exponent, get a shifted copy of recip2pi */\n        long shpi0;\n        long shpiA;\n        long shpiB;\n        int idx = exponent >> 6;\n        int shift = exponent - (idx << 6);\n\n        if (shift != 0) {\n            shpi0 = (idx == 0) ? 0 : (RECIP_2PI[idx-1] << shift);\n            shpi0 |= RECIP_2PI[idx] >>> (64-shift);\n            shpiA = (RECIP_2PI[idx] << shift) | (RECIP_2PI[idx+1] >>> (64-shift));\n            shpiB = (RECIP_2PI[idx+1] << shift) | (RECIP_2PI[idx+2] >>> (64-shift));\n        } else {\n            shpi0 = (idx == 0) ? 0 : RECIP_2PI[idx-1];\n            shpiA = RECIP_2PI[idx];\n            shpiB = RECIP_2PI[idx+1];\n        }\n\n        /* Multiply input by shpiA */\n        long a = inbits >>> 32;\n        long b = inbits & 0xffffffffL;\n\n        long c = shpiA >>> 32;\n        long d = shpiA & 0xffffffffL;\n\n        long ac = a * c;\n        long bd = b * d;\n        long bc = b * c;\n        long ad = a * d;\n\n        long prodB = bd + (ad << 32);\n        long prodA = ac + (ad >>> 32);\n\n        boolean bita = (bd & 0x8000000000000000L) != 0;\n        boolean bitb = (ad & 0x80000000L ) != 0;\n        boolean bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prodB = prodB + (bc << 32);\n        prodA = prodA + (bc >>> 32);\n\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply input by shpiB */\n        c = shpiB >>> 32;\n        d = shpiB & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prodB += ac;\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply by shpi0 */\n        c = shpi0 >>> 32;\n        d = shpi0 & 0xffffffffL;\n\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        prodA += bd + ((bc + ad) << 32);\n\n        /*\n         * prodA, prodB now contain the remainder as a fraction of PI.  We want this as a fraction of\n         * PI/2, so use the following steps:\n         * 1.) multiply by 4.\n         * 2.) do a fixed point muliply by PI/4.\n         * 3.) Convert to floating point.\n         * 4.) Multiply by 2\n         */\n\n        /* This identifies the quadrant */\n        int intPart = (int)(prodA >>> 62);\n\n        /* Multiply by 4 */\n        prodA <<= 2;\n        prodA |= prodB >>> 62;\n        prodB <<= 2;\n\n        /* Multiply by PI/4 */\n        a = prodA >>> 32;\n        b = prodA & 0xffffffffL;\n\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n\n        ac = a * c;\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        long prod2B = bd + (ad << 32);\n        long prod2A = ac + (ad >>> 32);\n\n        bita = (bd & 0x8000000000000000L) != 0;\n        bitb = (ad & 0x80000000L ) != 0;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prod2B = prod2B + (bc << 32);\n        prod2A = prod2A + (bc >>> 32);\n\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply input by pio4bits[1] */\n        c = PI_O_4_BITS[1] >>> 32;\n        d = PI_O_4_BITS[1] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply inputB by pio4bits[0] */\n        a = prodB >>> 32;\n        b = prodB & 0xffffffffL;\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Convert to double */\nif(((((prod2A & 0xfffL) << 40) + (prod2B >>> 24)) / TWO_POWER_52)){\n        double tmpA = (prod2A >> 12) / TWO_POWER_52;  // High order 52 bits        double tmpB = (((prod2A & 0xfffL) << 40) + (prod2B >>> 24)) / TWO_POWER_52 / TWO_POWER_52; // Low bits\n\n        double sumA = tmpA + tmpB;\n        double sumB = -(sumA - tmpA - tmpB);\n\n        /* Multiply by PI/2 and return */\n        result[0] = intPart;\n        result[1] = sumA * 2.0;\n        result[2] = sumB * 2.0;\n}\n    }",
          "80": "    private static void reducePayneHanek(double x, double result[])\n    {\n        /* Convert input double to bits */\n        long inbits = Double.doubleToRawLongBits(x);\n        int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n\n        /* Convert to fixed point representation */\n        inbits &= 0x000fffffffffffffL;\n        inbits |= 0x0010000000000000L;\n\n        /* Normalize input to be between 0.5 and 1.0 */\n        exponent++;\n        inbits <<= 11;\n\n        /* Based on the exponent, get a shifted copy of recip2pi */\n        long shpi0;\n        long shpiA;\n        long shpiB;\n        int idx = exponent >> 6;\n        int shift = exponent - (idx << 6);\n\n        if (shift != 0) {\n            shpi0 = (idx == 0) ? 0 : (RECIP_2PI[idx-1] << shift);\n            shpi0 |= RECIP_2PI[idx] >>> (64-shift);\n            shpiA = (RECIP_2PI[idx] << shift) | (RECIP_2PI[idx+1] >>> (64-shift));\n            shpiB = (RECIP_2PI[idx+1] << shift) | (RECIP_2PI[idx+2] >>> (64-shift));\n        } else {\n            shpi0 = (idx == 0) ? 0 : RECIP_2PI[idx-1];\n            shpiA = RECIP_2PI[idx];\n            shpiB = RECIP_2PI[idx+1];\n        }\n\n        /* Multiply input by shpiA */\n        long a = inbits >>> 32;\n        long b = inbits & 0xffffffffL;\n\n        long c = shpiA >>> 32;\n        long d = shpiA & 0xffffffffL;\n\n        long ac = a * c;\n        long bd = b * d;\n        long bc = b * c;\n        long ad = a * d;\n\n        long prodB = bd + (ad << 32);\n        long prodA = ac + (ad >>> 32);\n\n        boolean bita = (bd & 0x8000000000000000L) != 0;\n        boolean bitb = (ad & 0x80000000L ) != 0;\n        boolean bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prodB = prodB + (bc << 32);\n        prodA = prodA + (bc >>> 32);\n\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply input by shpiB */\n        c = shpiB >>> 32;\n        d = shpiB & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prodB += ac;\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply by shpi0 */\n        c = shpi0 >>> 32;\n        d = shpi0 & 0xffffffffL;\n\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        prodA += bd + ((bc + ad) << 32);\n\n        /*\n         * prodA, prodB now contain the remainder as a fraction of PI.  We want this as a fraction of\n         * PI/2, so use the following steps:\n         * 1.) multiply by 4.\n         * 2.) do a fixed point muliply by PI/4.\n         * 3.) Convert to floating point.\n         * 4.) Multiply by 2\n         */\n\n        /* This identifies the quadrant */\n        int intPart = (int)(prodA >>> 62);\n\n        /* Multiply by 4 */\n        prodA <<= 2;\n        prodA |= prodB >>> 62;\n        prodB <<= 2;\n\n        /* Multiply by PI/4 */\n        a = prodA >>> 32;\n        b = prodA & 0xffffffffL;\n\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n\n        ac = a * c;\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        long prod2B = bd + (ad << 32);\n        long prod2A = ac + (ad >>> 32);\n\n        bita = (bd & 0x8000000000000000L) != 0;\n        bitb = (ad & 0x80000000L ) != 0;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prod2B = prod2B + (bc << 32);\n        prod2A = prod2A + (bc >>> 32);\n\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply input by pio4bits[1] */\n        c = PI_O_4_BITS[1] >>> 32;\n        d = PI_O_4_BITS[1] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply inputB by pio4bits[0] */\n        a = prodB >>> 32;\n        b = prodB & 0xffffffffL;\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Convert to double */\ndouble tmpA = ((prod2B >> 12) / TWO_POWER_52);\n        double tmpB = (((prod2A & 0xfffL) << 40) + (prod2B >>> 24)) / TWO_POWER_52 / TWO_POWER_52; // Low bits\n\n        double sumA = tmpA + tmpB;\n        double sumB = -(sumA - tmpA - tmpB);\n\n        /* Multiply by PI/2 and return */\n        result[0] = intPart;\n        result[1] = sumA * 2.0;\n        result[2] = sumB * 2.0;\n    }",
          "81": "    private static void reducePayneHanek(double x, double result[])\n    {\n        /* Convert input double to bits */\n        long inbits = Double.doubleToRawLongBits(x);\n        int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n\n        /* Convert to fixed point representation */\n        inbits &= 0x000fffffffffffffL;\n        inbits |= 0x0010000000000000L;\n\n        /* Normalize input to be between 0.5 and 1.0 */\n        exponent++;\n        inbits <<= 11;\n\n        /* Based on the exponent, get a shifted copy of recip2pi */\n        long shpi0;\n        long shpiA;\n        long shpiB;\n        int idx = exponent >> 6;\n        int shift = exponent - (idx << 6);\n\n        if (shift != 0) {\n            shpi0 = (idx == 0) ? 0 : (RECIP_2PI[idx-1] << shift);\n            shpi0 |= RECIP_2PI[idx] >>> (64-shift);\n            shpiA = (RECIP_2PI[idx] << shift) | (RECIP_2PI[idx+1] >>> (64-shift));\n            shpiB = (RECIP_2PI[idx+1] << shift) | (RECIP_2PI[idx+2] >>> (64-shift));\n        } else {\n            shpi0 = (idx == 0) ? 0 : RECIP_2PI[idx-1];\n            shpiA = RECIP_2PI[idx];\n            shpiB = RECIP_2PI[idx+1];\n        }\n\n        /* Multiply input by shpiA */\n        long a = inbits >>> 32;\n        long b = inbits & 0xffffffffL;\n\n        long c = shpiA >>> 32;\n        long d = shpiA & 0xffffffffL;\n\n        long ac = a * c;\n        long bd = b * d;\n        long bc = b * c;\n        long ad = a * d;\n\n        long prodB = bd + (ad << 32);\n        long prodA = ac + (ad >>> 32);\n\n        boolean bita = (bd & 0x8000000000000000L) != 0;\n        boolean bitb = (ad & 0x80000000L ) != 0;\n        boolean bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prodB = prodB + (bc << 32);\n        prodA = prodA + (bc >>> 32);\n\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply input by shpiB */\n        c = shpiB >>> 32;\n        d = shpiB & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prodB += ac;\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply by shpi0 */\n        c = shpi0 >>> 32;\n        d = shpi0 & 0xffffffffL;\n\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        prodA += bd + ((bc + ad) << 32);\n\n        /*\n         * prodA, prodB now contain the remainder as a fraction of PI.  We want this as a fraction of\n         * PI/2, so use the following steps:\n         * 1.) multiply by 4.\n         * 2.) do a fixed point muliply by PI/4.\n         * 3.) Convert to floating point.\n         * 4.) Multiply by 2\n         */\n\n        /* This identifies the quadrant */\n        int intPart = (int)(prodA >>> 62);\n\n        /* Multiply by 4 */\n        prodA <<= 2;\n        prodA |= prodB >>> 62;\n        prodB <<= 2;\n\n        /* Multiply by PI/4 */\n        a = prodA >>> 32;\n        b = prodA & 0xffffffffL;\n\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n\n        ac = a * c;\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        long prod2B = bd + (ad << 32);\n        long prod2A = ac + (ad >>> 32);\n\n        bita = (bd & 0x8000000000000000L) != 0;\n        bitb = (ad & 0x80000000L ) != 0;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prod2B = prod2B + (bc << 32);\n        prod2A = prod2A + (bc >>> 32);\n\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply input by pio4bits[1] */\n        c = PI_O_4_BITS[1] >>> 32;\n        d = PI_O_4_BITS[1] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply inputB by pio4bits[0] */\n        a = prodB >>> 32;\n        b = prodB & 0xffffffffL;\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Convert to double */\n        double tmpB = (((prod2A & 0xfffL) << 40) + (prod2B >>> 24)) / TWO_POWER_52 / TWO_POWER_52; // Low bits\n\n        double sumA = tmpA + tmpB;\n        double sumB = -(sumA - tmpA - tmpB);\n\n        /* Multiply by PI/2 and return */\n        result[0] = intPart;\n        result[1] = sumA * 2.0;\n        result[2] = sumB * 2.0;\n    }",
          "82": "    private static void reducePayneHanek(double x, double result[])\n    {\n        /* Convert input double to bits */\n        long inbits = Double.doubleToRawLongBits(x);\n        int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n\n        /* Convert to fixed point representation */\n        inbits &= 0x000fffffffffffffL;\n        inbits |= 0x0010000000000000L;\n\n        /* Normalize input to be between 0.5 and 1.0 */\n        exponent++;\n        inbits <<= 11;\n\n        /* Based on the exponent, get a shifted copy of recip2pi */\n        long shpi0;\n        long shpiA;\n        long shpiB;\n        int idx = exponent >> 6;\n        int shift = exponent - (idx << 6);\n\n        if (shift != 0) {\n            shpi0 = (idx == 0) ? 0 : (RECIP_2PI[idx-1] << shift);\n            shpi0 |= RECIP_2PI[idx] >>> (64-shift);\n            shpiA = (RECIP_2PI[idx] << shift) | (RECIP_2PI[idx+1] >>> (64-shift));\n            shpiB = (RECIP_2PI[idx+1] << shift) | (RECIP_2PI[idx+2] >>> (64-shift));\n        } else {\n            shpi0 = (idx == 0) ? 0 : RECIP_2PI[idx-1];\n            shpiA = RECIP_2PI[idx];\n            shpiB = RECIP_2PI[idx+1];\n        }\n\n        /* Multiply input by shpiA */\n        long a = inbits >>> 32;\n        long b = inbits & 0xffffffffL;\n\n        long c = shpiA >>> 32;\n        long d = shpiA & 0xffffffffL;\n\n        long ac = a * c;\n        long bd = b * d;\n        long bc = b * c;\n        long ad = a * d;\n\n        long prodB = bd + (ad << 32);\n        long prodA = ac + (ad >>> 32);\n\n        boolean bita = (bd & 0x8000000000000000L) != 0;\n        boolean bitb = (ad & 0x80000000L ) != 0;\n        boolean bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prodB = prodB + (bc << 32);\n        prodA = prodA + (bc >>> 32);\n\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply input by shpiB */\n        c = shpiB >>> 32;\n        d = shpiB & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prodB += ac;\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply by shpi0 */\n        c = shpi0 >>> 32;\n        d = shpi0 & 0xffffffffL;\n\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        prodA += bd + ((bc + ad) << 32);\n\n        /*\n         * prodA, prodB now contain the remainder as a fraction of PI.  We want this as a fraction of\n         * PI/2, so use the following steps:\n         * 1.) multiply by 4.\n         * 2.) do a fixed point muliply by PI/4.\n         * 3.) Convert to floating point.\n         * 4.) Multiply by 2\n         */\n\n        /* This identifies the quadrant */\n        int intPart = (int)(prodA >>> 62);\n\n        /* Multiply by 4 */\n        prodA <<= 2;\n        prodA |= prodB >>> 62;\n        prodB <<= 2;\n\n        /* Multiply by PI/4 */\n        a = prodA >>> 32;\n        b = prodA & 0xffffffffL;\n\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n\n        ac = a * c;\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        long prod2B = bd + (ad << 32);\n        long prod2A = ac + (ad >>> 32);\n\n        bita = (bd & 0x8000000000000000L) != 0;\n        bitb = (ad & 0x80000000L ) != 0;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prod2B = prod2B + (bc << 32);\n        prod2A = prod2A + (bc >>> 32);\n\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply input by pio4bits[1] */\n        c = PI_O_4_BITS[1] >>> 32;\n        d = PI_O_4_BITS[1] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply inputB by pio4bits[0] */\n        a = prodB >>> 32;\n        b = prodB & 0xffffffffL;\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Convert to double */\nif((prod2A != null)){\n        double tmpA = (prod2A >> 12) / TWO_POWER_52;  // High order 52 bits        double tmpB = (((prod2A & 0xfffL) << 40) + (prod2B >>> 24)) / TWO_POWER_52 / TWO_POWER_52; // Low bits\n\n        double sumA = tmpA + tmpB;\n        double sumB = -(sumA - tmpA - tmpB);\n\n        /* Multiply by PI/2 and return */\n        result[0] = intPart;\n        result[1] = sumA * 2.0;\n        result[2] = sumB * 2.0;\n}\n    }",
          "83": "    private static void reducePayneHanek(double x, double result[])\n    {\n        /* Convert input double to bits */\n        long inbits = Double.doubleToRawLongBits(x);\n        int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n\n        /* Convert to fixed point representation */\n        inbits &= 0x000fffffffffffffL;\n        inbits |= 0x0010000000000000L;\n\n        /* Normalize input to be between 0.5 and 1.0 */\n        exponent++;\n        inbits <<= 11;\n\n        /* Based on the exponent, get a shifted copy of recip2pi */\n        long shpi0;\n        long shpiA;\n        long shpiB;\n        int idx = exponent >> 6;\n        int shift = exponent - (idx << 6);\n\n        if (shift != 0) {\n            shpi0 = (idx == 0) ? 0 : (RECIP_2PI[idx-1] << shift);\n            shpi0 |= RECIP_2PI[idx] >>> (64-shift);\n            shpiA = (RECIP_2PI[idx] << shift) | (RECIP_2PI[idx+1] >>> (64-shift));\n            shpiB = (RECIP_2PI[idx+1] << shift) | (RECIP_2PI[idx+2] >>> (64-shift));\n        } else {\n            shpi0 = (idx == 0) ? 0 : RECIP_2PI[idx-1];\n            shpiA = RECIP_2PI[idx];\n            shpiB = RECIP_2PI[idx+1];\n        }\n\n        /* Multiply input by shpiA */\n        long a = inbits >>> 32;\n        long b = inbits & 0xffffffffL;\n\n        long c = shpiA >>> 32;\n        long d = shpiA & 0xffffffffL;\n\n        long ac = a * c;\n        long bd = b * d;\n        long bc = b * c;\n        long ad = a * d;\n\n        long prodB = bd + (ad << 32);\n        long prodA = ac + (ad >>> 32);\n\n        boolean bita = (bd & 0x8000000000000000L) != 0;\n        boolean bitb = (ad & 0x80000000L ) != 0;\n        boolean bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prodB = prodB + (bc << 32);\n        prodA = prodA + (bc >>> 32);\n\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply input by shpiB */\n        c = shpiB >>> 32;\n        d = shpiB & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prodB += ac;\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply by shpi0 */\n        c = shpi0 >>> 32;\n        d = shpi0 & 0xffffffffL;\n\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        prodA += bd + ((bc + ad) << 32);\n\n        /*\n         * prodA, prodB now contain the remainder as a fraction of PI.  We want this as a fraction of\n         * PI/2, so use the following steps:\n         * 1.) multiply by 4.\n         * 2.) do a fixed point muliply by PI/4.\n         * 3.) Convert to floating point.\n         * 4.) Multiply by 2\n         */\n\n        /* This identifies the quadrant */\n        int intPart = (int)(prodA >>> 62);\n\n        /* Multiply by 4 */\n        prodA <<= 2;\n        prodA |= prodB >>> 62;\n        prodB <<= 2;\n\n        /* Multiply by PI/4 */\n        a = prodA >>> 32;\n        b = prodA & 0xffffffffL;\n\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n\n        ac = a * c;\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        long prod2B = bd + (ad << 32);\n        long prod2A = ac + (ad >>> 32);\n\n        bita = (bd & 0x8000000000000000L) != 0;\n        bitb = (ad & 0x80000000L ) != 0;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prod2B = prod2B + (bc << 32);\n        prod2A = prod2A + (bc >>> 32);\n\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply input by pio4bits[1] */\n        c = PI_O_4_BITS[1] >>> 32;\n        d = PI_O_4_BITS[1] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply inputB by pio4bits[0] */\n        a = prodB >>> 32;\n        b = prodB & 0xffffffffL;\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Convert to double */\ndouble tmpA = ((prod2A >> 40) / TWO_POWER_52);\n        double tmpB = (((prod2A & 0xfffL) << 40) + (prod2B >>> 24)) / TWO_POWER_52 / TWO_POWER_52; // Low bits\n\n        double sumA = tmpA + tmpB;\n        double sumB = -(sumA - tmpA - tmpB);\n\n        /* Multiply by PI/2 and return */\n        result[0] = intPart;\n        result[1] = sumA * 2.0;\n        result[2] = sumB * 2.0;\n    }",
          "84": "    private static void reducePayneHanek(double x, double result[])\n    {\n        /* Convert input double to bits */\n        long inbits = Double.doubleToRawLongBits(x);\n        int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n\n        /* Convert to fixed point representation */\n        inbits &= 0x000fffffffffffffL;\n        inbits |= 0x0010000000000000L;\n\n        /* Normalize input to be between 0.5 and 1.0 */\n        exponent++;\n        inbits <<= 11;\n\n        /* Based on the exponent, get a shifted copy of recip2pi */\n        long shpi0;\n        long shpiA;\n        long shpiB;\n        int idx = exponent >> 6;\n        int shift = exponent - (idx << 6);\n\n        if (shift != 0) {\n            shpi0 = (idx == 0) ? 0 : (RECIP_2PI[idx-1] << shift);\n            shpi0 |= RECIP_2PI[idx] >>> (64-shift);\n            shpiA = (RECIP_2PI[idx] << shift) | (RECIP_2PI[idx+1] >>> (64-shift));\n            shpiB = (RECIP_2PI[idx+1] << shift) | (RECIP_2PI[idx+2] >>> (64-shift));\n        } else {\n            shpi0 = (idx == 0) ? 0 : RECIP_2PI[idx-1];\n            shpiA = RECIP_2PI[idx];\n            shpiB = RECIP_2PI[idx+1];\n        }\n\n        /* Multiply input by shpiA */\n        long a = inbits >>> 32;\n        long b = inbits & 0xffffffffL;\n\n        long c = shpiA >>> 32;\n        long d = shpiA & 0xffffffffL;\n\n        long ac = a * c;\n        long bd = b * d;\n        long bc = b * c;\n        long ad = a * d;\n\n        long prodB = bd + (ad << 32);\n        long prodA = ac + (ad >>> 32);\n\n        boolean bita = (bd & 0x8000000000000000L) != 0;\n        boolean bitb = (ad & 0x80000000L ) != 0;\n        boolean bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prodB = prodB + (bc << 32);\n        prodA = prodA + (bc >>> 32);\n\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply input by shpiB */\n        c = shpiB >>> 32;\n        d = shpiB & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prodB += ac;\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prodA++;\n        }\n\n        /* Multiply by shpi0 */\n        c = shpi0 >>> 32;\n        d = shpi0 & 0xffffffffL;\n\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        prodA += bd + ((bc + ad) << 32);\n\n        /*\n         * prodA, prodB now contain the remainder as a fraction of PI.  We want this as a fraction of\n         * PI/2, so use the following steps:\n         * 1.) multiply by 4.\n         * 2.) do a fixed point muliply by PI/4.\n         * 3.) Convert to floating point.\n         * 4.) Multiply by 2\n         */\n\n        /* This identifies the quadrant */\n        int intPart = (int)(prodA >>> 62);\n\n        /* Multiply by 4 */\n        prodA <<= 2;\n        prodA |= prodB >>> 62;\n        prodB <<= 2;\n\n        /* Multiply by PI/4 */\n        a = prodA >>> 32;\n        b = prodA & 0xffffffffL;\n\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n\n        ac = a * c;\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n\n        long prod2B = bd + (ad << 32);\n        long prod2A = ac + (ad >>> 32);\n\n        bita = (bd & 0x8000000000000000L) != 0;\n        bitb = (ad & 0x80000000L ) != 0;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L ) != 0;\n\n        prod2B = prod2B + (bc << 32);\n        prod2A = prod2A + (bc >>> 32);\n\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply input by pio4bits[1] */\n        c = PI_O_4_BITS[1] >>> 32;\n        d = PI_O_4_BITS[1] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Multiply inputB by pio4bits[0] */\n        a = prodB >>> 32;\n        b = prodB & 0xffffffffL;\n        c = PI_O_4_BITS[0] >>> 32;\n        d = PI_O_4_BITS[0] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n\n        /* Collect terms */\n        ac = ac + ((bc + ad) >>> 32);\n\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L ) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        /* Carry */\n        if ( (bita && bitb) ||\n                ((bita || bitb) && !bitsum) ) {\n            prod2A++;\n        }\n\n        /* Convert to double */\ndouble tmpA = ((prod2A >> 0x8000000000000000L) / TWO_POWER_52);\n        double tmpB = (((prod2A & 0xfffL) << 40) + (prod2B >>> 24)) / TWO_POWER_52 / TWO_POWER_52; // Low bits\n\n        double sumA = tmpA + tmpB;\n        double sumB = -(sumA - tmpA - tmpB);\n\n        /* Multiply by PI/2 and return */\n        result[0] = intPart;\n        result[1] = sumA * 2.0;\n        result[2] = sumB * 2.0;\n    }"
}