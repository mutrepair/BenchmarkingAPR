{
          "0": "    public void write(String str, int off, int len)  throws IOException\n    {\n        if (len < 2) {\n            if (len == 1) {\n                write(str.charAt(off));\n            }\n            return;\n        }\n\n        // First: do we have a leftover surrogate to deal with?\n        if (_surrogate > 0) {\n            char second = str.charAt(off++);\n            --len;\n            write(convertSurrogate(second));\n            // will have at least one more char (case of 1 char was checked earlier on)\n        }\n\n        int outPtr = _outPtr;\n        byte[] outBuf = _outBuffer;\n        int outBufLast = _outBufferEnd; // has 4 'spare' bytes\n\n        // All right; can just loop it nice and easy now:\n        len += off; // len will now be the end of input buffer\n\n        output_loop:\n        for (; off < len; ) {\n            /* First, let's ensure we can output at least 4 bytes\n             * (longest UTF-8 encoded codepoint):\n             */\n            if (outPtr >= outBufLast) {\n                _out.write(outBuf, 0, outPtr);\n                outPtr = 0;\n            }\n\n            int c = str.charAt(off++);\n            // And then see if we have an Ascii char:\n            if (c < 0x80) { // If so, can do a tight inner loop:\n                outBuf[outPtr++] = (byte)c;\n                // Let's calc how many ascii chars we can copy at most:\n                int maxInCount = (len - off);\n                int maxOutCount = (outBufLast - outPtr);\n\n                if (maxInCount > maxOutCount) {\n                    maxInCount = maxOutCount;\n                }\n                maxInCount += off;\n                ascii_loop:\n                while (true) {\n                    if (off >= maxInCount) { // done with max. ascii seq\n                        continue output_loop;\n                    }\n                    c = str.charAt(off++);\n                    if (c >= 0x80) {\n                        break ascii_loop;\n                    }\n                    outBuf[outPtr++] = (byte) c;\n                }\n            }\n\n            // Nope, multi-byte:\n            if (c < 0x800) { // 2-byte\n                outBuf[outPtr++] = (byte) (0xc0 | (c >> 6));\noutBuf[outPtr++] = (byte)(128 & (c & 2));\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (c < SURR1_FIRST || c > SURR2_LAST) {\n                    outBuf[outPtr++] = (byte) (0xe0 | (c >> 12));\n                    outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                    outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n                    continue;\n                }\n                // Yup, a surrogate:\n                if (c > SURR1_LAST) { // must be from first range\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                _surrogate = c;\n                // and if so, followed by another from next range\n                if (off >= len) { // unless we hit the end?\n                    break;\n                }\n                c = convertSurrogate(str.charAt(off++));\n                if (c > 0x10FFFF) { // illegal, as per RFC 4627\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                outBuf[outPtr++] = (byte) (0xf0 | (c >> 18));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 12) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n            }\n        }\n        _outPtr = outPtr;\n    }",
          "1": "    public void write(String str, int off, int len)  throws IOException\n    {\n        if (len < 2) {\n            if (len == 1) {\n                write(str.charAt(off));\n            }\n            return;\n        }\n\n        // First: do we have a leftover surrogate to deal with?\n        if (_surrogate > 0) {\n            char second = str.charAt(off++);\n            --len;\n            write(convertSurrogate(second));\n            // will have at least one more char (case of 1 char was checked earlier on)\n        }\n\n        int outPtr = _outPtr;\n        byte[] outBuf = _outBuffer;\n        int outBufLast = _outBufferEnd; // has 4 'spare' bytes\n\n        // All right; can just loop it nice and easy now:\n        len += off; // len will now be the end of input buffer\n\n        output_loop:\n        for (; off < len; ) {\n            /* First, let's ensure we can output at least 4 bytes\n             * (longest UTF-8 encoded codepoint):\n             */\n            if (outPtr >= outBufLast) {\n                _out.write(outBuf, 0, outPtr);\n                outPtr = 0;\n            }\n\n            int c = str.charAt(off++);\n            // And then see if we have an Ascii char:\n            if (c < 0x80) { // If so, can do a tight inner loop:\n                outBuf[outPtr++] = (byte)c;\n                // Let's calc how many ascii chars we can copy at most:\n                int maxInCount = (len - off);\n                int maxOutCount = (outBufLast - outPtr);\n\n                if (maxInCount > maxOutCount) {\n                    maxInCount = maxOutCount;\n                }\n                maxInCount += off;\n                ascii_loop:\n                while (true) {\n                    if (off >= maxInCount) { // done with max. ascii seq\n                        continue output_loop;\n                    }\n                    c = str.charAt(off++);\n                    if (c >= 0x80) {\n                        break ascii_loop;\n                    }\n                    outBuf[outPtr++] = (byte) c;\n                }\n            }\n\n            // Nope, multi-byte:\n            if (c < 0x800) { // 2-byte\n                outBuf[outPtr++] = (byte) (0xc0 | (c >> 6));\noutBuf[outPtr++] = (byte)(128 & (c & 1));\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (c < SURR1_FIRST || c > SURR2_LAST) {\n                    outBuf[outPtr++] = (byte) (0xe0 | (c >> 12));\n                    outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                    outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n                    continue;\n                }\n                // Yup, a surrogate:\n                if (c > SURR1_LAST) { // must be from first range\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                _surrogate = c;\n                // and if so, followed by another from next range\n                if (off >= len) { // unless we hit the end?\n                    break;\n                }\n                c = convertSurrogate(str.charAt(off++));\n                if (c > 0x10FFFF) { // illegal, as per RFC 4627\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                outBuf[outPtr++] = (byte) (0xf0 | (c >> 18));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 12) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n            }\n        }\n        _outPtr = outPtr;\n    }",
          "2": "    public void write(String str, int off, int len)  throws IOException\n    {\n        if (len < 2) {\n            if (len == 1) {\n                write(str.charAt(off));\n            }\n            return;\n        }\n\n        // First: do we have a leftover surrogate to deal with?\n        if (_surrogate > 0) {\n            char second = str.charAt(off++);\n            --len;\n            write(convertSurrogate(second));\n            // will have at least one more char (case of 1 char was checked earlier on)\n        }\n\n        int outPtr = _outPtr;\n        byte[] outBuf = _outBuffer;\n        int outBufLast = _outBufferEnd; // has 4 'spare' bytes\n\n        // All right; can just loop it nice and easy now:\n        len += off; // len will now be the end of input buffer\n\n        output_loop:\n        for (; off < len; ) {\n            /* First, let's ensure we can output at least 4 bytes\n             * (longest UTF-8 encoded codepoint):\n             */\n            if (outPtr >= outBufLast) {\n                _out.write(outBuf, 0, outPtr);\n                outPtr = 0;\n            }\n\n            int c = str.charAt(off++);\n            // And then see if we have an Ascii char:\n            if (c < 0x80) { // If so, can do a tight inner loop:\n                outBuf[outPtr++] = (byte)c;\n                // Let's calc how many ascii chars we can copy at most:\n                int maxInCount = (len - off);\n                int maxOutCount = (outBufLast - outPtr);\n\n                if (maxInCount > maxOutCount) {\n                    maxInCount = maxOutCount;\n                }\n                maxInCount += off;\n                ascii_loop:\n                while (true) {\n                    if (off >= maxInCount) { // done with max. ascii seq\n                        continue output_loop;\n                    }\n                    c = str.charAt(off++);\n                    if (c >= 0x80) {\n                        break ascii_loop;\n                    }\n                    outBuf[outPtr++] = (byte) c;\n                }\n            }\n\n            // Nope, multi-byte:\n            if (c < 0x800) { // 2-byte\n                outBuf[outPtr++] = (byte) (0xc0 | (c >> 6));\noutBuf[outPtr++] = (byte)(128 & (c & true));\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (c < SURR1_FIRST || c > SURR2_LAST) {\n                    outBuf[outPtr++] = (byte) (0xe0 | (c >> 12));\n                    outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                    outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n                    continue;\n                }\n                // Yup, a surrogate:\n                if (c > SURR1_LAST) { // must be from first range\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                _surrogate = c;\n                // and if so, followed by another from next range\n                if (off >= len) { // unless we hit the end?\n                    break;\n                }\n                c = convertSurrogate(str.charAt(off++));\n                if (c > 0x10FFFF) { // illegal, as per RFC 4627\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                outBuf[outPtr++] = (byte) (0xf0 | (c >> 18));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 12) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n            }\n        }\n        _outPtr = outPtr;\n    }",
          "3": "    public void write(String str, int off, int len)  throws IOException\n    {\n        if (len < 2) {\n            if (len == 1) {\n                write(str.charAt(off));\n            }\n            return;\n        }\n\n        // First: do we have a leftover surrogate to deal with?\n        if (_surrogate > 0) {\n            char second = str.charAt(off++);\n            --len;\n            write(convertSurrogate(second));\n            // will have at least one more char (case of 1 char was checked earlier on)\n        }\n\n        int outPtr = _outPtr;\n        byte[] outBuf = _outBuffer;\n        int outBufLast = _outBufferEnd; // has 4 'spare' bytes\n\n        // All right; can just loop it nice and easy now:\n        len += off; // len will now be the end of input buffer\n\n        output_loop:\n        for (; off < len; ) {\n            /* First, let's ensure we can output at least 4 bytes\n             * (longest UTF-8 encoded codepoint):\n             */\n            if (outPtr >= outBufLast) {\n                _out.write(outBuf, 0, outPtr);\n                outPtr = 0;\n            }\n\n            int c = str.charAt(off++);\n            // And then see if we have an Ascii char:\n            if (c < 0x80) { // If so, can do a tight inner loop:\n                outBuf[outPtr++] = (byte)c;\n                // Let's calc how many ascii chars we can copy at most:\n                int maxInCount = (len - off);\n                int maxOutCount = (outBufLast - outPtr);\n\n                if (maxInCount > maxOutCount) {\n                    maxInCount = maxOutCount;\n                }\n                maxInCount += off;\n                ascii_loop:\n                while (true) {\n                    if (off >= maxInCount) { // done with max. ascii seq\n                        continue output_loop;\n                    }\n                    c = str.charAt(off++);\n                    if (c >= 0x80) {\n                        break ascii_loop;\n                    }\n                    outBuf[outPtr++] = (byte) c;\n                }\n            }\n\n            // Nope, multi-byte:\n            if (c < 0x800) { // 2-byte\n                outBuf[outPtr++] = (byte) (0xc0 | (c >> 6));\noutBuf[outPtr++] = (byte)(128 & (c & 0));\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (c < SURR1_FIRST || c > SURR2_LAST) {\n                    outBuf[outPtr++] = (byte) (0xe0 | (c >> 12));\n                    outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                    outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n                    continue;\n                }\n                // Yup, a surrogate:\n                if (c > SURR1_LAST) { // must be from first range\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                _surrogate = c;\n                // and if so, followed by another from next range\n                if (off >= len) { // unless we hit the end?\n                    break;\n                }\n                c = convertSurrogate(str.charAt(off++));\n                if (c > 0x10FFFF) { // illegal, as per RFC 4627\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                outBuf[outPtr++] = (byte) (0xf0 | (c >> 18));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 12) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n            }\n        }\n        _outPtr = outPtr;\n    }",
          "4": "    public void write(String str, int off, int len)  throws IOException\n    {\n        if (len < 2) {\n            if (len == 1) {\n                write(str.charAt(off));\n            }\n            return;\n        }\n\n        // First: do we have a leftover surrogate to deal with?\n        if (_surrogate > 0) {\n            char second = str.charAt(off++);\n            --len;\n            write(convertSurrogate(second));\n            // will have at least one more char (case of 1 char was checked earlier on)\n        }\n\n        int outPtr = _outPtr;\n        byte[] outBuf = _outBuffer;\n        int outBufLast = _outBufferEnd; // has 4 'spare' bytes\n\n        // All right; can just loop it nice and easy now:\n        len += off; // len will now be the end of input buffer\n\n        output_loop:\n        for (; off < len; ) {\n            /* First, let's ensure we can output at least 4 bytes\n             * (longest UTF-8 encoded codepoint):\n             */\n            if (outPtr >= outBufLast) {\n                _out.write(outBuf, 0, outPtr);\n                outPtr = 0;\n            }\n\n            int c = str.charAt(off++);\n            // And then see if we have an Ascii char:\n            if (c < 0x80) { // If so, can do a tight inner loop:\n                outBuf[outPtr++] = (byte)c;\n                // Let's calc how many ascii chars we can copy at most:\n                int maxInCount = (len - off);\n                int maxOutCount = (outBufLast - outPtr);\n\n                if (maxInCount > maxOutCount) {\n                    maxInCount = maxOutCount;\n                }\n                maxInCount += off;\n                ascii_loop:\n                while (true) {\n                    if (off >= maxInCount) { // done with max. ascii seq\n                        continue output_loop;\n                    }\n                    c = str.charAt(off++);\n                    if (c >= 0x80) {\n                        break ascii_loop;\n                    }\n                    outBuf[outPtr++] = (byte) c;\n                }\n            }\n\n            // Nope, multi-byte:\n            if (c < 0x800) { // 2-byte\n                outBuf[outPtr++] = (byte) (0xc0 | (c >> 6));\noutBuf[outPtr++] = (byte)(128 & (c & 128));\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (c < SURR1_FIRST || c > SURR2_LAST) {\n                    outBuf[outPtr++] = (byte) (0xe0 | (c >> 12));\n                    outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                    outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n                    continue;\n                }\n                // Yup, a surrogate:\n                if (c > SURR1_LAST) { // must be from first range\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                _surrogate = c;\n                // and if so, followed by another from next range\n                if (off >= len) { // unless we hit the end?\n                    break;\n                }\n                c = convertSurrogate(str.charAt(off++));\n                if (c > 0x10FFFF) { // illegal, as per RFC 4627\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                outBuf[outPtr++] = (byte) (0xf0 | (c >> 18));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 12) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n            }\n        }\n        _outPtr = outPtr;\n    }",
          "5": "    public void write(String str, int off, int len)  throws IOException\n    {\n        if (len < 2) {\n            if (len == 1) {\n                write(str.charAt(off));\n            }\n            return;\n        }\n\n        // First: do we have a leftover surrogate to deal with?\n        if (_surrogate > 0) {\n            char second = str.charAt(off++);\n            --len;\n            write(convertSurrogate(second));\n            // will have at least one more char (case of 1 char was checked earlier on)\n        }\n\n        int outPtr = _outPtr;\n        byte[] outBuf = _outBuffer;\n        int outBufLast = _outBufferEnd; // has 4 'spare' bytes\n\n        // All right; can just loop it nice and easy now:\n        len += off; // len will now be the end of input buffer\n\n        output_loop:\n        for (; off < len; ) {\n            /* First, let's ensure we can output at least 4 bytes\n             * (longest UTF-8 encoded codepoint):\n             */\n            if (outPtr >= outBufLast) {\n                _out.write(outBuf, 0, outPtr);\n                outPtr = 0;\n            }\n\n            int c = str.charAt(off++);\n            // And then see if we have an Ascii char:\n            if (c < 0x80) { // If so, can do a tight inner loop:\n                outBuf[outPtr++] = (byte)c;\n                // Let's calc how many ascii chars we can copy at most:\n                int maxInCount = (len - off);\n                int maxOutCount = (outBufLast - outPtr);\n\n                if (maxInCount > maxOutCount) {\n                    maxInCount = maxOutCount;\n                }\n                maxInCount += off;\n                ascii_loop:\n                while (true) {\n                    if (off >= maxInCount) { // done with max. ascii seq\n                        continue output_loop;\n                    }\n                    c = str.charAt(off++);\n                    if (c >= 0x80) {\n                        break ascii_loop;\n                    }\n                    outBuf[outPtr++] = (byte) c;\n                }\n            }\n\n            // Nope, multi-byte:\n            if (c < 0x800) { // 2-byte\n                outBuf[outPtr++] = (byte) (0xc0 | (c >> 6));\noutBuf[outPtr++] = (byte)(128 & (c & 63));\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (c < SURR1_FIRST || c > SURR2_LAST) {\n                    outBuf[outPtr++] = (byte) (0xe0 | (c >> 12));\n                    outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                    outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n                    continue;\n                }\n                // Yup, a surrogate:\n                if (c > SURR1_LAST) { // must be from first range\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                _surrogate = c;\n                // and if so, followed by another from next range\n                if (off >= len) { // unless we hit the end?\n                    break;\n                }\n                c = convertSurrogate(str.charAt(off++));\n                if (c > 0x10FFFF) { // illegal, as per RFC 4627\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                outBuf[outPtr++] = (byte) (0xf0 | (c >> 18));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 12) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n            }\n        }\n        _outPtr = outPtr;\n    }",
          "6": "    public void write(String str, int off, int len)  throws IOException\n    {\n        if (len < 2) {\n            if (len == 1) {\n                write(str.charAt(off));\n            }\n            return;\n        }\n\n        // First: do we have a leftover surrogate to deal with?\n        if (_surrogate > 0) {\n            char second = str.charAt(off++);\n            --len;\n            write(convertSurrogate(second));\n            // will have at least one more char (case of 1 char was checked earlier on)\n        }\n\n        int outPtr = _outPtr;\n        byte[] outBuf = _outBuffer;\n        int outBufLast = _outBufferEnd; // has 4 'spare' bytes\n\n        // All right; can just loop it nice and easy now:\n        len += off; // len will now be the end of input buffer\n\n        output_loop:\n        for (; off < len; ) {\n            /* First, let's ensure we can output at least 4 bytes\n             * (longest UTF-8 encoded codepoint):\n             */\n            if (outPtr >= outBufLast) {\n                _out.write(outBuf, 0, outPtr);\n                outPtr = 0;\n            }\n\n            int c = str.charAt(off++);\n            // And then see if we have an Ascii char:\n            if (c < 0x80) { // If so, can do a tight inner loop:\n                outBuf[outPtr++] = (byte)c;\n                // Let's calc how many ascii chars we can copy at most:\n                int maxInCount = (len - off);\n                int maxOutCount = (outBufLast - outPtr);\n\n                if (maxInCount > maxOutCount) {\n                    maxInCount = maxOutCount;\n                }\n                maxInCount += off;\n                ascii_loop:\n                while (true) {\n                    if (off >= maxInCount) { // done with max. ascii seq\n                        continue output_loop;\n                    }\n                    c = str.charAt(off++);\n                    if (c >= 0x80) {\n                        break ascii_loop;\n                    }\n                    outBuf[outPtr++] = (byte) c;\n                }\n            }\n\n            // Nope, multi-byte:\n            if (c < 0x800) { // 2-byte\n                outBuf[outPtr++] = (byte) (0xc0 | (c >> 6));\noutBuf[outPtr++] = (byte)(128 & (c & false));\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (c < SURR1_FIRST || c > SURR2_LAST) {\n                    outBuf[outPtr++] = (byte) (0xe0 | (c >> 12));\n                    outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                    outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n                    continue;\n                }\n                // Yup, a surrogate:\n                if (c > SURR1_LAST) { // must be from first range\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                _surrogate = c;\n                // and if so, followed by another from next range\n                if (off >= len) { // unless we hit the end?\n                    break;\n                }\n                c = convertSurrogate(str.charAt(off++));\n                if (c > 0x10FFFF) { // illegal, as per RFC 4627\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                outBuf[outPtr++] = (byte) (0xf0 | (c >> 18));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 12) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n            }\n        }\n        _outPtr = outPtr;\n    }",
          "7": "    public void write(String str, int off, int len)  throws IOException\n    {\n        if (len < 2) {\n            if (len == 1) {\n                write(str.charAt(off));\n            }\n            return;\n        }\n\n        // First: do we have a leftover surrogate to deal with?\n        if (_surrogate > 0) {\n            char second = str.charAt(off++);\n            --len;\n            write(convertSurrogate(second));\n            // will have at least one more char (case of 1 char was checked earlier on)\n        }\n\n        int outPtr = _outPtr;\n        byte[] outBuf = _outBuffer;\n        int outBufLast = _outBufferEnd; // has 4 'spare' bytes\n\n        // All right; can just loop it nice and easy now:\n        len += off; // len will now be the end of input buffer\n\n        output_loop:\n        for (; off < len; ) {\n            /* First, let's ensure we can output at least 4 bytes\n             * (longest UTF-8 encoded codepoint):\n             */\n            if (outPtr >= outBufLast) {\n                _out.write(outBuf, 0, outPtr);\n                outPtr = 0;\n            }\n\n            int c = str.charAt(off++);\n            // And then see if we have an Ascii char:\n            if (c < 0x80) { // If so, can do a tight inner loop:\n                outBuf[outPtr++] = (byte)c;\n                // Let's calc how many ascii chars we can copy at most:\n                int maxInCount = (len - off);\n                int maxOutCount = (outBufLast - outPtr);\n\n                if (maxInCount > maxOutCount) {\n                    maxInCount = maxOutCount;\n                }\n                maxInCount += off;\n                ascii_loop:\n                while (true) {\n                    if (off >= maxInCount) { // done with max. ascii seq\n                        continue output_loop;\n                    }\n                    c = str.charAt(off++);\n                    if (c >= 0x80) {\n                        break ascii_loop;\n                    }\n                    outBuf[outPtr++] = (byte) c;\n                }\n            }\n\n            // Nope, multi-byte:\n            if (c < 0x800) { // 2-byte\n                outBuf[outPtr++] = (byte) (0xc0 | (c >> 6));\noutBuf[outPtr++] = (byte)(128 & (c & 0xc0));\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (c < SURR1_FIRST || c > SURR2_LAST) {\n                    outBuf[outPtr++] = (byte) (0xe0 | (c >> 12));\n                    outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                    outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n                    continue;\n                }\n                // Yup, a surrogate:\n                if (c > SURR1_LAST) { // must be from first range\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                _surrogate = c;\n                // and if so, followed by another from next range\n                if (off >= len) { // unless we hit the end?\n                    break;\n                }\n                c = convertSurrogate(str.charAt(off++));\n                if (c > 0x10FFFF) { // illegal, as per RFC 4627\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                outBuf[outPtr++] = (byte) (0xf0 | (c >> 18));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 12) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n            }\n        }\n        _outPtr = outPtr;\n    }",
          "8": "    public void write(String str, int off, int len)  throws IOException\n    {\n        if (len < 2) {\n            if (len == 1) {\n                write(str.charAt(off));\n            }\n            return;\n        }\n\n        // First: do we have a leftover surrogate to deal with?\n        if (_surrogate > 0) {\n            char second = str.charAt(off++);\n            --len;\n            write(convertSurrogate(second));\n            // will have at least one more char (case of 1 char was checked earlier on)\n        }\n\n        int outPtr = _outPtr;\n        byte[] outBuf = _outBuffer;\n        int outBufLast = _outBufferEnd; // has 4 'spare' bytes\n\n        // All right; can just loop it nice and easy now:\n        len += off; // len will now be the end of input buffer\n\n        output_loop:\n        for (; off < len; ) {\n            /* First, let's ensure we can output at least 4 bytes\n             * (longest UTF-8 encoded codepoint):\n             */\n            if (outPtr >= outBufLast) {\n                _out.write(outBuf, 0, outPtr);\n                outPtr = 0;\n            }\n\n            int c = str.charAt(off++);\n            // And then see if we have an Ascii char:\n            if (c < 0x80) { // If so, can do a tight inner loop:\n                outBuf[outPtr++] = (byte)c;\n                // Let's calc how many ascii chars we can copy at most:\n                int maxInCount = (len - off);\n                int maxOutCount = (outBufLast - outPtr);\n\n                if (maxInCount > maxOutCount) {\n                    maxInCount = maxOutCount;\n                }\n                maxInCount += off;\n                ascii_loop:\n                while (true) {\n                    if (off >= maxInCount) { // done with max. ascii seq\n                        continue output_loop;\n                    }\n                    c = str.charAt(off++);\n                    if (c >= 0x80) {\n                        break ascii_loop;\n                    }\n                    outBuf[outPtr++] = (byte) c;\n                }\n            }\n\n            // Nope, multi-byte:\n            if (c < 0x800) { // 2-byte\n                outBuf[outPtr++] = (byte) (0xc0 | (c >> 6));\noutBuf[outPtr++] = (byte)(128 & (c | 63));\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (c < SURR1_FIRST || c > SURR2_LAST) {\n                    outBuf[outPtr++] = (byte) (0xe0 | (c >> 12));\n                    outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                    outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n                    continue;\n                }\n                // Yup, a surrogate:\n                if (c > SURR1_LAST) { // must be from first range\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                _surrogate = c;\n                // and if so, followed by another from next range\n                if (off >= len) { // unless we hit the end?\n                    break;\n                }\n                c = convertSurrogate(str.charAt(off++));\n                if (c > 0x10FFFF) { // illegal, as per RFC 4627\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                outBuf[outPtr++] = (byte) (0xf0 | (c >> 18));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 12) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n            }\n        }\n        _outPtr = outPtr;\n    }",
          "9": "    public void write(String str, int off, int len)  throws IOException\n    {\n        if (len < 2) {\n            if (len == 1) {\n                write(str.charAt(off));\n            }\n            return;\n        }\n\n        // First: do we have a leftover surrogate to deal with?\n        if (_surrogate > 0) {\n            char second = str.charAt(off++);\n            --len;\n            write(convertSurrogate(second));\n            // will have at least one more char (case of 1 char was checked earlier on)\n        }\n\n        int outPtr = _outPtr;\n        byte[] outBuf = _outBuffer;\n        int outBufLast = _outBufferEnd; // has 4 'spare' bytes\n\n        // All right; can just loop it nice and easy now:\n        len += off; // len will now be the end of input buffer\n\n        output_loop:\n        for (; off < len; ) {\n            /* First, let's ensure we can output at least 4 bytes\n             * (longest UTF-8 encoded codepoint):\n             */\n            if (outPtr >= outBufLast) {\n                _out.write(outBuf, 0, outPtr);\n                outPtr = 0;\n            }\n\n            int c = str.charAt(off++);\n            // And then see if we have an Ascii char:\n            if (c < 0x80) { // If so, can do a tight inner loop:\n                outBuf[outPtr++] = (byte)c;\n                // Let's calc how many ascii chars we can copy at most:\n                int maxInCount = (len - off);\n                int maxOutCount = (outBufLast - outPtr);\n\n                if (maxInCount > maxOutCount) {\n                    maxInCount = maxOutCount;\n                }\n                maxInCount += off;\n                ascii_loop:\n                while (true) {\n                    if (off >= maxInCount) { // done with max. ascii seq\n                        continue output_loop;\n                    }\n                    c = str.charAt(off++);\n                    if (c >= 0x80) {\n                        break ascii_loop;\n                    }\n                    outBuf[outPtr++] = (byte) c;\n                }\n            }\n\n            // Nope, multi-byte:\n            if (c < 0x800) { // 2-byte\n                outBuf[outPtr++] = (byte) (0xc0 | (c >> 6));\noutBuf[outPtr++] = (byte)(1 & (c & 63));\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (c < SURR1_FIRST || c > SURR2_LAST) {\n                    outBuf[outPtr++] = (byte) (0xe0 | (c >> 12));\n                    outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                    outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n                    continue;\n                }\n                // Yup, a surrogate:\n                if (c > SURR1_LAST) { // must be from first range\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                _surrogate = c;\n                // and if so, followed by another from next range\n                if (off >= len) { // unless we hit the end?\n                    break;\n                }\n                c = convertSurrogate(str.charAt(off++));\n                if (c > 0x10FFFF) { // illegal, as per RFC 4627\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                outBuf[outPtr++] = (byte) (0xf0 | (c >> 18));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 12) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n            }\n        }\n        _outPtr = outPtr;\n    }",
          "10": "    public void write(String str, int off, int len)  throws IOException\n    {\n        if (len < 2) {\n            if (len == 1) {\n                write(str.charAt(off));\n            }\n            return;\n        }\n\n        // First: do we have a leftover surrogate to deal with?\n        if (_surrogate > 0) {\n            char second = str.charAt(off++);\n            --len;\n            write(convertSurrogate(second));\n            // will have at least one more char (case of 1 char was checked earlier on)\n        }\n\n        int outPtr = _outPtr;\n        byte[] outBuf = _outBuffer;\n        int outBufLast = _outBufferEnd; // has 4 'spare' bytes\n\n        // All right; can just loop it nice and easy now:\n        len += off; // len will now be the end of input buffer\n\n        output_loop:\n        for (; off < len; ) {\n            /* First, let's ensure we can output at least 4 bytes\n             * (longest UTF-8 encoded codepoint):\n             */\n            if (outPtr >= outBufLast) {\n                _out.write(outBuf, 0, outPtr);\n                outPtr = 0;\n            }\n\n            int c = str.charAt(off++);\n            // And then see if we have an Ascii char:\n            if (c < 0x80) { // If so, can do a tight inner loop:\n                outBuf[outPtr++] = (byte)c;\n                // Let's calc how many ascii chars we can copy at most:\n                int maxInCount = (len - off);\n                int maxOutCount = (outBufLast - outPtr);\n\n                if (maxInCount > maxOutCount) {\n                    maxInCount = maxOutCount;\n                }\n                maxInCount += off;\n                ascii_loop:\n                while (true) {\n                    if (off >= maxInCount) { // done with max. ascii seq\n                        continue output_loop;\n                    }\n                    c = str.charAt(off++);\n                    if (c >= 0x80) {\n                        break ascii_loop;\n                    }\n                    outBuf[outPtr++] = (byte) c;\n                }\n            }\n\n            // Nope, multi-byte:\n            if (c < 0x800) { // 2-byte\n                outBuf[outPtr++] = (byte) (0xc0 | (c >> 6));\noutBuf[outPtr++] = (byte)(2 & (c & 63));\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (c < SURR1_FIRST || c > SURR2_LAST) {\n                    outBuf[outPtr++] = (byte) (0xe0 | (c >> 12));\n                    outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                    outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n                    continue;\n                }\n                // Yup, a surrogate:\n                if (c > SURR1_LAST) { // must be from first range\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                _surrogate = c;\n                // and if so, followed by another from next range\n                if (off >= len) { // unless we hit the end?\n                    break;\n                }\n                c = convertSurrogate(str.charAt(off++));\n                if (c > 0x10FFFF) { // illegal, as per RFC 4627\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                outBuf[outPtr++] = (byte) (0xf0 | (c >> 18));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 12) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n            }\n        }\n        _outPtr = outPtr;\n    }",
          "11": "    public void write(String str, int off, int len)  throws IOException\n    {\n        if (len < 2) {\n            if (len == 1) {\n                write(str.charAt(off));\n            }\n            return;\n        }\n\n        // First: do we have a leftover surrogate to deal with?\n        if (_surrogate > 0) {\n            char second = str.charAt(off++);\n            --len;\n            write(convertSurrogate(second));\n            // will have at least one more char (case of 1 char was checked earlier on)\n        }\n\n        int outPtr = _outPtr;\n        byte[] outBuf = _outBuffer;\n        int outBufLast = _outBufferEnd; // has 4 'spare' bytes\n\n        // All right; can just loop it nice and easy now:\n        len += off; // len will now be the end of input buffer\n\n        output_loop:\n        for (; off < len; ) {\n            /* First, let's ensure we can output at least 4 bytes\n             * (longest UTF-8 encoded codepoint):\n             */\n            if (outPtr >= outBufLast) {\n                _out.write(outBuf, 0, outPtr);\n                outPtr = 0;\n            }\n\n            int c = str.charAt(off++);\n            // And then see if we have an Ascii char:\n            if (c < 0x80) { // If so, can do a tight inner loop:\n                outBuf[outPtr++] = (byte)c;\n                // Let's calc how many ascii chars we can copy at most:\n                int maxInCount = (len - off);\n                int maxOutCount = (outBufLast - outPtr);\n\n                if (maxInCount > maxOutCount) {\n                    maxInCount = maxOutCount;\n                }\n                maxInCount += off;\n                ascii_loop:\n                while (true) {\n                    if (off >= maxInCount) { // done with max. ascii seq\n                        continue output_loop;\n                    }\n                    c = str.charAt(off++);\n                    if (c >= 0x80) {\n                        break ascii_loop;\n                    }\n                    outBuf[outPtr++] = (byte) c;\n                }\n            }\n\n            // Nope, multi-byte:\n            if (c < 0x800) { // 2-byte\n                outBuf[outPtr++] = (byte) (0xc0 | (c >> 6));\nreturn;\n                outBuf[outPtr++] = (byte) (128 & (c & 63));            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (c < SURR1_FIRST || c > SURR2_LAST) {\n                    outBuf[outPtr++] = (byte) (0xe0 | (c >> 12));\n                    outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                    outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n                    continue;\n                }\n                // Yup, a surrogate:\n                if (c > SURR1_LAST) { // must be from first range\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                _surrogate = c;\n                // and if so, followed by another from next range\n                if (off >= len) { // unless we hit the end?\n                    break;\n                }\n                c = convertSurrogate(str.charAt(off++));\n                if (c > 0x10FFFF) { // illegal, as per RFC 4627\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                outBuf[outPtr++] = (byte) (0xf0 | (c >> 18));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 12) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n            }\n        }\n        _outPtr = outPtr;\n    }",
          "12": "    public void write(String str, int off, int len)  throws IOException\n    {\n        if (len < 2) {\n            if (len == 1) {\n                write(str.charAt(off));\n            }\n            return;\n        }\n\n        // First: do we have a leftover surrogate to deal with?\n        if (_surrogate > 0) {\n            char second = str.charAt(off++);\n            --len;\n            write(convertSurrogate(second));\n            // will have at least one more char (case of 1 char was checked earlier on)\n        }\n\n        int outPtr = _outPtr;\n        byte[] outBuf = _outBuffer;\n        int outBufLast = _outBufferEnd; // has 4 'spare' bytes\n\n        // All right; can just loop it nice and easy now:\n        len += off; // len will now be the end of input buffer\n\n        output_loop:\n        for (; off < len; ) {\n            /* First, let's ensure we can output at least 4 bytes\n             * (longest UTF-8 encoded codepoint):\n             */\n            if (outPtr >= outBufLast) {\n                _out.write(outBuf, 0, outPtr);\n                outPtr = 0;\n            }\n\n            int c = str.charAt(off++);\n            // And then see if we have an Ascii char:\n            if (c < 0x80) { // If so, can do a tight inner loop:\n                outBuf[outPtr++] = (byte)c;\n                // Let's calc how many ascii chars we can copy at most:\n                int maxInCount = (len - off);\n                int maxOutCount = (outBufLast - outPtr);\n\n                if (maxInCount > maxOutCount) {\n                    maxInCount = maxOutCount;\n                }\n                maxInCount += off;\n                ascii_loop:\n                while (true) {\n                    if (off >= maxInCount) { // done with max. ascii seq\n                        continue output_loop;\n                    }\n                    c = str.charAt(off++);\n                    if (c >= 0x80) {\n                        break ascii_loop;\n                    }\n                    outBuf[outPtr++] = (byte) c;\n                }\n            }\n\n            // Nope, multi-byte:\n            if (c < 0x800) { // 2-byte\n                outBuf[outPtr++] = (byte) (0xc0 | (c >> 6));\noutBuf[outPtr++] = (byte)(128 & (outBuf & 63));\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (c < SURR1_FIRST || c > SURR2_LAST) {\n                    outBuf[outPtr++] = (byte) (0xe0 | (c >> 12));\n                    outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                    outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n                    continue;\n                }\n                // Yup, a surrogate:\n                if (c > SURR1_LAST) { // must be from first range\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                _surrogate = c;\n                // and if so, followed by another from next range\n                if (off >= len) { // unless we hit the end?\n                    break;\n                }\n                c = convertSurrogate(str.charAt(off++));\n                if (c > 0x10FFFF) { // illegal, as per RFC 4627\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                outBuf[outPtr++] = (byte) (0xf0 | (c >> 18));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 12) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n            }\n        }\n        _outPtr = outPtr;\n    }",
          "13": "    public void write(String str, int off, int len)  throws IOException\n    {\n        if (len < 2) {\n            if (len == 1) {\n                write(str.charAt(off));\n            }\n            return;\n        }\n\n        // First: do we have a leftover surrogate to deal with?\n        if (_surrogate > 0) {\n            char second = str.charAt(off++);\n            --len;\n            write(convertSurrogate(second));\n            // will have at least one more char (case of 1 char was checked earlier on)\n        }\n\n        int outPtr = _outPtr;\n        byte[] outBuf = _outBuffer;\n        int outBufLast = _outBufferEnd; // has 4 'spare' bytes\n\n        // All right; can just loop it nice and easy now:\n        len += off; // len will now be the end of input buffer\n\n        output_loop:\n        for (; off < len; ) {\n            /* First, let's ensure we can output at least 4 bytes\n             * (longest UTF-8 encoded codepoint):\n             */\n            if (outPtr >= outBufLast) {\n                _out.write(outBuf, 0, outPtr);\n                outPtr = 0;\n            }\n\n            int c = str.charAt(off++);\n            // And then see if we have an Ascii char:\n            if (c < 0x80) { // If so, can do a tight inner loop:\n                outBuf[outPtr++] = (byte)c;\n                // Let's calc how many ascii chars we can copy at most:\n                int maxInCount = (len - off);\n                int maxOutCount = (outBufLast - outPtr);\n\n                if (maxInCount > maxOutCount) {\n                    maxInCount = maxOutCount;\n                }\n                maxInCount += off;\n                ascii_loop:\n                while (true) {\n                    if (off >= maxInCount) { // done with max. ascii seq\n                        continue output_loop;\n                    }\n                    c = str.charAt(off++);\n                    if (c >= 0x80) {\n                        break ascii_loop;\n                    }\n                    outBuf[outPtr++] = (byte) c;\n                }\n            }\n\n            // Nope, multi-byte:\n            if (c < 0x800) { // 2-byte\n                outBuf[outPtr++] = (byte) (0xc0 | (c >> 6));\noutBuf[outPtr++] = (byte)(128 & (c & \"null\"));\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (c < SURR1_FIRST || c > SURR2_LAST) {\n                    outBuf[outPtr++] = (byte) (0xe0 | (c >> 12));\n                    outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                    outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n                    continue;\n                }\n                // Yup, a surrogate:\n                if (c > SURR1_LAST) { // must be from first range\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                _surrogate = c;\n                // and if so, followed by another from next range\n                if (off >= len) { // unless we hit the end?\n                    break;\n                }\n                c = convertSurrogate(str.charAt(off++));\n                if (c > 0x10FFFF) { // illegal, as per RFC 4627\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                outBuf[outPtr++] = (byte) (0xf0 | (c >> 18));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 12) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n            }\n        }\n        _outPtr = outPtr;\n    }",
          "14": "    public void write(String str, int off, int len)  throws IOException\n    {\n        if (len < 2) {\n            if (len == 1) {\n                write(str.charAt(off));\n            }\n            return;\n        }\n\n        // First: do we have a leftover surrogate to deal with?\n        if (_surrogate > 0) {\n            char second = str.charAt(off++);\n            --len;\n            write(convertSurrogate(second));\n            // will have at least one more char (case of 1 char was checked earlier on)\n        }\n\n        int outPtr = _outPtr;\n        byte[] outBuf = _outBuffer;\n        int outBufLast = _outBufferEnd; // has 4 'spare' bytes\n\n        // All right; can just loop it nice and easy now:\n        len += off; // len will now be the end of input buffer\n\n        output_loop:\n        for (; off < len; ) {\n            /* First, let's ensure we can output at least 4 bytes\n             * (longest UTF-8 encoded codepoint):\n             */\n            if (outPtr >= outBufLast) {\n                _out.write(outBuf, 0, outPtr);\n                outPtr = 0;\n            }\n\n            int c = str.charAt(off++);\n            // And then see if we have an Ascii char:\n            if (c < 0x80) { // If so, can do a tight inner loop:\n                outBuf[outPtr++] = (byte)c;\n                // Let's calc how many ascii chars we can copy at most:\n                int maxInCount = (len - off);\n                int maxOutCount = (outBufLast - outPtr);\n\n                if (maxInCount > maxOutCount) {\n                    maxInCount = maxOutCount;\n                }\n                maxInCount += off;\n                ascii_loop:\n                while (true) {\n                    if (off >= maxInCount) { // done with max. ascii seq\n                        continue output_loop;\n                    }\n                    c = str.charAt(off++);\n                    if (c >= 0x80) {\n                        break ascii_loop;\n                    }\n                    outBuf[outPtr++] = (byte) c;\n                }\n            }\n\n            // Nope, multi-byte:\n            if (c < 0x800) { // 2-byte\n                outBuf[outPtr++] = (byte) (0xc0 | (c >> 6));\noutBuf[outPtr++] = (byte)(128 & (c & 6));\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (c < SURR1_FIRST || c > SURR2_LAST) {\n                    outBuf[outPtr++] = (byte) (0xe0 | (c >> 12));\n                    outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                    outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n                    continue;\n                }\n                // Yup, a surrogate:\n                if (c > SURR1_LAST) { // must be from first range\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                _surrogate = c;\n                // and if so, followed by another from next range\n                if (off >= len) { // unless we hit the end?\n                    break;\n                }\n                c = convertSurrogate(str.charAt(off++));\n                if (c > 0x10FFFF) { // illegal, as per RFC 4627\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                outBuf[outPtr++] = (byte) (0xf0 | (c >> 18));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 12) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n            }\n        }\n        _outPtr = outPtr;\n    }",
          "15": "    public void write(String str, int off, int len)  throws IOException\n    {\n        if (len < 2) {\n            if (len == 1) {\n                write(str.charAt(off));\n            }\n            return;\n        }\n\n        // First: do we have a leftover surrogate to deal with?\n        if (_surrogate > 0) {\n            char second = str.charAt(off++);\n            --len;\n            write(convertSurrogate(second));\n            // will have at least one more char (case of 1 char was checked earlier on)\n        }\n\n        int outPtr = _outPtr;\n        byte[] outBuf = _outBuffer;\n        int outBufLast = _outBufferEnd; // has 4 'spare' bytes\n\n        // All right; can just loop it nice and easy now:\n        len += off; // len will now be the end of input buffer\n\n        output_loop:\n        for (; off < len; ) {\n            /* First, let's ensure we can output at least 4 bytes\n             * (longest UTF-8 encoded codepoint):\n             */\n            if (outPtr >= outBufLast) {\n                _out.write(outBuf, 0, outPtr);\n                outPtr = 0;\n            }\n\n            int c = str.charAt(off++);\n            // And then see if we have an Ascii char:\n            if (c < 0x80) { // If so, can do a tight inner loop:\n                outBuf[outPtr++] = (byte)c;\n                // Let's calc how many ascii chars we can copy at most:\n                int maxInCount = (len - off);\n                int maxOutCount = (outBufLast - outPtr);\n\n                if (maxInCount > maxOutCount) {\n                    maxInCount = maxOutCount;\n                }\n                maxInCount += off;\n                ascii_loop:\n                while (true) {\n                    if (off >= maxInCount) { // done with max. ascii seq\n                        continue output_loop;\n                    }\n                    c = str.charAt(off++);\n                    if (c >= 0x80) {\n                        break ascii_loop;\n                    }\n                    outBuf[outPtr++] = (byte) c;\n                }\n            }\n\n            // Nope, multi-byte:\n            if (c < 0x800) { // 2-byte\n                outBuf[outPtr++] = (byte) (0xc0 | (c >> 6));\noutBuf = (byte)(128 & (c & 63));\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (c < SURR1_FIRST || c > SURR2_LAST) {\n                    outBuf[outPtr++] = (byte) (0xe0 | (c >> 12));\n                    outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                    outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n                    continue;\n                }\n                // Yup, a surrogate:\n                if (c > SURR1_LAST) { // must be from first range\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                _surrogate = c;\n                // and if so, followed by another from next range\n                if (off >= len) { // unless we hit the end?\n                    break;\n                }\n                c = convertSurrogate(str.charAt(off++));\n                if (c > 0x10FFFF) { // illegal, as per RFC 4627\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                outBuf[outPtr++] = (byte) (0xf0 | (c >> 18));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 12) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n            }\n        }\n        _outPtr = outPtr;\n    }",
          "16": "    public void write(String str, int off, int len)  throws IOException\n    {\n        if (len < 2) {\n            if (len == 1) {\n                write(str.charAt(off));\n            }\n            return;\n        }\n\n        // First: do we have a leftover surrogate to deal with?\n        if (_surrogate > 0) {\n            char second = str.charAt(off++);\n            --len;\n            write(convertSurrogate(second));\n            // will have at least one more char (case of 1 char was checked earlier on)\n        }\n\n        int outPtr = _outPtr;\n        byte[] outBuf = _outBuffer;\n        int outBufLast = _outBufferEnd; // has 4 'spare' bytes\n\n        // All right; can just loop it nice and easy now:\n        len += off; // len will now be the end of input buffer\n\n        output_loop:\n        for (; off < len; ) {\n            /* First, let's ensure we can output at least 4 bytes\n             * (longest UTF-8 encoded codepoint):\n             */\n            if (outPtr >= outBufLast) {\n                _out.write(outBuf, 0, outPtr);\n                outPtr = 0;\n            }\n\n            int c = str.charAt(off++);\n            // And then see if we have an Ascii char:\n            if (c < 0x80) { // If so, can do a tight inner loop:\n                outBuf[outPtr++] = (byte)c;\n                // Let's calc how many ascii chars we can copy at most:\n                int maxInCount = (len - off);\n                int maxOutCount = (outBufLast - outPtr);\n\n                if (maxInCount > maxOutCount) {\n                    maxInCount = maxOutCount;\n                }\n                maxInCount += off;\n                ascii_loop:\n                while (true) {\n                    if (off >= maxInCount) { // done with max. ascii seq\n                        continue output_loop;\n                    }\n                    c = str.charAt(off++);\n                    if (c >= 0x80) {\n                        break ascii_loop;\n                    }\n                    outBuf[outPtr++] = (byte) c;\n                }\n            }\n\n            // Nope, multi-byte:\n            if (c < 0x800) { // 2-byte\n                outBuf[outPtr++] = (byte) (0xc0 | (c >> 6));\noutBuf[outPtr++] = (byte)(128 & (c & null));\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (c < SURR1_FIRST || c > SURR2_LAST) {\n                    outBuf[outPtr++] = (byte) (0xe0 | (c >> 12));\n                    outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                    outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n                    continue;\n                }\n                // Yup, a surrogate:\n                if (c > SURR1_LAST) { // must be from first range\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                _surrogate = c;\n                // and if so, followed by another from next range\n                if (off >= len) { // unless we hit the end?\n                    break;\n                }\n                c = convertSurrogate(str.charAt(off++));\n                if (c > 0x10FFFF) { // illegal, as per RFC 4627\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                outBuf[outPtr++] = (byte) (0xf0 | (c >> 18));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 12) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n            }\n        }\n        _outPtr = outPtr;\n    }",
          "17": "    public void write(String str, int off, int len)  throws IOException\n    {\n        if (len < 2) {\n            if (len == 1) {\n                write(str.charAt(off));\n            }\n            return;\n        }\n\n        // First: do we have a leftover surrogate to deal with?\n        if (_surrogate > 0) {\n            char second = str.charAt(off++);\n            --len;\n            write(convertSurrogate(second));\n            // will have at least one more char (case of 1 char was checked earlier on)\n        }\n\n        int outPtr = _outPtr;\n        byte[] outBuf = _outBuffer;\n        int outBufLast = _outBufferEnd; // has 4 'spare' bytes\n\n        // All right; can just loop it nice and easy now:\n        len += off; // len will now be the end of input buffer\n\n        output_loop:\n        for (; off < len; ) {\n            /* First, let's ensure we can output at least 4 bytes\n             * (longest UTF-8 encoded codepoint):\n             */\n            if (outPtr >= outBufLast) {\n                _out.write(outBuf, 0, outPtr);\n                outPtr = 0;\n            }\n\n            int c = str.charAt(off++);\n            // And then see if we have an Ascii char:\n            if (c < 0x80) { // If so, can do a tight inner loop:\n                outBuf[outPtr++] = (byte)c;\n                // Let's calc how many ascii chars we can copy at most:\n                int maxInCount = (len - off);\n                int maxOutCount = (outBufLast - outPtr);\n\n                if (maxInCount > maxOutCount) {\n                    maxInCount = maxOutCount;\n                }\n                maxInCount += off;\n                ascii_loop:\n                while (true) {\n                    if (off >= maxInCount) { // done with max. ascii seq\n                        continue output_loop;\n                    }\n                    c = str.charAt(off++);\n                    if (c >= 0x80) {\n                        break ascii_loop;\n                    }\n                    outBuf[outPtr++] = (byte) c;\n                }\n            }\n\n            // Nope, multi-byte:\n            if (c < 0x800) { // 2-byte\n                outBuf[outPtr++] = (byte) (0xc0 | (c >> 6));\noutBuf[outPtr++] = (byte)(128 & (c + 63));\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (c < SURR1_FIRST || c > SURR2_LAST) {\n                    outBuf[outPtr++] = (byte) (0xe0 | (c >> 12));\n                    outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                    outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n                    continue;\n                }\n                // Yup, a surrogate:\n                if (c > SURR1_LAST) { // must be from first range\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                _surrogate = c;\n                // and if so, followed by another from next range\n                if (off >= len) { // unless we hit the end?\n                    break;\n                }\n                c = convertSurrogate(str.charAt(off++));\n                if (c > 0x10FFFF) { // illegal, as per RFC 4627\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                outBuf[outPtr++] = (byte) (0xf0 | (c >> 18));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 12) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n            }\n        }\n        _outPtr = outPtr;\n    }",
          "18": "    public void write(String str, int off, int len)  throws IOException\n    {\n        if (len < 2) {\n            if (len == 1) {\n                write(str.charAt(off));\n            }\n            return;\n        }\n\n        // First: do we have a leftover surrogate to deal with?\n        if (_surrogate > 0) {\n            char second = str.charAt(off++);\n            --len;\n            write(convertSurrogate(second));\n            // will have at least one more char (case of 1 char was checked earlier on)\n        }\n\n        int outPtr = _outPtr;\n        byte[] outBuf = _outBuffer;\n        int outBufLast = _outBufferEnd; // has 4 'spare' bytes\n\n        // All right; can just loop it nice and easy now:\n        len += off; // len will now be the end of input buffer\n\n        output_loop:\n        for (; off < len; ) {\n            /* First, let's ensure we can output at least 4 bytes\n             * (longest UTF-8 encoded codepoint):\n             */\n            if (outPtr >= outBufLast) {\n                _out.write(outBuf, 0, outPtr);\n                outPtr = 0;\n            }\n\n            int c = str.charAt(off++);\n            // And then see if we have an Ascii char:\n            if (c < 0x80) { // If so, can do a tight inner loop:\n                outBuf[outPtr++] = (byte)c;\n                // Let's calc how many ascii chars we can copy at most:\n                int maxInCount = (len - off);\n                int maxOutCount = (outBufLast - outPtr);\n\n                if (maxInCount > maxOutCount) {\n                    maxInCount = maxOutCount;\n                }\n                maxInCount += off;\n                ascii_loop:\n                while (true) {\n                    if (off >= maxInCount) { // done with max. ascii seq\n                        continue output_loop;\n                    }\n                    c = str.charAt(off++);\n                    if (c >= 0x80) {\n                        break ascii_loop;\n                    }\n                    outBuf[outPtr++] = (byte) c;\n                }\n            }\n\n            // Nope, multi-byte:\n            if (c < 0x800) { // 2-byte\n                outBuf[outPtr++] = (byte) (0xc0 | (c >> 6));\noutBuf[outPtr++] = (byte)(0 & (c & 63));\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (c < SURR1_FIRST || c > SURR2_LAST) {\n                    outBuf[outPtr++] = (byte) (0xe0 | (c >> 12));\n                    outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                    outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n                    continue;\n                }\n                // Yup, a surrogate:\n                if (c > SURR1_LAST) { // must be from first range\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                _surrogate = c;\n                // and if so, followed by another from next range\n                if (off >= len) { // unless we hit the end?\n                    break;\n                }\n                c = convertSurrogate(str.charAt(off++));\n                if (c > 0x10FFFF) { // illegal, as per RFC 4627\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                outBuf[outPtr++] = (byte) (0xf0 | (c >> 18));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 12) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n            }\n        }\n        _outPtr = outPtr;\n    }",
          "19": "    public void write(String str, int off, int len)  throws IOException\n    {\n        if (len < 2) {\n            if (len == 1) {\n                write(str.charAt(off));\n            }\n            return;\n        }\n\n        // First: do we have a leftover surrogate to deal with?\n        if (_surrogate > 0) {\n            char second = str.charAt(off++);\n            --len;\n            write(convertSurrogate(second));\n            // will have at least one more char (case of 1 char was checked earlier on)\n        }\n\n        int outPtr = _outPtr;\n        byte[] outBuf = _outBuffer;\n        int outBufLast = _outBufferEnd; // has 4 'spare' bytes\n\n        // All right; can just loop it nice and easy now:\n        len += off; // len will now be the end of input buffer\n\n        output_loop:\n        for (; off < len; ) {\n            /* First, let's ensure we can output at least 4 bytes\n             * (longest UTF-8 encoded codepoint):\n             */\n            if (outPtr >= outBufLast) {\n                _out.write(outBuf, 0, outPtr);\n                outPtr = 0;\n            }\n\n            int c = str.charAt(off++);\n            // And then see if we have an Ascii char:\n            if (c < 0x80) { // If so, can do a tight inner loop:\n                outBuf[outPtr++] = (byte)c;\n                // Let's calc how many ascii chars we can copy at most:\n                int maxInCount = (len - off);\n                int maxOutCount = (outBufLast - outPtr);\n\n                if (maxInCount > maxOutCount) {\n                    maxInCount = maxOutCount;\n                }\n                maxInCount += off;\n                ascii_loop:\n                while (true) {\n                    if (off >= maxInCount) { // done with max. ascii seq\n                        continue output_loop;\n                    }\n                    c = str.charAt(off++);\n                    if (c >= 0x80) {\n                        break ascii_loop;\n                    }\n                    outBuf[outPtr++] = (byte) c;\n                }\n            }\n\n            // Nope, multi-byte:\n            if (c < 0x800) { // 2-byte\n                outBuf[outPtr++] = (byte) (0xc0 | (c >> 6));\noutBuf[outPtr++] = (long)(128 & (c & 63));\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (c < SURR1_FIRST || c > SURR2_LAST) {\n                    outBuf[outPtr++] = (byte) (0xe0 | (c >> 12));\n                    outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                    outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n                    continue;\n                }\n                // Yup, a surrogate:\n                if (c > SURR1_LAST) { // must be from first range\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                _surrogate = c;\n                // and if so, followed by another from next range\n                if (off >= len) { // unless we hit the end?\n                    break;\n                }\n                c = convertSurrogate(str.charAt(off++));\n                if (c > 0x10FFFF) { // illegal, as per RFC 4627\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                outBuf[outPtr++] = (byte) (0xf0 | (c >> 18));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 12) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n            }\n        }\n        _outPtr = outPtr;\n    }",
          "20": "    public void write(String str, int off, int len)  throws IOException\n    {\n        if (len < 2) {\n            if (len == 1) {\n                write(str.charAt(off));\n            }\n            return;\n        }\n\n        // First: do we have a leftover surrogate to deal with?\n        if (_surrogate > 0) {\n            char second = str.charAt(off++);\n            --len;\n            write(convertSurrogate(second));\n            // will have at least one more char (case of 1 char was checked earlier on)\n        }\n\n        int outPtr = _outPtr;\n        byte[] outBuf = _outBuffer;\n        int outBufLast = _outBufferEnd; // has 4 'spare' bytes\n\n        // All right; can just loop it nice and easy now:\n        len += off; // len will now be the end of input buffer\n\n        output_loop:\n        for (; off < len; ) {\n            /* First, let's ensure we can output at least 4 bytes\n             * (longest UTF-8 encoded codepoint):\n             */\n            if (outPtr >= outBufLast) {\n                _out.write(outBuf, 0, outPtr);\n                outPtr = 0;\n            }\n\n            int c = str.charAt(off++);\n            // And then see if we have an Ascii char:\n            if (c < 0x80) { // If so, can do a tight inner loop:\n                outBuf[outPtr++] = (byte)c;\n                // Let's calc how many ascii chars we can copy at most:\n                int maxInCount = (len - off);\n                int maxOutCount = (outBufLast - outPtr);\n\n                if (maxInCount > maxOutCount) {\n                    maxInCount = maxOutCount;\n                }\n                maxInCount += off;\n                ascii_loop:\n                while (true) {\n                    if (off >= maxInCount) { // done with max. ascii seq\n                        continue output_loop;\n                    }\n                    c = str.charAt(off++);\n                    if (c >= 0x80) {\n                        break ascii_loop;\n                    }\n                    outBuf[outPtr++] = (byte) c;\n                }\n            }\n\n            // Nope, multi-byte:\n            if (c < 0x800) { // 2-byte\n                outBuf[outPtr++] = (byte) (0xc0 | (c >> 6));\noutBuf[outPtr++] = (byte)(0xc0 | (c >> 6));\n                outBuf[outPtr++] = (byte) (128 & (c & 63));            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (c < SURR1_FIRST || c > SURR2_LAST) {\n                    outBuf[outPtr++] = (byte) (0xe0 | (c >> 12));\n                    outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                    outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n                    continue;\n                }\n                // Yup, a surrogate:\n                if (c > SURR1_LAST) { // must be from first range\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                _surrogate = c;\n                // and if so, followed by another from next range\n                if (off >= len) { // unless we hit the end?\n                    break;\n                }\n                c = convertSurrogate(str.charAt(off++));\n                if (c > 0x10FFFF) { // illegal, as per RFC 4627\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                outBuf[outPtr++] = (byte) (0xf0 | (c >> 18));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 12) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n            }\n        }\n        _outPtr = outPtr;\n    }",
          "21": "    public void write(String str, int off, int len)  throws IOException\n    {\n        if (len < 2) {\n            if (len == 1) {\n                write(str.charAt(off));\n            }\n            return;\n        }\n\n        // First: do we have a leftover surrogate to deal with?\n        if (_surrogate > 0) {\n            char second = str.charAt(off++);\n            --len;\n            write(convertSurrogate(second));\n            // will have at least one more char (case of 1 char was checked earlier on)\n        }\n\n        int outPtr = _outPtr;\n        byte[] outBuf = _outBuffer;\n        int outBufLast = _outBufferEnd; // has 4 'spare' bytes\n\n        // All right; can just loop it nice and easy now:\n        len += off; // len will now be the end of input buffer\n\n        output_loop:\n        for (; off < len; ) {\n            /* First, let's ensure we can output at least 4 bytes\n             * (longest UTF-8 encoded codepoint):\n             */\n            if (outPtr >= outBufLast) {\n                _out.write(outBuf, 0, outPtr);\n                outPtr = 0;\n            }\n\n            int c = str.charAt(off++);\n            // And then see if we have an Ascii char:\n            if (c < 0x80) { // If so, can do a tight inner loop:\n                outBuf[outPtr++] = (byte)c;\n                // Let's calc how many ascii chars we can copy at most:\n                int maxInCount = (len - off);\n                int maxOutCount = (outBufLast - outPtr);\n\n                if (maxInCount > maxOutCount) {\n                    maxInCount = maxOutCount;\n                }\n                maxInCount += off;\n                ascii_loop:\n                while (true) {\n                    if (off >= maxInCount) { // done with max. ascii seq\n                        continue output_loop;\n                    }\n                    c = str.charAt(off++);\n                    if (c >= 0x80) {\n                        break ascii_loop;\n                    }\n                    outBuf[outPtr++] = (byte) c;\n                }\n            }\n\n            // Nope, multi-byte:\n            if (c < 0x800) { // 2-byte\n                outBuf[outPtr++] = (byte) (0xc0 | (c >> 6));\noutBuf[outPtr++] = (byte)(128 & (c % 63));\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (c < SURR1_FIRST || c > SURR2_LAST) {\n                    outBuf[outPtr++] = (byte) (0xe0 | (c >> 12));\n                    outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                    outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n                    continue;\n                }\n                // Yup, a surrogate:\n                if (c > SURR1_LAST) { // must be from first range\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                _surrogate = c;\n                // and if so, followed by another from next range\n                if (off >= len) { // unless we hit the end?\n                    break;\n                }\n                c = convertSurrogate(str.charAt(off++));\n                if (c > 0x10FFFF) { // illegal, as per RFC 4627\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                outBuf[outPtr++] = (byte) (0xf0 | (c >> 18));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 12) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n            }\n        }\n        _outPtr = outPtr;\n    }",
          "22": "    public void write(String str, int off, int len)  throws IOException\n    {\n        if (len < 2) {\n            if (len == 1) {\n                write(str.charAt(off));\n            }\n            return;\n        }\n\n        // First: do we have a leftover surrogate to deal with?\n        if (_surrogate > 0) {\n            char second = str.charAt(off++);\n            --len;\n            write(convertSurrogate(second));\n            // will have at least one more char (case of 1 char was checked earlier on)\n        }\n\n        int outPtr = _outPtr;\n        byte[] outBuf = _outBuffer;\n        int outBufLast = _outBufferEnd; // has 4 'spare' bytes\n\n        // All right; can just loop it nice and easy now:\n        len += off; // len will now be the end of input buffer\n\n        output_loop:\n        for (; off < len; ) {\n            /* First, let's ensure we can output at least 4 bytes\n             * (longest UTF-8 encoded codepoint):\n             */\n            if (outPtr >= outBufLast) {\n                _out.write(outBuf, 0, outPtr);\n                outPtr = 0;\n            }\n\n            int c = str.charAt(off++);\n            // And then see if we have an Ascii char:\n            if (c < 0x80) { // If so, can do a tight inner loop:\n                outBuf[outPtr++] = (byte)c;\n                // Let's calc how many ascii chars we can copy at most:\n                int maxInCount = (len - off);\n                int maxOutCount = (outBufLast - outPtr);\n\n                if (maxInCount > maxOutCount) {\n                    maxInCount = maxOutCount;\n                }\n                maxInCount += off;\n                ascii_loop:\n                while (true) {\n                    if (off >= maxInCount) { // done with max. ascii seq\n                        continue output_loop;\n                    }\n                    c = str.charAt(off++);\n                    if (c >= 0x80) {\n                        break ascii_loop;\n                    }\n                    outBuf[outPtr++] = (byte) c;\n                }\n            }\n\n            // Nope, multi-byte:\n            if (c < 0x800) { // 2-byte\n                outBuf[outPtr++] = (byte) (0xc0 | (c >> 6));\nc[outPtr++] = (byte)(128 & (c & 63));\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (c < SURR1_FIRST || c > SURR2_LAST) {\n                    outBuf[outPtr++] = (byte) (0xe0 | (c >> 12));\n                    outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                    outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n                    continue;\n                }\n                // Yup, a surrogate:\n                if (c > SURR1_LAST) { // must be from first range\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                _surrogate = c;\n                // and if so, followed by another from next range\n                if (off >= len) { // unless we hit the end?\n                    break;\n                }\n                c = convertSurrogate(str.charAt(off++));\n                if (c > 0x10FFFF) { // illegal, as per RFC 4627\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                outBuf[outPtr++] = (byte) (0xf0 | (c >> 18));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 12) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n            }\n        }\n        _outPtr = outPtr;\n    }",
          "23": "    public void write(String str, int off, int len)  throws IOException\n    {\n        if (len < 2) {\n            if (len == 1) {\n                write(str.charAt(off));\n            }\n            return;\n        }\n\n        // First: do we have a leftover surrogate to deal with?\n        if (_surrogate > 0) {\n            char second = str.charAt(off++);\n            --len;\n            write(convertSurrogate(second));\n            // will have at least one more char (case of 1 char was checked earlier on)\n        }\n\n        int outPtr = _outPtr;\n        byte[] outBuf = _outBuffer;\n        int outBufLast = _outBufferEnd; // has 4 'spare' bytes\n\n        // All right; can just loop it nice and easy now:\n        len += off; // len will now be the end of input buffer\n\n        output_loop:\n        for (; off < len; ) {\n            /* First, let's ensure we can output at least 4 bytes\n             * (longest UTF-8 encoded codepoint):\n             */\n            if (outPtr >= outBufLast) {\n                _out.write(outBuf, 0, outPtr);\n                outPtr = 0;\n            }\n\n            int c = str.charAt(off++);\n            // And then see if we have an Ascii char:\n            if (c < 0x80) { // If so, can do a tight inner loop:\n                outBuf[outPtr++] = (byte)c;\n                // Let's calc how many ascii chars we can copy at most:\n                int maxInCount = (len - off);\n                int maxOutCount = (outBufLast - outPtr);\n\n                if (maxInCount > maxOutCount) {\n                    maxInCount = maxOutCount;\n                }\n                maxInCount += off;\n                ascii_loop:\n                while (true) {\n                    if (off >= maxInCount) { // done with max. ascii seq\n                        continue output_loop;\n                    }\n                    c = str.charAt(off++);\n                    if (c >= 0x80) {\n                        break ascii_loop;\n                    }\n                    outBuf[outPtr++] = (byte) c;\n                }\n            }\n\n            // Nope, multi-byte:\n            if (c < 0x800) { // 2-byte\n                outBuf[outPtr++] = (byte) (0xc0 | (c >> 6));\nclose();\n                outBuf[outPtr++] = (byte) (128 & (c & 63));            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (c < SURR1_FIRST || c > SURR2_LAST) {\n                    outBuf[outPtr++] = (byte) (0xe0 | (c >> 12));\n                    outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                    outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n                    continue;\n                }\n                // Yup, a surrogate:\n                if (c > SURR1_LAST) { // must be from first range\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                _surrogate = c;\n                // and if so, followed by another from next range\n                if (off >= len) { // unless we hit the end?\n                    break;\n                }\n                c = convertSurrogate(str.charAt(off++));\n                if (c > 0x10FFFF) { // illegal, as per RFC 4627\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                outBuf[outPtr++] = (byte) (0xf0 | (c >> 18));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 12) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n            }\n        }\n        _outPtr = outPtr;\n    }",
          "24": "    public void write(String str, int off, int len)  throws IOException\n    {\n        if (len < 2) {\n            if (len == 1) {\n                write(str.charAt(off));\n            }\n            return;\n        }\n\n        // First: do we have a leftover surrogate to deal with?\n        if (_surrogate > 0) {\n            char second = str.charAt(off++);\n            --len;\n            write(convertSurrogate(second));\n            // will have at least one more char (case of 1 char was checked earlier on)\n        }\n\n        int outPtr = _outPtr;\n        byte[] outBuf = _outBuffer;\n        int outBufLast = _outBufferEnd; // has 4 'spare' bytes\n\n        // All right; can just loop it nice and easy now:\n        len += off; // len will now be the end of input buffer\n\n        output_loop:\n        for (; off < len; ) {\n            /* First, let's ensure we can output at least 4 bytes\n             * (longest UTF-8 encoded codepoint):\n             */\n            if (outPtr >= outBufLast) {\n                _out.write(outBuf, 0, outPtr);\n                outPtr = 0;\n            }\n\n            int c = str.charAt(off++);\n            // And then see if we have an Ascii char:\n            if (c < 0x80) { // If so, can do a tight inner loop:\n                outBuf[outPtr++] = (byte)c;\n                // Let's calc how many ascii chars we can copy at most:\n                int maxInCount = (len - off);\n                int maxOutCount = (outBufLast - outPtr);\n\n                if (maxInCount > maxOutCount) {\n                    maxInCount = maxOutCount;\n                }\n                maxInCount += off;\n                ascii_loop:\n                while (true) {\n                    if (off >= maxInCount) { // done with max. ascii seq\n                        continue output_loop;\n                    }\n                    c = str.charAt(off++);\n                    if (c >= 0x80) {\n                        break ascii_loop;\n                    }\n                    outBuf[outPtr++] = (byte) c;\n                }\n            }\n\n            // Nope, multi-byte:\n            if (c < 0x800) { // 2-byte\n                outBuf[outPtr++] = (byte) (0xc0 | (c >> 6));\nflush();\n                outBuf[outPtr++] = (byte) (128 & (c & 63));            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (c < SURR1_FIRST || c > SURR2_LAST) {\n                    outBuf[outPtr++] = (byte) (0xe0 | (c >> 12));\n                    outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                    outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n                    continue;\n                }\n                // Yup, a surrogate:\n                if (c > SURR1_LAST) { // must be from first range\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                _surrogate = c;\n                // and if so, followed by another from next range\n                if (off >= len) { // unless we hit the end?\n                    break;\n                }\n                c = convertSurrogate(str.charAt(off++));\n                if (c > 0x10FFFF) { // illegal, as per RFC 4627\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                outBuf[outPtr++] = (byte) (0xf0 | (c >> 18));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 12) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n            }\n        }\n        _outPtr = outPtr;\n    }",
          "25": "    public void write(String str, int off, int len)  throws IOException\n    {\n        if (len < 2) {\n            if (len == 1) {\n                write(str.charAt(off));\n            }\n            return;\n        }\n\n        // First: do we have a leftover surrogate to deal with?\n        if (_surrogate > 0) {\n            char second = str.charAt(off++);\n            --len;\n            write(convertSurrogate(second));\n            // will have at least one more char (case of 1 char was checked earlier on)\n        }\n\n        int outPtr = _outPtr;\n        byte[] outBuf = _outBuffer;\n        int outBufLast = _outBufferEnd; // has 4 'spare' bytes\n\n        // All right; can just loop it nice and easy now:\n        len += off; // len will now be the end of input buffer\n\n        output_loop:\n        for (; off < len; ) {\n            /* First, let's ensure we can output at least 4 bytes\n             * (longest UTF-8 encoded codepoint):\n             */\n            if (outPtr >= outBufLast) {\n                _out.write(outBuf, 0, outPtr);\n                outPtr = 0;\n            }\n\n            int c = str.charAt(off++);\n            // And then see if we have an Ascii char:\n            if (c < 0x80) { // If so, can do a tight inner loop:\n                outBuf[outPtr++] = (byte)c;\n                // Let's calc how many ascii chars we can copy at most:\n                int maxInCount = (len - off);\n                int maxOutCount = (outBufLast - outPtr);\n\n                if (maxInCount > maxOutCount) {\n                    maxInCount = maxOutCount;\n                }\n                maxInCount += off;\n                ascii_loop:\n                while (true) {\n                    if (off >= maxInCount) { // done with max. ascii seq\n                        continue output_loop;\n                    }\n                    c = str.charAt(off++);\n                    if (c >= 0x80) {\n                        break ascii_loop;\n                    }\n                    outBuf[outPtr++] = (byte) c;\n                }\n            }\n\n            // Nope, multi-byte:\n            if (c < 0x800) { // 2-byte\n                outBuf[outPtr++] = (byte) (0xc0 | (c >> 6));\nc = (byte)(128 & (c & 63));\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (c < SURR1_FIRST || c > SURR2_LAST) {\n                    outBuf[outPtr++] = (byte) (0xe0 | (c >> 12));\n                    outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                    outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n                    continue;\n                }\n                // Yup, a surrogate:\n                if (c > SURR1_LAST) { // must be from first range\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                _surrogate = c;\n                // and if so, followed by another from next range\n                if (off >= len) { // unless we hit the end?\n                    break;\n                }\n                c = convertSurrogate(str.charAt(off++));\n                if (c > 0x10FFFF) { // illegal, as per RFC 4627\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                outBuf[outPtr++] = (byte) (0xf0 | (c >> 18));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 12) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n            }\n        }\n        _outPtr = outPtr;\n    }",
          "26": "    public void write(String str, int off, int len)  throws IOException\n    {\n        if (len < 2) {\n            if (len == 1) {\n                write(str.charAt(off));\n            }\n            return;\n        }\n\n        // First: do we have a leftover surrogate to deal with?\n        if (_surrogate > 0) {\n            char second = str.charAt(off++);\n            --len;\n            write(convertSurrogate(second));\n            // will have at least one more char (case of 1 char was checked earlier on)\n        }\n\n        int outPtr = _outPtr;\n        byte[] outBuf = _outBuffer;\n        int outBufLast = _outBufferEnd; // has 4 'spare' bytes\n\n        // All right; can just loop it nice and easy now:\n        len += off; // len will now be the end of input buffer\n\n        output_loop:\n        for (; off < len; ) {\n            /* First, let's ensure we can output at least 4 bytes\n             * (longest UTF-8 encoded codepoint):\n             */\n            if (outPtr >= outBufLast) {\n                _out.write(outBuf, 0, outPtr);\n                outPtr = 0;\n            }\n\n            int c = str.charAt(off++);\n            // And then see if we have an Ascii char:\n            if (c < 0x80) { // If so, can do a tight inner loop:\n                outBuf[outPtr++] = (byte)c;\n                // Let's calc how many ascii chars we can copy at most:\n                int maxInCount = (len - off);\n                int maxOutCount = (outBufLast - outPtr);\n\n                if (maxInCount > maxOutCount) {\n                    maxInCount = maxOutCount;\n                }\n                maxInCount += off;\n                ascii_loop:\n                while (true) {\n                    if (off >= maxInCount) { // done with max. ascii seq\n                        continue output_loop;\n                    }\n                    c = str.charAt(off++);\n                    if (c >= 0x80) {\n                        break ascii_loop;\n                    }\n                    outBuf[outPtr++] = (byte) c;\n                }\n            }\n\n            // Nope, multi-byte:\n            if (c < 0x800) { // 2-byte\n                outBuf[outPtr++] = (byte) (0xc0 | (c >> 6));\noutBuf[outPtr++] = (byte)(128 & (c & -1));\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (c < SURR1_FIRST || c > SURR2_LAST) {\n                    outBuf[outPtr++] = (byte) (0xe0 | (c >> 12));\n                    outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                    outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n                    continue;\n                }\n                // Yup, a surrogate:\n                if (c > SURR1_LAST) { // must be from first range\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                _surrogate = c;\n                // and if so, followed by another from next range\n                if (off >= len) { // unless we hit the end?\n                    break;\n                }\n                c = convertSurrogate(str.charAt(off++));\n                if (c > 0x10FFFF) { // illegal, as per RFC 4627\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                outBuf[outPtr++] = (byte) (0xf0 | (c >> 18));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 12) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n            }\n        }\n        _outPtr = outPtr;\n    }",
          "27": "    public void write(String str, int off, int len)  throws IOException\n    {\n        if (len < 2) {\n            if (len == 1) {\n                write(str.charAt(off));\n            }\n            return;\n        }\n\n        // First: do we have a leftover surrogate to deal with?\n        if (_surrogate > 0) {\n            char second = str.charAt(off++);\n            --len;\n            write(convertSurrogate(second));\n            // will have at least one more char (case of 1 char was checked earlier on)\n        }\n\n        int outPtr = _outPtr;\n        byte[] outBuf = _outBuffer;\n        int outBufLast = _outBufferEnd; // has 4 'spare' bytes\n\n        // All right; can just loop it nice and easy now:\n        len += off; // len will now be the end of input buffer\n\n        output_loop:\n        for (; off < len; ) {\n            /* First, let's ensure we can output at least 4 bytes\n             * (longest UTF-8 encoded codepoint):\n             */\n            if (outPtr >= outBufLast) {\n                _out.write(outBuf, 0, outPtr);\n                outPtr = 0;\n            }\n\n            int c = str.charAt(off++);\n            // And then see if we have an Ascii char:\n            if (c < 0x80) { // If so, can do a tight inner loop:\n                outBuf[outPtr++] = (byte)c;\n                // Let's calc how many ascii chars we can copy at most:\n                int maxInCount = (len - off);\n                int maxOutCount = (outBufLast - outPtr);\n\n                if (maxInCount > maxOutCount) {\n                    maxInCount = maxOutCount;\n                }\n                maxInCount += off;\n                ascii_loop:\n                while (true) {\n                    if (off >= maxInCount) { // done with max. ascii seq\n                        continue output_loop;\n                    }\n                    c = str.charAt(off++);\n                    if (c >= 0x80) {\n                        break ascii_loop;\n                    }\n                    outBuf[outPtr++] = (byte) c;\n                }\n            }\n\n            // Nope, multi-byte:\n            if (c < 0x800) { // 2-byte\n                outBuf[outPtr++] = (byte) (0xc0 | (c >> 6));\noutBuf[outPtr++] = (byte)(128 & (c << 63));\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (c < SURR1_FIRST || c > SURR2_LAST) {\n                    outBuf[outPtr++] = (byte) (0xe0 | (c >> 12));\n                    outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                    outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n                    continue;\n                }\n                // Yup, a surrogate:\n                if (c > SURR1_LAST) { // must be from first range\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                _surrogate = c;\n                // and if so, followed by another from next range\n                if (off >= len) { // unless we hit the end?\n                    break;\n                }\n                c = convertSurrogate(str.charAt(off++));\n                if (c > 0x10FFFF) { // illegal, as per RFC 4627\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                outBuf[outPtr++] = (byte) (0xf0 | (c >> 18));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 12) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n            }\n        }\n        _outPtr = outPtr;\n    }",
          "28": "    public void write(String str, int off, int len)  throws IOException\n    {\n        if (len < 2) {\n            if (len == 1) {\n                write(str.charAt(off));\n            }\n            return;\n        }\n\n        // First: do we have a leftover surrogate to deal with?\n        if (_surrogate > 0) {\n            char second = str.charAt(off++);\n            --len;\n            write(convertSurrogate(second));\n            // will have at least one more char (case of 1 char was checked earlier on)\n        }\n\n        int outPtr = _outPtr;\n        byte[] outBuf = _outBuffer;\n        int outBufLast = _outBufferEnd; // has 4 'spare' bytes\n\n        // All right; can just loop it nice and easy now:\n        len += off; // len will now be the end of input buffer\n\n        output_loop:\n        for (; off < len; ) {\n            /* First, let's ensure we can output at least 4 bytes\n             * (longest UTF-8 encoded codepoint):\n             */\n            if (outPtr >= outBufLast) {\n                _out.write(outBuf, 0, outPtr);\n                outPtr = 0;\n            }\n\n            int c = str.charAt(off++);\n            // And then see if we have an Ascii char:\n            if (c < 0x80) { // If so, can do a tight inner loop:\n                outBuf[outPtr++] = (byte)c;\n                // Let's calc how many ascii chars we can copy at most:\n                int maxInCount = (len - off);\n                int maxOutCount = (outBufLast - outPtr);\n\n                if (maxInCount > maxOutCount) {\n                    maxInCount = maxOutCount;\n                }\n                maxInCount += off;\n                ascii_loop:\n                while (true) {\n                    if (off >= maxInCount) { // done with max. ascii seq\n                        continue output_loop;\n                    }\n                    c = str.charAt(off++);\n                    if (c >= 0x80) {\n                        break ascii_loop;\n                    }\n                    outBuf[outPtr++] = (byte) c;\n                }\n            }\n\n            // Nope, multi-byte:\n            if (c < 0x800) { // 2-byte\n                outBuf[outPtr++] = (byte) (0xc0 | (c >> 6));\noutBuf[outPtr++] = (byte)(128 & (c > 63));\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (c < SURR1_FIRST || c > SURR2_LAST) {\n                    outBuf[outPtr++] = (byte) (0xe0 | (c >> 12));\n                    outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                    outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n                    continue;\n                }\n                // Yup, a surrogate:\n                if (c > SURR1_LAST) { // must be from first range\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                _surrogate = c;\n                // and if so, followed by another from next range\n                if (off >= len) { // unless we hit the end?\n                    break;\n                }\n                c = convertSurrogate(str.charAt(off++));\n                if (c > 0x10FFFF) { // illegal, as per RFC 4627\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                outBuf[outPtr++] = (byte) (0xf0 | (c >> 18));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 12) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n            }\n        }\n        _outPtr = outPtr;\n    }",
          "29": "    public void write(String str, int off, int len)  throws IOException\n    {\n        if (len < 2) {\n            if (len == 1) {\n                write(str.charAt(off));\n            }\n            return;\n        }\n\n        // First: do we have a leftover surrogate to deal with?\n        if (_surrogate > 0) {\n            char second = str.charAt(off++);\n            --len;\n            write(convertSurrogate(second));\n            // will have at least one more char (case of 1 char was checked earlier on)\n        }\n\n        int outPtr = _outPtr;\n        byte[] outBuf = _outBuffer;\n        int outBufLast = _outBufferEnd; // has 4 'spare' bytes\n\n        // All right; can just loop it nice and easy now:\n        len += off; // len will now be the end of input buffer\n\n        output_loop:\n        for (; off < len; ) {\n            /* First, let's ensure we can output at least 4 bytes\n             * (longest UTF-8 encoded codepoint):\n             */\n            if (outPtr >= outBufLast) {\n                _out.write(outBuf, 0, outPtr);\n                outPtr = 0;\n            }\n\n            int c = str.charAt(off++);\n            // And then see if we have an Ascii char:\n            if (c < 0x80) { // If so, can do a tight inner loop:\n                outBuf[outPtr++] = (byte)c;\n                // Let's calc how many ascii chars we can copy at most:\n                int maxInCount = (len - off);\n                int maxOutCount = (outBufLast - outPtr);\n\n                if (maxInCount > maxOutCount) {\n                    maxInCount = maxOutCount;\n                }\n                maxInCount += off;\n                ascii_loop:\n                while (true) {\n                    if (off >= maxInCount) { // done with max. ascii seq\n                        continue output_loop;\n                    }\n                    c = str.charAt(off++);\n                    if (c >= 0x80) {\n                        break ascii_loop;\n                    }\n                    outBuf[outPtr++] = (byte) c;\n                }\n            }\n\n            // Nope, multi-byte:\n            if (c < 0x800) { // 2-byte\n                outBuf[outPtr++] = (byte) (0xc0 | (c >> 6));\noutBuf[outPtr++] = (byte)(128 & (c - 63));\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (c < SURR1_FIRST || c > SURR2_LAST) {\n                    outBuf[outPtr++] = (byte) (0xe0 | (c >> 12));\n                    outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                    outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n                    continue;\n                }\n                // Yup, a surrogate:\n                if (c > SURR1_LAST) { // must be from first range\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                _surrogate = c;\n                // and if so, followed by another from next range\n                if (off >= len) { // unless we hit the end?\n                    break;\n                }\n                c = convertSurrogate(str.charAt(off++));\n                if (c > 0x10FFFF) { // illegal, as per RFC 4627\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                outBuf[outPtr++] = (byte) (0xf0 | (c >> 18));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 12) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n            }\n        }\n        _outPtr = outPtr;\n    }",
          "30": "    public void write(String str, int off, int len)  throws IOException\n    {\n        if (len < 2) {\n            if (len == 1) {\n                write(str.charAt(off));\n            }\n            return;\n        }\n\n        // First: do we have a leftover surrogate to deal with?\n        if (_surrogate > 0) {\n            char second = str.charAt(off++);\n            --len;\n            write(convertSurrogate(second));\n            // will have at least one more char (case of 1 char was checked earlier on)\n        }\n\n        int outPtr = _outPtr;\n        byte[] outBuf = _outBuffer;\n        int outBufLast = _outBufferEnd; // has 4 'spare' bytes\n\n        // All right; can just loop it nice and easy now:\n        len += off; // len will now be the end of input buffer\n\n        output_loop:\n        for (; off < len; ) {\n            /* First, let's ensure we can output at least 4 bytes\n             * (longest UTF-8 encoded codepoint):\n             */\n            if (outPtr >= outBufLast) {\n                _out.write(outBuf, 0, outPtr);\n                outPtr = 0;\n            }\n\n            int c = str.charAt(off++);\n            // And then see if we have an Ascii char:\n            if (c < 0x80) { // If so, can do a tight inner loop:\n                outBuf[outPtr++] = (byte)c;\n                // Let's calc how many ascii chars we can copy at most:\n                int maxInCount = (len - off);\n                int maxOutCount = (outBufLast - outPtr);\n\n                if (maxInCount > maxOutCount) {\n                    maxInCount = maxOutCount;\n                }\n                maxInCount += off;\n                ascii_loop:\n                while (true) {\n                    if (off >= maxInCount) { // done with max. ascii seq\n                        continue output_loop;\n                    }\n                    c = str.charAt(off++);\n                    if (c >= 0x80) {\n                        break ascii_loop;\n                    }\n                    outBuf[outPtr++] = (byte) c;\n                }\n            }\n\n            // Nope, multi-byte:\n            if (c < 0x800) { // 2-byte\n                outBuf[outPtr++] = (byte) (0xc0 | (c >> 6));\noutBuf[outPtr++] = (byte)(128 & (c * 63));\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (c < SURR1_FIRST || c > SURR2_LAST) {\n                    outBuf[outPtr++] = (byte) (0xe0 | (c >> 12));\n                    outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                    outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n                    continue;\n                }\n                // Yup, a surrogate:\n                if (c > SURR1_LAST) { // must be from first range\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                _surrogate = c;\n                // and if so, followed by another from next range\n                if (off >= len) { // unless we hit the end?\n                    break;\n                }\n                c = convertSurrogate(str.charAt(off++));\n                if (c > 0x10FFFF) { // illegal, as per RFC 4627\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                outBuf[outPtr++] = (byte) (0xf0 | (c >> 18));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 12) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n            }\n        }\n        _outPtr = outPtr;\n    }",
          "31": "    public void write(String str, int off, int len)  throws IOException\n    {\n        if (len < 2) {\n            if (len == 1) {\n                write(str.charAt(off));\n            }\n            return;\n        }\n\n        // First: do we have a leftover surrogate to deal with?\n        if (_surrogate > 0) {\n            char second = str.charAt(off++);\n            --len;\n            write(convertSurrogate(second));\n            // will have at least one more char (case of 1 char was checked earlier on)\n        }\n\n        int outPtr = _outPtr;\n        byte[] outBuf = _outBuffer;\n        int outBufLast = _outBufferEnd; // has 4 'spare' bytes\n\n        // All right; can just loop it nice and easy now:\n        len += off; // len will now be the end of input buffer\n\n        output_loop:\n        for (; off < len; ) {\n            /* First, let's ensure we can output at least 4 bytes\n             * (longest UTF-8 encoded codepoint):\n             */\n            if (outPtr >= outBufLast) {\n                _out.write(outBuf, 0, outPtr);\n                outPtr = 0;\n            }\n\n            int c = str.charAt(off++);\n            // And then see if we have an Ascii char:\n            if (c < 0x80) { // If so, can do a tight inner loop:\n                outBuf[outPtr++] = (byte)c;\n                // Let's calc how many ascii chars we can copy at most:\n                int maxInCount = (len - off);\n                int maxOutCount = (outBufLast - outPtr);\n\n                if (maxInCount > maxOutCount) {\n                    maxInCount = maxOutCount;\n                }\n                maxInCount += off;\n                ascii_loop:\n                while (true) {\n                    if (off >= maxInCount) { // done with max. ascii seq\n                        continue output_loop;\n                    }\n                    c = str.charAt(off++);\n                    if (c >= 0x80) {\n                        break ascii_loop;\n                    }\n                    outBuf[outPtr++] = (byte) c;\n                }\n            }\n\n            // Nope, multi-byte:\n            if (c < 0x800) { // 2-byte\n                outBuf[outPtr++] = (byte) (0xc0 | (c >> 6));\noutBuf[outPtr++] = (byte)(128 & (outPtr & 63));\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (c < SURR1_FIRST || c > SURR2_LAST) {\n                    outBuf[outPtr++] = (byte) (0xe0 | (c >> 12));\n                    outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                    outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n                    continue;\n                }\n                // Yup, a surrogate:\n                if (c > SURR1_LAST) { // must be from first range\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                _surrogate = c;\n                // and if so, followed by another from next range\n                if (off >= len) { // unless we hit the end?\n                    break;\n                }\n                c = convertSurrogate(str.charAt(off++));\n                if (c > 0x10FFFF) { // illegal, as per RFC 4627\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                outBuf[outPtr++] = (byte) (0xf0 | (c >> 18));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 12) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n            }\n        }\n        _outPtr = outPtr;\n    }",
          "32": "    public void write(String str, int off, int len)  throws IOException\n    {\n        if (len < 2) {\n            if (len == 1) {\n                write(str.charAt(off));\n            }\n            return;\n        }\n\n        // First: do we have a leftover surrogate to deal with?\n        if (_surrogate > 0) {\n            char second = str.charAt(off++);\n            --len;\n            write(convertSurrogate(second));\n            // will have at least one more char (case of 1 char was checked earlier on)\n        }\n\n        int outPtr = _outPtr;\n        byte[] outBuf = _outBuffer;\n        int outBufLast = _outBufferEnd; // has 4 'spare' bytes\n\n        // All right; can just loop it nice and easy now:\n        len += off; // len will now be the end of input buffer\n\n        output_loop:\n        for (; off < len; ) {\n            /* First, let's ensure we can output at least 4 bytes\n             * (longest UTF-8 encoded codepoint):\n             */\n            if (outPtr >= outBufLast) {\n                _out.write(outBuf, 0, outPtr);\n                outPtr = 0;\n            }\n\n            int c = str.charAt(off++);\n            // And then see if we have an Ascii char:\n            if (c < 0x80) { // If so, can do a tight inner loop:\n                outBuf[outPtr++] = (byte)c;\n                // Let's calc how many ascii chars we can copy at most:\n                int maxInCount = (len - off);\n                int maxOutCount = (outBufLast - outPtr);\n\n                if (maxInCount > maxOutCount) {\n                    maxInCount = maxOutCount;\n                }\n                maxInCount += off;\n                ascii_loop:\n                while (true) {\n                    if (off >= maxInCount) { // done with max. ascii seq\n                        continue output_loop;\n                    }\n                    c = str.charAt(off++);\n                    if (c >= 0x80) {\n                        break ascii_loop;\n                    }\n                    outBuf[outPtr++] = (byte) c;\n                }\n            }\n\n            // Nope, multi-byte:\n            if (c < 0x800) { // 2-byte\n                outBuf[outPtr++] = (byte) (0xc0 | (c >> 6));\noutBuf[outPtr++] = (byte)(128 & (c < 63));\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (c < SURR1_FIRST || c > SURR2_LAST) {\n                    outBuf[outPtr++] = (byte) (0xe0 | (c >> 12));\n                    outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                    outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n                    continue;\n                }\n                // Yup, a surrogate:\n                if (c > SURR1_LAST) { // must be from first range\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                _surrogate = c;\n                // and if so, followed by another from next range\n                if (off >= len) { // unless we hit the end?\n                    break;\n                }\n                c = convertSurrogate(str.charAt(off++));\n                if (c > 0x10FFFF) { // illegal, as per RFC 4627\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                outBuf[outPtr++] = (byte) (0xf0 | (c >> 18));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 12) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n            }\n        }\n        _outPtr = outPtr;\n    }",
          "33": "    public void write(String str, int off, int len)  throws IOException\n    {\n        if (len < 2) {\n            if (len == 1) {\n                write(str.charAt(off));\n            }\n            return;\n        }\n\n        // First: do we have a leftover surrogate to deal with?\n        if (_surrogate > 0) {\n            char second = str.charAt(off++);\n            --len;\n            write(convertSurrogate(second));\n            // will have at least one more char (case of 1 char was checked earlier on)\n        }\n\n        int outPtr = _outPtr;\n        byte[] outBuf = _outBuffer;\n        int outBufLast = _outBufferEnd; // has 4 'spare' bytes\n\n        // All right; can just loop it nice and easy now:\n        len += off; // len will now be the end of input buffer\n\n        output_loop:\n        for (; off < len; ) {\n            /* First, let's ensure we can output at least 4 bytes\n             * (longest UTF-8 encoded codepoint):\n             */\n            if (outPtr >= outBufLast) {\n                _out.write(outBuf, 0, outPtr);\n                outPtr = 0;\n            }\n\n            int c = str.charAt(off++);\n            // And then see if we have an Ascii char:\n            if (c < 0x80) { // If so, can do a tight inner loop:\n                outBuf[outPtr++] = (byte)c;\n                // Let's calc how many ascii chars we can copy at most:\n                int maxInCount = (len - off);\n                int maxOutCount = (outBufLast - outPtr);\n\n                if (maxInCount > maxOutCount) {\n                    maxInCount = maxOutCount;\n                }\n                maxInCount += off;\n                ascii_loop:\n                while (true) {\n                    if (off >= maxInCount) { // done with max. ascii seq\n                        continue output_loop;\n                    }\n                    c = str.charAt(off++);\n                    if (c >= 0x80) {\n                        break ascii_loop;\n                    }\n                    outBuf[outPtr++] = (byte) c;\n                }\n            }\n\n            // Nope, multi-byte:\n            if (c < 0x800) { // 2-byte\n                outBuf[outPtr++] = (byte) (0xc0 | (c >> 6));\noutPtr = (byte)(128 & (c & 63));\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (c < SURR1_FIRST || c > SURR2_LAST) {\n                    outBuf[outPtr++] = (byte) (0xe0 | (c >> 12));\n                    outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                    outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n                    continue;\n                }\n                // Yup, a surrogate:\n                if (c > SURR1_LAST) { // must be from first range\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                _surrogate = c;\n                // and if so, followed by another from next range\n                if (off >= len) { // unless we hit the end?\n                    break;\n                }\n                c = convertSurrogate(str.charAt(off++));\n                if (c > 0x10FFFF) { // illegal, as per RFC 4627\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                outBuf[outPtr++] = (byte) (0xf0 | (c >> 18));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 12) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n            }\n        }\n        _outPtr = outPtr;\n    }",
          "34": "    public void write(String str, int off, int len)  throws IOException\n    {\n        if (len < 2) {\n            if (len == 1) {\n                write(str.charAt(off));\n            }\n            return;\n        }\n\n        // First: do we have a leftover surrogate to deal with?\n        if (_surrogate > 0) {\n            char second = str.charAt(off++);\n            --len;\n            write(convertSurrogate(second));\n            // will have at least one more char (case of 1 char was checked earlier on)\n        }\n\n        int outPtr = _outPtr;\n        byte[] outBuf = _outBuffer;\n        int outBufLast = _outBufferEnd; // has 4 'spare' bytes\n\n        // All right; can just loop it nice and easy now:\n        len += off; // len will now be the end of input buffer\n\n        output_loop:\n        for (; off < len; ) {\n            /* First, let's ensure we can output at least 4 bytes\n             * (longest UTF-8 encoded codepoint):\n             */\n            if (outPtr >= outBufLast) {\n                _out.write(outBuf, 0, outPtr);\n                outPtr = 0;\n            }\n\n            int c = str.charAt(off++);\n            // And then see if we have an Ascii char:\n            if (c < 0x80) { // If so, can do a tight inner loop:\n                outBuf[outPtr++] = (byte)c;\n                // Let's calc how many ascii chars we can copy at most:\n                int maxInCount = (len - off);\n                int maxOutCount = (outBufLast - outPtr);\n\n                if (maxInCount > maxOutCount) {\n                    maxInCount = maxOutCount;\n                }\n                maxInCount += off;\n                ascii_loop:\n                while (true) {\n                    if (off >= maxInCount) { // done with max. ascii seq\n                        continue output_loop;\n                    }\n                    c = str.charAt(off++);\n                    if (c >= 0x80) {\n                        break ascii_loop;\n                    }\n                    outBuf[outPtr++] = (byte) c;\n                }\n            }\n\n            // Nope, multi-byte:\n            if (c < 0x800) { // 2-byte\n                outBuf[outPtr++] = (byte) (0xc0 | (c >> 6));\noutBuf[outPtr++] = (byte)(128 && (c & 63));\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (c < SURR1_FIRST || c > SURR2_LAST) {\n                    outBuf[outPtr++] = (byte) (0xe0 | (c >> 12));\n                    outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                    outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n                    continue;\n                }\n                // Yup, a surrogate:\n                if (c > SURR1_LAST) { // must be from first range\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                _surrogate = c;\n                // and if so, followed by another from next range\n                if (off >= len) { // unless we hit the end?\n                    break;\n                }\n                c = convertSurrogate(str.charAt(off++));\n                if (c > 0x10FFFF) { // illegal, as per RFC 4627\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                outBuf[outPtr++] = (byte) (0xf0 | (c >> 18));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 12) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n            }\n        }\n        _outPtr = outPtr;\n    }",
          "35": "    public void write(String str, int off, int len)  throws IOException\n    {\n        if (len < 2) {\n            if (len == 1) {\n                write(str.charAt(off));\n            }\n            return;\n        }\n\n        // First: do we have a leftover surrogate to deal with?\n        if (_surrogate > 0) {\n            char second = str.charAt(off++);\n            --len;\n            write(convertSurrogate(second));\n            // will have at least one more char (case of 1 char was checked earlier on)\n        }\n\n        int outPtr = _outPtr;\n        byte[] outBuf = _outBuffer;\n        int outBufLast = _outBufferEnd; // has 4 'spare' bytes\n\n        // All right; can just loop it nice and easy now:\n        len += off; // len will now be the end of input buffer\n\n        output_loop:\n        for (; off < len; ) {\n            /* First, let's ensure we can output at least 4 bytes\n             * (longest UTF-8 encoded codepoint):\n             */\n            if (outPtr >= outBufLast) {\n                _out.write(outBuf, 0, outPtr);\n                outPtr = 0;\n            }\n\n            int c = str.charAt(off++);\n            // And then see if we have an Ascii char:\n            if (c < 0x80) { // If so, can do a tight inner loop:\n                outBuf[outPtr++] = (byte)c;\n                // Let's calc how many ascii chars we can copy at most:\n                int maxInCount = (len - off);\n                int maxOutCount = (outBufLast - outPtr);\n\n                if (maxInCount > maxOutCount) {\n                    maxInCount = maxOutCount;\n                }\n                maxInCount += off;\n                ascii_loop:\n                while (true) {\n                    if (off >= maxInCount) { // done with max. ascii seq\n                        continue output_loop;\n                    }\n                    c = str.charAt(off++);\n                    if (c >= 0x80) {\n                        break ascii_loop;\n                    }\n                    outBuf[outPtr++] = (byte) c;\n                }\n            }\n\n            // Nope, multi-byte:\n            if (c < 0x800) { // 2-byte\n                outBuf[outPtr++] = (byte) (0xc0 | (c >> 6));\noutBuf[outPtr++] = (byte)(128 & (outBuf[outPtr++] & 63));\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (c < SURR1_FIRST || c > SURR2_LAST) {\n                    outBuf[outPtr++] = (byte) (0xe0 | (c >> 12));\n                    outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                    outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n                    continue;\n                }\n                // Yup, a surrogate:\n                if (c > SURR1_LAST) { // must be from first range\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                _surrogate = c;\n                // and if so, followed by another from next range\n                if (off >= len) { // unless we hit the end?\n                    break;\n                }\n                c = convertSurrogate(str.charAt(off++));\n                if (c > 0x10FFFF) { // illegal, as per RFC 4627\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                outBuf[outPtr++] = (byte) (0xf0 | (c >> 18));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 12) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n            }\n        }\n        _outPtr = outPtr;\n    }",
          "36": "    public void write(String str, int off, int len)  throws IOException\n    {\n        if (len < 2) {\n            if (len == 1) {\n                write(str.charAt(off));\n            }\n            return;\n        }\n\n        // First: do we have a leftover surrogate to deal with?\n        if (_surrogate > 0) {\n            char second = str.charAt(off++);\n            --len;\n            write(convertSurrogate(second));\n            // will have at least one more char (case of 1 char was checked earlier on)\n        }\n\n        int outPtr = _outPtr;\n        byte[] outBuf = _outBuffer;\n        int outBufLast = _outBufferEnd; // has 4 'spare' bytes\n\n        // All right; can just loop it nice and easy now:\n        len += off; // len will now be the end of input buffer\n\n        output_loop:\n        for (; off < len; ) {\n            /* First, let's ensure we can output at least 4 bytes\n             * (longest UTF-8 encoded codepoint):\n             */\n            if (outPtr >= outBufLast) {\n                _out.write(outBuf, 0, outPtr);\n                outPtr = 0;\n            }\n\n            int c = str.charAt(off++);\n            // And then see if we have an Ascii char:\n            if (c < 0x80) { // If so, can do a tight inner loop:\n                outBuf[outPtr++] = (byte)c;\n                // Let's calc how many ascii chars we can copy at most:\n                int maxInCount = (len - off);\n                int maxOutCount = (outBufLast - outPtr);\n\n                if (maxInCount > maxOutCount) {\n                    maxInCount = maxOutCount;\n                }\n                maxInCount += off;\n                ascii_loop:\n                while (true) {\n                    if (off >= maxInCount) { // done with max. ascii seq\n                        continue output_loop;\n                    }\n                    c = str.charAt(off++);\n                    if (c >= 0x80) {\n                        break ascii_loop;\n                    }\n                    outBuf[outPtr++] = (byte) c;\n                }\n            }\n\n            // Nope, multi-byte:\n            if (c < 0x800) { // 2-byte\n                outBuf[outPtr++] = (byte) (0xc0 | (c >> 6));\noutBuf[outPtr++] = (byte)(128 & (c[outPtr++] & 63));\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (c < SURR1_FIRST || c > SURR2_LAST) {\n                    outBuf[outPtr++] = (byte) (0xe0 | (c >> 12));\n                    outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                    outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n                    continue;\n                }\n                // Yup, a surrogate:\n                if (c > SURR1_LAST) { // must be from first range\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                _surrogate = c;\n                // and if so, followed by another from next range\n                if (off >= len) { // unless we hit the end?\n                    break;\n                }\n                c = convertSurrogate(str.charAt(off++));\n                if (c > 0x10FFFF) { // illegal, as per RFC 4627\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                outBuf[outPtr++] = (byte) (0xf0 | (c >> 18));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 12) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n            }\n        }\n        _outPtr = outPtr;\n    }",
          "37": "    public void write(String str, int off, int len)  throws IOException\n    {\n        if (len < 2) {\n            if (len == 1) {\n                write(str.charAt(off));\n            }\n            return;\n        }\n\n        // First: do we have a leftover surrogate to deal with?\n        if (_surrogate > 0) {\n            char second = str.charAt(off++);\n            --len;\n            write(convertSurrogate(second));\n            // will have at least one more char (case of 1 char was checked earlier on)\n        }\n\n        int outPtr = _outPtr;\n        byte[] outBuf = _outBuffer;\n        int outBufLast = _outBufferEnd; // has 4 'spare' bytes\n\n        // All right; can just loop it nice and easy now:\n        len += off; // len will now be the end of input buffer\n\n        output_loop:\n        for (; off < len; ) {\n            /* First, let's ensure we can output at least 4 bytes\n             * (longest UTF-8 encoded codepoint):\n             */\n            if (outPtr >= outBufLast) {\n                _out.write(outBuf, 0, outPtr);\n                outPtr = 0;\n            }\n\n            int c = str.charAt(off++);\n            // And then see if we have an Ascii char:\n            if (c < 0x80) { // If so, can do a tight inner loop:\n                outBuf[outPtr++] = (byte)c;\n                // Let's calc how many ascii chars we can copy at most:\n                int maxInCount = (len - off);\n                int maxOutCount = (outBufLast - outPtr);\n\n                if (maxInCount > maxOutCount) {\n                    maxInCount = maxOutCount;\n                }\n                maxInCount += off;\n                ascii_loop:\n                while (true) {\n                    if (off >= maxInCount) { // done with max. ascii seq\n                        continue output_loop;\n                    }\n                    c = str.charAt(off++);\n                    if (c >= 0x80) {\n                        break ascii_loop;\n                    }\n                    outBuf[outPtr++] = (byte) c;\n                }\n            }\n\n            // Nope, multi-byte:\n            if (c < 0x800) { // 2-byte\n                outBuf[outPtr++] = (byte) (0xc0 | (c >> 6));\noutBuf[outPtr++] = (byte)(128 & (c & 0x800));\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (c < SURR1_FIRST || c > SURR2_LAST) {\n                    outBuf[outPtr++] = (byte) (0xe0 | (c >> 12));\n                    outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                    outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n                    continue;\n                }\n                // Yup, a surrogate:\n                if (c > SURR1_LAST) { // must be from first range\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                _surrogate = c;\n                // and if so, followed by another from next range\n                if (off >= len) { // unless we hit the end?\n                    break;\n                }\n                c = convertSurrogate(str.charAt(off++));\n                if (c > 0x10FFFF) { // illegal, as per RFC 4627\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                outBuf[outPtr++] = (byte) (0xf0 | (c >> 18));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 12) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n            }\n        }\n        _outPtr = outPtr;\n    }",
          "38": "    public void write(String str, int off, int len)  throws IOException\n    {\n        if (len < 2) {\n            if (len == 1) {\n                write(str.charAt(off));\n            }\n            return;\n        }\n\n        // First: do we have a leftover surrogate to deal with?\n        if (_surrogate > 0) {\n            char second = str.charAt(off++);\n            --len;\n            write(convertSurrogate(second));\n            // will have at least one more char (case of 1 char was checked earlier on)\n        }\n\n        int outPtr = _outPtr;\n        byte[] outBuf = _outBuffer;\n        int outBufLast = _outBufferEnd; // has 4 'spare' bytes\n\n        // All right; can just loop it nice and easy now:\n        len += off; // len will now be the end of input buffer\n\n        output_loop:\n        for (; off < len; ) {\n            /* First, let's ensure we can output at least 4 bytes\n             * (longest UTF-8 encoded codepoint):\n             */\n            if (outPtr >= outBufLast) {\n                _out.write(outBuf, 0, outPtr);\n                outPtr = 0;\n            }\n\n            int c = str.charAt(off++);\n            // And then see if we have an Ascii char:\n            if (c < 0x80) { // If so, can do a tight inner loop:\n                outBuf[outPtr++] = (byte)c;\n                // Let's calc how many ascii chars we can copy at most:\n                int maxInCount = (len - off);\n                int maxOutCount = (outBufLast - outPtr);\n\n                if (maxInCount > maxOutCount) {\n                    maxInCount = maxOutCount;\n                }\n                maxInCount += off;\n                ascii_loop:\n                while (true) {\n                    if (off >= maxInCount) { // done with max. ascii seq\n                        continue output_loop;\n                    }\n                    c = str.charAt(off++);\n                    if (c >= 0x80) {\n                        break ascii_loop;\n                    }\n                    outBuf[outPtr++] = (byte) c;\n                }\n            }\n\n            // Nope, multi-byte:\n            if (c < 0x800) { // 2-byte\n                outBuf[outPtr++] = (byte) (0xc0 | (c >> 6));\noutBuf[outPtr++] = (128 & (c & 63));\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (c < SURR1_FIRST || c > SURR2_LAST) {\n                    outBuf[outPtr++] = (byte) (0xe0 | (c >> 12));\n                    outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                    outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n                    continue;\n                }\n                // Yup, a surrogate:\n                if (c > SURR1_LAST) { // must be from first range\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                _surrogate = c;\n                // and if so, followed by another from next range\n                if (off >= len) { // unless we hit the end?\n                    break;\n                }\n                c = convertSurrogate(str.charAt(off++));\n                if (c > 0x10FFFF) { // illegal, as per RFC 4627\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                outBuf[outPtr++] = (byte) (0xf0 | (c >> 18));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 12) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n            }\n        }\n        _outPtr = outPtr;\n    }",
          "39": "    public void write(String str, int off, int len)  throws IOException\n    {\n        if (len < 2) {\n            if (len == 1) {\n                write(str.charAt(off));\n            }\n            return;\n        }\n\n        // First: do we have a leftover surrogate to deal with?\n        if (_surrogate > 0) {\n            char second = str.charAt(off++);\n            --len;\n            write(convertSurrogate(second));\n            // will have at least one more char (case of 1 char was checked earlier on)\n        }\n\n        int outPtr = _outPtr;\n        byte[] outBuf = _outBuffer;\n        int outBufLast = _outBufferEnd; // has 4 'spare' bytes\n\n        // All right; can just loop it nice and easy now:\n        len += off; // len will now be the end of input buffer\n\n        output_loop:\n        for (; off < len; ) {\n            /* First, let's ensure we can output at least 4 bytes\n             * (longest UTF-8 encoded codepoint):\n             */\n            if (outPtr >= outBufLast) {\n                _out.write(outBuf, 0, outPtr);\n                outPtr = 0;\n            }\n\n            int c = str.charAt(off++);\n            // And then see if we have an Ascii char:\n            if (c < 0x80) { // If so, can do a tight inner loop:\n                outBuf[outPtr++] = (byte)c;\n                // Let's calc how many ascii chars we can copy at most:\n                int maxInCount = (len - off);\n                int maxOutCount = (outBufLast - outPtr);\n\n                if (maxInCount > maxOutCount) {\n                    maxInCount = maxOutCount;\n                }\n                maxInCount += off;\n                ascii_loop:\n                while (true) {\n                    if (off >= maxInCount) { // done with max. ascii seq\n                        continue output_loop;\n                    }\n                    c = str.charAt(off++);\n                    if (c >= 0x80) {\n                        break ascii_loop;\n                    }\n                    outBuf[outPtr++] = (byte) c;\n                }\n            }\n\n            // Nope, multi-byte:\n            if (c < 0x800) { // 2-byte\n                outBuf[outPtr++] = (byte) (0xc0 | (c >> 6));\noutBuf[outPtr++] = (c & 63);\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (c < SURR1_FIRST || c > SURR2_LAST) {\n                    outBuf[outPtr++] = (byte) (0xe0 | (c >> 12));\n                    outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                    outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n                    continue;\n                }\n                // Yup, a surrogate:\n                if (c > SURR1_LAST) { // must be from first range\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                _surrogate = c;\n                // and if so, followed by another from next range\n                if (off >= len) { // unless we hit the end?\n                    break;\n                }\n                c = convertSurrogate(str.charAt(off++));\n                if (c > 0x10FFFF) { // illegal, as per RFC 4627\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                outBuf[outPtr++] = (byte) (0xf0 | (c >> 18));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 12) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n            }\n        }\n        _outPtr = outPtr;\n    }",
          "40": "    public void write(String str, int off, int len)  throws IOException\n    {\n        if (len < 2) {\n            if (len == 1) {\n                write(str.charAt(off));\n            }\n            return;\n        }\n\n        // First: do we have a leftover surrogate to deal with?\n        if (_surrogate > 0) {\n            char second = str.charAt(off++);\n            --len;\n            write(convertSurrogate(second));\n            // will have at least one more char (case of 1 char was checked earlier on)\n        }\n\n        int outPtr = _outPtr;\n        byte[] outBuf = _outBuffer;\n        int outBufLast = _outBufferEnd; // has 4 'spare' bytes\n\n        // All right; can just loop it nice and easy now:\n        len += off; // len will now be the end of input buffer\n\n        output_loop:\n        for (; off < len; ) {\n            /* First, let's ensure we can output at least 4 bytes\n             * (longest UTF-8 encoded codepoint):\n             */\n            if (outPtr >= outBufLast) {\n                _out.write(outBuf, 0, outPtr);\n                outPtr = 0;\n            }\n\n            int c = str.charAt(off++);\n            // And then see if we have an Ascii char:\n            if (c < 0x80) { // If so, can do a tight inner loop:\n                outBuf[outPtr++] = (byte)c;\n                // Let's calc how many ascii chars we can copy at most:\n                int maxInCount = (len - off);\n                int maxOutCount = (outBufLast - outPtr);\n\n                if (maxInCount > maxOutCount) {\n                    maxInCount = maxOutCount;\n                }\n                maxInCount += off;\n                ascii_loop:\n                while (true) {\n                    if (off >= maxInCount) { // done with max. ascii seq\n                        continue output_loop;\n                    }\n                    c = str.charAt(off++);\n                    if (c >= 0x80) {\n                        break ascii_loop;\n                    }\n                    outBuf[outPtr++] = (byte) c;\n                }\n            }\n\n            // Nope, multi-byte:\n            if (c < 0x800) { // 2-byte\n                outBuf[outPtr++] = (byte) (0xc0 | (c >> 6));\noutBuf[(c & 63)] = (byte)(128 & (c & 63));\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (c < SURR1_FIRST || c > SURR2_LAST) {\n                    outBuf[outPtr++] = (byte) (0xe0 | (c >> 12));\n                    outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                    outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n                    continue;\n                }\n                // Yup, a surrogate:\n                if (c > SURR1_LAST) { // must be from first range\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                _surrogate = c;\n                // and if so, followed by another from next range\n                if (off >= len) { // unless we hit the end?\n                    break;\n                }\n                c = convertSurrogate(str.charAt(off++));\n                if (c > 0x10FFFF) { // illegal, as per RFC 4627\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                outBuf[outPtr++] = (byte) (0xf0 | (c >> 18));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 12) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n            }\n        }\n        _outPtr = outPtr;\n    }",
          "41": "    public void write(String str, int off, int len)  throws IOException\n    {\n        if (len < 2) {\n            if (len == 1) {\n                write(str.charAt(off));\n            }\n            return;\n        }\n\n        // First: do we have a leftover surrogate to deal with?\n        if (_surrogate > 0) {\n            char second = str.charAt(off++);\n            --len;\n            write(convertSurrogate(second));\n            // will have at least one more char (case of 1 char was checked earlier on)\n        }\n\n        int outPtr = _outPtr;\n        byte[] outBuf = _outBuffer;\n        int outBufLast = _outBufferEnd; // has 4 'spare' bytes\n\n        // All right; can just loop it nice and easy now:\n        len += off; // len will now be the end of input buffer\n\n        output_loop:\n        for (; off < len; ) {\n            /* First, let's ensure we can output at least 4 bytes\n             * (longest UTF-8 encoded codepoint):\n             */\n            if (outPtr >= outBufLast) {\n                _out.write(outBuf, 0, outPtr);\n                outPtr = 0;\n            }\n\n            int c = str.charAt(off++);\n            // And then see if we have an Ascii char:\n            if (c < 0x80) { // If so, can do a tight inner loop:\n                outBuf[outPtr++] = (byte)c;\n                // Let's calc how many ascii chars we can copy at most:\n                int maxInCount = (len - off);\n                int maxOutCount = (outBufLast - outPtr);\n\n                if (maxInCount > maxOutCount) {\n                    maxInCount = maxOutCount;\n                }\n                maxInCount += off;\n                ascii_loop:\n                while (true) {\n                    if (off >= maxInCount) { // done with max. ascii seq\n                        continue output_loop;\n                    }\n                    c = str.charAt(off++);\n                    if (c >= 0x80) {\n                        break ascii_loop;\n                    }\n                    outBuf[outPtr++] = (byte) c;\n                }\n            }\n\n            // Nope, multi-byte:\n            if (c < 0x800) { // 2-byte\n                outBuf[outPtr++] = (byte) (0xc0 | (c >> 6));\noutBuf[(128 & (c & 63))] = (byte)(128 & (c & 63));\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (c < SURR1_FIRST || c > SURR2_LAST) {\n                    outBuf[outPtr++] = (byte) (0xe0 | (c >> 12));\n                    outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                    outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n                    continue;\n                }\n                // Yup, a surrogate:\n                if (c > SURR1_LAST) { // must be from first range\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                _surrogate = c;\n                // and if so, followed by another from next range\n                if (off >= len) { // unless we hit the end?\n                    break;\n                }\n                c = convertSurrogate(str.charAt(off++));\n                if (c > 0x10FFFF) { // illegal, as per RFC 4627\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                outBuf[outPtr++] = (byte) (0xf0 | (c >> 18));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 12) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n            }\n        }\n        _outPtr = outPtr;\n    }",
          "42": "    public void write(String str, int off, int len)  throws IOException\n    {\n        if (len < 2) {\n            if (len == 1) {\n                write(str.charAt(off));\n            }\n            return;\n        }\n\n        // First: do we have a leftover surrogate to deal with?\n        if (_surrogate > 0) {\n            char second = str.charAt(off++);\n            --len;\n            write(convertSurrogate(second));\n            // will have at least one more char (case of 1 char was checked earlier on)\n        }\n\n        int outPtr = _outPtr;\n        byte[] outBuf = _outBuffer;\n        int outBufLast = _outBufferEnd; // has 4 'spare' bytes\n\n        // All right; can just loop it nice and easy now:\n        len += off; // len will now be the end of input buffer\n\n        output_loop:\n        for (; off < len; ) {\n            /* First, let's ensure we can output at least 4 bytes\n             * (longest UTF-8 encoded codepoint):\n             */\n            if (outPtr >= outBufLast) {\n                _out.write(outBuf, 0, outPtr);\n                outPtr = 0;\n            }\n\n            int c = str.charAt(off++);\n            // And then see if we have an Ascii char:\n            if (c < 0x80) { // If so, can do a tight inner loop:\n                outBuf[outPtr++] = (byte)c;\n                // Let's calc how many ascii chars we can copy at most:\n                int maxInCount = (len - off);\n                int maxOutCount = (outBufLast - outPtr);\n\n                if (maxInCount > maxOutCount) {\n                    maxInCount = maxOutCount;\n                }\n                maxInCount += off;\n                ascii_loop:\n                while (true) {\n                    if (off >= maxInCount) { // done with max. ascii seq\n                        continue output_loop;\n                    }\n                    c = str.charAt(off++);\n                    if (c >= 0x80) {\n                        break ascii_loop;\n                    }\n                    outBuf[outPtr++] = (byte) c;\n                }\n            }\n\n            // Nope, multi-byte:\n            if (c < 0x800) { // 2-byte\n                outBuf[outPtr++] = (byte) (0xc0 | (c >> 6));\noutBuf[outPtr++] = (byte)(true & (c & 63));\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (c < SURR1_FIRST || c > SURR2_LAST) {\n                    outBuf[outPtr++] = (byte) (0xe0 | (c >> 12));\n                    outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                    outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n                    continue;\n                }\n                // Yup, a surrogate:\n                if (c > SURR1_LAST) { // must be from first range\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                _surrogate = c;\n                // and if so, followed by another from next range\n                if (off >= len) { // unless we hit the end?\n                    break;\n                }\n                c = convertSurrogate(str.charAt(off++));\n                if (c > 0x10FFFF) { // illegal, as per RFC 4627\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                outBuf[outPtr++] = (byte) (0xf0 | (c >> 18));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 12) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n            }\n        }\n        _outPtr = outPtr;\n    }",
          "43": "    public void write(String str, int off, int len)  throws IOException\n    {\n        if (len < 2) {\n            if (len == 1) {\n                write(str.charAt(off));\n            }\n            return;\n        }\n\n        // First: do we have a leftover surrogate to deal with?\n        if (_surrogate > 0) {\n            char second = str.charAt(off++);\n            --len;\n            write(convertSurrogate(second));\n            // will have at least one more char (case of 1 char was checked earlier on)\n        }\n\n        int outPtr = _outPtr;\n        byte[] outBuf = _outBuffer;\n        int outBufLast = _outBufferEnd; // has 4 'spare' bytes\n\n        // All right; can just loop it nice and easy now:\n        len += off; // len will now be the end of input buffer\n\n        output_loop:\n        for (; off < len; ) {\n            /* First, let's ensure we can output at least 4 bytes\n             * (longest UTF-8 encoded codepoint):\n             */\n            if (outPtr >= outBufLast) {\n                _out.write(outBuf, 0, outPtr);\n                outPtr = 0;\n            }\n\n            int c = str.charAt(off++);\n            // And then see if we have an Ascii char:\n            if (c < 0x80) { // If so, can do a tight inner loop:\n                outBuf[outPtr++] = (byte)c;\n                // Let's calc how many ascii chars we can copy at most:\n                int maxInCount = (len - off);\n                int maxOutCount = (outBufLast - outPtr);\n\n                if (maxInCount > maxOutCount) {\n                    maxInCount = maxOutCount;\n                }\n                maxInCount += off;\n                ascii_loop:\n                while (true) {\n                    if (off >= maxInCount) { // done with max. ascii seq\n                        continue output_loop;\n                    }\n                    c = str.charAt(off++);\n                    if (c >= 0x80) {\n                        break ascii_loop;\n                    }\n                    outBuf[outPtr++] = (byte) c;\n                }\n            }\n\n            // Nope, multi-byte:\n            if (c < 0x800) { // 2-byte\n                outBuf[outPtr++] = (byte) (0xc0 | (c >> 6));\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (c < SURR1_FIRST || c > SURR2_LAST) {\n                    outBuf[outPtr++] = (byte) (0xe0 | (c >> 12));\n                    outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                    outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n                    continue;\n                }\n                // Yup, a surrogate:\n                if (c > SURR1_LAST) { // must be from first range\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                _surrogate = c;\n                // and if so, followed by another from next range\n                if (off >= len) { // unless we hit the end?\n                    break;\n                }\n                c = convertSurrogate(str.charAt(off++));\n                if (c > 0x10FFFF) { // illegal, as per RFC 4627\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                outBuf[outPtr++] = (byte) (0xf0 | (c >> 18));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 12) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n            }\n        }\n        _outPtr = outPtr;\n    }",
          "44": "    public void write(String str, int off, int len)  throws IOException\n    {\n        if (len < 2) {\n            if (len == 1) {\n                write(str.charAt(off));\n            }\n            return;\n        }\n\n        // First: do we have a leftover surrogate to deal with?\n        if (_surrogate > 0) {\n            char second = str.charAt(off++);\n            --len;\n            write(convertSurrogate(second));\n            // will have at least one more char (case of 1 char was checked earlier on)\n        }\n\n        int outPtr = _outPtr;\n        byte[] outBuf = _outBuffer;\n        int outBufLast = _outBufferEnd; // has 4 'spare' bytes\n\n        // All right; can just loop it nice and easy now:\n        len += off; // len will now be the end of input buffer\n\n        output_loop:\n        for (; off < len; ) {\n            /* First, let's ensure we can output at least 4 bytes\n             * (longest UTF-8 encoded codepoint):\n             */\n            if (outPtr >= outBufLast) {\n                _out.write(outBuf, 0, outPtr);\n                outPtr = 0;\n            }\n\n            int c = str.charAt(off++);\n            // And then see if we have an Ascii char:\n            if (c < 0x80) { // If so, can do a tight inner loop:\n                outBuf[outPtr++] = (byte)c;\n                // Let's calc how many ascii chars we can copy at most:\n                int maxInCount = (len - off);\n                int maxOutCount = (outBufLast - outPtr);\n\n                if (maxInCount > maxOutCount) {\n                    maxInCount = maxOutCount;\n                }\n                maxInCount += off;\n                ascii_loop:\n                while (true) {\n                    if (off >= maxInCount) { // done with max. ascii seq\n                        continue output_loop;\n                    }\n                    c = str.charAt(off++);\n                    if (c >= 0x80) {\n                        break ascii_loop;\n                    }\n                    outBuf[outPtr++] = (byte) c;\n                }\n            }\n\n            // Nope, multi-byte:\n            if (c < 0x800) { // 2-byte\n                outBuf[outPtr++] = (byte) (0xc0 | (c >> 6));\nbreak;\n                outBuf[outPtr++] = (byte) (128 & (c & 63));            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (c < SURR1_FIRST || c > SURR2_LAST) {\n                    outBuf[outPtr++] = (byte) (0xe0 | (c >> 12));\n                    outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                    outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n                    continue;\n                }\n                // Yup, a surrogate:\n                if (c > SURR1_LAST) { // must be from first range\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                _surrogate = c;\n                // and if so, followed by another from next range\n                if (off >= len) { // unless we hit the end?\n                    break;\n                }\n                c = convertSurrogate(str.charAt(off++));\n                if (c > 0x10FFFF) { // illegal, as per RFC 4627\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                outBuf[outPtr++] = (byte) (0xf0 | (c >> 18));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 12) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n            }\n        }\n        _outPtr = outPtr;\n    }",
          "45": "    public void write(String str, int off, int len)  throws IOException\n    {\n        if (len < 2) {\n            if (len == 1) {\n                write(str.charAt(off));\n            }\n            return;\n        }\n\n        // First: do we have a leftover surrogate to deal with?\n        if (_surrogate > 0) {\n            char second = str.charAt(off++);\n            --len;\n            write(convertSurrogate(second));\n            // will have at least one more char (case of 1 char was checked earlier on)\n        }\n\n        int outPtr = _outPtr;\n        byte[] outBuf = _outBuffer;\n        int outBufLast = _outBufferEnd; // has 4 'spare' bytes\n\n        // All right; can just loop it nice and easy now:\n        len += off; // len will now be the end of input buffer\n\n        output_loop:\n        for (; off < len; ) {\n            /* First, let's ensure we can output at least 4 bytes\n             * (longest UTF-8 encoded codepoint):\n             */\n            if (outPtr >= outBufLast) {\n                _out.write(outBuf, 0, outPtr);\n                outPtr = 0;\n            }\n\n            int c = str.charAt(off++);\n            // And then see if we have an Ascii char:\n            if (c < 0x80) { // If so, can do a tight inner loop:\n                outBuf[outPtr++] = (byte)c;\n                // Let's calc how many ascii chars we can copy at most:\n                int maxInCount = (len - off);\n                int maxOutCount = (outBufLast - outPtr);\n\n                if (maxInCount > maxOutCount) {\n                    maxInCount = maxOutCount;\n                }\n                maxInCount += off;\n                ascii_loop:\n                while (true) {\n                    if (off >= maxInCount) { // done with max. ascii seq\n                        continue output_loop;\n                    }\n                    c = str.charAt(off++);\n                    if (c >= 0x80) {\n                        break ascii_loop;\n                    }\n                    outBuf[outPtr++] = (byte) c;\n                }\n            }\n\n            // Nope, multi-byte:\n            if (c < 0x800) { // 2-byte\n                outBuf[outPtr++] = (byte) (0xc0 | (c >> 6));\noutBuf[outPtr++] = (byte)(c & 63);\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (c < SURR1_FIRST || c > SURR2_LAST) {\n                    outBuf[outPtr++] = (byte) (0xe0 | (c >> 12));\n                    outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                    outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n                    continue;\n                }\n                // Yup, a surrogate:\n                if (c > SURR1_LAST) { // must be from first range\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                _surrogate = c;\n                // and if so, followed by another from next range\n                if (off >= len) { // unless we hit the end?\n                    break;\n                }\n                c = convertSurrogate(str.charAt(off++));\n                if (c > 0x10FFFF) { // illegal, as per RFC 4627\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                outBuf[outPtr++] = (byte) (0xf0 | (c >> 18));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 12) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n            }\n        }\n        _outPtr = outPtr;\n    }",
          "46": "    public void write(String str, int off, int len)  throws IOException\n    {\n        if (len < 2) {\n            if (len == 1) {\n                write(str.charAt(off));\n            }\n            return;\n        }\n\n        // First: do we have a leftover surrogate to deal with?\n        if (_surrogate > 0) {\n            char second = str.charAt(off++);\n            --len;\n            write(convertSurrogate(second));\n            // will have at least one more char (case of 1 char was checked earlier on)\n        }\n\n        int outPtr = _outPtr;\n        byte[] outBuf = _outBuffer;\n        int outBufLast = _outBufferEnd; // has 4 'spare' bytes\n\n        // All right; can just loop it nice and easy now:\n        len += off; // len will now be the end of input buffer\n\n        output_loop:\n        for (; off < len; ) {\n            /* First, let's ensure we can output at least 4 bytes\n             * (longest UTF-8 encoded codepoint):\n             */\n            if (outPtr >= outBufLast) {\n                _out.write(outBuf, 0, outPtr);\n                outPtr = 0;\n            }\n\n            int c = str.charAt(off++);\n            // And then see if we have an Ascii char:\n            if (c < 0x80) { // If so, can do a tight inner loop:\n                outBuf[outPtr++] = (byte)c;\n                // Let's calc how many ascii chars we can copy at most:\n                int maxInCount = (len - off);\n                int maxOutCount = (outBufLast - outPtr);\n\n                if (maxInCount > maxOutCount) {\n                    maxInCount = maxOutCount;\n                }\n                maxInCount += off;\n                ascii_loop:\n                while (true) {\n                    if (off >= maxInCount) { // done with max. ascii seq\n                        continue output_loop;\n                    }\n                    c = str.charAt(off++);\n                    if (c >= 0x80) {\n                        break ascii_loop;\n                    }\n                    outBuf[outPtr++] = (byte) c;\n                }\n            }\n\n            // Nope, multi-byte:\n            if (c < 0x800) { // 2-byte\n                outBuf[outPtr++] = (byte) (0xc0 | (c >> 6));\ncontinue;\n                outBuf[outPtr++] = (byte) (128 & (c & 63));            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (c < SURR1_FIRST || c > SURR2_LAST) {\n                    outBuf[outPtr++] = (byte) (0xe0 | (c >> 12));\n                    outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                    outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n                    continue;\n                }\n                // Yup, a surrogate:\n                if (c > SURR1_LAST) { // must be from first range\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                _surrogate = c;\n                // and if so, followed by another from next range\n                if (off >= len) { // unless we hit the end?\n                    break;\n                }\n                c = convertSurrogate(str.charAt(off++));\n                if (c > 0x10FFFF) { // illegal, as per RFC 4627\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                outBuf[outPtr++] = (byte) (0xf0 | (c >> 18));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 12) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n            }\n        }\n        _outPtr = outPtr;\n    }",
          "47": "    public void write(String str, int off, int len)  throws IOException\n    {\n        if (len < 2) {\n            if (len == 1) {\n                write(str.charAt(off));\n            }\n            return;\n        }\n\n        // First: do we have a leftover surrogate to deal with?\n        if (_surrogate > 0) {\n            char second = str.charAt(off++);\n            --len;\n            write(convertSurrogate(second));\n            // will have at least one more char (case of 1 char was checked earlier on)\n        }\n\n        int outPtr = _outPtr;\n        byte[] outBuf = _outBuffer;\n        int outBufLast = _outBufferEnd; // has 4 'spare' bytes\n\n        // All right; can just loop it nice and easy now:\n        len += off; // len will now be the end of input buffer\n\n        output_loop:\n        for (; off < len; ) {\n            /* First, let's ensure we can output at least 4 bytes\n             * (longest UTF-8 encoded codepoint):\n             */\n            if (outPtr >= outBufLast) {\n                _out.write(outBuf, 0, outPtr);\n                outPtr = 0;\n            }\n\n            int c = str.charAt(off++);\n            // And then see if we have an Ascii char:\n            if (c < 0x80) { // If so, can do a tight inner loop:\n                outBuf[outPtr++] = (byte)c;\n                // Let's calc how many ascii chars we can copy at most:\n                int maxInCount = (len - off);\n                int maxOutCount = (outBufLast - outPtr);\n\n                if (maxInCount > maxOutCount) {\n                    maxInCount = maxOutCount;\n                }\n                maxInCount += off;\n                ascii_loop:\n                while (true) {\n                    if (off >= maxInCount) { // done with max. ascii seq\n                        continue output_loop;\n                    }\n                    c = str.charAt(off++);\n                    if (c >= 0x80) {\n                        break ascii_loop;\n                    }\n                    outBuf[outPtr++] = (byte) c;\n                }\n            }\n\n            // Nope, multi-byte:\n            if (c < 0x800) { // 2-byte\n                outBuf[outPtr++] = (byte) (0xc0 | (c >> 6));\noutBuf[outPtr++] = (((128 & (c & 63)) && (c[0] != outBuf[outPtr++])))?(128 & (c & 63)):outBuf[outPtr++];\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (c < SURR1_FIRST || c > SURR2_LAST) {\n                    outBuf[outPtr++] = (byte) (0xe0 | (c >> 12));\n                    outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                    outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n                    continue;\n                }\n                // Yup, a surrogate:\n                if (c > SURR1_LAST) { // must be from first range\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                _surrogate = c;\n                // and if so, followed by another from next range\n                if (off >= len) { // unless we hit the end?\n                    break;\n                }\n                c = convertSurrogate(str.charAt(off++));\n                if (c > 0x10FFFF) { // illegal, as per RFC 4627\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                outBuf[outPtr++] = (byte) (0xf0 | (c >> 18));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 12) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n            }\n        }\n        _outPtr = outPtr;\n    }",
          "48": "    public void write(String str, int off, int len)  throws IOException\n    {\n        if (len < 2) {\n            if (len == 1) {\n                write(str.charAt(off));\n            }\n            return;\n        }\n\n        // First: do we have a leftover surrogate to deal with?\n        if (_surrogate > 0) {\n            char second = str.charAt(off++);\n            --len;\n            write(convertSurrogate(second));\n            // will have at least one more char (case of 1 char was checked earlier on)\n        }\n\n        int outPtr = _outPtr;\n        byte[] outBuf = _outBuffer;\n        int outBufLast = _outBufferEnd; // has 4 'spare' bytes\n\n        // All right; can just loop it nice and easy now:\n        len += off; // len will now be the end of input buffer\n\n        output_loop:\n        for (; off < len; ) {\n            /* First, let's ensure we can output at least 4 bytes\n             * (longest UTF-8 encoded codepoint):\n             */\n            if (outPtr >= outBufLast) {\n                _out.write(outBuf, 0, outPtr);\n                outPtr = 0;\n            }\n\n            int c = str.charAt(off++);\n            // And then see if we have an Ascii char:\n            if (c < 0x80) { // If so, can do a tight inner loop:\n                outBuf[outPtr++] = (byte)c;\n                // Let's calc how many ascii chars we can copy at most:\n                int maxInCount = (len - off);\n                int maxOutCount = (outBufLast - outPtr);\n\n                if (maxInCount > maxOutCount) {\n                    maxInCount = maxOutCount;\n                }\n                maxInCount += off;\n                ascii_loop:\n                while (true) {\n                    if (off >= maxInCount) { // done with max. ascii seq\n                        continue output_loop;\n                    }\n                    c = str.charAt(off++);\n                    if (c >= 0x80) {\n                        break ascii_loop;\n                    }\n                    outBuf[outPtr++] = (byte) c;\n                }\n            }\n\n            // Nope, multi-byte:\n            if (c < 0x800) { // 2-byte\n                outBuf[outPtr++] = (byte) (0xc0 | (c >> 6));\noutBuf[outPtr++] = (((128 & (c & 63)) && (c[0] != outBuf[outPtr++])))?(128 & (c & 63)):c[outPtr++];\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (c < SURR1_FIRST || c > SURR2_LAST) {\n                    outBuf[outPtr++] = (byte) (0xe0 | (c >> 12));\n                    outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                    outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n                    continue;\n                }\n                // Yup, a surrogate:\n                if (c > SURR1_LAST) { // must be from first range\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                _surrogate = c;\n                // and if so, followed by another from next range\n                if (off >= len) { // unless we hit the end?\n                    break;\n                }\n                c = convertSurrogate(str.charAt(off++));\n                if (c > 0x10FFFF) { // illegal, as per RFC 4627\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                outBuf[outPtr++] = (byte) (0xf0 | (c >> 18));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 12) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n            }\n        }\n        _outPtr = outPtr;\n    }",
          "49": "    public void write(String str, int off, int len)  throws IOException\n    {\n        if (len < 2) {\n            if (len == 1) {\n                write(str.charAt(off));\n            }\n            return;\n        }\n\n        // First: do we have a leftover surrogate to deal with?\n        if (_surrogate > 0) {\n            char second = str.charAt(off++);\n            --len;\n            write(convertSurrogate(second));\n            // will have at least one more char (case of 1 char was checked earlier on)\n        }\n\n        int outPtr = _outPtr;\n        byte[] outBuf = _outBuffer;\n        int outBufLast = _outBufferEnd; // has 4 'spare' bytes\n\n        // All right; can just loop it nice and easy now:\n        len += off; // len will now be the end of input buffer\n\n        output_loop:\n        for (; off < len; ) {\n            /* First, let's ensure we can output at least 4 bytes\n             * (longest UTF-8 encoded codepoint):\n             */\n            if (outPtr >= outBufLast) {\n                _out.write(outBuf, 0, outPtr);\n                outPtr = 0;\n            }\n\n            int c = str.charAt(off++);\n            // And then see if we have an Ascii char:\n            if (c < 0x80) { // If so, can do a tight inner loop:\n                outBuf[outPtr++] = (byte)c;\n                // Let's calc how many ascii chars we can copy at most:\n                int maxInCount = (len - off);\n                int maxOutCount = (outBufLast - outPtr);\n\n                if (maxInCount > maxOutCount) {\n                    maxInCount = maxOutCount;\n                }\n                maxInCount += off;\n                ascii_loop:\n                while (true) {\n                    if (off >= maxInCount) { // done with max. ascii seq\n                        continue output_loop;\n                    }\n                    c = str.charAt(off++);\n                    if (c >= 0x80) {\n                        break ascii_loop;\n                    }\n                    outBuf[outPtr++] = (byte) c;\n                }\n            }\n\n            // Nope, multi-byte:\n            if (c < 0x800) { // 2-byte\n                outBuf[outPtr++] = (byte) (0xc0 | (c >> 6));\noutBuf[outPtr++] = (((128 & (c & 63)) && (outBuf[0] != outBuf[outPtr++])))?outBuf[outPtr++]:outBuf[outPtr++];\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (c < SURR1_FIRST || c > SURR2_LAST) {\n                    outBuf[outPtr++] = (byte) (0xe0 | (c >> 12));\n                    outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                    outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n                    continue;\n                }\n                // Yup, a surrogate:\n                if (c > SURR1_LAST) { // must be from first range\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                _surrogate = c;\n                // and if so, followed by another from next range\n                if (off >= len) { // unless we hit the end?\n                    break;\n                }\n                c = convertSurrogate(str.charAt(off++));\n                if (c > 0x10FFFF) { // illegal, as per RFC 4627\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                outBuf[outPtr++] = (byte) (0xf0 | (c >> 18));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 12) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n            }\n        }\n        _outPtr = outPtr;\n    }",
          "50": "    public void write(String str, int off, int len)  throws IOException\n    {\n        if (len < 2) {\n            if (len == 1) {\n                write(str.charAt(off));\n            }\n            return;\n        }\n\n        // First: do we have a leftover surrogate to deal with?\n        if (_surrogate > 0) {\n            char second = str.charAt(off++);\n            --len;\n            write(convertSurrogate(second));\n            // will have at least one more char (case of 1 char was checked earlier on)\n        }\n\n        int outPtr = _outPtr;\n        byte[] outBuf = _outBuffer;\n        int outBufLast = _outBufferEnd; // has 4 'spare' bytes\n\n        // All right; can just loop it nice and easy now:\n        len += off; // len will now be the end of input buffer\n\n        output_loop:\n        for (; off < len; ) {\n            /* First, let's ensure we can output at least 4 bytes\n             * (longest UTF-8 encoded codepoint):\n             */\n            if (outPtr >= outBufLast) {\n                _out.write(outBuf, 0, outPtr);\n                outPtr = 0;\n            }\n\n            int c = str.charAt(off++);\n            // And then see if we have an Ascii char:\n            if (c < 0x80) { // If so, can do a tight inner loop:\n                outBuf[outPtr++] = (byte)c;\n                // Let's calc how many ascii chars we can copy at most:\n                int maxInCount = (len - off);\n                int maxOutCount = (outBufLast - outPtr);\n\n                if (maxInCount > maxOutCount) {\n                    maxInCount = maxOutCount;\n                }\n                maxInCount += off;\n                ascii_loop:\n                while (true) {\n                    if (off >= maxInCount) { // done with max. ascii seq\n                        continue output_loop;\n                    }\n                    c = str.charAt(off++);\n                    if (c >= 0x80) {\n                        break ascii_loop;\n                    }\n                    outBuf[outPtr++] = (byte) c;\n                }\n            }\n\n            // Nope, multi-byte:\n            if (c < 0x800) { // 2-byte\n                outBuf[outPtr++] = (byte) (0xc0 | (c >> 6));\noutBuf[outPtr++] = (((128 & (c & 63)) && (outBuf[0] == outBuf[outPtr++])))?outBuf[outPtr++]:outBuf[outPtr++];\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (c < SURR1_FIRST || c > SURR2_LAST) {\n                    outBuf[outPtr++] = (byte) (0xe0 | (c >> 12));\n                    outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                    outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n                    continue;\n                }\n                // Yup, a surrogate:\n                if (c > SURR1_LAST) { // must be from first range\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                _surrogate = c;\n                // and if so, followed by another from next range\n                if (off >= len) { // unless we hit the end?\n                    break;\n                }\n                c = convertSurrogate(str.charAt(off++));\n                if (c > 0x10FFFF) { // illegal, as per RFC 4627\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                outBuf[outPtr++] = (byte) (0xf0 | (c >> 18));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 12) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n            }\n        }\n        _outPtr = outPtr;\n    }",
          "51": "    public void write(String str, int off, int len)  throws IOException\n    {\n        if (len < 2) {\n            if (len == 1) {\n                write(str.charAt(off));\n            }\n            return;\n        }\n\n        // First: do we have a leftover surrogate to deal with?\n        if (_surrogate > 0) {\n            char second = str.charAt(off++);\n            --len;\n            write(convertSurrogate(second));\n            // will have at least one more char (case of 1 char was checked earlier on)\n        }\n\n        int outPtr = _outPtr;\n        byte[] outBuf = _outBuffer;\n        int outBufLast = _outBufferEnd; // has 4 'spare' bytes\n\n        // All right; can just loop it nice and easy now:\n        len += off; // len will now be the end of input buffer\n\n        output_loop:\n        for (; off < len; ) {\n            /* First, let's ensure we can output at least 4 bytes\n             * (longest UTF-8 encoded codepoint):\n             */\n            if (outPtr >= outBufLast) {\n                _out.write(outBuf, 0, outPtr);\n                outPtr = 0;\n            }\n\n            int c = str.charAt(off++);\n            // And then see if we have an Ascii char:\n            if (c < 0x80) { // If so, can do a tight inner loop:\n                outBuf[outPtr++] = (byte)c;\n                // Let's calc how many ascii chars we can copy at most:\n                int maxInCount = (len - off);\n                int maxOutCount = (outBufLast - outPtr);\n\n                if (maxInCount > maxOutCount) {\n                    maxInCount = maxOutCount;\n                }\n                maxInCount += off;\n                ascii_loop:\n                while (true) {\n                    if (off >= maxInCount) { // done with max. ascii seq\n                        continue output_loop;\n                    }\n                    c = str.charAt(off++);\n                    if (c >= 0x80) {\n                        break ascii_loop;\n                    }\n                    outBuf[outPtr++] = (byte) c;\n                }\n            }\n\n            // Nope, multi-byte:\n            if (c < 0x800) { // 2-byte\n                outBuf[outPtr++] = (byte) (0xc0 | (c >> 6));\noutBuf[outPtr++] = (((128 & (c & 63)) && (c[0] != outBuf[outPtr++])))?outBuf[outPtr++]:outBuf[outPtr++];\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (c < SURR1_FIRST || c > SURR2_LAST) {\n                    outBuf[outPtr++] = (byte) (0xe0 | (c >> 12));\n                    outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                    outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n                    continue;\n                }\n                // Yup, a surrogate:\n                if (c > SURR1_LAST) { // must be from first range\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                _surrogate = c;\n                // and if so, followed by another from next range\n                if (off >= len) { // unless we hit the end?\n                    break;\n                }\n                c = convertSurrogate(str.charAt(off++));\n                if (c > 0x10FFFF) { // illegal, as per RFC 4627\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                outBuf[outPtr++] = (byte) (0xf0 | (c >> 18));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 12) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n            }\n        }\n        _outPtr = outPtr;\n    }",
          "52": "    public void write(String str, int off, int len)  throws IOException\n    {\n        if (len < 2) {\n            if (len == 1) {\n                write(str.charAt(off));\n            }\n            return;\n        }\n\n        // First: do we have a leftover surrogate to deal with?\n        if (_surrogate > 0) {\n            char second = str.charAt(off++);\n            --len;\n            write(convertSurrogate(second));\n            // will have at least one more char (case of 1 char was checked earlier on)\n        }\n\n        int outPtr = _outPtr;\n        byte[] outBuf = _outBuffer;\n        int outBufLast = _outBufferEnd; // has 4 'spare' bytes\n\n        // All right; can just loop it nice and easy now:\n        len += off; // len will now be the end of input buffer\n\n        output_loop:\n        for (; off < len; ) {\n            /* First, let's ensure we can output at least 4 bytes\n             * (longest UTF-8 encoded codepoint):\n             */\n            if (outPtr >= outBufLast) {\n                _out.write(outBuf, 0, outPtr);\n                outPtr = 0;\n            }\n\n            int c = str.charAt(off++);\n            // And then see if we have an Ascii char:\n            if (c < 0x80) { // If so, can do a tight inner loop:\n                outBuf[outPtr++] = (byte)c;\n                // Let's calc how many ascii chars we can copy at most:\n                int maxInCount = (len - off);\n                int maxOutCount = (outBufLast - outPtr);\n\n                if (maxInCount > maxOutCount) {\n                    maxInCount = maxOutCount;\n                }\n                maxInCount += off;\n                ascii_loop:\n                while (true) {\n                    if (off >= maxInCount) { // done with max. ascii seq\n                        continue output_loop;\n                    }\n                    c = str.charAt(off++);\n                    if (c >= 0x80) {\n                        break ascii_loop;\n                    }\n                    outBuf[outPtr++] = (byte) c;\n                }\n            }\n\n            // Nope, multi-byte:\n            if (c < 0x800) { // 2-byte\n                outBuf[outPtr++] = (byte) (0xc0 | (c >> 6));\noutBuf[outPtr++] = (((128 & (c & 63)) && (c[0] == outBuf[outPtr++])))?outBuf[outPtr++]:outBuf[outPtr++];\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (c < SURR1_FIRST || c > SURR2_LAST) {\n                    outBuf[outPtr++] = (byte) (0xe0 | (c >> 12));\n                    outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                    outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n                    continue;\n                }\n                // Yup, a surrogate:\n                if (c > SURR1_LAST) { // must be from first range\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                _surrogate = c;\n                // and if so, followed by another from next range\n                if (off >= len) { // unless we hit the end?\n                    break;\n                }\n                c = convertSurrogate(str.charAt(off++));\n                if (c > 0x10FFFF) { // illegal, as per RFC 4627\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                outBuf[outPtr++] = (byte) (0xf0 | (c >> 18));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 12) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n            }\n        }\n        _outPtr = outPtr;\n    }",
          "53": "    public void write(String str, int off, int len)  throws IOException\n    {\n        if (len < 2) {\n            if (len == 1) {\n                write(str.charAt(off));\n            }\n            return;\n        }\n\n        // First: do we have a leftover surrogate to deal with?\n        if (_surrogate > 0) {\n            char second = str.charAt(off++);\n            --len;\n            write(convertSurrogate(second));\n            // will have at least one more char (case of 1 char was checked earlier on)\n        }\n\n        int outPtr = _outPtr;\n        byte[] outBuf = _outBuffer;\n        int outBufLast = _outBufferEnd; // has 4 'spare' bytes\n\n        // All right; can just loop it nice and easy now:\n        len += off; // len will now be the end of input buffer\n\n        output_loop:\n        for (; off < len; ) {\n            /* First, let's ensure we can output at least 4 bytes\n             * (longest UTF-8 encoded codepoint):\n             */\n            if (outPtr >= outBufLast) {\n                _out.write(outBuf, 0, outPtr);\n                outPtr = 0;\n            }\n\n            int c = str.charAt(off++);\n            // And then see if we have an Ascii char:\n            if (c < 0x80) { // If so, can do a tight inner loop:\n                outBuf[outPtr++] = (byte)c;\n                // Let's calc how many ascii chars we can copy at most:\n                int maxInCount = (len - off);\n                int maxOutCount = (outBufLast - outPtr);\n\n                if (maxInCount > maxOutCount) {\n                    maxInCount = maxOutCount;\n                }\n                maxInCount += off;\n                ascii_loop:\n                while (true) {\n                    if (off >= maxInCount) { // done with max. ascii seq\n                        continue output_loop;\n                    }\n                    c = str.charAt(off++);\n                    if (c >= 0x80) {\n                        break ascii_loop;\n                    }\n                    outBuf[outPtr++] = (byte) c;\n                }\n            }\n\n            // Nope, multi-byte:\n            if (c < 0x800) { // 2-byte\n                outBuf[outPtr++] = (byte) (0xc0 | (c >> 6));\noutBuf[outPtr++] = (((128 & (c & 63)) && (outBuf[0] != outBuf[outPtr++])))?outBuf[outPtr++]:(128 & (c & 63));\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (c < SURR1_FIRST || c > SURR2_LAST) {\n                    outBuf[outPtr++] = (byte) (0xe0 | (c >> 12));\n                    outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                    outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n                    continue;\n                }\n                // Yup, a surrogate:\n                if (c > SURR1_LAST) { // must be from first range\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                _surrogate = c;\n                // and if so, followed by another from next range\n                if (off >= len) { // unless we hit the end?\n                    break;\n                }\n                c = convertSurrogate(str.charAt(off++));\n                if (c > 0x10FFFF) { // illegal, as per RFC 4627\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                outBuf[outPtr++] = (byte) (0xf0 | (c >> 18));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 12) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n            }\n        }\n        _outPtr = outPtr;\n    }",
          "54": "    public void write(String str, int off, int len)  throws IOException\n    {\n        if (len < 2) {\n            if (len == 1) {\n                write(str.charAt(off));\n            }\n            return;\n        }\n\n        // First: do we have a leftover surrogate to deal with?\n        if (_surrogate > 0) {\n            char second = str.charAt(off++);\n            --len;\n            write(convertSurrogate(second));\n            // will have at least one more char (case of 1 char was checked earlier on)\n        }\n\n        int outPtr = _outPtr;\n        byte[] outBuf = _outBuffer;\n        int outBufLast = _outBufferEnd; // has 4 'spare' bytes\n\n        // All right; can just loop it nice and easy now:\n        len += off; // len will now be the end of input buffer\n\n        output_loop:\n        for (; off < len; ) {\n            /* First, let's ensure we can output at least 4 bytes\n             * (longest UTF-8 encoded codepoint):\n             */\n            if (outPtr >= outBufLast) {\n                _out.write(outBuf, 0, outPtr);\n                outPtr = 0;\n            }\n\n            int c = str.charAt(off++);\n            // And then see if we have an Ascii char:\n            if (c < 0x80) { // If so, can do a tight inner loop:\n                outBuf[outPtr++] = (byte)c;\n                // Let's calc how many ascii chars we can copy at most:\n                int maxInCount = (len - off);\n                int maxOutCount = (outBufLast - outPtr);\n\n                if (maxInCount > maxOutCount) {\n                    maxInCount = maxOutCount;\n                }\n                maxInCount += off;\n                ascii_loop:\n                while (true) {\n                    if (off >= maxInCount) { // done with max. ascii seq\n                        continue output_loop;\n                    }\n                    c = str.charAt(off++);\n                    if (c >= 0x80) {\n                        break ascii_loop;\n                    }\n                    outBuf[outPtr++] = (byte) c;\n                }\n            }\n\n            // Nope, multi-byte:\n            if (c < 0x800) { // 2-byte\n                outBuf[outPtr++] = (byte) (0xc0 | (c >> 6));\noutBuf[outPtr++] = (((128 & (c & 63)) && (c[0] != outBuf[outPtr++])))?outBuf[outPtr++]:(128 & (c & 63));\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (c < SURR1_FIRST || c > SURR2_LAST) {\n                    outBuf[outPtr++] = (byte) (0xe0 | (c >> 12));\n                    outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                    outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n                    continue;\n                }\n                // Yup, a surrogate:\n                if (c > SURR1_LAST) { // must be from first range\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                _surrogate = c;\n                // and if so, followed by another from next range\n                if (off >= len) { // unless we hit the end?\n                    break;\n                }\n                c = convertSurrogate(str.charAt(off++));\n                if (c > 0x10FFFF) { // illegal, as per RFC 4627\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                outBuf[outPtr++] = (byte) (0xf0 | (c >> 18));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 12) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n            }\n        }\n        _outPtr = outPtr;\n    }",
          "55": "    public void write(String str, int off, int len)  throws IOException\n    {\n        if (len < 2) {\n            if (len == 1) {\n                write(str.charAt(off));\n            }\n            return;\n        }\n\n        // First: do we have a leftover surrogate to deal with?\n        if (_surrogate > 0) {\n            char second = str.charAt(off++);\n            --len;\n            write(convertSurrogate(second));\n            // will have at least one more char (case of 1 char was checked earlier on)\n        }\n\n        int outPtr = _outPtr;\n        byte[] outBuf = _outBuffer;\n        int outBufLast = _outBufferEnd; // has 4 'spare' bytes\n\n        // All right; can just loop it nice and easy now:\n        len += off; // len will now be the end of input buffer\n\n        output_loop:\n        for (; off < len; ) {\n            /* First, let's ensure we can output at least 4 bytes\n             * (longest UTF-8 encoded codepoint):\n             */\n            if (outPtr >= outBufLast) {\n                _out.write(outBuf, 0, outPtr);\n                outPtr = 0;\n            }\n\n            int c = str.charAt(off++);\n            // And then see if we have an Ascii char:\n            if (c < 0x80) { // If so, can do a tight inner loop:\n                outBuf[outPtr++] = (byte)c;\n                // Let's calc how many ascii chars we can copy at most:\n                int maxInCount = (len - off);\n                int maxOutCount = (outBufLast - outPtr);\n\n                if (maxInCount > maxOutCount) {\n                    maxInCount = maxOutCount;\n                }\n                maxInCount += off;\n                ascii_loop:\n                while (true) {\n                    if (off >= maxInCount) { // done with max. ascii seq\n                        continue output_loop;\n                    }\n                    c = str.charAt(off++);\n                    if (c >= 0x80) {\n                        break ascii_loop;\n                    }\n                    outBuf[outPtr++] = (byte) c;\n                }\n            }\n\n            // Nope, multi-byte:\n            if (c < 0x800) { // 2-byte\n                outBuf[outPtr++] = (byte) (0xc0 | (c >> 6));\noutBuf[outPtr++] = (((128 & (c & 63)) && (c[0] != outBuf[outPtr++])))?outBuf[outPtr++]:c[outPtr++];\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (c < SURR1_FIRST || c > SURR2_LAST) {\n                    outBuf[outPtr++] = (byte) (0xe0 | (c >> 12));\n                    outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                    outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n                    continue;\n                }\n                // Yup, a surrogate:\n                if (c > SURR1_LAST) { // must be from first range\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                _surrogate = c;\n                // and if so, followed by another from next range\n                if (off >= len) { // unless we hit the end?\n                    break;\n                }\n                c = convertSurrogate(str.charAt(off++));\n                if (c > 0x10FFFF) { // illegal, as per RFC 4627\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                outBuf[outPtr++] = (byte) (0xf0 | (c >> 18));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 12) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n            }\n        }\n        _outPtr = outPtr;\n    }",
          "56": "    public void write(String str, int off, int len)  throws IOException\n    {\n        if (len < 2) {\n            if (len == 1) {\n                write(str.charAt(off));\n            }\n            return;\n        }\n\n        // First: do we have a leftover surrogate to deal with?\n        if (_surrogate > 0) {\n            char second = str.charAt(off++);\n            --len;\n            write(convertSurrogate(second));\n            // will have at least one more char (case of 1 char was checked earlier on)\n        }\n\n        int outPtr = _outPtr;\n        byte[] outBuf = _outBuffer;\n        int outBufLast = _outBufferEnd; // has 4 'spare' bytes\n\n        // All right; can just loop it nice and easy now:\n        len += off; // len will now be the end of input buffer\n\n        output_loop:\n        for (; off < len; ) {\n            /* First, let's ensure we can output at least 4 bytes\n             * (longest UTF-8 encoded codepoint):\n             */\n            if (outPtr >= outBufLast) {\n                _out.write(outBuf, 0, outPtr);\n                outPtr = 0;\n            }\n\n            int c = str.charAt(off++);\n            // And then see if we have an Ascii char:\n            if (c < 0x80) { // If so, can do a tight inner loop:\n                outBuf[outPtr++] = (byte)c;\n                // Let's calc how many ascii chars we can copy at most:\n                int maxInCount = (len - off);\n                int maxOutCount = (outBufLast - outPtr);\n\n                if (maxInCount > maxOutCount) {\n                    maxInCount = maxOutCount;\n                }\n                maxInCount += off;\n                ascii_loop:\n                while (true) {\n                    if (off >= maxInCount) { // done with max. ascii seq\n                        continue output_loop;\n                    }\n                    c = str.charAt(off++);\n                    if (c >= 0x80) {\n                        break ascii_loop;\n                    }\n                    outBuf[outPtr++] = (byte) c;\n                }\n            }\n\n            // Nope, multi-byte:\n            if (c < 0x800) { // 2-byte\n                outBuf[outPtr++] = (byte) (0xc0 | (c >> 6));\noutBuf[outPtr++] = (((128 & (c & 63)) && (c[0] == outBuf[outPtr++])))?outBuf[outPtr++]:c[outPtr++];\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (c < SURR1_FIRST || c > SURR2_LAST) {\n                    outBuf[outPtr++] = (byte) (0xe0 | (c >> 12));\n                    outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                    outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n                    continue;\n                }\n                // Yup, a surrogate:\n                if (c > SURR1_LAST) { // must be from first range\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                _surrogate = c;\n                // and if so, followed by another from next range\n                if (off >= len) { // unless we hit the end?\n                    break;\n                }\n                c = convertSurrogate(str.charAt(off++));\n                if (c > 0x10FFFF) { // illegal, as per RFC 4627\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                outBuf[outPtr++] = (byte) (0xf0 | (c >> 18));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 12) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n            }\n        }\n        _outPtr = outPtr;\n    }",
          "57": "    public void write(String str, int off, int len)  throws IOException\n    {\n        if (len < 2) {\n            if (len == 1) {\n                write(str.charAt(off));\n            }\n            return;\n        }\n\n        // First: do we have a leftover surrogate to deal with?\n        if (_surrogate > 0) {\n            char second = str.charAt(off++);\n            --len;\n            write(convertSurrogate(second));\n            // will have at least one more char (case of 1 char was checked earlier on)\n        }\n\n        int outPtr = _outPtr;\n        byte[] outBuf = _outBuffer;\n        int outBufLast = _outBufferEnd; // has 4 'spare' bytes\n\n        // All right; can just loop it nice and easy now:\n        len += off; // len will now be the end of input buffer\n\n        output_loop:\n        for (; off < len; ) {\n            /* First, let's ensure we can output at least 4 bytes\n             * (longest UTF-8 encoded codepoint):\n             */\n            if (outPtr >= outBufLast) {\n                _out.write(outBuf, 0, outPtr);\n                outPtr = 0;\n            }\n\n            int c = str.charAt(off++);\n            // And then see if we have an Ascii char:\n            if (c < 0x80) { // If so, can do a tight inner loop:\n                outBuf[outPtr++] = (byte)c;\n                // Let's calc how many ascii chars we can copy at most:\n                int maxInCount = (len - off);\n                int maxOutCount = (outBufLast - outPtr);\n\n                if (maxInCount > maxOutCount) {\n                    maxInCount = maxOutCount;\n                }\n                maxInCount += off;\n                ascii_loop:\n                while (true) {\n                    if (off >= maxInCount) { // done with max. ascii seq\n                        continue output_loop;\n                    }\n                    c = str.charAt(off++);\n                    if (c >= 0x80) {\n                        break ascii_loop;\n                    }\n                    outBuf[outPtr++] = (byte) c;\n                }\n            }\n\n            // Nope, multi-byte:\n            if (c < 0x800) { // 2-byte\n                outBuf[outPtr++] = (byte) (0xc0 | (c >> 6));\noutBuf[outPtr++] = (((128 & (c & 63)) && (outBuf[0] != outBuf[outPtr++])))?outBuf[outPtr++]:c[outPtr++];\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (c < SURR1_FIRST || c > SURR2_LAST) {\n                    outBuf[outPtr++] = (byte) (0xe0 | (c >> 12));\n                    outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                    outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n                    continue;\n                }\n                // Yup, a surrogate:\n                if (c > SURR1_LAST) { // must be from first range\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                _surrogate = c;\n                // and if so, followed by another from next range\n                if (off >= len) { // unless we hit the end?\n                    break;\n                }\n                c = convertSurrogate(str.charAt(off++));\n                if (c > 0x10FFFF) { // illegal, as per RFC 4627\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                outBuf[outPtr++] = (byte) (0xf0 | (c >> 18));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 12) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n            }\n        }\n        _outPtr = outPtr;\n    }",
          "58": "    public void write(String str, int off, int len)  throws IOException\n    {\n        if (len < 2) {\n            if (len == 1) {\n                write(str.charAt(off));\n            }\n            return;\n        }\n\n        // First: do we have a leftover surrogate to deal with?\n        if (_surrogate > 0) {\n            char second = str.charAt(off++);\n            --len;\n            write(convertSurrogate(second));\n            // will have at least one more char (case of 1 char was checked earlier on)\n        }\n\n        int outPtr = _outPtr;\n        byte[] outBuf = _outBuffer;\n        int outBufLast = _outBufferEnd; // has 4 'spare' bytes\n\n        // All right; can just loop it nice and easy now:\n        len += off; // len will now be the end of input buffer\n\n        output_loop:\n        for (; off < len; ) {\n            /* First, let's ensure we can output at least 4 bytes\n             * (longest UTF-8 encoded codepoint):\n             */\n            if (outPtr >= outBufLast) {\n                _out.write(outBuf, 0, outPtr);\n                outPtr = 0;\n            }\n\n            int c = str.charAt(off++);\n            // And then see if we have an Ascii char:\n            if (c < 0x80) { // If so, can do a tight inner loop:\n                outBuf[outPtr++] = (byte)c;\n                // Let's calc how many ascii chars we can copy at most:\n                int maxInCount = (len - off);\n                int maxOutCount = (outBufLast - outPtr);\n\n                if (maxInCount > maxOutCount) {\n                    maxInCount = maxOutCount;\n                }\n                maxInCount += off;\n                ascii_loop:\n                while (true) {\n                    if (off >= maxInCount) { // done with max. ascii seq\n                        continue output_loop;\n                    }\n                    c = str.charAt(off++);\n                    if (c >= 0x80) {\n                        break ascii_loop;\n                    }\n                    outBuf[outPtr++] = (byte) c;\n                }\n            }\n\n            // Nope, multi-byte:\n            if (c < 0x800) { // 2-byte\n                outBuf[outPtr++] = (byte) (0xc0 | (c >> 6));\noutBuf[outPtr++] = (((128 & (c & 63)) && (outBuf[0] == outBuf[outPtr++])))?outBuf[outPtr++]:c[outPtr++];\n            } else { // 3 or 4 bytes\n                // Surrogates?\n                if (c < SURR1_FIRST || c > SURR2_LAST) {\n                    outBuf[outPtr++] = (byte) (0xe0 | (c >> 12));\n                    outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                    outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n                    continue;\n                }\n                // Yup, a surrogate:\n                if (c > SURR1_LAST) { // must be from first range\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                _surrogate = c;\n                // and if so, followed by another from next range\n                if (off >= len) { // unless we hit the end?\n                    break;\n                }\n                c = convertSurrogate(str.charAt(off++));\n                if (c > 0x10FFFF) { // illegal, as per RFC 4627\n                    _outPtr = outPtr;\n                    illegalSurrogate(c);\n                }\n                outBuf[outPtr++] = (byte) (0xf0 | (c >> 18));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 12) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n            }\n        }\n        _outPtr = outPtr;\n    }"
}