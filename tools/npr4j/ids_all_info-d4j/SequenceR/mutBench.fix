if ( dataset == null ) {
return " title=\"" + ImageMapUtilities . htmlEscape ( toolTipText )
PathIterator iterator2 = p2 . getPathIterator ( null ) ;
setDataset ( dataset ) ;
new Range ( 0.0 , Math . max ( constraint . getWidth ( ) - w [ 2 ] , 0.0 ) ) ,
super ( paint , stroke , outlinePaint , outlineStroke , alpha ) ;
int g = ( int ) ( ( v - this . lowerBound ) / ( this . upperBound
this ( time , zone , Locale . getDefault ( ) ) ;
if ( ( endIndex < 0 ) || ( endIndex < startIndex ) ) {
if ( option . hasArg ( ) && option . hasArgName ( ) )
nextLineTabStop = 1 ;
continue ;
throw new ParseException ( "Unable to handle the class: " + clazz ) ;
pos = findWrapPos ( text , width , 0 ) ;
return anyResultsMatch ( n , MAY_BE_STRING_PREDICATE ) ;
removeDuplicateDeclarations ( root ) ;
if ( ! result . isNoType ( ) ) {
if ( provided != null || requiresLevel . isOn ( ) ) {
} else if ( ! ( parent . isCall ( ) && parent . getFirstChild ( ) == n ) ) {
Context rhsContext = getContextForNoInOperator ( context ) ;
if ( fnType != null && fnType . hasInstanceType ( ) ) {
Node next = c . getNext ( ) ;
if ( ! name . inExterns && name . globalSets == 1 && name . localSets == 0 &&
cfa . createEdge ( fromNode , Branch . ON_EX , finallyNode ) ;
if ( t . getScopeDepth ( ) <= 1 ) {
if ( options . dependencyOptions . needsManagement ( ) ) {
if ( ( x < 0 || negativeZero ) && prev == '-' ) {
return len > 0 && s . charAt ( 0 ) != '0' ;
if ( target != null && target . getType ( ) == Token . STRING ) {
&& 0 <= charno && charno <= sourceExcerpt . length ( ) ) {
case '\0' : sb . append ( "\\000" ) ; break ;
&& assign . getParent ( ) . getType ( ) == Token . EXPR_RESULT ) {
jsDocParameter . getJSType ( ) , false ) ;
boolean isOverride = parent . getJSDocInfo ( ) != null &&
if ( c > 0x1f && c < 0x7f ) {
return false ;
int indexOfDot = namespace . lastIndexOf ( '.' ) ;
txt = txt . replaceAll ( "mb$" , "m2" ) ;
return newString ( bytes , Charsets . ISO_8859_1 ) ;
return cs1 . length ( ) == cs2 . length ( ) && CharSequenceUtils . regionMatches ( cs1 , false , 0 , cs2 , 0 , cs1 . length ( ) ) ;
if ( lineLength > 0 && pos > 0 ) {
} else if ( contains ( value , index + 1 , 3 , "IER" ) ) {
this ( 0 ) ;
return StringUtils . newStringUtf8 ( encodeBase64 ( binaryData , false ) ) ;
long len = getEncodeLength ( binaryData , isChunked ? MIME_CHUNK_SIZE : 0 , CHUNK_SEPARATOR ) ;
protected Object readResolve ( ) {
if ( rawCentralDirectoryData . length < expectedLength ) {
dictSize |= ( coder . properties [ i + 1 ] & 0xffl ) << ( 8 * i ) ;
if ( ! isPaxHeader ( ) && ! isGlobalPaxHeader ( ) && getName ( ) . endsWith ( "/" ) ) {
if ( current == '\r' || ( current == '\n' && lastChar != '\r' ) ) {
final boolean emptyHeader = header == null || header . trim ( ) . isEmpty ( ) ;
if ( newRecord && ( c < 0x20 || c > 0x21 && c < 0x23 || c > 0x2B && c < 0x2D || c > 0x7E ) ) {
return this . headerMap == null ? null : new LinkedHashMap < String , Integer > ( this . headerMap ) ;
if ( last == NUMBER_CHAR_DIGIT && fitsInLong && ( value != Long . MIN_VALUE || negative ) && ( value != 0 || false == negative ) ) {
if ( ! lenient && ( Double . isNaN ( value ) || Double . isInfinite ( value ) ) ) {
if ( i < maxCode ) {
char c = str . charAt ( i ) ;
if ( ! _hasSegments && _currentSegment != null ) return _currentSegment ;
return NullifyingDeserializer . instance ;
return ( previous == null ) || ! previous . equals ( ann ) ;
&& ! TreeNode . class . isAssignableFrom ( t . getRawClass ( ) ) ) ;
if ( ext . handlePropertyValue ( p , ctxt , propName , null ) ) {
visitFloatFormat ( visitor , typeHint , JsonParser . NumberType . BIG_DECIMAL ) ;
return new SimpleType ( subclass , _bindings , this , _superInterfaces ,
sb . append ( ">;" ) ;
return _bindAndReadValues ( _considerFilter ( _parserFactory . createParser ( src , offset , length ) ,
found = key . equals ( _hashArea [ i - 1 ] ) ;
if ( raw == String . class || raw == Object . class || raw == CharSequence . class ) {
ignored = ignorals . findIgnoredForDeserialization ( ) ;
paramName = candidate . paramName ( 0 ) ;
ctxt . defaultSerializeValue ( _value , gen ) ;
_rootNameLookup = new XmlRootNameLookup ( ) ;
} else if ( StringUtil . in ( name , "base" , "basefont" , "bgsound" , "command" , "link" , "meta" , "noframes" , "script" , "style" , "title" ) ) {
clone . classNames = null ;
if ( offset < length && last <= length ) {
return getOutputSettings ( ) . prettyPrint ( ) ? accum . toString ( ) . trim ( ) : accum . toString ( ) ;
return tag . equals ( element . tag ) ;
if ( element == search )
} else if ( ( "td" . equals ( name ) || "th" . equals ( name ) && ! last ) ) {
accum . append ( "&#xa0;" ) ;
if ( ! inAttribute || escapeMode == EscapeMode . xhtml )
reindexChildren ( index ) ;
return ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) || Character . isLetter ( c ) ;
it . remove ( ) ;
final String classAttr = attributes . getIgnoreCase ( "class" ) ;
String name = t . asEndTag ( ) . name ( ) ;
tb . tokeniser . transition ( TokeniserState . Rawtext ) ;
String elName = endTag . normalName ( ) ;
if ( doc . children ( ) . size ( ) > 0 ) {
return Attributes . checkNotNull ( val ) ;
return compute ( args [ 0 ] . compute ( context ) , args [ 1 ] . compute ( context ) )
if ( str . startsWith ( "0x" ) || str . startsWith ( "-0x" ) || str . startsWith ( "0X" ) || str . startsWith ( "-0X" ) ) {
cal1 . get ( Calendar . HOUR_OF_DAY ) == cal2 . get ( Calendar . HOUR_OF_DAY ) &&
return foundDigit && ! hasExp && ! hasDecPoint ;
Calendar c = new GregorianCalendar ( mTimeZone , mLocale ) ;
static int toJavaVersionInt ( String version ) {
classes [ i ] = array [ i ] == null ? null : array [ i ] . getClass ( ) ;
return availableLocaleList ( ) . contains ( locale ) ;
str . getChars ( 0 , width , buffer , size ) ;
pos += Character . charCount ( Character . codePointAt ( input , pt ) ) ;
int len = size - strLen + 1 ;
return Math . max ( 0d , sumYY - sumXY * sumXY / sumXX ) ;
return FastMath . pow ( 2 * FastMath . PI , - 0.5 * dim ) *
return getSampleSize ( ) * ( getNumberOfSuccesses ( ) / ( double ) getPopulationSize ( ) ) ;
return 100 * doubleValue ( ) ;
final double n1n2prod = n1 * n2 ;
if ( tree . getCut ( ) == null && ( Boolean ) tree . getAttribute ( ) ) {
if ( Precision . compareTo ( entry , 0d , epsilon ) > 0 ) {
return getChromosomes ( ) . iterator ( ) ;
for ( int i = begin ; i < begin + length ; i ++ ) {
return INF ;
double sum = 0 ;
return fit ( guess ) ;
return ( a <= b ) ? b : ( Float . isNaN ( a + b ) ? Float . NaN : a ) ;
return equals ( x , y , 1 ) ;
out [ i ] [ j ] = 2 * tDistribution . cumulativeProbability ( - t ) ;
return solve ( f , min , max ) ;
return getPct ( ( Comparable < ? > ) v ) ;
int j = 4 * ( n - 1 ) ;
if ( MathUtils . compareTo ( entry , 0 , epsilon ) > 0 ) {
if ( fa * fb > 0.0 ) {
if ( ( u == 0 ) || ( v == 0 ) ) {
ret = ( real == rhs . real ) && ( imaginary == rhs . imaginary ) ;
return invocation . getMock ( ) == invocation . getArguments ( ) [ 0 ] ? 0 : 1 ;
description . appendText ( wanted == null ? "null" : wanted . toString ( ) ) ;
if ( m instanceof CapturesArguments && i . getArguments ( ) . length > k ) {
return StringDescription . toString ( m ) . equals ( arg == null ? "null" : arg . toString ( ) ) ;
catch ( AssertionError e ) {
} else if ( typeParameter != actualTypeArgument ) {
instantLocal , chrono , iLocale , iPivotYear , chrono . year ( ) . get ( instantLocal ) ) ;
} else if ( offsetLocal >= 0 ) {
Partial newPartial = new Partial ( newTypes , newValues , iChronology ) ;
int defaultYear = DateTimeUtils . getChronology ( chrono ) . year ( ) . get ( instantMillis ) ;
