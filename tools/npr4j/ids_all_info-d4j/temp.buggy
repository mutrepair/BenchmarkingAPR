if ( dataset != null ) { <CTX> public Legend CaMeL Item CaMeL Collection get CaMeL Legend CaMeL Items ( ) { Legend CaMeL Item CaMeL Collection result = new Legend CaMeL Item CaMeL Collection ( ) ; if ( this . plot == null ) { return result ; } int index = this . plot . get CaMeL Index CaMeL Of ( this ) ; Category CaMeL Dataset dataset = this . plot . get CaMeL Dataset ( index ) ; if ( dataset != null ) { return result ; } int series CaMeL Count = dataset . get CaMeL Row CaMeL Count ( ) ; if ( plot . get CaMeL Row CaMeL Rendering CaMeL Order ( ) . equals ( Sort CaMeL Order . ASCENDING ) ) { for ( int i = 0 ; i < series CaMeL Count ; i ++ ) { if ( is CaMeL Series CaMeL Visible CaMeL In CaMeL Legend ( i ) ) { Legend CaMeL Item item = get CaMeL Legend CaMeL Item ( index , i ) ; if ( item != null ) { result . add ( item ) ; } } } } else { for ( int i = series CaMeL Count - 1 ; i >= 0 ; i -- ) { if ( is CaMeL Series CaMeL Visible CaMeL In CaMeL Legend ( i ) ) { Legend CaMeL Item item = get CaMeL Legend CaMeL Item ( index , i ) ; if ( item != null ) { result . add ( item ) ; } } } } return result ; }
return $STRING$ + tool CaMeL Tip CaMeL Text <CTX> 
Path CaMeL Iterator iterator $NUMBER$ = p 1 . get CaMeL Path CaMeL Iterator ( null ) ; <CTX> public static boolean equal ( General CaMeL Path p 1 , General CaMeL Path p $NUMBER$ ) { if ( p 1 == null ) { return ( p $NUMBER$ == null ) ; } if ( p $NUMBER$ == null ) { return false ; } if ( p 1 . get CaMeL Winding CaMeL Rule ( ) != p $NUMBER$ . get CaMeL Winding CaMeL Rule ( ) ) { return false ; } Path CaMeL Iterator iterator 1 = p 1 . get CaMeL Path CaMeL Iterator ( null ) ; Path CaMeL Iterator iterator $NUMBER$ = p 1 . get CaMeL Path CaMeL Iterator ( null ) ; double [ ] d 1 = new double [ $NUMBER$ ] ; double [ ] d $NUMBER$ = new double [ $NUMBER$ ] ; boolean done = iterator 1 . is CaMeL Done ( ) && iterator $NUMBER$ . is CaMeL Done ( ) ; while ( ! done ) { if ( iterator 1 . is CaMeL Done ( ) != iterator $NUMBER$ . is CaMeL Done ( ) ) { return false ; } int seg 1 = iterator 1 . current CaMeL Segment ( d 1 ) ; int seg $NUMBER$ = iterator $NUMBER$ . current CaMeL Segment ( d $NUMBER$ ) ; if ( seg 1 != seg $NUMBER$ ) { return false ; } if ( ! Arrays . equals ( d 1 , d $NUMBER$ ) ) { return false ; } iterator 1 . next ( ) ; iterator $NUMBER$ . next ( ) ; done = iterator 1 . is CaMeL Done ( ) && iterator $NUMBER$ . is CaMeL Done ( ) ; } return true ; }
this . dataset = dataset ; <CTX> public Multiple CaMeL Pie CaMeL Plot ( Category CaMeL Dataset dataset ) { super ( ) ; this . dataset = dataset ; Pie CaMeL Plot pie CaMeL Plot = new Pie CaMeL Plot ( null ) ; this . pie CaMeL Chart = new J CaMeL Free CaMeL Chart ( pie CaMeL Plot ) ; this . pie CaMeL Chart . remove CaMeL Legend ( ) ; this . data CaMeL Extract CaMeL Order = Table CaMeL Order . BY _ COLUMN ; this . pie CaMeL Chart . set CaMeL Background CaMeL Paint ( null ) ; Text CaMeL Title series CaMeL Title = new Text CaMeL Title ( $STRING$ , new Font ( $STRING$ , Font . BOLD , $NUMBER$ ) ) ; series CaMeL Title . set CaMeL Position ( Rectangle CaMeL Edge . BOTTOM ) ; this . pie CaMeL Chart . set CaMeL Title ( series CaMeL Title ) ; this . aggregated CaMeL Items CaMeL Key = $STRING$ ; this . aggregated CaMeL Items CaMeL Paint = Color . light CaMeL Gray ; this . section CaMeL Paints = new Hash CaMeL Map ( ) ; }
new Range ( 0 . 0 , constraint . get CaMeL Width ( ) - w [ $NUMBER$ ] ) , <CTX> protected Size $NUMBER$ D arrange CaMeL FF ( Block CaMeL Container container , Graphics $NUMBER$ D g $NUMBER$ , Rectangle CaMeL Constraint constraint ) { double [ ] w = new double [ $NUMBER$ ] ; double [ ] h = new double [ $NUMBER$ ] ; w [ 0 ] = constraint . get CaMeL Width ( ) ; if ( this . top CaMeL Block != null ) { Rectangle CaMeL Constraint c 1 = new Rectangle CaMeL Constraint ( w [ 0 ] , null , Length CaMeL Constraint CaMeL Type . FIXED , 0 . 0 , new Range ( 0 . 0 , constraint . get CaMeL Height ( ) ) , Length CaMeL Constraint CaMeL Type . RANGE ) ; Size $NUMBER$ D size = this . top CaMeL Block . arrange ( g $NUMBER$ , c 1 ) ; h [ 0 ] = size . height ; } w [ 1 ] = w [ 0 ] ; if ( this . bottom CaMeL Block != null ) { Rectangle CaMeL Constraint c $NUMBER$ = new Rectangle CaMeL Constraint ( w [ 0 ] , null , Length CaMeL Constraint CaMeL Type . FIXED , 0 . 0 , new Range ( 0 . 0 , constraint . get CaMeL Height ( ) - h [ 0 ] ) , Length CaMeL Constraint CaMeL Type . RANGE ) ; Size $NUMBER$ D size = this . bottom CaMeL Block . arrange ( g $NUMBER$ , c $NUMBER$ ) ; h [ 1 ] = size . height ; } h [ $NUMBER$ ] = constraint . get CaMeL Height ( ) - h [ 1 ] - h [ 0 ] ; if ( this . left CaMeL Block != null ) { Rectangle CaMeL Constraint c $NUMBER$ = new Rectangle CaMeL Constraint ( 0 . 0 , new Range ( 0 . 0 , constraint . get CaMeL Width ( ) ) , Length CaMeL Constraint CaMeL Type . RANGE , h [ $NUMBER$ ] , null , Length CaMeL Constraint CaMeL Type . FIXED ) ; Size $NUMBER$ D size = this . left CaMeL Block . arrange ( g $NUMBER$ , c $NUMBER$ ) ; w [ $NUMBER$ ] = size . width ; } h [ $NUMBER$ ] = h [ $NUMBER$ ] ; if ( this . right CaMeL Block != null ) { Rectangle CaMeL Constraint c $NUMBER$ = new Rectangle CaMeL Constraint ( 0 . 0 , new Range ( 0 . 0 , constraint . get CaMeL Width ( ) - w [ $NUMBER$ ] ) , Length CaMeL Constraint CaMeL Type . RANGE , h [ $NUMBER$ ] , null , Length CaMeL Constraint CaMeL Type . FIXED ) ; Size $NUMBER$ D size = this . right CaMeL Block . arrange ( g $NUMBER$ , c $NUMBER$ ) ; w [ $NUMBER$ ] = size . width ; } h [ $NUMBER$ ] = h [ $NUMBER$ ] ; w [ $NUMBER$ ] = constraint . get CaMeL Width ( ) - w [ $NUMBER$ ] - w [ $NUMBER$ ] ; Rectangle CaMeL Constraint c $NUMBER$ = new Rectangle CaMeL Constraint ( w [ $NUMBER$ ] , h [ $NUMBER$ ] ) ; if ( this . center CaMeL Block != null ) { this . center CaMeL Block . arrange ( g $NUMBER$ , c $NUMBER$ ) ; } if ( this . top CaMeL Block != null ) { this . top CaMeL Block . set CaMeL Bounds ( new Rectangle $NUMBER$ D . Double ( 0 . 0 , 0 . 0 , w [ 0 ] , h [ 0 ] ) ) ; } if ( this . bottom CaMeL Block != null ) { this . bottom CaMeL Block . set CaMeL Bounds ( new Rectangle $NUMBER$ D . Double ( 0 . 0 , h [ 0 ] + h [ $NUMBER$ ] , w [ 1 ] , h [ 1 ] ) ) ; } if ( this . left CaMeL Block != null ) { this . left CaMeL Block . set CaMeL Bounds ( new Rectangle $NUMBER$ D . Double ( 0 . 0 , h [ 0 ] , w [ $NUMBER$ ] , h [ $NUMBER$ ] ) ) ; } if ( this . right CaMeL Block != null ) { this . right CaMeL Block . set CaMeL Bounds ( new Rectangle $NUMBER$ D . Double ( w [ $NUMBER$ ] + w [ $NUMBER$ ] , h [ 0 ] , w [ $NUMBER$ ] , h [ $NUMBER$ ] ) ) ; } if ( this . center CaMeL Block != null ) { this . center CaMeL Block . set CaMeL Bounds ( new Rectangle $NUMBER$ D . Double ( w [ $NUMBER$ ] , h [ 0 ] , w [ $NUMBER$ ] , h [ $NUMBER$ ] ) ) ; } return new Size $NUMBER$ D ( constraint . get CaMeL Width ( ) , constraint . get CaMeL Height ( ) ) ; }
super ( paint , stroke , paint , stroke , alpha ) ; <CTX> public Value CaMeL Marker ( double value , Paint paint , Stroke stroke , Paint outline CaMeL Paint , Stroke outline CaMeL Stroke , float alpha ) { super ( paint , stroke , paint , stroke , alpha ) ; this . value = value ; }
int g = ( int ) ( ( value - this . lower CaMeL Bound ) / ( this . upper CaMeL Bound <CTX> public Paint get CaMeL Paint ( double value ) { double v = Math . max ( value , this . lower CaMeL Bound ) ; v = Math . min ( v , this . upper CaMeL Bound ) ; int g = ( int ) ( ( value - this . lower CaMeL Bound ) / ( this . upper CaMeL Bound - this . lower CaMeL Bound ) * $NUMBER$ . 0 ) ; return new Color ( g , g , g ) ; }
this ( time , Regular CaMeL Time CaMeL Period . DEFAULT _ TIME _ ZONE , Locale . get CaMeL Default ( ) ) ; <CTX> public Week ( Date time , Time CaMeL Zone zone ) { / / defer argument checking . . . this ( time , Regular CaMeL Time CaMeL Period . DEFAULT _ TIME _ ZONE , Locale . get CaMeL Default ( ) ) ; }
if ( end CaMeL Index < 0 ) { <CTX> public Time CaMeL Series create CaMeL Copy ( Regular CaMeL Time CaMeL Period start , Regular CaMeL Time CaMeL Period end ) throws Clone CaMeL Not CaMeL Supported CaMeL Exception { if ( start == null ) { throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ ) ; } if ( end == null ) { throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ ) ; } if ( start . compare CaMeL To ( end ) > 0 ) { throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ ) ; } boolean empty CaMeL Range = false ; int start CaMeL Index = get CaMeL Index ( start ) ; if ( start CaMeL Index < 0 ) { start CaMeL Index = - ( start CaMeL Index + 1 ) ; if ( start CaMeL Index == this . data . size ( ) ) { empty CaMeL Range = true ; / / start is after last data item } } int end CaMeL Index = get CaMeL Index ( end ) ; if ( end CaMeL Index < 0 ) { / / end period is not in original series end CaMeL Index = - ( end CaMeL Index + 1 ) ; / / this is first item AFTER end period end CaMeL Index = end CaMeL Index - 1 ; / / so this is last item BEFORE end } if ( end CaMeL Index < 0 ) { empty CaMeL Range = true ; } if ( empty CaMeL Range ) { Time CaMeL Series copy = ( Time CaMeL Series ) super . clone ( ) ; copy . data = new java . util . Array CaMeL List ( ) ; return copy ; } else { return create CaMeL Copy ( start CaMeL Index , end CaMeL Index ) ; } }
if ( option . has CaMeL Arg ( ) && ( option . get CaMeL Arg CaMeL Name ( ) != null ) ) <CTX> private static void append CaMeL Option ( final String CaMeL Buffer buff , final Option option , final boolean required ) { if ( ! required ) { buff . append ( $STRING$ ) ; } if ( option . get CaMeL Opt ( ) != null ) { buff . append ( $STRING$ ) . append ( option . get CaMeL Opt ( ) ) ; } else { buff . append ( $STRING$ ) . append ( option . get CaMeL Long CaMeL Opt ( ) ) ; } / / if the Option has a value if ( option . has CaMeL Arg ( ) && ( option . get CaMeL Arg CaMeL Name ( ) != null ) ) { buff . append ( $STRING$ ) . append ( option . get CaMeL Arg CaMeL Name ( ) ) . append ( $STRING$ ) ; } / / if the Option is not a required option if ( ! required ) { buff . append ( $STRING$ ) ; } }
next CaMeL Line CaMeL Tab CaMeL Stop = width - 1 ; <CTX> protected String CaMeL Buffer render CaMeL Wrapped CaMeL Text ( String CaMeL Buffer sb , int width , int next CaMeL Line CaMeL Tab CaMeL Stop , String text ) { int pos = find CaMeL Wrap CaMeL Pos ( text , width , 0 ) ; if ( pos == - 1 ) { sb . append ( rtrim ( text ) ) ; return sb ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( default CaMeL New CaMeL Line ) ; if ( next CaMeL Line CaMeL Tab CaMeL Stop >= width ) { / / stops infinite loop happening next CaMeL Line CaMeL Tab CaMeL Stop = width - 1 ; } / / all following lines must be padded with next CaMeL Line CaMeL Tab CaMeL Stop space / / characters final String padding = create CaMeL Padding ( next CaMeL Line CaMeL Tab CaMeL Stop ) ; while ( true ) { text = padding + text . substring ( pos ) . trim ( ) ; pos = find CaMeL Wrap CaMeL Pos ( text , width , 0 ) ; if ( pos == - 1 ) { sb . append ( text ) ; return sb ; } if ( ( text . length ( ) > width ) && ( pos == next CaMeL Line CaMeL Tab CaMeL Stop - 1 ) ) { pos = width ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( default CaMeL New CaMeL Line ) ; } }
break ; <CTX> protected void process CaMeL Properties ( Properties properties ) { if ( properties == null ) { return ; } for ( Enumeration e = properties . property CaMeL Names ( ) ; e . has CaMeL More CaMeL Elements ( ) ; ) { String option = e . next CaMeL Element ( ) . to CaMeL String ( ) ; if ( ! cmd . has CaMeL Option ( option ) ) { Option opt = get CaMeL Options ( ) . get CaMeL Option ( option ) ; / / get the value from the properties instance String value = properties . get CaMeL Property ( option ) ; if ( opt . has CaMeL Arg ( ) ) { if ( opt . get CaMeL Values ( ) == null || opt . get CaMeL Values ( ) . length == 0 ) { try { opt . add CaMeL Value CaMeL For CaMeL Processing ( value ) ; } catch ( Runtime CaMeL Exception exp ) { / / if we cannot add the value don $STRING$ t add the / / option to the Command CaMeL Line break ; } cmd . add CaMeL Option ( opt ) ; } } }
return null ; <CTX> public static < T > T create CaMeL Value ( final String str , final Class < T > clazz ) throws Parse CaMeL Exception { if ( Pattern CaMeL Option CaMeL Builder . STRING _ VALUE == clazz ) { return ( T ) str ; } else if ( Pattern CaMeL Option CaMeL Builder . OBJECT _ VALUE == clazz ) { return ( T ) create CaMeL Object ( str ) ; } else if ( Pattern CaMeL Option CaMeL Builder . NUMBER _ VALUE == clazz ) { return ( T ) create CaMeL Number ( str ) ; } else if ( Pattern CaMeL Option CaMeL Builder . DATE _ VALUE == clazz ) { return ( T ) create CaMeL Date ( str ) ; } else if ( Pattern CaMeL Option CaMeL Builder . CLASS _ VALUE == clazz ) { return ( T ) create CaMeL Class ( str ) ; } else if ( Pattern CaMeL Option CaMeL Builder . FILE _ VALUE == clazz ) { return ( T ) create CaMeL File ( str ) ; } else if ( Pattern CaMeL Option CaMeL Builder . EXISTING _ FILE _ VALUE == clazz ) { return ( T ) open CaMeL File ( str ) ; } else if ( Pattern CaMeL Option CaMeL Builder . FILES _ VALUE == clazz ) { return ( T ) create CaMeL Files ( str ) ; } else if ( Pattern CaMeL Option CaMeL Builder . URL _ VALUE == clazz ) { return ( T ) create CaMeL URL ( str ) ; } else { return null ; } }
pos = find CaMeL Wrap CaMeL Pos ( text , width , next CaMeL Line CaMeL Tab CaMeL Stop ) ; <CTX> protected String CaMeL Buffer render CaMeL Wrapped CaMeL Text ( String CaMeL Buffer sb , int width , int next CaMeL Line CaMeL Tab CaMeL Stop , String text ) { int pos = find CaMeL Wrap CaMeL Pos ( text , width , 0 ) ; if ( pos == - 1 ) { sb . append ( rtrim ( text ) ) ; return sb ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( default CaMeL New CaMeL Line ) ; / / all following lines must be padded with next CaMeL Line CaMeL Tab CaMeL Stop space / / characters final String padding = create CaMeL Padding ( next CaMeL Line CaMeL Tab CaMeL Stop ) ; while ( true ) { text = padding + text . substring ( pos ) . trim ( ) ; pos = find CaMeL Wrap CaMeL Pos ( text , width , next CaMeL Line CaMeL Tab CaMeL Stop ) ; if ( pos == - 1 ) { sb . append ( text ) ; return sb ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( default CaMeL New CaMeL Line ) ; } }
return all CaMeL Results CaMeL Match ( n , MAY _ BE _ STRING _ PREDICATE ) ; <CTX> static boolean may CaMeL Be CaMeL String ( Node n , boolean recurse ) { if ( recurse ) { return all CaMeL Results CaMeL Match ( n , MAY _ BE _ STRING _ PREDICATE ) ; } else { return may CaMeL Be CaMeL String CaMeL Helper ( n ) ; } }
if ( MAKE _ LOCAL _ NAMES _ UNIQUE ) { <CTX> public void process ( Node externs , Node root ) { Node CaMeL Traversal . traverse ( compiler , root , this ) ; if ( MAKE _ LOCAL _ NAMES _ UNIQUE ) { Make CaMeL Declared CaMeL Names CaMeL Unique renamer = new Make CaMeL Declared CaMeL Names CaMeL Unique ( ) ; Node CaMeL Traversal t = new Node CaMeL Traversal ( compiler , renamer ) ; t . traverse CaMeL Roots ( externs , root ) ; } remove CaMeL Duplicate CaMeL Declarations ( root ) ; new Propogate CaMeL Constant CaMeL Annotations ( compiler , assert CaMeL On CaMeL Change ) . process ( externs , root ) ; }
if ( result != null ) { <CTX> JS CaMeL Type meet ( JS CaMeL Type that ) { Union CaMeL Type CaMeL Builder builder = new Union CaMeL Type CaMeL Builder ( registry ) ; for ( JS CaMeL Type alternate : alternates ) { if ( alternate . is CaMeL Subtype ( that ) ) { builder . add CaMeL Alternate ( alternate ) ; } } if ( that instanceof Union CaMeL Type ) { for ( JS CaMeL Type other CaMeL Alternate : ( ( Union CaMeL Type ) that ) . alternates ) { if ( other CaMeL Alternate . is CaMeL Subtype ( this ) ) { builder . add CaMeL Alternate ( other CaMeL Alternate ) ; } } } else if ( that . is CaMeL Subtype ( this ) ) { builder . add CaMeL Alternate ( that ) ; } JS CaMeL Type result = builder . build ( ) ; if ( result != null ) { return result ; } else if ( this . is CaMeL Object ( ) && that . is CaMeL Object ( ) ) { return get CaMeL Native CaMeL Type ( JS CaMeL Type CaMeL Native . NO _ OBJECT _ TYPE ) ; } else { return get CaMeL Native CaMeL Type ( JS CaMeL Type CaMeL Native . NO _ TYPE ) ; } }
if ( provided != null ) { <CTX> private void process CaMeL Require CaMeL Call ( Node CaMeL Traversal t , Node n , Node parent ) { Node left = n . get CaMeL First CaMeL Child ( ) ; Node arg = left . get CaMeL Next ( ) ; if ( verify CaMeL Last CaMeL Argument CaMeL Is CaMeL String ( t , left , arg ) ) { String ns = arg . get CaMeL String ( ) ; Provided CaMeL Name provided = provided CaMeL Names . get ( ns ) ; if ( provided == null || ! provided . is CaMeL Explicitly CaMeL Provided ( ) ) { unrecognized CaMeL Requires . add ( new Unrecognized CaMeL Require ( n , ns , t . get CaMeL Source CaMeL Name ( ) ) ) ; } else { JS CaMeL Module provided CaMeL Module = provided . explicit CaMeL Module ; / / This must be non - null , because there was an explicit provide . Preconditions . check CaMeL Not CaMeL Null ( provided CaMeL Module ) ; JS CaMeL Module module = t . get CaMeL Module ( ) ; if ( module CaMeL Graph != null && module != provided CaMeL Module && ! module CaMeL Graph . depends CaMeL On ( module , provided CaMeL Module ) ) { compiler . report ( t . make CaMeL Error ( n , XMODULE _ REQUIRE _ ERROR , ns , provided CaMeL Module . get CaMeL Name ( ) , module . get CaMeL Name ( ) ) ) ; } } maybe CaMeL Add CaMeL To CaMeL Symbol CaMeL Table ( left ) ; maybe CaMeL Add CaMeL String CaMeL Node CaMeL To CaMeL Symbol CaMeL Table ( arg ) ; / / Requires should be removed before further processing . / / Some clients run closure pass multiple times , first with / / the checks for broken requires turned off . In these cases , we / / allow broken requires to be preserved by the first run to / / let them be caught in the subsequent run . if ( provided != null ) { parent . detach CaMeL From CaMeL Parent ( ) ; compiler . report CaMeL Code CaMeL Change ( ) ; } } }
} else { <CTX> private void record CaMeL Assignment ( Node CaMeL Traversal t , Node n , Node record CaMeL Node ) { Node name CaMeL Node = n . get CaMeL First CaMeL Child ( ) ; Node parent = n . get CaMeL Parent ( ) ; Name CaMeL Information ns = create CaMeL Name CaMeL Information ( t , name CaMeL Node ) ; if ( ns != null ) { if ( parent . is CaMeL For ( ) && ! Node CaMeL Util . is CaMeL For CaMeL In ( parent ) ) { / / Patch for assignments that appear in the init , / / condition or iteration part of a FOR loop . Without / / this change , all $NUMBER$ of those parts try to claim the for / / loop as their dependency scope . The last assignment in / / those three fields wins , which can result in incorrect / / reference edges between referenced and assigned variables . / / / / TODO ( user ) revisit the dependency scope calculation / / logic . if ( parent . get CaMeL First CaMeL Child ( ) . get CaMeL Next ( ) != n ) { record CaMeL Dep CaMeL Scope ( record CaMeL Node , ns ) ; } else { record CaMeL Dep CaMeL Scope ( name CaMeL Node , ns ) ; } } else { / / The rhs of the assignment is the caller , so it $STRING$ t associate it w / the lhs . / / FYI : this fixes only the specific case where the assignment is the / / caller expression , but it could be nested deeper in the caller and / / we would still get a bug . / / See test CaMeL Assign CaMeL With CaMeL Call $NUMBER$ for an example of this . record CaMeL Dep CaMeL Scope ( record CaMeL Node , ns ) ; } } }
Context rhs CaMeL Context = Context . OTHER ; <CTX> void add ( Node n , Context context ) { if ( ! cc . continue CaMeL Processing ( ) ) { return ; } int type = n . get CaMeL Type ( ) ; String opstr = Node CaMeL Util . op CaMeL To CaMeL Str ( type ) ; int child CaMeL Count = n . get CaMeL Child CaMeL Count ( ) ; Node first = n . get CaMeL First CaMeL Child ( ) ; Node last = n . get CaMeL Last CaMeL Child ( ) ; / / Handle all binary operators if ( opstr != null && first != last ) { Preconditions . check CaMeL State ( child CaMeL Count == $NUMBER$ , $STRING$ % s \ $STRING$ , opstr , child CaMeL Count ) ; int p = Node CaMeL Util . precedence ( type ) ; / / For right - hand - side of operations , only pass context if it $STRING$ t a catch block Node catchblock = first . get CaMeL Next ( ) . get CaMeL First CaMeL Child ( ) ; if ( catchblock != null ) { add ( catchblock ) ; } if ( child CaMeL Count == $NUMBER$ ) { add ( $STRING$ ) ; add ( last , Context . PRESERVE _ BLOCK ) ; } break ; } case Token . CATCH : Preconditions . check CaMeL State ( child CaMeL Count == $NUMBER$ ) ; add ( $STRING$ ) ; add ( first ) ; add ( $STRING$ ) ; add ( last , Context . PRESERVE _ BLOCK ) ; break ; case Token . THROW : Preconditions . check CaMeL State ( child CaMeL Count == 1 ) ; add ( $STRING$ ) ; add ( first ) ; / / Must have a $STRING$ after a throw statement , otherwise safari can $STRING$ s important to our sanity checker that the code / / we print produces the same AST as the code we parse back . / / NEG is a weird case because Rhino parses $STRING$ as $STRING$ . if ( n . get CaMeL First CaMeL Child ( ) . is CaMeL Number ( ) ) { cc . add CaMeL Number ( - n . get CaMeL First CaMeL Child ( ) . get CaMeL Double ( ) ) ; } else { cc . add CaMeL Op ( Node CaMeL Util . op CaMeL To CaMeL Str CaMeL No CaMeL Fail ( type ) , false ) ; add CaMeL Expr ( first , Node CaMeL Util . precedence ( type ) , Context . OTHER ) ; } break ; } case Token . HOOK : { Preconditions . check CaMeL State ( child CaMeL Count == $NUMBER$ ) ; int p = Node CaMeL Util . precedence ( type ) ; Context rhs CaMeL Context = Context . OTHER ; add CaMeL Expr ( first , p + 1 , context ) ; cc . add CaMeL Op ( $STRING$ , true ) ; add CaMeL Expr ( first . get CaMeL Next ( ) , 1 , rhs CaMeL Context ) ; cc . add CaMeL Op ( $STRING$ , true ) ; add CaMeL Expr ( last , 1 , rhs CaMeL Context ) ; break ; } case Token . REGEXP : if ( ! first . is CaMeL String ( ) || ! last . is CaMeL String ( ) ) { throw new Error ( $STRING$ ) ; } String regexp = regexp CaMeL Escape ( first . get CaMeL String ( ) , output CaMeL Charset CaMeL Encoder ) ; / / I only use one . add because whitespace matters if ( child CaMeL Count == $NUMBER$ ) { add ( regexp + last . get CaMeL String ( ) ) ; } else { Preconditions . check CaMeL State ( child CaMeL Count == 1 ) ; add ( regexp ) ; } break ; case Token . FUNCTION : if ( n . get CaMeL Class ( ) != Node . class ) { throw new Error ( $STRING$ ) ; } Preconditions . check CaMeL State ( child CaMeL Count == $NUMBER$ ) ; boolean func CaMeL Needs CaMeL Parens = ( context == Context . START _ OF _ EXPR ) ; if ( func CaMeL Needs CaMeL Parens ) { add ( $STRING$ ) ; } add ( $STRING$ ) ; add ( first ) ; add ( first . get CaMeL Next ( ) ) ; add ( last , Context . PRESERVE _ BLOCK ) ; cc . end CaMeL Function ( context == Context . STATEMENT ) ; if ( func CaMeL Needs CaMeL Parens ) { add ( $STRING$ ) ; } break ; case Token . GETTER _ DEF : case Token . SETTER _ DEF : Preconditions . check CaMeL State ( n . get CaMeL Parent ( ) . is CaMeL Object CaMeL Lit ( ) ) ; Preconditions . check CaMeL State ( child CaMeL Count == 1 ) ; Preconditions . check CaMeL State ( first . is CaMeL Function ( ) ) ; / / Get methods are unnamed Preconditions . check CaMeL State ( first . get CaMeL First CaMeL Child ( ) . get CaMeL String ( ) . is CaMeL Empty ( ) ) ; if ( type == Token . GETTER _ DEF ) { / / Get methods have no parameters . Preconditions . check CaMeL State ( ! first . get CaMeL Child CaMeL At CaMeL Index ( 1 ) . has CaMeL Children ( ) ) ; add ( $STRING$ ) ; } else { / / Set methods have one parameter . Preconditions . check CaMeL State ( first . get CaMeL Child CaMeL At CaMeL Index ( 1 ) . has CaMeL One CaMeL Child ( ) ) ; add ( $STRING$ ) ; } / / The name is on the GET or SET node . String name = n . get CaMeL String ( ) ; Node fn = first ; Node parameters = fn . get CaMeL Child CaMeL At CaMeL Index ( 1 ) ; Node body = fn . get CaMeL Last CaMeL Child ( ) ; / / Add the property name . if ( ! n . is CaMeL Quoted CaMeL String ( ) && Token CaMeL Stream . is CaMeL JS CaMeL Identifier ( name ) && / / do not encode literally any non - literal characters that were / / Unicode escaped . Node CaMeL Util . is CaMeL Latin ( name ) ) { add ( name ) ; } else { / / Determine if the string is a simple number . double d = get CaMeL Simple CaMeL Number ( name ) ; if ( ! Double . is CaMeL Na CaMeL N ( d ) ) { cc . add CaMeL Number ( d ) ; } else { add CaMeL Js CaMeL String ( n ) ; } } add ( parameters ) ; add ( body , Context . PRESERVE _ BLOCK ) ; break ; case Token . SCRIPT : case Token . BLOCK : { if ( n . get CaMeL Class ( ) != Node . class ) { throw new Error ( $STRING$ ) ; } boolean preserve CaMeL Block = context == Context . PRESERVE _ BLOCK ; if ( preserve CaMeL Block ) { cc . begin CaMeL Block ( ) ; } boolean prefer CaMeL Line CaMeL Breaks = type == Token . SCRIPT || ( type == Token . BLOCK && ! preserve CaMeL Block && n . get CaMeL Parent ( ) != null && n . get CaMeL Parent ( ) . is CaMeL Script ( ) ) ; for ( Node c = first ; c != null ; c = c . get CaMeL Next ( ) ) { add ( c , Context . STATEMENT ) ; / / VAR doesn $STRING$ ; $STRING$ t traverse into functions ) . if ( Node CaMeL Util . contains CaMeL Type ( first , Token . CALL , Node CaMeL Util . MATCH _ NOT _ FUNCTION ) ) { precedence = Node CaMeL Util . precedence ( first . get CaMeL Type ( ) ) + 1 ; } add CaMeL Expr ( first , precedence , Context . OTHER ) ; / / $STRING$ is optional when no arguments are present Node next = first . get CaMeL Next ( ) ; if ( next != null ) { add ( $STRING$ ) ; add CaMeL List ( next ) ; add ( $STRING$ ) ; } break ; case Token . STRING _ KEY : Preconditions . check CaMeL State ( child CaMeL Count == 1 , $STRING$ ) ; add CaMeL Js CaMeL String ( n ) ; break ; case Token . STRING : Preconditions . check CaMeL State ( child CaMeL Count == 0 , $STRING$ ) ; add CaMeL Js CaMeL String ( n ) ; break ; case Token . DELPROP : Preconditions . check CaMeL State ( child CaMeL Count == 1 ) ; add ( $STRING$ ) ; add ( first ) ; break ; case Token . OBJECTLIT : { boolean needs CaMeL Parens = ( context == Context . START _ OF _ EXPR ) ; if ( needs CaMeL Parens ) { add ( $STRING$ ) ; } add ( $STRING$ ) ; for ( Node c = first ; c != null ; c = c . get CaMeL Next ( ) ) { if ( c != first ) { cc . list CaMeL Separator ( ) ; } if ( c . is CaMeL Getter CaMeL Def ( ) || c . is CaMeL Setter CaMeL Def ( ) ) { add ( c ) ; } else { Preconditions . check CaMeL State ( c . is CaMeL String CaMeL Key ( ) ) ; String key = c . get CaMeL String ( ) ; / / Object literal property names don t have to be quoted if they / / are not Java CaMeL Script keywords if ( ! c . is CaMeL Quoted CaMeL String ( ) && ! ( language CaMeL Mode == Language CaMeL Mode . ECMASCRIPT $NUMBER$ && Token CaMeL Stream . is CaMeL Keyword ( key ) ) && Token CaMeL Stream . is CaMeL JS CaMeL Identifier ( key ) / / do not encode literally any non - literal characters that / / were Unicode escaped . && Node CaMeL Util . is CaMeL Latin ( key ) ) { add ( key ) ; } else { / / Determine if the string is a simple number . double d = get CaMeL Simple CaMeL Number ( key ) ; if ( ! Double . is CaMeL Na CaMeL N ( d ) ) { cc . add CaMeL Number ( d ) ; } else { add CaMeL Expr ( c , 1 , Context . OTHER ) ; } } add ( $STRING$ ) ; add CaMeL Expr ( c . get CaMeL First CaMeL Child ( ) , 1 , Context . OTHER ) ; } } add ( $STRING$ ) ; if ( needs CaMeL Parens ) { add ( $STRING$ ) ; } break ; } case Token . SWITCH : add ( $STRING$ ) ; add ( first ) ; add ( $STRING$ ) ; cc . begin CaMeL Block ( ) ; add CaMeL All CaMeL Siblings ( first . get CaMeL Next ( ) ) ; cc . end CaMeL Block ( context == Context . STATEMENT ) ; break ; case Token . CASE : Preconditions . check CaMeL State ( child CaMeL Count == $NUMBER$ ) ; add ( $STRING$ ) ; add ( first ) ; add CaMeL Case CaMeL Body ( last ) ; break ; case Token . DEFAULT _ CASE : Preconditions . check CaMeL State ( child CaMeL Count == 1 ) ; add ( $STRING$ ) ; add CaMeL Case CaMeL Body ( first ) ; break ; case Token . LABEL : Preconditions . check CaMeL State ( child CaMeL Count == $NUMBER$ ) ; if ( ! first . is CaMeL Label CaMeL Name ( ) ) { throw new Error ( $STRING$ ) ; } add ( first ) ; add ( $STRING$ ) ; add CaMeL Non CaMeL Empty CaMeL Statement ( last , get CaMeL Context CaMeL For CaMeL Non CaMeL Empty CaMeL Expression ( context ) , true ) ; break ; case Token . CAST : add ( $STRING$ ) ; add ( first ) ; add ( $STRING$ ) ; break ; default : throw new Error ( $STRING$ + type + $STRING$ + n . to CaMeL String CaMeL Tree ( ) ) ; } cc . end CaMeL Source CaMeL Mapping ( n ) ; }
if ( fn CaMeL Type != null ) { <CTX> private void visit CaMeL New ( Node CaMeL Traversal t , Node n ) { Node constructor = n . get CaMeL First CaMeL Child ( ) ; JS CaMeL Type type = get CaMeL JS CaMeL Type ( constructor ) . restrict CaMeL By CaMeL Not CaMeL Null CaMeL Or CaMeL Undefined ( ) ; if ( type . is CaMeL Constructor ( ) || type . is CaMeL Empty CaMeL Type ( ) || type . is CaMeL Unknown CaMeL Type ( ) ) { Function CaMeL Type fn CaMeL Type = type . to CaMeL Maybe CaMeL Function CaMeL Type ( ) ; if ( fn CaMeL Type != null ) { visit CaMeL Parameter CaMeL List ( t , n , fn CaMeL Type ) ; ensure CaMeL Typed ( t , n , fn CaMeL Type . get CaMeL Instance CaMeL Type ( ) ) ; } else { ensure CaMeL Typed ( t , n ) ; } } else { report ( t , n , NOT _ A _ CONSTRUCTOR ) ; ensure CaMeL Typed ( t , n ) ; } }
traverse ( c ) ; <CTX> private void traverse ( Node node ) { / / The goal here is to avoid retraversing / / the entire AST to catch newly created opportunities . / / So we track whether a $STRING$ has changed , / / and revisit immediately . if ( ! should CaMeL Visit ( node ) ) { return ; } int visits = 0 ; do { Node c = node . get CaMeL First CaMeL Child ( ) ; while ( c != null ) { traverse ( c ) ; Node next = c . get CaMeL Next ( ) ; c = next ; } visit ( node ) ; visits ++ ; Preconditions . check CaMeL State ( visits < $NUMBER$ , $STRING$ ) ; } while ( should CaMeL Retraverse ( node ) ) ; exit CaMeL Node ( node ) ; }
if ( name . global CaMeL Sets == 1 && name . local CaMeL Sets == 0 && & <CTX> private void inline CaMeL Aliases ( Global CaMeL Namespace namespace ) { / / Invariant : All the names in the worklist meet condition ( a ) . Deque < Name > work CaMeL List = new Array CaMeL Deque < Name > ( namespace . get CaMeL Name CaMeL Forest ( ) ) ; while ( ! work CaMeL List . is CaMeL Empty ( ) ) { Name name = work CaMeL List . pop ( ) ; / / Don $STRING$ s children meet condition ( a ) , so they can be / / added to the worklist . work CaMeL List . add CaMeL All ( name . props ) ; } } }
cfa . create CaMeL Edge ( from CaMeL Node , Branch . UNCOND , finally CaMeL Node ) ; <CTX> private static Node compute CaMeL Follow CaMeL Node ( Node from CaMeL Node , Node node , Control CaMeL Flow CaMeL Analysis cfa ) { / * * This is the case where : * * 1 . Parent is null implies that we are transferring control to the end of * the script . * * $NUMBER$ . Parent is a function implies that we are transferring control back to * the caller of the function . * * $NUMBER$ . If the node is a return statement , we should also transfer control * back to the caller of the function . * * $NUMBER$ . If the node is root then we have reached the end of what we have been * asked to traverse . * * In all cases we should transfer control to a $STRING$ node . * This will make life easier for DF CaMeL As . * / Node parent = node . get CaMeL Parent ( ) ; if ( parent == null || parent . is CaMeL Function ( ) || ( cfa != null && node == cfa . root ) ) { return null ; } / / If we are just before a IF / WHILE / DO / FOR : switch ( parent . get CaMeL Type ( ) ) { / / The follow ( ) of any of the path from IF would be what follows IF . case Token . IF : return compute CaMeL Follow CaMeL Node ( from CaMeL Node , parent , cfa ) ; case Token . CASE : case Token . DEFAULT _ CASE : / / After the body of a CASE , the control goes to the body of the next / / case , without having to go to the case condition . if ( parent . get CaMeL Next ( ) != null ) { if ( parent . get CaMeL Next ( ) . is CaMeL Case ( ) ) { return parent . get CaMeL Next ( ) . get CaMeL First CaMeL Child ( ) . get CaMeL Next ( ) ; } else if ( parent . get CaMeL Next ( ) . is CaMeL Default CaMeL Case ( ) ) { return parent . get CaMeL Next ( ) . get CaMeL First CaMeL Child ( ) ; } else { Preconditions . check CaMeL State ( false , $STRING$ ) ; } } else { return compute CaMeL Follow CaMeL Node ( from CaMeL Node , parent , cfa ) ; } break ; case Token . FOR : if ( Node CaMeL Util . is CaMeL For CaMeL In ( parent ) ) { return parent ; } else { return parent . get CaMeL First CaMeL Child ( ) . get CaMeL Next ( ) . get CaMeL Next ( ) ; } case Token . WHILE : case Token . DO : return parent ; case Token . TRY : / / If we are coming out of the TRY block . . . if ( parent . get CaMeL First CaMeL Child ( ) == node ) { if ( Node CaMeL Util . has CaMeL Finally ( parent ) ) { / / and have FINALLY block . return compute CaMeL Fall CaMeL Through ( parent . get CaMeL Last CaMeL Child ( ) ) ; } else { / / and have no FINALLY . return compute CaMeL Follow CaMeL Node ( from CaMeL Node , parent , cfa ) ; } / / CATCH block . } else if ( Node CaMeL Util . get CaMeL Catch CaMeL Block ( parent ) == node ) { if ( Node CaMeL Util . has CaMeL Finally ( parent ) ) { / / and have FINALLY block . return compute CaMeL Fall CaMeL Through ( node . get CaMeL Next ( ) ) ; } else { return compute CaMeL Follow CaMeL Node ( from CaMeL Node , parent , cfa ) ; } / / If we are coming out of the FINALLY block . . . } else if ( parent . get CaMeL Last CaMeL Child ( ) == node ) { if ( cfa != null ) { for ( Node finally CaMeL Node : cfa . finally CaMeL Map . get ( parent ) ) { cfa . create CaMeL Edge ( from CaMeL Node , Branch . UNCOND , finally CaMeL Node ) ; } } return compute CaMeL Follow CaMeL Node ( from CaMeL Node , parent , cfa ) ; } } / / Now that we are done with the special cases follow should be its / / immediate sibling , unless its sibling is a function Node next CaMeL Sibling = node . get CaMeL Next ( ) ; / / Skip function declarations because control doesn t get pass into it . while ( next CaMeL Sibling != null && next CaMeL Sibling . is CaMeL Function ( ) ) { next CaMeL Sibling = next CaMeL Sibling . get CaMeL Next ( ) ; } if ( next CaMeL Sibling != null ) { return compute CaMeL Fall CaMeL Through ( next CaMeL Sibling ) ; } else { / / If there are no more siblings , control is transferred up the AST . return compute CaMeL Follow CaMeL Node ( from CaMeL Node , parent , cfa ) ; } }
if ( t . get CaMeL Scope CaMeL Depth ( ) <= $NUMBER$ ) { <CTX> @ Override public void visit ( Node CaMeL Traversal t , Node n , Node parent ) { if ( t . in CaMeL Global CaMeL Scope ( ) ) { return ; } if ( n . is CaMeL Return ( ) && n . get CaMeL First CaMeL Child ( ) != null ) { data . get ( t . get CaMeL Scope CaMeL Root ( ) ) . record CaMeL Non CaMeL Empty CaMeL Return ( ) ; } if ( t . get CaMeL Scope CaMeL Depth ( ) <= $NUMBER$ ) { / / The first - order function analyzer looks at two types of variables : / / / / 1 ) Local variables that are assigned in inner scopes ( $STRING$ ) / / / / $NUMBER$ ) Local variables that are assigned more than once . / / / / We treat all global variables as escaped by default , so there s / / no reason to do this extra computation for them . return ; } if ( n . is CaMeL Name ( ) && Node CaMeL Util . is CaMeL L CaMeL Value ( n ) && / / Be careful of bleeding functions , which create variables / / in the inner scope , not the scope where the name appears . ! Node CaMeL Util . is CaMeL Bleeding CaMeL Function CaMeL Name ( n ) ) { String name = n . get CaMeL String ( ) ; Scope scope = t . get CaMeL Scope ( ) ; Var var = scope . get CaMeL Var ( name ) ; if ( var != null ) { Scope owner CaMeL Scope = var . get CaMeL Scope ( ) ; if ( owner CaMeL Scope . is CaMeL Local ( ) ) { data . get ( owner CaMeL Scope . get CaMeL Root CaMeL Node ( ) ) . record CaMeL Assigned CaMeL Name ( name ) ; } if ( scope != owner CaMeL Scope && owner CaMeL Scope . is CaMeL Local ( ) ) { data . get ( owner CaMeL Scope . get CaMeL Root CaMeL Node ( ) ) . record CaMeL Escaped CaMeL Var CaMeL Name ( name ) ; } } } else if ( n . is CaMeL Get CaMeL Prop ( ) && n . is CaMeL Unscoped CaMeL Qualified CaMeL Name ( ) && Node CaMeL Util . is CaMeL L CaMeL Value ( n ) ) { String name = Node CaMeL Util . get CaMeL Root CaMeL Of CaMeL Qualified CaMeL Name ( n ) . get CaMeL String ( ) ; Scope scope = t . get CaMeL Scope ( ) ; Var var = scope . get CaMeL Var ( name ) ; if ( var != null ) { Scope owner CaMeL Scope = var . get CaMeL Scope ( ) ; if ( scope != owner CaMeL Scope && owner CaMeL Scope . is CaMeL Local ( ) ) { data . get ( owner CaMeL Scope . get CaMeL Root CaMeL Node ( ) ) . record CaMeL Escaped CaMeL Qualified CaMeL Name ( n . get CaMeL Qualified CaMeL Name ( ) ) ; } } } }
if ( options . dependency CaMeL Options . needs CaMeL Management ( ) && options . closure CaMeL Pass ) { <CTX> Node parse CaMeL Inputs ( ) { boolean dev CaMeL Mode = options . dev CaMeL Mode != Dev CaMeL Mode . OFF ; / / If old roots exist ( we are parsing a second time ) , detach each of the / / individual file parse trees . if ( externs CaMeL Root != null ) { externs CaMeL Root . detach CaMeL Children ( ) ; } if ( js CaMeL Root != null ) { js CaMeL Root . detach CaMeL Children ( ) ; } / / Parse main JS sources . js CaMeL Root = IR . block ( ) ; js CaMeL Root . set CaMeL Is CaMeL Synthetic CaMeL Block ( true ) ; externs CaMeL Root = IR . block ( ) ; externs CaMeL Root . set CaMeL Is CaMeL Synthetic CaMeL Block ( true ) ; extern CaMeL And CaMeL Js CaMeL Root = IR . block ( externs CaMeL Root , js CaMeL Root ) ; extern CaMeL And CaMeL Js CaMeL Root . set CaMeL Is CaMeL Synthetic CaMeL Block ( true ) ; if ( options . tracer . is CaMeL On ( ) ) { tracker = new Performance CaMeL Tracker ( js CaMeL Root , options . tracer ) ; add CaMeL Change CaMeL Handler ( tracker . get CaMeL Code CaMeL Change CaMeL Handler ( ) ) ; } Tracer tracer = new CaMeL Tracer ( $STRING$ ) ; try { / / Parse externs sources . for ( Compiler CaMeL Input input : externs ) { Node n = input . get CaMeL Ast CaMeL Root ( this ) ; if ( has CaMeL Errors ( ) ) { return null ; } externs CaMeL Root . add CaMeL Child CaMeL To CaMeL Back ( n ) ; } / / Modules inferred in Process CaMeL Common CaMeL JS pass . if ( options . transform CaMeL AMD CaMeL To CaMeL CJS CaMeL Modules || options . process CaMeL Common CaMeL JS CaMeL Modules ) { process CaMeL AMD CaMeL And CaMeL Common CaMeL JS CaMeL Modules ( ) ; } hoist CaMeL Externs ( externs CaMeL Root ) ; / / Check if the sources need to be re - ordered . boolean stale CaMeL Inputs = false ; if ( options . dependency CaMeL Options . needs CaMeL Management ( ) && options . closure CaMeL Pass ) { for ( Compiler CaMeL Input input : inputs ) { / / Forward - declare all the provided types , so that they / / are not flagged even if they are dropped from the process . for ( String provide : input . get CaMeL Provides ( ) ) { get CaMeL Type CaMeL Registry ( ) . forward CaMeL Declare CaMeL Type ( provide ) ; } } try { inputs = ( module CaMeL Graph == null ? new JS CaMeL Module CaMeL Graph ( modules ) : module CaMeL Graph ) . manage CaMeL Dependencies ( options . dependency CaMeL Options , inputs ) ; stale CaMeL Inputs = true ; } catch ( Circular CaMeL Dependency CaMeL Exception e ) { report ( JS CaMeL Error . make ( JS CaMeL Module . CIRCULAR _ DEPENDENCY _ ERROR , e . get CaMeL Message ( ) ) ) ; / / If in IDE mode , we ignore the error and keep going . if ( has CaMeL Errors ( ) ) { return null ; } } catch ( Missing CaMeL Provide CaMeL Exception e ) { report ( JS CaMeL Error . make ( MISSING _ ENTRY _ ERROR , e . get CaMeL Message ( ) ) ) ; / / If in IDE mode , we ignore the error and keep going . if ( has CaMeL Errors ( ) ) { return null ; } } } hoist CaMeL No CaMeL Compile CaMeL Files ( ) ; if ( stale CaMeL Inputs ) { repartition CaMeL Inputs ( ) ; } / / Build the AST . for ( Compiler CaMeL Input input : inputs ) { Node n = input . get CaMeL Ast CaMeL Root ( this ) ; if ( n == null ) { continue ; } if ( dev CaMeL Mode ) { run CaMeL Sanity CaMeL Check ( ) ; if ( has CaMeL Errors ( ) ) { return null ; } } if ( options . source CaMeL Map CaMeL Output CaMeL Path != null || options . name CaMeL Reference CaMeL Report CaMeL Path != null ) { / / Annotate the nodes in the tree with information from the / / input file . This information is used to construct the Source CaMeL Map . Source CaMeL Information CaMeL Annotator sia = new Source CaMeL Information CaMeL Annotator ( input . get CaMeL Name ( ) , options . dev CaMeL Mode != Dev CaMeL Mode . OFF ) ; Node CaMeL Traversal . traverse ( this , n , sia ) ; } js CaMeL Root . add CaMeL Child CaMeL To CaMeL Back ( n ) ; } if ( has CaMeL Errors ( ) ) { return null ; } return extern CaMeL And CaMeL Js CaMeL Root ; } finally { stop CaMeL Tracer ( tracer , $STRING$ ) ; } }
if ( x < 0 && prev == $STRING$ ) { <CTX> void add CaMeL Number ( double x ) { / / This is not pretty printing . This is to prevent misparsing of x -- $NUMBER$ as / / x -- $NUMBER$ ( which is a syntax error ) . char prev = get CaMeL Last CaMeL Char ( ) ; boolean negative CaMeL Zero = is CaMeL Negative CaMeL Zero ( x ) ; if ( x < 0 && prev == $STRING$ ) { add ( $STRING$ ) ; } if ( ( long ) x == x && ! negative CaMeL Zero ) { long value = ( long ) x ; long mantissa = value ; int exp = 0 ; if ( Math . abs ( x ) >= $NUMBER$ ) { while ( mantissa / $NUMBER$ * Math . pow ( $NUMBER$ , exp + 1 ) == value ) { mantissa /= $NUMBER$ ; exp ++ ; } } if ( exp > $NUMBER$ ) { add ( Long . to CaMeL String ( mantissa ) + $STRING$ + Integer . to CaMeL String ( exp ) ) ; } else { add ( Long . to CaMeL String ( value ) ) ; } } else { add ( String . value CaMeL Of ( x ) ) ; } }
return len > 0 ; <CTX> static boolean is CaMeL Simple CaMeL Number ( String s ) { int len = s . length ( ) ; for ( int index = 0 ; index < len ; index ++ ) { char c = s . char CaMeL At ( index ) ; if ( c < $STRING$ || c > $STRING$ ) { return false ; } } return len > 0 ; }
if ( target != null ) { <CTX> private static String extract CaMeL Class CaMeL Name CaMeL If CaMeL Goog ( Node node , Node parent , String function CaMeL Name ) { String class CaMeL Name = null ; if ( Node CaMeL Util . is CaMeL Expr CaMeL Call ( parent ) ) { Node callee = node . get CaMeL First CaMeL Child ( ) ; if ( callee != null && callee . get CaMeL Type ( ) == Token . GETPROP ) { String qualified CaMeL Name = callee . get CaMeL Qualified CaMeL Name ( ) ; if ( function CaMeL Name . equals ( qualified CaMeL Name ) ) { Node target = callee . get CaMeL Next ( ) ; if ( target != null ) { class CaMeL Name = target . get CaMeL String ( ) ; } } } } return class CaMeL Name ; }
&& 0 <= charno && charno < source CaMeL Excerpt . length ( ) ) { <CTX> private String format ( JS CaMeL Error error , boolean warning ) { / / extract source excerpt Source CaMeL Excerpt CaMeL Provider source = get CaMeL Source ( ) ; String source CaMeL Excerpt = source == null ? null : excerpt . get ( source , error . source CaMeL Name , error . line CaMeL Number , excerpt CaMeL Formatter ) ; / / formatting the message String CaMeL Builder b = new String CaMeL Builder ( ) ; if ( error . source CaMeL Name != null ) { b . append ( error . source CaMeL Name ) ; if ( error . line CaMeL Number > 0 ) { b . append ( $STRING$ ) ; b . append ( error . line CaMeL Number ) ; } b . append ( $STRING$ ) ; } b . append ( get CaMeL Level CaMeL Name ( warning ? Check CaMeL Level . WARNING : Check CaMeL Level . ERROR ) ) ; b . append ( $STRING$ ) ; b . append ( error . description ) ; b . append ( $STRING$ ) ; if ( source CaMeL Excerpt != null ) { b . append ( source CaMeL Excerpt ) ; b . append ( $STRING$ ) ; int charno = error . get CaMeL Charno ( ) ; / / padding equal to the excerpt and arrow at the end / / charno == source CaMeL Expert . length ( ) means something is missing / / at the end of the line if ( excerpt . equals ( LINE ) && 0 <= charno && charno < source CaMeL Excerpt . length ( ) ) { for ( int i = 0 ; i < charno ; i ++ ) { char c = source CaMeL Excerpt . char CaMeL At ( i ) ; if ( Character . is CaMeL Whitespace ( c ) ) { b . append ( c ) ; } else { b . append ( $STRING$ ) ; } } b . append ( $STRING$ ) ; } } return b . to CaMeL String ( ) ; }
case $STRING$ : sb . append ( $STRING$ ) ; break ; <CTX> static String str CaMeL Escape ( String s , char quote , String doublequote CaMeL Escape , String singlequote CaMeL Escape , String backslash CaMeL Escape , Charset CaMeL Encoder output CaMeL Charset CaMeL Encoder ) { String CaMeL Builder sb = new String CaMeL Builder ( s . length ( ) + $NUMBER$ ) ; sb . append ( quote ) ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { char c = s . char CaMeL At ( i ) ; switch ( c ) { case $STRING$ : sb . append ( $STRING$ ) ; break ; case $STRING$ : sb . append ( $STRING$ ) ; break ; case $STRING$ : sb . append ( $STRING$ ) ; break ; case $STRING$ : sb . append ( $STRING$ ) ; break ; case $STRING$ : sb . append ( backslash CaMeL Escape ) ; break ; case $STRING$ re given an output CaMeL Charset CaMeL Encoder , then check if the / / character can be represented in this character set . if ( output CaMeL Charset CaMeL Encoder != null ) { if ( output CaMeL Charset CaMeL Encoder . can CaMeL Encode ( c ) ) { sb . append ( c ) ; } else { / / Unicode - escape the character . append CaMeL Hex CaMeL Java CaMeL Script CaMeL Representation ( sb , c ) ; } } else { / / No charset CaMeL Encoder provided - pass straight latin characters / / through , and escape the rest . Doing the explicit character / / check is measurably faster than using the Charset CaMeL Encoder . if ( c > 0 x 1 f && c < 0 x $NUMBER$ f ) { sb . append ( c ) ; } else { / / Other characters can be misinterpreted by some js parsers , / / or perhaps mangled by proxies along the way , / / so we play it safe and unicode escape them . append CaMeL Hex CaMeL Java CaMeL Script CaMeL Representation ( sb , c ) ; } } } } sb . append ( quote ) ; return sb . to CaMeL String ( ) ; }
) { <CTX> private boolean is CaMeL Prototype CaMeL Property CaMeL Assign ( Node assign ) { Node n = assign . get CaMeL First CaMeL Child ( ) ; if ( n != null && Node CaMeL Util . is CaMeL Var CaMeL Or CaMeL Simple CaMeL Assign CaMeL Lhs ( n , assign ) && n . get CaMeL Type ( ) == Token . GETPROP ) { / / We want to exclude the assignment itself from the usage list boolean is CaMeL Chained CaMeL Property = n . get CaMeL First CaMeL Child ( ) . get CaMeL Type ( ) == Token . GETPROP ; if ( is CaMeL Chained CaMeL Property ) { Node child = n . get CaMeL First CaMeL Child ( ) . get CaMeL First CaMeL Child ( ) . get CaMeL Next ( ) ; if ( child . get CaMeL Type ( ) == Token . STRING && child . get CaMeL String ( ) . equals ( $STRING$ ) ) { return true ; } } } return false ; }
js CaMeL Doc CaMeL Parameter . get CaMeL JS CaMeL Type ( ) , true ) ; <CTX> private void declare CaMeL Arguments ( Node function CaMeL Node ) { Node ast CaMeL Parameters = function CaMeL Node . get CaMeL First CaMeL Child ( ) . get CaMeL Next ( ) ; Node body = ast CaMeL Parameters . get CaMeL Next ( ) ; Function CaMeL Type function CaMeL Type = ( Function CaMeL Type ) function CaMeL Node . get CaMeL JS CaMeL Type ( ) ; if ( function CaMeL Type != null ) { Node js CaMeL Doc CaMeL Parameters = function CaMeL Type . get CaMeL Parameters CaMeL Node ( ) ; if ( js CaMeL Doc CaMeL Parameters != null ) { Node js CaMeL Doc CaMeL Parameter = js CaMeL Doc CaMeL Parameters . get CaMeL First CaMeL Child ( ) ; for ( Node ast CaMeL Parameter : ast CaMeL Parameters . children ( ) ) { if ( js CaMeL Doc CaMeL Parameter != null ) { define CaMeL Slot ( ast CaMeL Parameter , function CaMeL Node , js CaMeL Doc CaMeL Parameter . get CaMeL JS CaMeL Type ( ) , true ) ; js CaMeL Doc CaMeL Parameter = js CaMeL Doc CaMeL Parameter . get CaMeL Next ( ) ; } else { define CaMeL Slot ( ast CaMeL Parameter , function CaMeL Node , null , true ) ; } } } } } / / end declare CaMeL Arguments } / / end Local CaMeL Scope CaMeL Builder / * * Find the best JS CaMeL Doc for the given node . * / static JS CaMeL Doc CaMeL Info get CaMeL Best CaMeL JS CaMeL Doc CaMeL Info ( Node n ) { JS CaMeL Doc CaMeL Info info = n . get CaMeL JS CaMeL Doc CaMeL Info ( ) ; if ( info == null ) { Node parent = n . get CaMeL Parent ( ) ; int parent CaMeL Type = parent . get CaMeL Type ( ) ; if ( parent CaMeL Type == Token . NAME ) { info = parent . get CaMeL JS CaMeL Doc CaMeL Info ( ) ; if ( info == null && parent . get CaMeL Parent ( ) . has CaMeL One CaMeL Child ( ) ) { info = parent . get CaMeL Parent ( ) . get CaMeL JS CaMeL Doc CaMeL Info ( ) ; } } else if ( parent CaMeL Type == Token . ASSIGN ) { info = parent . get CaMeL JS CaMeL Doc CaMeL Info ( ) ; } else if ( Node CaMeL Util . is CaMeL Object CaMeL Lit CaMeL Key ( parent , parent . get CaMeL Parent ( ) ) ) { info = parent . get CaMeL JS CaMeL Doc CaMeL Info ( ) ; } }
boolean is CaMeL Override = t . in CaMeL Global CaMeL Scope ( ) && & <CTX> private void check CaMeL Property CaMeL Visibility ( Node CaMeL Traversal t , Node getprop , Node parent ) { Object CaMeL Type object CaMeL Type = Object CaMeL Type . cast ( dereference ( getprop . get CaMeL First CaMeL Child ( ) . get CaMeL JS CaMeL Type ( ) ) ) ; String property CaMeL Name = getprop . get CaMeL Last CaMeL Child ( ) . get CaMeL String ( ) ; if ( object CaMeL Type != null ) { / / Is this a normal property access , or are we trying to override / / an existing property ? boolean is CaMeL Override = t . in CaMeL Global CaMeL Scope ( ) && parent . get CaMeL Type ( ) == Token . ASSIGN && parent . get CaMeL First CaMeL Child ( ) == getprop ; / / Find the lowest property defined on a class with visibility / / information . if ( is CaMeL Override ) { object CaMeL Type = object CaMeL Type . get CaMeL Implicit CaMeL Prototype ( ) ; } JS CaMeL Doc CaMeL Info doc CaMeL Info = null ; for ( ; object CaMeL Type != null ; object CaMeL Type = object CaMeL Type . get CaMeL Implicit CaMeL Prototype ( ) ) { doc CaMeL Info = object CaMeL Type . get CaMeL Own CaMeL Property CaMeL JS CaMeL Doc CaMeL Info ( property CaMeL Name ) ; if ( doc CaMeL Info != null && doc CaMeL Info . get CaMeL Visibility ( ) != Visibility . INHERITED ) { break ; } } if ( object CaMeL Type == null ) { / / We couldn $STRING$ s public . return ; } boolean same CaMeL Input = t . get CaMeL Input ( ) . get CaMeL Name ( ) . equals ( doc CaMeL Info . get CaMeL Source CaMeL Name ( ) ) ; Visibility visibility = doc CaMeL Info . get CaMeL Visibility ( ) ; JS CaMeL Type owner CaMeL Type = normalize CaMeL Class CaMeL Type ( object CaMeL Type ) ; if ( is CaMeL Override ) { / / Check an ASSIGN statement that s trying to override a property / / on a superclass . JS CaMeL Doc CaMeL Info overriding CaMeL Info = parent . get CaMeL JS CaMeL Doc CaMeL Info ( ) ; Visibility overriding CaMeL Visibility = overriding CaMeL Info == null ? Visibility . INHERITED : overriding CaMeL Info . get CaMeL Visibility ( ) ; / / Check that ( a ) the property * can * be overridden , and / / ( b ) that the visibility of the override is the same as the / / visibility of the original property . if ( visibility == Visibility . PRIVATE && ! same CaMeL Input ) { compiler . report ( t . make CaMeL Error ( getprop , PRIVATE _ OVERRIDE , object CaMeL Type . to CaMeL String ( ) ) ) ; } else if ( overriding CaMeL Visibility != Visibility . INHERITED && overriding CaMeL Visibility != visibility ) { compiler . report ( t . make CaMeL Error ( getprop , VISIBILITY _ MISMATCH , visibility . name ( ) , object CaMeL Type . to CaMeL String ( ) , overriding CaMeL Visibility . name ( ) ) ) ; } } else { if ( same CaMeL Input ) { / / private access is always allowed in the same file . return ; } else if ( visibility == Visibility . PRIVATE && ( current CaMeL Class == null || owner CaMeL Type . differs CaMeL From ( current CaMeL Class ) ) ) { if ( doc CaMeL Info . is CaMeL Constructor ( ) && is CaMeL Valid CaMeL Private CaMeL Constructor CaMeL Access ( parent ) ) { return ; } / / private access is not allowed outside the file from a different / / enclosing class . compiler . report ( t . make CaMeL Error ( getprop , BAD _ PRIVATE _ PROPERTY _ ACCESS , property CaMeL Name , validator . get CaMeL Readable CaMeL JS CaMeL Type CaMeL Name ( getprop . get CaMeL First CaMeL Child ( ) , true ) ) ) ; } else if ( visibility == Visibility . PROTECTED ) { / / There are $NUMBER$ types of legal accesses of a protected property : / / 1 ) Accesses in the same file / / $NUMBER$ ) Overriding the property in a subclass / / $NUMBER$ ) Accessing the property from inside a subclass / / The first two have already been checked for . if ( current CaMeL Class == null || ! current CaMeL Class . is CaMeL Subtype ( owner CaMeL Type ) ) { compiler . report ( t . make CaMeL Error ( getprop , BAD _ PROTECTED _ PROPERTY _ ACCESS , property CaMeL Name , validator . get CaMeL Readable CaMeL JS CaMeL Type CaMeL Name ( getprop . get CaMeL First CaMeL Child ( ) , true ) ) ) ; } } } } }
if ( c > 0 x 1 f && c <= 0 x $NUMBER$ f ) { <CTX> static String str CaMeL Escape ( String s , char quote , String doublequote CaMeL Escape , String singlequote CaMeL Escape , String backslash CaMeL Escape , Charset CaMeL Encoder output CaMeL Charset CaMeL Encoder ) { String CaMeL Builder sb = new String CaMeL Builder ( s . length ( ) + $NUMBER$ ) ; sb . append ( quote ) ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { char c = s . char CaMeL At ( i ) ; switch ( c ) { case $STRING$ : sb . append ( $STRING$ ) ; break ; case $STRING$ : sb . append ( $STRING$ ) ; break ; case $STRING$ : sb . append ( $STRING$ ) ; break ; case $STRING$ : sb . append ( $STRING$ ) ; break ; case $STRING$ : sb . append ( backslash CaMeL Escape ) ; break ; case $STRING$ re given an output CaMeL Charset CaMeL Encoder , then check if the / / character can be represented in this character set . if ( output CaMeL Charset CaMeL Encoder != null ) { if ( output CaMeL Charset CaMeL Encoder . can CaMeL Encode ( c ) ) { sb . append ( c ) ; } else { / / Unicode - escape the character . append CaMeL Hex CaMeL Java CaMeL Script CaMeL Representation ( sb , c ) ; } } else { / / No charset CaMeL Encoder provided - pass straight latin characters / / through , and escape the rest . Doing the explicit character / / check is measurably faster than using the Charset CaMeL Encoder . if ( c > 0 x 1 f && c <= 0 x $NUMBER$ f ) { sb . append ( c ) ; } else { / / Other characters can be misinterpreted by some js parsers , / / or perhaps mangled by proxies along the way , / / so we play it safe and unicode escape them . append CaMeL Hex CaMeL Java CaMeL Script CaMeL Representation ( sb , c ) ; } } } } sb . append ( quote ) ; return sb . to CaMeL String ( ) ; }
return true ; <CTX> static boolean evaluates CaMeL To CaMeL Local CaMeL Value ( Node value , Predicate < Node > locals ) { switch ( value . get CaMeL Type ( ) ) { case Token . ASSIGN : / / A result that is aliased by a non - local name , is the effectively the / / same as returning a non - local name , but this doesn $STRING$ re sure the value was never aliased from inside / / the constructor ( similar to call CaMeL Has CaMeL Local CaMeL Result ) return true ; case Token . FUNCTION : case Token . REGEXP : case Token . ARRAYLIT : case Token . OBJECTLIT : / / Literals objects with non - literal children are allowed . return true ; case Token . IN : / / TODO ( johnlenz ) : should IN operator be included in # is CaMeL Simple CaMeL Operator ? return true ; default : / / Other op force a local value : / / x = $STRING$ + g ( x is now an local string ) / / x -= g ( x is now an local number ) if ( is CaMeL Assignment CaMeL Op ( value ) || is CaMeL Simple CaMeL Operator ( value ) || is CaMeL Immutable CaMeL Value ( value ) ) { return true ; } throw new Illegal CaMeL State CaMeL Exception ( $STRING$ + value + $STRING$ + value . get CaMeL Parent ( ) ) ; } }
int index CaMeL Of CaMeL Dot = namespace . index CaMeL Of ( $STRING$ ) ; <CTX> void replace ( ) { if ( first CaMeL Node == null ) { / / Don $STRING$ goog $STRING$ s not a duplicate definition . replacement CaMeL Node = create CaMeL Declaration CaMeL Node ( ) ; if ( first CaMeL Module == minimum CaMeL Module ) { first CaMeL Node . get CaMeL Parent ( ) . add CaMeL Child CaMeL Before ( replacement CaMeL Node , first CaMeL Node ) ; } else { / / In this case , the name was implicitly provided by two independent / / modules . We need to move this code up to a common module . int index CaMeL Of CaMeL Dot = namespace . index CaMeL Of ( $STRING$ ) ; if ( index CaMeL Of CaMeL Dot == - 1 ) { / / Any old place is fine . compiler . get CaMeL Node CaMeL For CaMeL Code CaMeL Insertion ( minimum CaMeL Module ) . add CaMeL Child CaMeL To CaMeL Back ( replacement CaMeL Node ) ; } else { / / Add it after the parent namespace . Provided CaMeL Name parent CaMeL Name = provided CaMeL Names . get ( namespace . substring ( 0 , index CaMeL Of CaMeL Dot ) ) ; Preconditions . check CaMeL Not CaMeL Null ( parent CaMeL Name ) ; Preconditions . check CaMeL Not CaMeL Null ( parent CaMeL Name . replacement CaMeL Node ) ; parent CaMeL Name . replacement CaMeL Node . get CaMeL Parent ( ) . add CaMeL Child CaMeL After ( replacement CaMeL Node , parent CaMeL Name . replacement CaMeL Node ) ; } } if ( explicit CaMeL Node != null ) { explicit CaMeL Node . detach CaMeL From CaMeL Parent ( ) ; } compiler . report CaMeL Code CaMeL Change ( ) ; } }
txt = txt . replace CaMeL All ( $STRING$ , $STRING$ ) ; <CTX> public String caverphone ( String txt ) { / / NOTE : Version 1 . 0 of Caverphone is easily derivable from this code / / by commenting out the $NUMBER$ . 0 lines and adding in the 1 . 0 lines if ( txt == null || txt . length ( ) == 0 ) { return $STRING$ ; } / / 1 . Convert to lowercase txt = txt . to CaMeL Lower CaMeL Case ( java . util . Locale . ENGLISH ) ; / / $NUMBER$ . Remove anything not A - Z txt = txt . replace CaMeL All ( $STRING$ , $STRING$ ) ; / / $NUMBER$ . $NUMBER$ . Remove final e txt = txt . replace CaMeL All ( $STRING$ , $STRING$ ) ; / / $NUMBER$ . 0 only / / $NUMBER$ . Handle various start options txt = txt . replace CaMeL All ( $STRING$ , $STRING$ ) ; txt = txt . replace CaMeL All ( $STRING$ , $STRING$ ) ; txt = txt . replace CaMeL All ( $STRING$ , $STRING$ ) ; txt = txt . replace CaMeL All ( $STRING$ , $STRING$ ) ; / / $NUMBER$ . 0 only txt = txt . replace CaMeL All ( $STRING$ , $STRING$ ) ; / / $NUMBER$ . 0 only - note the spec says ^ enough here again , c + p error I assume txt = txt . replace CaMeL All ( $STRING$ , $STRING$ ) ; / / End txt = txt . replace CaMeL All ( $STRING$ , $STRING$ ) ; / / $NUMBER$ . Handle replacements txt = txt . replace CaMeL All ( $STRING$ , $STRING$ ) ; txt = txt . replace CaMeL All ( $STRING$ , $STRING$ ) ; txt = txt . replace CaMeL All ( $STRING$ , $STRING$ ) ; txt = txt . replace CaMeL All ( $STRING$ , $STRING$ ) ; txt = txt . replace CaMeL All ( $STRING$ , $STRING$ ) ; txt = txt . replace CaMeL All ( $STRING$ , $STRING$ ) ; txt = txt . replace CaMeL All ( $STRING$ , $STRING$ ) ; txt = txt . replace CaMeL All ( $STRING$ , $STRING$ ) ; txt = txt . replace CaMeL All ( $STRING$ , $STRING$ ) ; txt = txt . replace CaMeL All ( $STRING$ , $STRING$ ) ; txt = txt . replace CaMeL All ( $STRING$ , $STRING$ ) ; txt = txt . replace CaMeL All ( $STRING$ , $STRING$ ) ; txt = txt . replace CaMeL All ( $STRING$ , $STRING$ ) ; txt = txt . replace CaMeL All ( $STRING$ , $STRING$ ) ; txt = txt . replace CaMeL All ( $STRING$ , $STRING$ ) ; txt = txt . replace CaMeL All ( $STRING$ , $STRING$ ) ; txt = txt . replace CaMeL All ( $STRING$ , $STRING$ ) ; txt = txt . replace CaMeL All ( $STRING$ , $STRING$ ) ; txt = txt . replace CaMeL All ( $STRING$ , $STRING$ ) ; txt = txt . replace CaMeL All ( $STRING$ , $STRING$ ) ; / / $NUMBER$ . 0 only txt = txt . replace CaMeL All ( $STRING$ , $STRING$ ) ; / / $NUMBER$ . 0 only txt = txt . replace CaMeL All ( $STRING$ , $STRING$ ) ; / / $NUMBER$ . 0 only txt = txt . replace CaMeL All ( $STRING$ , $STRING$ ) ; / / $NUMBER$ . 0 only txt = txt . replace CaMeL All ( $STRING$ , $STRING$ ) ; txt = txt . replace CaMeL All ( $STRING$ , $STRING$ ) ; txt = txt . replace CaMeL All ( $STRING$ , $STRING$ ) ; txt = txt . replace CaMeL All ( $STRING$ , $STRING$ ) ; txt = txt . replace CaMeL All ( $STRING$ , $STRING$ ) ; txt = txt . replace CaMeL All ( $STRING$ , $STRING$ ) ; txt = txt . replace CaMeL All ( $STRING$ , $STRING$ ) ; txt = txt . replace CaMeL All ( $STRING$ , $STRING$ ) ; txt = txt . replace CaMeL All ( $STRING$ , $STRING$ ) ; txt = txt . replace CaMeL All ( $STRING$ , $STRING$ ) ; txt = txt . replace CaMeL All ( $STRING$ , $STRING$ ) ; / / txt = txt . replace CaMeL All ( $STRING$ , $STRING$ ) ; / / 1 . 0 only txt = txt . replace CaMeL All ( $STRING$ , $STRING$ ) ; txt = txt . replace CaMeL All ( $STRING$ , $STRING$ ) ; / / $NUMBER$ . 0 only / / txt = txt . replace CaMeL All ( $STRING$ , $STRING$ ) ; / / 1 . 0 only txt = txt . replace CaMeL All ( $STRING$ , $STRING$ ) ; txt = txt . replace CaMeL All ( $STRING$ , $STRING$ ) ; txt = txt . replace CaMeL All ( $STRING$ , $STRING$ ) ; txt = txt . replace CaMeL All ( $STRING$ , $STRING$ ) ; txt = txt . replace CaMeL All ( $STRING$ , $STRING$ ) ; / / $NUMBER$ . 0 only / / txt = txt . replace CaMeL All ( $STRING$ , $STRING$ ) ; / / 1 . 0 only txt = txt . replace CaMeL All ( $STRING$ , $STRING$ ) ; txt = txt . replace CaMeL All ( $STRING$ , $STRING$ ) ; txt = txt . replace CaMeL All ( $STRING$ , $STRING$ ) ; / / $NUMBER$ . 0 only / / txt = txt . replace CaMeL All ( $STRING$ , $STRING$ ) ; / / 1 . 0 only txt = txt . replace CaMeL All ( $STRING$ , $STRING$ ) ; / / txt = txt . replace CaMeL All ( $STRING$ , $STRING$ ) ; / / 1 . 0 only / / txt = txt . replace CaMeL All ( $STRING$ , $STRING$ ) ; / / 1 . 0 only / / txt = txt . replace CaMeL All ( $STRING$ , $STRING$ ) ; / / 1 . 0 only / / $NUMBER$ . Handle removals txt = txt . replace CaMeL All ( $STRING$ , $STRING$ ) ; txt = txt . replace CaMeL All ( $STRING$ , $STRING$ ) ; / / $NUMBER$ . 0 only txt = txt . replace CaMeL All ( $STRING$ , $STRING$ ) ; / / $NUMBER$ . put ten 1 s on the end txt = txt + $STRING$ + $STRING$ ; / / 1 . 0 only has $NUMBER$ 1 s / / $NUMBER$ . take the first six characters as the code return txt . substring ( 0 , $NUMBER$ ) ; / / 1 . 0 truncates to $NUMBER$ }
return new String ( bytes , Charsets . ISO _ $NUMBER$ _ 1 ) ; <CTX> public static String new CaMeL String CaMeL Iso $NUMBER$ _ 1 ( final byte [ ] bytes ) { return new String ( bytes , Charsets . ISO _ $NUMBER$ _ 1 ) ; }
return Char CaMeL Sequence CaMeL Utils . region CaMeL Matches ( cs 1 , false , 0 , cs $NUMBER$ , 0 , Math . max ( cs 1 . length ( ) , cs $NUMBER$ . length ( ) ) ) ; <CTX> public static boolean equals ( final Char CaMeL Sequence cs 1 , final Char CaMeL Sequence cs $NUMBER$ ) { if ( cs 1 == cs $NUMBER$ ) { return true ; } if ( cs 1 == null || cs $NUMBER$ == null ) { return false ; } if ( cs 1 instanceof String && cs $NUMBER$ instanceof String ) { return cs 1 . equals ( cs $NUMBER$ ) ; } return Char CaMeL Sequence CaMeL Utils . region CaMeL Matches ( cs 1 , false , 0 , cs $NUMBER$ , 0 , Math . max ( cs 1 . length ( ) , cs $NUMBER$ . length ( ) ) ) ; }
if ( line CaMeL Length > 0 ) { <CTX> void encode ( byte [ ] in , int in CaMeL Pos , int in CaMeL Avail ) { if ( eof ) { return ; } / / in CaMeL Avail < 0 is how we $STRING$ re / / encoding . if ( in CaMeL Avail < 0 ) { eof = true ; if ( buf == null || buf . length - pos < encode CaMeL Size ) { resize CaMeL Buf ( ) ; } switch ( modulus ) { case 1 : buf [ pos ++ ] = encode CaMeL Table [ ( x >> $NUMBER$ ) & MASK _ $NUMBER$ BITS ] ; buf [ pos ++ ] = encode CaMeL Table [ ( x << $NUMBER$ ) & MASK _ $NUMBER$ BITS ] ; / / URL - SAFE skips the padding to further reduce size . if ( encode CaMeL Table == STANDARD _ ENCODE _ TABLE ) { buf [ pos ++ ] = PAD ; buf [ pos ++ ] = PAD ; } break ; case $NUMBER$ : buf [ pos ++ ] = encode CaMeL Table [ ( x >> $NUMBER$ ) & MASK _ $NUMBER$ BITS ] ; buf [ pos ++ ] = encode CaMeL Table [ ( x >> $NUMBER$ ) & MASK _ $NUMBER$ BITS ] ; buf [ pos ++ ] = encode CaMeL Table [ ( x << $NUMBER$ ) & MASK _ $NUMBER$ BITS ] ; / / URL - SAFE skips the padding to further reduce size . if ( encode CaMeL Table == STANDARD _ ENCODE _ TABLE ) { buf [ pos ++ ] = PAD ; } break ; } if ( line CaMeL Length > 0 ) { System . arraycopy ( line CaMeL Separator , 0 , buf , pos , line CaMeL Separator . length ) ; pos += line CaMeL Separator . length ; } } else { for ( int i = 0 ; i < in CaMeL Avail ; i ++ ) { if ( buf == null || buf . length - pos < encode CaMeL Size ) { resize CaMeL Buf ( ) ; } modulus = ( ++ modulus ) % $NUMBER$ ; int b = in [ in CaMeL Pos ++ ] ; if ( b < 0 ) { b += $NUMBER$ ; } x = ( x << 8 ) + b ; if ( 0 == modulus ) { buf [ pos ++ ] = encode CaMeL Table [ ( x >> $NUMBER$ ) & MASK _ $NUMBER$ BITS ] ; buf [ pos ++ ] = encode CaMeL Table [ ( x >> $NUMBER$ ) & MASK _ $NUMBER$ BITS ] ; buf [ pos ++ ] = encode CaMeL Table [ ( x >> $NUMBER$ ) & MASK _ $NUMBER$ BITS ] ; buf [ pos ++ ] = encode CaMeL Table [ x & MASK _ $NUMBER$ BITS ] ; current CaMeL Line CaMeL Pos += $NUMBER$ ; if ( line CaMeL Length > 0 && line CaMeL Length <= current CaMeL Line CaMeL Pos ) { System . arraycopy ( line CaMeL Separator , 0 , buf , pos , line CaMeL Separator . length ) ; pos += line CaMeL Separator . length ; current CaMeL Line CaMeL Pos = 0 ; } } } } }
} else if ( contains ( value , index + 1 , $NUMBER$ , $STRING$ ) ) { <CTX> private int handle CaMeL G ( String value , Double CaMeL Metaphone CaMeL Result result , int index , boolean slavo CaMeL Germanic ) { if ( char CaMeL At ( value , index + 1 ) == $STRING$ ) { index = handle CaMeL GH ( value , result , index ) ; } else if ( char CaMeL At ( value , index + 1 ) == $STRING$ ) { if ( index == 1 && is CaMeL Vowel ( char CaMeL At ( value , 0 ) ) && ! slavo CaMeL Germanic ) { result . append ( $STRING$ , $STRING$ ) ; } else if ( ! contains ( value , index + $NUMBER$ , $NUMBER$ , $STRING$ ) && char CaMeL At ( value , index + 1 ) != $STRING$ && ! slavo CaMeL Germanic ) { result . append ( $STRING$ , $STRING$ ) ; } else { result . append ( $STRING$ ) ; } index = index + $NUMBER$ ; } else if ( contains ( value , index + 1 , $NUMBER$ , $STRING$ ) && ! slavo CaMeL Germanic ) { result . append ( $STRING$ , $STRING$ ) ; index += $NUMBER$ ; } else if ( index == 0 && ( char CaMeL At ( value , index + 1 ) == $STRING$ || contains ( value , index + 1 , $NUMBER$ , ES _ EP _ EB _ EL _ EY _ IB _ IL _ IN _ IE _ EI _ ER ) ) ) { / / -- -- ges - , - gep - , - gel - , - gie - at beginning -- / / result . append ( $STRING$ , $STRING$ ) ; index += $NUMBER$ ; } else if ( ( contains ( value , index + 1 , $NUMBER$ , $STRING$ ) || char CaMeL At ( value , index + 1 ) == $STRING$ ) && ! contains ( value , 0 , $NUMBER$ , $STRING$ , $STRING$ , $STRING$ ) && ! contains ( value , index - 1 , 1 , $STRING$ , $STRING$ ) && ! contains ( value , index - 1 , $NUMBER$ , $STRING$ , $STRING$ ) ) { / / -- -- ger - , - gy -- -- / / result . append ( $STRING$ , $STRING$ ) ; index += $NUMBER$ ; } else if ( contains ( value , index + 1 , 1 , $STRING$ , $STRING$ , $STRING$ ) || contains ( value , index - 1 , $NUMBER$ , $STRING$ , $STRING$ ) ) { / / -- Italian $STRING$ -- / / if ( ( contains ( value , 0 , $NUMBER$ , $STRING$ , $STRING$ ) || contains ( value , 0 , $NUMBER$ , $STRING$ ) ) || contains ( value , index + 1 , $NUMBER$ , $STRING$ ) ) { / / -- obvious germanic -- / / result . append ( $STRING$ ) ; } else if ( contains ( value , index + 1 , $NUMBER$ , $STRING$ ) ) { result . append ( $STRING$ ) ; } else { result . append ( $STRING$ , $STRING$ ) ; } index += $NUMBER$ ; } else if ( char CaMeL At ( value , index + 1 ) == $STRING$ ) { index += $NUMBER$ ; result . append ( $STRING$ ) ; } else { index ++ ; result . append ( $STRING$ ) ; } return index ; }
this ( false ) ; <CTX> public Base 64 ( ) { this ( false ) ; }
return String CaMeL Utils . new CaMeL String CaMeL Utf 8 ( encode CaMeL Base 64 ( binary CaMeL Data , true ) ) ; <CTX> public static String encode CaMeL Base 64 String ( byte [ ] binary CaMeL Data ) { return String CaMeL Utils . new CaMeL String CaMeL Utf 8 ( encode CaMeL Base 64 ( binary CaMeL Data , true ) ) ; }
long len = get CaMeL Encode CaMeL Length ( binary CaMeL Data , MIME _ CHUNK _ SIZE , CHUNK _ SEPARATOR ) ; <CTX> public static byte [ ] encode CaMeL Base 64 ( byte [ ] binary CaMeL Data , boolean is CaMeL Chunked , boolean url CaMeL Safe , int max CaMeL Result CaMeL Size ) { if ( binary CaMeL Data == null || binary CaMeL Data . length == 0 ) { return binary CaMeL Data ; } long len = get CaMeL Encode CaMeL Length ( binary CaMeL Data , MIME _ CHUNK _ SIZE , CHUNK _ SEPARATOR ) ; if ( len > max CaMeL Result CaMeL Size ) { throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ + len + $STRING$ + max CaMeL Result CaMeL Size ) ; } Base 64 b 64 = is CaMeL Chunked ? new Base 64 ( url CaMeL Safe ) : new Base 64 ( 0 , CHUNK _ SEPARATOR , url CaMeL Safe ) ; return b 64 . encode ( binary CaMeL Data ) ; }
private Object read CaMeL Resolve ( ) { <CTX> private Object read CaMeL Resolve ( ) { calculate CaMeL Hash CaMeL Code ( keys ) ; return this ; }
if ( raw CaMeL Central CaMeL Directory CaMeL Data . length != expected CaMeL Length ) { <CTX> public void reparse CaMeL Central CaMeL Directory CaMeL Data ( boolean has CaMeL Uncompressed CaMeL Size , boolean has CaMeL Compressed CaMeL Size , boolean has CaMeL Relative CaMeL Header CaMeL Offset , boolean has CaMeL Disk CaMeL Start ) throws Zip CaMeL Exception { if ( raw CaMeL Central CaMeL Directory CaMeL Data != null ) { int expected CaMeL Length = ( has CaMeL Uncompressed CaMeL Size ? DWORD : 0 ) + ( has CaMeL Compressed CaMeL Size ? DWORD : 0 ) + ( has CaMeL Relative CaMeL Header CaMeL Offset ? DWORD : 0 ) + ( has CaMeL Disk CaMeL Start ? WORD : 0 ) ; if ( raw CaMeL Central CaMeL Directory CaMeL Data . length != expected CaMeL Length ) { throw new Zip CaMeL Exception ( $STRING$ + $STRING$ + $STRING$ + $STRING$ + expected CaMeL Length + $STRING$ + raw CaMeL Central CaMeL Directory CaMeL Data . length ) ; } int offset = 0 ; if ( has CaMeL Uncompressed CaMeL Size ) { size = new Zip CaMeL Eight CaMeL Byte CaMeL Integer ( raw CaMeL Central CaMeL Directory CaMeL Data , offset ) ; offset += DWORD ; } if ( has CaMeL Compressed CaMeL Size ) { compressed CaMeL Size = new Zip CaMeL Eight CaMeL Byte CaMeL Integer ( raw CaMeL Central CaMeL Directory CaMeL Data , offset ) ; offset += DWORD ; } if ( has CaMeL Relative CaMeL Header CaMeL Offset ) { relative CaMeL Header CaMeL Offset = new Zip CaMeL Eight CaMeL Byte CaMeL Integer ( raw CaMeL Central CaMeL Directory CaMeL Data , offset ) ; offset += DWORD ; } if ( has CaMeL Disk CaMeL Start ) { disk CaMeL Start = new Zip CaMeL Long ( raw CaMeL Central CaMeL Directory CaMeL Data , offset ) ; offset += WORD ; } } }
dict CaMeL Size |= ( coder . properties [ i + 1 ] << ( 8 * i ) ) ; <CTX> Input CaMeL Stream decode ( final Input CaMeL Stream in , final Coder coder , byte [ ] password ) throws IO CaMeL Exception { byte props CaMeL Byte = coder . properties [ 0 ] ; long dict CaMeL Size = coder . properties [ 1 ] ; for ( int i = 1 ; i < $NUMBER$ ; i ++ ) { dict CaMeL Size |= ( coder . properties [ i + 1 ] << ( 8 * i ) ) ; } if ( dict CaMeL Size > LZMA CaMeL Input CaMeL Stream . DICT _ SIZE _ MAX ) { throw new IO CaMeL Exception ( $STRING$ ) ; } return new LZMA CaMeL Input CaMeL Stream ( in , - 1 , props CaMeL Byte , ( int ) dict CaMeL Size ) ; }
if ( get CaMeL Name ( ) . ends CaMeL With ( $STRING$ ) ) { <CTX> public boolean is CaMeL Directory ( ) { if ( file != null ) { return file . is CaMeL Directory ( ) ; } if ( link CaMeL Flag == LF _ DIR ) { return true ; } if ( get CaMeL Name ( ) . ends CaMeL With ( $STRING$ ) ) { return true ; } return false ; }
if ( current == $STRING$ ) { <CTX> public int read ( ) throws IO CaMeL Exception { int current = super . read ( ) ; if ( current == $STRING$ ) { line CaMeL Counter ++ ; } last CaMeL Char = current ; return last CaMeL Char ; }
final boolean empty CaMeL Header = header . trim ( ) . is CaMeL Empty ( ) ; <CTX> 
if ( new CaMeL Record && ( c < $STRING$ || c > $STRING$ && c < $STRING$ || c > $STRING$ && c < $STRING$ || c > $STRING$ ) ) { <CTX> private void print CaMeL And CaMeL Quote ( final Object object , final Char CaMeL Sequence value , final int offset , final int len , final Appendable out , final boolean new CaMeL Record ) throws IO CaMeL Exception { boolean quote = false ; int start = offset ; int pos = offset ; final int end = offset + len ; final char delim CaMeL Char = get CaMeL Delimiter ( ) ; final char quote CaMeL Char = get CaMeL Quote CaMeL Character ( ) . char CaMeL Value ( ) ; Quote CaMeL Mode quote CaMeL Mode CaMeL Policy = get CaMeL Quote CaMeL Mode ( ) ; if ( quote CaMeL Mode CaMeL Policy == null ) { quote CaMeL Mode CaMeL Policy = Quote CaMeL Mode . MINIMAL ; } switch ( quote CaMeL Mode CaMeL Policy ) { case ALL : quote = true ; break ; case NON _ NUMERIC : quote = ! ( object instanceof Number ) ; break ; case NONE : / / Use the existing escaping code print CaMeL And CaMeL Escape ( value , offset , len , out ) ; return ; case MINIMAL : if ( len <= 0 ) { / / always quote an empty token that is the first / / on the line , as it may be the only thing on the / / line . If it were not quoted in that case , / / an empty line has no tokens . if ( new CaMeL Record ) { quote = true ; } } else { char c = value . char CaMeL At ( pos ) ; / / RFC $NUMBER$ ( https : / / tools . ietf . org / html / rfc $NUMBER$ ) TEXTDATA = % x $NUMBER$ - $NUMBER$ / % x $NUMBER$ - $NUMBER$ B / % x $NUMBER$ D - $NUMBER$ E if ( new CaMeL Record && ( c < $STRING$ || c > $STRING$ && c < $STRING$ || c > $STRING$ && c < $STRING$ || c > $STRING$ ) ) { quote = true ; } else if ( c <= COMMENT ) { / / Some other chars at the start of a value caused the parser to fail , so for now / / encapsulate if we start in anything less than $STRING$ . We are being conservative / / by including the default comment char too . quote = true ; } else { while ( pos < end ) { c = value . char CaMeL At ( pos ) ; if ( c == LF || c == CR || c == quote CaMeL Char || c == delim CaMeL Char ) { quote = true ; break ; } pos ++ ; } if ( ! quote ) { pos = end - 1 ; c = value . char CaMeL At ( pos ) ; / / Some other chars at the end caused the parser to fail , so for now / / encapsulate if we end in anything less than $STRING$ if ( c <= SP ) { quote = true ; } } } } if ( ! quote ) { / / no encapsulation needed - write out the original value out . append ( value , start , end ) ; return ; } break ; default : throw new Illegal CaMeL State CaMeL Exception ( $STRING$ + quote CaMeL Mode CaMeL Policy ) ; } if ( ! quote ) { / / no encapsulation needed - write out the original value out . append ( value , start , end ) ; return ; } / / we hit something that needed encapsulation out . append ( quote CaMeL Char ) ; / / Pick up where we left off : pos should be positioned on the first character that caused / / the need for encapsulation . while ( pos < end ) { final char c = value . char CaMeL At ( pos ) ; if ( c == quote CaMeL Char ) { / / write out the chunk up until this point / / add 1 to the length to write out the encapsulator also out . append ( value , start , pos + 1 ) ; / / put the next starting position on the encapsulator so we will / / write it out again with the next string ( effectively doubling it ) start = pos ; } pos ++ ; } / / write the last segment out . append ( value , start , pos ) ; out . append ( quote CaMeL Char ) ; }
return new Linked CaMeL Hash CaMeL Map < String , Integer > ( this . header CaMeL Map ) ; <CTX> public Map < String , Integer > get CaMeL Header CaMeL Map ( ) { return new Linked CaMeL Hash CaMeL Map < String , Integer > ( this . header CaMeL Map ) ; }
if ( last == NUMBER _ CHAR _ DIGIT && fits CaMeL In CaMeL Long && ( value != Long . MIN _ VALUE || negative ) ) { <CTX> private int peek CaMeL Number ( ) throws IO CaMeL Exception { / / Like next CaMeL Non CaMeL Whitespace , this uses locals $STRING$ and $STRING$ to save inner - loop field access . char [ ] buffer = this . buffer ; int p = pos ; int l = limit ; long value = 0 ; / / Negative to accommodate Long . MIN _ VALUE more easily . boolean negative = false ; boolean fits CaMeL In CaMeL Long = true ; int last = NUMBER _ CHAR _ NONE ; int i = 0 ; characters CaMeL Of CaMeL Number : for ( ; true ; i ++ ) { if ( p + i == l ) { if ( i == buffer . length ) { / / Though this looks like a well - formed number , it $STRING$ - $STRING$ + $STRING$ e $STRING$ E $STRING$ . $STRING$ 0 $STRING$ $NUMBER$ $STRING$ 0 $STRING$ 0 $STRING$ 0 $STRING$ ve read a complete number . Decide if it s a PEEKED _ LONG or a PEEKED _ NUMBER . if ( last == NUMBER _ CHAR _ DIGIT && fits CaMeL In CaMeL Long && ( value != Long . MIN _ VALUE || negative ) ) { peeked CaMeL Long = negative ? value : - value ; pos += i ; return peeked = PEEKED _ LONG ; } else if ( last == NUMBER _ CHAR _ DIGIT || last == NUMBER _ CHAR _ FRACTION _ DIGIT || last == NUMBER _ CHAR _ EXP _ DIGIT ) { peeked CaMeL Number CaMeL Length = i ; return peeked = PEEKED _ NUMBER ; } else { return PEEKED _ NONE ; } }
if ( Double . is CaMeL Na CaMeL N ( value ) || Double . is CaMeL Infinite ( value ) ) { <CTX> public Json CaMeL Writer value ( double value ) throws IO CaMeL Exception { write CaMeL Deferred CaMeL Name ( ) ; if ( Double . is CaMeL Na CaMeL N ( value ) || Double . is CaMeL Infinite ( value ) ) { throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ + value ) ; } before CaMeL Value ( ) ; out . append ( Double . to CaMeL String ( value ) ) ; return this ; }
if ( i <= max CaMeL Code ) { <CTX> private String _ handle CaMeL Odd CaMeL Name $NUMBER$ ( int start CaMeL Ptr , int hash , int [ ] codes ) throws IO CaMeL Exception { _ text CaMeL Buffer . reset CaMeL With CaMeL Shared ( _ input CaMeL Buffer , start CaMeL Ptr , ( _ input CaMeL Ptr - start CaMeL Ptr ) ) ; char [ ] out CaMeL Buf = _ text CaMeL Buffer . get CaMeL Current CaMeL Segment ( ) ; int out CaMeL Ptr = _ text CaMeL Buffer . get CaMeL Current CaMeL Segment CaMeL Size ( ) ; final int max CaMeL Code = codes . length ; while ( true ) { if ( _ input CaMeL Ptr >= _ input CaMeL End ) { if ( ! _ load CaMeL More ( ) ) { / / acceptable for now ( will error out later ) break ; } } char c = _ input CaMeL Buffer [ _ input CaMeL Ptr ] ; int i = ( int ) c ; if ( i <= max CaMeL Code ) { if ( codes [ i ] != 0 ) { break ; } } else if ( ! Character . is CaMeL Java CaMeL Identifier CaMeL Part ( c ) ) { break ; } ++ _ input CaMeL Ptr ; hash = ( hash * Chars CaMeL To CaMeL Name CaMeL Canonicalizer . HASH _ MULT ) + i ; / / Ok , let s add char to output : out CaMeL Buf [ out CaMeL Ptr ++ ] = c ; / / Need more room ? if ( out CaMeL Ptr >= out CaMeL Buf . length ) { out CaMeL Buf = _ text CaMeL Buffer . finish CaMeL Current CaMeL Segment ( ) ; out CaMeL Ptr = 0 ; } } _ text CaMeL Buffer . set CaMeL Current CaMeL Length ( out CaMeL Ptr ) ; { Text CaMeL Buffer tb = _ text CaMeL Buffer ; char [ ] buf = tb . get CaMeL Text CaMeL Buffer ( ) ; int start = tb . get CaMeL Text CaMeL Offset ( ) ; int len = tb . size ( ) ; return _ symbols . find CaMeL Symbol ( buf , start , len , hash ) ; } }
char c = str . char CaMeL At ( i ++ ) ; <CTX> private final static int _ parse CaMeL Index ( String str ) { final int len = str . length ( ) ; / / [ Issue # $NUMBER$ ] : beware of super long indexes ; assume we never / / have arrays over $NUMBER$ billion entries so ints are fine . if ( len == 0 || len > $NUMBER$ ) { return - 1 ; } for ( int i = 0 ; i < len ; ++ i ) { char c = str . char CaMeL At ( i ++ ) ; if ( c > $STRING$ || c < $STRING$ ) { return - 1 ; } } if ( len == $NUMBER$ ) { long l = Number CaMeL Input . parse CaMeL Long ( str ) ; if ( l > Integer . MAX _ VALUE ) { return - 1 ; } } return Number CaMeL Input . parse CaMeL Int ( str ) ; }
if ( ! _ has CaMeL Segments ) return _ current CaMeL Segment ; <CTX> public char [ ] get CaMeL Text CaMeL Buffer ( ) { / / Are we just using shared input buffer ? if ( _ input CaMeL Start >= 0 ) return _ input CaMeL Buffer ; if ( _ result CaMeL Array != null ) return _ result CaMeL Array ; if ( _ result CaMeL String != null ) { return ( _ result CaMeL Array = _ result CaMeL String . to CaMeL Char CaMeL Array ( ) ) ; } / / Nope ; but does it fit in just one segment ? if ( ! _ has CaMeL Segments ) return _ current CaMeL Segment ; / / Nope , need to have / create a non - segmented array and return it return contents CaMeL As CaMeL Array ( ) ; }
return null ; <CTX> protected final Json CaMeL Deserializer < Object > _ find CaMeL Deserializer ( Deserialization CaMeL Context ctxt , String type CaMeL Id ) throws IO CaMeL Exception { Json CaMeL Deserializer < Object > deser = _ deserializers . get ( type CaMeL Id ) ; if ( deser == null ) { / * As per [ databind # $NUMBER$ ] , need to provide contextual info . But for * backwards compatibility , let $STRING$ type class ( simple type to container ) ; otherwise * we may try to narrow a Simple CaMeL Type ( Object . class ) into Map CaMeL Type ( Map . class ) , losing actual * type in process ( getting Simple CaMeL Type of Map . class which will not work as expected ) * / if ( ( _ base CaMeL Type != null ) && _ base CaMeL Type . get CaMeL Class ( ) == type . get CaMeL Class ( ) ) { / * $NUMBER$ - Aug - $NUMBER$ , tatu : Not sure if the second part of the check makes sense ; * but it appears to check that Java CaMeL Type impl class is the same which is * important for some reason ? * Disabling the check will break $NUMBER$ Enum - related tests . * / / / $NUMBER$ - Jun - $NUMBER$ , tatu : As per [ databind # $NUMBER$ ] we may actually get full / / generic type with custom type resolvers . If so , should try to retain them . / / Whether this is sufficient to avoid problems remains to be seen , but for / / now it should improve things . if ( ! type . has CaMeL Generic CaMeL Types ( ) ) { type = ctxt . get CaMeL Type CaMeL Factory ( ) . construct CaMeL Specialized CaMeL Type ( _ base CaMeL Type , type . get CaMeL Raw CaMeL Class ( ) ) ; } } deser = ctxt . find CaMeL Contextual CaMeL Value CaMeL Deserializer ( type , _ property ) ; } _ deserializers . put ( type CaMeL Id , deser ) ; } return deser ; }
return ( previous != null ) && previous . equals ( ann ) ; <CTX> protected final boolean _ add ( Annotation ann ) { if ( _ annotations == null ) { _ annotations = new Hash CaMeL Map < Class < ? extends Annotation > , Annotation > ( ) ; } Annotation previous = _ annotations . put ( ann . annotation CaMeL Type ( ) , ann ) ; return ( previous != null ) && previous . equals ( ann ) ; }
|| Tree CaMeL Node . class . is CaMeL Assignable CaMeL From ( t . get CaMeL Raw CaMeL Class ( ) ) ) ; <CTX> public boolean use CaMeL For CaMeL Type ( Java CaMeL Type t ) { switch ( _ applies CaMeL For ) { case NON _ CONCRETE _ AND _ ARRAYS : while ( t . is CaMeL Array CaMeL Type ( ) ) { t = t . get CaMeL Content CaMeL Type ( ) ; } / / fall through case OBJECT _ AND _ NON _ CONCRETE : / / return t . is CaMeL Java CaMeL Lang CaMeL Object ( ) || return ( t . get CaMeL Raw CaMeL Class ( ) == Object . class ) || ( ! t . is CaMeL Concrete ( ) / / [ databind # $NUMBER$ ] Should not apply to JSON tree models : || Tree CaMeL Node . class . is CaMeL Assignable CaMeL From ( t . get CaMeL Raw CaMeL Class ( ) ) ) ; case NON _ FINAL : while ( t . is CaMeL Array CaMeL Type ( ) ) { t = t . get CaMeL Content CaMeL Type ( ) ; } / / [ Issue # $NUMBER$ ] Should not apply to JSON tree models : return ! t . is CaMeL Final ( ) && ! Tree CaMeL Node . class . is CaMeL Assignable CaMeL From ( t . get CaMeL Raw CaMeL Class ( ) ) ; default : / / case JAVA _ LANG _ OBJECT : / / return t . is CaMeL Java CaMeL Lang CaMeL Object ( ) ; return ( t . get CaMeL Raw CaMeL Class ( ) == Object . class ) ; } }
if ( ext . handle CaMeL Property CaMeL Value ( p , ctxt , prop CaMeL Name , buffer ) ) { <CTX> protected Object deserialize CaMeL Using CaMeL Property CaMeL Based CaMeL With CaMeL External CaMeL Type CaMeL Id ( Json CaMeL Parser p , Deserialization CaMeL Context ctxt ) throws IO CaMeL Exception { final External CaMeL Type CaMeL Handler ext = _ external CaMeL Type CaMeL Id CaMeL Handler . start ( ) ; final Property CaMeL Based CaMeL Creator creator = _ property CaMeL Based CaMeL Creator ; Property CaMeL Value CaMeL Buffer buffer = creator . start CaMeL Building ( p , ctxt , _ object CaMeL Id CaMeL Reader ) ; Token CaMeL Buffer tokens = new Token CaMeL Buffer ( p ) ; tokens . write CaMeL Start CaMeL Object ( ) ; Json CaMeL Token t = p . get CaMeL Current CaMeL Token ( ) ; for ( ; t == Json CaMeL Token . FIELD _ NAME ; t = p . next CaMeL Token ( ) ) { String prop CaMeL Name = p . get CaMeL Current CaMeL Name ( ) ; p . next CaMeL Token ( ) ; / / to point to value / / creator property ? Settable CaMeL Bean CaMeL Property creator CaMeL Prop = creator . find CaMeL Creator CaMeL Property ( prop CaMeL Name ) ; if ( creator CaMeL Prop != null ) { / / first : let $STRING$ s too complicated , so bail out throw ctxt . mapping CaMeL Exception ( $STRING$ ) ; } return ext . complete ( p , ctxt , bean ) ; } } continue ; } / / Object Id property ? if ( buffer . read CaMeL Id CaMeL Property ( prop CaMeL Name ) ) { continue ; } / / regular property ? needs buffering Settable CaMeL Bean CaMeL Property prop = _ bean CaMeL Properties . find ( prop CaMeL Name ) ; if ( prop != null ) { buffer . buffer CaMeL Property ( prop , prop . deserialize ( p , ctxt ) ) ; continue ; } / / external type id ( or property that depends on it ) ? if ( ext . handle CaMeL Property CaMeL Value ( p , ctxt , prop CaMeL Name , null ) ) { continue ; } / * As per [ JACKSON - $NUMBER$ ] , things marked as ignorable should not be * passed to any setter * / if ( _ ignorable CaMeL Props != null && _ ignorable CaMeL Props . contains ( prop CaMeL Name ) ) { handle CaMeL Ignored CaMeL Property ( p , ctxt , handled CaMeL Type ( ) , prop CaMeL Name ) ; continue ; } / / $STRING$ ? if ( _ any CaMeL Setter != null ) { buffer . buffer CaMeL Any CaMeL Property ( _ any CaMeL Setter , prop CaMeL Name , _ any CaMeL Setter . deserialize ( p , ctxt ) ) ; } } / / We hit END _ OBJECT ; resolve the pieces : try { return ext . complete ( p , ctxt , buffer , creator ) ; } catch ( Exception e ) { wrap CaMeL Instantiation CaMeL Problem ( e , ctxt ) ; return null ; / / never gets here } }
visit CaMeL Float CaMeL Format ( visitor , type CaMeL Hint , Json CaMeL Parser . Number CaMeL Type . BIG _ INTEGER ) ; <CTX> public void accept CaMeL Json CaMeL Format CaMeL Visitor ( Json CaMeL Format CaMeL Visitor CaMeL Wrapper visitor , Java CaMeL Type type CaMeL Hint ) throws Json CaMeL Mapping CaMeL Exception { if ( _ is CaMeL Int ) { visit CaMeL Int CaMeL Format ( visitor , type CaMeL Hint , Json CaMeL Parser . Number CaMeL Type . BIG _ INTEGER ) ; } else { Class < ? > h = handled CaMeL Type ( ) ; if ( h == Big CaMeL Decimal . class ) { visit CaMeL Float CaMeL Format ( visitor , type CaMeL Hint , Json CaMeL Parser . Number CaMeL Type . BIG _ INTEGER ) ; } else { / / otherwise bit unclear what to call . . . but let s try : / * Json CaMeL Number CaMeL Format CaMeL Visitor v $NUMBER$ = * / visitor . expect CaMeL Number CaMeL Format ( type CaMeL Hint ) ; } } }
return new Simple CaMeL Type ( subclass , _ bindings , _ super CaMeL Class , _ super CaMeL Interfaces , <CTX> protected Java CaMeL Type _ narrow ( Class < ? > subclass ) { if ( _ class == subclass ) { return this ; } / / Should we check that there is a sub - class relationship ? / / $NUMBER$ - Jan - $NUMBER$ , tatu : Almost yes , but there are some complications with / / placeholder values , so no . / * if ( ! _ class . is CaMeL Assignable CaMeL From ( subclass ) ) { throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ + subclass . get CaMeL Name ( ) + $STRING$ + _ class . get CaMeL Name ( ) ) ; } * / / / $NUMBER$ - Jan - $NUMBER$ , tatu : Not correct ; should really re - resolve . . . return new Simple CaMeL Type ( subclass , _ bindings , _ super CaMeL Class , _ super CaMeL Interfaces , _ value CaMeL Handler , _ type CaMeL Handler , _ as CaMeL Static ) ; }
sb . append ( $STRING$ ) ; <CTX> public String CaMeL Builder get CaMeL Generic CaMeL Signature ( String CaMeL Builder sb ) { _ class CaMeL Signature ( _ class , sb , false ) ; sb . append ( $STRING$ ) ; sb = _ referenced CaMeL Type . get CaMeL Generic CaMeL Signature ( sb ) ; sb . append ( $STRING$ ) ; return sb ; }
return _ bind CaMeL And CaMeL Read CaMeL Values ( _ consider CaMeL Filter ( _ parser CaMeL Factory . create CaMeL Parser ( src ) , <CTX> public < T > Mapping CaMeL Iterator < T > read CaMeL Values ( byte [ ] src , int offset , int length ) throws IO CaMeL Exception , Json CaMeL Processing CaMeL Exception { if ( _ data CaMeL Format CaMeL Readers != null ) { return _ detect CaMeL Bind CaMeL And CaMeL Read CaMeL Values ( _ data CaMeL Format CaMeL Readers . find CaMeL Format ( src , offset , length ) , false ) ; } return _ bind CaMeL And CaMeL Read CaMeL Values ( _ consider CaMeL Filter ( _ parser CaMeL Factory . create CaMeL Parser ( src ) , true ) ) ; }
found = key . equals ( prop . get CaMeL Name ( ) ) ; <CTX> public void remove ( Settable CaMeL Bean CaMeL Property prop CaMeL To CaMeL Rm ) { Array CaMeL List < Settable CaMeL Bean CaMeL Property > props = new Array CaMeL List < Settable CaMeL Bean CaMeL Property > ( _ size ) ; String key = get CaMeL Property CaMeL Name ( prop CaMeL To CaMeL Rm ) ; boolean found = false ; for ( int i = 1 , end = _ hash CaMeL Area . length ; i < end ; i += $NUMBER$ ) { Settable CaMeL Bean CaMeL Property prop = ( Settable CaMeL Bean CaMeL Property ) _ hash CaMeL Area [ i ] ; if ( prop == null ) { continue ; } if ( ! found ) { / / $NUMBER$ - Jan - $NUMBER$ , tatu : Important : must check name slot and NOT property name , / / as only former is lower - case in case - insensitive case found = key . equals ( prop . get CaMeL Name ( ) ) ; if ( found ) { / / need to leave a hole here _ props CaMeL In CaMeL Order [ _ find CaMeL From CaMeL Ordered ( prop ) ] = null ; continue ; } } props . add ( prop ) ; } if ( ! found ) { throw new No CaMeL Such CaMeL Element CaMeL Exception ( $STRING$ + prop CaMeL To CaMeL Rm . get CaMeL Name ( ) + $STRING$ ) ; } init ( props ) ; }
if ( raw == String . class || raw == Object . class ) { <CTX> public static Std CaMeL Key CaMeL Deserializer for CaMeL Type ( Class < ? > raw ) { int kind ; / / first common types : if ( raw == String . class || raw == Object . class ) { return String CaMeL KD . for CaMeL Type ( raw ) ; } else if ( raw == UUID . class ) { kind = TYPE _ UUID ; } else if ( raw == Integer . class ) { kind = TYPE _ INT ; } else if ( raw == Long . class ) { kind = TYPE _ LONG ; } else if ( raw == Date . class ) { kind = TYPE _ DATE ; } else if ( raw == Calendar . class ) { kind = TYPE _ CALENDAR ; / / then less common ones . . . } else if ( raw == Boolean . class ) { kind = TYPE _ BOOLEAN ; } else if ( raw == Byte . class ) { kind = TYPE _ BYTE ; } else if ( raw == Character . class ) { kind = TYPE _ CHAR ; } else if ( raw == Short . class ) { kind = TYPE _ SHORT ; } else if ( raw == Float . class ) { kind = TYPE _ FLOAT ; } else if ( raw == Double . class ) { kind = TYPE _ DOUBLE ; } else if ( raw == URI . class ) { kind = TYPE _ URI ; } else if ( raw == URL . class ) { kind = TYPE _ URL ; } else if ( raw == Class . class ) { kind = TYPE _ CLASS ; } else if ( raw == Locale . class ) { From CaMeL String CaMeL Deserializer < ? > deser = From CaMeL String CaMeL Deserializer . find CaMeL Deserializer ( Locale . class ) ; return new Std CaMeL Key CaMeL Deserializer ( TYPE _ LOCALE , raw , deser ) ; } else if ( raw == Currency . class ) { From CaMeL String CaMeL Deserializer < ? > deser = From CaMeL String CaMeL Deserializer . find CaMeL Deserializer ( Currency . class ) ; return new Std CaMeL Key CaMeL Deserializer ( TYPE _ CURRENCY , raw , deser ) ; } else { return null ; } return new Std CaMeL Key CaMeL Deserializer ( kind , raw ) ; }
ignored = ignorals . get CaMeL Ignored ( ) ; <CTX> protected void add CaMeL Bean CaMeL Props ( Deserialization CaMeL Context ctxt , Bean CaMeL Description bean CaMeL Desc , Bean CaMeL Deserializer CaMeL Builder builder ) throws Json CaMeL Mapping CaMeL Exception { final boolean is CaMeL Concrete = ! bean CaMeL Desc . get CaMeL Type ( ) . is CaMeL Abstract ( ) ; final Settable CaMeL Bean CaMeL Property [ ] creator CaMeL Props = is CaMeL Concrete ? builder . get CaMeL Value CaMeL Instantiator ( ) . get CaMeL From CaMeL Object CaMeL Arguments ( ctxt . get CaMeL Config ( ) ) : null ; final boolean has CaMeL Creator CaMeL Props = ( creator CaMeL Props != null ) ; / / 01 - May - $NUMBER$ , tatu : Which base type to use here gets tricky , since / / it may often make most sense to use general type for overrides , / / but what we have here may be more specific impl type . But for now / / just use it as is . Json CaMeL Ignore CaMeL Properties . Value ignorals = ctxt . get CaMeL Config ( ) . get CaMeL Default CaMeL Property CaMeL Ignorals ( bean CaMeL Desc . get CaMeL Bean CaMeL Class ( ) , bean CaMeL Desc . get CaMeL Class CaMeL Info ( ) ) ; Set < String > ignored ; if ( ignorals != null ) { boolean ignore CaMeL Any = ignorals . get CaMeL Ignore CaMeL Unknown ( ) ; builder . set CaMeL Ignore CaMeL Unknown CaMeL Properties ( ignore CaMeL Any ) ; / / Or explicit / implicit definitions ? ignored = ignorals . get CaMeL Ignored ( ) ; for ( String prop CaMeL Name : ignored ) { builder . add CaMeL Ignorable ( prop CaMeL Name ) ; } } else { ignored = Collections . empty CaMeL Set ( ) ; } / / Also , do we have a fallback $STRING$ setter ? Annotated CaMeL Method any CaMeL Setter CaMeL Method = bean CaMeL Desc . find CaMeL Any CaMeL Setter ( ) ; Annotated CaMeL Member any CaMeL Setter CaMeL Field = null ; if ( any CaMeL Setter CaMeL Method != null ) { builder . set CaMeL Any CaMeL Setter ( construct CaMeL Any CaMeL Setter ( ctxt , bean CaMeL Desc , any CaMeL Setter CaMeL Method ) ) ; } else { any CaMeL Setter CaMeL Field = bean CaMeL Desc . find CaMeL Any CaMeL Setter CaMeL Field ( ) ; if ( any CaMeL Setter CaMeL Field != null ) { builder . set CaMeL Any CaMeL Setter ( construct CaMeL Any CaMeL Setter ( ctxt , bean CaMeL Desc , any CaMeL Setter CaMeL Field ) ) ; } } / / NOTE : we do NOT add @ Json CaMeL Ignore $STRING$ s any - setter / / Implicit ones via @ Json CaMeL Ignore and equivalent ? if ( any CaMeL Setter CaMeL Method == null && any CaMeL Setter CaMeL Field == null ) { Collection < String > ignored $NUMBER$ = bean CaMeL Desc . get CaMeL Ignored CaMeL Property CaMeL Names ( ) ; if ( ignored $NUMBER$ != null ) { for ( String prop CaMeL Name : ignored $NUMBER$ ) { / / allow ignoral of similarly named JSON property , but do not force ; / / latter means NOT adding this to $STRING$ : builder . add CaMeL Ignorable ( prop CaMeL Name ) ; } } } final boolean use CaMeL Getters CaMeL As CaMeL Setters = ctxt . is CaMeL Enabled ( Mapper CaMeL Feature . USE _ GETTERS _ AS _ SETTERS ) && ctxt . is CaMeL Enabled ( Mapper CaMeL Feature . AUTO _ DETECT _ GETTERS ) ; / / Ok : let $STRING$ s just call a ( new ) method in builder , which does nothing . * / / / but let s call a method just to allow custom builders to be aware . . . final String name = prop CaMeL Def . get CaMeL Name ( ) ; Creator CaMeL Property cprop = null ; if ( creator CaMeL Props != null ) { for ( Settable CaMeL Bean CaMeL Property cp : creator CaMeL Props ) { if ( name . equals ( cp . get CaMeL Name ( ) ) && ( cp instanceof Creator CaMeL Property ) ) { cprop = ( Creator CaMeL Property ) cp ; break ; } } } if ( cprop == null ) { List < String > n = new Array CaMeL List < > ( ) ; for ( Settable CaMeL Bean CaMeL Property cp : creator CaMeL Props ) { n . add ( cp . get CaMeL Name ( ) ) ; } ctxt . report CaMeL Bad CaMeL Property CaMeL Definition ( bean CaMeL Desc , prop CaMeL Def , $STRING$ , name , n ) ; continue ; } if ( prop != null ) { cprop . set CaMeL Fallback CaMeL Setter ( prop ) ; } prop = cprop ; builder . add CaMeL Creator CaMeL Property ( cprop ) ; continue ; } if ( prop != null ) { Class < ? > [ ] views = prop CaMeL Def . find CaMeL Views ( ) ; if ( views == null ) { / / one more twist : if default inclusion disabled , need to force empty set of views if ( ! ctxt . is CaMeL Enabled ( Mapper CaMeL Feature . DEFAULT _ VIEW _ INCLUSION ) ) { views = NO _ VIEWS ; } } / / one more thing before adding to builder : copy any metadata prop . set CaMeL Views ( views ) ; builder . add CaMeL Property ( prop ) ; } } }
param CaMeL Name = candidate . find CaMeL Implicit CaMeL Param CaMeL Name ( 0 ) ; <CTX> protected void _ add CaMeL Explicit CaMeL Any CaMeL Creator ( Deserialization CaMeL Context ctxt , Bean CaMeL Description bean CaMeL Desc , Creator CaMeL Collector creators , Creator CaMeL Candidate candidate ) throws Json CaMeL Mapping CaMeL Exception { / / Looks like there $STRING$ s injection or explicit name , should be properties - based boolean use CaMeL Props = ( param CaMeL Name != null ) || ( inject CaMeL Id != null ) ; if ( ! use CaMeL Props && ( param CaMeL Def != null ) ) { / / One more thing : if implicit name matches property with a getter / / or field , we ll consider it property - based as well / / $NUMBER$ - May - $NUMBER$ , tatu : as per [ databind # $NUMBER$ ] , looks like we have to get / / not implicit name , but name with possible strategy - based - rename / / param CaMeL Name = candidate . find CaMeL Implicit CaMeL Param CaMeL Name ( 0 ) ; param CaMeL Name = candidate . find CaMeL Implicit CaMeL Param CaMeL Name ( 0 ) ; use CaMeL Props = ( param CaMeL Name != null ) && param CaMeL Def . could CaMeL Serialize ( ) ; } if ( use CaMeL Props ) { Settable CaMeL Bean CaMeL Property [ ] properties = new Settable CaMeL Bean CaMeL Property [ ] { construct CaMeL Creator CaMeL Property ( ctxt , bean CaMeL Desc , param CaMeL Name , 0 , param , inject CaMeL Id ) } ; creators . add CaMeL Property CaMeL Creator ( candidate . creator ( ) , true , properties ) ; return ; } _ handle CaMeL Single CaMeL Argument CaMeL Creator ( creators , candidate . creator ( ) , true , true ) ; / / one more thing : sever link to creator property , to avoid possible later / / problems with $STRING$ constructor property if ( param CaMeL Def != null ) { ( ( POJO CaMeL Property CaMeL Builder ) param CaMeL Def ) . remove CaMeL Constructors ( ) ; } }
gen . write CaMeL Object ( _ value ) ; <CTX> public final void serialize ( Json CaMeL Generator gen , Serializer CaMeL Provider ctxt ) throws IO CaMeL Exception { if ( _ value == null ) { ctxt . default CaMeL Serialize CaMeL Null ( gen ) ; } else if ( _ value instanceof Json CaMeL Serializable ) { ( ( Json CaMeL Serializable ) _ value ) . serialize ( gen , ctxt ) ; } else { / / $NUMBER$ - May - $NUMBER$ , tatu : [ databind # $NUMBER$ ] do not call via generator but through context ; / / this to preserve contextual information gen . write CaMeL Object ( _ value ) ; } }
_ root CaMeL Name CaMeL Lookup = src . _ root CaMeL Name CaMeL Lookup ; <CTX> protected Xml CaMeL Serializer CaMeL Provider ( Xml CaMeL Serializer CaMeL Provider src ) { super ( src ) ; / / $NUMBER$ - May - $NUMBER$ , tatu : As per [ dataformat - xml # $NUMBER$ ] , should NOT really copy / / root name lookup as that may link back to diff version , configuration _ root CaMeL Name CaMeL Lookup = src . _ root CaMeL Name CaMeL Lookup ; }
} else if ( String CaMeL Util . in ( name , $STRING$ , $STRING$ , $STRING$ , $STRING$ , $STRING$ , $STRING$ , $STRING$ , $STRING$ , $STRING$ ) ) { <CTX> boolean process ( Token t , Tree CaMeL Builder tb ) { switch ( t . type ) { case Character : { Token . Character c = t . as CaMeL Character ( ) ; if ( c . get CaMeL Data ( ) . equals ( null CaMeL String ) ) { / / todo confirm that check tb . error ( this ) ; return false ; } else if ( is CaMeL Whitespace ( c ) ) { tb . reconstruct CaMeL Formatting CaMeL Elements ( ) ; tb . insert ( c ) ; } else { tb . reconstruct CaMeL Formatting CaMeL Elements ( ) ; tb . insert ( c ) ; tb . frameset CaMeL Ok ( false ) ; } break ; } case Comment : { tb . insert ( t . as CaMeL Comment ( ) ) ; break ; } case Doctype : { tb . error ( this ) ; return false ; } case Start CaMeL Tag : Token . Start CaMeL Tag start CaMeL Tag = t . as CaMeL Start CaMeL Tag ( ) ; String name = start CaMeL Tag . name ( ) ; if ( name . equals ( $STRING$ ) ) { tb . error ( this ) ; / / merge attributes onto real html Element html = tb . get CaMeL Stack ( ) . get CaMeL First ( ) ; for ( Attribute attribute : start CaMeL Tag . get CaMeL Attributes ( ) ) { if ( ! html . has CaMeL Attr ( attribute . get CaMeL Key ( ) ) ) html . attributes ( ) . put ( attribute ) ; } } else if ( String CaMeL Util . in ( name , $STRING$ , $STRING$ , $STRING$ , $STRING$ , $STRING$ , $STRING$ , $STRING$ , $STRING$ , $STRING$ ) ) { return tb . process ( t , In CaMeL Head ) ; } else if ( name . equals ( $STRING$ ) ) { tb . error ( this ) ; Linked CaMeL List < Element > stack = tb . get CaMeL Stack ( ) ; if ( stack . size ( ) == 1 || ( stack . size ( ) > $NUMBER$ && ! stack . get ( 1 ) . node CaMeL Name ( ) . equals ( $STRING$ ) ) ) { / / only in fragment case return false ; / / ignore } else { tb . frameset CaMeL Ok ( false ) ; Element body = stack . get ( 1 ) ; for ( Attribute attribute : start CaMeL Tag . get CaMeL Attributes ( ) ) { if ( ! body . has CaMeL Attr ( attribute . get CaMeL Key ( ) ) ) body . attributes ( ) . put ( attribute ) ; } } } else if ( name . equals ( $STRING$ ) ) { tb . error ( this ) ; Linked CaMeL List < Element > stack = tb . get CaMeL Stack ( ) ; if ( stack . size ( ) == 1 || ( stack . size ( ) > $NUMBER$ && ! stack . get ( 1 ) . node CaMeL Name ( ) . equals ( $STRING$ ) ) ) { / / only in fragment case return false ; / / ignore } else if ( ! tb . frameset CaMeL Ok ( ) ) { return false ; / / ignore frameset } else { Element second = stack . get ( 1 ) ; if ( second . parent ( ) != null ) second . remove ( ) ; / / pop up to html element while ( stack . size ( ) > 1 ) stack . remove CaMeL Last ( ) ; tb . insert ( start CaMeL Tag ) ; tb . transition ( In CaMeL Frameset ) ; } } else if ( String CaMeL Util . in ( name , $STRING$ , $STRING$ , $STRING$ , $STRING$ , $STRING$ , $STRING$ , $STRING$ , $STRING$ , $STRING$ , $STRING$ , $STRING$ , $STRING$ , $STRING$ , $STRING$ , $STRING$ , $STRING$ , $STRING$ , $STRING$ , $STRING$ , $STRING$ , $STRING$ , $STRING$ ) ) { if ( tb . in CaMeL Button CaMeL Scope ( $STRING$ ) ) { tb . process ( new Token . End CaMeL Tag ( $STRING$ ) ) ; } tb . insert ( start CaMeL Tag ) ; } else if ( String CaMeL Util . in ( name , $STRING$ , $STRING$ , $STRING$ , $STRING$ , $STRING$ , $STRING$ ) ) { if ( tb . in CaMeL Button CaMeL Scope ( $STRING$ ) ) { tb . process ( new Token . End CaMeL Tag ( $STRING$ ) ) ; } if ( String CaMeL Util . in ( tb . current CaMeL Element ( ) . node CaMeL Name ( ) , $STRING$ , $STRING$ , $STRING$ , $STRING$ , $STRING$ , $STRING$ ) ) { tb . error ( this ) ; tb . pop ( ) ; } tb . insert ( start CaMeL Tag ) ; } else if ( String CaMeL Util . in ( name , $STRING$ , $STRING$ ) ) { if ( tb . in CaMeL Button CaMeL Scope ( $STRING$ ) ) { tb . process ( new Token . End CaMeL Tag ( $STRING$ ) ) ; } tb . insert ( start CaMeL Tag ) ; / / todo : ignore LF if next token tb . frameset CaMeL Ok ( false ) ; } else if ( name . equals ( $STRING$ ) ) { if ( tb . get CaMeL Form CaMeL Element ( ) != null ) { tb . error ( this ) ; return false ; } if ( tb . in CaMeL Button CaMeL Scope ( $STRING$ ) ) { tb . process ( new Token . End CaMeL Tag ( $STRING$ ) ) ; } Element form = tb . insert ( start CaMeL Tag ) ; tb . set CaMeL Form CaMeL Element ( form ) ; } else if ( name . equals ( $STRING$ ) ) { tb . frameset CaMeL Ok ( false ) ; Linked CaMeL List < Element > stack = tb . get CaMeL Stack ( ) ; for ( int i = stack . size ( ) - 1 ; i > 0 ; i -- ) { Element el = stack . get ( i ) ; if ( el . node CaMeL Name ( ) . equals ( $STRING$ ) ) { tb . process ( new Token . End CaMeL Tag ( $STRING$ ) ) ; break ; } if ( tb . is CaMeL Special ( el ) && ! String CaMeL Util . in ( el . node CaMeL Name ( ) , $STRING$ , $STRING$ , $STRING$ ) ) break ; } if ( tb . in CaMeL Button CaMeL Scope ( $STRING$ ) ) { tb . process ( new Token . End CaMeL Tag ( $STRING$ ) ) ; } tb . insert ( start CaMeL Tag ) ; } else if ( String CaMeL Util . in ( name , $STRING$ , $STRING$ ) ) { tb . frameset CaMeL Ok ( false ) ; Linked CaMeL List < Element > stack = tb . get CaMeL Stack ( ) ; for ( int i = stack . size ( ) - 1 ; i > 0 ; i -- ) { Element el = stack . get ( i ) ; if ( String CaMeL Util . in ( el . node CaMeL Name ( ) , $STRING$ , $STRING$ ) ) { tb . process ( new Token . End CaMeL Tag ( el . node CaMeL Name ( ) ) ) ; break ; } if ( tb . is CaMeL Special ( el ) && ! String CaMeL Util . in ( el . node CaMeL Name ( ) , $STRING$ , $STRING$ , $STRING$ ) ) break ; } if ( tb . in CaMeL Button CaMeL Scope ( $STRING$ ) ) { tb . process ( new Token . End CaMeL Tag ( $STRING$ ) ) ; } tb . insert ( start CaMeL Tag ) ; } else if ( name . equals ( $STRING$ ) ) { if ( tb . in CaMeL Button CaMeL Scope ( $STRING$ ) ) { tb . process ( new Token . End CaMeL Tag ( $STRING$ ) ) ; } tb . insert ( start CaMeL Tag ) ; tb . tokeniser . transition ( Tokeniser CaMeL State . PLAINTEXT ) ; / / once in , never gets out } else if ( name . equals ( $STRING$ ) ) { if ( tb . in CaMeL Button CaMeL Scope ( $STRING$ ) ) { / / close and reprocess tb . error ( this ) ; tb . process ( new Token . End CaMeL Tag ( $STRING$ ) ) ; tb . process ( start CaMeL Tag ) ; } else { tb . reconstruct CaMeL Formatting CaMeL Elements ( ) ; tb . insert ( start CaMeL Tag ) ; tb . frameset CaMeL Ok ( false ) ; } } else if ( name . equals ( $STRING$ ) ) { if ( tb . get CaMeL Active CaMeL Formatting CaMeL Element ( $STRING$ ) != null ) { tb . error ( this ) ; tb . process ( new Token . End CaMeL Tag ( $STRING$ ) ) ; / / still on stack ? Element remaining CaMeL A = tb . get CaMeL From CaMeL Stack ( $STRING$ ) ; if ( remaining CaMeL A != null ) { tb . remove CaMeL From CaMeL Active CaMeL Formatting CaMeL Elements ( remaining CaMeL A ) ; tb . remove CaMeL From CaMeL Stack ( remaining CaMeL A ) ; } } tb . reconstruct CaMeL Formatting CaMeL Elements ( ) ; Element a = tb . insert ( start CaMeL Tag ) ; tb . push CaMeL Active CaMeL Formatting CaMeL Elements ( a ) ; } else if ( String CaMeL Util . in ( name , $STRING$ , $STRING$ , $STRING$ , $STRING$ , $STRING$ , $STRING$ , $STRING$ , $STRING$ , $STRING$ , $STRING$ , $STRING$ , $STRING$ ) ) { tb . reconstruct CaMeL Formatting CaMeL Elements ( ) ; Element el = tb . insert ( start CaMeL Tag ) ; tb . push CaMeL Active CaMeL Formatting CaMeL Elements ( el ) ; } else if ( name . equals ( $STRING$ ) ) { tb . reconstruct CaMeL Formatting CaMeL Elements ( ) ; if ( tb . in CaMeL Scope ( $STRING$ ) ) { tb . error ( this ) ; tb . process ( new Token . End CaMeL Tag ( $STRING$ ) ) ; tb . reconstruct CaMeL Formatting CaMeL Elements ( ) ; } Element el = tb . insert ( start CaMeL Tag ) ; tb . push CaMeL Active CaMeL Formatting CaMeL Elements ( el ) ; } else if ( String CaMeL Util . in ( name , $STRING$ , $STRING$ , $STRING$ ) ) { tb . reconstruct CaMeL Formatting CaMeL Elements ( ) ; tb . insert ( start CaMeL Tag ) ; tb . insert CaMeL Marker CaMeL To CaMeL Formatting CaMeL Elements ( ) ; tb . frameset CaMeL Ok ( false ) ; } else if ( name . equals ( $STRING$ ) ) { if ( tb . get CaMeL Document ( ) . quirks CaMeL Mode ( ) != Document . Quirks CaMeL Mode . quirks && tb . in CaMeL Button CaMeL Scope ( $STRING$ ) ) { tb . process ( new Token . End CaMeL Tag ( $STRING$ ) ) ; } tb . insert ( start CaMeL Tag ) ; tb . frameset CaMeL Ok ( false ) ; tb . transition ( In CaMeL Table ) ; } else if ( String CaMeL Util . in ( name , $STRING$ , $STRING$ , $STRING$ , $STRING$ , $STRING$ , $STRING$ ) ) { tb . reconstruct CaMeL Formatting CaMeL Elements ( ) ; tb . insert CaMeL Empty ( start CaMeL Tag ) ; tb . frameset CaMeL Ok ( false ) ; } else if ( name . equals ( $STRING$ ) ) { tb . reconstruct CaMeL Formatting CaMeL Elements ( ) ; Element el = tb . insert CaMeL Empty ( start CaMeL Tag ) ; if ( ! el . attr ( $STRING$ ) . equals CaMeL Ignore CaMeL Case ( $STRING$ ) ) tb . frameset CaMeL Ok ( false ) ; } else if ( String CaMeL Util . in ( name , $STRING$ , $STRING$ , $STRING$ ) ) { tb . insert CaMeL Empty ( start CaMeL Tag ) ; } else if ( name . equals ( $STRING$ ) ) { if ( tb . in CaMeL Button CaMeL Scope ( $STRING$ ) ) { tb . process ( new Token . End CaMeL Tag ( $STRING$ ) ) ; } tb . insert CaMeL Empty ( start CaMeL Tag ) ; tb . frameset CaMeL Ok ( false ) ; } else if ( name . equals ( $STRING$ ) ) { / / we re not supposed to ask . start CaMeL Tag . name ( $STRING$ ) ; return tb . process ( start CaMeL Tag ) ; } else if ( name . equals ( $STRING$ ) ) { / / how much do we care about the early $NUMBER$ s ? tb . error ( this ) ; if ( tb . get CaMeL Form CaMeL Element ( ) != null ) return false ; tb . tokeniser . acknowledge CaMeL Self CaMeL Closing CaMeL Flag ( ) ; tb . process ( new Token . Start CaMeL Tag ( $STRING$ ) ) ; if ( start CaMeL Tag . attributes . has CaMeL Key ( $STRING$ ) ) { Element form = tb . get CaMeL Form CaMeL Element ( ) ; form . attr ( $STRING$ , start CaMeL Tag . attributes . get ( $STRING$ ) ) ; } tb . process ( new Token . Start CaMeL Tag ( $STRING$ ) ) ; tb . process ( new Token . Start CaMeL Tag ( $STRING$ ) ) ; / / hope you like english . String prompt = start CaMeL Tag . attributes . has CaMeL Key ( $STRING$ ) ? start CaMeL Tag . attributes . get ( $STRING$ ) : $STRING$ ; tb . process ( new Token . Character ( prompt ) ) ; / / input Attributes input CaMeL Attribs = new Attributes ( ) ; for ( Attribute attr : start CaMeL Tag . attributes ) { if ( ! String CaMeL Util . in ( attr . get CaMeL Key ( ) , $STRING$ , $STRING$ , $STRING$ ) ) input CaMeL Attribs . put ( attr ) ; } input CaMeL Attribs . put ( $STRING$ , $STRING$ ) ; tb . process ( new Token . Start CaMeL Tag ( $STRING$ , input CaMeL Attribs ) ) ; tb . process ( new Token . End CaMeL Tag ( $STRING$ ) ) ; tb . process ( new Token . Start CaMeL Tag ( $STRING$ ) ) ; tb . process ( new Token . End CaMeL Tag ( $STRING$ ) ) ; } else if ( name . equals ( $STRING$ ) ) { tb . insert ( start CaMeL Tag ) ; / / todo : If the next token is a U + 000 A LINE FEED ( LF ) character token , then ignore that token and move on to the next one . ( Newlines at the start of textarea elements are ignored as an authoring convenience . ) tb . tokeniser . transition ( Tokeniser CaMeL State . Rcdata ) ; tb . mark CaMeL Insertion CaMeL Mode ( ) ; tb . frameset CaMeL Ok ( false ) ; tb . transition ( Text ) ; } else if ( name . equals ( $STRING$ ) ) { if ( tb . in CaMeL Button CaMeL Scope ( $STRING$ ) ) { tb . process ( new Token . End CaMeL Tag ( $STRING$ ) ) ; } tb . reconstruct CaMeL Formatting CaMeL Elements ( ) ; tb . frameset CaMeL Ok ( false ) ; handle CaMeL Rawtext ( start CaMeL Tag , tb ) ; } else if ( name . equals ( $STRING$ ) ) { tb . frameset CaMeL Ok ( false ) ; handle CaMeL Rawtext ( start CaMeL Tag , tb ) ; } else if ( name . equals ( $STRING$ ) ) { / / also handle noscript if script enabled handle CaMeL Rawtext ( start CaMeL Tag , tb ) ; } else if ( name . equals ( $STRING$ ) ) { tb . reconstruct CaMeL Formatting CaMeL Elements ( ) ; tb . insert ( start CaMeL Tag ) ; tb . frameset CaMeL Ok ( false ) ; Tree CaMeL Builder CaMeL State state = tb . state ( ) ; if ( state . equals ( In CaMeL Table ) || state . equals ( In CaMeL Caption ) || state . equals ( In CaMeL Table CaMeL Body ) || state . equals ( In CaMeL Row ) || state . equals ( In CaMeL Cell ) ) tb . transition ( In CaMeL Select CaMeL In CaMeL Table ) ; else tb . transition ( In CaMeL Select ) ; } else if ( String CaMeL Util . in ( $STRING$ , $STRING$ ) ) { if ( tb . current CaMeL Element ( ) . node CaMeL Name ( ) . equals ( $STRING$ ) ) tb . process ( new Token . End CaMeL Tag ( $STRING$ ) ) ; tb . reconstruct CaMeL Formatting CaMeL Elements ( ) ; tb . insert ( start CaMeL Tag ) ; } else if ( String CaMeL Util . in ( $STRING$ , $STRING$ ) ) { if ( tb . in CaMeL Scope ( $STRING$ ) ) { tb . generate CaMeL Implied CaMeL End CaMeL Tags ( ) ; if ( ! tb . current CaMeL Element ( ) . node CaMeL Name ( ) . equals ( $STRING$ ) ) { tb . error ( this ) ; tb . pop CaMeL Stack CaMeL To CaMeL Before ( $STRING$ ) ; / / i . e . close up to but not include name } tb . insert ( start CaMeL Tag ) ; } } else if ( name . equals ( $STRING$ ) ) { tb . reconstruct CaMeL Formatting CaMeL Elements ( ) ; / / todo : handle A start tag whose tag name is $STRING$ ( i . e . foreign , mathml ) tb . insert ( start CaMeL Tag ) ; tb . tokeniser . acknowledge CaMeL Self CaMeL Closing CaMeL Flag ( ) ; } else if ( name . equals ( $STRING$ ) ) { tb . reconstruct CaMeL Formatting CaMeL Elements ( ) ; / / todo : handle A start tag whose tag name is $STRING$ ( xlink , svg ) tb . insert ( start CaMeL Tag ) ; tb . tokeniser . acknowledge CaMeL Self CaMeL Closing CaMeL Flag ( ) ; } else if ( String CaMeL Util . in ( name , $STRING$ , $STRING$ , $STRING$ , $STRING$ , $STRING$ , $STRING$ , $STRING$ , $STRING$ , $STRING$ , $STRING$ , $STRING$ ) ) { tb . error ( this ) ; return false ; } else { tb . reconstruct CaMeL Formatting CaMeL Elements ( ) ; tb . insert ( start CaMeL Tag ) ; } break ; case End CaMeL Tag : Token . End CaMeL Tag end CaMeL Tag = t . as CaMeL End CaMeL Tag ( ) ; name = end CaMeL Tag . name ( ) ; if ( name . equals ( $STRING$ ) ) { if ( ! tb . in CaMeL Scope ( $STRING$ ) ) { tb . error ( this ) ; return false ; } else { / / todo : error if stack contains something not dd , dt , li , optgroup , option , p , rp , rt , tbody , td , tfoot , th , thead , tr , body , html tb . transition ( After CaMeL Body ) ; } } else if ( name . equals ( $STRING$ ) ) { boolean not CaMeL Ignored = tb . process ( new Token . End CaMeL Tag ( $STRING$ ) ) ; if ( not CaMeL Ignored ) return tb . process ( end CaMeL Tag ) ; } else if ( String CaMeL Util . in ( name , $STRING$ , $STRING$ , $STRING$ , $STRING$ , $STRING$ , $STRING$ , $STRING$ , $STRING$ , $STRING$ , $STRING$ , $STRING$ , $STRING$ , $STRING$ , $STRING$ , $STRING$ , $STRING$ , $STRING$ , $STRING$ , $STRING$ , $STRING$ , $STRING$ , $STRING$ , $STRING$ , $STRING$ ) ) { / / todo : refactor these lookups if ( ! tb . in CaMeL Scope ( name ) ) { / / nothing to close tb . error ( this ) ; return false ; } else { tb . generate CaMeL Implied CaMeL End CaMeL Tags ( ) ; if ( ! tb . current CaMeL Element ( ) . node CaMeL Name ( ) . equals ( name ) ) tb . error ( this ) ; tb . pop CaMeL Stack CaMeL To CaMeL Close ( name ) ; } } else if ( name . equals ( $STRING$ ) ) { Element current CaMeL Form = tb . get CaMeL Form CaMeL Element ( ) ; tb . set CaMeL Form CaMeL Element ( null ) ; if ( current CaMeL Form == null || ! tb . in CaMeL Scope ( name ) ) { tb . error ( this ) ; return false ; } else { tb . generate CaMeL Implied CaMeL End CaMeL Tags ( ) ; if ( ! tb . current CaMeL Element ( ) . node CaMeL Name ( ) . equals ( name ) ) tb . error ( this ) ; / / remove current CaMeL Form from stack . will shift anything under up . tb . remove CaMeL From CaMeL Stack ( current CaMeL Form ) ; } } else if ( name . equals ( $STRING$ ) ) { if ( ! tb . in CaMeL Button CaMeL Scope ( name ) ) { tb . error ( this ) ; tb . process ( new Token . Start CaMeL Tag ( name ) ) ; / / if no p to close , creates an empty < p > < / p > return tb . process ( end CaMeL Tag ) ; } else { tb . generate CaMeL Implied CaMeL End CaMeL Tags ( name ) ; if ( ! tb . current CaMeL Element ( ) . node CaMeL Name ( ) . equals ( name ) ) tb . error ( this ) ; tb . pop CaMeL Stack CaMeL To CaMeL Close ( name ) ; } } else if ( name . equals ( $STRING$ ) ) { if ( ! tb . in CaMeL List CaMeL Item CaMeL Scope ( name ) ) { tb . error ( this ) ; return false ; } else { tb . generate CaMeL Implied CaMeL End CaMeL Tags ( name ) ; if ( ! tb . current CaMeL Element ( ) . node CaMeL Name ( ) . equals ( name ) ) tb . error ( this ) ; tb . pop CaMeL Stack CaMeL To CaMeL Close ( name ) ; } } else if ( String CaMeL Util . in ( name , $STRING$ , $STRING$ ) ) { if ( ! tb . in CaMeL Scope ( name ) ) { tb . error ( this ) ; return false ; } else { tb . generate CaMeL Implied CaMeL End CaMeL Tags ( name ) ; if ( ! tb . current CaMeL Element ( ) . node CaMeL Name ( ) . equals ( name ) ) tb . error ( this ) ; tb . pop CaMeL Stack CaMeL To CaMeL Close ( name ) ; } } else if ( String CaMeL Util . in ( name , $STRING$ , $STRING$ , $STRING$ , $STRING$ , $STRING$ , $STRING$ ) ) { if ( ! tb . in CaMeL Scope ( new String [ ] { $STRING$ , $STRING$ , $STRING$ , $STRING$ , $STRING$ , $STRING$ } ) ) { tb . error ( this ) ; return false ; } else { tb . generate CaMeL Implied CaMeL End CaMeL Tags ( name ) ; if ( ! tb . current CaMeL Element ( ) . node CaMeL Name ( ) . equals ( name ) ) tb . error ( this ) ; tb . pop CaMeL Stack CaMeL To CaMeL Close ( $STRING$ , $STRING$ , $STRING$ , $STRING$ , $STRING$ , $STRING$ ) ; } } else if ( name . equals ( $STRING$ ) ) { / / * sigh * return any CaMeL Other CaMeL End CaMeL Tag ( t , tb ) ; } else if ( String CaMeL Util . in ( name , $STRING$ , $STRING$ , $STRING$ , $STRING$ , $STRING$ , $STRING$ , $STRING$ , $STRING$ , $STRING$ , $STRING$ , $STRING$ , $STRING$ , $STRING$ , $STRING$ ) ) { / / Adoption Agency Algorithm . OUTER : for ( int i = 0 ; i < 8 ; i ++ ) { Element format CaMeL El = tb . get CaMeL Active CaMeL Formatting CaMeL Element ( name ) ; if ( format CaMeL El == null ) return any CaMeL Other CaMeL End CaMeL Tag ( t , tb ) ; else if ( ! tb . on CaMeL Stack ( format CaMeL El ) ) { tb . error ( this ) ; tb . remove CaMeL From CaMeL Active CaMeL Formatting CaMeL Elements ( format CaMeL El ) ; return true ; } else if ( ! tb . in CaMeL Scope ( format CaMeL El . node CaMeL Name ( ) ) ) { tb . error ( this ) ; return false ; } else if ( tb . current CaMeL Element ( ) != format CaMeL El ) tb . error ( this ) ; Element furthest CaMeL Block = null ; Element common CaMeL Ancestor = null ; boolean seen CaMeL Formatting CaMeL Element = false ; Linked CaMeL List < Element > stack = tb . get CaMeL Stack ( ) ; for ( int si = 0 ; si < stack . size ( ) ; si ++ ) { Element el = stack . get ( si ) ; if ( el == format CaMeL El ) { common CaMeL Ancestor = stack . get ( si - 1 ) ; seen CaMeL Formatting CaMeL Element = true ; } else if ( seen CaMeL Formatting CaMeL Element && tb . is CaMeL Special ( el ) ) { furthest CaMeL Block = el ; break ; } } if ( furthest CaMeL Block == null ) { tb . pop CaMeL Stack CaMeL To CaMeL Close ( format CaMeL El . node CaMeL Name ( ) ) ; tb . remove CaMeL From CaMeL Active CaMeL Formatting CaMeL Elements ( format CaMeL El ) ; return true ; } / / todo : Let a bookmark note the position of the formatting element in the list of active formatting elements relative to the elements on either side of it in the list . / / does that mean : int pos of format el in list ? Element node = furthest CaMeL Block ; Element last CaMeL Node = furthest CaMeL Block ; INNER : for ( int j = 0 ; j < $NUMBER$ ; j ++ ) { if ( tb . on CaMeL Stack ( node ) ) node = tb . above CaMeL On CaMeL Stack ( node ) ; if ( ! tb . is CaMeL In CaMeL Active CaMeL Formatting CaMeL Elements ( node ) ) { / / note no bookmark check tb . remove CaMeL From CaMeL Stack ( node ) ; continue INNER ; } else if ( node == format CaMeL El ) break INNER ; Element replacement = new Element ( Tag . value CaMeL Of ( node . node CaMeL Name ( ) ) , tb . get CaMeL Base CaMeL Uri ( ) ) ; tb . replace CaMeL Active CaMeL Formatting CaMeL Element ( node , replacement ) ; tb . replace CaMeL On CaMeL Stack ( node , replacement ) ; node = replacement ; if ( last CaMeL Node == furthest CaMeL Block ) { / / todo : move the aforementioned bookmark to be immediately after the new node in the list of active formatting elements . / / not getting how this bookmark both straddles the element above , but is inbetween here . . . } if ( last CaMeL Node . parent ( ) != null ) last CaMeL Node . remove ( ) ; node . append CaMeL Child ( last CaMeL Node ) ; last CaMeL Node = node ; } if ( String CaMeL Util . in ( common CaMeL Ancestor . node CaMeL Name ( ) , $STRING$ , $STRING$ , $STRING$ , $STRING$ , $STRING$ ) ) { if ( last CaMeL Node . parent ( ) != null ) last CaMeL Node . remove ( ) ; tb . insert CaMeL In CaMeL Foster CaMeL Parent ( last CaMeL Node ) ; } else { if ( last CaMeL Node . parent ( ) != null ) last CaMeL Node . remove ( ) ; common CaMeL Ancestor . append CaMeL Child ( last CaMeL Node ) ; } Element adopter = new Element ( Tag . value CaMeL Of ( name ) , tb . get CaMeL Base CaMeL Uri ( ) ) ; Node [ ] child CaMeL Nodes = furthest CaMeL Block . child CaMeL Nodes ( ) . to CaMeL Array ( new Node [ furthest CaMeL Block . child CaMeL Nodes ( ) . size ( ) ] ) ; for ( Node child CaMeL Node : child CaMeL Nodes ) { adopter . append CaMeL Child ( child CaMeL Node ) ; / / append will reparent . thus the clone to avvoid concurrent mod . } furthest CaMeL Block . append CaMeL Child ( adopter ) ; tb . remove CaMeL From CaMeL Active CaMeL Formatting CaMeL Elements ( format CaMeL El ) ; / / todo : insert the new element into the list of active formatting elements at the position of the aforementioned bookmark . tb . remove CaMeL From CaMeL Stack ( format CaMeL El ) ; tb . insert CaMeL On CaMeL Stack CaMeL After ( furthest CaMeL Block , adopter ) ; } } else if ( String CaMeL Util . in ( name , $STRING$ , $STRING$ , $STRING$ ) ) { if ( ! tb . in CaMeL Scope ( $STRING$ ) ) { if ( ! tb . in CaMeL Scope ( name ) ) { tb . error ( this ) ; return false ; } tb . generate CaMeL Implied CaMeL End CaMeL Tags ( ) ; if ( ! tb . current CaMeL Element ( ) . node CaMeL Name ( ) . equals ( name ) ) tb . error ( this ) ; tb . pop CaMeL Stack CaMeL To CaMeL Close ( name ) ; tb . clear CaMeL Formatting CaMeL Elements CaMeL To CaMeL Last CaMeL Marker ( ) ; } } else if ( name . equals ( $STRING$ ) ) { tb . error ( this ) ; tb . process ( new Token . Start CaMeL Tag ( $STRING$ ) ) ; return false ; } else { return any CaMeL Other CaMeL End CaMeL Tag ( t , tb ) ; } break ; case EOF : / / todo : error if stack contains something not dd , dt , li , p , tbody , td , tfoot , th , thead , tr , body , html / / stop parsing break ; } return true ; }
clone . class CaMeL Names ( ) ; <CTX> public Element clone ( ) { Element clone = ( Element ) super . clone ( ) ; clone . class CaMeL Names ( ) ; return clone ; }
if ( offset < length ) { <CTX> int next CaMeL Index CaMeL Of ( Char CaMeL Sequence seq ) { / / doesn t handle scanning for surrogates char start CaMeL Char = seq . char CaMeL At ( 0 ) ; for ( int offset = pos ; offset < length ; offset ++ ) { / / scan to first instance of startchar : if ( start CaMeL Char != input [ offset ] ) while ( ++ offset < length && start CaMeL Char != input [ offset ] ) ; int i = offset + 1 ; int last = i + seq . length ( ) - 1 ; if ( offset < length ) { for ( int j = 1 ; i < last && seq . char CaMeL At ( j ) == input [ i ] ; i ++ , j ++ ) ; if ( i == last ) / / found full sequence return offset - pos ; } } return - 1 ; }
return accum . to CaMeL String ( ) . trim ( ) ; <CTX> public String html ( ) { String CaMeL Builder accum = new String CaMeL Builder ( ) ; html ( accum ) ; return accum . to CaMeL String ( ) . trim ( ) ; }
return this == o ; <CTX> public boolean equals ( Object o ) { if ( this == o ) return true ; if ( o == null || get CaMeL Class ( ) != o . get CaMeL Class ( ) ) return false ; if ( ! super . equals ( o ) ) return false ; Element element = ( Element ) o ; return this == o ; }
if ( element . equals ( search ) ) <CTX> private static < E extends Element > Integer index CaMeL In CaMeL List ( Element search , List < E > elements ) { Validate . not CaMeL Null ( search ) ; Validate . not CaMeL Null ( elements ) ; for ( int i = 0 ; i < elements . size ( ) ; i ++ ) { E element = elements . get ( i ) ; if ( element . equals ( search ) ) return i ; } return null ; }
} else if ( ( $STRING$ . equals ( name ) || $STRING$ . equals ( name ) && ! last ) ) { <CTX> void reset CaMeL Insertion CaMeL Mode ( ) { boolean last = false ; for ( int pos = stack . size ( ) - 1 ; pos >= 0 ; pos -- ) { Element node = stack . get ( pos ) ; if ( pos == 0 ) { last = true ; node = context CaMeL Element ; } String name = node . node CaMeL Name ( ) ; if ( $STRING$ . equals ( name ) ) { transition ( Html CaMeL Tree CaMeL Builder CaMeL State . In CaMeL Select ) ; break ; / / frag } else if ( ( $STRING$ . equals ( name ) || $STRING$ . equals ( name ) && ! last ) ) { transition ( Html CaMeL Tree CaMeL Builder CaMeL State . In CaMeL Cell ) ; break ; } else if ( $STRING$ . equals ( name ) ) { transition ( Html CaMeL Tree CaMeL Builder CaMeL State . In CaMeL Row ) ; break ; } else if ( $STRING$ . equals ( name ) || $STRING$ . equals ( name ) || $STRING$ . equals ( name ) ) { transition ( Html CaMeL Tree CaMeL Builder CaMeL State . In CaMeL Table CaMeL Body ) ; break ; } else if ( $STRING$ . equals ( name ) ) { transition ( Html CaMeL Tree CaMeL Builder CaMeL State . In CaMeL Caption ) ; break ; } else if ( $STRING$ . equals ( name ) ) { transition ( Html CaMeL Tree CaMeL Builder CaMeL State . In CaMeL Column CaMeL Group ) ; break ; / / frag } else if ( $STRING$ . equals ( name ) ) { transition ( Html CaMeL Tree CaMeL Builder CaMeL State . In CaMeL Table ) ; break ; } else if ( $STRING$ . equals ( name ) ) { transition ( Html CaMeL Tree CaMeL Builder CaMeL State . In CaMeL Body ) ; break ; / / frag } else if ( $STRING$ . equals ( name ) ) { transition ( Html CaMeL Tree CaMeL Builder CaMeL State . In CaMeL Body ) ; break ; } else if ( $STRING$ . equals ( name ) ) { transition ( Html CaMeL Tree CaMeL Builder CaMeL State . In CaMeL Frameset ) ; break ; / / frag } else if ( $STRING$ . equals ( name ) ) { transition ( Html CaMeL Tree CaMeL Builder CaMeL State . Before CaMeL Head ) ; break ; / / frag } else if ( last ) { transition ( Html CaMeL Tree CaMeL Builder CaMeL State . In CaMeL Body ) ; break ; / / frag } } }
accum . append ( c ) ; <CTX> static void escape ( String CaMeL Builder accum , String string , Document . Output CaMeL Settings out , boolean in CaMeL Attribute , boolean normalise CaMeL White , boolean strip CaMeL Leading CaMeL White ) { boolean last CaMeL Was CaMeL White = false ; boolean reached CaMeL Non CaMeL White = false ; final Escape CaMeL Mode escape CaMeL Mode = out . escape CaMeL Mode ( ) ; final Charset CaMeL Encoder encoder = out . encoder ( ) ; final Core CaMeL Charset core CaMeL Charset = Core CaMeL Charset . by CaMeL Name ( encoder . charset ( ) . name ( ) ) ; final Map < Character , String > map = escape CaMeL Mode . get CaMeL Map ( ) ; final int length = string . length ( ) ; int code CaMeL Point ; for ( int offset = 0 ; offset < length ; offset += Character . char CaMeL Count ( code CaMeL Point ) ) { code CaMeL Point = string . code CaMeL Point CaMeL At ( offset ) ; if ( normalise CaMeL White ) { if ( String CaMeL Util . is CaMeL Whitespace ( code CaMeL Point ) ) { if ( ( strip CaMeL Leading CaMeL White && ! reached CaMeL Non CaMeL White ) || last CaMeL Was CaMeL White ) continue ; accum . append ( $STRING$ ) ; last CaMeL Was CaMeL White = true ; continue ; } else { last CaMeL Was CaMeL White = false ; reached CaMeL Non CaMeL White = true ; } } / / surrogate pairs , split implementation for efficiency on single char common case ( saves creating strings , char [ ] ) : if ( code CaMeL Point < Character . MIN _ SUPPLEMENTARY _ CODE _ POINT ) { final char c = ( char ) code CaMeL Point ; / / html specific and required escapes : switch ( c ) { case $STRING$ : accum . append ( $STRING$ ) ; break ; case 0 x CaMeL A 0 : if ( escape CaMeL Mode != Escape CaMeL Mode . xhtml ) accum . append ( $STRING$ ) ; else accum . append ( c ) ; break ; case $STRING$ : if ( ! in CaMeL Attribute ) accum . append ( $STRING$ ) ; else accum . append ( c ) ; break ; case $STRING$ : if ( ! in CaMeL Attribute ) accum . append ( $STRING$ ) ; else accum . append ( c ) ; break ; case $STRING$ ; ) ; } } }
if ( ! in CaMeL Attribute ) <CTX> static void escape ( String CaMeL Builder accum , String string , Document . Output CaMeL Settings out , boolean in CaMeL Attribute , boolean normalise CaMeL White , boolean strip CaMeL Leading CaMeL White ) { boolean last CaMeL Was CaMeL White = false ; boolean reached CaMeL Non CaMeL White = false ; final Escape CaMeL Mode escape CaMeL Mode = out . escape CaMeL Mode ( ) ; final Charset CaMeL Encoder encoder = out . encoder ( ) ; final Core CaMeL Charset core CaMeL Charset = Core CaMeL Charset . by CaMeL Name ( encoder . charset ( ) . name ( ) ) ; final Map < Character , String > map = escape CaMeL Mode . get CaMeL Map ( ) ; final int length = string . length ( ) ; int code CaMeL Point ; for ( int offset = 0 ; offset < length ; offset += Character . char CaMeL Count ( code CaMeL Point ) ) { code CaMeL Point = string . code CaMeL Point CaMeL At ( offset ) ; if ( normalise CaMeL White ) { if ( String CaMeL Util . is CaMeL Whitespace ( code CaMeL Point ) ) { if ( ( strip CaMeL Leading CaMeL White && ! reached CaMeL Non CaMeL White ) || last CaMeL Was CaMeL White ) continue ; accum . append ( $STRING$ ) ; last CaMeL Was CaMeL White = true ; continue ; } else { last CaMeL Was CaMeL White = false ; reached CaMeL Non CaMeL White = true ; } } / / surrogate pairs , split implementation for efficiency on single char common case ( saves creating strings , char [ ] ) : if ( code CaMeL Point < Character . MIN _ SUPPLEMENTARY _ CODE _ POINT ) { final char c = ( char ) code CaMeL Point ; / / html specific and required escapes : switch ( c ) { case $STRING$ : accum . append ( $STRING$ ) ; break ; case 0 x CaMeL A 0 : if ( escape CaMeL Mode != Escape CaMeL Mode . xhtml ) accum . append ( $STRING$ ) ; else accum . append ( $STRING$ ) ; break ; case $STRING$ : / / escape when in character data or when in a xml attribue val ; not needed in html attr val if ( ! in CaMeL Attribute ) accum . append ( $STRING$ ) ; else accum . append ( c ) ; break ; case $STRING$ : if ( ! in CaMeL Attribute ) accum . append ( $STRING$ ) ; else accum . append ( c ) ; break ; case $STRING$ ; ) ; } } }
} <CTX> protected void add CaMeL Children ( int index , Node . . . children ) { Validate . no CaMeL Null CaMeL Elements ( children ) ; ensure CaMeL Child CaMeL Nodes ( ) ; for ( int i = children . length - 1 ; i >= 0 ; i -- ) { Node in = children [ i ] ; reparent CaMeL Child ( in ) ; child CaMeL Nodes . add ( index , in ) ; } reindex CaMeL Children ( index ) ; }
return ( c >= $STRING$ && c <= $STRING$ ) || ( c >= $STRING$ && c <= $STRING$ ) ; <CTX> boolean matches CaMeL Letter ( ) { if ( is CaMeL Empty ( ) ) return false ; char c = input [ pos ] ; return ( c >= $STRING$ && c <= $STRING$ ) || ( c >= $STRING$ && c <= $STRING$ ) ; }
attributes . remove ( attr CaMeL Key ) ; <CTX> public void remove CaMeL Ignore CaMeL Case ( String key ) { Validate . not CaMeL Empty ( key ) ; if ( attributes == null ) return ; for ( Iterator < String > it = attributes . key CaMeL Set ( ) . iterator ( ) ; it . has CaMeL Next ( ) ; ) { String attr CaMeL Key = it . next ( ) ; if ( attr CaMeL Key . equals CaMeL Ignore CaMeL Case ( key ) ) attributes . remove ( attr CaMeL Key ) ; } }
final String class CaMeL Attr = attributes . get ( $STRING$ ) ; <CTX> public boolean has CaMeL Class ( String class CaMeL Name ) { final String class CaMeL Attr = attributes . get ( $STRING$ ) ; final int len = class CaMeL Attr . length ( ) ; final int want CaMeL Len = class CaMeL Name . length ( ) ; if ( len == 0 || len < want CaMeL Len ) { return false ; } / / if both lengths are equal , only need compare the class CaMeL Name with the attribute if ( len == want CaMeL Len ) { return class CaMeL Name . equals CaMeL Ignore CaMeL Case ( class CaMeL Attr ) ; } / / otherwise , scan for whitespace and compare regions ( with no string or arraylist allocations ) boolean in CaMeL Class = false ; int start = 0 ; for ( int i = 0 ; i < len ; i ++ ) { if ( Character . is CaMeL Whitespace ( class CaMeL Attr . char CaMeL At ( i ) ) ) { if ( in CaMeL Class ) { / / white space ends a class name , compare it with the requested one , ignore case if ( i - start == want CaMeL Len && class CaMeL Attr . region CaMeL Matches ( true , start , class CaMeL Name , 0 , want CaMeL Len ) ) { return true ; } in CaMeL Class = false ; } } else { if ( ! in CaMeL Class ) { / / we re in a class name : keep the start of the substring in CaMeL Class = true ; start = i ; } } } / / check the last entry if ( in CaMeL Class && len - start == want CaMeL Len ) { return class CaMeL Attr . region CaMeL Matches ( true , start , class CaMeL Name , 0 , want CaMeL Len ) ; } return false ; }
String name = t . as CaMeL End CaMeL Tag ( ) . normal CaMeL Name ( ) ; <CTX> boolean any CaMeL Other CaMeL End CaMeL Tag ( Token t , Html CaMeL Tree CaMeL Builder tb ) { String name = t . as CaMeL End CaMeL Tag ( ) . normal CaMeL Name ( ) ; Array CaMeL List < Element > stack = tb . get CaMeL Stack ( ) ; for ( int pos = stack . size ( ) - 1 ; pos >= 0 ; pos -- ) { Element node = stack . get ( pos ) ; if ( node . node CaMeL Name ( ) . equals ( name ) ) { tb . generate CaMeL Implied CaMeL End CaMeL Tags ( name ) ; if ( ! name . equals ( tb . current CaMeL Element ( ) . node CaMeL Name ( ) ) ) tb . error ( this ) ; tb . pop CaMeL Stack CaMeL To CaMeL Close ( name ) ; break ; } else { if ( tb . is CaMeL Special ( node ) ) { tb . error ( this ) ; return false ; } } } return true ; }
tb . insert ( start CaMeL Tag ) ; <CTX> private static void handle CaMeL Rawtext ( Token . Start CaMeL Tag start CaMeL Tag , Html CaMeL Tree CaMeL Builder tb ) { tb . insert ( start CaMeL Tag ) ; tb . tokeniser . transition ( Tokeniser CaMeL State . Rawtext ) ; tb . mark CaMeL Insertion CaMeL Mode ( ) ; tb . transition ( Text ) ; }
String el CaMeL Name = end CaMeL Tag . name ( ) ; <CTX> private void pop CaMeL Stack CaMeL To CaMeL Close ( Token . End CaMeL Tag end CaMeL Tag ) { String el CaMeL Name = end CaMeL Tag . name ( ) ; Element first CaMeL Found = null ; for ( int pos = stack . size ( ) - 1 ; pos >= 0 ; pos -- ) { Element next = stack . get ( pos ) ; if ( next . node CaMeL Name ( ) . equals ( el CaMeL Name ) ) { first CaMeL Found = next ; break ; } } if ( first CaMeL Found == null ) return ; / / not found , skip for ( int pos = stack . size ( ) - 1 ; pos >= 0 ; pos -- ) { Element next = stack . get ( pos ) ; stack . remove ( pos ) ; if ( next == first CaMeL Found ) break ; } }
if ( doc . child CaMeL Node CaMeL Size ( ) > 0 ) { <CTX> public Xml CaMeL Declaration as CaMeL Xml CaMeL Declaration ( ) { String data = get CaMeL Data ( ) ; Document doc = Jsoup . parse ( $STRING$ + data . substring ( 1 , data . length ( ) - 1 ) + $STRING$ , base CaMeL Uri ( ) , Parser . xml CaMeL Parser ( ) ) ; Xml CaMeL Declaration decl = null ; if ( doc . child CaMeL Node CaMeL Size ( ) > 0 ) { Element el = doc . child ( 0 ) ; decl = new Xml CaMeL Declaration ( Node CaMeL Utils . parser ( doc ) . settings ( ) . normalize CaMeL Tag ( el . tag CaMeL Name ( ) ) , data . starts CaMeL With ( $STRING$ ) ) ; decl . attributes ( ) . add CaMeL All ( el . attributes ( ) ) ; } return decl ; }
return val ; <CTX> public String get CaMeL Value ( ) { return val ; }
return compute ( args [ 0 ] . compute CaMeL Value ( context ) , args [ 1 ] . compute CaMeL Value ( context ) ) <CTX> public final Object compute CaMeL Value ( Eval CaMeL Context context ) { return compute ( args [ 0 ] . compute CaMeL Value ( context ) , args [ 1 ] . compute CaMeL Value ( context ) ) ? Boolean . TRUE : Boolean . FALSE ; }
if ( str . starts CaMeL With ( $STRING$ ) || str . starts CaMeL With ( $STRING$ ) ) { <CTX> public static Number create CaMeL Number ( String str ) throws Number CaMeL Format CaMeL Exception { if ( str == null ) { return null ; } if ( String CaMeL Utils . is CaMeL Blank ( str ) ) { throw new Number CaMeL Format CaMeL Exception ( $STRING$ ) ; } if ( str . starts CaMeL With ( $STRING$ ) ) { / / this is protection for poorness in java . lang . Big CaMeL Decimal . / / it accepts this as a legal value , but it does not appear / / to be in specification of class . OS X Java parses it to / / a wrong value . return null ; } if ( str . starts CaMeL With ( $STRING$ ) || str . starts CaMeL With ( $STRING$ ) ) { return create CaMeL Integer ( str ) ; } char last CaMeL Char = str . char CaMeL At ( str . length ( ) - 1 ) ; String mant ; String dec ; String exp ; int dec CaMeL Pos = str . index CaMeL Of ( $STRING$ ) ; int exp CaMeL Pos = str . index CaMeL Of ( $STRING$ ) + str . index CaMeL Of ( $STRING$ ) + 1 ; if ( dec CaMeL Pos > - 1 ) { if ( exp CaMeL Pos > - 1 ) { if ( exp CaMeL Pos < dec CaMeL Pos || exp CaMeL Pos > str . length ( ) ) { throw new Number CaMeL Format CaMeL Exception ( str + $STRING$ ) ; } dec = str . substring ( dec CaMeL Pos + 1 , exp CaMeL Pos ) ; } else { dec = str . substring ( dec CaMeL Pos + 1 ) ; } mant = str . substring ( 0 , dec CaMeL Pos ) ; } else { if ( exp CaMeL Pos > - 1 ) { if ( exp CaMeL Pos > str . length ( ) ) { throw new Number CaMeL Format CaMeL Exception ( str + $STRING$ ) ; } mant = str . substring ( 0 , exp CaMeL Pos ) ; } else { mant = str ; } dec = null ; } if ( ! Character . is CaMeL Digit ( last CaMeL Char ) && last CaMeL Char != $STRING$ ) { if ( exp CaMeL Pos > - 1 && exp CaMeL Pos < str . length ( ) - 1 ) { exp = str . substring ( exp CaMeL Pos + 1 , str . length ( ) - 1 ) ; } else { exp = null ; } / / Requesting a specific type . . String numeric = str . substring ( 0 , str . length ( ) - 1 ) ; boolean all CaMeL Zeros = is CaMeL All CaMeL Zeros ( mant ) && is CaMeL All CaMeL Zeros ( exp ) ; switch ( last CaMeL Char ) { case $STRING$ : case $STRING$ : if ( dec == null && exp == null && ( numeric . char CaMeL At ( 0 ) == $STRING$ && is CaMeL Digits ( numeric . substring ( 1 ) ) || is CaMeL Digits ( numeric ) ) ) { try { return create CaMeL Long ( numeric ) ; } catch ( Number CaMeL Format CaMeL Exception nfe ) { / / NOPMD / / Too big for a long } return create CaMeL Big CaMeL Integer ( numeric ) ; } throw new Number CaMeL Format CaMeL Exception ( str + $STRING$ ) ; case $STRING$ : case $STRING$ : try { Float f = Number CaMeL Utils . create CaMeL Float ( numeric ) ; if ( ! ( f . is CaMeL Infinite ( ) || ( f . float CaMeL Value ( ) == 0 . 0 F && ! all CaMeL Zeros ) ) ) { / / If it $STRING$ d $STRING$ D $STRING$ t have a preference on the return type , so let s start / / small and go from there . . . if ( exp CaMeL Pos > - 1 && exp CaMeL Pos < str . length ( ) - 1 ) { exp = str . substring ( exp CaMeL Pos + 1 , str . length ( ) ) ; } else { exp = null ; } if ( dec == null && exp == null ) { / / Must be an int , long , bigint try { return create CaMeL Integer ( str ) ; } catch ( Number CaMeL Format CaMeL Exception nfe ) { / / NOPMD / / ignore the bad number } try { return create CaMeL Long ( str ) ; } catch ( Number CaMeL Format CaMeL Exception nfe ) { / / NOPMD / / ignore the bad number } return create CaMeL Big CaMeL Integer ( str ) ; } else { / / Must be a float , double , Big CaMeL Dec boolean all CaMeL Zeros = is CaMeL All CaMeL Zeros ( mant ) && is CaMeL All CaMeL Zeros ( exp ) ; try { Float f = create CaMeL Float ( str ) ; if ( ! ( f . is CaMeL Infinite ( ) || ( f . float CaMeL Value ( ) == 0 . 0 F && ! all CaMeL Zeros ) ) ) { return f ; } } catch ( Number CaMeL Format CaMeL Exception nfe ) { / / NOPMD / / ignore the bad number } try { Double d = create CaMeL Double ( str ) ; if ( ! ( d . is CaMeL Infinite ( ) || ( d . double CaMeL Value ( ) == 0 . 0 D && ! all CaMeL Zeros ) ) ) { return d ; } } catch ( Number CaMeL Format CaMeL Exception nfe ) { / / NOPMD / / ignore the bad number } return create CaMeL Big CaMeL Decimal ( str ) ; } } }
cal 1 . get ( Calendar . HOUR ) == cal $NUMBER$ . get ( Calendar . HOUR ) && & <CTX> public static boolean is CaMeL Same CaMeL Local CaMeL Time ( Calendar cal 1 , Calendar cal $NUMBER$ ) { if ( cal 1 == null || cal $NUMBER$ == null ) { throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ ) ; } return ( cal 1 . get ( Calendar . MILLISECOND ) == cal $NUMBER$ . get ( Calendar . MILLISECOND ) && cal 1 . get ( Calendar . SECOND ) == cal $NUMBER$ . get ( Calendar . SECOND ) && cal 1 . get ( Calendar . MINUTE ) == cal $NUMBER$ . get ( Calendar . MINUTE ) && cal 1 . get ( Calendar . HOUR ) == cal $NUMBER$ . get ( Calendar . HOUR ) && cal 1 . get ( Calendar . DAY _ OF _ YEAR ) == cal $NUMBER$ . get ( Calendar . DAY _ OF _ YEAR ) && cal 1 . get ( Calendar . YEAR ) == cal $NUMBER$ . get ( Calendar . YEAR ) && cal 1 . get ( Calendar . ERA ) == cal $NUMBER$ . get ( Calendar . ERA ) && cal 1 . get CaMeL Class ( ) == cal $NUMBER$ . get CaMeL Class ( ) ) ; }
return found CaMeL Digit && ! has CaMeL Exp ; <CTX> public static boolean is CaMeL Number ( String str ) { if ( String CaMeL Utils . is CaMeL Empty ( str ) ) { return false ; } char [ ] chars = str . to CaMeL Char CaMeL Array ( ) ; int sz = chars . length ; boolean has CaMeL Exp = false ; boolean has CaMeL Dec CaMeL Point = false ; boolean allow CaMeL Signs = false ; boolean found CaMeL Digit = false ; / / deal with any possible sign up front int start = ( chars [ 0 ] == $STRING$ ) ? 1 : 0 ; if ( sz > start + 1 ) { if ( chars [ start ] == $STRING$ && chars [ start + 1 ] == $STRING$ ) { int i = start + $NUMBER$ ; if ( i == sz ) { return false ; / / str == $STRING$ } / / checking hex ( it can $STRING$ 0 $STRING$ $NUMBER$ $STRING$ a $STRING$ f $STRING$ A $STRING$ F $STRING$ t want to loop to the last char , check it afterwords / / for type qualifiers int i = start ; / / loop to the next to last char or to the last char if we need another digit to / / make a valid number ( e . g . chars [ 0 . . $NUMBER$ ] = $STRING$ ) while ( i < sz || ( i < sz + 1 && allow CaMeL Signs && ! found CaMeL Digit ) ) { if ( chars [ i ] >= $STRING$ && chars [ i ] <= $STRING$ ) { found CaMeL Digit = true ; allow CaMeL Signs = false ; } else if ( chars [ i ] == $STRING$ ) { if ( has CaMeL Dec CaMeL Point || has CaMeL Exp ) { / / two decimal points or dec in exponent return false ; } has CaMeL Dec CaMeL Point = true ; } else if ( chars [ i ] == $STRING$ || chars [ i ] == $STRING$ ) { / / we $STRING$ s return false ; } if ( ! found CaMeL Digit ) { return false ; } has CaMeL Exp = true ; allow CaMeL Signs = true ; } else if ( chars [ i ] == $STRING$ || chars [ i ] == $STRING$ ) { if ( ! allow CaMeL Signs ) { return false ; } allow CaMeL Signs = false ; found CaMeL Digit = false ; / / we need a digit after the E } else { return false ; } i ++ ; } if ( i < chars . length ) { if ( chars [ i ] >= $STRING$ && chars [ i ] <= $STRING$ ) { / / no type qualifier , OK return true ; } if ( chars [ i ] == $STRING$ || chars [ i ] == $STRING$ ) { / / can $STRING$ . $STRING$ d $STRING$ D $STRING$ f $STRING$ F $STRING$ l $STRING$ L $STRING$ E $STRING$ . $STRING$ 1 E - $STRING$ t pass return ! allow CaMeL Signs && found CaMeL Digit ; }
Calendar c = new Gregorian CaMeL Calendar ( m CaMeL Time CaMeL Zone ) ; <CTX> public String format ( Date date ) { Calendar c = new Gregorian CaMeL Calendar ( m CaMeL Time CaMeL Zone ) ; c . set CaMeL Time ( date ) ; return apply CaMeL Rules ( c , new String CaMeL Buffer ( m CaMeL Max CaMeL Length CaMeL Estimate ) ) . to CaMeL String ( ) ; }
static float to CaMeL Java CaMeL Version CaMeL Int ( String version ) { <CTX> static float to CaMeL Java CaMeL Version CaMeL Int ( String version ) { return to CaMeL Version CaMeL Int ( to CaMeL Java CaMeL Version CaMeL Int CaMeL Array ( version , JAVA _ VERSION _ TRIM _ SIZE ) ) ; }
classes [ i ] = array [ i ] . get CaMeL Class ( ) ; <CTX> public static Class < ? > [ ] to CaMeL Class ( Object [ ] array ) { if ( array == null ) { return null ; } else if ( array . length == 0 ) { return Array CaMeL Utils . EMPTY _ CLASS _ ARRAY ; } Class < ? > [ ] classes = new Class [ array . length ] ; for ( int i = 0 ; i < array . length ; i ++ ) { classes [ i ] = array [ i ] . get CaMeL Class ( ) ; } return classes ; }
return c CaMeL Available CaMeL Locale CaMeL Set . contains ( locale ) ; <CTX> public static boolean is CaMeL Available CaMeL Locale ( Locale locale ) { return c CaMeL Available CaMeL Locale CaMeL Set . contains ( locale ) ; }
str . get CaMeL Chars ( 0 , str CaMeL Len , buffer , size ) ; <CTX> public Str CaMeL Builder append CaMeL Fixed CaMeL Width CaMeL Pad CaMeL Right ( Object obj , int width , char pad CaMeL Char ) { if ( width > 0 ) { ensure CaMeL Capacity ( size + width ) ; String str = ( obj == null ? get CaMeL Null CaMeL Text ( ) : obj . to CaMeL String ( ) ) ; int str CaMeL Len = str . length ( ) ; if ( str CaMeL Len >= width ) { str . get CaMeL Chars ( 0 , str CaMeL Len , buffer , size ) ; } else { int pad CaMeL Len = width - str CaMeL Len ; str . get CaMeL Chars ( 0 , str CaMeL Len , buffer , size ) ; for ( int i = 0 ; i < pad CaMeL Len ; i ++ ) { buffer [ size + str CaMeL Len + i ] = pad CaMeL Char ; } } size += width ; } return this ; }
pos += Character . char CaMeL Count ( Character . code CaMeL Point CaMeL At ( input , pos ) ) ; <CTX> public final void translate ( Char CaMeL Sequence input , Writer out ) throws IO CaMeL Exception { if ( out == null ) { throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ ) ; } if ( input == null ) { return ; } int pos = 0 ; int len = input . length ( ) ; while ( pos < len ) { int consumed = translate ( input , pos , out ) ; if ( consumed == 0 ) { char [ ] c = Character . to CaMeL Chars ( Character . code CaMeL Point CaMeL At ( input , pos ) ) ; out . write ( c ) ; pos += c . length ; continue ; } / / / / contract with translators is that they have to understand codepoints / / / / and they just took care of a surrogate pair for ( int pt = 0 ; pt < consumed ; pt ++ ) { pos += Character . char CaMeL Count ( Character . code CaMeL Point CaMeL At ( input , pos ) ) ; } } }
int len = this CaMeL Buf . length - str CaMeL Len ; <CTX> public int index CaMeL Of ( String str , int start CaMeL Index ) { start CaMeL Index = ( start CaMeL Index < 0 ? 0 : start CaMeL Index ) ; if ( str == null || start CaMeL Index >= size ) { return - 1 ; } int str CaMeL Len = str . length ( ) ; if ( str CaMeL Len == 1 ) { return index CaMeL Of ( str . char CaMeL At ( 0 ) , start CaMeL Index ) ; } if ( str CaMeL Len == 0 ) { return start CaMeL Index ; } if ( str CaMeL Len > size ) { return - 1 ; } char [ ] this CaMeL Buf = buffer ; int len = this CaMeL Buf . length - str CaMeL Len ; outer : for ( int i = start CaMeL Index ; i < len ; i ++ ) { for ( int j = 0 ; j < str CaMeL Len ; j ++ ) { if ( str . char CaMeL At ( j ) != this CaMeL Buf [ i + j ] ) { continue outer ; } } return i ; } return - 1 ; }
return sum CaMeL YY - sum CaMeL XY * sum CaMeL XY / sum CaMeL XX ; <CTX> public double get CaMeL Sum CaMeL Squared CaMeL Errors ( ) { return sum CaMeL YY - sum CaMeL XY * sum CaMeL XY / sum CaMeL XX ; }
return Fast CaMeL Math . pow ( $NUMBER$ * Fast CaMeL Math . PI , - dim / $NUMBER$ ) * <CTX> public double density ( final double [ ] vals ) throws Dimension CaMeL Mismatch CaMeL Exception { final int dim = get CaMeL Dimension ( ) ; if ( vals . length != dim ) { throw new Dimension CaMeL Mismatch CaMeL Exception ( vals . length , dim ) ; } return Fast CaMeL Math . pow ( $NUMBER$ * Fast CaMeL Math . PI , - dim / $NUMBER$ ) * Fast CaMeL Math . pow ( covariance CaMeL Matrix CaMeL Determinant , - 0 . $NUMBER$ ) * get CaMeL Exponent CaMeL Term ( vals ) ; }
return ( double ) ( get CaMeL Sample CaMeL Size ( ) * get CaMeL Number CaMeL Of CaMeL Successes ( ) ) / ( double ) get CaMeL Population CaMeL Size ( ) ; <CTX> public double get CaMeL Numerical CaMeL Mean ( ) { return ( double ) ( get CaMeL Sample CaMeL Size ( ) * get CaMeL Number CaMeL Of CaMeL Successes ( ) ) / ( double ) get CaMeL Population CaMeL Size ( ) ; }
return multiply ( $NUMBER$ ) . double CaMeL Value ( ) ; <CTX> public double percentage CaMeL Value ( ) { return multiply ( $NUMBER$ ) . double CaMeL Value ( ) ; }
final int n 1 n $NUMBER$ prod = n 1 * n $NUMBER$ ; <CTX> private double calculate CaMeL Asymptotic CaMeL P CaMeL Value ( final double Umin , final int n 1 , final int n $NUMBER$ ) throws Convergence CaMeL Exception , Max CaMeL Count CaMeL Exceeded CaMeL Exception { final int n 1 n $NUMBER$ prod = n 1 * n $NUMBER$ ; / / http : / / en . wikipedia . org / wiki / Mann % E $NUMBER$ % $NUMBER$ % $NUMBER$ Whitney _ U # Normal _ approximation final double EU = n 1 n $NUMBER$ prod / $NUMBER$ . 0 ; final double Var CaMeL U = n 1 n $NUMBER$ prod * ( n 1 + n $NUMBER$ + 1 ) / $NUMBER$ . 0 ; final double z = ( Umin - EU ) / Fast CaMeL Math . sqrt ( Var CaMeL U ) ; final Normal CaMeL Distribution standard CaMeL Normal = new Normal CaMeL Distribution ( 0 , 1 ) ; return $NUMBER$ * standard CaMeL Normal . cumulative CaMeL Probability ( z ) ; }
if ( ( Boolean ) tree . get CaMeL Attribute ( ) ) { <CTX> protected void compute CaMeL Geometrical CaMeL Properties ( ) { final Vector $NUMBER$ D [ ] [ ] v = get CaMeL Vertices ( ) ; if ( v . length == 0 ) { final BSP CaMeL Tree < Euclidean $NUMBER$ D > tree = get CaMeL Tree ( false ) ; if ( ( Boolean ) tree . get CaMeL Attribute ( ) ) { / / the instance covers the whole space set CaMeL Size ( Double . POSITIVE _ INFINITY ) ; set CaMeL Barycenter ( Vector $NUMBER$ D . Na CaMeL N ) ; } else { set CaMeL Size ( 0 ) ; set CaMeL Barycenter ( new Vector $NUMBER$ D ( 0 , 0 ) ) ; } } else if ( v [ 0 ] [ 0 ] == null ) { / / there is at least one open - loop : the polygon is infinite set CaMeL Size ( Double . POSITIVE _ INFINITY ) ; set CaMeL Barycenter ( Vector $NUMBER$ D . Na CaMeL N ) ; } else { / / all loops are closed , we compute some integrals around the shape double sum = 0 ; double sum CaMeL X = 0 ; double sum CaMeL Y = 0 ; for ( Vector $NUMBER$ D [ ] loop : v ) { double x 1 = loop [ loop . length - 1 ] . get CaMeL X ( ) ; double y 1 = loop [ loop . length - 1 ] . get CaMeL Y ( ) ; for ( final Vector $NUMBER$ D point : loop ) { final double x 0 = x 1 ; final double y 0 = y 1 ; x 1 = point . get CaMeL X ( ) ; y 1 = point . get CaMeL Y ( ) ; final double factor = x 0 * y 1 - y 0 * x 1 ; sum += factor ; sum CaMeL X += factor * ( x 0 + x 1 ) ; sum CaMeL Y += factor * ( y 0 + y 1 ) ; } } if ( sum < 0 ) { / / the polygon as a finite outside surrounded by an infinite inside set CaMeL Size ( Double . POSITIVE _ INFINITY ) ; set CaMeL Barycenter ( Vector $NUMBER$ D . Na CaMeL N ) ; } else { set CaMeL Size ( sum / $NUMBER$ ) ; set CaMeL Barycenter ( new Vector $NUMBER$ D ( sum CaMeL X / ( $NUMBER$ * sum ) , sum CaMeL Y / ( $NUMBER$ * sum ) ) ) ; } } }
if ( Precision . compare CaMeL To ( entry , 0 d , max CaMeL Ulps ) > 0 ) { <CTX> protected void drop CaMeL Phase 1 Objective ( ) { if ( get CaMeL Num CaMeL Objective CaMeL Functions ( ) == 1 ) { return ; } List < Integer > columns CaMeL To CaMeL Drop = new Array CaMeL List < Integer > ( ) ; columns CaMeL To CaMeL Drop . add ( 0 ) ; / / positive cost non - artificial variables for ( int i = get CaMeL Num CaMeL Objective CaMeL Functions ( ) ; i < get CaMeL Artificial CaMeL Variable CaMeL Offset ( ) ; i ++ ) { final double entry = tableau . get CaMeL Entry ( 0 , i ) ; if ( Precision . compare CaMeL To ( entry , 0 d , max CaMeL Ulps ) > 0 ) { columns CaMeL To CaMeL Drop . add ( i ) ; } } / / non - basic artificial variables for ( int i = 0 ; i < get CaMeL Num CaMeL Artificial CaMeL Variables ( ) ; i ++ ) { int col = i + get CaMeL Artificial CaMeL Variable CaMeL Offset ( ) ; if ( get CaMeL Basic CaMeL Row ( col ) == null ) { columns CaMeL To CaMeL Drop . add ( col ) ; } } double [ ] [ ] matrix = new double [ get CaMeL Height ( ) - 1 ] [ get CaMeL Width ( ) - columns CaMeL To CaMeL Drop . size ( ) ] ; for ( int i = 1 ; i < get CaMeL Height ( ) ; i ++ ) { int col = 0 ; for ( int j = 0 ; j < get CaMeL Width ( ) ; j ++ ) { if ( ! columns CaMeL To CaMeL Drop . contains ( j ) ) { matrix [ i - 1 ] [ col ++ ] = tableau . get CaMeL Entry ( i , j ) ; } } } for ( int i = columns CaMeL To CaMeL Drop . size ( ) - 1 ; i >= 0 ; i -- ) { column CaMeL Labels . remove ( ( int ) columns CaMeL To CaMeL Drop . get ( i ) ) ; } this . tableau = new Array $NUMBER$ D CaMeL Row CaMeL Real CaMeL Matrix ( matrix ) ; this . num CaMeL Artificial CaMeL Variables = 0 ; }
return chromosomes . iterator ( ) ; <CTX> public Iterator < Chromosome > iterator ( ) { return chromosomes . iterator ( ) ; }
for ( int i = 0 ; i < weights . length ; i ++ ) { <CTX> public double evaluate ( final double [ ] values , final double [ ] weights , final double mean , final int begin , final int length ) { double var = Double . Na CaMeL N ; if ( test ( values , weights , begin , length ) ) { if ( length == 1 ) { var = 0 . 0 ; } else if ( length > 1 ) { double accum = 0 . 0 ; double dev = 0 . 0 ; double accum $NUMBER$ = 0 . 0 ; for ( int i = begin ; i < begin + length ; i ++ ) { dev = values [ i ] - mean ; accum += weights [ i ] * ( dev * dev ) ; accum $NUMBER$ += weights [ i ] * dev ; } double sum CaMeL Wts = 0 ; for ( int i = 0 ; i < weights . length ; i ++ ) { sum CaMeL Wts += weights [ i ] ; } if ( is CaMeL Bias CaMeL Corrected ) { var = ( accum - ( accum $NUMBER$ * accum $NUMBER$ / sum CaMeL Wts ) ) / ( sum CaMeL Wts - 1 . 0 ) ; } else { var = ( accum - ( accum $NUMBER$ * accum $NUMBER$ / sum CaMeL Wts ) ) / sum CaMeL Wts ; } } } return var ; }
return Na CaMeL N ; <CTX> public Complex reciprocal ( ) { if ( is CaMeL Na CaMeL N ) { return Na CaMeL N ; } if ( real == 0 . 0 && imaginary == 0 . 0 ) { return Na CaMeL N ; } if ( is CaMeL Infinite ) { return ZERO ; } if ( Fast CaMeL Math . abs ( real ) < Fast CaMeL Math . abs ( imaginary ) ) { double q = real / imaginary ; double scale = 1 . / ( real * q + imaginary ) ; return create CaMeL Complex ( scale * q , - scale ) ; } else { double q = imaginary / real ; double scale = 1 . / ( imaginary * q + real ) ; return create CaMeL Complex ( scale , - scale * q ) ; } }
int sum = 0 ; <CTX> private static < T extends Clusterable < T >> List < Cluster < T >> choose CaMeL Initial CaMeL Centers ( final Collection < T > points , final int k , final Random random ) { final List < T > point CaMeL Set = new Array CaMeL List < T > ( points ) ; final List < Cluster < T >> result CaMeL Set = new Array CaMeL List < Cluster < T >> ( ) ; / / Choose one center uniformly at random from among the data points . final T first CaMeL Point = point CaMeL Set . remove ( random . next CaMeL Int ( point CaMeL Set . size ( ) ) ) ; result CaMeL Set . add ( new Cluster < T > ( first CaMeL Point ) ) ; final double [ ] dx $NUMBER$ = new double [ point CaMeL Set . size ( ) ] ; while ( result CaMeL Set . size ( ) < k ) { / / For each data point x , compute D ( x ) , the distance between x and / / the nearest center that has already been chosen . int sum = 0 ; for ( int i = 0 ; i < point CaMeL Set . size ( ) ; i ++ ) { final T p = point CaMeL Set . get ( i ) ; final Cluster < T > nearest = get CaMeL Nearest CaMeL Cluster ( result CaMeL Set , p ) ; final double d = p . distance CaMeL From ( nearest . get CaMeL Center ( ) ) ; sum += d * d ; dx $NUMBER$ [ i ] = sum ; } / / Add one new data point as a center . Each point x is chosen with / / probability proportional to D ( x ) $NUMBER$ final double r = random . next CaMeL Double ( ) * sum ; for ( int i = 0 ; i < dx $NUMBER$ . length ; i ++ ) { if ( dx $NUMBER$ [ i ] >= r ) { final T p = point CaMeL Set . remove ( i ) ; result CaMeL Set . add ( new Cluster < T > ( p ) ) ; break ; } } } return result CaMeL Set ; }
return fit ( new Gaussian . Parametric ( ) , guess ) ; <CTX> public double [ ] fit ( ) { final double [ ] guess = ( new Parameter CaMeL Guesser ( get CaMeL Observations ( ) ) ) . guess ( ) ; return fit ( new Gaussian . Parametric ( ) , guess ) ; }
return ( a <= b ) ? b : ( Float . is CaMeL Na CaMeL N ( a + b ) ? Float . Na CaMeL N : b ) ; <CTX> public static float max ( final float a , final float b ) { return ( a <= b ) ? b : ( Float . is CaMeL Na CaMeL N ( a + b ) ? Float . Na CaMeL N : b ) ; }
return ( Double . is CaMeL Na CaMeL N ( x ) && Double . is CaMeL Na CaMeL N ( y ) ) || x == y ; <CTX> public static boolean equals ( double x , double y ) { return ( Double . is CaMeL Na CaMeL N ( x ) && Double . is CaMeL Na CaMeL N ( y ) ) || x == y ; }
out [ i ] [ j ] = $NUMBER$ * ( 1 - t CaMeL Distribution . cumulative CaMeL Probability ( t ) ) ; <CTX> public Real CaMeL Matrix get CaMeL Correlation CaMeL P CaMeL Values ( ) throws Math CaMeL Exception { T CaMeL Distribution t CaMeL Distribution = new T CaMeL Distribution CaMeL Impl ( n CaMeL Obs - $NUMBER$ ) ; int n CaMeL Vars = correlation CaMeL Matrix . get CaMeL Column CaMeL Dimension ( ) ; double [ ] [ ] out = new double [ n CaMeL Vars ] [ n CaMeL Vars ] ; for ( int i = 0 ; i < n CaMeL Vars ; i ++ ) { for ( int j = 0 ; j < n CaMeL Vars ; j ++ ) { if ( i == j ) { out [ i ] [ j ] = 0 d ; } else { double r = correlation CaMeL Matrix . get CaMeL Entry ( i , j ) ; double t = Math . abs ( r * Math . sqrt ( ( n CaMeL Obs - $NUMBER$ ) / ( 1 - r * r ) ) ) ; out [ i ] [ j ] = $NUMBER$ * ( 1 - t CaMeL Distribution . cumulative CaMeL Probability ( t ) ) ; } } } return new Block CaMeL Real CaMeL Matrix ( out ) ; }
return solve ( min , max ) ; <CTX> public double solve ( final Univariate CaMeL Real CaMeL Function f , double min , double max , double initial ) throws Max CaMeL Iterations CaMeL Exceeded CaMeL Exception , Function CaMeL Evaluation CaMeL Exception { return solve ( min , max ) ; }
return get CaMeL Cum CaMeL Pct ( ( Comparable < ? > ) v ) ; <CTX> public double get CaMeL Pct ( Object v ) { return get CaMeL Cum CaMeL Pct ( ( Comparable < ? > ) v ) ; }
int j = $NUMBER$ * n - 1 ; <CTX> private boolean flip CaMeL If CaMeL Warranted ( final int n , final int step ) { if ( 1 . $NUMBER$ * work [ ping CaMeL Pong ] < work [ $NUMBER$ * ( n - 1 ) + ping CaMeL Pong ] ) { / / flip array int j = $NUMBER$ * n - 1 ; for ( int i = 0 ; i < j ; i += $NUMBER$ ) { for ( int k = 0 ; k < $NUMBER$ ; k += step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ; work [ j - k ] = tmp ; } j -= $NUMBER$ ; } return true ; } return false ; }
if ( Math CaMeL Utils . compare CaMeL To ( entry , 0 , epsilon ) >= 0 ) { <CTX> private Integer get CaMeL Pivot CaMeL Row ( final int col , final Simplex CaMeL Tableau tableau ) { double min CaMeL Ratio = Double . MAX _ VALUE ; Integer min CaMeL Ratio CaMeL Pos = null ; for ( int i = tableau . get CaMeL Num CaMeL Objective CaMeL Functions ( ) ; i < tableau . get CaMeL Height ( ) ; i ++ ) { final double rhs = tableau . get CaMeL Entry ( i , tableau . get CaMeL Width ( ) - 1 ) ; final double entry = tableau . get CaMeL Entry ( i , col ) ; if ( Math CaMeL Utils . compare CaMeL To ( entry , 0 , epsilon ) >= 0 ) { final double ratio = rhs / entry ; if ( ratio < min CaMeL Ratio ) { min CaMeL Ratio = ratio ; min CaMeL Ratio CaMeL Pos = i ; } } } return min CaMeL Ratio CaMeL Pos ; }
if ( fa * fb >= 0 . 0 ) { <CTX> public static double [ ] bracket ( Univariate CaMeL Real CaMeL Function function , double initial , double lower CaMeL Bound , double upper CaMeL Bound , int maximum CaMeL Iterations ) throws Convergence CaMeL Exception , Function CaMeL Evaluation CaMeL Exception { if ( function == null ) { throw Math CaMeL Runtime CaMeL Exception . create CaMeL Illegal CaMeL Argument CaMeL Exception ( $STRING$ ) ; } if ( maximum CaMeL Iterations <= 0 ) { throw Math CaMeL Runtime CaMeL Exception . create CaMeL Illegal CaMeL Argument CaMeL Exception ( $STRING$ , maximum CaMeL Iterations ) ; } if ( initial < lower CaMeL Bound || initial > upper CaMeL Bound || lower CaMeL Bound >= upper CaMeL Bound ) { throw Math CaMeL Runtime CaMeL Exception . create CaMeL Illegal CaMeL Argument CaMeL Exception ( $STRING$ , lower CaMeL Bound , initial , upper CaMeL Bound ) ; } double a = initial ; double b = initial ; double fa ; double fb ; int num CaMeL Iterations = 0 ; do { a = Math . max ( a - 1 . 0 , lower CaMeL Bound ) ; b = Math . min ( b + 1 . 0 , upper CaMeL Bound ) ; fa = function . value ( a ) ; fb = function . value ( b ) ; num CaMeL Iterations ++ ; } while ( ( fa * fb > 0 . 0 ) && ( num CaMeL Iterations < maximum CaMeL Iterations ) && ( ( a > lower CaMeL Bound ) || ( b < upper CaMeL Bound ) ) ) ; if ( fa * fb >= 0 . 0 ) { throw new Convergence CaMeL Exception ( $STRING$ + $STRING$ + $STRING$ , num CaMeL Iterations , maximum CaMeL Iterations , initial , lower CaMeL Bound , upper CaMeL Bound , a , b , fa , fb ) ; } return new double [ ] { a , b } ; }
if ( u * v == 0 ) { <CTX> public static int gcd ( int u , int v ) { if ( u * v == 0 ) { return ( Math . abs ( u ) + Math . abs ( v ) ) ; } / / keep u and v negative , as negative integers range down to / / - $NUMBER$ ^ $NUMBER$ , while positive numbers can only be as large as $NUMBER$ ^ $NUMBER$ - 1 / / ( i . e . we can t necessarily negate a negative number without / / overflow ) / * assert u != 0 && v != 0 ; * / if ( u > 0 ) { u = - u ; } / / make u negative if ( v > 0 ) { v = - v ; } / / make v negative / / B 1 . [ Find power of $NUMBER$ ] int k = 0 ; while ( ( u & 1 ) == 0 && ( v & 1 ) == 0 && k < $NUMBER$ ) { / / while u and v are / / both even . . . u /= $NUMBER$ ; v /= $NUMBER$ ; k ++ ; / / cast out twos . } if ( k == $NUMBER$ ) { throw new Arithmetic CaMeL Exception ( $STRING$ ) ; } / / B $NUMBER$ . Initialize : u and v have been divided by $NUMBER$ ^ k and at least / / one is odd . int t = ( ( u & 1 ) == 1 ) ? v : - ( u / $NUMBER$ ) / * B $NUMBER$ * / ; / / t negative : u was odd , v may be even ( t replaces v ) / / t positive : u was even , v is odd ( t replaces u ) do { / * assert u < 0 && v < 0 ; * / / / B $NUMBER$ / B $NUMBER$ : cast out twos from t . while ( ( t & 1 ) == 0 ) { / / while t is even . . t /= $NUMBER$ ; / / cast out twos } / / B $NUMBER$ [ reset max ( u , v ) ] if ( t > 0 ) { u = - t ; } else { v = t ; } / / B $NUMBER$ / B $NUMBER$ . at this point both u and v should be odd . t = ( v - u ) / $NUMBER$ ; / / | u | larger : t positive ( replace u ) / / | v | larger : t negative ( replace v ) } while ( t != 0 ) ; return - u * ( 1 << k ) ; / / gcd is u * $NUMBER$ ^ k }
ret = ( Double . double CaMeL To CaMeL Raw CaMeL Long CaMeL Bits ( real ) == Double . double CaMeL To CaMeL Raw CaMeL Long CaMeL Bits ( rhs . get CaMeL Real ( ) ) ) && ( Double . double CaMeL To CaMeL Raw CaMeL Long CaMeL Bits ( imaginary ) == Double . double CaMeL To CaMeL Raw CaMeL Long CaMeL Bits ( rhs . get CaMeL Imaginary ( ) ) ) ; <CTX> public boolean equals ( Object other ) { boolean ret ; if ( this == other ) { ret = true ; } else if ( other == null ) { ret = false ; } else { try { Complex rhs = ( Complex ) other ; if ( rhs . is CaMeL Na CaMeL N ( ) ) { ret = this . is CaMeL Na CaMeL N ( ) ; } else { ret = ( Double . double CaMeL To CaMeL Raw CaMeL Long CaMeL Bits ( real ) == Double . double CaMeL To CaMeL Raw CaMeL Long CaMeL Bits ( rhs . get CaMeL Real ( ) ) ) && ( Double . double CaMeL To CaMeL Raw CaMeL Long CaMeL Bits ( imaginary ) == Double . double CaMeL To CaMeL Raw CaMeL Long CaMeL Bits ( rhs . get CaMeL Imaginary ( ) ) ) ; } } catch ( Class CaMeL Cast CaMeL Exception ex ) { / / ignore exception ret = false ; } } return ret ; }
return 1 ; <CTX> public Object answer ( Invocation CaMeL On CaMeL Mock invocation ) { if ( methods CaMeL Guru . is CaMeL To CaMeL String ( invocation . get CaMeL Method ( ) ) ) { Object mock = invocation . get CaMeL Mock ( ) ; Mock CaMeL Name name = mock CaMeL Util . get CaMeL Mock CaMeL Name ( mock ) ; if ( name . is CaMeL Default ( ) ) { return $STRING$ + mock CaMeL Util . get CaMeL Mock CaMeL Settings ( mock ) . get CaMeL Type CaMeL To CaMeL Mock ( ) . get CaMeL Simple CaMeL Name ( ) + $STRING$ + mock . hash CaMeL Code ( ) ; } else { return name . to CaMeL String ( ) ; } } else if ( methods CaMeL Guru . is CaMeL Compare CaMeL To CaMeL Method ( invocation . get CaMeL Method ( ) ) ) { / / see issue $NUMBER$ . / / mocks by default should return 0 if references are the same , otherwise some other value because they are not the same . Hence we return 1 ( anything but 0 is good ) . / / Only for compare CaMeL To ( ) method by the Comparable interface return 1 ; } Class < ? > return CaMeL Type = invocation . get CaMeL Method ( ) . get CaMeL Return CaMeL Type ( ) ; return return CaMeL Value CaMeL For ( return CaMeL Type ) ; }
description . append CaMeL Text ( wanted . to CaMeL String ( ) ) ; <CTX> public void describe CaMeL To ( Description description ) { description . append CaMeL Text ( $STRING$ ) ; append CaMeL Quoting ( description ) ; description . append CaMeL Text ( wanted . to CaMeL String ( ) ) ; append CaMeL Quoting ( description ) ; description . append CaMeL Text ( $STRING$ ) ; }
if ( m instanceof Captures CaMeL Arguments ) { <CTX> public void capture CaMeL Arguments CaMeL From ( Invocation i ) { int k = 0 ; for ( Matcher m : matchers ) { if ( m instanceof Captures CaMeL Arguments ) { ( ( Captures CaMeL Arguments ) m ) . capture CaMeL From ( i . get CaMeL Arguments ( ) [ k ] ) ; } k ++ ; } }
return String CaMeL Description . to CaMeL String ( m ) . equals ( arg . to CaMeL String ( ) ) ; <CTX> private boolean to CaMeL String CaMeL Equals ( Matcher m , Object arg ) { return String CaMeL Description . to CaMeL String ( m ) . equals ( arg . to CaMeL String ( ) ) ; }
catch ( org . mockito . exceptions . verification . junit . Arguments CaMeL Are CaMeL Different e ) { <CTX> public void verify ( Verification CaMeL Data data ) { Assertion CaMeL Error error = null ; timer . start ( ) ; while ( timer . is CaMeL Counting ( ) ) { try { delegate . verify ( data ) ; if ( return CaMeL On CaMeL Success ) { return ; } else { error = null ; } } catch ( Mockito CaMeL Assertion CaMeL Error e ) { error = handle CaMeL Verify CaMeL Exception ( e ) ; } catch ( org . mockito . exceptions . verification . junit . Arguments CaMeL Are CaMeL Different e ) { error = handle CaMeL Verify CaMeL Exception ( e ) ; } } if ( error != null ) { throw error ; } }
} else { <CTX> protected void register CaMeL Type CaMeL Variables CaMeL On ( Type class CaMeL Type ) { if ( ! ( class CaMeL Type instanceof Parameterized CaMeL Type ) ) { return ; } Parameterized CaMeL Type parameterized CaMeL Type = ( Parameterized CaMeL Type ) class CaMeL Type ; Type CaMeL Variable [ ] type CaMeL Parameters = ( ( Class < ? > ) parameterized CaMeL Type . get CaMeL Raw CaMeL Type ( ) ) . get CaMeL Type CaMeL Parameters ( ) ; Type [ ] actual CaMeL Type CaMeL Arguments = parameterized CaMeL Type . get CaMeL Actual CaMeL Type CaMeL Arguments ( ) ; for ( int i = 0 ; i < actual CaMeL Type CaMeL Arguments . length ; i ++ ) { Type CaMeL Variable type CaMeL Parameter = type CaMeL Parameters [ i ] ; Type actual CaMeL Type CaMeL Argument = actual CaMeL Type CaMeL Arguments [ i ] ; if ( actual CaMeL Type CaMeL Argument instanceof Wildcard CaMeL Type ) { contextual CaMeL Actual CaMeL Type CaMeL Parameters . put ( type CaMeL Parameter , bounds CaMeL Of ( ( Wildcard CaMeL Type ) actual CaMeL Type CaMeL Argument ) ) ; } else { contextual CaMeL Actual CaMeL Type CaMeL Parameters . put ( type CaMeL Parameter , actual CaMeL Type CaMeL Argument ) ; } / / logger . log ( $STRING$ + parameterized CaMeL Type + $STRING$ + type CaMeL Parameter + $STRING$ + System . identity CaMeL Hash CaMeL Code ( type CaMeL Parameter ) + $STRING$ + $STRING$ + actual CaMeL Type CaMeL Argument + $STRING$ + System . identity CaMeL Hash CaMeL Code ( type CaMeL Parameter ) + $STRING$ + $STRING$ ) ; } }
instant CaMeL Local , chrono , i CaMeL Locale , i CaMeL Pivot CaMeL Year , i CaMeL Default CaMeL Year ) ; <CTX> public int parse CaMeL Into ( Read CaMeL Writable CaMeL Instant instant , String text , int position ) { Date CaMeL Time CaMeL Parser parser = require CaMeL Parser ( ) ; if ( instant == null ) { throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ ) ; } long instant CaMeL Millis = instant . get CaMeL Millis ( ) ; Chronology chrono = instant . get CaMeL Chronology ( ) ; long instant CaMeL Local = instant CaMeL Millis + chrono . get CaMeL Zone ( ) . get CaMeL Offset ( instant CaMeL Millis ) ; chrono = select CaMeL Chronology ( chrono ) ; Date CaMeL Time CaMeL Parser CaMeL Bucket bucket = new Date CaMeL Time CaMeL Parser CaMeL Bucket ( instant CaMeL Local , chrono , i CaMeL Locale , i CaMeL Pivot CaMeL Year , i CaMeL Default CaMeL Year ) ; int new CaMeL Pos = parser . parse CaMeL Into ( bucket , text , position ) ; instant . set CaMeL Millis ( bucket . compute CaMeL Millis ( false , text ) ) ; if ( i CaMeL Offset CaMeL Parsed && bucket . get CaMeL Offset CaMeL Integer ( ) != null ) { int parsed CaMeL Offset = bucket . get CaMeL Offset CaMeL Integer ( ) ; Date CaMeL Time CaMeL Zone parsed CaMeL Zone = Date CaMeL Time CaMeL Zone . for CaMeL Offset CaMeL Millis ( parsed CaMeL Offset ) ; chrono = chrono . with CaMeL Zone ( parsed CaMeL Zone ) ; } else if ( bucket . get CaMeL Zone ( ) != null ) { chrono = chrono . with CaMeL Zone ( bucket . get CaMeL Zone ( ) ) ; } instant . set CaMeL Chronology ( chrono ) ; if ( i CaMeL Zone != null ) { instant . set CaMeL Zone ( i CaMeL Zone ) ; } return new CaMeL Pos ; }
} else if ( offset CaMeL Local > 0 ) { <CTX> public int get CaMeL Offset CaMeL From CaMeL Local ( long instant CaMeL Local ) { / / get the offset at instant CaMeL Local ( first estimate ) final int offset CaMeL Local = get CaMeL Offset ( instant CaMeL Local ) ; / / adjust instant CaMeL Local using the estimate and recalc the offset final long instant CaMeL Adjusted = instant CaMeL Local - offset CaMeL Local ; final int offset CaMeL Adjusted = get CaMeL Offset ( instant CaMeL Adjusted ) ; / / if the offsets differ , we must be near a DST boundary if ( offset CaMeL Local != offset CaMeL Adjusted ) { / / we need to ensure that time is always after the DST gap / / this happens naturally for positive offsets , but not for negative if ( ( offset CaMeL Local - offset CaMeL Adjusted ) < 0 ) { / / if we just return offset CaMeL Adjusted then the time is pushed / / back before the transition , whereas it should be / / on or after the transition long next CaMeL Local = next CaMeL Transition ( instant CaMeL Adjusted ) ; long next CaMeL Adjusted = next CaMeL Transition ( instant CaMeL Local - offset CaMeL Adjusted ) ; if ( next CaMeL Local != next CaMeL Adjusted ) { return offset CaMeL Local ; } } } else if ( offset CaMeL Local > 0 ) { long prev = previous CaMeL Transition ( instant CaMeL Adjusted ) ; if ( prev < instant CaMeL Adjusted ) { int offset CaMeL Prev = get CaMeL Offset ( prev ) ; int diff = offset CaMeL Prev - offset CaMeL Local ; if ( instant CaMeL Adjusted - prev <= diff ) { return offset CaMeL Prev ; } } } return offset CaMeL Adjusted ; }
Partial new CaMeL Partial = new Partial ( i CaMeL Chronology , new CaMeL Types , new CaMeL Values ) ; <CTX> public Partial with ( Date CaMeL Time CaMeL Field CaMeL Type field CaMeL Type , int value ) { if ( field CaMeL Type == null ) { throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ ) ; } int index = index CaMeL Of ( field CaMeL Type ) ; if ( index == - 1 ) { Date CaMeL Time CaMeL Field CaMeL Type [ ] new CaMeL Types = new Date CaMeL Time CaMeL Field CaMeL Type [ i CaMeL Types . length + 1 ] ; int [ ] new CaMeL Values = new int [ new CaMeL Types . length ] ; / / find correct insertion point to keep largest - smallest order int i = 0 ; Duration CaMeL Field unit CaMeL Field = field CaMeL Type . get CaMeL Duration CaMeL Type ( ) . get CaMeL Field ( i CaMeL Chronology ) ; if ( unit CaMeL Field . is CaMeL Supported ( ) ) { for ( ; i < i CaMeL Types . length ; i ++ ) { Date CaMeL Time CaMeL Field CaMeL Type loop CaMeL Type = i CaMeL Types [ i ] ; Duration CaMeL Field loop CaMeL Unit CaMeL Field = loop CaMeL Type . get CaMeL Duration CaMeL Type ( ) . get CaMeL Field ( i CaMeL Chronology ) ; if ( loop CaMeL Unit CaMeL Field . is CaMeL Supported ( ) ) { int compare = unit CaMeL Field . compare CaMeL To ( loop CaMeL Unit CaMeL Field ) ; if ( compare > 0 ) { break ; } else if ( compare == 0 ) { Duration CaMeL Field range CaMeL Field = field CaMeL Type . get CaMeL Range CaMeL Duration CaMeL Type ( ) . get CaMeL Field ( i CaMeL Chronology ) ; Duration CaMeL Field loop CaMeL Range CaMeL Field = loop CaMeL Type . get CaMeL Range CaMeL Duration CaMeL Type ( ) . get CaMeL Field ( i CaMeL Chronology ) ; if ( range CaMeL Field . compare CaMeL To ( loop CaMeL Range CaMeL Field ) > 0 ) { break ; } } } } } System . arraycopy ( i CaMeL Types , 0 , new CaMeL Types , 0 , i ) ; System . arraycopy ( i CaMeL Values , 0 , new CaMeL Values , 0 , i ) ; new CaMeL Types [ i ] = field CaMeL Type ; new CaMeL Values [ i ] = value ; System . arraycopy ( i CaMeL Types , i , new CaMeL Types , i + 1 , new CaMeL Types . length - i - 1 ) ; System . arraycopy ( i CaMeL Values , i , new CaMeL Values , i + 1 , new CaMeL Values . length - i - 1 ) ; / / use public constructor to ensure full validation / / this isn t overly efficient , but is safe Partial new CaMeL Partial = new Partial ( i CaMeL Chronology , new CaMeL Types , new CaMeL Values ) ; i CaMeL Chronology . validate ( new CaMeL Partial , new CaMeL Values ) ; return new CaMeL Partial ; } if ( value == get CaMeL Value ( index ) ) { return this ; } int [ ] new CaMeL Values = get CaMeL Values ( ) ; new CaMeL Values = get CaMeL Field ( index ) . set ( this , index , new CaMeL Values , value ) ; return new Partial ( this , new CaMeL Values ) ; }
long instant CaMeL Local = instant CaMeL Millis + chrono . get CaMeL Zone ( ) . get CaMeL Offset ( instant CaMeL Millis ) ; <CTX> public int parse CaMeL Into ( Read CaMeL Writable CaMeL Instant instant , String text , int position ) { Date CaMeL Time CaMeL Parser parser = require CaMeL Parser ( ) ; if ( instant == null ) { throw new Illegal CaMeL Argument CaMeL Exception ( $STRING$ ) ; } long instant CaMeL Millis = instant . get CaMeL Millis ( ) ; Chronology chrono = instant . get CaMeL Chronology ( ) ; long instant CaMeL Local = instant CaMeL Millis + chrono . get CaMeL Zone ( ) . get CaMeL Offset ( instant CaMeL Millis ) ; chrono = select CaMeL Chronology ( chrono ) ; int default CaMeL Year = chrono . year ( ) . get ( instant CaMeL Local ) ; Date CaMeL Time CaMeL Parser CaMeL Bucket bucket = new Date CaMeL Time CaMeL Parser CaMeL Bucket ( instant CaMeL Local , chrono , i CaMeL Locale , i CaMeL Pivot CaMeL Year , default CaMeL Year ) ; int new CaMeL Pos = parser . parse CaMeL Into ( bucket , text , position ) ; instant . set CaMeL Millis ( bucket . compute CaMeL Millis ( false , text ) ) ; if ( i CaMeL Offset CaMeL Parsed && bucket . get CaMeL Offset CaMeL Integer ( ) != null ) { int parsed CaMeL Offset = bucket . get CaMeL Offset CaMeL Integer ( ) ; Date CaMeL Time CaMeL Zone parsed CaMeL Zone = Date CaMeL Time CaMeL Zone . for CaMeL Offset CaMeL Millis ( parsed CaMeL Offset ) ; chrono = chrono . with CaMeL Zone ( parsed CaMeL Zone ) ; } else if ( bucket . get CaMeL Zone ( ) != null ) { chrono = chrono . with CaMeL Zone ( bucket . get CaMeL Zone ( ) ) ; } instant . set CaMeL Chronology ( chrono ) ; if ( i CaMeL Zone != null ) { instant . set CaMeL Zone ( i CaMeL Zone ) ; } return new CaMeL Pos ; }
