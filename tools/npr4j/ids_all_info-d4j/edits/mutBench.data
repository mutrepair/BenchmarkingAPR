test ### public LegendItemCollection getLegendItems ( ) { LegendItemCollection result = new LegendItemCollection ( ) ; if ( this . plot == null ) { return result ; } int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset != null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) { for ( int i = 0 ; i < seriesCount ; i ++ ) { if ( isSeriesVisibleInLegend ( i ) ) { LegendItem item = getLegendItem ( index , i ) ; if ( item != null ) { result . add ( item ) ; } } } } else { for ( int i = seriesCount - 1 ; i >= 0 ; i -- ) { if ( isSeriesVisibleInLegend ( i ) ) { LegendItem item = getLegendItem ( index , i ) ; if ( item != null ) { result . add ( item ) ; } } } } return result ; } ### 51 57 ### <s> if ( dataset == null ) { </s>
test ### public String generateToolTipFragment ( String toolTipText ) { return " title=\"" + toolTipText + "\" alt=\"\"" ; } ### 8 12 ### <s> return " title=\"" + ImageMapUtilities . htmlEscape ( toolTipText ) </s>
test ### public static boolean equal ( GeneralPath p1 , GeneralPath p2 ) { if ( p1 == null ) { return ( p2 == null ) ; } if ( p2 == null ) { return false ; } if ( p1 . getWindingRule ( ) != p2 . getWindingRule ( ) ) { return false ; } PathIterator iterator1 = p1 . getPathIterator ( null ) ; PathIterator iterator2 = p1 . getPathIterator ( null ) ; double [ ] d1 = new double [ 6 ] ; double [ ] d2 = new double [ 6 ] ; boolean done = iterator1 . isDone ( ) && iterator2 . isDone ( ) ; while ( ! done ) { if ( iterator1 . isDone ( ) != iterator2 . isDone ( ) ) { return false ; } int seg1 = iterator1 . currentSegment ( d1 ) ; int seg2 = iterator2 . currentSegment ( d2 ) ; if ( seg1 != seg2 ) { return false ; } if ( ! Arrays . equals ( d1 , d2 ) ) { return false ; } iterator1 . next ( ) ; iterator2 . next ( ) ; done = iterator1 . isDone ( ) && iterator2 . isDone ( ) ; } return true ; } ### 67 76 ### <s> PathIterator iterator2 = p2 . getPathIterator ( null ) ; </s>
test ### public MultiplePiePlot ( CategoryDataset dataset ) { super ( ) ; this . dataset = dataset ; PiePlot piePlot = new PiePlot ( null ) ; this . pieChart = new JFreeChart ( piePlot ) ; this . pieChart . removeLegend ( ) ; this . dataExtractOrder = TableOrder . BY_COLUMN ; this . pieChart . setBackgroundPaint ( null ) ; TextTitle seriesTitle = new TextTitle ( "Series Title" , new Font ( "SansSerif" , Font . BOLD , 12 ) ) ; seriesTitle . setPosition ( RectangleEdge . BOTTOM ) ; this . pieChart . setTitle ( seriesTitle ) ; this . aggregatedItemsKey = "Other" ; this . aggregatedItemsPaint = Color . lightGray ; this . sectionPaints = new HashMap ( ) ; } ### 11 16 ### <s> setDataset ( dataset ) ; </s>
test ### protected Size2D arrangeFF ( BlockContainer container , Graphics2D g2 , RectangleConstraint constraint ) { double [ ] w = new double [ 5 ] ; double [ ] h = new double [ 5 ] ; w [ 0 ] = constraint . getWidth ( ) ; if ( this . topBlock != null ) { RectangleConstraint c1 = new RectangleConstraint ( w [ 0 ] , null , LengthConstraintType . FIXED , 0.0 , new Range ( 0.0 , constraint . getHeight ( ) ) , LengthConstraintType . RANGE ) ; Size2D size = this . topBlock . arrange ( g2 , c1 ) ; h [ 0 ] = size . height ; } w [ 1 ] = w [ 0 ] ; if ( this . bottomBlock != null ) { RectangleConstraint c2 = new RectangleConstraint ( w [ 0 ] , null , LengthConstraintType . FIXED , 0.0 , new Range ( 0.0 , constraint . getHeight ( ) - h [ 0 ] ) , LengthConstraintType . RANGE ) ; Size2D size = this . bottomBlock . arrange ( g2 , c2 ) ; h [ 1 ] = size . height ; } h [ 2 ] = constraint . getHeight ( ) - h [ 1 ] - h [ 0 ] ; if ( this . leftBlock != null ) { RectangleConstraint c3 = new RectangleConstraint ( 0.0 , new Range ( 0.0 , constraint . getWidth ( ) ) , LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; w [ 2 ] = size . width ; } h [ 3 ] = h [ 2 ] ; if ( this . rightBlock != null ) { RectangleConstraint c4 = new RectangleConstraint ( 0.0 , new Range ( 0.0 , constraint . getWidth ( ) - w [ 2 ] ) , LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . rightBlock . arrange ( g2 , c4 ) ; w [ 3 ] = size . width ; } h [ 4 ] = h [ 2 ] ; w [ 4 ] = constraint . getWidth ( ) - w [ 3 ] - w [ 2 ] ; RectangleConstraint c5 = new RectangleConstraint ( w [ 4 ] , h [ 4 ] ) ; if ( this . centerBlock != null ) { this . centerBlock . arrange ( g2 , c5 ) ; } if ( this . topBlock != null ) { this . topBlock . setBounds ( new Rectangle2D . Double ( 0.0 , 0.0 , w [ 0 ] , h [ 0 ] ) ) ; } if ( this . bottomBlock != null ) { this . bottomBlock . setBounds ( new Rectangle2D . Double ( 0.0 , h [ 0 ] + h [ 2 ] , w [ 1 ] , h [ 1 ] ) ) ; } if ( this . leftBlock != null ) { this . leftBlock . setBounds ( new Rectangle2D . Double ( 0.0 , h [ 0 ] , w [ 2 ] , h [ 2 ] ) ) ; } if ( this . rightBlock != null ) { this . rightBlock . setBounds ( new Rectangle2D . Double ( w [ 2 ] + w [ 4 ] , h [ 0 ] , w [ 3 ] , h [ 3 ] ) ) ; } if ( this . centerBlock != null ) { this . centerBlock . setBounds ( new Rectangle2D . Double ( w [ 2 ] , h [ 0 ] , w [ 4 ] , h [ 4 ] ) ) ; } return new Size2D ( constraint . getWidth ( ) , constraint . getHeight ( ) ) ; } ### 317 333 ### <s> new Range ( 0.0 , Math . max ( constraint . getWidth ( ) - w [ 2 ] , 0.0 ) ) , </s>
test ### public ValueMarker ( double value , Paint paint , Stroke stroke , Paint outlinePaint , Stroke outlineStroke , float alpha ) { super ( paint , stroke , paint , stroke , alpha ) ; this . value = value ; } ### 22 34 ### <s> super ( paint , stroke , outlinePaint , outlineStroke , alpha ) ; </s>
test ### public Paint getPaint ( double value ) { double v = Math . max ( value , this . lowerBound ) ; v = Math . min ( v , this . upperBound ) ; int g = ( int ) ( ( value - this . lowerBound ) / ( this . upperBound - this . lowerBound ) * 255.0 ) ; return new Color ( g , g , g ) ; } ### 35 53 ### <s> int g = ( int ) ( ( v - this . lowerBound ) / ( this . upperBound </s>
test ### public Week ( Date time , TimeZone zone ) { this ( time , RegularTimePeriod . DEFAULT_TIME_ZONE , Locale . getDefault ( ) ) ; } ### 10 24 ### <s> this ( time , zone , Locale . getDefault ( ) ) ; </s>
test ### public TimeSeries createCopy ( RegularTimePeriod start , RegularTimePeriod end ) throws CloneNotSupportedException { if ( start == null ) { throw new IllegalArgumentException ( "Null 'start' argument." ) ; } if ( end == null ) { throw new IllegalArgumentException ( "Null 'end' argument." ) ; } if ( start . compareTo ( end ) > 0 ) { throw new IllegalArgumentException ( "Requires start on or before end." ) ; } boolean emptyRange = false ; int startIndex = getIndex ( start ) ; if ( startIndex < 0 ) { startIndex = - ( startIndex + 1 ) ; if ( startIndex == this . data . size ( ) ) { emptyRange = true ; } } int endIndex = getIndex ( end ) ; if ( endIndex < 0 ) { endIndex = - ( endIndex + 1 ) ; endIndex = endIndex - 1 ; } if ( endIndex < 0 ) { emptyRange = true ; } if ( emptyRange ) { TimeSeries copy = ( TimeSeries ) super . clone ( ) ; copy . data = new java . util . ArrayList ( ) ; return copy ; } else { return createCopy ( startIndex , endIndex ) ; } } ### 151 157 ### <s> if ( ( endIndex < 0 )  ( endIndex < startIndex ) ) { </s>
test ### private static void appendOption ( final StringBuffer buff , final Option option , final boolean required ) { if ( ! required ) { buff . append ( "[" ) ; } if ( option . getOpt ( ) != null ) { buff . append ( "-" ) . append ( option . getOpt ( ) ) ; } else { buff . append ( "--" ) . append ( option . getLongOpt ( ) ) ; } if ( option . hasArg ( ) && ( option . getArgName ( ) != null ) ) { buff . append ( " <" ) . append ( option . getArgName ( ) ) . append ( ">" ) ; } if ( ! required ) { buff . append ( "]" ) ; } } ### 79 96 ### <s> if ( option . hasArg ( ) && option . hasArgName ( ) ) </s>
test ### protected StringBuffer renderWrappedText ( StringBuffer sb , int width , int nextLineTabStop , String text ) { int pos = findWrapPos ( text , width , 0 ) ; if ( pos == - 1 ) { sb . append ( rtrim ( text ) ) ; return sb ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( defaultNewLine ) ; if ( nextLineTabStop >= width ) { nextLineTabStop = width - 1 ; } final String padding = createPadding ( nextLineTabStop ) ; while ( true ) { text = padding + text . substring ( pos ) . trim ( ) ; pos = findWrapPos ( text , width , 0 ) ; if ( pos == - 1 ) { sb . append ( text ) ; return sb ; } if ( ( text . length ( ) > width ) && ( pos == nextLineTabStop - 1 ) ) { pos = width ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( defaultNewLine ) ; } } ### 80 85 ### <s> nextLineTabStop = 1 ; </s>
test ### protected void processProperties ( Properties properties ) { if ( properties == null ) { return ; } for ( Enumeration e = properties . propertyNames ( ) ; e . hasMoreElements ( ) ; ) { String option = e . nextElement ( ) . toString ( ) ; if ( ! cmd . hasOption ( option ) ) { Option opt = getOptions ( ) . getOption ( option ) ; String value = properties . getProperty ( option ) ; if ( opt . hasArg ( ) ) { if ( opt . getValues ( ) == null opt . getValues ( ) . length == 0 ) { try { opt . addValueForProcessing ( value ) ; } catch ( RuntimeException exp ) { } } } else if ( ! ( "yes" . equalsIgnoreCase ( value ) "true" . equalsIgnoreCase ( value ) "1" . equalsIgnoreCase ( value ) ) ) { break ; } cmd . addOption ( opt ) ; } } } ### 157 158 ### <s> continue ; </s>
test ### public static < T > T createValue ( final String str , final Class < T > clazz ) throws ParseException { if ( PatternOptionBuilder . STRING_VALUE == clazz ) { return ( T ) str ; } else if ( PatternOptionBuilder . OBJECT_VALUE == clazz ) { return ( T ) createObject ( str ) ; } else if ( PatternOptionBuilder . NUMBER_VALUE == clazz ) { return ( T ) createNumber ( str ) ; } else if ( PatternOptionBuilder . DATE_VALUE == clazz ) { return ( T ) createDate ( str ) ; } else if ( PatternOptionBuilder . CLASS_VALUE == clazz ) { return ( T ) createClass ( str ) ; } else if ( PatternOptionBuilder . FILE_VALUE == clazz ) { return ( T ) createFile ( str ) ; } else if ( PatternOptionBuilder . EXISTING_FILE_VALUE == clazz ) { return ( T ) openFile ( str ) ; } else if ( PatternOptionBuilder . FILES_VALUE == clazz ) { return ( T ) createFiles ( str ) ; } else if ( PatternOptionBuilder . URL_VALUE == clazz ) { return ( T ) createURL ( str ) ; } else { return null ; } } ### 200 202 ### <s> throw new ParseException ( "Unable to handle the class: " + clazz ) ; </s>
test ### protected StringBuffer renderWrappedText ( StringBuffer sb , int width , int nextLineTabStop , String text ) { int pos = findWrapPos ( text , width , 0 ) ; if ( pos == - 1 ) { sb . append ( rtrim ( text ) ) ; return sb ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( defaultNewLine ) ; final String padding = createPadding ( nextLineTabStop ) ; while ( true ) { text = padding + text . substring ( pos ) . trim ( ) ; pos = findWrapPos ( text , width , nextLineTabStop ) ; if ( pos == - 1 ) { sb . append ( text ) ; return sb ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( defaultNewLine ) ; } } ### 102 112 ### <s> pos = findWrapPos ( text , width , 0 ) ; </s>
test ### static boolean mayBeString ( Node n , boolean recurse ) { if ( recurse ) { return allResultsMatch ( n , MAY_BE_STRING_PREDICATE ) ; } else { return mayBeStringHelper ( n ) ; } } ### 16 23 ### <s> return anyResultsMatch ( n , MAY_BE_STRING_PREDICATE ) ; </s>
test ### public void process ( Node externs , Node root ) { NodeTraversal . traverse ( compiler , root , this ) ; if ( MAKE_LOCAL_NAMES_UNIQUE ) { MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique ( ) ; NodeTraversal t = new NodeTraversal ( compiler , renamer ) ; t . traverseRoots ( externs , root ) ; } removeDuplicateDeclarations ( root ) ; new PropogateConstantAnnotations ( compiler , assertOnChange ) . process ( externs , root ) ; } ### 22 26 ### <s> removeDuplicateDeclarations ( root ) ; </s>
test ### JSType meet ( JSType that ) { UnionTypeBuilder builder = new UnionTypeBuilder ( registry ) ; for ( JSType alternate : alternates ) { if ( alternate . isSubtype ( that ) ) { builder . addAlternate ( alternate ) ; } } if ( that instanceof UnionType ) { for ( JSType otherAlternate : ( ( UnionType ) that ) . alternates ) { if ( otherAlternate . isSubtype ( this ) ) { builder . addAlternate ( otherAlternate ) ; } } } else if ( that . isSubtype ( this ) ) { builder . addAlternate ( that ) ; } JSType result = builder . build ( ) ; if ( result != null ) { return result ; } else if ( this . isObject ( ) && that . isObject ( ) ) { return getNativeType ( JSTypeNative . NO_OBJECT_TYPE ) ; } else { return getNativeType ( JSTypeNative . NO_TYPE ) ; } } ### 113 119 ### <s> if ( ! result . isNoType ( ) ) { </s>
test ### private void processRequireCall ( NodeTraversal t , Node n , Node parent ) { Node left = n . getFirstChild ( ) ; Node arg = left . getNext ( ) ; if ( verifyLastArgumentIsString ( t , left , arg ) ) { String ns = arg . getString ( ) ; ProvidedName provided = providedNames . get ( ns ) ; if ( provided == null ! provided . isExplicitlyProvided ( ) ) { unrecognizedRequires . add ( new UnrecognizedRequire ( n , ns , t . getSourceName ( ) ) ) ; } else { JSModule providedModule = provided . explicitModule ; Preconditions . checkNotNull ( providedModule ) ; JSModule module = t . getModule ( ) ; if ( moduleGraph != null && module != providedModule && ! moduleGraph . dependsOn ( module , providedModule ) ) { compiler . report ( t . makeError ( n , XMODULE_REQUIRE_ERROR , ns , providedModule . getName ( ) , module . getName ( ) ) ) ; } } maybeAddToSymbolTable ( left ) ; maybeAddStringNodeToSymbolTable ( arg ) ; if ( provided != null ) { parent . detachFromParent ( ) ; compiler . reportCodeChange ( ) ; } } } ### 182 188 ### <s> if ( provided != null  requiresLevel . isOn ( ) ) { </s>
test ### private void recordAssignment ( NodeTraversal t , Node n , Node recordNode ) { Node nameNode = n . getFirstChild ( ) ; Node parent = n . getParent ( ) ; NameInformation ns = createNameInformation ( t , nameNode ) ; if ( ns != null ) { if ( parent . isFor ( ) && ! NodeUtil . isForIn ( parent ) ) { if ( parent . getFirstChild ( ) . getNext ( ) != n ) { recordDepScope ( recordNode , ns ) ; } else { recordDepScope ( nameNode , ns ) ; } } else { recordDepScope ( recordNode , ns ) ; } } } ### 99 101 ### <s> } else if ( ! ( parent . isCall ( ) && parent . getFirstChild ( ) == n ) ) { </s>
test ### void add ( Node n , Context context ) { if ( ! cc . continueProcessing ( ) ) { return ; } int type = n . getType ( ) ; String opstr = NodeUtil . opToStr ( type ) ; int childCount = n . getChildCount ( ) ; Node first = n . getFirstChild ( ) ; Node last = n . getLastChild ( ) ; if ( opstr != null && first != last ) { Preconditions . checkState ( childCount == 2 , "Bad binary operator \"%s\": expected 2 arguments but got %s" , opstr , childCount ) ; int p = NodeUtil . precedence ( type ) ; Context rhsContext = getContextForNoInOperator ( context ) ; if ( last . getType ( ) == type && NodeUtil . isAssociative ( type ) ) { addExpr ( first , p , context ) ; cc . addOp ( opstr , true ) ; addExpr ( last , p , rhsContext ) ; } else if ( NodeUtil . isAssignmentOp ( n ) && NodeUtil . isAssignmentOp ( last ) ) { addExpr ( first , p , context ) ; cc . addOp ( opstr , true ) ; addExpr ( last , p , rhsContext ) ; } else { unrollBinaryOperator ( n , type , opstr , context , rhsContext , p , p + 1 ) ; } return ; } cc . startSourceMapping ( n ) ; switch ( type ) { case Token . TRY : { Preconditions . checkState ( first . getNext ( ) . isBlock ( ) && ! first . getNext ( ) . hasMoreThanOneChild ( ) ) ; Preconditions . checkState ( childCount >= 2 && childCount <= 3 ) ; add ( "try" ) ; add ( first , Context . PRESERVE_BLOCK ) ; Node catchblock = first . getNext ( ) . getFirstChild ( ) ; if ( catchblock != null ) { add ( catchblock ) ; } if ( childCount == 3 ) { add ( "finally" ) ; add ( last , Context . PRESERVE_BLOCK ) ; } break ; } case Token . CATCH : Preconditions . checkState ( childCount == 2 ) ; add ( "catch(" ) ; add ( first ) ; add ( ")" ) ; add ( last , Context . PRESERVE_BLOCK ) ; break ; case Token . THROW : Preconditions . checkState ( childCount == 1 ) ; add ( "throw" ) ; add ( first ) ; cc . endStatement ( true ) ; break ; case Token . RETURN : add ( "return" ) ; if ( childCount == 1 ) { add ( first ) ; } else { Preconditions . checkState ( childCount == 0 ) ; } cc . endStatement ( ) ; break ; case Token . VAR : if ( first != null ) { add ( "var " ) ; addList ( first , false , getContextForNoInOperator ( context ) ) ; } break ; case Token . LABEL_NAME : Preconditions . checkState ( ! n . getString ( ) . isEmpty ( ) ) ; addIdentifier ( n . getString ( ) ) ; break ; case Token . NAME : if ( first == null first . isEmpty ( ) ) { addIdentifier ( n . getString ( ) ) ; } else { Preconditions . checkState ( childCount == 1 ) ; addIdentifier ( n . getString ( ) ) ; cc . addOp ( "=" , true ) ; if ( first . isComma ( ) ) { addExpr ( first , NodeUtil . precedence ( Token . ASSIGN ) , Context . OTHER ) ; } else { addExpr ( first , 0 , getContextForNoInOperator ( context ) ) ; } } break ; case Token . ARRAYLIT : add ( "[" ) ; addArrayList ( first ) ; add ( "]" ) ; break ; case Token . PARAM_LIST : add ( "(" ) ; addList ( first ) ; add ( ")" ) ; break ; case Token . COMMA : Preconditions . checkState ( childCount == 2 ) ; unrollBinaryOperator ( n , Token . COMMA , "," , context , getContextForNoInOperator ( context ) , 0 , 0 ) ; break ; case Token . NUMBER : Preconditions . checkState ( childCount == 0 ) ; cc . addNumber ( n . getDouble ( ) ) ; break ; case Token . TYPEOF : case Token . VOID : case Token . NOT : case Token . BITNOT : case Token . POS : { Preconditions . checkState ( childCount == 1 ) ; cc . addOp ( NodeUtil . opToStrNoFail ( type ) , false ) ; addExpr ( first , NodeUtil . precedence ( type ) , Context . OTHER ) ; break ; } case Token . NEG : { Preconditions . checkState ( childCount == 1 ) ; if ( n . getFirstChild ( ) . isNumber ( ) ) { cc . addNumber ( - n . getFirstChild ( ) . getDouble ( ) ) ; } else { cc . addOp ( NodeUtil . opToStrNoFail ( type ) , false ) ; addExpr ( first , NodeUtil . precedence ( type ) , Context . OTHER ) ; } break ; } case Token . HOOK : { Preconditions . checkState ( childCount == 3 ) ; int p = NodeUtil . precedence ( type ) ; Context rhsContext = Context . OTHER ; addExpr ( first , p + 1 , context ) ; cc . addOp ( "?" , true ) ; addExpr ( first . getNext ( ) , 1 , rhsContext ) ; cc . addOp ( ":" , true ) ; addExpr ( last , 1 , rhsContext ) ; break ; } case Token . REGEXP : if ( ! first . isString ( ) ! last . isString ( ) ) { throw new Error ( "Expected children to be strings" ) ; } String regexp = regexpEscape ( first . getString ( ) , outputCharsetEncoder ) ; if ( childCount == 2 ) { add ( regexp + last . getString ( ) ) ; } else { Preconditions . checkState ( childCount == 1 ) ; add ( regexp ) ; } break ; case Token . FUNCTION : if ( n . getClass ( ) != Node . class ) { throw new Error ( "Unexpected Node subclass." ) ; } Preconditions . checkState ( childCount == 3 ) ; boolean funcNeedsParens = ( context == Context . START_OF_EXPR ) ; if ( funcNeedsParens ) { add ( "(" ) ; } add ( "function" ) ; add ( first ) ; add ( first . getNext ( ) ) ; add ( last , Context . PRESERVE_BLOCK ) ; cc . endFunction ( context == Context . STATEMENT ) ; if ( funcNeedsParens ) { add ( ")" ) ; } break ; case Token . GETTER_DEF : case Token . SETTER_DEF : Preconditions . checkState ( n . getParent ( ) . isObjectLit ( ) ) ; Preconditions . checkState ( childCount == 1 ) ; Preconditions . checkState ( first . isFunction ( ) ) ; Preconditions . checkState ( first . getFirstChild ( ) . getString ( ) . isEmpty ( ) ) ; if ( type == Token . GETTER_DEF ) { Preconditions . checkState ( ! first . getChildAtIndex ( 1 ) . hasChildren ( ) ) ; add ( "get " ) ; } else { Preconditions . checkState ( first . getChildAtIndex ( 1 ) . hasOneChild ( ) ) ; add ( "set " ) ; } String name = n . getString ( ) ; Node fn = first ; Node parameters = fn . getChildAtIndex ( 1 ) ; Node body = fn . getLastChild ( ) ; if ( ! n . isQuotedString ( ) && TokenStream . isJSIdentifier ( name ) && NodeUtil . isLatin ( name ) ) { add ( name ) ; } else { double d = getSimpleNumber ( name ) ; if ( ! Double . isNaN ( d ) ) { cc . addNumber ( d ) ; } else { addJsString ( n ) ; } } add ( parameters ) ; add ( body , Context . PRESERVE_BLOCK ) ; break ; case Token . SCRIPT : case Token . BLOCK : { if ( n . getClass ( ) != Node . class ) { throw new Error ( "Unexpected Node subclass." ) ; } boolean preserveBlock = context == Context . PRESERVE_BLOCK ; if ( preserveBlock ) { cc . beginBlock ( ) ; } boolean preferLineBreaks = type == Token . SCRIPT ( type == Token . BLOCK && ! preserveBlock && n . getParent ( ) != null && n . getParent ( ) . isScript ( ) ) ; for ( Node c = first ; c != null ; c = c . getNext ( ) ) { add ( c , Context . STATEMENT ) ; if ( c . isVar ( ) ) { cc . endStatement ( ) ; } if ( c . isFunction ( ) ) { cc . maybeLineBreak ( ) ; } if ( preferLineBreaks ) { cc . notePreferredLineBreak ( ) ; } } if ( preserveBlock ) { cc . endBlock ( cc . breakAfterBlockFor ( n , context == Context . STATEMENT ) ) ; } break ; } case Token . FOR : if ( childCount == 4 ) { add ( "for(" ) ; if ( first . isVar ( ) ) { add ( first , Context . IN_FOR_INIT_CLAUSE ) ; } else { addExpr ( first , 0 , Context . IN_FOR_INIT_CLAUSE ) ; } add ( ";" ) ; add ( first . getNext ( ) ) ; add ( ";" ) ; add ( first . getNext ( ) . getNext ( ) ) ; add ( ")" ) ; addNonEmptyStatement ( last , getContextForNonEmptyExpression ( context ) , false ) ; } else { Preconditions . checkState ( childCount == 3 ) ; add ( "for(" ) ; add ( first ) ; add ( "in" ) ; add ( first . getNext ( ) ) ; add ( ")" ) ; addNonEmptyStatement ( last , getContextForNonEmptyExpression ( context ) , false ) ; } break ; case Token . DO : Preconditions . checkState ( childCount == 2 ) ; add ( "do" ) ; addNonEmptyStatement ( first , Context . OTHER , false ) ; add ( "while(" ) ; add ( last ) ; add ( ")" ) ; cc . endStatement ( ) ; break ; case Token . WHILE : Preconditions . checkState ( childCount == 2 ) ; add ( "while(" ) ; add ( first ) ; add ( ")" ) ; addNonEmptyStatement ( last , getContextForNonEmptyExpression ( context ) , false ) ; break ; case Token . EMPTY : Preconditions . checkState ( childCount == 0 ) ; break ; case Token . GETPROP : { Preconditions . checkState ( childCount == 2 , "Bad GETPROP: expected 2 children, but got %s" , childCount ) ; Preconditions . checkState ( last . isString ( ) , "Bad GETPROP: RHS should be STRING" ) ; boolean needsParens = ( first . isNumber ( ) ) ; if ( needsParens ) { add ( "(" ) ; } addExpr ( first , NodeUtil . precedence ( type ) , context ) ; if ( needsParens ) { add ( ")" ) ; } if ( this . languageMode == LanguageMode . ECMASCRIPT3 && TokenStream . isKeyword ( last . getString ( ) ) ) { add ( "[" ) ; add ( last ) ; add ( "]" ) ; } else { add ( "." ) ; addIdentifier ( last . getString ( ) ) ; } break ; } case Token . GETELEM : Preconditions . checkState ( childCount == 2 , "Bad GETELEM: expected 2 children but got %s" , childCount ) ; addExpr ( first , NodeUtil . precedence ( type ) , context ) ; add ( "[" ) ; add ( first . getNext ( ) ) ; add ( "]" ) ; break ; case Token . WITH : Preconditions . checkState ( childCount == 2 ) ; add ( "with(" ) ; add ( first ) ; add ( ")" ) ; addNonEmptyStatement ( last , getContextForNonEmptyExpression ( context ) , false ) ; break ; case Token . INC : case Token . DEC : { Preconditions . checkState ( childCount == 1 ) ; String o = type == Token . INC ? "++" : "--" ; int postProp = n . getIntProp ( Node . INCRDECR_PROP ) ; if ( postProp != 0 ) { addExpr ( first , NodeUtil . precedence ( type ) , context ) ; cc . addOp ( o , false ) ; } else { cc . addOp ( o , false ) ; add ( first ) ; } break ; } case Token . CALL : if ( isIndirectEval ( first ) n . getBooleanProp ( Node . FREE_CALL ) && NodeUtil . isGet ( first ) ) { add ( "(0," ) ; addExpr ( first , NodeUtil . precedence ( Token . COMMA ) , Context . OTHER ) ; add ( ")" ) ; } else { addExpr ( first , NodeUtil . precedence ( type ) , context ) ; } add ( "(" ) ; addList ( first . getNext ( ) ) ; add ( ")" ) ; break ; case Token . IF : boolean hasElse = childCount == 3 ; boolean ambiguousElseClause = context == Context . BEFORE_DANGLING_ELSE && ! hasElse ; if ( ambiguousElseClause ) { cc . beginBlock ( ) ; } add ( "if(" ) ; add ( first ) ; add ( ")" ) ; if ( hasElse ) { addNonEmptyStatement ( first . getNext ( ) , Context . BEFORE_DANGLING_ELSE , false ) ; add ( "else" ) ; addNonEmptyStatement ( last , getContextForNonEmptyExpression ( context ) , false ) ; } else { addNonEmptyStatement ( first . getNext ( ) , Context . OTHER , false ) ; Preconditions . checkState ( childCount == 2 ) ; } if ( ambiguousElseClause ) { cc . endBlock ( ) ; } break ; case Token . NULL : Preconditions . checkState ( childCount == 0 ) ; cc . addConstant ( "null" ) ; break ; case Token . THIS : Preconditions . checkState ( childCount == 0 ) ; add ( "this" ) ; break ; case Token . FALSE : Preconditions . checkState ( childCount == 0 ) ; cc . addConstant ( "false" ) ; break ; case Token . TRUE : Preconditions . checkState ( childCount == 0 ) ; cc . addConstant ( "true" ) ; break ; case Token . CONTINUE : Preconditions . checkState ( childCount <= 1 ) ; add ( "continue" ) ; if ( childCount == 1 ) { if ( ! first . isLabelName ( ) ) { throw new Error ( "Unexpected token type. Should be LABEL_NAME." ) ; } add ( " " ) ; add ( first ) ; } cc . endStatement ( ) ; break ; case Token . DEBUGGER : Preconditions . checkState ( childCount == 0 ) ; add ( "debugger" ) ; cc . endStatement ( ) ; break ; case Token . BREAK : Preconditions . checkState ( childCount <= 1 ) ; add ( "break" ) ; if ( childCount == 1 ) { if ( ! first . isLabelName ( ) ) { throw new Error ( "Unexpected token type. Should be LABEL_NAME." ) ; } add ( " " ) ; add ( first ) ; } cc . endStatement ( ) ; break ; case Token . EXPR_RESULT : Preconditions . checkState ( childCount == 1 ) ; add ( first , Context . START_OF_EXPR ) ; cc . endStatement ( ) ; break ; case Token . NEW : add ( "new " ) ; int precedence = NodeUtil . precedence ( type ) ; if ( NodeUtil . containsType ( first , Token . CALL , NodeUtil . MATCH_NOT_FUNCTION ) ) { precedence = NodeUtil . precedence ( first . getType ( ) ) + 1 ; } addExpr ( first , precedence , Context . OTHER ) ; Node next = first . getNext ( ) ; if ( next != null ) { add ( "(" ) ; addList ( next ) ; add ( ")" ) ; } break ; case Token . STRING_KEY : Preconditions . checkState ( childCount == 1 , "Object lit key must have 1 child" ) ; addJsString ( n ) ; break ; case Token . STRING : Preconditions . checkState ( childCount == 0 , "A string may not have children" ) ; addJsString ( n ) ; break ; case Token . DELPROP : Preconditions . checkState ( childCount == 1 ) ; add ( "delete " ) ; add ( first ) ; break ; case Token . OBJECTLIT : { boolean needsParens = ( context == Context . START_OF_EXPR ) ; if ( needsParens ) { add ( "(" ) ; } add ( "{" ) ; for ( Node c = first ; c != null ; c = c . getNext ( ) ) { if ( c != first ) { cc . listSeparator ( ) ; } if ( c . isGetterDef ( ) c . isSetterDef ( ) ) { add ( c ) ; } else { Preconditions . checkState ( c . isStringKey ( ) ) ; String key = c . getString ( ) ; if ( ! c . isQuotedString ( ) && ! ( languageMode == LanguageMode . ECMASCRIPT3 && TokenStream . isKeyword ( key ) ) && TokenStream . isJSIdentifier ( key ) && NodeUtil . isLatin ( key ) ) { add ( key ) ; } else { double d = getSimpleNumber ( key ) ; if ( ! Double . isNaN ( d ) ) { cc . addNumber ( d ) ; } else { addExpr ( c , 1 , Context . OTHER ) ; } } add ( ":" ) ; addExpr ( c . getFirstChild ( ) , 1 , Context . OTHER ) ; } } add ( "}" ) ; if ( needsParens ) { add ( ")" ) ; } break ; } case Token . SWITCH : add ( "switch(" ) ; add ( first ) ; add ( ")" ) ; cc . beginBlock ( ) ; addAllSiblings ( first . getNext ( ) ) ; cc . endBlock ( context == Context . STATEMENT ) ; break ; case Token . CASE : Preconditions . checkState ( childCount == 2 ) ; add ( "case " ) ; add ( first ) ; addCaseBody ( last ) ; break ; case Token . DEFAULT_CASE : Preconditions . checkState ( childCount == 1 ) ; add ( "default" ) ; addCaseBody ( first ) ; break ; case Token . LABEL : Preconditions . checkState ( childCount == 2 ) ; if ( ! first . isLabelName ( ) ) { throw new Error ( "Unexpected token type. Should be LABEL_NAME." ) ; } add ( first ) ; add ( ":" ) ; addNonEmptyStatement ( last , getContextForNonEmptyExpression ( context ) , true ) ; break ; case Token . CAST : add ( "(" ) ; add ( first ) ; add ( ")" ) ; break ; default : throw new Error ( "Unknown type " + type + "\n" + n . toStringTree ( ) ) ; } cc . endSourceMapping ( n ) ; } ### 927 933 ### <s> Context rhsContext = getContextForNoInOperator ( context ) ; </s>
test ### private void visitNew ( NodeTraversal t , Node n ) { Node constructor = n . getFirstChild ( ) ; JSType type = getJSType ( constructor ) . restrictByNotNullOrUndefined ( ) ; if ( type . isConstructor ( ) type . isEmptyType ( ) type . isUnknownType ( ) ) { FunctionType fnType = type . toMaybeFunctionType ( ) ; if ( fnType != null ) { visitParameterList ( t , n , fnType ) ; ensureTyped ( t , n , fnType . getInstanceType ( ) ) ; } else { ensureTyped ( t , n ) ; } } else { report ( t , n , NOT_A_CONSTRUCTOR ) ; ensureTyped ( t , n ) ; } } ### 60 66 ### <s> if ( fnType != null && fnType . hasInstanceType ( ) ) { </s>
test ### private void traverse ( Node node ) { if ( ! shouldVisit ( node ) ) { return ; } int visits = 0 ; do { Node c = node . getFirstChild ( ) ; while ( c != null ) { traverse ( c ) ; Node next = c . getNext ( ) ; c = next ; } visit ( node ) ; visits ++ ; Preconditions . checkState ( visits < 10000 , "too many interations" ) ; } while ( shouldRetraverse ( node ) ) ; exitNode ( node ) ; } ### 43 47 ### <s> Node next = c . getNext ( ) ; </s>
test ### private void inlineAliases ( GlobalNamespace namespace ) { Deque < Name > workList = new ArrayDeque < Name > ( namespace . getNameForest ( ) ) ; while ( ! workList . isEmpty ( ) ) { Name name = workList . pop ( ) ; if ( name . type == Name . Type . GET name . type == Name . Type . SET ) { continue ; } if ( name . globalSets == 1 && name . localSets == 0 && name . aliasingGets > 0 ) { List < Ref > refs = Lists . newArrayList ( name . getRefs ( ) ) ; for ( Ref ref : refs ) { if ( ref . type == Type . ALIASING_GET && ref . scope . isLocal ( ) ) { if ( inlineAliasIfPossible ( ref , namespace ) ) { name . removeRef ( ref ) ; } } } } if ( ( name . type == Name . Type . OBJECTLIT name . type == Name . Type . FUNCTION ) && name . aliasingGets == 0 && name . props != null ) { workList . addAll ( name . props ) ; } } } ### 71 84 ### <s> if ( ! name . inExterns && name . globalSets == 1 && name . localSets == 0 && </s>
test ### private static Node computeFollowNode ( Node fromNode , Node node , ControlFlowAnalysis cfa ) { Node parent = node . getParent ( ) ; if ( parent == null parent . isFunction ( ) ( cfa != null && node == cfa . root ) ) { return null ; } switch ( parent . getType ( ) ) { case Token . IF : return computeFollowNode ( fromNode , parent , cfa ) ; case Token . CASE : case Token . DEFAULT_CASE : if ( parent . getNext ( ) != null ) { if ( parent . getNext ( ) . isCase ( ) ) { return parent . getNext ( ) . getFirstChild ( ) . getNext ( ) ; } else if ( parent . getNext ( ) . isDefaultCase ( ) ) { return parent . getNext ( ) . getFirstChild ( ) ; } else { Preconditions . checkState ( false , "Not reachable" ) ; } } else { return computeFollowNode ( fromNode , parent , cfa ) ; } break ; case Token . FOR : if ( NodeUtil . isForIn ( parent ) ) { return parent ; } else { return parent . getFirstChild ( ) . getNext ( ) . getNext ( ) ; } case Token . WHILE : case Token . DO : return parent ; case Token . TRY : if ( parent . getFirstChild ( ) == node ) { if ( NodeUtil . hasFinally ( parent ) ) { return computeFallThrough ( parent . getLastChild ( ) ) ; } else { return computeFollowNode ( fromNode , parent , cfa ) ; } } else if ( NodeUtil . getCatchBlock ( parent ) == node ) { if ( NodeUtil . hasFinally ( parent ) ) { return computeFallThrough ( node . getNext ( ) ) ; } else { return computeFollowNode ( fromNode , parent , cfa ) ; } } else if ( parent . getLastChild ( ) == node ) { if ( cfa != null ) { for ( Node finallyNode : cfa . finallyMap . get ( parent ) ) { cfa . createEdge ( fromNode , Branch . UNCOND , finallyNode ) ; } } return computeFollowNode ( fromNode , parent , cfa ) ; } } Node nextSibling = node . getNext ( ) ; while ( nextSibling != null && nextSibling . isFunction ( ) ) { nextSibling = nextSibling . getNext ( ) ; } if ( nextSibling != null ) { return computeFallThrough ( nextSibling ) ; } else { return computeFollowNode ( fromNode , parent , cfa ) ; } } ### 363 375 ### <s> cfa . createEdge ( fromNode , Branch . ON_EX , finallyNode ) ; </s>
test ### @ Override public void visit ( NodeTraversal t , Node n , Node parent ) { if ( t . inGlobalScope ( ) ) { return ; } if ( n . isReturn ( ) && n . getFirstChild ( ) != null ) { data . get ( t . getScopeRoot ( ) ) . recordNonEmptyReturn ( ) ; } if ( t . getScopeDepth ( ) <= 2 ) { return ; } if ( n . isName ( ) && NodeUtil . isLValue ( n ) && ! NodeUtil . isBleedingFunctionName ( n ) ) { String name = n . getString ( ) ; Scope scope = t . getScope ( ) ; Var var = scope . getVar ( name ) ; if ( var != null ) { Scope ownerScope = var . getScope ( ) ; if ( ownerScope . isLocal ( ) ) { data . get ( ownerScope . getRootNode ( ) ) . recordAssignedName ( name ) ; } if ( scope != ownerScope && ownerScope . isLocal ( ) ) { data . get ( ownerScope . getRootNode ( ) ) . recordEscapedVarName ( name ) ; } } } else if ( n . isGetProp ( ) && n . isUnscopedQualifiedName ( ) && NodeUtil . isLValue ( n ) ) { String name = NodeUtil . getRootOfQualifiedName ( n ) . getString ( ) ; Scope scope = t . getScope ( ) ; Var var = scope . getVar ( name ) ; if ( var != null ) { Scope ownerScope = var . getScope ( ) ; if ( scope != ownerScope && ownerScope . isLocal ( ) ) { data . get ( ownerScope . getRootNode ( ) ) . recordEscapedQualifiedName ( n . getQualifiedName ( ) ) ; } } } } ### 61 71 ### <s> if ( t . getScopeDepth ( ) <= 1 ) { </s>
test ### Node parseInputs ( ) { boolean devMode = options . devMode != DevMode . OFF ; if ( externsRoot != null ) { externsRoot . detachChildren ( ) ; } if ( jsRoot != null ) { jsRoot . detachChildren ( ) ; } jsRoot = IR . block ( ) ; jsRoot . setIsSyntheticBlock ( true ) ; externsRoot = IR . block ( ) ; externsRoot . setIsSyntheticBlock ( true ) ; externAndJsRoot = IR . block ( externsRoot , jsRoot ) ; externAndJsRoot . setIsSyntheticBlock ( true ) ; if ( options . tracer . isOn ( ) ) { tracker = new PerformanceTracker ( jsRoot , options . tracer ) ; addChangeHandler ( tracker . getCodeChangeHandler ( ) ) ; } Tracer tracer = newTracer ( "parseInputs" ) ; try { for ( CompilerInput input : externs ) { Node n = input . getAstRoot ( this ) ; if ( hasErrors ( ) ) { return null ; } externsRoot . addChildToBack ( n ) ; } if ( options . transformAMDToCJSModules options . processCommonJSModules ) { processAMDAndCommonJSModules ( ) ; } hoistExterns ( externsRoot ) ; boolean staleInputs = false ; if ( options . dependencyOptions . needsManagement ( ) && options . closurePass ) { for ( CompilerInput input : inputs ) { for ( String provide : input . getProvides ( ) ) { getTypeRegistry ( ) . forwardDeclareType ( provide ) ; } } try { inputs = ( moduleGraph == null ? new JSModuleGraph ( modules ) : moduleGraph ) . manageDependencies ( options . dependencyOptions , inputs ) ; staleInputs = true ; } catch ( CircularDependencyException e ) { report ( JSError . make ( JSModule . CIRCULAR_DEPENDENCY_ERROR , e . getMessage ( ) ) ) ; if ( hasErrors ( ) ) { return null ; } } catch ( MissingProvideException e ) { report ( JSError . make ( MISSING_ENTRY_ERROR , e . getMessage ( ) ) ) ; if ( hasErrors ( ) ) { return null ; } } } hoistNoCompileFiles ( ) ; if ( staleInputs ) { repartitionInputs ( ) ; } for ( CompilerInput input : inputs ) { Node n = input . getAstRoot ( this ) ; if ( n == null ) { continue ; } if ( devMode ) { runSanityCheck ( ) ; if ( hasErrors ( ) ) { return null ; } } if ( options . sourceMapOutputPath != null options . nameReferenceReportPath != null ) { SourceInformationAnnotator sia = new SourceInformationAnnotator ( input . getName ( ) , options . devMode != DevMode . OFF ) ; NodeTraversal . traverse ( this , n , sia ) ; } jsRoot . addChildToBack ( n ) ; } if ( hasErrors ( ) ) { return null ; } return externAndJsRoot ; } finally { stopTracer ( tracer , "parseInputs" ) ; } } ### 197 211 ### <s> if ( options . dependencyOptions . needsManagement ( ) ) { </s>
test ### void addNumber ( double x ) { char prev = getLastChar ( ) ; boolean negativeZero = isNegativeZero ( x ) ; if ( x < 0 && prev == '-' ) { add ( " " ) ; } if ( ( long ) x == x && ! negativeZero ) { long value = ( long ) x ; long mantissa = value ; int exp = 0 ; if ( Math . abs ( x ) >= 100 ) { while ( mantissa / 10 * Math . pow ( 10 , exp + 1 ) == value ) { mantissa /= 10 ; exp ++ ; } } if ( exp > 2 ) { add ( Long . toString ( mantissa ) + "E" + Integer . toString ( exp ) ) ; } else { add ( Long . toString ( value ) ) ; } } else { add ( String . valueOf ( x ) ) ; } } ### 22 32 ### <s> if ( ( x < 0  negativeZero ) && prev == '-' ) { </s>
test ### static boolean isSimpleNumber ( String s ) { int len = s . length ( ) ; for ( int index = 0 ; index < len ; index ++ ) { char c = s . charAt ( index ) ; if ( c < '0' c > '9' ) { return false ; } } return len > 0 ; } ### 57 61 ### <s> return len > 0 && s . charAt ( 0 ) != '0' ; </s>
test ### private static String extractClassNameIfGoog ( Node node , Node parent , String functionName ) { String className = null ; if ( NodeUtil . isExprCall ( parent ) ) { Node callee = node . getFirstChild ( ) ; if ( callee != null && callee . getType ( ) == Token . GETPROP ) { String qualifiedName = callee . getQualifiedName ( ) ; if ( functionName . equals ( qualifiedName ) ) { Node target = callee . getNext ( ) ; if ( target != null ) { className = target . getString ( ) ; } } } } return className ; } ### 84 90 ### <s> if ( target != null && target . getType ( ) == Token . STRING ) { </s>
test ### private String format ( JSError error , boolean warning ) { SourceExcerptProvider source = getSource ( ) ; String sourceExcerpt = source == null ? null : excerpt . get ( source , error . sourceName , error . lineNumber , excerptFormatter ) ; StringBuilder b = new StringBuilder ( ) ; if ( error . sourceName != null ) { b . append ( error . sourceName ) ; if ( error . lineNumber > 0 ) { b . append ( ':' ) ; b . append ( error . lineNumber ) ; } b . append ( ": " ) ; } b . append ( getLevelName ( warning ? CheckLevel . WARNING : CheckLevel . ERROR ) ) ; b . append ( " - " ) ; b . append ( error . description ) ; b . append ( '\n' ) ; if ( sourceExcerpt != null ) { b . append ( sourceExcerpt ) ; b . append ( '\n' ) ; int charno = error . getCharno ( ) ; if ( excerpt . equals ( LINE ) && 0 <= charno && charno < sourceExcerpt . length ( ) ) { for ( int i = 0 ; i < charno ; i ++ ) { char c = sourceExcerpt . charAt ( i ) ; if ( Character . isWhitespace ( c ) ) { b . append ( c ) ; } else { b . append ( ' ' ) ; } } b . append ( "^\n" ) ; } } return b . toString ( ) ; } ### 186 199 ### <s> && 0 <= charno && charno <= sourceExcerpt . length ( ) ) { </s>
test ### static String strEscape ( String s , char quote , String doublequoteEscape , String singlequoteEscape , String backslashEscape , CharsetEncoder outputCharsetEncoder ) { StringBuilder sb = new StringBuilder ( s . length ( ) + 2 ) ; sb . append ( quote ) ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { char c = s . charAt ( i ) ; switch ( c ) { case '\0' : sb . append ( "\\0" ) ; break ; case '\n' : sb . append ( "\\n" ) ; break ; case '\r' : sb . append ( "\\r" ) ; break ; case '\t' : sb . append ( "\\t" ) ; break ; case '\\' : sb . append ( backslashEscape ) ; break ; case '\"' : sb . append ( doublequoteEscape ) ; break ; case '\'' : sb . append ( singlequoteEscape ) ; break ; case '>' : if ( i >= 2 && ( ( s . charAt ( i - 1 ) == '-' && s . charAt ( i - 2 ) == '-' ) ( s . charAt ( i - 1 ) == ']' && s . charAt ( i - 2 ) == ']' ) ) ) { sb . append ( "\\>" ) ; } else { sb . append ( c ) ; } break ; case '<' : final String END_SCRIPT = "/script" ; final String START_COMMENT = "!--" ; if ( s . regionMatches ( true , i + 1 , END_SCRIPT , 0 , END_SCRIPT . length ( ) ) ) { sb . append ( "<\\" ) ; } else if ( s . regionMatches ( false , i + 1 , START_COMMENT , 0 , START_COMMENT . length ( ) ) ) { sb . append ( "<\\" ) ; } else { sb . append ( c ) ; } break ; default : if ( outputCharsetEncoder != null ) { if ( outputCharsetEncoder . canEncode ( c ) ) { sb . append ( c ) ; } else { appendHexJavaScriptRepresentation ( sb , c ) ; } } else { if ( c > 0x1f && c < 0x7f ) { sb . append ( c ) ; } else { appendHexJavaScriptRepresentation ( sb , c ) ; } } } } sb . append ( quote ) ; return sb . toString ( ) ; } ### 79 90 ### <s> case '\0' : sb . append ( "\\000" ) ; break ; </s>
test ### private boolean isPrototypePropertyAssign ( Node assign ) { Node n = assign . getFirstChild ( ) ; if ( n != null && NodeUtil . isVarOrSimpleAssignLhs ( n , assign ) && n . getType ( ) == Token . GETPROP ) { boolean isChainedProperty = n . getFirstChild ( ) . getType ( ) == Token . GETPROP ; if ( isChainedProperty ) { Node child = n . getFirstChild ( ) . getFirstChild ( ) . getNext ( ) ; if ( child . getType ( ) == Token . STRING && child . getString ( ) . equals ( "prototype" ) ) { return true ; } } } return false ; } ### 41 42 ### <s> && assign . getParent ( ) . getType ( ) == Token . EXPR_RESULT ) { </s>
test ### private void declareArguments ( Node functionNode ) { Node astParameters = functionNode . getFirstChild ( ) . getNext ( ) ; Node body = astParameters . getNext ( ) ; FunctionType functionType = ( FunctionType ) functionNode . getJSType ( ) ; if ( functionType != null ) { Node jsDocParameters = functionType . getParametersNode ( ) ; if ( jsDocParameters != null ) { Node jsDocParameter = jsDocParameters . getFirstChild ( ) ; for ( Node astParameter : astParameters . children ( ) ) { if ( jsDocParameter != null ) { defineSlot ( astParameter , functionNode , jsDocParameter . getJSType ( ) , true ) ; jsDocParameter = jsDocParameter . getNext ( ) ; } else { defineSlot ( astParameter , functionNode , null , true ) ; } } } } } } static JSDocInfo getBestJSDocInfo ( Node n ) { JSDocInfo info = n . getJSDocInfo ( ) ; if ( info == null ) { Node parent = n . getParent ( ) ; int parentType = parent . getType ( ) ; if ( parentType == Token . NAME ) { info = parent . getJSDocInfo ( ) ; if ( info == null && parent . getParent ( ) . hasOneChild ( ) ) { info = parent . getParent ( ) . getJSDocInfo ( ) ; } } else if ( parentType == Token . ASSIGN ) { info = parent . getJSDocInfo ( ) ; } else if ( NodeUtil . isObjectLitKey ( parent , parent . getParent ( ) ) ) { info = parent . getJSDocInfo ( ) ; } } ### 99 107 ### <s> jsDocParameter . getJSType ( ) , false ) ; </s>
test ### private void checkPropertyVisibility ( NodeTraversal t , Node getprop , Node parent ) { ObjectType objectType = ObjectType . cast ( dereference ( getprop . getFirstChild ( ) . getJSType ( ) ) ) ; String propertyName = getprop . getLastChild ( ) . getString ( ) ; if ( objectType != null ) { boolean isOverride = t . inGlobalScope ( ) && parent . getType ( ) == Token . ASSIGN && parent . getFirstChild ( ) == getprop ; if ( isOverride ) { objectType = objectType . getImplicitPrototype ( ) ; } JSDocInfo docInfo = null ; for ( ; objectType != null ; objectType = objectType . getImplicitPrototype ( ) ) { docInfo = objectType . getOwnPropertyJSDocInfo ( propertyName ) ; if ( docInfo != null && docInfo . getVisibility ( ) != Visibility . INHERITED ) { break ; } } if ( objectType == null ) { return ; } boolean sameInput = t . getInput ( ) . getName ( ) . equals ( docInfo . getSourceName ( ) ) ; Visibility visibility = docInfo . getVisibility ( ) ; JSType ownerType = normalizeClassType ( objectType ) ; if ( isOverride ) { JSDocInfo overridingInfo = parent . getJSDocInfo ( ) ; Visibility overridingVisibility = overridingInfo == null ? Visibility . INHERITED : overridingInfo . getVisibility ( ) ; if ( visibility == Visibility . PRIVATE && ! sameInput ) { compiler . report ( t . makeError ( getprop , PRIVATE_OVERRIDE , objectType . toString ( ) ) ) ; } else if ( overridingVisibility != Visibility . INHERITED && overridingVisibility != visibility ) { compiler . report ( t . makeError ( getprop , VISIBILITY_MISMATCH , visibility . name ( ) , objectType . toString ( ) , overridingVisibility . name ( ) ) ) ; } } else { if ( sameInput ) { return ; } else if ( visibility == Visibility . PRIVATE && ( currentClass == null ownerType . differsFrom ( currentClass ) ) ) { if ( docInfo . isConstructor ( ) && isValidPrivateConstructorAccess ( parent ) ) { return ; } compiler . report ( t . makeError ( getprop , BAD_PRIVATE_PROPERTY_ACCESS , propertyName , validator . getReadableJSTypeName ( getprop . getFirstChild ( ) , true ) ) ) ; } else if ( visibility == Visibility . PROTECTED ) { if ( currentClass == null ! currentClass . isSubtype ( ownerType ) ) { compiler . report ( t . makeError ( getprop , BAD_PROTECTED_PROPERTY_ACCESS , propertyName , validator . getReadableJSTypeName ( getprop . getFirstChild ( ) , true ) ) ) ; } } } } } ### 55 63 ### <s> boolean isOverride = parent . getJSDocInfo ( ) != null && </s>
test ### static String strEscape ( String s , char quote , String doublequoteEscape , String singlequoteEscape , String backslashEscape , CharsetEncoder outputCharsetEncoder ) { StringBuilder sb = new StringBuilder ( s . length ( ) + 2 ) ; sb . append ( quote ) ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { char c = s . charAt ( i ) ; switch ( c ) { case '\0' : sb . append ( "\\0" ) ; break ; case '\n' : sb . append ( "\\n" ) ; break ; case '\r' : sb . append ( "\\r" ) ; break ; case '\t' : sb . append ( "\\t" ) ; break ; case '\\' : sb . append ( backslashEscape ) ; break ; case '\"' : sb . append ( doublequoteEscape ) ; break ; case '\'' : sb . append ( singlequoteEscape ) ; break ; case '>' : if ( i >= 2 && ( ( s . charAt ( i - 1 ) == '-' && s . charAt ( i - 2 ) == '-' ) ( s . charAt ( i - 1 ) == ']' && s . charAt ( i - 2 ) == ']' ) ) ) { sb . append ( "\\>" ) ; } else { sb . append ( c ) ; } break ; case '<' : final String END_SCRIPT = "/script" ; final String START_COMMENT = "!--" ; if ( s . regionMatches ( true , i + 1 , END_SCRIPT , 0 , END_SCRIPT . length ( ) ) ) { sb . append ( "<\\" ) ; } else if ( s . regionMatches ( false , i + 1 , START_COMMENT , 0 , START_COMMENT . length ( ) ) ) { sb . append ( "<\\" ) ; } else { sb . append ( c ) ; } break ; default : if ( outputCharsetEncoder != null ) { if ( outputCharsetEncoder . canEncode ( c ) ) { sb . append ( c ) ; } else { appendHexJavaScriptRepresentation ( sb , c ) ; } } else { if ( c > 0x1f && c <= 0x7f ) { sb . append ( c ) ; } else { appendHexJavaScriptRepresentation ( sb , c ) ; } } } } sb . append ( quote ) ; return sb . toString ( ) ; } ### 374 384 ### <s> if ( c > 0x1f && c < 0x7f ) { </s>
test ### static boolean evaluatesToLocalValue ( Node value , Predicate < Node > locals ) { switch ( value . getType ( ) ) { case Token . ASSIGN : return NodeUtil . isImmutableValue ( value . getLastChild ( ) ) ( locals . apply ( value ) && evaluatesToLocalValue ( value . getLastChild ( ) , locals ) ) ; case Token . COMMA : return evaluatesToLocalValue ( value . getLastChild ( ) , locals ) ; case Token . AND : case Token . OR : return evaluatesToLocalValue ( value . getFirstChild ( ) , locals ) && evaluatesToLocalValue ( value . getLastChild ( ) , locals ) ; case Token . HOOK : return evaluatesToLocalValue ( value . getFirstChild ( ) . getNext ( ) , locals ) && evaluatesToLocalValue ( value . getLastChild ( ) , locals ) ; case Token . INC : case Token . DEC : if ( value . getBooleanProp ( Node . INCRDECR_PROP ) ) { return evaluatesToLocalValue ( value . getFirstChild ( ) , locals ) ; } else { return true ; } case Token . THIS : return locals . apply ( value ) ; case Token . NAME : return isImmutableValue ( value ) locals . apply ( value ) ; case Token . GETELEM : case Token . GETPROP : return locals . apply ( value ) ; case Token . CALL : return callHasLocalResult ( value ) isToStringMethodCall ( value ) locals . apply ( value ) ; case Token . NEW : return true ; case Token . FUNCTION : case Token . REGEXP : case Token . ARRAYLIT : case Token . OBJECTLIT : return true ; case Token . IN : return true ; default : if ( isAssignmentOp ( value ) isSimpleOperator ( value ) isImmutableValue ( value ) ) { return true ; } throw new IllegalStateException ( "Unexpected expression node" + value + "\n parent:" + value . getParent ( ) ) ; } } ### 256 258 ### <s> return false ; </s>
test ### void replace ( ) { if ( firstNode == null ) { replacementNode = candidateDefinition ; return ; } if ( candidateDefinition != null && explicitNode != null ) { explicitNode . detachFromParent ( ) ; compiler . reportCodeChange ( ) ; replacementNode = candidateDefinition ; if ( NodeUtil . isExpressionNode ( candidateDefinition ) ) { candidateDefinition . putBooleanProp ( Node . IS_NAMESPACE , true ) ; Node assignNode = candidateDefinition . getFirstChild ( ) ; Node nameNode = assignNode . getFirstChild ( ) ; if ( nameNode . getType ( ) == Token . NAME ) { Node valueNode = nameNode . getNext ( ) ; assignNode . removeChild ( nameNode ) ; assignNode . removeChild ( valueNode ) ; nameNode . addChildToFront ( valueNode ) ; Node varNode = new Node ( Token . VAR , nameNode ) ; varNode . copyInformationFrom ( candidateDefinition ) ; candidateDefinition . getParent ( ) . replaceChild ( candidateDefinition , varNode ) ; nameNode . setJSDocInfo ( assignNode . getJSDocInfo ( ) ) ; compiler . reportCodeChange ( ) ; replacementNode = varNode ; } } } else { replacementNode = createDeclarationNode ( ) ; if ( firstModule == minimumModule ) { firstNode . getParent ( ) . addChildBefore ( replacementNode , firstNode ) ; } else { int indexOfDot = namespace . indexOf ( '.' ) ; if ( indexOfDot == - 1 ) { compiler . getNodeForCodeInsertion ( minimumModule ) . addChildToBack ( replacementNode ) ; } else { ProvidedName parentName = providedNames . get ( namespace . substring ( 0 , indexOfDot ) ) ; Preconditions . checkNotNull ( parentName ) ; Preconditions . checkNotNull ( parentName . replacementNode ) ; parentName . replacementNode . getParent ( ) . addChildAfter ( replacementNode , parentName . replacementNode ) ; } } if ( explicitNode != null ) { explicitNode . detachFromParent ( ) ; } compiler . reportCodeChange ( ) ; } } ### 216 225 ### <s> int indexOfDot = namespace . lastIndexOf ( '.' ) ; </s>
test ### public String caverphone ( String txt ) { if ( txt == null txt . length ( ) == 0 ) { return "1111111111" ; } txt = txt . toLowerCase ( java . util . Locale . ENGLISH ) ; txt = txt . replaceAll ( "[^a-z]" , "" ) ; txt = txt . replaceAll ( "e$" , "" ) ; txt = txt . replaceAll ( "^cough" , "cou2f" ) ; txt = txt . replaceAll ( "^rough" , "rou2f" ) ; txt = txt . replaceAll ( "^tough" , "tou2f" ) ; txt = txt . replaceAll ( "^enough" , "enou2f" ) ; txt = txt . replaceAll ( "^trough" , "trou2f" ) ; txt = txt . replaceAll ( "^gn" , "2n" ) ; txt = txt . replaceAll ( "^mb" , "m2" ) ; txt = txt . replaceAll ( "cq" , "2q" ) ; txt = txt . replaceAll ( "ci" , "si" ) ; txt = txt . replaceAll ( "ce" , "se" ) ; txt = txt . replaceAll ( "cy" , "sy" ) ; txt = txt . replaceAll ( "tch" , "2ch" ) ; txt = txt . replaceAll ( "c" , "k" ) ; txt = txt . replaceAll ( "q" , "k" ) ; txt = txt . replaceAll ( "x" , "k" ) ; txt = txt . replaceAll ( "v" , "f" ) ; txt = txt . replaceAll ( "dg" , "2g" ) ; txt = txt . replaceAll ( "tio" , "sio" ) ; txt = txt . replaceAll ( "tia" , "sia" ) ; txt = txt . replaceAll ( "d" , "t" ) ; txt = txt . replaceAll ( "ph" , "fh" ) ; txt = txt . replaceAll ( "b" , "p" ) ; txt = txt . replaceAll ( "sh" , "s2" ) ; txt = txt . replaceAll ( "z" , "s" ) ; txt = txt . replaceAll ( "^[aeiou]" , "A" ) ; txt = txt . replaceAll ( "[aeiou]" , "3" ) ; txt = txt . replaceAll ( "j" , "y" ) ; txt = txt . replaceAll ( "^y3" , "Y3" ) ; txt = txt . replaceAll ( "^y" , "A" ) ; txt = txt . replaceAll ( "y" , "3" ) ; txt = txt . replaceAll ( "3gh3" , "3kh3" ) ; txt = txt . replaceAll ( "gh" , "22" ) ; txt = txt . replaceAll ( "g" , "k" ) ; txt = txt . replaceAll ( "s+" , "S" ) ; txt = txt . replaceAll ( "t+" , "T" ) ; txt = txt . replaceAll ( "p+" , "P" ) ; txt = txt . replaceAll ( "k+" , "K" ) ; txt = txt . replaceAll ( "f+" , "F" ) ; txt = txt . replaceAll ( "m+" , "M" ) ; txt = txt . replaceAll ( "n+" , "N" ) ; txt = txt . replaceAll ( "w3" , "W3" ) ; txt = txt . replaceAll ( "wh3" , "Wh3" ) ; txt = txt . replaceAll ( "w$" , "3" ) ; txt = txt . replaceAll ( "w" , "2" ) ; txt = txt . replaceAll ( "^h" , "A" ) ; txt = txt . replaceAll ( "h" , "2" ) ; txt = txt . replaceAll ( "r3" , "R3" ) ; txt = txt . replaceAll ( "r$" , "3" ) ; txt = txt . replaceAll ( "r" , "2" ) ; txt = txt . replaceAll ( "l3" , "L3" ) ; txt = txt . replaceAll ( "l$" , "3" ) ; txt = txt . replaceAll ( "l" , "2" ) ; txt = txt . replaceAll ( "2" , "" ) ; txt = txt . replaceAll ( "3$" , "A" ) ; txt = txt . replaceAll ( "3" , "" ) ; txt = txt + "111111" + "1111" ; return txt . substring ( 0 , 10 ) ; } ### 129 139 ### <s> txt = txt . replaceAll ( "mb$" , "m2" ) ; </s>
test ### public static String newStringIso8859_1 ( final byte [ ] bytes ) { return new String ( bytes , Charsets . ISO_8859_1 ) ; } ### 12 22 ### <s> return newString ( bytes , Charsets . ISO_8859_1 ) ; </s>
test ### public static boolean equals ( final CharSequence cs1 , final CharSequence cs2 ) { if ( cs1 == cs2 ) { return true ; } if ( cs1 == null cs2 == null ) { return false ; } if ( cs1 instanceof String && cs2 instanceof String ) { return cs1 . equals ( cs2 ) ; } return CharSequenceUtils . regionMatches ( cs1 , false , 0 , cs2 , 0 , Math . max ( cs1 . length ( ) , cs2 . length ( ) ) ) ; } ### 59 91 ### <s> return cs1 . length ( ) == cs2 . length ( ) && CharSequenceUtils . regionMatches ( cs1 , false , 0 , cs2 , 0 , cs1 . length ( ) ) ; </s>
test ### void encode ( byte [ ] in , int inPos , int inAvail ) { if ( eof ) { return ; } if ( inAvail < 0 ) { eof = true ; if ( buf == null buf . length - pos < encodeSize ) { resizeBuf ( ) ; } switch ( modulus ) { case 1 : buf [ pos ++ ] = encodeTable [ ( x > > 2 ) & MASK_6BITS ] ; buf [ pos ++ ] = encodeTable [ ( x << 4 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { buf [ pos ++ ] = PAD ; buf [ pos ++ ] = PAD ; } break ; case 2 : buf [ pos ++ ] = encodeTable [ ( x > > 10 ) & MASK_6BITS ] ; buf [ pos ++ ] = encodeTable [ ( x > > 4 ) & MASK_6BITS ] ; buf [ pos ++ ] = encodeTable [ ( x << 2 ) & MASK_6BITS ] ; if ( encodeTable == STANDARD_ENCODE_TABLE ) { buf [ pos ++ ] = PAD ; } break ; } if ( lineLength > 0 ) { System . arraycopy ( lineSeparator , 0 , buf , pos , lineSeparator . length ) ; pos += lineSeparator . length ; } } else { for ( int i = 0 ; i < inAvail ; i ++ ) { if ( buf == null buf . length - pos < encodeSize ) { resizeBuf ( ) ; } modulus = ( ++ modulus ) % 3 ; int b = in [ inPos ++ ] ; if ( b < 0 ) { b += 256 ; } x = ( x << 8 ) + b ; if ( 0 == modulus ) { buf [ pos ++ ] = encodeTable [ ( x > > 18 ) & MASK_6BITS ] ; buf [ pos ++ ] = encodeTable [ ( x > > 12 ) & MASK_6BITS ] ; buf [ pos ++ ] = encodeTable [ ( x > > 6 ) & MASK_6BITS ] ; buf [ pos ++ ] = encodeTable [ x & MASK_6BITS ] ; currentLinePos += 4 ; if ( lineLength > 0 && lineLength <= currentLinePos ) { System . arraycopy ( lineSeparator , 0 , buf , pos , lineSeparator . length ) ; pos += lineSeparator . length ; currentLinePos = 0 ; } } } } } ### 197 203 ### <s> if ( lineLength > 0 && pos > 0 ) { </s>
test ### private int handleG ( String value , DoubleMetaphoneResult result , int index , boolean slavoGermanic ) { if ( charAt ( value , index + 1 ) == 'H' ) { index = handleGH ( value , result , index ) ; } else if ( charAt ( value , index + 1 ) == 'N' ) { if ( index == 1 && isVowel ( charAt ( value , 0 ) ) && ! slavoGermanic ) { result . append ( "KN" , "N" ) ; } else if ( ! contains ( value , index + 2 , 2 , "EY" ) && charAt ( value , index + 1 ) != 'Y' && ! slavoGermanic ) { result . append ( "N" , "KN" ) ; } else { result . append ( "KN" ) ; } index = index + 2 ; } else if ( contains ( value , index + 1 , 2 , "LI" ) && ! slavoGermanic ) { result . append ( "KL" , "L" ) ; index += 2 ; } else if ( index == 0 && ( charAt ( value , index + 1 ) == 'Y' contains ( value , index + 1 , 2 , ES_EP_EB_EL_EY_IB_IL_IN_IE_EI_ER ) ) ) { result . append ( 'K' , 'J' ) ; index += 2 ; } else if ( ( contains ( value , index + 1 , 2 , "ER" ) charAt ( value , index + 1 ) == 'Y' ) && ! contains ( value , 0 , 6 , "DANGER" , "RANGER" , "MANGER" ) && ! contains ( value , index - 1 , 1 , "E" , "I" ) && ! contains ( value , index - 1 , 3 , "RGY" , "OGY" ) ) { result . append ( 'K' , 'J' ) ; index += 2 ; } else if ( contains ( value , index + 1 , 1 , "E" , "I" , "Y" ) contains ( value , index - 1 , 4 , "AGGI" , "OGGI" ) ) { if ( ( contains ( value , 0 , 4 , "VAN " , "VON " ) contains ( value , 0 , 3 , "SCH" ) ) contains ( value , index + 1 , 2 , "ET" ) ) { result . append ( 'K' ) ; } else if ( contains ( value , index + 1 , 4 , "IER" ) ) { result . append ( 'J' ) ; } else { result . append ( 'J' , 'K' ) ; } index += 2 ; } else if ( charAt ( value , index + 1 ) == 'G' ) { index += 2 ; result . append ( 'K' ) ; } else { index ++ ; result . append ( 'K' ) ; } return index ; } ### 403 420 ### <s> } else if ( contains ( value , index + 1 , 3 , "IER" ) ) { </s>
test ### public Base64 ( ) { this ( false ) ; } ### 5 9 ### <s> this ( 0 ) ; </s>
test ### public static String encodeBase64String ( byte [ ] binaryData ) { return StringUtils . newStringUtf8 ( encodeBase64 ( binaryData , true ) ) ; } ### 11 23 ### <s> return StringUtils . newStringUtf8 ( encodeBase64 ( binaryData , false ) ) ; </s>
test ### public static byte [ ] encodeBase64 ( byte [ ] binaryData , boolean isChunked , boolean urlSafe , int maxResultSize ) { if ( binaryData == null binaryData . length == 0 ) { return binaryData ; } long len = getEncodeLength ( binaryData , MIME_CHUNK_SIZE , CHUNK_SEPARATOR ) ; if ( len > maxResultSize ) { throw new IllegalArgumentException ( "Input array too big, the output array would be bigger (" + len + ") than the specified maxium size of " + maxResultSize ) ; } Base64 b64 = isChunked ? new Base64 ( urlSafe ) : new Base64 ( 0 , CHUNK_SEPARATOR , urlSafe ) ; return b64 . encode ( binaryData ) ; } ### 38 49 ### <s> long len = getEncodeLength ( binaryData , isChunked ? MIME_CHUNK_SIZE : 0 , CHUNK_SEPARATOR ) ; </s>
test ### private Object readResolve ( ) { calculateHashCode ( keys ) ; return this ; } ### 0 5 ### <s> protected Object readResolve ( ) { </s>
test ### public void reparseCentralDirectoryData ( boolean hasUncompressedSize , boolean hasCompressedSize , boolean hasRelativeHeaderOffset , boolean hasDiskStart ) throws ZipException { if ( rawCentralDirectoryData != null ) { int expectedLength = ( hasUncompressedSize ? DWORD : 0 ) + ( hasCompressedSize ? DWORD : 0 ) + ( hasRelativeHeaderOffset ? DWORD : 0 ) + ( hasDiskStart ? WORD : 0 ) ; if ( rawCentralDirectoryData . length != expectedLength ) { throw new ZipException ( "central directory zip64 extended" + " information extra field's length" + " doesn't match central directory" + " data. Expected length " + expectedLength + " but is " + rawCentralDirectoryData . length ) ; } int offset = 0 ; if ( hasUncompressedSize ) { size = new ZipEightByteInteger ( rawCentralDirectoryData , offset ) ; offset += DWORD ; } if ( hasCompressedSize ) { compressedSize = new ZipEightByteInteger ( rawCentralDirectoryData , offset ) ; offset += DWORD ; } if ( hasRelativeHeaderOffset ) { relativeHeaderOffset = new ZipEightByteInteger ( rawCentralDirectoryData , offset ) ; offset += DWORD ; } if ( hasDiskStart ) { diskStart = new ZipLong ( rawCentralDirectoryData , offset ) ; offset += WORD ; } } } ### 61 69 ### <s> if ( rawCentralDirectoryData . length < expectedLength ) { </s>
test ### InputStream decode ( final InputStream in , final Coder coder , byte [ ] password ) throws IOException { byte propsByte = coder . properties [ 0 ] ; long dictSize = coder . properties [ 1 ] ; for ( int i = 1 ; i < 4 ; i ++ ) { dictSize = ( coder . properties [ i + 1 ] << ( 8 * i ) ) ; } if ( dictSize > LZMAInputStream . DICT_SIZE_MAX ) { throw new IOException ( "Dictionary larger than 4GiB maximum size" ) ; } return new LZMAInputStream ( in , - 1 , propsByte , ( int ) dictSize ) ; } ### 54 72 ### <s> dictSize = ( coder . properties [ i + 1 ] & 0xffl ) << ( 8 * i ) ; </s>
test ### public boolean isDirectory ( ) { if ( file != null ) { return file . isDirectory ( ) ; } if ( linkFlag == LF_DIR ) { return true ; } if ( getName ( ) . endsWith ( "/" ) ) { return true ; } return false ; } ### 32 43 ### <s> if ( ! isPaxHeader ( ) && ! isGlobalPaxHeader ( ) && getName ( ) . endsWith ( "/" ) ) { </s>
test ### public int read ( ) throws IOException { int current = super . read ( ) ; if ( current == '\n' ) { lineCounter ++ ; } lastChar = current ; return lastChar ; } ### 17 23 ### <s> if ( current == '\r'  ( current == '\n' && lastChar != '\r' ) ) { </s>
test ### private Map < String , Integer > initializeHeader ( ) throws IOException { Map < String , Integer > hdrMap = null ; final String [ ] formatHeader = this . format . getHeader ( ) ; if ( formatHeader != null ) { hdrMap = new LinkedHashMap < String , Integer > ( ) ; String [ ] headerRecord = null ; if ( formatHeader . length == 0 ) { final CSVRecord nextRecord = this . nextRecord ( ) ; if ( nextRecord != null ) { headerRecord = nextRecord . values ( ) ; } } else { if ( this . format . getSkipHeaderRecord ( ) ) { this . nextRecord ( ) ; } headerRecord = formatHeader ; } if ( headerRecord != null ) { for ( int i = 0 ; i < headerRecord . length ; i ++ ) { final String header = headerRecord [ i ] ; final boolean containsHeader = hdrMap . containsKey ( header ) ; final boolean emptyHeader = header . trim ( ) . isEmpty ( ) ; if ( containsHeader && ( ! emptyHeader ( emptyHeader && ! this . format . getIgnoreEmptyHeaders ( ) ) ) ) { throw new IllegalArgumentException ( "The header contains a duplicate name: \"" + header + "\" in " + Arrays . toString ( headerRecord ) ) ; } hdrMap . put ( header , Integer . valueOf ( i ) ) ; } } } return hdrMap ; } ### 168 181 ### <s> final boolean emptyHeader = header == null  header . trim ( ) . isEmpty ( ) ; </s>
test ### private void printAndQuote ( final Object object , final CharSequence value , final int offset , final int len , final Appendable out , final boolean newRecord ) throws IOException { boolean quote = false ; int start = offset ; int pos = offset ; final int end = offset + len ; final char delimChar = getDelimiter ( ) ; final char quoteChar = getQuoteCharacter ( ) . charValue ( ) ; QuoteMode quoteModePolicy = getQuoteMode ( ) ; if ( quoteModePolicy == null ) { quoteModePolicy = QuoteMode . MINIMAL ; } switch ( quoteModePolicy ) { case ALL : quote = true ; break ; case NON_NUMERIC : quote = ! ( object instanceof Number ) ; break ; case NONE : printAndEscape ( value , offset , len , out ) ; return ; case MINIMAL : if ( len <= 0 ) { if ( newRecord ) { quote = true ; } } else { char c = value . charAt ( pos ) ; if ( newRecord && ( c < '0' c > '9' && c < 'A' c > 'Z' && c < 'a' c > 'z' ) ) { quote = true ; } else if ( c <= COMMENT ) { quote = true ; } else { while ( pos < end ) { c = value . charAt ( pos ) ; if ( c == LF c == CR c == quoteChar c == delimChar ) { quote = true ; break ; } pos ++ ; } if ( ! quote ) { pos = end - 1 ; c = value . charAt ( pos ) ; if ( c <= SP ) { quote = true ; } } } } if ( ! quote ) { out . append ( value , start , end ) ; return ; } break ; default : throw new IllegalStateException ( "Unexpected Quote value: " + quoteModePolicy ) ; } if ( ! quote ) { out . append ( value , start , end ) ; return ; } out . append ( quoteChar ) ; while ( pos < end ) { final char c = value . charAt ( pos ) ; if ( c == quoteChar ) { out . append ( value , start , pos + 1 ) ; start = pos ; } pos ++ ; } out . append ( value , start , pos ) ; out . append ( quoteChar ) ; } ### 172 199 ### <s> if ( newRecord && ( c < 0x20  c > 0x21 && c < 0x23  c > 0x2B && c < 0x2D  c > 0x7E ) ) { </s>
test ### public Map < String , Integer > getHeaderMap ( ) { return new LinkedHashMap < String , Integer > ( this . headerMap ) ; } ### 11 24 ### <s> return this . headerMap == null ? null : new LinkedHashMap < String , Integer > ( this . headerMap ) ; </s>
test ### private int peekNumber ( ) throws IOException { char [ ] buffer = this . buffer ; int p = pos ; int l = limit ; long value = 0 ; boolean negative = false ; boolean fitsInLong = true ; int last = NUMBER_CHAR_NONE ; int i = 0 ; charactersOfNumber : for ( ; true ; i ++ ) { if ( p + i == l ) { if ( i == buffer . length ) { return PEEKED_NONE ; } if ( ! fillBuffer ( i + 1 ) ) { break ; } p = pos ; l = limit ; } char c = buffer [ p + i ] ; switch ( c ) { case '-' : if ( last == NUMBER_CHAR_NONE ) { negative = true ; last = NUMBER_CHAR_SIGN ; continue ; } else if ( last == NUMBER_CHAR_EXP_E ) { last = NUMBER_CHAR_EXP_SIGN ; continue ; } return PEEKED_NONE ; case '+' : if ( last == NUMBER_CHAR_EXP_E ) { last = NUMBER_CHAR_EXP_SIGN ; continue ; } return PEEKED_NONE ; case 'e' : case 'E' : if ( last == NUMBER_CHAR_DIGIT last == NUMBER_CHAR_FRACTION_DIGIT ) { last = NUMBER_CHAR_EXP_E ; continue ; } return PEEKED_NONE ; case '.' : if ( last == NUMBER_CHAR_DIGIT ) { last = NUMBER_CHAR_DECIMAL ; continue ; } return PEEKED_NONE ; default : if ( c < '0' c > '9' ) { if ( ! isLiteral ( c ) ) { break charactersOfNumber ; } return PEEKED_NONE ; } if ( last == NUMBER_CHAR_SIGN last == NUMBER_CHAR_NONE ) { value = - ( c - '0' ) ; last = NUMBER_CHAR_DIGIT ; } else if ( last == NUMBER_CHAR_DIGIT ) { if ( value == 0 ) { return PEEKED_NONE ; } long newValue = value * 10 - ( c - '0' ) ; fitsInLong &= value > MIN_INCOMPLETE_INTEGER ( value == MIN_INCOMPLETE_INTEGER && newValue < value ) ; value = newValue ; } else if ( last == NUMBER_CHAR_DECIMAL ) { last = NUMBER_CHAR_FRACTION_DIGIT ; } else if ( last == NUMBER_CHAR_EXP_E last == NUMBER_CHAR_EXP_SIGN ) { last = NUMBER_CHAR_EXP_DIGIT ; } } } if ( last == NUMBER_CHAR_DIGIT && fitsInLong && ( value != Long . MIN_VALUE negative ) ) { peekedLong = negative ? value : - value ; pos += i ; return peeked = PEEKED_LONG ; } else if ( last == NUMBER_CHAR_DIGIT last == NUMBER_CHAR_FRACTION_DIGIT last == NUMBER_CHAR_EXP_DIGIT ) { peekedNumberLength = i ; return peeked = PEEKED_NUMBER ; } else { return PEEKED_NONE ; } } ### 364 381 ### <s> if ( last == NUMBER_CHAR_DIGIT && fitsInLong && ( value != Long . MIN_VALUE  negative ) && ( value != 0  false == negative ) ) { </s>
test ### public JsonWriter value ( double value ) throws IOException { writeDeferredName ( ) ; if ( Double . isNaN ( value ) Double . isInfinite ( value ) ) { throw new IllegalArgumentException ( "Numeric values must be finite, but was " + value ) ; } beforeValue ( ) ; out . append ( Double . toString ( value ) ) ; return this ; } ### 14 29 ### <s> if ( ! lenient && ( Double . isNaN ( value )  Double . isInfinite ( value ) ) ) { </s>
test ### private String _handleOddName2 ( int startPtr , int hash , int [ ] codes ) throws IOException { _textBuffer . resetWithShared ( _inputBuffer , startPtr , ( _inputPtr - startPtr ) ) ; char [ ] outBuf = _textBuffer . getCurrentSegment ( ) ; int outPtr = _textBuffer . getCurrentSegmentSize ( ) ; final int maxCode = codes . length ; while ( true ) { if ( _inputPtr >= _inputEnd ) { if ( ! _loadMore ( ) ) { break ; } } char c = _inputBuffer [ _inputPtr ] ; int i = ( int ) c ; if ( i <= maxCode ) { if ( codes [ i ] != 0 ) { break ; } } else if ( ! Character . isJavaIdentifierPart ( c ) ) { break ; } ++ _inputPtr ; hash = ( hash * CharsToNameCanonicalizer . HASH_MULT ) + i ; outBuf [ outPtr ++ ] = c ; if ( outPtr >= outBuf . length ) { outBuf = _textBuffer . finishCurrentSegment ( ) ; outPtr = 0 ; } } _textBuffer . setCurrentLength ( outPtr ) ; { TextBuffer tb = _textBuffer ; char [ ] buf = tb . getTextBuffer ( ) ; int start = tb . getTextOffset ( ) ; int len = tb . size ( ) ; return _symbols . findSymbol ( buf , start , len , hash ) ; } } ### 101 107 ### <s> if ( i < maxCode ) { </s>
test ### private final static int _parseIndex ( String str ) { final int len = str . length ( ) ; if ( len == 0 len > 10 ) { return - 1 ; } for ( int i = 0 ; i < len ; ++ i ) { char c = str . charAt ( i ++ ) ; if ( c > '9' c < '0' ) { return - 1 ; } } if ( len == 10 ) { long l = NumberInput . parseLong ( str ) ; if ( l > Integer . MAX_VALUE ) { return - 1 ; } } return NumberInput . parseInt ( str ) ; } ### 50 60 ### <s> char c = str . charAt ( i ) ; </s>
test ### public char [ ] getTextBuffer ( ) { if ( _inputStart >= 0 ) return _inputBuffer ; if ( _resultArray != null ) return _resultArray ; if ( _resultString != null ) { return ( _resultArray = _resultString . toCharArray ( ) ) ; } if ( ! _hasSegments ) return _currentSegment ; return contentsAsArray ( ) ; } ### 45 52 ### <s> if ( ! _hasSegments && _currentSegment != null ) return _currentSegment ; </s>
test ### protected final JsonDeserializer < Object > _findDeserializer ( DeserializationContext ctxt , String typeId ) throws IOException { JsonDeserializer < Object > deser = _deserializers . get ( typeId ) ; if ( deser == null ) { JavaType type = _idResolver . typeFromId ( ctxt , typeId ) ; if ( type == null ) { deser = _findDefaultImplDeserializer ( ctxt ) ; if ( deser == null ) { JavaType actual = _handleUnknownTypeId ( ctxt , typeId ) ; if ( actual == null ) { return null ; } deser = ctxt . findContextualValueDeserializer ( actual , _property ) ; } } else { if ( ( _baseType != null ) && _baseType . getClass ( ) == type . getClass ( ) ) { if ( ! type . hasGenericTypes ( ) ) { type = ctxt . getTypeFactory ( ) . constructSpecializedType ( _baseType , type . getRawClass ( ) ) ; } } deser = ctxt . findContextualValueDeserializer ( type , _property ) ; } _deserializers . put ( typeId , deser ) ; } return deser ; } ### 87 89 ### <s> return NullifyingDeserializer . instance ; </s>
test ### protected final boolean _add ( Annotation ann ) { if ( _annotations == null ) { _annotations = new HashMap < Class < ? extends Annotation > , Annotation > ( ) ; } Annotation previous = _annotations . put ( ann . annotationType ( ) , ann ) ; return ( previous != null ) && previous . equals ( ann ) ; } ### 50 63 ### <s> return ( previous == null )  ! previous . equals ( ann ) ; </s>
test ### public boolean useForType ( JavaType t ) { switch ( _appliesFor ) { case NON_CONCRETE_AND_ARRAYS : while ( t . isArrayType ( ) ) { t = t . getContentType ( ) ; } case OBJECT_AND_NON_CONCRETE : return ( t . getRawClass ( ) == Object . class ) ( ! t . isConcrete ( ) TreeNode . class . isAssignableFrom ( t . getRawClass ( ) ) ) ; case NON_FINAL : while ( t . isArrayType ( ) ) { t = t . getContentType ( ) ; } return ! t . isFinal ( ) && ! TreeNode . class . isAssignableFrom ( t . getRawClass ( ) ) ; default : return ( t . getRawClass ( ) == Object . class ) ; } } ### 56 69 ### <s> && ! TreeNode . class . isAssignableFrom ( t . getRawClass ( ) ) ) ; </s>
test ### protected Object deserializeUsingPropertyBasedWithExternalTypeId ( JsonParser p , DeserializationContext ctxt ) throws IOException { final ExternalTypeHandler ext = _externalTypeIdHandler . start ( ) ; final PropertyBasedCreator creator = _propertyBasedCreator ; PropertyValueBuffer buffer = creator . startBuilding ( p , ctxt , _objectIdReader ) ; TokenBuffer tokens = new TokenBuffer ( p ) ; tokens . writeStartObject ( ) ; JsonToken t = p . getCurrentToken ( ) ; for ( ; t == JsonToken . FIELD_NAME ; t = p . nextToken ( ) ) { String propName = p . getCurrentName ( ) ; p . nextToken ( ) ; SettableBeanProperty creatorProp = creator . findCreatorProperty ( propName ) ; if ( creatorProp != null ) { if ( ext . handlePropertyValue ( p , ctxt , propName , buffer ) ) { ; } else { if ( buffer . assignParameter ( creatorProp , _deserializeWithErrorWrapping ( p , ctxt , creatorProp ) ) ) { t = p . nextToken ( ) ; Object bean ; try { bean = creator . build ( ctxt , buffer ) ; } catch ( Exception e ) { wrapAndThrow ( e , _beanType . getRawClass ( ) , propName , ctxt ) ; continue ; } while ( t == JsonToken . FIELD_NAME ) { p . nextToken ( ) ; tokens . copyCurrentStructure ( p ) ; t = p . nextToken ( ) ; } if ( bean . getClass ( ) != _beanType . getRawClass ( ) ) { throw ctxt . mappingException ( "Can not create polymorphic instances with unwrapped values" ) ; } return ext . complete ( p , ctxt , bean ) ; } } continue ; } if ( buffer . readIdProperty ( propName ) ) { continue ; } SettableBeanProperty prop = _beanProperties . find ( propName ) ; if ( prop != null ) { buffer . bufferProperty ( prop , prop . deserialize ( p , ctxt ) ) ; continue ; } if ( ext . handlePropertyValue ( p , ctxt , propName , null ) ) { continue ; } if ( _ignorableProps != null && _ignorableProps . contains ( propName ) ) { handleIgnoredProperty ( p , ctxt , handledType ( ) , propName ) ; continue ; } if ( _anySetter != null ) { buffer . bufferAnyProperty ( _anySetter , propName , _anySetter . deserialize ( p , ctxt ) ) ; } } try { return ext . complete ( p , ctxt , buffer , creator ) ; } catch ( Exception e ) { wrapInstantiationProblem ( e , ctxt ) ; return null ; } } ### 117 132 ### <s> if ( ext . handlePropertyValue ( p , ctxt , propName , null ) ) { </s>
test ### public void acceptJsonFormatVisitor ( JsonFormatVisitorWrapper visitor , JavaType typeHint ) throws JsonMappingException { if ( _isInt ) { visitIntFormat ( visitor , typeHint , JsonParser . NumberType . BIG_INTEGER ) ; } else { Class < ? > h = handledType ( ) ; if ( h == BigDecimal . class ) { visitFloatFormat ( visitor , typeHint , JsonParser . NumberType . BIG_INTEGER ) ; } else { visitor . expectNumberFormat ( typeHint ) ; } } } ### 53 65 ### <s> visitFloatFormat ( visitor , typeHint , JsonParser . NumberType . BIG_DECIMAL ) ; </s>
test ### protected JavaType _narrow ( Class < ? > subclass ) { if ( _class == subclass ) { return this ; } return new SimpleType ( subclass , _bindings , _superClass , _superInterfaces , _valueHandler , _typeHandler , _asStatic ) ; } ### 22 33 ### <s> return new SimpleType ( subclass , _bindings , this , _superInterfaces , </s>
test ### public StringBuilder getGenericSignature ( StringBuilder sb ) { _classSignature ( _class , sb , false ) ; sb . append ( '<' ) ; sb = _referencedType . getGenericSignature ( sb ) ; sb . append ( ';' ) ; return sb ; } ### 33 39 ### <s> sb . append ( ">;" ) ; </s>
test ### public < T > MappingIterator < T > readValues ( byte [ ] src , int offset , int length ) throws IOException , JsonProcessingException { if ( _dataFormatReaders != null ) { return _detectBindAndReadValues ( _dataFormatReaders . findFormat ( src , offset , length ) , false ) ; } return _bindAndReadValues ( _considerFilter ( _parserFactory . createParser ( src ) , true ) ) ; } ### 51 62 ### <s> return _bindAndReadValues ( _considerFilter ( _parserFactory . createParser ( src , offset , length ) , </s>
test ### public void remove ( SettableBeanProperty propToRm ) { ArrayList < SettableBeanProperty > props = new ArrayList < SettableBeanProperty > ( _size ) ; String key = getPropertyName ( propToRm ) ; boolean found = false ; for ( int i = 1 , end = _hashArea . length ; i < end ; i += 2 ) { SettableBeanProperty prop = ( SettableBeanProperty ) _hashArea [ i ] ; if ( prop == null ) { continue ; } if ( ! found ) { found = key . equals ( prop . getName ( ) ) ; if ( found ) { _propsInOrder [ _findFromOrdered ( prop ) ] = null ; continue ; } } props . add ( prop ) ; } if ( ! found ) { throw new NoSuchElementException ( "No entry '" + propToRm . getName ( ) + "' found, can't remove" ) ; } init ( props ) ; } ### 85 97 ### <s> found = key . equals ( _hashArea [ i - 1 ] ) ; </s>
test ### public static StdKeyDeserializer forType ( Class < ? > raw ) { int kind ; if ( raw == String . class raw == Object . class ) { return StringKD . forType ( raw ) ; } else if ( raw == UUID . class ) { kind = TYPE_UUID ; } else if ( raw == Integer . class ) { kind = TYPE_INT ; } else if ( raw == Long . class ) { kind = TYPE_LONG ; } else if ( raw == Date . class ) { kind = TYPE_DATE ; } else if ( raw == Calendar . class ) { kind = TYPE_CALENDAR ; } else if ( raw == Boolean . class ) { kind = TYPE_BOOLEAN ; } else if ( raw == Byte . class ) { kind = TYPE_BYTE ; } else if ( raw == Character . class ) { kind = TYPE_CHAR ; } else if ( raw == Short . class ) { kind = TYPE_SHORT ; } else if ( raw == Float . class ) { kind = TYPE_FLOAT ; } else if ( raw == Double . class ) { kind = TYPE_DOUBLE ; } else if ( raw == URI . class ) { kind = TYPE_URI ; } else if ( raw == URL . class ) { kind = TYPE_URL ; } else if ( raw == Class . class ) { kind = TYPE_CLASS ; } else if ( raw == Locale . class ) { FromStringDeserializer < ? > deser = FromStringDeserializer . findDeserializer ( Locale . class ) ; return new StdKeyDeserializer ( TYPE_LOCALE , raw , deser ) ; } else if ( raw == Currency . class ) { FromStringDeserializer < ? > deser = FromStringDeserializer . findDeserializer ( Currency . class ) ; return new StdKeyDeserializer ( TYPE_CURRENCY , raw , deser ) ; } else { return null ; } return new StdKeyDeserializer ( kind , raw ) ; } ### 15 28 ### <s> if ( raw == String . class  raw == Object . class  raw == CharSequence . class ) { </s>
test ### protected void addBeanProps ( DeserializationContext ctxt , BeanDescription beanDesc , BeanDeserializerBuilder builder ) throws JsonMappingException { final boolean isConcrete = ! beanDesc . getType ( ) . isAbstract ( ) ; final SettableBeanProperty [ ] creatorProps = isConcrete ? builder . getValueInstantiator ( ) . getFromObjectArguments ( ctxt . getConfig ( ) ) : null ; final boolean hasCreatorProps = ( creatorProps != null ) ; JsonIgnoreProperties . Value ignorals = ctxt . getConfig ( ) . getDefaultPropertyIgnorals ( beanDesc . getBeanClass ( ) , beanDesc . getClassInfo ( ) ) ; Set < String > ignored ; if ( ignorals != null ) { boolean ignoreAny = ignorals . getIgnoreUnknown ( ) ; builder . setIgnoreUnknownProperties ( ignoreAny ) ; ignored = ignorals . getIgnored ( ) ; for ( String propName : ignored ) { builder . addIgnorable ( propName ) ; } } else { ignored = Collections . emptySet ( ) ; } AnnotatedMethod anySetterMethod = beanDesc . findAnySetter ( ) ; AnnotatedMember anySetterField = null ; if ( anySetterMethod != null ) { builder . setAnySetter ( constructAnySetter ( ctxt , beanDesc , anySetterMethod ) ) ; } else { anySetterField = beanDesc . findAnySetterField ( ) ; if ( anySetterField != null ) { builder . setAnySetter ( constructAnySetter ( ctxt , beanDesc , anySetterField ) ) ; } } if ( anySetterMethod == null && anySetterField == null ) { Collection < String > ignored2 = beanDesc . getIgnoredPropertyNames ( ) ; if ( ignored2 != null ) { for ( String propName : ignored2 ) { builder . addIgnorable ( propName ) ; } } } final boolean useGettersAsSetters = ctxt . isEnabled ( MapperFeature . USE_GETTERS_AS_SETTERS ) && ctxt . isEnabled ( MapperFeature . AUTO_DETECT_GETTERS ) ; List < BeanPropertyDefinition > propDefs = filterBeanProps ( ctxt , beanDesc , builder , beanDesc . findProperties ( ) , ignored ) ; if ( _factoryConfig . hasDeserializerModifiers ( ) ) { for ( BeanDeserializerModifier mod : _factoryConfig . deserializerModifiers ( ) ) { propDefs = mod . updateProperties ( ctxt . getConfig ( ) , beanDesc , propDefs ) ; } } for ( BeanPropertyDefinition propDef : propDefs ) { SettableBeanProperty prop = null ; if ( propDef . hasSetter ( ) ) { JavaType propertyType = propDef . getSetter ( ) . getParameterType ( 0 ) ; prop = constructSettableProperty ( ctxt , beanDesc , propDef , propertyType ) ; } else if ( propDef . hasField ( ) ) { JavaType propertyType = propDef . getField ( ) . getType ( ) ; prop = constructSettableProperty ( ctxt , beanDesc , propDef , propertyType ) ; } else if ( useGettersAsSetters && propDef . hasGetter ( ) ) { AnnotatedMethod getter = propDef . getGetter ( ) ; Class < ? > rawPropertyType = getter . getRawType ( ) ; if ( Collection . class . isAssignableFrom ( rawPropertyType ) Map . class . isAssignableFrom ( rawPropertyType ) ) { prop = constructSetterlessProperty ( ctxt , beanDesc , propDef ) ; } } if ( hasCreatorProps && propDef . hasConstructorParameter ( ) ) { final String name = propDef . getName ( ) ; CreatorProperty cprop = null ; if ( creatorProps != null ) { for ( SettableBeanProperty cp : creatorProps ) { if ( name . equals ( cp . getName ( ) ) && ( cp instanceof CreatorProperty ) ) { cprop = ( CreatorProperty ) cp ; break ; } } } if ( cprop == null ) { List < String > n = new ArrayList < > ( ) ; for ( SettableBeanProperty cp : creatorProps ) { n . add ( cp . getName ( ) ) ; } ctxt . reportBadPropertyDefinition ( beanDesc , propDef , "Could not find creator property with name '%s' (known Creator properties: %s)" , name , n ) ; continue ; } if ( prop != null ) { cprop . setFallbackSetter ( prop ) ; } prop = cprop ; builder . addCreatorProperty ( cprop ) ; continue ; } if ( prop != null ) { Class < ? > [ ] views = propDef . findViews ( ) ; if ( views == null ) { if ( ! ctxt . isEnabled ( MapperFeature . DEFAULT_VIEW_INCLUSION ) ) { views = NO_VIEWS ; } } prop . setViews ( views ) ; builder . addProperty ( prop ) ; } } } ### 121 128 ### <s> ignored = ignorals . findIgnoredForDeserialization ( ) ; </s>
test ### protected void _addExplicitAnyCreator ( DeserializationContext ctxt , BeanDescription beanDesc , CreatorCollector creators , CreatorCandidate candidate ) throws JsonMappingException { if ( 1 != candidate . paramCount ( ) ) { int oneNotInjected = candidate . findOnlyParamWithoutInjection ( ) ; if ( oneNotInjected >= 0 ) { if ( candidate . paramName ( oneNotInjected ) == null ) { _addExplicitDelegatingCreator ( ctxt , beanDesc , creators , candidate ) ; return ; } } _addExplicitPropertyCreator ( ctxt , beanDesc , creators , candidate ) ; return ; } AnnotatedParameter param = candidate . parameter ( 0 ) ; JacksonInject . Value injectId = candidate . injection ( 0 ) ; PropertyName paramName = candidate . explicitParamName ( 0 ) ; BeanPropertyDefinition paramDef = candidate . propertyDef ( 0 ) ; boolean useProps = ( paramName != null ) ( injectId != null ) ; if ( ! useProps && ( paramDef != null ) ) { paramName = candidate . findImplicitParamName ( 0 ) ; useProps = ( paramName != null ) && paramDef . couldSerialize ( ) ; } if ( useProps ) { SettableBeanProperty [ ] properties = new SettableBeanProperty [ ] { constructCreatorProperty ( ctxt , beanDesc , paramName , 0 , param , injectId ) } ; creators . addPropertyCreator ( candidate . creator ( ) , true , properties ) ; return ; } _handleSingleArgumentCreator ( creators , candidate . creator ( ) , true , true ) ; if ( paramDef != null ) { ( ( POJOPropertyBuilder ) paramDef ) . removeConstructors ( ) ; } } ### 155 163 ### <s> paramName = candidate . paramName ( 0 ) ; </s>
test ### public final void serialize ( JsonGenerator gen , SerializerProvider ctxt ) throws IOException { if ( _value == null ) { ctxt . defaultSerializeNull ( gen ) ; } else if ( _value instanceof JsonSerializable ) { ( ( JsonSerializable ) _value ) . serialize ( gen , ctxt ) ; } else { gen . writeObject ( _value ) ; } } ### 54 60 ### <s> ctxt . defaultSerializeValue ( _value , gen ) ; </s>
test ### protected XmlSerializerProvider ( XmlSerializerProvider src ) { super ( src ) ; _rootNameLookup = src . _rootNameLookup ; } ### 12 17 ### <s> _rootNameLookup = new XmlRootNameLookup ( ) ; </s>
test ### boolean process ( Token t , TreeBuilder tb ) { switch ( t . type ) { case Character : { Token . Character c = t . asCharacter ( ) ; if ( c . getData ( ) . equals ( nullString ) ) { tb . error ( this ) ; return false ; } else if ( isWhitespace ( c ) ) { tb . reconstructFormattingElements ( ) ; tb . insert ( c ) ; } else { tb . reconstructFormattingElements ( ) ; tb . insert ( c ) ; tb . framesetOk ( false ) ; } break ; } case Comment : { tb . insert ( t . asComment ( ) ) ; break ; } case Doctype : { tb . error ( this ) ; return false ; } case StartTag : Token . StartTag startTag = t . asStartTag ( ) ; String name = startTag . name ( ) ; if ( name . equals ( "html" ) ) { tb . error ( this ) ; Element html = tb . getStack ( ) . getFirst ( ) ; for ( Attribute attribute : startTag . getAttributes ( ) ) { if ( ! html . hasAttr ( attribute . getKey ( ) ) ) html . attributes ( ) . put ( attribute ) ; } } else if ( StringUtil . in ( name , "base" , "basefont" , "bgsound" , "command" , "link" , "meta" , "noframes" , "style" , "title" ) ) { return tb . process ( t , InHead ) ; } else if ( name . equals ( "body" ) ) { tb . error ( this ) ; LinkedList < Element > stack = tb . getStack ( ) ; if ( stack . size ( ) == 1 ( stack . size ( ) > 2 && ! stack . get ( 1 ) . nodeName ( ) . equals ( "body" ) ) ) { return false ; } else { tb . framesetOk ( false ) ; Element body = stack . get ( 1 ) ; for ( Attribute attribute : startTag . getAttributes ( ) ) { if ( ! body . hasAttr ( attribute . getKey ( ) ) ) body . attributes ( ) . put ( attribute ) ; } } } else if ( name . equals ( "frameset" ) ) { tb . error ( this ) ; LinkedList < Element > stack = tb . getStack ( ) ; if ( stack . size ( ) == 1 ( stack . size ( ) > 2 && ! stack . get ( 1 ) . nodeName ( ) . equals ( "body" ) ) ) { return false ; } else if ( ! tb . framesetOk ( ) ) { return false ; } else { Element second = stack . get ( 1 ) ; if ( second . parent ( ) != null ) second . remove ( ) ; while ( stack . size ( ) > 1 ) stack . removeLast ( ) ; tb . insert ( startTag ) ; tb . transition ( InFrameset ) ; } } else if ( StringUtil . in ( name , "address" , "article" , "aside" , "blockquote" , "center" , "details" , "dir" , "div" , "dl" , "fieldset" , "figcaption" , "figure" , "footer" , "header" , "hgroup" , "menu" , "nav" , "ol" , "p" , "section" , "summary" , "ul" ) ) { if ( tb . inButtonScope ( "p" ) ) { tb . process ( new Token . EndTag ( "p" ) ) ; } tb . insert ( startTag ) ; } else if ( StringUtil . in ( name , "h1" , "h2" , "h3" , "h4" , "h5" , "h6" ) ) { if ( tb . inButtonScope ( "p" ) ) { tb . process ( new Token . EndTag ( "p" ) ) ; } if ( StringUtil . in ( tb . currentElement ( ) . nodeName ( ) , "h1" , "h2" , "h3" , "h4" , "h5" , "h6" ) ) { tb . error ( this ) ; tb . pop ( ) ; } tb . insert ( startTag ) ; } else if ( StringUtil . in ( name , "pre" , "listing" ) ) { if ( tb . inButtonScope ( "p" ) ) { tb . process ( new Token . EndTag ( "p" ) ) ; } tb . insert ( startTag ) ; tb . framesetOk ( false ) ; } else if ( name . equals ( "form" ) ) { if ( tb . getFormElement ( ) != null ) { tb . error ( this ) ; return false ; } if ( tb . inButtonScope ( "p" ) ) { tb . process ( new Token . EndTag ( "p" ) ) ; } Element form = tb . insert ( startTag ) ; tb . setFormElement ( form ) ; } else if ( name . equals ( "li" ) ) { tb . framesetOk ( false ) ; LinkedList < Element > stack = tb . getStack ( ) ; for ( int i = stack . size ( ) - 1 ; i > 0 ; i -- ) { Element el = stack . get ( i ) ; if ( el . nodeName ( ) . equals ( "li" ) ) { tb . process ( new Token . EndTag ( "li" ) ) ; break ; } if ( tb . isSpecial ( el ) && ! StringUtil . in ( el . nodeName ( ) , "address" , "div" , "p" ) ) break ; } if ( tb . inButtonScope ( "p" ) ) { tb . process ( new Token . EndTag ( "p" ) ) ; } tb . insert ( startTag ) ; } else if ( StringUtil . in ( name , "dd" , "dt" ) ) { tb . framesetOk ( false ) ; LinkedList < Element > stack = tb . getStack ( ) ; for ( int i = stack . size ( ) - 1 ; i > 0 ; i -- ) { Element el = stack . get ( i ) ; if ( StringUtil . in ( el . nodeName ( ) , "dd" , "dt" ) ) { tb . process ( new Token . EndTag ( el . nodeName ( ) ) ) ; break ; } if ( tb . isSpecial ( el ) && ! StringUtil . in ( el . nodeName ( ) , "address" , "div" , "p" ) ) break ; } if ( tb . inButtonScope ( "p" ) ) { tb . process ( new Token . EndTag ( "p" ) ) ; } tb . insert ( startTag ) ; } else if ( name . equals ( "plaintext" ) ) { if ( tb . inButtonScope ( "p" ) ) { tb . process ( new Token . EndTag ( "p" ) ) ; } tb . insert ( startTag ) ; tb . tokeniser . transition ( TokeniserState . PLAINTEXT ) ; } else if ( name . equals ( "button" ) ) { if ( tb . inButtonScope ( "button" ) ) { tb . error ( this ) ; tb . process ( new Token . EndTag ( "button" ) ) ; tb . process ( startTag ) ; } else { tb . reconstructFormattingElements ( ) ; tb . insert ( startTag ) ; tb . framesetOk ( false ) ; } } else if ( name . equals ( "a" ) ) { if ( tb . getActiveFormattingElement ( "a" ) != null ) { tb . error ( this ) ; tb . process ( new Token . EndTag ( "a" ) ) ; Element remainingA = tb . getFromStack ( "a" ) ; if ( remainingA != null ) { tb . removeFromActiveFormattingElements ( remainingA ) ; tb . removeFromStack ( remainingA ) ; } } tb . reconstructFormattingElements ( ) ; Element a = tb . insert ( startTag ) ; tb . pushActiveFormattingElements ( a ) ; } else if ( StringUtil . in ( name , "b" , "big" , "code" , "em" , "font" , "i" , "s" , "small" , "strike" , "strong" , "tt" , "u" ) ) { tb . reconstructFormattingElements ( ) ; Element el = tb . insert ( startTag ) ; tb . pushActiveFormattingElements ( el ) ; } else if ( name . equals ( "nobr" ) ) { tb . reconstructFormattingElements ( ) ; if ( tb . inScope ( "nobr" ) ) { tb . error ( this ) ; tb . process ( new Token . EndTag ( "nobr" ) ) ; tb . reconstructFormattingElements ( ) ; } Element el = tb . insert ( startTag ) ; tb . pushActiveFormattingElements ( el ) ; } else if ( StringUtil . in ( name , "applet" , "marquee" , "object" ) ) { tb . reconstructFormattingElements ( ) ; tb . insert ( startTag ) ; tb . insertMarkerToFormattingElements ( ) ; tb . framesetOk ( false ) ; } else if ( name . equals ( "table" ) ) { if ( tb . getDocument ( ) . quirksMode ( ) != Document . QuirksMode . quirks && tb . inButtonScope ( "p" ) ) { tb . process ( new Token . EndTag ( "p" ) ) ; } tb . insert ( startTag ) ; tb . framesetOk ( false ) ; tb . transition ( InTable ) ; } else if ( StringUtil . in ( name , "area" , "br" , "embed" , "img" , "keygen" , "wbr" ) ) { tb . reconstructFormattingElements ( ) ; tb . insertEmpty ( startTag ) ; tb . framesetOk ( false ) ; } else if ( name . equals ( "input" ) ) { tb . reconstructFormattingElements ( ) ; Element el = tb . insertEmpty ( startTag ) ; if ( ! el . attr ( "type" ) . equalsIgnoreCase ( "hidden" ) ) tb . framesetOk ( false ) ; } else if ( StringUtil . in ( name , "param" , "source" , "track" ) ) { tb . insertEmpty ( startTag ) ; } else if ( name . equals ( "hr" ) ) { if ( tb . inButtonScope ( "p" ) ) { tb . process ( new Token . EndTag ( "p" ) ) ; } tb . insertEmpty ( startTag ) ; tb . framesetOk ( false ) ; } else if ( name . equals ( "image" ) ) { startTag . name ( "img" ) ; return tb . process ( startTag ) ; } else if ( name . equals ( "isindex" ) ) { tb . error ( this ) ; if ( tb . getFormElement ( ) != null ) return false ; tb . tokeniser . acknowledgeSelfClosingFlag ( ) ; tb . process ( new Token . StartTag ( "form" ) ) ; if ( startTag . attributes . hasKey ( "action" ) ) { Element form = tb . getFormElement ( ) ; form . attr ( "action" , startTag . attributes . get ( "action" ) ) ; } tb . process ( new Token . StartTag ( "hr" ) ) ; tb . process ( new Token . StartTag ( "label" ) ) ; String prompt = startTag . attributes . hasKey ( "prompt" ) ? startTag . attributes . get ( "prompt" ) : "This is a searchable index. Enter search keywords: " ; tb . process ( new Token . Character ( prompt ) ) ; Attributes inputAttribs = new Attributes ( ) ; for ( Attribute attr : startTag . attributes ) { if ( ! StringUtil . in ( attr . getKey ( ) , "name" , "action" , "prompt" ) ) inputAttribs . put ( attr ) ; } inputAttribs . put ( "name" , "isindex" ) ; tb . process ( new Token . StartTag ( "input" , inputAttribs ) ) ; tb . process ( new Token . EndTag ( "label" ) ) ; tb . process ( new Token . StartTag ( "hr" ) ) ; tb . process ( new Token . EndTag ( "form" ) ) ; } else if ( name . equals ( "textarea" ) ) { tb . insert ( startTag ) ; tb . tokeniser . transition ( TokeniserState . Rcdata ) ; tb . markInsertionMode ( ) ; tb . framesetOk ( false ) ; tb . transition ( Text ) ; } else if ( name . equals ( "xmp" ) ) { if ( tb . inButtonScope ( "p" ) ) { tb . process ( new Token . EndTag ( "p" ) ) ; } tb . reconstructFormattingElements ( ) ; tb . framesetOk ( false ) ; handleRawtext ( startTag , tb ) ; } else if ( name . equals ( "iframe" ) ) { tb . framesetOk ( false ) ; handleRawtext ( startTag , tb ) ; } else if ( name . equals ( "noembed" ) ) { handleRawtext ( startTag , tb ) ; } else if ( name . equals ( "select" ) ) { tb . reconstructFormattingElements ( ) ; tb . insert ( startTag ) ; tb . framesetOk ( false ) ; TreeBuilderState state = tb . state ( ) ; if ( state . equals ( InTable ) state . equals ( InCaption ) state . equals ( InTableBody ) state . equals ( InRow ) state . equals ( InCell ) ) tb . transition ( InSelectInTable ) ; else tb . transition ( InSelect ) ; } else if ( StringUtil . in ( "optgroup" , "option" ) ) { if ( tb . currentElement ( ) . nodeName ( ) . equals ( "option" ) ) tb . process ( new Token . EndTag ( "option" ) ) ; tb . reconstructFormattingElements ( ) ; tb . insert ( startTag ) ; } else if ( StringUtil . in ( "rp" , "rt" ) ) { if ( tb . inScope ( "ruby" ) ) { tb . generateImpliedEndTags ( ) ; if ( ! tb . currentElement ( ) . nodeName ( ) . equals ( "ruby" ) ) { tb . error ( this ) ; tb . popStackToBefore ( "ruby" ) ; } tb . insert ( startTag ) ; } } else if ( name . equals ( "math" ) ) { tb . reconstructFormattingElements ( ) ; tb . insert ( startTag ) ; tb . tokeniser . acknowledgeSelfClosingFlag ( ) ; } else if ( name . equals ( "svg" ) ) { tb . reconstructFormattingElements ( ) ; tb . insert ( startTag ) ; tb . tokeniser . acknowledgeSelfClosingFlag ( ) ; } else if ( StringUtil . in ( name , "caption" , "col" , "colgroup" , "frame" , "head" , "tbody" , "td" , "tfoot" , "th" , "thead" , "tr" ) ) { tb . error ( this ) ; return false ; } else { tb . reconstructFormattingElements ( ) ; tb . insert ( startTag ) ; } break ; case EndTag : Token . EndTag endTag = t . asEndTag ( ) ; name = endTag . name ( ) ; if ( name . equals ( "body" ) ) { if ( ! tb . inScope ( "body" ) ) { tb . error ( this ) ; return false ; } else { tb . transition ( AfterBody ) ; } } else if ( name . equals ( "html" ) ) { boolean notIgnored = tb . process ( new Token . EndTag ( "body" ) ) ; if ( notIgnored ) return tb . process ( endTag ) ; } else if ( StringUtil . in ( name , "address" , "article" , "aside" , "blockquote" , "button" , "center" , "details" , "dir" , "div" , "dl" , "fieldset" , "figcaption" , "figure" , "footer" , "header" , "hgroup" , "listing" , "menu" , "nav" , "ol" , "pre" , "section" , "summary" , "ul" ) ) { if ( ! tb . inScope ( name ) ) { tb . error ( this ) ; return false ; } else { tb . generateImpliedEndTags ( ) ; if ( ! tb . currentElement ( ) . nodeName ( ) . equals ( name ) ) tb . error ( this ) ; tb . popStackToClose ( name ) ; } } else if ( name . equals ( "form" ) ) { Element currentForm = tb . getFormElement ( ) ; tb . setFormElement ( null ) ; if ( currentForm == null ! tb . inScope ( name ) ) { tb . error ( this ) ; return false ; } else { tb . generateImpliedEndTags ( ) ; if ( ! tb . currentElement ( ) . nodeName ( ) . equals ( name ) ) tb . error ( this ) ; tb . removeFromStack ( currentForm ) ; } } else if ( name . equals ( "p" ) ) { if ( ! tb . inButtonScope ( name ) ) { tb . error ( this ) ; tb . process ( new Token . StartTag ( name ) ) ; return tb . process ( endTag ) ; } else { tb . generateImpliedEndTags ( name ) ; if ( ! tb . currentElement ( ) . nodeName ( ) . equals ( name ) ) tb . error ( this ) ; tb . popStackToClose ( name ) ; } } else if ( name . equals ( "li" ) ) { if ( ! tb . inListItemScope ( name ) ) { tb . error ( this ) ; return false ; } else { tb . generateImpliedEndTags ( name ) ; if ( ! tb . currentElement ( ) . nodeName ( ) . equals ( name ) ) tb . error ( this ) ; tb . popStackToClose ( name ) ; } } else if ( StringUtil . in ( name , "dd" , "dt" ) ) { if ( ! tb . inScope ( name ) ) { tb . error ( this ) ; return false ; } else { tb . generateImpliedEndTags ( name ) ; if ( ! tb . currentElement ( ) . nodeName ( ) . equals ( name ) ) tb . error ( this ) ; tb . popStackToClose ( name ) ; } } else if ( StringUtil . in ( name , "h1" , "h2" , "h3" , "h4" , "h5" , "h6" ) ) { if ( ! tb . inScope ( new String [ ] { "h1" , "h2" , "h3" , "h4" , "h5" , "h6" } ) ) { tb . error ( this ) ; return false ; } else { tb . generateImpliedEndTags ( name ) ; if ( ! tb . currentElement ( ) . nodeName ( ) . equals ( name ) ) tb . error ( this ) ; tb . popStackToClose ( "h1" , "h2" , "h3" , "h4" , "h5" , "h6" ) ; } } else if ( name . equals ( "sarcasm" ) ) { return anyOtherEndTag ( t , tb ) ; } else if ( StringUtil . in ( name , "a" , "b" , "big" , "code" , "em" , "font" , "i" , "nobr" , "s" , "small" , "strike" , "strong" , "tt" , "u" ) ) { OUTER : for ( int i = 0 ; i < 8 ; i ++ ) { Element formatEl = tb . getActiveFormattingElement ( name ) ; if ( formatEl == null ) return anyOtherEndTag ( t , tb ) ; else if ( ! tb . onStack ( formatEl ) ) { tb . error ( this ) ; tb . removeFromActiveFormattingElements ( formatEl ) ; return true ; } else if ( ! tb . inScope ( formatEl . nodeName ( ) ) ) { tb . error ( this ) ; return false ; } else if ( tb . currentElement ( ) != formatEl ) tb . error ( this ) ; Element furthestBlock = null ; Element commonAncestor = null ; boolean seenFormattingElement = false ; LinkedList < Element > stack = tb . getStack ( ) ; for ( int si = 0 ; si < stack . size ( ) ; si ++ ) { Element el = stack . get ( si ) ; if ( el == formatEl ) { commonAncestor = stack . get ( si - 1 ) ; seenFormattingElement = true ; } else if ( seenFormattingElement && tb . isSpecial ( el ) ) { furthestBlock = el ; break ; } } if ( furthestBlock == null ) { tb . popStackToClose ( formatEl . nodeName ( ) ) ; tb . removeFromActiveFormattingElements ( formatEl ) ; return true ; } Element node = furthestBlock ; Element lastNode = furthestBlock ; INNER : for ( int j = 0 ; j < 3 ; j ++ ) { if ( tb . onStack ( node ) ) node = tb . aboveOnStack ( node ) ; if ( ! tb . isInActiveFormattingElements ( node ) ) { tb . removeFromStack ( node ) ; continue INNER ; } else if ( node == formatEl ) break INNER ; Element replacement = new Element ( Tag . valueOf ( node . nodeName ( ) ) , tb . getBaseUri ( ) ) ; tb . replaceActiveFormattingElement ( node , replacement ) ; tb . replaceOnStack ( node , replacement ) ; node = replacement ; if ( lastNode == furthestBlock ) { } if ( lastNode . parent ( ) != null ) lastNode . remove ( ) ; node . appendChild ( lastNode ) ; lastNode = node ; } if ( StringUtil . in ( commonAncestor . nodeName ( ) , "table" , "tbody" , "tfoot" , "thead" , "tr" ) ) { if ( lastNode . parent ( ) != null ) lastNode . remove ( ) ; tb . insertInFosterParent ( lastNode ) ; } else { if ( lastNode . parent ( ) != null ) lastNode . remove ( ) ; commonAncestor . appendChild ( lastNode ) ; } Element adopter = new Element ( Tag . valueOf ( name ) , tb . getBaseUri ( ) ) ; Node [ ] childNodes = furthestBlock . childNodes ( ) . toArray ( new Node [ furthestBlock . childNodes ( ) . size ( ) ] ) ; for ( Node childNode : childNodes ) { adopter . appendChild ( childNode ) ; } furthestBlock . appendChild ( adopter ) ; tb . removeFromActiveFormattingElements ( formatEl ) ; tb . removeFromStack ( formatEl ) ; tb . insertOnStackAfter ( furthestBlock , adopter ) ; } } else if ( StringUtil . in ( name , "applet" , "marquee" , "object" ) ) { if ( ! tb . inScope ( "name" ) ) { if ( ! tb . inScope ( name ) ) { tb . error ( this ) ; return false ; } tb . generateImpliedEndTags ( ) ; if ( ! tb . currentElement ( ) . nodeName ( ) . equals ( name ) ) tb . error ( this ) ; tb . popStackToClose ( name ) ; tb . clearFormattingElementsToLastMarker ( ) ; } } else if ( name . equals ( "br" ) ) { tb . error ( this ) ; tb . process ( new Token . StartTag ( "br" ) ) ; return false ; } else { return anyOtherEndTag ( t , tb ) ; } break ; case EOF : break ; } return true ; } ### 230 259 ### <s> } else if ( StringUtil . in ( name , "base" , "basefont" , "bgsound" , "command" , "link" , "meta" , "noframes" , "script" , "style" , "title" ) ) { </s>
test ### public Element clone ( ) { Element clone = ( Element ) super . clone ( ) ; clone . classNames ( ) ; return clone ; } ### 18 23 ### <s> clone . classNames = null ; </s>
test ### int nextIndexOf ( CharSequence seq ) { char startChar = seq . charAt ( 0 ) ; for ( int offset = pos ; offset < length ; offset ++ ) { if ( startChar != input [ offset ] ) while ( ++ offset < length && startChar != input [ offset ] ) ; int i = offset + 1 ; int last = i + seq . length ( ) - 1 ; if ( offset < length ) { for ( int j = 1 ; i < last && seq . charAt ( j ) == input [ i ] ; i ++ , j ++ ) ; if ( i == last ) return offset - pos ; } } return - 1 ; } ### 76 82 ### <s> if ( offset < length && last <= length ) { </s>
test ### public String html ( ) { StringBuilder accum = new StringBuilder ( ) ; html ( accum ) ; return accum . toString ( ) . trim ( ) ; } ### 19 29 ### <s> return getOutputSettings ( ) . prettyPrint ( ) ? accum . toString ( ) . trim ( ) : accum . toString ( ) ; </s>
test ### public boolean equals ( Object o ) { if ( this == o ) return true ; if ( o == null getClass ( ) != o . getClass ( ) ) return false ; if ( ! super . equals ( o ) ) return false ; Element element = ( Element ) o ; return this == o ; } ### 56 60 ### <s> return tag . equals ( element . tag ) ; </s>
test ### private static < E extends Element > Integer indexInList ( Element search , List < E > elements ) { Validate . notNull ( search ) ; Validate . notNull ( elements ) ; for ( int i = 0 ; i < elements . size ( ) ; i ++ ) { E element = elements . get ( i ) ; if ( element . equals ( search ) ) return i ; } return null ; } ### 63 71 ### <s> if ( element == search ) </s>
test ### void resetInsertionMode ( ) { boolean last = false ; for ( int pos = stack . size ( ) - 1 ; pos >= 0 ; pos -- ) { Element node = stack . get ( pos ) ; if ( pos == 0 ) { last = true ; node = contextElement ; } String name = node . nodeName ( ) ; if ( "select" . equals ( name ) ) { transition ( HtmlTreeBuilderState . InSelect ) ; break ; } else if ( ( "td" . equals ( name ) "td" . equals ( name ) && ! last ) ) { transition ( HtmlTreeBuilderState . InCell ) ; break ; } else if ( "tr" . equals ( name ) ) { transition ( HtmlTreeBuilderState . InRow ) ; break ; } else if ( "tbody" . equals ( name ) "thead" . equals ( name ) "tfoot" . equals ( name ) ) { transition ( HtmlTreeBuilderState . InTableBody ) ; break ; } else if ( "caption" . equals ( name ) ) { transition ( HtmlTreeBuilderState . InCaption ) ; break ; } else if ( "colgroup" . equals ( name ) ) { transition ( HtmlTreeBuilderState . InColumnGroup ) ; break ; } else if ( "table" . equals ( name ) ) { transition ( HtmlTreeBuilderState . InTable ) ; break ; } else if ( "head" . equals ( name ) ) { transition ( HtmlTreeBuilderState . InBody ) ; break ; } else if ( "body" . equals ( name ) ) { transition ( HtmlTreeBuilderState . InBody ) ; break ; } else if ( "frameset" . equals ( name ) ) { transition ( HtmlTreeBuilderState . InFrameset ) ; break ; } else if ( "html" . equals ( name ) ) { transition ( HtmlTreeBuilderState . BeforeHead ) ; break ; } else if ( last ) { transition ( HtmlTreeBuilderState . InBody ) ; break ; } } } ### 85 107 ### <s> } else if ( ( "td" . equals ( name )  "th" . equals ( name ) && ! last ) ) { </s>
test ### static void escape ( StringBuilder accum , String string , Document . OutputSettings out , boolean inAttribute , boolean normaliseWhite , boolean stripLeadingWhite ) { boolean lastWasWhite = false ; boolean reachedNonWhite = false ; final EscapeMode escapeMode = out . escapeMode ( ) ; final CharsetEncoder encoder = out . encoder ( ) ; final CoreCharset coreCharset = CoreCharset . byName ( encoder . charset ( ) . name ( ) ) ; final Map < Character , String > map = escapeMode . getMap ( ) ; final int length = string . length ( ) ; int codePoint ; for ( int offset = 0 ; offset < length ; offset += Character . charCount ( codePoint ) ) { codePoint = string . codePointAt ( offset ) ; if ( normaliseWhite ) { if ( StringUtil . isWhitespace ( codePoint ) ) { if ( ( stripLeadingWhite && ! reachedNonWhite ) lastWasWhite ) continue ; accum . append ( ' ' ) ; lastWasWhite = true ; continue ; } else { lastWasWhite = false ; reachedNonWhite = true ; } } if ( codePoint < Character . MIN_SUPPLEMENTARY_CODE_POINT ) { final char c = ( char ) codePoint ; switch ( c ) { case '&' : accum . append ( "&amp;" ) ; break ; case 0xA0 : if ( escapeMode != EscapeMode . xhtml ) accum . append ( "&nbsp;" ) ; else accum . append ( c ) ; break ; case '<' : if ( ! inAttribute ) accum . append ( "&lt;" ) ; else accum . append ( c ) ; break ; case '>' : if ( ! inAttribute ) accum . append ( "&gt;" ) ; else accum . append ( c ) ; break ; case '"' : if ( inAttribute ) accum . append ( "&quot;" ) ; else accum . append ( c ) ; break ; default : if ( canEncode ( coreCharset , c , encoder ) ) accum . append ( c ) ; else if ( map . containsKey ( c ) ) accum . append ( '&' ) . append ( map . get ( c ) ) . append ( ';' ) ; else accum . append ( "&#x" ) . append ( Integer . toHexString ( codePoint ) ) . append ( ';' ) ; } } else { final String c = new String ( Character . toChars ( codePoint ) ) ; if ( encoder . canEncode ( c ) ) accum . append ( c ) ; else accum . append ( "&#x" ) . append ( Integer . toHexString ( codePoint ) ) . append ( ';' ) ; } } } ### 240 246 ### <s> accum . append ( "&#xa0;" ) ; </s>
test ### static void escape ( StringBuilder accum , String string , Document . OutputSettings out , boolean inAttribute , boolean normaliseWhite , boolean stripLeadingWhite ) { boolean lastWasWhite = false ; boolean reachedNonWhite = false ; final EscapeMode escapeMode = out . escapeMode ( ) ; final CharsetEncoder encoder = out . encoder ( ) ; final CoreCharset coreCharset = CoreCharset . byName ( encoder . charset ( ) . name ( ) ) ; final Map < Character , String > map = escapeMode . getMap ( ) ; final int length = string . length ( ) ; int codePoint ; for ( int offset = 0 ; offset < length ; offset += Character . charCount ( codePoint ) ) { codePoint = string . codePointAt ( offset ) ; if ( normaliseWhite ) { if ( StringUtil . isWhitespace ( codePoint ) ) { if ( ( stripLeadingWhite && ! reachedNonWhite ) lastWasWhite ) continue ; accum . append ( ' ' ) ; lastWasWhite = true ; continue ; } else { lastWasWhite = false ; reachedNonWhite = true ; } } if ( codePoint < Character . MIN_SUPPLEMENTARY_CODE_POINT ) { final char c = ( char ) codePoint ; switch ( c ) { case '&' : accum . append ( "&amp;" ) ; break ; case 0xA0 : if ( escapeMode != EscapeMode . xhtml ) accum . append ( "&nbsp;" ) ; else accum . append ( "&#xa0;" ) ; break ; case '<' : if ( ! inAttribute ) accum . append ( "&lt;" ) ; else accum . append ( c ) ; break ; case '>' : if ( ! inAttribute ) accum . append ( "&gt;" ) ; else accum . append ( c ) ; break ; case '"' : if ( inAttribute ) accum . append ( "&quot;" ) ; else accum . append ( c ) ; break ; default : if ( canEncode ( coreCharset , c , encoder ) ) accum . append ( c ) ; else if ( map . containsKey ( c ) ) accum . append ( '&' ) . append ( map . get ( c ) ) . append ( ';' ) ; else accum . append ( "&#x" ) . append ( Integer . toHexString ( codePoint ) ) . append ( ';' ) ; } } else { final String c = new String ( Character . toChars ( codePoint ) ) ; if ( encoder . canEncode ( c ) ) accum . append ( c ) ; else accum . append ( "&#x" ) . append ( Integer . toHexString ( codePoint ) ) . append ( ';' ) ; } } } ### 252 256 ### <s> if ( ! inAttribute  escapeMode == EscapeMode . xhtml ) </s>
test ### protected void addChildren ( int index , Node ... children ) { Validate . noNullElements ( children ) ; ensureChildNodes ( ) ; for ( int i = children . length - 1 ; i >= 0 ; i -- ) { Node in = children [ i ] ; reparentChild ( in ) ; childNodes . add ( index , in ) ; } reindexChildren ( index ) ; } ### 64 64 ### <s> reindexChildren ( index ) ; </s>
test ### boolean matchesLetter ( ) { if ( isEmpty ( ) ) return false ; char c = input [ pos ] ; return ( c >= 'A' && c <= 'Z' ) ( c >= 'a' && c <= 'z' ) ; } ### 22 41 ### <s> return ( c >= 'A' && c <= 'Z' )  ( c >= 'a' && c <= 'z' )  Character . isLetter ( c ) ; </s>
test ### public void removeIgnoreCase ( String key ) { Validate . notEmpty ( key ) ; if ( attributes == null ) return ; for ( Iterator < String > it = attributes . keySet ( ) . iterator ( ) ; it . hasNext ( ) ; ) { String attrKey = it . next ( ) ; if ( attrKey . equalsIgnoreCase ( key ) ) attributes . remove ( attrKey ) ; } } ### 67 73 ### <s> it . remove ( ) ; </s>
test ### public boolean hasClass ( String className ) { final String classAttr = attributes . get ( "class" ) ; final int len = classAttr . length ( ) ; final int wantLen = className . length ( ) ; if ( len == 0 len < wantLen ) { return false ; } if ( len == wantLen ) { return className . equalsIgnoreCase ( classAttr ) ; } boolean inClass = false ; int start = 0 ; for ( int i = 0 ; i < len ; i ++ ) { if ( Character . isWhitespace ( classAttr . charAt ( i ) ) ) { if ( inClass ) { if ( i - start == wantLen && classAttr . regionMatches ( true , start , className , 0 , wantLen ) ) { return true ; } inClass = false ; } } else { if ( ! inClass ) { inClass = true ; start = i ; } } } if ( inClass && len - start == wantLen ) { return classAttr . regionMatches ( true , start , className , 0 , wantLen ) ; } return false ; } ### 8 18 ### <s> final String classAttr = attributes . getIgnoreCase ( "class" ) ; </s>
test ### boolean anyOtherEndTag ( Token t , HtmlTreeBuilder tb ) { String name = t . asEndTag ( ) . normalName ( ) ; ArrayList < Element > stack = tb . getStack ( ) ; for ( int pos = stack . size ( ) - 1 ; pos >= 0 ; pos -- ) { Element node = stack . get ( pos ) ; if ( node . nodeName ( ) . equals ( name ) ) { tb . generateImpliedEndTags ( name ) ; if ( ! name . equals ( tb . currentElement ( ) . nodeName ( ) ) ) tb . error ( this ) ; tb . popStackToClose ( name ) ; break ; } else { if ( tb . isSpecial ( node ) ) { tb . error ( this ) ; return false ; } } } return true ; } ### 10 22 ### <s> String name = t . asEndTag ( ) . name ( ) ; </s>
test ### private static void handleRawtext ( Token . StartTag startTag , HtmlTreeBuilder tb ) { tb . insert ( startTag ) ; tb . tokeniser . transition ( TokeniserState . Rawtext ) ; tb . markInsertionMode ( ) ; tb . transition ( Text ) ; } ### 14 20 ### <s> tb . tokeniser . transition ( TokeniserState . Rawtext ) ; </s>
test ### private void popStackToClose ( Token . EndTag endTag ) { String elName = endTag . name ( ) ; Element firstFound = null ; for ( int pos = stack . size ( ) - 1 ; pos >= 0 ; pos -- ) { Element next = stack . get ( pos ) ; if ( next . nodeName ( ) . equals ( elName ) ) { firstFound = next ; break ; } } if ( firstFound == null ) return ; for ( int pos = stack . size ( ) - 1 ; pos >= 0 ; pos -- ) { Element next = stack . get ( pos ) ; stack . remove ( pos ) ; if ( next == firstFound ) break ; } } ### 10 18 ### <s> String elName = endTag . normalName ( ) ; </s>
test ### public XmlDeclaration asXmlDeclaration ( ) { String data = getData ( ) ; Document doc = Jsoup . parse ( "<" + data . substring ( 1 , data . length ( ) - 1 ) + ">" , baseUri ( ) , Parser . xmlParser ( ) ) ; XmlDeclaration decl = null ; if ( doc . childNodeSize ( ) > 0 ) { Element el = doc . child ( 0 ) ; decl = new XmlDeclaration ( NodeUtils . parser ( doc ) . settings ( ) . normalizeTag ( el . tagName ( ) ) , data . startsWith ( "!" ) ) ; decl . attributes ( ) . addAll ( el . attributes ( ) ) ; } return decl ; } ### 55 65 ### <s> if ( doc . children ( ) . size ( ) > 0 ) { </s>
test ### public String getValue ( ) { return val ; } ### 6 8 ### <s> return Attributes . checkNotNull ( val ) ; </s>
test ### public final Object computeValue ( EvalContext context ) { return compute ( args [ 0 ] . computeValue ( context ) , args [ 1 ] . computeValue ( context ) ) ? Boolean . TRUE : Boolean . FALSE ; } ### 9 31 ### <s> return compute ( args [ 0 ] . compute ( context ) , args [ 1 ] . compute ( context ) ) </s>
test ### public static Number createNumber ( String str ) throws NumberFormatException { if ( str == null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( "A blank string is not a valid number" ) ; } if ( str . startsWith ( "--" ) ) { return null ; } if ( str . startsWith ( "0x" ) str . startsWith ( "-0x" ) ) { return createInteger ( str ) ; } char lastChar = str . charAt ( str . length ( ) - 1 ) ; String mant ; String dec ; String exp ; int decPos = str . indexOf ( '.' ) ; int expPos = str . indexOf ( 'e' ) + str . indexOf ( 'E' ) + 1 ; if ( decPos > - 1 ) { if ( expPos > - 1 ) { if ( expPos < decPos expPos > str . length ( ) ) { throw new NumberFormatException ( str + " is not a valid number." ) ; } dec = str . substring ( decPos + 1 , expPos ) ; } else { dec = str . substring ( decPos + 1 ) ; } mant = str . substring ( 0 , decPos ) ; } else { if ( expPos > - 1 ) { if ( expPos > str . length ( ) ) { throw new NumberFormatException ( str + " is not a valid number." ) ; } mant = str . substring ( 0 , expPos ) ; } else { mant = str ; } dec = null ; } if ( ! Character . isDigit ( lastChar ) && lastChar != '.' ) { if ( expPos > - 1 && expPos < str . length ( ) - 1 ) { exp = str . substring ( expPos + 1 , str . length ( ) - 1 ) ; } else { exp = null ; } String numeric = str . substring ( 0 , str . length ( ) - 1 ) ; boolean allZeros = isAllZeros ( mant ) && isAllZeros ( exp ) ; switch ( lastChar ) { case 'l' : case 'L' : if ( dec == null && exp == null && ( numeric . charAt ( 0 ) == '-' && isDigits ( numeric . substring ( 1 ) ) isDigits ( numeric ) ) ) { try { return createLong ( numeric ) ; } catch ( NumberFormatException nfe ) { } return createBigInteger ( numeric ) ; } throw new NumberFormatException ( str + " is not a valid number." ) ; case 'f' : case 'F' : try { Float f = NumberUtils . createFloat ( numeric ) ; if ( ! ( f . isInfinite ( ) ( f . floatValue ( ) == 0.0F && ! allZeros ) ) ) { return f ; } } catch ( NumberFormatException nfe ) { } case 'd' : case 'D' : try { Double d = NumberUtils . createDouble ( numeric ) ; if ( ! ( d . isInfinite ( ) ( d . floatValue ( ) == 0.0D && ! allZeros ) ) ) { return d ; } } catch ( NumberFormatException nfe ) { } try { return createBigDecimal ( numeric ) ; } catch ( NumberFormatException e ) { } default : throw new NumberFormatException ( str + " is not a valid number." ) ; } } else { if ( expPos > - 1 && expPos < str . length ( ) - 1 ) { exp = str . substring ( expPos + 1 , str . length ( ) ) ; } else { exp = null ; } if ( dec == null && exp == null ) { try { return createInteger ( str ) ; } catch ( NumberFormatException nfe ) { } try { return createLong ( str ) ; } catch ( NumberFormatException nfe ) { } return createBigInteger ( str ) ; } else { boolean allZeros = isAllZeros ( mant ) && isAllZeros ( exp ) ; try { Float f = createFloat ( str ) ; if ( ! ( f . isInfinite ( ) ( f . floatValue ( ) == 0.0F && ! allZeros ) ) ) { return f ; } } catch ( NumberFormatException nfe ) { } try { Double d = createDouble ( str ) ; if ( ! ( d . isInfinite ( ) ( d . doubleValue ( ) == 0.0D && ! allZeros ) ) ) { return d ; } } catch ( NumberFormatException nfe ) { } return createBigDecimal ( str ) ; } } } ### 61 76 ### <s> if ( str . startsWith ( "0x" )  str . startsWith ( "-0x" )  str . startsWith ( "0X" )  str . startsWith ( "-0X" ) ) { </s>
test ### public static boolean isSameLocalTime ( Calendar cal1 , Calendar cal2 ) { if ( cal1 == null cal2 == null ) { throw new IllegalArgumentException ( "The date must not be null" ) ; } return ( cal1 . get ( Calendar . MILLISECOND ) == cal2 . get ( Calendar . MILLISECOND ) && cal1 . get ( Calendar . SECOND ) == cal2 . get ( Calendar . SECOND ) && cal1 . get ( Calendar . MINUTE ) == cal2 . get ( Calendar . MINUTE ) && cal1 . get ( Calendar . HOUR ) == cal2 . get ( Calendar . HOUR ) && cal1 . get ( Calendar . DAY_OF_YEAR ) == cal2 . get ( Calendar . DAY_OF_YEAR ) && cal1 . get ( Calendar . YEAR ) == cal2 . get ( Calendar . YEAR ) && cal1 . get ( Calendar . ERA ) == cal2 . get ( Calendar . ERA ) && cal1 . getClass ( ) == cal2 . getClass ( ) ) ; } ### 91 108 ### <s> cal1 . get ( Calendar . HOUR_OF_DAY ) == cal2 . get ( Calendar . HOUR_OF_DAY ) && </s>
test ### public static boolean isNumber ( String str ) { if ( StringUtils . isEmpty ( str ) ) { return false ; } char [ ] chars = str . toCharArray ( ) ; int sz = chars . length ; boolean hasExp = false ; boolean hasDecPoint = false ; boolean allowSigns = false ; boolean foundDigit = false ; int start = ( chars [ 0 ] == '-' ) ? 1 : 0 ; if ( sz > start + 1 ) { if ( chars [ start ] == '0' && chars [ start + 1 ] == 'x' ) { int i = start + 2 ; if ( i == sz ) { return false ; } for ( ; i < chars . length ; i ++ ) { if ( ( chars [ i ] < '0' chars [ i ] > '9' ) && ( chars [ i ] < 'a' chars [ i ] > 'f' ) && ( chars [ i ] < 'A' chars [ i ] > 'F' ) ) { return false ; } } return true ; } } sz -- ; int i = start ; while ( i < sz ( i < sz + 1 && allowSigns && ! foundDigit ) ) { if ( chars [ i ] >= '0' && chars [ i ] <= '9' ) { foundDigit = true ; allowSigns = false ; } else if ( chars [ i ] == '.' ) { if ( hasDecPoint hasExp ) { return false ; } hasDecPoint = true ; } else if ( chars [ i ] == 'e' chars [ i ] == 'E' ) { if ( hasExp ) { return false ; } if ( ! foundDigit ) { return false ; } hasExp = true ; allowSigns = true ; } else if ( chars [ i ] == '+' chars [ i ] == '-' ) { if ( ! allowSigns ) { return false ; } allowSigns = false ; foundDigit = false ; } else { return false ; } i ++ ; } if ( i < chars . length ) { if ( chars [ i ] >= '0' && chars [ i ] <= '9' ) { return true ; } if ( chars [ i ] == 'e' chars [ i ] == 'E' ) { return false ; } if ( chars [ i ] == '.' ) { if ( hasDecPoint hasExp ) { return false ; } return foundDigit ; } if ( ! allowSigns && ( chars [ i ] == 'd' chars [ i ] == 'D' chars [ i ] == 'f' chars [ i ] == 'F' ) ) { return foundDigit ; } if ( chars [ i ] == 'l' chars [ i ] == 'L' ) { return foundDigit && ! hasExp ; } return false ; } return ! allowSigns && foundDigit ; } ### 491 496 ### <s> return foundDigit && ! hasExp && ! hasDecPoint ; </s>
test ### public String format ( Date date ) { Calendar c = new GregorianCalendar ( mTimeZone ) ; c . setTime ( date ) ; return applyRules ( c , new StringBuffer ( mMaxLengthEstimate ) ) . toString ( ) ; } ### 8 16 ### <s> Calendar c = new GregorianCalendar ( mTimeZone , mLocale ) ; </s>
test ### static float toJavaVersionInt ( String version ) { return toVersionInt ( toJavaVersionIntArray ( version , JAVA_VERSION_TRIM_SIZE ) ) ; } ### 0 7 ### <s> static int toJavaVersionInt ( String version ) { </s>
test ### public static Class < ? > [ ] toClass ( Object [ ] array ) { if ( array == null ) { return null ; } else if ( array . length == 0 ) { return ArrayUtils . EMPTY_CLASS_ARRAY ; } Class < ? > [ ] classes = new Class [ array . length ] ; for ( int i = 0 ; i < array . length ; i ++ ) { classes [ i ] = array [ i ] . getClass ( ) ; } return classes ; } ### 76 89 ### <s> classes [ i ] = array [ i ] == null ? null : array [ i ] . getClass ( ) ; </s>
test ### public static boolean isAvailableLocale ( Locale locale ) { return cAvailableLocaleSet . contains ( locale ) ; } ### 9 16 ### <s> return availableLocaleList ( ) . contains ( locale ) ; </s>
test ### public StrBuilder appendFixedWidthPadRight ( Object obj , int width , char padChar ) { if ( width > 0 ) { ensureCapacity ( size + width ) ; String str = ( obj == null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen >= width ) { str . getChars ( 0 , strLen , buffer , size ) ; } else { int padLen = width - strLen ; str . getChars ( 0 , strLen , buffer , size ) ; for ( int i = 0 ; i < padLen ; i ++ ) { buffer [ size + strLen + i ] = padChar ; } } size += width ; } return this ; } ### 63 75 ### <s> str . getChars ( 0 , width , buffer , size ) ; </s>
test ### public final void translate ( CharSequence input , Writer out ) throws IOException { if ( out == null ) { throw new IllegalArgumentException ( "The Writer must not be null" ) ; } if ( input == null ) { return ; } int pos = 0 ; int len = input . length ( ) ; while ( pos < len ) { int consumed = translate ( input , pos , out ) ; if ( consumed == 0 ) { char [ ] c = Character . toChars ( Character . codePointAt ( input , pos ) ) ; out . write ( c ) ; pos += c . length ; continue ; } for ( int pt = 0 ; pt < consumed ; pt ++ ) { pos += Character . charCount ( Character . codePointAt ( input , pos ) ) ; } } } ### 134 149 ### <s> pos += Character . charCount ( Character . codePointAt ( input , pt ) ) ; </s>
test ### public int indexOf ( String str , int startIndex ) { startIndex = ( startIndex < 0 ? 0 : startIndex ) ; if ( str == null startIndex >= size ) { return - 1 ; } int strLen = str . length ( ) ; if ( strLen == 1 ) { return indexOf ( str . charAt ( 0 ) , startIndex ) ; } if ( strLen == 0 ) { return startIndex ; } if ( strLen > size ) { return - 1 ; } char [ ] thisBuf = buffer ; int len = thisBuf . length - strLen ; outer : for ( int i = startIndex ; i < len ; i ++ ) { for ( int j = 0 ; j < strLen ; j ++ ) { if ( str . charAt ( j ) != thisBuf [ i + j ] ) { continue outer ; } } return i ; } return - 1 ; } ### 98 106 ### <s> int len = size - strLen + 1 ; </s>
test ### public double getSumSquaredErrors ( ) { return sumYY - sumXY * sumXY / sumXX ; } ### 6 14 ### <s> return Math . max ( 0d , sumYY - sumXY * sumXY / sumXX ) ; </s>
test ### public double density ( final double [ ] vals ) throws DimensionMismatchException { final int dim = getDimension ( ) ; if ( vals . length != dim ) { throw new DimensionMismatchException ( vals . length , dim ) ; } return FastMath . pow ( 2 * FastMath . PI , - dim / 2 ) * FastMath . pow ( covarianceMatrixDeterminant , - 0.5 ) * getExponentTerm ( vals ) ; } ### 42 58 ### <s> return FastMath . pow ( 2 * FastMath . PI , - 0.5 * dim ) * </s>
test ### public double getNumericalMean ( ) { return ( double ) ( getSampleSize ( ) * getNumberOfSuccesses ( ) ) / ( double ) getPopulationSize ( ) ; } ### 6 26 ### <s> return getSampleSize ( ) * ( getNumberOfSuccesses ( ) / ( double ) getPopulationSize ( ) ) ; </s>
test ### public double percentageValue ( ) { return multiply ( 100 ) . doubleValue ( ) ; } ### 6 15 ### <s> return 100 * doubleValue ( ) ; </s>
test ### private double calculateAsymptoticPValue ( final double Umin , final int n1 , final int n2 ) throws ConvergenceException , MaxCountExceededException { final int n1n2prod = n1 * n2 ; final double EU = n1n2prod / 2.0 ; final double VarU = n1n2prod * ( n1 + n2 + 1 ) / 12.0 ; final double z = ( Umin - EU ) / FastMath . sqrt ( VarU ) ; final NormalDistribution standardNormal = new NormalDistribution ( 0 , 1 ) ; return 2 * standardNormal . cumulativeProbability ( z ) ; } ### 21 28 ### <s> final double n1n2prod = n1 * n2 ; </s>
test ### protected void computeGeometricalProperties ( ) { final Vector2D [ ] [ ] v = getVertices ( ) ; if ( v . length == 0 ) { final BSPTree < Euclidean2D > tree = getTree ( false ) ; if ( ( Boolean ) tree . getAttribute ( ) ) { setSize ( Double . POSITIVE_INFINITY ) ; setBarycenter ( Vector2D . NaN ) ; } else { setSize ( 0 ) ; setBarycenter ( new Vector2D ( 0 , 0 ) ) ; } } else if ( v [ 0 ] [ 0 ] == null ) { setSize ( Double . POSITIVE_INFINITY ) ; setBarycenter ( Vector2D . NaN ) ; } else { double sum = 0 ; double sumX = 0 ; double sumY = 0 ; for ( Vector2D [ ] loop : v ) { double x1 = loop [ loop . length - 1 ] . getX ( ) ; double y1 = loop [ loop . length - 1 ] . getY ( ) ; for ( final Vector2D point : loop ) { final double x0 = x1 ; final double y0 = y1 ; x1 = point . getX ( ) ; y1 = point . getY ( ) ; final double factor = x0 * y1 - y0 * x1 ; sum += factor ; sumX += factor * ( x0 + x1 ) ; sumY += factor * ( y0 + y1 ) ; } } if ( sum < 0 ) { setSize ( Double . POSITIVE_INFINITY ) ; setBarycenter ( Vector2D . NaN ) ; } else { setSize ( sum / 2 ) ; setBarycenter ( new Vector2D ( sumX / ( 3 * sum ) , sumY / ( 3 * sum ) ) ) ; } } } ### 39 50 ### <s> if ( tree . getCut ( ) == null && ( Boolean ) tree . getAttribute ( ) ) { </s>
test ### protected void dropPhase1Objective ( ) { if ( getNumObjectiveFunctions ( ) == 1 ) { return ; } List < Integer > columnsToDrop = new ArrayList < Integer > ( ) ; columnsToDrop . add ( 0 ) ; for ( int i = getNumObjectiveFunctions ( ) ; i < getArtificialVariableOffset ( ) ; i ++ ) { final double entry = tableau . getEntry ( 0 , i ) ; if ( Precision . compareTo ( entry , 0d , maxUlps ) > 0 ) { columnsToDrop . add ( i ) ; } } for ( int i = 0 ; i < getNumArtificialVariables ( ) ; i ++ ) { int col = i + getArtificialVariableOffset ( ) ; if ( getBasicRow ( col ) == null ) { columnsToDrop . add ( col ) ; } } double [ ] [ ] matrix = new double [ getHeight ( ) - 1 ] [ getWidth ( ) - columnsToDrop . size ( ) ] ; for ( int i = 1 ; i < getHeight ( ) ; i ++ ) { int col = 0 ; for ( int j = 0 ; j < getWidth ( ) ; j ++ ) { if ( ! columnsToDrop . contains ( j ) ) { matrix [ i - 1 ] [ col ++ ] = tableau . getEntry ( i , j ) ; } } } for ( int i = columnsToDrop . size ( ) - 1 ; i >= 0 ; i -- ) { columnLabels . remove ( ( int ) columnsToDrop . get ( i ) ) ; } this . tableau = new Array2DRowRealMatrix ( matrix ) ; this . numArtificialVariables = 0 ; } ### 71 86 ### <s> if ( Precision . compareTo ( entry , 0d , epsilon ) > 0 ) { </s>
test ### public Iterator < Chromosome > iterator ( ) { return chromosomes . iterator ( ) ; } ### 9 15 ### <s> return getChromosomes ( ) . iterator ( ) ; </s>
test ### public double evaluate ( final double [ ] values , final double [ ] weights , final double mean , final int begin , final int length ) { double var = Double . NaN ; if ( test ( values , weights , begin , length ) ) { if ( length == 1 ) { var = 0.0 ; } else if ( length > 1 ) { double accum = 0.0 ; double dev = 0.0 ; double accum2 = 0.0 ; for ( int i = begin ; i < begin + length ; i ++ ) { dev = values [ i ] - mean ; accum += weights [ i ] * ( dev * dev ) ; accum2 += weights [ i ] * dev ; } double sumWts = 0 ; for ( int i = 0 ; i < weights . length ; i ++ ) { sumWts += weights [ i ] ; } if ( isBiasCorrected ) { var = ( accum - ( accum2 * accum2 / sumWts ) ) / ( sumWts - 1.0 ) ; } else { var = ( accum - ( accum2 * accum2 / sumWts ) ) / sumWts ; } } } return var ; } ### 139 155 ### <s> for ( int i = begin ; i < begin + length ; i ++ ) { </s>
test ### public Complex reciprocal ( ) { if ( isNaN ) { return NaN ; } if ( real == 0.0 && imaginary == 0.0 ) { return NaN ; } if ( isInfinite ) { return ZERO ; } if ( FastMath . abs ( real ) < FastMath . abs ( imaginary ) ) { double q = real / imaginary ; double scale = 1. / ( real * q + imaginary ) ; return createComplex ( scale * q , - scale ) ; } else { double q = imaginary / real ; double scale = 1. / ( imaginary * q + real ) ; return createComplex ( scale , - scale * q ) ; } } ### 26 28 ### <s> return INF ; </s>
test ### private static < T extends Clusterable < T > > List < Cluster < T > > chooseInitialCenters ( final Collection < T > points , final int k , final Random random ) { final List < T > pointSet = new ArrayList < T > ( points ) ; final List < Cluster < T > > resultSet = new ArrayList < Cluster < T > > ( ) ; final T firstPoint = pointSet . remove ( random . nextInt ( pointSet . size ( ) ) ) ; resultSet . add ( new Cluster < T > ( firstPoint ) ) ; final double [ ] dx2 = new double [ pointSet . size ( ) ] ; while ( resultSet . size ( ) < k ) { int sum = 0 ; for ( int i = 0 ; i < pointSet . size ( ) ; i ++ ) { final T p = pointSet . get ( i ) ; final Cluster < T > nearest = getNearestCluster ( resultSet , p ) ; final double d = p . distanceFrom ( nearest . getCenter ( ) ) ; sum += d * d ; dx2 [ i ] = sum ; } final double r = random . nextDouble ( ) * sum ; for ( int i = 0 ; i < dx2 . length ; i ++ ) { if ( dx2 [ i ] >= r ) { final T p = pointSet . remove ( i ) ; resultSet . add ( new Cluster < T > ( p ) ) ; break ; } } } return resultSet ; } ### 133 137 ### <s> double sum = 0 ; </s>
test ### public double [ ] fit ( ) { final double [ ] guess = ( new ParameterGuesser ( getObservations ( ) ) ) . guess ( ) ; return fit ( new Gaussian . Parametric ( ) , guess ) ; } ### 28 40 ### <s> return fit ( guess ) ; </s>
test ### public static float max ( final float a , final float b ) { return ( a <= b ) ? b : ( Float . isNaN ( a + b ) ? Float . NaN : b ) ; } ### 14 39 ### <s> return ( a <= b ) ? b : ( Float . isNaN ( a + b ) ? Float . NaN : a ) ; </s>
test ### public static boolean equals ( double x , double y ) { return ( Double . isNaN ( x ) && Double . isNaN ( y ) ) x == y ; } ### 12 31 ### <s> return equals ( x , y , 1 ) ; </s>
test ### public RealMatrix getCorrelationPValues ( ) throws MathException { TDistribution tDistribution = new TDistributionImpl ( nObs - 2 ) ; int nVars = correlationMatrix . getColumnDimension ( ) ; double [ ] [ ] out = new double [ nVars ] [ nVars ] ; for ( int i = 0 ; i < nVars ; i ++ ) { for ( int j = 0 ; j < nVars ; j ++ ) { if ( i == j ) { out [ i ] [ j ] = 0d ; } else { double r = correlationMatrix . getEntry ( i , j ) ; double t = Math . abs ( r * Math . sqrt ( ( nObs - 2 ) / ( 1 - r * r ) ) ) ; out [ i ] [ j ] = 2 * ( 1 - tDistribution . cumulativeProbability ( t ) ) ; } } } return new BlockRealMatrix ( out ) ; } ### 135 155 ### <s> out [ i ] [ j ] = 2 * tDistribution . cumulativeProbability ( - t ) ; </s>
test ### public double solve ( final UnivariateRealFunction f , double min , double max , double initial ) throws MaxIterationsExceededException , FunctionEvaluationException { return solve ( min , max ) ; } ### 22 29 ### <s> return solve ( f , min , max ) ; </s>
test ### public double getPct ( Object v ) { return getCumPct ( ( Comparable < ? > ) v ) ; } ### 8 19 ### <s> return getPct ( ( Comparable < ? > ) v ) ; </s>
test ### private boolean flipIfWarranted ( final int n , final int step ) { if ( 1.5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i += 4 ) { for ( int k = 0 ; k < 4 ; k += step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ; work [ j - k ] = tmp ; } j -= 4 ; } return true ; } return false ; } ### 36 44 ### <s> int j = 4 * ( n - 1 ) ; </s>
test ### private Integer getPivotRow ( final int col , final SimplexTableau tableau ) { double minRatio = Double . MAX_VALUE ; Integer minRatioPos = null ; for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getHeight ( ) ; i ++ ) { final double rhs = tableau . getEntry ( i , tableau . getWidth ( ) - 1 ) ; final double entry = tableau . getEntry ( i , col ) ; if ( MathUtils . compareTo ( entry , 0 , epsilon ) >= 0 ) { final double ratio = rhs / entry ; if ( ratio < minRatio ) { minRatio = ratio ; minRatioPos = i ; } } } return minRatioPos ; } ### 80 95 ### <s> if ( MathUtils . compareTo ( entry , 0 , epsilon ) > 0 ) { </s>
test ### public static double [ ] bracket ( UnivariateRealFunction function , double initial , double lowerBound , double upperBound , int maximumIterations ) throws ConvergenceException , FunctionEvaluationException { if ( function == null ) { throw MathRuntimeException . createIllegalArgumentException ( "function is null" ) ; } if ( maximumIterations <= 0 ) { throw MathRuntimeException . createIllegalArgumentException ( "bad value for maximum iterations number: {0}" , maximumIterations ) ; } if ( initial < lowerBound initial > upperBound lowerBound >= upperBound ) { throw MathRuntimeException . createIllegalArgumentException ( "invalid bracketing parameters: lower bound={0}, initial={1}, upper bound={2}" , lowerBound , initial , upperBound ) ; } double a = initial ; double b = initial ; double fa ; double fb ; int numIterations = 0 ; do { a = Math . max ( a - 1.0 , lowerBound ) ; b = Math . min ( b + 1.0 , upperBound ) ; fa = function . value ( a ) ; fb = function . value ( b ) ; numIterations ++ ; } while ( ( fa * fb > 0.0 ) && ( numIterations < maximumIterations ) && ( ( a > lowerBound ) ( b < upperBound ) ) ) ; if ( fa * fb >= 0.0 ) { throw new ConvergenceException ( "number of iterations={0}, maximum iterations={1}, " + "initial={2}, lower bound={3}, upper bound={4}, final a value={5}, " + "final b value={6}, f(a)={7}, f(b)={8}" , numIterations , maximumIterations , initial , lowerBound , upperBound , a , b , fa , fb ) ; } return new double [ ] { a , b } ; } ### 205 213 ### <s> if ( fa * fb > 0.0 ) { </s>
test ### public static int gcd ( int u , int v ) { if ( u * v == 0 ) { return ( Math . abs ( u ) + Math . abs ( v ) ) ; } if ( u > 0 ) { u = - u ; } if ( v > 0 ) { v = - v ; } int k = 0 ; while ( ( u & 1 ) == 0 && ( v & 1 ) == 0 && k < 31 ) { u /= 2 ; v /= 2 ; k ++ ; } if ( k == 31 ) { throw new ArithmeticException ( "overflow: gcd is 2^31" ) ; } int t = ( ( u & 1 ) == 1 ) ? v : - ( u / 2 ) ; do { while ( ( t & 1 ) == 0 ) { t /= 2 ; } if ( t > 0 ) { u = - t ; } else { v = t ; } t = ( v - u ) / 2 ; } while ( t != 0 ) ; return - u * ( 1 << k ) ; } ### 12 20 ### <s> if ( ( u == 0 )  ( v == 0 ) ) { </s>
test ### public boolean equals ( Object other ) { boolean ret ; if ( this == other ) { ret = true ; } else if ( other == null ) { ret = false ; } else { try { Complex rhs = ( Complex ) other ; if ( rhs . isNaN ( ) ) { ret = this . isNaN ( ) ; } else { ret = ( Double . doubleToRawLongBits ( real ) == Double . doubleToRawLongBits ( rhs . getReal ( ) ) ) && ( Double . doubleToRawLongBits ( imaginary ) == Double . doubleToRawLongBits ( rhs . getImaginary ( ) ) ) ; } } catch ( ClassCastException ex ) { ret = false ; } } return ret ; } ### 68 109 ### <s> ret = ( real == rhs . real ) && ( imaginary == rhs . imaginary ) ; </s>
test ### public Object answer ( InvocationOnMock invocation ) { if ( methodsGuru . isToString ( invocation . getMethod ( ) ) ) { Object mock = invocation . getMock ( ) ; MockName name = mockUtil . getMockName ( mock ) ; if ( name . isDefault ( ) ) { return "Mock for " + mockUtil . getMockSettings ( mock ) . getTypeToMock ( ) . getSimpleName ( ) + ", hashCode: " + mock . hashCode ( ) ; } else { return name . toString ( ) ; } } else if ( methodsGuru . isCompareToMethod ( invocation . getMethod ( ) ) ) { return 1 ; } Class < ? > returnType = invocation . getMethod ( ) . getReturnType ( ) ; return returnValueFor ( returnType ) ; } ### 107 109 ### <s> return invocation . getMock ( ) == invocation . getArguments ( ) [ 0 ] ? 0 : 1 ; </s>
test ### public void describeTo ( Description description ) { description . appendText ( "same(" ) ; appendQuoting ( description ) ; description . appendText ( wanted . toString ( ) ) ; appendQuoting ( description ) ; description . appendText ( ")" ) ; } ### 20 30 ### <s> description . appendText ( wanted == null ? "null" : wanted . toString ( ) ) ; </s>
test ### public void captureArgumentsFrom ( Invocation i ) { int k = 0 ; for ( Matcher m : matchers ) { if ( m instanceof CapturesArguments ) { ( ( CapturesArguments ) m ) . captureFrom ( i . getArguments ( ) [ k ] ) ; } k ++ ; } } ### 21 27 ### <s> if ( m instanceof CapturesArguments && i . getArguments ( ) . length > k ) { </s>
test ### private boolean toStringEquals ( Matcher m , Object arg ) { return StringDescription . toString ( m ) . equals ( arg . toString ( ) ) ; } ### 11 27 ### <s> return StringDescription . toString ( m ) . equals ( arg == null ? "null" : arg . toString ( ) ) ; </s>
test ### public void verify ( VerificationData data ) { AssertionError error = null ; timer . start ( ) ; while ( timer . isCounting ( ) ) { try { delegate . verify ( data ) ; if ( returnOnSuccess ) { return ; } else { error = null ; } } catch ( MockitoAssertionError e ) { error = handleVerifyException ( e ) ; } catch ( org . mockito . exceptions . verification . junit . ArgumentsAreDifferent e ) { error = handleVerifyException ( e ) ; } } if ( error != null ) { throw error ; } } ### 67 82 ### <s> catch ( AssertionError e ) { </s>
test ### protected void registerTypeVariablesOn ( Type classType ) { if ( ! ( classType instanceof ParameterizedType ) ) { return ; } ParameterizedType parameterizedType = ( ParameterizedType ) classType ; TypeVariable [ ] typeParameters = ( ( Class < ? > ) parameterizedType . getRawType ( ) ) . getTypeParameters ( ) ; Type [ ] actualTypeArguments = parameterizedType . getActualTypeArguments ( ) ; for ( int i = 0 ; i < actualTypeArguments . length ; i ++ ) { TypeVariable typeParameter = typeParameters [ i ] ; Type actualTypeArgument = actualTypeArguments [ i ] ; if ( actualTypeArgument instanceof WildcardType ) { contextualActualTypeParameters . put ( typeParameter , boundsOf ( ( WildcardType ) actualTypeArgument ) ) ; } else { contextualActualTypeParameters . put ( typeParameter , actualTypeArgument ) ; } } } ### 118 120 ### <s> } else if ( typeParameter != actualTypeArgument ) { </s>
test ### public int parseInto ( ReadWritableInstant instant , String text , int position ) { DateTimeParser parser = requireParser ( ) ; if ( instant == null ) { throw new IllegalArgumentException ( "Instant must not be null" ) ; } long instantMillis = instant . getMillis ( ) ; Chronology chrono = instant . getChronology ( ) ; long instantLocal = instantMillis + chrono . getZone ( ) . getOffset ( instantMillis ) ; chrono = selectChronology ( chrono ) ; DateTimeParserBucket bucket = new DateTimeParserBucket ( instantLocal , chrono , iLocale , iPivotYear , iDefaultYear ) ; int newPos = parser . parseInto ( bucket , text , position ) ; instant . setMillis ( bucket . computeMillis ( false , text ) ) ; if ( iOffsetParsed && bucket . getOffsetInteger ( ) != null ) { int parsedOffset = bucket . getOffsetInteger ( ) ; DateTimeZone parsedZone = DateTimeZone . forOffsetMillis ( parsedOffset ) ; chrono = chrono . withZone ( parsedZone ) ; } else if ( bucket . getZone ( ) != null ) { chrono = chrono . withZone ( bucket . getZone ( ) ) ; } instant . setChronology ( chrono ) ; if ( iZone != null ) { instant . setZone ( iZone ) ; } return newPos ; } ### 87 97 ### <s> instantLocal , chrono , iLocale , iPivotYear , chrono . year ( ) . get ( instantLocal ) ) ; </s>
test ### public int getOffsetFromLocal ( long instantLocal ) { final int offsetLocal = getOffset ( instantLocal ) ; final long instantAdjusted = instantLocal - offsetLocal ; final int offsetAdjusted = getOffset ( instantAdjusted ) ; if ( offsetLocal != offsetAdjusted ) { if ( ( offsetLocal - offsetAdjusted ) < 0 ) { long nextLocal = nextTransition ( instantAdjusted ) ; long nextAdjusted = nextTransition ( instantLocal - offsetAdjusted ) ; if ( nextLocal != nextAdjusted ) { return offsetLocal ; } } } else if ( offsetLocal > 0 ) { long prev = previousTransition ( instantAdjusted ) ; if ( prev < instantAdjusted ) { int offsetPrev = getOffset ( prev ) ; int diff = offsetPrev - offsetLocal ; if ( instantAdjusted - prev <= diff ) { return offsetPrev ; } } } return offsetAdjusted ; } ### 82 90 ### <s> } else if ( offsetLocal >= 0 ) { </s>
test ### public Partial with ( DateTimeFieldType fieldType , int value ) { if ( fieldType == null ) { throw new IllegalArgumentException ( "The field type must not be null" ) ; } int index = indexOf ( fieldType ) ; if ( index == - 1 ) { DateTimeFieldType [ ] newTypes = new DateTimeFieldType [ iTypes . length + 1 ] ; int [ ] newValues = new int [ newTypes . length ] ; int i = 0 ; DurationField unitField = fieldType . getDurationType ( ) . getField ( iChronology ) ; if ( unitField . isSupported ( ) ) { for ( ; i < iTypes . length ; i ++ ) { DateTimeFieldType loopType = iTypes [ i ] ; DurationField loopUnitField = loopType . getDurationType ( ) . getField ( iChronology ) ; if ( loopUnitField . isSupported ( ) ) { int compare = unitField . compareTo ( loopUnitField ) ; if ( compare > 0 ) { break ; } else if ( compare == 0 ) { DurationField rangeField = fieldType . getRangeDurationType ( ) . getField ( iChronology ) ; DurationField loopRangeField = loopType . getRangeDurationType ( ) . getField ( iChronology ) ; if ( rangeField . compareTo ( loopRangeField ) > 0 ) { break ; } } } } } System . arraycopy ( iTypes , 0 , newTypes , 0 , i ) ; System . arraycopy ( iValues , 0 , newValues , 0 , i ) ; newTypes [ i ] = fieldType ; newValues [ i ] = value ; System . arraycopy ( iTypes , i , newTypes , i + 1 , newTypes . length - i - 1 ) ; System . arraycopy ( iValues , i , newValues , i + 1 , newValues . length - i - 1 ) ; Partial newPartial = new Partial ( iChronology , newTypes , newValues ) ; iChronology . validate ( newPartial , newValues ) ; return newPartial ; } if ( value == getValue ( index ) ) { return this ; } int [ ] newValues = getValues ( ) ; newValues = getField ( index ) . set ( this , index , newValues , value ) ; return new Partial ( this , newValues ) ; } ### 313 325 ### <s> Partial newPartial = new Partial ( newTypes , newValues , iChronology ) ; </s>
test ### public int parseInto ( ReadWritableInstant instant , String text , int position ) { DateTimeParser parser = requireParser ( ) ; if ( instant == null ) { throw new IllegalArgumentException ( "Instant must not be null" ) ; } long instantMillis = instant . getMillis ( ) ; Chronology chrono = instant . getChronology ( ) ; long instantLocal = instantMillis + chrono . getZone ( ) . getOffset ( instantMillis ) ; chrono = selectChronology ( chrono ) ; int defaultYear = chrono . year ( ) . get ( instantLocal ) ; DateTimeParserBucket bucket = new DateTimeParserBucket ( instantLocal , chrono , iLocale , iPivotYear , defaultYear ) ; int newPos = parser . parseInto ( bucket , text , position ) ; instant . setMillis ( bucket . computeMillis ( false , text ) ) ; if ( iOffsetParsed && bucket . getOffsetInteger ( ) != null ) { int parsedOffset = bucket . getOffsetInteger ( ) ; DateTimeZone parsedZone = DateTimeZone . forOffsetMillis ( parsedOffset ) ; chrono = chrono . withZone ( parsedZone ) ; } else if ( bucket . getZone ( ) != null ) { chrono = chrono . withZone ( bucket . getZone ( ) ) ; } instant . setChronology ( chrono ) ; if ( iZone != null ) { instant . setZone ( iZone ) ; } return newPos ; } ### 58 73 ### <s> int defaultYear = DateTimeUtils . getChronology ( chrono ) . year ( ) . get ( instantMillis ) ; </s>
